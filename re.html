<!DOCTYPE html><html lang='en'><head><title>[re]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='re'><h1 ><a class='secnum' style='min-width:73pt'>28</a> Regular expressions library <a class='abbr_ref' href='./#re'>[re]</a></h1><p ><span class='indexparent'><a class='index' id='regular_expression'></a></span></p><div id='general'><h2 ><a class='secnum' href='#general' style='min-width:88pt'>28.1</a> General <a class='abbr_ref' href='re.general'>[re.general]</a></h2><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p >This Clause describes components that C++ programs may use to
perform operations involving regular expression matching and
searching.</p></div><div class='para' id='general-2'><div class='marginalizedparent'><a class='marginalized' href='#general-2'>2</a></div><p >The following subclauses describe a basic regular expression class template and its
traits that can handle char-like (<a href='strings.general'>[strings.general]</a>) template arguments,
two specializations of this class template that handle sequences of <span class='texttt'>char</span> and <span class='texttt'>wchar_t</span>,
a class template that holds the
result of a regular expression match, a series of algorithms that allow a character
sequence to be operated upon by a regular expression,
and two iterator types for
enumerating regular expression matches, as described in Table <a href='#tab:re.lib.summary'>[tab:re.lib.summary]</a>.</p><div class='numberedTable' id='tab:re.lib.summary'>Table <a href='#tab:re.lib.summary'>122</a> — Regular expressions library summary<br><table ><tr class='rowsep'><td colspan='2' class='center'><b>Subclause</b></td><td class='left'>	<b>Header(s)</b>	</td></tr><tr class='capsep'><td class='left'> 


<a href='re.def'>[re.def]</a>        </td><td class='left'>   Definitions                 </td><td class='left'>                       </td></tr><tr ><td class='left'>
<a href='re.req'>[re.req]</a>        </td><td class='left'>   Requirements                </td><td class='left'>                       </td></tr><tr class='rowsep'><td class='left'> 
<a href='re.const'>[re.const]</a>      </td><td class='left'>   Constants                   </td><td class='left'>                       </td></tr><tr ><td class='left'>
<a href='re.badexp'>[re.badexp]</a>     </td><td class='left'>   Exception type              </td><td class='left'>                       </td></tr><tr ><td class='left'>
<a href='re.traits'>[re.traits]</a>     </td><td class='left'>   Traits                      </td><td class='left'>                       </td></tr><tr ><td class='left'>
<a href='re.regex'>[re.regex]</a>      </td><td class='left'>   Regular expression template </td><td class='left'>   <span class='texttt'>&lt;regex&gt;</span>     </td></tr><tr ><td class='left'>
<a href='re.submatch'>[re.submatch]</a>   </td><td class='left'>   Submatches                  </td><td class='left'>                       </td></tr><tr ><td class='left'>
<a href='re.results'>[re.results]</a>    </td><td class='left'>   Match results               </td><td class='left'>                       </td></tr><tr ><td class='left'>
<a href='re.alg'>[re.alg]</a>        </td><td class='left'>   Algorithms                  </td><td class='left'>                       </td></tr><tr ><td class='left'>
<a href='re.iter'>[re.iter]</a>       </td><td class='left'>   Iterators                   </td><td class='left'>                       </td></tr><tr class='rowsep'><td class='left'> 
<a href='re.grammar'>[re.grammar]</a>    </td><td class='left'>   Grammar                     </td><td class='left'>                       </td></tr></table></div></div></div><div id='def'><h2 ><a class='secnum' href='#def' style='min-width:88pt'>28.2</a> Definitions <a class='abbr_ref' href='re.def'>[re.def]</a></h2><div class='para' id='def-1'><div class='marginalizedparent'><a class='marginalized' href='#def-1'>1</a></div><p >The following definitions shall apply to this Clause:</p><p ><span class='indexparent'><a class='index' id='collating_element'></a></span><span class='indexparent'><a class='index' id='locale'></a></span></p></div><div id='defns.regex.collating.element'><h3 ><a class='secnum' href='#defns.regex.collating.element' style='min-width:103pt'>28.2.1</a> collating element <a class='abbr_ref' href='defns.regex.collating.element'>[defns.regex.collating.element]</a></h3><p >a sequence of one or more characters within the
current locale that collate as if they were a single character.</p><p ><span class='indexparent'><a class='index' id='finite_state_machine'></a></span></p></div><div id='defns.regex.finite.state.machine'><h3 ><a class='secnum' href='#defns.regex.finite.state.machine' style='min-width:103pt'>28.2.2</a> finite state machine <a class='abbr_ref' href='defns.regex.finite.state.machine'>[defns.regex.finite.state.machine]</a></h3><p >an unspecified data structure that is used to
represent a regular expression, and which permits efficient matches
against the regular expression to be obtained.</p><p ><span class='indexparent'><a class='index' id='format_specifier'></a></span></p></div><div id='defns.regex.format.specifier'><h3 ><a class='secnum' href='#defns.regex.format.specifier' style='min-width:103pt'>28.2.3</a> format specifier <a class='abbr_ref' href='defns.regex.format.specifier'>[defns.regex.format.specifier]</a></h3><p >a sequence of one or more characters that is to be
replaced with some part of a regular expression match.</p><p ><span class='indexparent'><a class='index' id='matched'></a></span><span class='indexparent'><a class='index' id='regular_expression,matched'></a></span></p></div><div id='defns.regex.matched'><h3 ><a class='secnum' href='#defns.regex.matched' style='min-width:103pt'>28.2.4</a> matched <a class='abbr_ref' href='defns.regex.matched'>[defns.regex.matched]</a></h3><p >a sequence of zero or more characters is matched by
a regular expression when the characters in the sequence
correspond to a sequence of characters defined by the pattern.</p><p ><span class='indexparent'><a class='index' id='primary_equivalence_class'></a></span><span class='indexparent'><a class='index' id='locale'></a></span></p></div><div id='defns.regex.primary.equivalence.class'><h3 ><a class='secnum' href='#defns.regex.primary.equivalence.class' style='min-width:103pt'>28.2.5</a> primary equivalence class <a class='abbr_ref' href='defns.regex.primary.equivalence.class'>[defns.regex.primary.equivalence.class]</a></h3><p >a set of one or more characters which
share the same primary sort key: that is the sort key weighting that
depends only upon character shape, and not accents, case, or
locale specific tailorings.</p></div><div id='defns.regex.regular.expression'><h3 ><a class='secnum' href='#defns.regex.regular.expression' style='min-width:103pt'>28.2.6</a> regular expression <a class='abbr_ref' href='defns.regex.regular.expression'>[defns.regex.regular.expression]</a></h3><p >a pattern that selects specific strings
from a set of character strings.</p><p ><span class='indexparent'><a class='index' id='sub-expression'></a></span></p></div><div id='defns.regex.subexpression'><h3 ><a class='secnum' href='#defns.regex.subexpression' style='min-width:103pt'>28.2.7</a> sub-expression <a class='abbr_ref' href='defns.regex.subexpression'>[defns.regex.subexpression]</a></h3><p >a subset of a regular expression that has
been marked by parenthesis.</p></div></div><div id='req'><h2 ><a class='secnum' href='#req' style='min-width:88pt'>28.3</a> Requirements <a class='abbr_ref' href='re.req'>[re.req]</a></h2><div class='para' id='req-1'><div class='marginalizedparent'><a class='marginalized' href='#req-1'>1</a></div><p >This subclause defines requirements on classes representing regular
expression traits.  [&nbsp;<i>Note:</i> The class template
<span class='texttt'>regex_traits</span>, defined in Clause <a href='re.traits'>[re.traits]</a>,
satisfies these requirements.  <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='req-2'><div class='marginalizedparent'><a class='marginalized' href='#req-2'>2</a></div><p >The class template <span class='texttt'>basic_regex</span>, defined in
Clause <a href='re.regex'>[re.regex]</a>, needs a set of related types and
functions to complete the definition of its semantics. These types
and functions are provided as a set of member <i ><a href='dcl.typedef#nt:typedef-name'>typedef-names</a></i> and functions
in the template parameter <span class='texttt'>traits</span> used by the <span class='texttt'>basic_regex</span> class
template. This subclause defines the semantics of these
members.</p></div><div class='para' id='req-3'><div class='marginalizedparent'><a class='marginalized' href='#req-3'>3</a></div><p >To specialize class template <span class='texttt'>basic_regex</span> for a character
container <span class='texttt'>CharT</span> and its related regular
expression traits class <span class='texttt'>Traits</span>, use <span class='texttt'>basic_regex&lt;CharT, Traits&gt;</span>.</p></div><div class='para' id='req-4'><div class='marginalizedparent'><a class='marginalized' href='#req-4'>4</a></div><p ><span class='indexparent'><a class='index' id='regular_expression_traits,requirements'></a></span><span class='indexparent'><a class='index' id='requirements,regular_expression_traits'></a></span><span class='indexparent'><a class='index' id='regular_expression,requirements'></a></span><span class='indexparent'><a class='index' id='locale'></a></span>In Table <a href='#tab:re:RegexpTraits'>[tab:re:RegexpTraits]</a> <span class='texttt'>X</span> denotes a traits class
defining types and functions for the character container
type <span class='texttt'>charT</span>; <span class='texttt'>u</span> is an object of
type <span class='texttt'>X</span>; <span class='texttt'>v</span> is an object of type <span class='texttt'>const
X</span>; <span class='texttt'>p</span> is a value of type <span class='texttt'>const charT*</span>; <span class='texttt'>I1</span>
and <span class='texttt'>I2</span> are input iterators (<a href='input.iterators'>[input.iterators]</a>);
<span class='texttt'>F1</span> and <span class='texttt'>F2</span> are forward iterators (<a href='forward.iterators'>[forward.iterators]</a>);
<span class='texttt'>c</span> is a value of type <span class='texttt'>const charT</span>;
<span class='texttt'>s</span> is an object of type <span class='texttt'>X::string_type</span>;
<span class='texttt'>cs</span> is an object of type <span class='texttt'>const X::string_type</span>;
<span class='texttt'>b</span> is a value of  type <span class='texttt'>bool</span>;
<span class='texttt'>I</span> is a value of type <span class='texttt'>int</span>;
<span class='texttt'>cl</span> is an object of type <span class='texttt'>X::char_class_type</span>,
and <span class='texttt'>loc</span> is an object of type <span class='texttt'>X::locale_type</span>.</p><div class='numberedTable' id='tab:re:RegexpTraits'>Table <a href='#tab:re:RegexpTraits'>123</a> — Regular expression traits class requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Assertion/note pre-/post-condition </b></td></tr><tr class='capsep'><td class='left'> 

<span class='texttt'>X::char_type</span>
  </td><td class='left'> <span class='texttt'>charT</span>
  </td><td class='left'> The character container type used in the implementation of class
    template <span class='texttt'>basic_regex</span>.
  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::string_type</span>
  </td><td class='left'> <span class='texttt'>basic_string&lt;charT&gt;</span>
  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::locale_type</span>
  </td><td class='left'> A copy constructible type
  </td><td class='left'> A type that represents the locale used by the traits class. <span class='indexparent'><a class='index' id='locale'></a></span>
 </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::char_class_type</span>
 </td><td class='left'> A bitmask type (<a href='bitmask.types'>[bitmask.types]</a>).
 </td><td class='left'> A bitmask type representing a particular character classification.
   <span class='indexparent'><a class='index' id='regular_expression_traits,char_class_type'></a></span>   <span class='indexparent'><a class='index' id='char_class_type,regular_expression_traits'></a></span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X::length(p)</span>
  </td><td class='left'> <span class='texttt'>size_t</span>
  </td><td class='left'> Yields the smallest <span class='texttt'>i</span> such that <span class='texttt'>p[i] == 0</span>. Complexity is
    linear in <span class='texttt'>i</span> .
  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>v.translate(c)</span>
  </td><td class='left'> <span class='texttt'>X::char_type</span>
  </td><td class='left'> Returns a character such that for any character <span class='texttt'>d</span> that is to
    be considered equivalent to <span class='texttt'>c</span> then <span class='texttt'>v.translate(c) == v.translate(d)</span>.
   <span class='indexparent'><a class='index' id='regular_expression_traits,translate'></a></span>   <span class='indexparent'><a class='index' id='translate,regular_expression_traits'></a></span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>v.translate_nocase(c)</span>
  </td><td class='left'> <span class='texttt'>X::char_type</span>
  </td><td class='left'> For all characters <span class='texttt'>C</span> that are to be considered equivalent
    to <span class='texttt'>c</span> when comparisons are to be performed without regard to
  case, then <span class='texttt'>v.translate_nocase(c) == v.translate_nocase(C)</span>.
   <span class='indexparent'><a class='index' id='regular_expression_traits,translate_nocase'></a></span>   <span class='indexparent'><a class='index' id='translate_nocase,regular_expression_traits'></a></span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>v.transform(F1, F2)</span>
  </td><td class='left'> <span class='texttt'>X::string_type</span>
  </td><td class='left'> Returns a sort key for the character sequence designated by the
    iterator range <span class='texttt'>[F1, F2)</span> such that if the character sequence
  <span class='texttt'>[G1, G2)</span> sorts before the character sequence <span class='texttt'>[H1, H2)</span>
  then <span class='texttt'>v.transform(G1, G2) &lt; v.transform(H1, H2)</span>.
   <span class='indexparent'><a class='index' id='regular_expression_traits,transform'></a></span>   <span class='indexparent'><a class='index' id='transform,regular_expression_traits'></a></span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>v.transform_primary(F1, F2)</span>
  </td><td class='left'> <span class='texttt'>X::string_type</span>
  </td><td class='left'> Returns a sort key for the character sequence designated by the
    iterator range <span class='texttt'>[F1, F2)</span> such that if the character sequence
  <span class='texttt'>[G1, G2)</span> sorts before the character sequence <span class='texttt'>[H1, H2)</span>
  when character case is not considered
  then <span class='texttt'>v.transform_primary(G1, G2) &lt; v.transform_primary(H1, H2)</span>.
   <span class='indexparent'><a class='index' id='regular_expression_traits,transform_primary'></a></span>   <span class='indexparent'><a class='index' id='transform_primary,regular_expression_traits'></a></span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>v.lookup_collatename(F1, F2)</span>
  </td><td class='left'> <span class='texttt'>X::string_type</span>
  </td><td class='left'> Returns a sequence of characters that represents the collating element
    consisting of the character sequence designated by the iterator range
  <span class='texttt'>[F1, F2)</span>. Returns an empty string if the character sequence is not
  a valid collating element.
   <span class='indexparent'><a class='index' id='regular_expression_traits,lookup_collatename'></a></span>   <span class='indexparent'><a class='index' id='lookup_collatename,regular_expression_traits'></a></span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>v.lookup_classname(F1, F2, b)</span>
  </td><td class='left'> <span class='texttt'>X::char_class_type</span>
  </td><td class='left'>  Converts the character sequence designated by the iterator range
   <span class='texttt'>[F1, F2)</span> into a value of a bitmask type that can
    subsequently be passed to <span class='texttt'>isctype</span>. Values returned from
    <span class='texttt'>lookup_classname</span> can be bitwise or'ed together; the
    resulting value represents membership in either of the
    corresponding character classes.
  If <span class='texttt'>b</span> is <span class='texttt'>true</span>, the returned bitmask is suitable for
  matching characters without regard to their case.
  Returns 0 if the character
    sequence is not the name of a character class recognized by
    <span class='texttt'>X</span>.  The value returned shall be independent of the case of
    the characters in the sequence.
  <span class='indexparent'><a class='index' id='regular_expression_traits,lookup_classname'></a></span>   <span class='indexparent'><a class='index' id='lookup_classname,regular_expression_traits'></a></span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>v.isctype(c, cl)</span>
  </td><td class='left'> <span class='texttt'>bool</span>
  </td><td class='left'> Returns <span class='texttt'>true</span> if character <span class='texttt'>c</span> is a member of
    one of the character classes designated by <span class='texttt'>cl</span>,
    <span class='texttt'>false</span> otherwise.
   <span class='indexparent'><a class='index' id='regular_expression_traits,isctype'></a></span>   <span class='indexparent'><a class='index' id='isctype,regular_expression_traits'></a></span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>v.value(c, I)</span>
  </td><td class='left'> <span class='texttt'>int</span>
  </td><td class='left'> Returns the value represented by the digit <i>c</i> in base
    <i>I</i> if the character <i>c</i> is a valid digit in base <i>I</i>;
  otherwise returns <span class='texttt'>-1</span>. [&nbsp;<i>Note:</i> The value of <i>I</i> will only
  be 8, 10, or 16. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>u.imbue(loc)</span>
  </td><td class='left'> <span class='texttt'>X::locale_type</span>
  </td><td class='left'> Imbues <span class='texttt'>u</span> with the locale <span class='texttt'>loc</span> and returns the previous locale
    used by <span class='texttt'>u</span> if any. <span class='indexparent'><a class='index' id='locale'></a></span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>v.getloc()</span>
  </td><td class='left'> <span class='texttt'>X::locale_type</span>
  </td><td class='left'> Returns the current locale used by <span class='texttt'>v</span>, if any. <span class='indexparent'><a class='index' id='locale'></a></span>  </td></tr></table></div></div><div class='para' id='req-5'><div class='marginalizedparent'><a class='marginalized' href='#req-5'>5</a></div><p >[&nbsp;<i>Note:</i>
Class template <span class='texttt'>regex_traits</span> satisfies the requirements for a
regular expression traits class when it is specialized for
<span class='texttt'>char</span> or <span class='texttt'>wchar_t</span>.  This class template is described in
the header <span class='texttt'>&lt;regex&gt;</span>, and is described in Clause <a href='re.traits'>[re.traits]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='syn'><h2 ><a class='secnum' href='#syn' style='min-width:88pt'>28.4</a> Header <span class='texttt'>&lt;regex&gt;</span> synopsis <a class='abbr_ref' href='re.syn'>[re.syn]</a></h2><p ><span class='indexparent'><a class='index' id='regex'></a></span><span class='indexparent'><a class='index' id='basic_regex'></a></span><span class='indexparent'><a class='index' id='regex'></a></span><span class='indexparent'><a class='index' id='wregex'></a></span></p><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// <a href='re.const'>[re.const]</a>, regex constants
</span>  namespace regex_constants {
    using syntax_option_type = <i>T1</i>;
    using match_flag_type = <i>T2</i>;
    using error_type = <i>T3</i>;
  }

  <span class='comment'>// <a href='re.badexp'>[re.badexp]</a>, class regex_error
</span>  class regex_error;

  <span class='comment'>// <a href='re.traits'>[re.traits]</a>, class template regex_traits
</span>  template &lt;class charT&gt; struct regex_traits;

  <span class='comment'>// <a href='re.regex'>[re.regex]</a>, class template basic_regex
</span>  template &lt;class charT, class traits = regex_traits&lt;charT&gt;&gt; class basic_regex;

  using regex  = basic_regex&lt;char&gt;;
  using wregex = basic_regex&lt;wchar_t&gt;;

  <span class='comment'>// <a href='re.regex.swap'>[re.regex.swap]</a>, basic_regex swap
</span>  template &lt;class charT, class traits&gt;
    void swap(basic_regex&lt;charT, traits&gt;&amp; e1, basic_regex&lt;charT, traits&gt;&amp; e2);

  <span class='comment'>// <a href='re.submatch'>[re.submatch]</a>, class template sub_match
</span>  template &lt;class BidirectionalIterator&gt;
    class sub_match;

  using csub_match  = sub_match&lt;const char*&gt;;
  using wcsub_match = sub_match&lt;const wchar_t*&gt;;
  using ssub_match  = sub_match&lt;string::const_iterator&gt;;
  using wssub_match = sub_match&lt;wstring::const_iterator&gt;;

  <span class='comment'>// <a href='re.submatch.op'>[re.submatch.op]</a>, sub_match non-member operators
</span>  template &lt;class BiIter&gt;
    bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);

  template &lt;class BiIter, class ST, class SA&gt;
    bool operator==(
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt;
    bool operator!=(
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt;
    bool operator&lt;(
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt;
    bool operator&gt;(
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt;
    bool operator&gt;=(
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt;
    bool operator&lt;=(
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);

  template &lt;class BiIter, class ST, class SA&gt;
    bool operator==(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt;
    bool operator!=(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt;
    bool operator&lt;(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt;
    bool operator&gt;(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt;
    bool operator&gt;=(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt;
    bool operator&lt;=(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);

  template &lt;class BiIter&gt;
    bool operator==(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator!=(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&lt;(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                   const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&gt;(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                   const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&gt;=(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&lt;=(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);

  template &lt;class BiIter&gt;
    bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
  template &lt;class BiIter&gt;
    bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
  template &lt;class BiIter&gt;
    bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                   const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
  template &lt;class BiIter&gt;
    bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                   const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
  template &lt;class BiIter&gt;
    bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
  template &lt;class BiIter&gt;
    bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);

  template &lt;class BiIter&gt;
    bool operator==(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator!=(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&lt;(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                   const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&gt;(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                   const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&gt;=(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&lt;=(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                    const sub_match&lt;BiIter&gt;&amp; rhs);

  template &lt;class BiIter&gt;
    bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                   const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                   const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);

  template &lt;class charT, class ST, class BiIter&gt;
    basic_ostream&lt;charT, ST&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, ST&gt;&amp; os, const sub_match&lt;BiIter&gt;&amp; m);

  <span class='comment'>// <a href='re.results'>[re.results]</a>, class template match_results
</span>  template &lt;class BidirectionalIterator,
            class Allocator = allocator&lt;sub_match&lt;BidirectionalIterator&gt;&gt;&gt;
    class match_results;

  using cmatch  = match_results&lt;const char*&gt;;
  using wcmatch = match_results&lt;const wchar_t*&gt;;
  using smatch  = match_results&lt;string::const_iterator&gt;;
  using wsmatch = match_results&lt;wstring::const_iterator&gt;;

  <span class='comment'>// match_results comparisons
</span>  template &lt;class BidirectionalIterator, class Allocator&gt;
    bool operator==(const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
                    const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
  template &lt;class BidirectionalIterator, class Allocator&gt;
    bool operator!=(const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
                    const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);

  <span class='comment'>// <a href='re.results.swap'>[re.results.swap]</a>, match_results swap
</span>  template &lt;class BidirectionalIterator, class Allocator&gt;
    void swap(match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
              match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);

  <span class='comment'>// <a href='re.alg.match'>[re.alg.match]</a>, function template regex_match
</span>  template &lt;class BidirectionalIterator, class Allocator,
      class charT, class traits&gt;
    bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                     match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);
  template &lt;class BidirectionalIterator, class charT, class traits&gt;
  bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                   const basic_regex&lt;charT, traits&gt;&amp; e,
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default);
  template &lt;class charT, class Allocator, class traits&gt;
    bool regex_match(const charT* str, match_results&lt;const charT*, Allocator&gt;&amp; m,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);
  template &lt;class ST, class SA, class Allocator, class charT, class traits&gt;
    bool regex_match(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                     match_results&lt;
                       typename basic_string&lt;charT, ST, SA&gt;::const_iterator,
                       Allocator&gt;&amp; m,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);
  template &lt;class ST, class SA, class Allocator, class charT, class traits&gt;
    bool regex_match(const basic_string&lt;charT, ST, SA&gt;&amp;&amp;,
                     match_results&lt;
                       typename basic_string&lt;charT, ST, SA&gt;::const_iterator,
                       Allocator&gt;&amp;,
                     const basic_regex&lt;charT, traits&gt;&amp;,
                     regex_constants::match_flag_type =
                       regex_constants::match_default) = delete;
  template &lt;class charT, class traits&gt;
    bool regex_match(const charT* str,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);
  template &lt;class ST, class SA, class charT, class traits&gt;
    bool regex_match(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);

  <span class='comment'>// <a href='re.alg.search'>[re.alg.search]</a>, function template regex_search
</span>  template &lt;class BidirectionalIterator, class Allocator,
      class charT, class traits&gt;
    bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                      match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template &lt;class BidirectionalIterator, class charT, class traits&gt;
    bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template &lt;class charT, class Allocator, class traits&gt;
    bool regex_search(const charT* str,
                      match_results&lt;const charT*, Allocator&gt;&amp; m,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template &lt;class charT, class traits&gt;
    bool regex_search(const charT* str,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template &lt;class ST, class SA, class charT, class traits&gt;
    bool regex_search(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template &lt;class ST, class SA, class Allocator, class charT, class traits&gt;
    bool regex_search(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                      match_results&lt;
                        typename basic_string&lt;charT, ST, SA&gt;::const_iterator,
                        Allocator&gt;&amp; m,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template &lt;class ST, class SA, class Allocator, class charT, class traits&gt;
    bool regex_search(const basic_string&lt;charT, ST, SA&gt;&amp;&amp;,
                      match_results&lt;
                        typename basic_string&lt;charT, ST, SA&gt;::const_iterator,
                        Allocator&gt;&amp;,
                      const basic_regex&lt;charT, traits&gt;&amp;,
                      regex_constants::match_flag_type =
                        regex_constants::match_default) = delete;

  <span class='comment'>// <a href='re.alg.replace'>[re.alg.replace]</a>, function template regex_replace
</span>  template &lt;class OutputIterator, class BidirectionalIterator,
      class traits, class charT, class ST, class SA&gt;
    OutputIterator
    regex_replace(OutputIterator out,
                  BidirectionalIterator first, BidirectionalIterator last,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  const basic_string&lt;charT, ST, SA&gt;&amp; fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
  template &lt;class OutputIterator, class BidirectionalIterator,
      class traits, class charT&gt;
    OutputIterator
    regex_replace(OutputIterator out,
                  BidirectionalIterator first, BidirectionalIterator last,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  const charT* fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
  template &lt;class traits, class charT, class ST, class SA,
      class FST, class FSA&gt;
    basic_string&lt;charT, ST, SA&gt;
    regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  const basic_string&lt;charT, FST, FSA&gt;&amp; fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
  template &lt;class traits, class charT, class ST, class SA&gt;
    basic_string&lt;charT, ST, SA&gt;
    regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  const charT* fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
  template &lt;class traits, class charT, class ST, class SA&gt;
    basic_string&lt;charT&gt;
    regex_replace(const charT* s,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  const basic_string&lt;charT, ST, SA&gt;&amp; fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
  template &lt;class traits, class charT&gt;
    basic_string&lt;charT&gt;
    regex_replace(const charT* s,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  const charT* fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);

  <span class='comment'>// <a href='re.regiter'>[re.regiter]</a>, class template regex_iterator
</span>  template &lt;class BidirectionalIterator,
            class charT = typename iterator_traits&lt;
              BidirectionalIterator&gt;::value_type,
            class traits = regex_traits&lt;charT&gt;&gt;
    class regex_iterator;

  using cregex_iterator  = regex_iterator&lt;const char*&gt;;
  using wcregex_iterator = regex_iterator&lt;const wchar_t*&gt;;
  using sregex_iterator  = regex_iterator&lt;string::const_iterator&gt;;
  using wsregex_iterator = regex_iterator&lt;wstring::const_iterator&gt;;

  <span class='comment'>// <a href='re.tokiter'>[re.tokiter]</a>, class template regex_token_iterator
</span>  template &lt;class BidirectionalIterator,
            class charT = typename iterator_traits&lt;
              BidirectionalIterator&gt;::value_type,
            class traits = regex_traits&lt;charT&gt;&gt;
    class regex_token_iterator;

  using cregex_token_iterator  = regex_token_iterator&lt;const char*&gt;;
  using wcregex_token_iterator = regex_token_iterator&lt;const wchar_t*&gt;;
  using sregex_token_iterator  = regex_token_iterator&lt;string::const_iterator&gt;;
  using wsregex_token_iterator = regex_token_iterator&lt;wstring::const_iterator&gt;;

  namespace pmr {
    template &lt;class BidirectionalIterator&gt;
      using match_results =
        std::match_results&lt;BidirectionalIterator,
                           polymorphic_allocator&lt;sub_match&lt;BidirectionalIterator&gt;&gt;&gt;;

    using cmatch  = match_results&lt;const char*&gt;;
    using wcmatch = match_results&lt;const wchar_t*&gt;;
    using smatch  = match_results&lt;string::const_iterator&gt;;
    using wsmatch = match_results&lt;wstring::const_iterator&gt;;
  }
}
</pre></div><div id='const'><h2 ><a class='secnum' href='#const' style='min-width:88pt'>28.5</a> Namespace <span class='texttt'>std::regex_constants</span> <a class='abbr_ref' href='re.const'>[re.const]</a></h2><div class='para' id='const-1'><div class='marginalizedparent'><a class='marginalized' href='#const-1'>1</a></div><p ><span class='indexparent'><a class='index' id='regex_constants'></a></span>The namespace <span class='texttt'>std::regex_constants</span> holds
symbolic constants used by the regular expression library.  This
namespace provides three types, <span class='texttt'>syntax_option_type</span>,
<span class='texttt'>match_flag_type</span>, and <span class='texttt'>error_type</span>, along with several
constants of these types.</p></div><div id='synopt'><h3 ><a class='secnum' href='#synopt' style='min-width:103pt'>28.5.1</a> Bitmask type <span class='texttt'>syntax_option_type</span> <a class='abbr_ref' href='re.synopt'>[re.synopt]</a></h3><p ><span class='indexparent'><a class='index' id='syntax_option_type'></a></span><span class='indexparent'><a class='index' id='regex_constants,syntax_option_type'></a></span></p><pre class='codeblock'>
namespace std::regex_constants {
  using syntax_option_type = <i>T1</i>;
  constexpr syntax_option_type icase = <i><span class='texttt'>unspecified</span></i>;
  constexpr syntax_option_type nosubs = <i><span class='texttt'>unspecified</span></i>;
  constexpr syntax_option_type optimize = <i><span class='texttt'>unspecified</span></i>;
  constexpr syntax_option_type collate = <i><span class='texttt'>unspecified</span></i>;
  constexpr syntax_option_type ECMAScript = <i><span class='texttt'>unspecified</span></i>;
  constexpr syntax_option_type basic = <i><span class='texttt'>unspecified</span></i>;
  constexpr syntax_option_type extended = <i><span class='texttt'>unspecified</span></i>;
  constexpr syntax_option_type awk = <i><span class='texttt'>unspecified</span></i>;
  constexpr syntax_option_type grep = <i><span class='texttt'>unspecified</span></i>;
  constexpr syntax_option_type egrep = <i><span class='texttt'>unspecified</span></i>;
  constexpr syntax_option_type multiline = <i><span class='texttt'>unspecified</span></i>;
}
</pre><div class='para' id='synopt-1'><div class='marginalizedparent'><a class='marginalized' href='#synopt-1'>1</a></div><p ><span class='indexparent'><a class='index' id='syntax_option_type'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,icase'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,nosubs'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,optimize'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,collate'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,ECMAScript'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,basic'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,extended'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,awk'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,grep'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,egrep'></a></span>The type <span class='texttt'>syntax_option_type</span> is an <span class='indexparent'><a class='index' id='type_of_syntax_option_type'></a></span>implementation-defined bitmask
type (<a href='bitmask.types'>[bitmask.types]</a>). Setting its elements has the effects listed in
Table <a href='#tab:re:syntaxoption'>[tab:re:syntaxoption]</a>.  A valid value of type
<span class='texttt'>syntax_option_type</span> shall have at most one of the grammar elements
<span class='texttt'>ECMAScript</span>, <span class='texttt'>basic</span>, <span class='texttt'>extended</span>, <span class='texttt'>awk</span>, <span class='texttt'>grep</span>, <span class='texttt'>egrep</span>, set.
If no grammar element is set, the default grammar is <span class='texttt'>ECMAScript</span>.</p><div class='numberedTable' id='tab:re:syntaxoption'>Table <a href='#tab:re:syntaxoption'>124</a> — <span class='texttt'>syntax_option_type</span> effects<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Element</b></td><td colspan='1' class='center'><b>Effect(s) if set</b></td></tr><tr class='capsep'><td class='left'> 



<span class='texttt'>icase</span> </td><td class='justify'>
Specifies that matching of regular expressions against a character
container sequence shall be performed without regard to case.
<span class='indexparent'><a class='index' id='syntax_option_type,icase'></a></span></td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>nosubs</span> </td><td class='justify'>
Specifies that no sub-expressions shall be considered to be marked, so that
when a regular expression is matched against a
character container sequence, no sub-expression matches shall be
stored in the supplied <span class='texttt'>match_results</span> structure.
<span class='indexparent'><a class='index' id='syntax_option_type,nosubs'></a></span></td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>optimize</span> </td><td class='justify'>
Specifies that the regular expression engine should pay more attention
to the speed with which regular expressions are matched, and less to
the speed with which regular expression objects are
constructed. Otherwise it has no detectable effect on the program
output.
<span class='indexparent'><a class='index' id='syntax_option_type,optimize'></a></span></td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>collate</span> </td><td class='justify'>
Specifies that character ranges of the form <span class='texttt'>"[a-b]"</span> shall be locale
sensitive.
<span class='indexparent'><a class='index' id='syntax_option_type,collate'></a></span><span class='indexparent'><a class='index' id='locale'></a></span></td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>ECMAScript</span> </td><td class='justify'>
Specifies that the grammar recognized by the regular expression engine
shall be that used by ECMAScript in ECMA-262, as modified in <a href='re.grammar'>[re.grammar]</a>.
<span class='indexparent'><a class='index' id='ECMAScript'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,ECMAScript'></a></span></td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>basic</span> </td><td class='justify'>
Specifies that the grammar recognized by the regular expression engine
shall be that used by basic regular expressions in POSIX, Base Definitions and
Headers, Section 9, Regular Expressions.
<span class='indexparent'><a class='index' id='POSIX,regular_expressions'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,basic'></a></span></td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>extended</span> </td><td class='justify'>
Specifies that the grammar recognized by the regular expression engine
shall be that used by extended regular expressions in POSIX, Base Definitions and
Headers, Section 9, Regular Expressions.
<span class='indexparent'><a class='index' id='POSIX,extended_regular_expressions'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,extended'></a></span></td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>awk</span> </td><td class='justify'>
Specifies that the grammar recognized by the regular expression engine
shall be that used by the utility awk in POSIX.
<span class='indexparent'><a class='index' id='awk'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,awk'></a></span></td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>grep</span> </td><td class='justify'>
Specifies that the grammar recognized by the regular expression engine
shall be that used by the utility grep in POSIX.
<span class='indexparent'><a class='index' id='grep'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,grep'></a></span></td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>egrep</span> </td><td class='justify'>
Specifies that the grammar recognized by the regular expression engine
shall be that used by the utility grep when given the -E
option in POSIX.
<span class='indexparent'><a class='index' id='egrep'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,egrep'></a></span></td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>multiline</span> </td><td class='justify'>
Specifies that <span class='texttt'>^</span> shall match the beginning of a line and
<span class='texttt'>&#36;</span> shall match the end of a line,
if the <span class='texttt'>ECMAScript</span> engine is selected.
<span class='indexparent'><a class='index' id='multiline'></a></span><span class='indexparent'><a class='index' id='syntax_option_type,multiline'></a></span></td></tr></table></div></div></div><div id='matchflag'><h3 ><a class='secnum' href='#matchflag' style='min-width:103pt'>28.5.2</a> Bitmask type <span class='texttt'>match_flag_type</span> <a class='abbr_ref' href='re.matchflag'>[re.matchflag]</a></h3><p ><span class='indexparent'><a class='index' id='match_flag_type'></a></span><span class='indexparent'><a class='index' id='regex_constants,match_flag_type'></a></span><span class='indexparent'><a class='index' id='match_default'></a></span><span class='indexparent'><a class='index' id='match_not_bol'></a></span><span class='indexparent'><a class='index' id='match_not_eol'></a></span><span class='indexparent'><a class='index' id='match_not_bow'></a></span><span class='indexparent'><a class='index' id='match_not_eow'></a></span><span class='indexparent'><a class='index' id='match_any'></a></span><span class='indexparent'><a class='index' id='match_not_null'></a></span><span class='indexparent'><a class='index' id='match_continuous'></a></span><span class='indexparent'><a class='index' id='match_prev_avail'></a></span><span class='indexparent'><a class='index' id='format_default'></a></span><span class='indexparent'><a class='index' id='format_sed'></a></span><span class='indexparent'><a class='index' id='format_no_copy'></a></span><span class='indexparent'><a class='index' id='format_first_only'></a></span></p><pre class='codeblock'>
namespace std::regex_constants {
  using match_flag_type = <i>T2</i>;
  constexpr match_flag_type match_default = {};
  constexpr match_flag_type match_not_bol = <i><span class='texttt'>unspecified</span></i>;
  constexpr match_flag_type match_not_eol = <i><span class='texttt'>unspecified</span></i>;
  constexpr match_flag_type match_not_bow = <i><span class='texttt'>unspecified</span></i>;
  constexpr match_flag_type match_not_eow = <i><span class='texttt'>unspecified</span></i>;
  constexpr match_flag_type match_any = <i><span class='texttt'>unspecified</span></i>;
  constexpr match_flag_type match_not_null = <i><span class='texttt'>unspecified</span></i>;
  constexpr match_flag_type match_continuous = <i><span class='texttt'>unspecified</span></i>;
  constexpr match_flag_type match_prev_avail = <i><span class='texttt'>unspecified</span></i>;
  constexpr match_flag_type format_default = {};
  constexpr match_flag_type format_sed = <i><span class='texttt'>unspecified</span></i>;
  constexpr match_flag_type format_no_copy = <i><span class='texttt'>unspecified</span></i>;
  constexpr match_flag_type format_first_only = <i><span class='texttt'>unspecified</span></i>;
}
</pre><div class='para' id='matchflag-1'><div class='marginalizedparent'><a class='marginalized' href='#matchflag-1'>1</a></div><p ><span class='indexparent'><a class='index' id='match_flag_type'></a></span>The type <span class='texttt'>match_flag_type</span> is an
<span class='indexparent'><a class='index' id='type_of_regex_constants::match_flag_type'></a></span>implementation-defined bitmask type (<a href='bitmask.types'>[bitmask.types]</a>).
The constants of that type, except for <span class='texttt'>match_default</span> and
<span class='texttt'>format_default</span>, are bitmask elements. The <span class='texttt'>match_default</span> and
<span class='texttt'>format_default</span> constants are empty bitmasks.
Matching a regular expression against a sequence of characters
<span class='texttt'>[first, last)</span> proceeds according to the rules of the grammar specified for the regular
expression object, modified according to the effects listed in Table <a href='#tab:re:matchflag'>[tab:re:matchflag]</a> for
any bitmask elements set.</p><div class='numberedTable' id='tab:re:matchflag'>Table <a href='#tab:re:matchflag'>125</a> — <span class='texttt'>regex_constants::match_flag_type</span> effects when obtaining a match against a
     character container sequence <span class='texttt'>[first, last)</span>.<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Element</b></td><td colspan='1' class='center'><b>Effect(s) if set</b></td></tr><tr class='capsep'><td class='left'> 
 



<span class='indexparent'><a class='index' id='match_not_bol'></a></span><span class='texttt'>match_not_bol</span> </td><td class='justify'>
The first character in the sequence <span class='texttt'>[first, last)</span> shall be treated
as though it is not at the beginning of a line, so the character
<code >^</code> in the regular expression shall not match <span class='texttt'>[first, first)</span>.
</td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='match_not_eol'></a></span><span class='texttt'>match_not_eol</span> </td><td class='justify'>
The last character in the sequence <span class='texttt'>[first, last)</span> shall be treated
as though it is not at the end of a line, so the character
<code >"&#36;"</code> in the regular expression shall not match <span class='texttt'>[last, last)</span>.
</td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='match_not_bow'></a></span><span class='texttt'>match_not_bow</span> </td><td class='justify'>
The expression <code >"\\b"</code> shall not match the
sub-sequence <span class='texttt'>[first, first)</span>.
</td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='match_not_eow'></a></span><span class='texttt'>match_not_eow</span> </td><td class='justify'>
The expression <code >"\\b"</code> shall not match the
sub-sequence <span class='texttt'>[last, last)</span>.
</td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='match_any'></a></span><span class='texttt'>match_any</span> </td><td class='justify'>
If more than one match is possible then any match is an
acceptable result.
</td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='match_not_null'></a></span><span class='texttt'>match_not_null</span> </td><td class='justify'>
The expression shall not match an empty
sequence.
</td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='match_continuous'></a></span><span class='texttt'>match_continuous</span> </td><td class='justify'>
The expression shall only match a sub-sequence that begins at
<span class='texttt'>first</span>.
</td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='match_prev_avail'></a></span><span class='texttt'>match_prev_avail</span> </td><td class='justify'>
<code >--first</code> is a valid iterator position. When this flag is
set the flags match_not_bol and match_not_bow shall be ignored by the
regular expression algorithms <a href='re.alg'>[re.alg]</a> and iterators <a href='re.iter'>[re.iter]</a>.
</td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='format_default'></a></span><span class='texttt'>format_default</span> </td><td class='justify'>
When a regular expression match is to be replaced by a
new string, the new string shall be constructed using the rules used by
the ECMAScript replace function in ECMA-262,
part 15.5.4.11 String.prototype.replace. In
addition, during search and replace operations all non-overlapping
occurrences of the regular expression shall be located and replaced, and
sections of the input that did not match the expression shall be copied
unchanged to the output string.
</td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='format_sed'></a></span><span class='texttt'>format_sed</span> </td><td class='justify'>
When a regular expression match is to be replaced by a
new string, the new string shall be constructed using the rules used by
the sed utility in POSIX.
</td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='format_no_copy'></a></span><span class='texttt'>format_no_copy</span> </td><td class='justify'>
During a search and replace operation, sections of
the character container sequence being searched that do not match the
regular expression shall not be copied to the output string. </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='format_first_only'></a></span><span class='texttt'>format_first_only</span> </td><td class='justify'>
When specified during a search and replace operation, only the
first occurrence of the regular expression shall be replaced.
</td></tr></table></div></div></div><div id='err'><h3 ><a class='secnum' href='#err' style='min-width:103pt'>28.5.3</a> Implementation-defined <span class='texttt'>error_type</span> <a class='abbr_ref' href='re.err'>[re.err]</a></h3><p ><span class='indexparent'><a class='index' id='error_type'></a></span><span class='indexparent'><a class='index' id='regex_constants,error_type'></a></span></p><pre class='codeblock'>
namespace std::regex_constants {
  using error_type = <i>T3</i>;
  constexpr error_type error_collate = <i><span class='texttt'>unspecified</span></i>;
  constexpr error_type error_ctype = <i><span class='texttt'>unspecified</span></i>;
  constexpr error_type error_escape = <i><span class='texttt'>unspecified</span></i>;
  constexpr error_type error_backref = <i><span class='texttt'>unspecified</span></i>;
  constexpr error_type error_brack = <i><span class='texttt'>unspecified</span></i>;
  constexpr error_type error_paren = <i><span class='texttt'>unspecified</span></i>;
  constexpr error_type error_brace = <i><span class='texttt'>unspecified</span></i>;
  constexpr error_type error_badbrace = <i><span class='texttt'>unspecified</span></i>;
  constexpr error_type error_range = <i><span class='texttt'>unspecified</span></i>;
  constexpr error_type error_space = <i><span class='texttt'>unspecified</span></i>;
  constexpr error_type error_badrepeat = <i><span class='texttt'>unspecified</span></i>;
  constexpr error_type error_complexity = <i><span class='texttt'>unspecified</span></i>;
  constexpr error_type error_stack = <i><span class='texttt'>unspecified</span></i>;
}
</pre><div class='para' id='err-1'><div class='marginalizedparent'><a class='marginalized' href='#err-1'>1</a></div><p ><span class='indexparent'><a class='index' id='error_type'></a></span><span class='indexparent'><a class='index' id='regex_constants,error_type'></a></span>The type <span class='texttt'>error_type</span> is an <span class='indexparent'><a class='index' id='type_of_regex_constants::error_type'></a></span>implementation-defined enumerated type (<a href='enumerated.types'>[enumerated.types]</a>).
Values of type <span class='texttt'>error_type</span> represent the error
conditions described in Table <a href='#tab:re:errortype'>[tab:re:errortype]</a>:</p><div class='numberedTable' id='tab:re:errortype'>Table <a href='#tab:re:errortype'>126</a> — <span class='texttt'>error_type</span> values in the C locale<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Value</b></td><td colspan='1' class='center'><b>Error condition</b></td></tr><tr class='capsep'><td class='left'> 
 


<span class='texttt'>error_collate</span>
</td><td class='justify'>
The expression contained an invalid collating element name.  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>error_ctype</span>
</td><td class='justify'>
The expression contained an invalid character class name.  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>error_escape</span>
</td><td class='justify'>
The expression contained an invalid escaped character, or a trailing
escape.  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>error_backref</span>
</td><td class='justify'>
The expression contained an invalid back reference.  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>error_brack</span>
</td><td class='justify'>
The expression contained mismatched <code >[</code> and <code >]</code>.  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>error_paren</span>
</td><td class='justify'>
The expression contained mismatched <code >(</code> and <code >)</code>.  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>error_brace</span>
</td><td class='justify'>
The expression contained mismatched <code >{</code> and <code >}</code> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>error_badbrace</span>
</td><td class='justify'>
The expression contained an invalid range in a <code >{}</code> expression.  </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>error_range</span>
</td><td class='justify'>
The expression contained an invalid character range, such as
<code >[b-a]</code> in most encodings.  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>error_space</span>
</td><td class='justify'>
There was insufficient memory to convert the expression into a finite
state machine.  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>error_badrepeat</span>
</td><td class='justify'>
One of <code >*?+{</code> was not preceded by a valid regular expression.  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>error_complexity</span>
</td><td class='justify'>
The complexity of an attempted match against a regular expression
exceeded a pre-set level.  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>error_stack</span>
</td><td class='justify'>
There was insufficient memory to determine whether the regular
expression could match the specified character sequence.  </td></tr></table></div></div></div></div><div id='badexp'><h2 ><a class='secnum' href='#badexp' style='min-width:88pt'>28.6</a> Class <span class='texttt'>regex_error</span> <a class='abbr_ref' href='re.badexp'>[re.badexp]</a></h2><p ><span class='indexparent'><a class='index' id='regex_error'></a></span></p><pre class='codeblock'>
class regex_error : public runtime_error {
  public:
    explicit regex_error(regex_constants::error_type ecode);
    regex_constants::error_type code() const;
};
</pre><div class='para' id='badexp-1'><div class='marginalizedparent'><a class='marginalized' href='#badexp-1'>1</a></div><p >The class <span class='texttt'>regex_error</span> defines the type of objects thrown as
exceptions to report errors from the regular expression library.</p><p ><span class='indexparent'><a class='index' id='regex_error,constructor'></a></span><code class='itemdecl'>
regex_error(regex_constants::error_type ecode);
</code></p></div><div class='itemdescr'></div><div class='para' id='badexp-2'><div class='marginalizedparent'><a class='marginalized' href='#badexp-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an object of class <span class='texttt'>regex_error</span>.</p></div></div><div class='para' id='badexp-3'><div class='marginalizedparent'><a class='marginalized' href='#badexp-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>ecode == code()</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='error_type'></a></span><span class='indexparent'><a class='index' id='regex_constants,error_type'></a></span><code class='itemdecl'>
regex_constants::error_type code() const;
</code></p><div class='itemdescr'></div><div class='para' id='badexp-4'><div class='marginalizedparent'><a class='marginalized' href='#badexp-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> The error code that was passed to the constructor.
</p></div></div></div><div id='traits'><h2 ><a class='secnum' href='#traits' style='min-width:88pt'>28.7</a> Class template <span class='texttt'>regex_traits</span> <a class='abbr_ref' href='re.traits'>[re.traits]</a></h2><p ><span class='indexparent'><a class='index' id='regex_traits'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  struct regex_traits {
  public:
     using char_type       = charT;
     using string_type     = basic_string&lt;char_type&gt;;
     using locale_type     = locale;
     using char_class_type = <i> bitmask_type</i>;

     regex_traits();
     static size_t length(const char_type* p);
     charT translate(charT c) const;
     charT translate_nocase(charT c) const;
     template &lt;class ForwardIterator&gt;
       string_type transform(ForwardIterator first, ForwardIterator last) const;
     template &lt;class ForwardIterator&gt;
       string_type transform_primary(
         ForwardIterator first, ForwardIterator last) const;
     template &lt;class ForwardIterator&gt;
       string_type lookup_collatename(
         ForwardIterator first, ForwardIterator last) const;
     template &lt;class ForwardIterator&gt;
       char_class_type lookup_classname(
         ForwardIterator first, ForwardIterator last, bool icase = false) const;
     bool isctype(charT c, char_class_type f) const;
     int value(charT ch, int radix) const;
     locale_type imbue(locale_type l);
     locale_type getloc() const;
  };
}
</pre><div class='para' id='traits-1'><div class='marginalizedparent'><a class='marginalized' href='#traits-1'>1</a></div><p ><span class='indexparent'><a class='index' id='regular_expression_traits,requirements'></a></span><span class='indexparent'><a class='index' id='requirements,regular_expression_traits'></a></span><span class='indexparent'><a class='index' id='regex_traits,specializations'></a></span>The specializations <span class='texttt'>regex_traits&lt;char&gt;</span> and
<span class='texttt'>regex_traits&lt;wchar_t&gt;</span> shall be valid and shall satisfy the
requirements for a regular expression traits class (<a href='re.req'>[re.req]</a>).</p><p ><span class='indexparent'><a class='index' id='regex_traits,char_class_type'></a></span><span class='indexparent'><a class='index' id='char_class_type,regex_traits'></a></span><code class='itemdecl'>
using char_class_type = <i>bitmask_type</i>;
</code></p></div><div class='itemdescr'></div><div class='para' id='traits-2'><div class='marginalizedparent'><a class='marginalized' href='#traits-2'>2</a></div><div class='itemdescr'><p >The type <span class='texttt'>char_class_type</span> is used to represent a character
classification and is capable of holding an implementation specific
set returned by <span class='texttt'>lookup_classname</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='length,regex_traits'></a></span><span class='indexparent'><a class='index' id='regex_traits,length'></a></span><code class='itemdecl'>
static size_t length(const char_type* p);
</code></p><div class='itemdescr'></div><div class='para' id='traits-3'><div class='marginalizedparent'><a class='marginalized' href='#traits-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>char_traits&lt;charT&gt;::length(p)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_traits,translate'></a></span><span class='indexparent'><a class='index' id='translate,regex_traits'></a></span><code class='itemdecl'>
charT translate(charT c) const;
</code></p><div class='itemdescr'></div><div class='para' id='traits-4'><div class='marginalizedparent'><a class='marginalized' href='#traits-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>c</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_traits,translate_nocase'></a></span><span class='indexparent'><a class='index' id='translate_nocase,regex_traits'></a></span><code class='itemdecl'>
charT translate_nocase(charT c) const;
</code></p><div class='itemdescr'></div><div class='para' id='traits-5'><div class='marginalizedparent'><a class='marginalized' href='#traits-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>use_facet&lt;ctype&lt;charT&gt;&gt;(getloc()).tolower(c)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_traits,transform'></a></span><span class='indexparent'><a class='index' id='transform,regex_traits'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator&gt;
  string_type transform(ForwardIterator first, ForwardIterator last) const;
</code></p><div class='itemdescr'></div><div class='para' id='traits-6'><div class='marginalizedparent'><a class='marginalized' href='#traits-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
As if by:
</p><pre class='codeblock'>
string_type str(first, last);
return use_facet&lt;collate&lt;charT&gt;&gt;(
  getloc()).transform(&amp;*str.begin(), &amp;*str.begin() + str.length());
</pre></div></div><p ><span class='indexparent'><a class='index' id='regex_traits,transform_primary'></a></span><span class='indexparent'><a class='index' id='transform_primary,regex_traits'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator&gt;
  string_type transform_primary(ForwardIterator first, ForwardIterator last) const;
</code></p><div class='itemdescr'></div><div class='para' id='traits-7'><div class='marginalizedparent'><a class='marginalized' href='#traits-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>typeid(use_facet&lt;collate&lt;charT&gt;&gt;)
== typeid(collate_byname&lt;charT&gt;)</span>
and the form of the sort key returned
by <span class='texttt'>collate_byname&lt;charT&gt; :: transform(first, last)</span> is known and
can be converted into a primary sort key then returns that key,
otherwise returns an empty string.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_traits,lookup_collatename'></a></span><span class='indexparent'><a class='index' id='lookup_collatename,regex_traits'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator&gt;
  string_type lookup_collatename(ForwardIterator first, ForwardIterator last) const;
</code></p><div class='itemdescr'></div><div class='para' id='traits-8'><div class='marginalizedparent'><a class='marginalized' href='#traits-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> a sequence of one or more characters that
represents the collating element consisting of the character
sequence designated by the iterator range <span class='texttt'>[first, last)</span>.
Returns an empty string if the character sequence is not a
valid collating element.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_traits,lookup_classname'></a></span><span class='indexparent'><a class='index' id='lookup_classname,regex_traits'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator&gt;
  char_class_type lookup_classname(
    ForwardIterator first, ForwardIterator last, bool icase = false) const;
</code></p><div class='itemdescr'></div><div class='para' id='traits-9'><div class='marginalizedparent'><a class='marginalized' href='#traits-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> an unspecified value that represents
the character classification named by the character sequence
designated by the iterator range <span class='texttt'>[first, last)</span>.
If the parameter <span class='texttt'>icase</span> is <span class='texttt'>true</span> then the returned mask identifies the
character classification without regard to the case of the characters being
matched, otherwise it does honor the case of the characters being
matched.<a class='footnotenum' href='#footnote-332'>332</a>
The value
returned shall be independent of the case of the characters in
the character sequence. If the name
is not recognized then returns <span class='texttt'>char_class_type()</span>.</p></div></div><div class='para' id='traits-10'><div class='marginalizedparent'><a class='marginalized' href='#traits-10'>10</a></div><div class='itemdescr'><p ><i>Remarks:</i>  For <span class='texttt'>regex_traits&lt;char&gt;</span>, at least the narrow character names
in Table <a href='#tab:re.traits.classnames'>[tab:re.traits.classnames]</a> shall be recognized.
For <span class='texttt'>regex_traits&lt;wchar_t&gt;</span>, at least the wide character names
in Table <a href='#tab:re.traits.classnames'>[tab:re.traits.classnames]</a> shall be recognized.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_traits,isctype'></a></span><span class='indexparent'><a class='index' id='isctype,regex_traits'></a></span><code class='itemdecl'>
bool isctype(charT c, char_class_type f) const;
</code></p><div class='itemdescr'></div><div class='para' id='traits-11'><div class='marginalizedparent'><a class='marginalized' href='#traits-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>  Determines if the character <span class='texttt'>c</span> is a member of the character
classification represented by <span class='texttt'>f</span>.</p></div></div><div class='para' id='traits-12'><div class='marginalizedparent'><a class='marginalized' href='#traits-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> Given the following function declaration:
</p><pre class='codeblock'>
<span class='comment'>// for exposition only
</span>template&lt;class C&gt;
  ctype_base::mask convert(typename regex_traits&lt;C&gt;::char_class_type f);
</pre><p >that returns a value in which each <span class='texttt'>ctype_base::mask</span> value corresponding to
a value in <span class='texttt'>f</span> named in Table <a href='#tab:re.traits.classnames'>[tab:re.traits.classnames]</a> is set, then the
result is determined as if by:
</p><pre class='codeblock'>
ctype_base::mask m = convert&lt;charT&gt;(f);
const ctype&lt;charT&gt;&amp; ct = use_facet&lt;ctype&lt;charT&gt;&gt;(getloc());
if (ct.is(m, c)) {
  return true;
} else if (c == ct.widen('_')) {
  charT w[1] = { ct.widen('w') };
  char_class_type x = lookup_classname(w, w+1);
  return (f&amp;x) == x;
} else {
  return false;
}
</pre><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
regex_traits&lt;char&gt; t;
string d("d");
string u("upper");
regex_traits&lt;char&gt;::char_class_type f;
f = t.lookup_classname(d.begin(), d.end());
f |= t.lookup_classname(u.begin(), u.end());
ctype_base::mask m = convert&lt;char&gt;(f); <span class='comment'>// <span class='texttt'>m == ctype_base::digit|ctype_base::upper</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
regex_traits&lt;char&gt; t;
string w("w");
regex_traits&lt;char&gt;::char_class_type f;
f = t.lookup_classname(w.begin(), w.end());
t.isctype('A', f); <span class='comment'>// returns <span class='texttt'>true</span>
</span>t.isctype('_', f); <span class='comment'>// returns <span class='texttt'>true</span>
</span>t.isctype(' ', f); <span class='comment'>// returns <span class='texttt'>false</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><p ><span class='indexparent'><a class='index' id='value,regex_traits'></a></span><span class='indexparent'><a class='index' id='regex_traits,value'></a></span><code class='itemdecl'>
int value(charT ch, int radix) const;
</code></p><div class='itemdescr'></div><div class='para' id='traits-13'><div class='marginalizedparent'><a class='marginalized' href='#traits-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i>  The value of <span class='texttt'>radix</span> shall be 8, 10, or 16.</p></div></div><div class='para' id='traits-14'><div class='marginalizedparent'><a class='marginalized' href='#traits-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> the value represented by the digit <span class='texttt'>ch</span> in base
<span class='texttt'>radix</span> if the character <span class='texttt'>ch</span> is a valid digit in base
<span class='texttt'>radix</span>; otherwise returns -1.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale'></a></span><span class='indexparent'><a class='index' id='imbue'></a></span><code class='itemdecl'>
locale_type imbue(locale_type loc);
</code></p><div class='itemdescr'></div><div class='para' id='traits-15'><div class='marginalizedparent'><a class='marginalized' href='#traits-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i>  Imbues <span class='texttt'>this</span> with a copy of the
locale <span class='texttt'>loc</span>. [&nbsp;<i>Note:</i> Calling <span class='texttt'>imbue</span> with a
different locale than the one currently in use invalidates all cached
data held by <span class='texttt'>*this</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='traits-16'><div class='marginalizedparent'><a class='marginalized' href='#traits-16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i> if no locale has been previously imbued then a copy of the
global locale in effect at the time of construction of <span class='texttt'>*this</span>,
otherwise a copy of the last argument passed to <span class='texttt'>imbue</span>.</p></div></div><div class='para' id='traits-17'><div class='marginalizedparent'><a class='marginalized' href='#traits-17'>17</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>getloc() == loc</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale'></a></span><span class='indexparent'><a class='index' id='getloc'></a></span><code class='itemdecl'>
locale_type getloc() const;
</code></p><div class='itemdescr'></div><div class='para' id='traits-18'><div class='marginalizedparent'><a class='marginalized' href='#traits-18'>18</a></div><div class='itemdescr'><p ><i>Returns:</i> if no locale has been imbued then a copy of the global locale
in effect at the time of construction of <span class='texttt'>*this</span>, otherwise a copy of
the last argument passed to <span class='texttt'>imbue</span>.
</p></div></div><div class='numberedTable' id='tab:re.traits.classnames'>Table <a href='#tab:re.traits.classnames'>127</a> — Character class names and corresponding <span class='texttt'>ctype</span> masks<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Narrow character name</b></td><td colspan='1' class='center'><b>Wide character name</b></td><td colspan='1' class='center'><b>Corresponding <span class='texttt'>ctype_base::mask</span> value</b></td></tr><tr class='capsep'><td class='left'>
<span class='texttt'>"alnum"</span>  </td><td class='left'> <span class='texttt'>L"alnum"</span>  </td><td class='left'> <span class='texttt'>ctype_base::alnum</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"alpha"</span>  </td><td class='left'> <span class='texttt'>L"alpha"</span>  </td><td class='left'> <span class='texttt'>ctype_base::alpha</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"blank"</span>  </td><td class='left'> <span class='texttt'>L"blank"</span>  </td><td class='left'> <span class='texttt'>ctype_base::blank</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"cntrl"</span>  </td><td class='left'> <span class='texttt'>L"cntrl"</span>  </td><td class='left'> <span class='texttt'>ctype_base::cntrl</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"digit"</span>  </td><td class='left'> <span class='texttt'>L"digit"</span>  </td><td class='left'> <span class='texttt'>ctype_base::digit</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"d"</span>      </td><td class='left'> <span class='texttt'>L"d"</span>      </td><td class='left'> <span class='texttt'>ctype_base::digit</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"graph"</span>  </td><td class='left'> <span class='texttt'>L"graph"</span>  </td><td class='left'> <span class='texttt'>ctype_base::graph</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"lower"</span>  </td><td class='left'> <span class='texttt'>L"lower"</span>  </td><td class='left'> <span class='texttt'>ctype_base::lower</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"print"</span>  </td><td class='left'> <span class='texttt'>L"print"</span>  </td><td class='left'> <span class='texttt'>ctype_base::print</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"punct"</span>  </td><td class='left'> <span class='texttt'>L"punct"</span>  </td><td class='left'> <span class='texttt'>ctype_base::punct</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"space"</span>  </td><td class='left'> <span class='texttt'>L"space"</span>  </td><td class='left'> <span class='texttt'>ctype_base::space</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"s"</span>      </td><td class='left'> <span class='texttt'>L"s"</span>      </td><td class='left'> <span class='texttt'>ctype_base::space</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"upper"</span>  </td><td class='left'> <span class='texttt'>L"upper"</span>  </td><td class='left'> <span class='texttt'>ctype_base::upper</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"w"</span>      </td><td class='left'> <span class='texttt'>L"w"</span>      </td><td class='left'> <span class='texttt'>ctype_base::alnum</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"xdigit"</span> </td><td class='left'> <span class='texttt'>L"xdigit"</span> </td><td class='left'> <span class='texttt'>ctype_base::xdigit</span> </td></tr></table></div><div class='footnote' id='footnote-332'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-332'>332)</a></div><p >For example, if the parameter <span class='texttt'>icase</span> is <span class='texttt'>true</span> then
<span class='texttt'>[[:lower:]]</span> is the same as <span class='texttt'>[[:alpha:]]</span>.</p></div></div><div id='regex'><h2 ><a class='secnum' href='#regex' style='min-width:88pt'>28.8</a> Class template <span class='texttt'>basic_regex</span> <a class='abbr_ref' href='re.regex'>[re.regex]</a></h2><p ><span class='indexparent'><a class='index' id='basic_regex'></a></span>
</p><div class='para' id='regex-1'><div class='marginalizedparent'><a class='marginalized' href='#regex-1'>1</a></div><p >For a char-like type <span class='texttt'>charT</span>, specializations of class
template <span class='texttt'>basic_regex</span> represent regular expressions constructed
from character sequences of <span class='texttt'>charT</span> characters.  In the rest
of <a href='re.regex'>[re.regex]</a>, <span class='texttt'>charT</span> denotes a given char-like
type. Storage for a regular expression is allocated and freed as
necessary by the member functions of class <span class='texttt'>basic_regex</span>.</p></div><div class='para' id='regex-2'><div class='marginalizedparent'><a class='marginalized' href='#regex-2'>2</a></div><p >Objects of type specialization of <span class='texttt'>basic_regex</span> are responsible for
converting the sequence of <span class='texttt'>charT</span> objects to an internal
representation. It is not specified what form this representation
takes, nor how it is accessed by algorithms that operate on regular
expressions. [&nbsp;<i>Note:</i> Implementations will typically declare
some function templates as friends of <span class='texttt'>basic_regex</span> to achieve
this <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='regex-3'><div class='marginalizedparent'><a class='marginalized' href='#regex-3'>3</a></div><p ><span class='indexparent'><a class='index' id='regex_error'></a></span>The functions described in this Clause report errors by throwing
exceptions of type <span class='texttt'>regex_error</span>.</p><p ><span class='indexparent'><a class='index' id='basic_regex'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT,
            class traits = regex_traits&lt;charT&gt;&gt;
  class basic_regex {
  public:
    <span class='comment'>// types:
</span>    using value_type  =          charT;
    using traits_type =          traits;
    using string_type = typename traits::string_type;
    using flag_type   =          regex_constants::syntax_option_type;
    using locale_type = typename traits::locale_type;

    <span class='comment'>// <a href='re.regex.const'>[re.regex.const]</a>, constants
</span>    static constexpr regex_constants::syntax_option_type
      icase = regex_constants::icase;
    static constexpr regex_constants::syntax_option_type
      nosubs = regex_constants::nosubs;
    static constexpr regex_constants::syntax_option_type
      optimize = regex_constants::optimize;
    static constexpr regex_constants::syntax_option_type
      collate = regex_constants::collate;
    static constexpr regex_constants::syntax_option_type
      ECMAScript = regex_constants::ECMAScript;
    static constexpr regex_constants::syntax_option_type
      basic = regex_constants::basic;
    static constexpr regex_constants::syntax_option_type
      extended = regex_constants::extended;
    static constexpr regex_constants::syntax_option_type
      awk = regex_constants::awk;
    static constexpr regex_constants::syntax_option_type
      grep = regex_constants::grep;
    static constexpr regex_constants::syntax_option_type
      egrep = regex_constants::egrep;

    <span class='comment'>// <a href='re.regex.construct'>[re.regex.construct]</a>, construct/copy/destroy
</span>    basic_regex();
    explicit basic_regex(const charT* p,
      flag_type f = regex_constants::ECMAScript);
    basic_regex(const charT* p, size_t len, flag_type f = regex_constants::ECMAScript);
    basic_regex(const basic_regex&amp;);
    basic_regex(basic_regex&amp;&amp;) noexcept;
    template &lt;class ST, class SA&gt;
      explicit basic_regex(const basic_string&lt;charT, ST, SA&gt;&amp; p,
                           flag_type f = regex_constants::ECMAScript);
    template &lt;class ForwardIterator&gt;
      basic_regex(ForwardIterator first, ForwardIterator last,
                  flag_type f = regex_constants::ECMAScript);
    basic_regex(initializer_list&lt;charT&gt;,
      flag_type = regex_constants::ECMAScript);

    ~basic_regex();

    basic_regex&amp; operator=(const basic_regex&amp;);
    basic_regex&amp; operator=(basic_regex&amp;&amp;) noexcept;
    basic_regex&amp; operator=(const charT* ptr);
    basic_regex&amp; operator=(initializer_list&lt;charT&gt; il);
    template &lt;class ST, class SA&gt;
      basic_regex&amp; operator=(const basic_string&lt;charT, ST, SA&gt;&amp; p);

    <span class='comment'>// <a href='re.regex.assign'>[re.regex.assign]</a>, assign
</span>    basic_regex&amp; assign(const basic_regex&amp; that);
    basic_regex&amp; assign(basic_regex&amp;&amp; that) noexcept;
    basic_regex&amp; assign(const charT* ptr,
      flag_type f = regex_constants::ECMAScript);
    basic_regex&amp; assign(const charT* p, size_t len, flag_type f);
    template &lt;class string_traits, class A&gt;
      basic_regex&amp; assign(const basic_string&lt;charT, string_traits, A&gt;&amp; s,
                          flag_type f = regex_constants::ECMAScript);
    template &lt;class InputIterator&gt;
      basic_regex&amp; assign(InputIterator first, InputIterator last,
                          flag_type f = regex_constants::ECMAScript);
    basic_regex&amp; assign(initializer_list&lt;charT&gt;,
                        flag_type = regex_constants::ECMAScript);

    <span class='comment'>// <a href='re.regex.operations'>[re.regex.operations]</a>, const operations
</span>    unsigned mark_count() const;
    flag_type flags() const;

    <span class='comment'>// <a href='re.regex.locale'>[re.regex.locale]</a>, locale
</span>    locale_type imbue(locale_type loc);
    locale_type getloc() const;

    <span class='comment'>// <a href='re.regex.swap'>[re.regex.swap]</a>, swap
</span>    void swap(basic_regex&amp;);
  };
}
</pre></div><div id='regex.const'><h3 ><a class='secnum' href='#regex.const' style='min-width:103pt'>28.8.1</a> <span class='texttt'>basic_regex</span> constants <a class='abbr_ref' href='re.regex.const'>[re.regex.const]</a></h3><p ><span class='indexparent'><a class='index' id='basic_regex,constants'></a></span>
</p><pre class='codeblock'>
static constexpr regex_constants::syntax_option_type
  icase = regex_constants::icase;
static constexpr regex_constants::syntax_option_type
  nosubs = regex_constants::nosubs;
static constexpr regex_constants::syntax_option_type
  optimize = regex_constants::optimize;
static constexpr regex_constants::syntax_option_type
  collate = regex_constants::collate;
static constexpr regex_constants::syntax_option_type
  ECMAScript = regex_constants::ECMAScript;
static constexpr regex_constants::syntax_option_type
  basic = regex_constants::basic;
static constexpr regex_constants::syntax_option_type
  extended = regex_constants::extended;
static constexpr regex_constants::syntax_option_type
  awk = regex_constants::awk;
static constexpr regex_constants::syntax_option_type
  grep = regex_constants::grep;
static constexpr regex_constants::syntax_option_type
  egrep = regex_constants::egrep;
</pre><div class='para' id='regex.const-1'><div class='marginalizedparent'><a class='marginalized' href='#regex.const-1'>1</a></div><p ><span class='indexparent'><a class='index' id='basic_regex,constants'></a></span>The static constant members are provided as synonyms for the constants
declared in namespace <span class='texttt'>regex_constants</span>.</p></div></div><div id='regex.construct'><h3 ><a class='secnum' href='#regex.construct' style='min-width:103pt'>28.8.2</a> <span class='texttt'>basic_regex</span> constructors <a class='abbr_ref' href='re.regex.construct'>[re.regex.construct]</a></h3><p ><span class='indexparent'><a class='index' id='basic_regex,constructor'></a></span><code class='itemdecl'>
basic_regex();
</code></p><div class='itemdescr'></div><div class='para' id='regex.construct-1'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an object of class <span class='texttt'>basic_regex</span> that
does not match any character sequence.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,constructor'></a></span><code class='itemdecl'>
explicit basic_regex(const charT* p, flag_type f = regex_constants::ECMAScript);
</code></p><div class='itemdescr'></div><div class='para' id='regex.construct-2'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>  <span class='texttt'>p</span> shall not be a null pointer.</p></div></div><div class='para' id='regex.construct-3'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i>  <span class='texttt'>regex_error</span> if <span class='texttt'>p</span> is not a valid regular expression.</p></div></div><div class='para' id='regex.construct-4'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an object of class <span class='texttt'>basic_regex</span>; the object's
internal finite state machine is constructed from the regular
expression contained in the array of <span class='texttt'>charT</span> of length
<span class='texttt'>char_traits&lt;charT&gt;::length(p)</span> whose first element is
designated by <span class='texttt'>p</span>, and interpreted according to the flags <span class='texttt'>f</span>.</p></div></div><div class='para' id='regex.construct-5'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>flags()</span> returns <span class='texttt'>f</span>. 
<span class='texttt'>mark_count()</span> returns the number of marked sub-expressions
within the expression.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,constructor'></a></span><code class='itemdecl'>
basic_regex(const charT* p, size_t len, flag_type f);
</code></p><div class='itemdescr'></div><div class='para' id='regex.construct-6'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>  <span class='texttt'>p</span> shall not be a null pointer.</p></div></div><div class='para' id='regex.construct-7'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-7'>7</a></div><div class='itemdescr'><p ><i>Throws:</i>  <span class='texttt'>regex_error</span> if <span class='texttt'>p</span> is not a valid regular expression.</p></div></div><div class='para' id='regex.construct-8'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an object of class <span class='texttt'>basic_regex</span>; the object's
internal finite state machine is constructed from the regular
expression contained in the sequence of characters <span class='texttt'>[p, p+len)</span>, and
interpreted according the flags specified in <span class='texttt'>f</span>.</p></div></div><div class='para' id='regex.construct-9'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-9'>9</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>flags()</span> returns <span class='texttt'>f</span>. 
<span class='texttt'>mark_count()</span> returns the number of marked sub-expressions
within the expression.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,constructor'></a></span><code class='itemdecl'>
basic_regex(const basic_regex&amp; e);
</code></p><div class='itemdescr'></div><div class='para' id='regex.construct-10'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an object of class <span class='texttt'>basic_regex</span> as a copy of
the object <span class='texttt'>e</span>.</p></div></div><div class='para' id='regex.construct-11'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-11'>11</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>flags()</span> and <span class='texttt'>mark_count()</span> return
<span class='texttt'>e.flags()</span> and <span class='texttt'>e.mark_count()</span>, respectively.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,constructor'></a></span><code class='itemdecl'>
basic_regex(basic_regex&amp;&amp; e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='regex.construct-12'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i>  Move constructs an object of class <span class='texttt'>basic_regex</span> from <span class='texttt'>e</span>.</p></div></div><div class='para' id='regex.construct-13'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-13'>13</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>flags()</span> and <span class='texttt'>mark_count()</span> return the values that
<span class='texttt'>e.flags()</span> and <span class='texttt'>e.mark_count()</span>, respectively, had before construction.
<span class='texttt'>e</span> is in a valid state with unspecified value.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,constructor'></a></span><code class='itemdecl'>
template &lt;class ST, class SA&gt;
  explicit basic_regex(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                       flag_type f = regex_constants::ECMAScript);
</code></p><div class='itemdescr'></div><div class='para' id='regex.construct-14'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-14'>14</a></div><div class='itemdescr'><p ><i>Throws:</i>  <span class='texttt'>regex_error</span> if <span class='texttt'>s</span> is not a valid regular expression.</p></div></div><div class='para' id='regex.construct-15'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an object of class <span class='texttt'>basic_regex</span>; the object's
internal finite state machine is constructed from the regular
expression contained in the string <span class='texttt'>s</span>, and interpreted according to the
flags specified in <span class='texttt'>f</span>.</p></div></div><div class='para' id='regex.construct-16'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-16'>16</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>flags()</span> returns <span class='texttt'>f</span>. 
<span class='texttt'>mark_count()</span> returns the number of marked sub-expressions
within the expression.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,constructor'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator&gt;
  basic_regex(ForwardIterator first, ForwardIterator last,
              flag_type f = regex_constants::ECMAScript);
</code></p><div class='itemdescr'></div><div class='para' id='regex.construct-17'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-17'>17</a></div><div class='itemdescr'><p ><i>Throws:</i>  <span class='texttt'>regex_error</span> if the sequence <span class='texttt'>[first, last)</span> is not a
valid regular expression.</p></div></div><div class='para' id='regex.construct-18'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-18'>18</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an object of class <span class='texttt'>basic_regex</span>; the object's
internal finite state machine is constructed from the regular
expression contained in the sequence of characters <span class='texttt'>[first, last)</span>, and
interpreted according to the flags specified in <span class='texttt'>f</span>.</p></div></div><div class='para' id='regex.construct-19'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-19'>19</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>flags()</span> returns <span class='texttt'>f</span>. 
<span class='texttt'>mark_count()</span> returns the number of marked sub-expressions
within the expression.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,constructor'></a></span><code class='itemdecl'>
basic_regex(initializer_list&lt;charT&gt; il,
            flag_type f = regex_constants::ECMAScript);
</code></p><div class='itemdescr'></div><div class='para' id='regex.construct-20'><div class='marginalizedparent'><a class='marginalized' href='#regex.construct-20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i> Same as <span class='texttt'>basic_regex(il.begin(), il.end(), f)</span>.
</p></div></div></div><div id='regex.assign'><h3 ><a class='secnum' href='#regex.assign' style='min-width:103pt'>28.8.3</a> <span class='texttt'>basic_regex</span> assign <a class='abbr_ref' href='re.regex.assign'>[re.regex.assign]</a></h3><p ><span class='indexparent'><a class='index' id='basic_regex,operator='></a></span><span class='indexparent'><a class='index' id='operator=,basic_regex'></a></span><code class='itemdecl'>
basic_regex&amp; operator=(const basic_regex&amp; e);
</code></p><div class='itemdescr'></div><div class='para' id='regex.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Copies <span class='texttt'>e</span> into <span class='texttt'>*this</span> and returns <span class='texttt'>*this</span>.</p></div></div><div class='para' id='regex.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>flags()</span> and <span class='texttt'>mark_count()</span> return
<span class='texttt'>e.flags()</span> and <span class='texttt'>e.mark_count()</span>, respectively.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,operator='></a></span><span class='indexparent'><a class='index' id='operator=,basic_regex'></a></span><code class='itemdecl'>
basic_regex&amp; operator=(basic_regex&amp;&amp; e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='regex.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Move assigns from <span class='texttt'>e</span> into <span class='texttt'>*this</span> and returns <span class='texttt'>*this</span>.</p></div></div><div class='para' id='regex.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>flags()</span> and <span class='texttt'>mark_count()</span> return the values that
<span class='texttt'>e.flags()</span> and <span class='texttt'>e.mark_count()</span>, respectively, had before assignment.
<span class='texttt'>e</span> is in a valid state with unspecified value.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,operator='></a></span><span class='indexparent'><a class='index' id='operator=,basic_regex'></a></span><code class='itemdecl'>
basic_regex&amp; operator=(const charT* ptr);
</code></p><div class='itemdescr'></div><div class='para' id='regex.assign-5'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i>  <span class='texttt'>ptr</span> shall not be a null pointer.</p></div></div><div class='para' id='regex.assign-6'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Returns <span class='texttt'>assign(ptr)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,operator='></a></span><span class='indexparent'><a class='index' id='operator=,basic_regex'></a></span><code class='itemdecl'>
basic_regex&amp; operator=(initializer_list&lt;charT&gt; il);
</code></p><div class='itemdescr'></div><div class='para' id='regex.assign-7'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Returns <span class='texttt'>assign(il.begin(), il.end())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,operator='></a></span><span class='indexparent'><a class='index' id='operator=,basic_regex'></a></span><code class='itemdecl'>
template &lt;class ST, class SA&gt;
  basic_regex&amp; operator=(const basic_string&lt;charT, ST, SA&gt;&amp; p);
</code></p><div class='itemdescr'></div><div class='para' id='regex.assign-8'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Returns <span class='texttt'>assign(p)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,assign'></a></span><span class='indexparent'><a class='index' id='assign,basic_regex'></a></span><code class='itemdecl'>
basic_regex&amp; assign(const basic_regex&amp; that);
</code></p><div class='itemdescr'></div><div class='para' id='regex.assign-9'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>*this = that</span>.</p></div></div><div class='para' id='regex.assign-10'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,assign'></a></span><span class='indexparent'><a class='index' id='assign,basic_regex'></a></span><code class='itemdecl'>
basic_regex&amp; assign(basic_regex&amp;&amp; that) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='regex.assign-11'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>  Equivalent to <span class='texttt'>*this = std::move(that)</span>.</p></div></div><div class='para' id='regex.assign-12'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,assign'></a></span><span class='indexparent'><a class='index' id='assign,basic_regex'></a></span><code class='itemdecl'>
basic_regex&amp; assign(const charT* ptr, flag_type f = regex_constants::ECMAScript);
</code></p><div class='itemdescr'></div><div class='para' id='regex.assign-13'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>assign(string_type(ptr), f)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,assign'></a></span><span class='indexparent'><a class='index' id='assign,basic_regex'></a></span><code class='itemdecl'>
basic_regex&amp; assign(const charT* ptr, size_t len,
  flag_type f = regex_constants::ECMAScript);
</code></p><div class='itemdescr'></div><div class='para' id='regex.assign-14'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>assign(string_type(ptr, len), f)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,assign'></a></span><span class='indexparent'><a class='index' id='assign,basic_regex'></a></span><code class='itemdecl'>
template &lt;class string_traits, class A&gt;
  basic_regex&amp; assign(const basic_string&lt;charT, string_traits, A&gt;&amp; s,
                      flag_type f = regex_constants::ECMAScript);
</code></p><div class='itemdescr'></div><div class='para' id='regex.assign-15'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-15'>15</a></div><div class='itemdescr'><p ><i>Throws:</i>  <span class='texttt'>regex_error</span> if <span class='texttt'>s</span> is not a valid regular expression.</p></div></div><div class='para' id='regex.assign-16'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.</p></div></div><div class='para' id='regex.assign-17'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-17'>17</a></div><div class='itemdescr'><p ><i>Effects:</i>  Assigns the regular expression contained in the string
<span class='texttt'>s</span>, interpreted according the flags specified in <span class='texttt'>f</span>.
If an exception is thrown, <span class='texttt'>*this</span> is unchanged. </p></div></div><div class='para' id='regex.assign-18'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-18'>18</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
If no exception is thrown,
<span class='texttt'>flags()</span> returns <span class='texttt'>f</span> and <span class='texttt'>mark_count()</span>
returns the number of marked sub-expressions within the expression.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_regex,assign'></a></span><span class='indexparent'><a class='index' id='assign,basic_regex'></a></span><code class='itemdecl'>
template &lt;class InputIterator&gt;
  basic_regex&amp; assign(InputIterator first, InputIterator last,
                      flag_type f = regex_constants::ECMAScript);
</code></p><div class='itemdescr'></div><div class='para' id='regex.assign-19'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-19'>19</a></div><div class='itemdescr'><p ><i>Requires:</i>  The type <span class='texttt'>InputIterator</span> shall satisfy the requirements for an Input
Iterator (<a href='input.iterators'>[input.iterators]</a>).</p></div></div><div class='para' id='regex.assign-20'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-20'>20</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>assign(string_type(first, last), f)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='assign,basic_regex'></a></span><span class='indexparent'><a class='index' id='basic_regex,assign'></a></span><code class='itemdecl'>
basic_regex&amp; assign(initializer_list&lt;charT&gt; il,
                    flag_type f = regex_constants::ECMAScript);
</code></p><div class='itemdescr'></div><div class='para' id='regex.assign-21'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-21'>21</a></div><div class='itemdescr'><p ><i>Effects:</i> Same as <span class='texttt'>assign(il.begin(), il.end(), f)</span>.</p></div></div><div class='para' id='regex.assign-22'><div class='marginalizedparent'><a class='marginalized' href='#regex.assign-22'>22</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='regex.operations'><h3 ><a class='secnum' href='#regex.operations' style='min-width:103pt'>28.8.4</a> <span class='texttt'>basic_regex</span> constant operations <a class='abbr_ref' href='re.regex.operations'>[re.regex.operations]</a></h3><p ><span class='indexparent'><a class='index' id='mark_count,basic_regex'></a></span><span class='indexparent'><a class='index' id='basic_regex,mark_count'></a></span><code class='itemdecl'>
unsigned mark_count() const;
</code></p><div class='itemdescr'></div><div class='para' id='regex.operations-1'><div class='marginalizedparent'><a class='marginalized' href='#regex.operations-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Returns the number of marked sub-expressions within the
regular expression.
</p></div></div><p ><span class='indexparent'><a class='index' id='flag_type,basic_regex'></a></span><span class='indexparent'><a class='index' id='basic_regex,flag_type'></a></span><code class='itemdecl'>
flag_type flags() const;
</code></p><div class='itemdescr'></div><div class='para' id='regex.operations-2'><div class='marginalizedparent'><a class='marginalized' href='#regex.operations-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>  Returns a copy of the regular expression syntax flags that
were passed to the object's constructor or to the last call
to <span class='texttt'>assign</span>.
</p></div></div></div><div id='regex.locale'><h3 ><a class='secnum' href='#regex.locale' style='min-width:103pt'>28.8.5</a> <span class='texttt'>basic_regex</span> locale <a class='abbr_ref' href='re.regex.locale'>[re.regex.locale]</a></h3><p ><span class='indexparent'><a class='index' id='locale'></a></span></p><p ><span class='indexparent'><a class='index' id='imbue,basic_regex'></a></span><span class='indexparent'><a class='index' id='basic_regex,imbue'></a></span><code class='itemdecl'>
locale_type imbue(locale_type loc);
</code></p><div class='itemdescr'></div><div class='para' id='regex.locale-1'><div class='marginalizedparent'><a class='marginalized' href='#regex.locale-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Returns the result of <span class='texttt'>traits_inst.imbue(loc)</span> where
<span class='texttt'>traits_inst</span> is a (default-initialized) instance of the template
type argument <span class='texttt'>traits</span> stored within the object.  After a call
to <span class='texttt'>imbue</span> the <span class='texttt'>basic_regex</span> object does not match any
character sequence.
</p></div></div><p ><span class='indexparent'><a class='index' id='getloc,basic_regex'></a></span><span class='indexparent'><a class='index' id='basic_regex,getloc'></a></span><code class='itemdecl'>
locale_type getloc() const;
</code></p><div class='itemdescr'></div><div class='para' id='regex.locale-2'><div class='marginalizedparent'><a class='marginalized' href='#regex.locale-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>  Returns the result of <span class='texttt'>traits_inst.getloc()</span> where
<span class='texttt'>traits_inst</span> is a (default-initialized) instance of the template
parameter <span class='texttt'>traits</span> stored within the object.
</p></div></div></div><div id='regex.swap'><h3 ><a class='secnum' href='#regex.swap' style='min-width:103pt'>28.8.6</a> <span class='texttt'>basic_regex</span> swap <a class='abbr_ref' href='re.regex.swap'>[re.regex.swap]</a></h3><p ><span class='indexparent'><a class='index' id='basic_regex,swap'></a></span><span class='indexparent'><a class='index' id='swap,basic_regex'></a></span>
<span class='indexparent'><a class='index' id='swap,basic_regex'></a></span><span class='indexparent'><a class='index' id='basic_regex,swap'></a></span><code class='itemdecl'>
void swap(basic_regex&amp; e);
</code></p><div class='itemdescr'></div><div class='para' id='regex.swap-1'><div class='marginalizedparent'><a class='marginalized' href='#regex.swap-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Swaps the contents of the two regular expressions.</p></div></div><div class='para' id='regex.swap-2'><div class='marginalizedparent'><a class='marginalized' href='#regex.swap-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>*this</span> contains the regular expression
that was in <span class='texttt'>e</span>, <span class='texttt'>e</span> contains the regular expression that
was in <span class='texttt'>*this</span>.</p></div></div><div class='para' id='regex.swap-3'><div class='marginalizedparent'><a class='marginalized' href='#regex.swap-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i> Constant time.
</p></div></div></div><div id='regex.nonmemb'><h3 ><a class='secnum' href='#regex.nonmemb' style='min-width:103pt'>28.8.7</a> <span class='texttt'>basic_regex</span> non-member functions <a class='abbr_ref' href='re.regex.nonmemb'>[re.regex.nonmemb]</a></h3><div id='regex.nmswap'><h4 ><a class='secnum' href='#regex.nmswap' style='min-width:118pt'>28.8.7.1</a> <span class='texttt'>basic_regex</span> non-member swap <a class='abbr_ref' href='re.regex.nmswap'>[re.regex.nmswap]</a></h4><p ><span class='indexparent'><a class='index' id='basic_regex,swap'></a></span><span class='indexparent'><a class='index' id='swap,basic_regex'></a></span><code class='itemdecl'>
template &lt;class charT, class traits&gt;
  void swap(basic_regex&lt;charT, traits&gt;&amp; lhs, basic_regex&lt;charT, traits&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='regex.nmswap-1'><div class='marginalizedparent'><a class='marginalized' href='#regex.nmswap-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Calls <span class='texttt'>lhs.swap(rhs)</span>.
</p></div></div></div></div></div><div id='submatch'><h2 ><a class='secnum' href='#submatch' style='min-width:88pt'>28.9</a> Class template <span class='texttt'>sub_match</span> <a class='abbr_ref' href='re.submatch'>[re.submatch]</a></h2><div class='para' id='submatch-1'><div class='marginalizedparent'><a class='marginalized' href='#submatch-1'>1</a></div><p ><span class='indexparent'><a class='index' id='sub_match'></a></span>Class template <span class='texttt'>sub_match</span> denotes the sequence of characters matched
by a particular marked sub-expression.</p><pre class='codeblock'>
namespace std {
  template &lt;class BidirectionalIterator&gt;
  class sub_match : public pair&lt;BidirectionalIterator, BidirectionalIterator&gt; {
  public:
     using value_type      =
             typename iterator_traits&lt;BidirectionalIterator&gt;::value_type;
     using difference_type =
             typename iterator_traits&lt;BidirectionalIterator&gt;::difference_type;
     using iterator        = BidirectionalIterator;
     using string_type     = basic_string&lt;value_type&gt;;

     bool matched;

     constexpr sub_match();

     difference_type length() const;
     operator string_type() const;
     string_type str() const;

     int compare(const sub_match&amp; s) const;
     int compare(const string_type&amp; s) const;
     int compare(const value_type* s) const;
  };
}
</pre></div><div id='submatch.members'><h3 ><a class='secnum' href='#submatch.members' style='min-width:103pt'>28.9.1</a> <span class='texttt'>sub_match</span> members <a class='abbr_ref' href='re.submatch.members'>[re.submatch.members]</a></h3><p ><span class='indexparent'><a class='index' id='sub_match,constructor'></a></span><code class='itemdecl'>
constexpr sub_match();
</code></p><div class='itemdescr'></div><div class='para' id='submatch.members-1'><div class='marginalizedparent'><a class='marginalized' href='#submatch.members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Value-initializes the <span class='texttt'>pair</span> base class subobject and the member
<span class='texttt'>matched</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,length'></a></span><span class='indexparent'><a class='index' id='length,sub_match'></a></span><code class='itemdecl'>
difference_type length() const;
</code></p><div class='itemdescr'></div><div class='para' id='submatch.members-2'><div class='marginalizedparent'><a class='marginalized' href='#submatch.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>(matched ? distance(first, second) : 0)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator_basic_string,sub_match'></a></span><span class='indexparent'><a class='index' id='sub_match,operator_basic_string'></a></span><code class='itemdecl'>
operator string_type() const;
</code></p><div class='itemdescr'></div><div class='para' id='submatch.members-3'><div class='marginalizedparent'><a class='marginalized' href='#submatch.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>matched ? string_type(first, second) : string_type()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,str'></a></span><span class='indexparent'><a class='index' id='str,sub_match'></a></span><code class='itemdecl'>
string_type str() const;
</code></p><div class='itemdescr'></div><div class='para' id='submatch.members-4'><div class='marginalizedparent'><a class='marginalized' href='#submatch.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>matched ? string_type(first, second) : string_type()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,compare'></a></span><span class='indexparent'><a class='index' id='compare,sub_match'></a></span><code class='itemdecl'>
int compare(const sub_match&amp; s) const;
</code></p><div class='itemdescr'></div><div class='para' id='submatch.members-5'><div class='marginalizedparent'><a class='marginalized' href='#submatch.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>str().compare(s.str())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,compare'></a></span><span class='indexparent'><a class='index' id='compare,sub_match'></a></span><code class='itemdecl'>
int compare(const string_type&amp; s) const;
</code></p><div class='itemdescr'></div><div class='para' id='submatch.members-6'><div class='marginalizedparent'><a class='marginalized' href='#submatch.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>str().compare(s)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,compare'></a></span><span class='indexparent'><a class='index' id='compare,sub_match'></a></span><code class='itemdecl'>
int compare(const value_type* s) const;
</code></p><div class='itemdescr'></div><div class='para' id='submatch.members-7'><div class='marginalizedparent'><a class='marginalized' href='#submatch.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>str().compare(s)</span>.
</p></div></div></div><div id='submatch.op'><h3 ><a class='secnum' href='#submatch.op' style='min-width:103pt'>28.9.2</a> <span class='texttt'>sub_match</span> non-member operators <a class='abbr_ref' href='re.submatch.op'>[re.submatch.op]</a></h3><p ><span class='indexparent'><a class='index' id='sub_match,operator=='></a></span><span class='indexparent'><a class='index' id='operator==,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-1'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.compare(rhs) == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator!='></a></span><span class='indexparent'><a class='index' id='operator!=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-2'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.compare(rhs) != 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator<'></a></span><span class='indexparent'><a class='index' id='operator<,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-3'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.compare(rhs) &lt; 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator<='></a></span><span class='indexparent'><a class='index' id='operator<=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-4'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.compare(rhs) &lt;= 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator>='></a></span><span class='indexparent'><a class='index' id='operator>=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-5'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.compare(rhs) &gt;= 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator>'></a></span><span class='indexparent'><a class='index' id='operator>,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-6'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.compare(rhs) &gt; 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator=='></a></span><span class='indexparent'><a class='index' id='operator==,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator==(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-7'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs.compare(typename sub_match&lt;BiIter&gt;::string_type(lhs.data(), lhs.size())) == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator!='></a></span><span class='indexparent'><a class='index' id='operator!=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator!=(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-8'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs == rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator<'></a></span><span class='indexparent'><a class='index' id='operator<,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator&lt;(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-9'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs.compare(typename sub_match&lt;BiIter&gt;::string_type(lhs.data(), lhs.size())) &gt; 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator>'></a></span><span class='indexparent'><a class='index' id='operator>,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator&gt;(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-10'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs &lt; lhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator>='></a></span><span class='indexparent'><a class='index' id='operator>=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator&gt;=(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-11'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs &lt; rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator<='></a></span><span class='indexparent'><a class='index' id='operator<=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator&lt;=(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-12'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(rhs &lt; lhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator==,sub_match'></a></span><span class='indexparent'><a class='index' id='sub_match,operator=='></a></span><code class='itemdecl'>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
                  const basic_string&lt;
                    typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-13'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.compare(typename sub_match&lt;BiIter&gt;::string_type(rhs.data(), rhs.size())) == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,sub_match'></a></span><span class='indexparent'><a class='index' id='sub_match,operator!='></a></span><code class='itemdecl'>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
                  const basic_string&lt;
                    typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-14'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs == rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,sub_match'></a></span><span class='indexparent'><a class='index' id='sub_match,operator<'></a></span><code class='itemdecl'>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                 const basic_string&lt;
                   typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-15'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.compare(typename sub_match&lt;BiIter&gt;::string_type(rhs.data(), rhs.size())) &lt; 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,sub_match'></a></span><span class='indexparent'><a class='index' id='sub_match,operator>'></a></span><code class='itemdecl'>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                 const basic_string&lt;
                   typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-16'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs &lt; lhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,sub_match'></a></span><span class='indexparent'><a class='index' id='sub_match,operator>='></a></span><code class='itemdecl'>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                  const basic_string&lt;
                    typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-17'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-17'>17</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs &lt; rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,sub_match'></a></span><span class='indexparent'><a class='index' id='sub_match,operator<='></a></span><code class='itemdecl'>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                  const basic_string&lt;
                    typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-18'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-18'>18</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(rhs &lt; lhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator=='></a></span><span class='indexparent'><a class='index' id='operator==,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator==(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                  const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-19'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-19'>19</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs.compare(lhs) == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator!='></a></span><span class='indexparent'><a class='index' id='operator!=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator!=(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                  const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-20'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-20'>20</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs == rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator<'></a></span><span class='indexparent'><a class='index' id='operator<,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&lt;(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                 const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-21'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-21'>21</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs.compare(lhs) &gt; 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator>'></a></span><span class='indexparent'><a class='index' id='operator>,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&gt;(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                 const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-22'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-22'>22</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs &lt; lhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator>='></a></span><span class='indexparent'><a class='index' id='operator>=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&gt;=(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                  const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-23'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-23'>23</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs &lt; rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator<='></a></span><span class='indexparent'><a class='index' id='operator<=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&lt;=(const typename iterator_traits&lt;BiIter&gt;::value_type* lhs,
                  const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-24'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-24'>24</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(rhs &lt; lhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator=='></a></span><span class='indexparent'><a class='index' id='operator==,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
                  const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-25'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-25'>25</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.compare(rhs) == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator!='></a></span><span class='indexparent'><a class='index' id='operator!=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
                  const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-26'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-26'>26</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs == rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator<'></a></span><span class='indexparent'><a class='index' id='operator<,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                 const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-27'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-27'>27</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.compare(rhs) &lt; 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator>'></a></span><span class='indexparent'><a class='index' id='operator>,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                 const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-28'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-28'>28</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs &lt; lhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator>='></a></span><span class='indexparent'><a class='index' id='operator>=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                  const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-29'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-29'>29</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs &lt; rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator<='></a></span><span class='indexparent'><a class='index' id='operator<=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                  const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-30'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-30'>30</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(rhs &lt; lhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator=='></a></span><span class='indexparent'><a class='index' id='operator==,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator==(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                  const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-31'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-31'>31</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs.compare(typename sub_match&lt;BiIter&gt;::string_type(1, lhs)) == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator!='></a></span><span class='indexparent'><a class='index' id='operator!=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator!=(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                  const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-32'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-32'>32</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs == rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator<'></a></span><span class='indexparent'><a class='index' id='operator<,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&lt;(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                 const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-33'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-33'>33</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs.compare(typename sub_match&lt;BiIter&gt;::string_type(1, lhs)) &gt; 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator>'></a></span><span class='indexparent'><a class='index' id='operator>,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&gt;(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                 const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-34'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-34'>34</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs &lt; lhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator>='></a></span><span class='indexparent'><a class='index' id='operator>=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&gt;=(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                  const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-35'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-35'>35</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs &lt; rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator<='></a></span><span class='indexparent'><a class='index' id='operator<=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&lt;=(const typename iterator_traits&lt;BiIter&gt;::value_type&amp; lhs,
                  const sub_match&lt;BiIter&gt;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-36'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-36'>36</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(rhs &lt; lhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator=='></a></span><span class='indexparent'><a class='index' id='operator==,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
                  const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-37'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-37'>37</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.compare(typename sub_match&lt;BiIter&gt;::string_type(1, rhs)) == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator!='></a></span><span class='indexparent'><a class='index' id='operator!=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
                  const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-38'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-38'>38</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs == rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator<'></a></span><span class='indexparent'><a class='index' id='operator<,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                 const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-39'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-39'>39</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>lhs.compare(typename sub_match&lt;BiIter&gt;::string_type(1, rhs)) &lt; 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator>'></a></span><span class='indexparent'><a class='index' id='operator>,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                 const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-40'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-40'>40</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rhs &lt; lhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator>='></a></span><span class='indexparent'><a class='index' id='operator>=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                  const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-41'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-41'>41</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(lhs &lt; rhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sub_match,operator<='></a></span><span class='indexparent'><a class='index' id='operator<=,sub_match'></a></span><code class='itemdecl'>
template &lt;class BiIter&gt;
  bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                  const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-42'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-42'>42</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(rhs &lt; lhs)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_ostream'></a></span><span class='indexparent'><a class='index' id='sub_match,operator<<'></a></span><span class='indexparent'><a class='index' id='operator<<,sub_match'></a></span><code class='itemdecl'>
template &lt;class charT, class ST, class BiIter&gt;
  basic_ostream&lt;charT, ST&gt;&amp;
  operator&lt;&lt;(basic_ostream&lt;charT, ST&gt;&amp; os, const sub_match&lt;BiIter&gt;&amp; m);
</code></p><div class='itemdescr'></div><div class='para' id='submatch.op-43'><div class='marginalizedparent'><a class='marginalized' href='#submatch.op-43'>43</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>(os &lt;&lt; m.str())</span>.
</p></div></div></div></div><div id='results'><h2 ><a class='secnum' href='#results' style='min-width:88pt'>28.10</a> Class template <span class='texttt'>match_results</span> <a class='abbr_ref' href='re.results'>[re.results]</a></h2><div class='para' id='results-1'><div class='marginalizedparent'><a class='marginalized' href='#results-1'>1</a></div><p ><span class='indexparent'><a class='index' id='match_results'></a></span>Class template <span class='texttt'>match_results</span> denotes a collection of character
sequences representing the result of a regular expression
match. Storage for the collection is allocated and freed as necessary
by the member functions of class template <span class='texttt'>match_results</span>.</p></div><div class='para' id='results-2'><div class='marginalizedparent'><a class='marginalized' href='#results-2'>2</a></div><p ><span class='indexparent'><a class='index' id='requirements,container'></a></span><span class='indexparent'><a class='index' id='requirements,sequence'></a></span><span class='indexparent'><a class='index' id='match_results,as_sequence'></a></span>The class template <span class='texttt'>match_results</span> satisfies the requirements of an
allocator-aware container and of a sequence container
(<a href='container.requirements.general'>[container.requirements.general]</a>, <a href='sequence.reqmts'>[sequence.reqmts]</a>)
except that only operations defined for const-qualified
sequence containers are supported and
that the semantics of comparison functions are different from those
required for a container.</p></div><div class='para' id='results-3'><div class='marginalizedparent'><a class='marginalized' href='#results-3'>3</a></div><p >A default-constructed <span class='texttt'>match_results</span> object has no fully established result state. A
match result is <a class='hidden_link' href='#def:ready' id='def:ready'><i>ready</i></a> when, as a consequence of a completed regular expression match
modifying such an object, its result state becomes fully established. The effects of calling
most member functions from a <span class='texttt'>match_results</span> object that is not ready are undefined.</p></div><div class='para' id='results-4'><div class='marginalizedparent'><a class='marginalized' href='#results-4'>4</a></div><p ><span class='indexparent'><a class='index' id='match_results,matched'></a></span>The <span class='texttt'>sub_match</span> object stored at index 0 represents sub-expression 0,
i.e., the whole match. In this case the <span class='texttt'>sub_match</span> member
<span class='texttt'>matched</span> is always <span class='texttt'>true</span>. The <span class='texttt'>sub_match</span>
object stored at index <span class='texttt'>n</span> denotes what matched the marked
sub-expression <span class='texttt'>n</span> within the matched expression. If the
sub-expression <span class='texttt'>n</span> participated in a regular expression
match then the <span class='texttt'>sub_match</span> member <span class='texttt'>matched</span> evaluates to <span class='texttt'>true</span>, and
members <span class='texttt'>first</span> and <span class='texttt'>second</span> denote the range of characters
<span class='texttt'>[first, second)</span> which formed that
match. Otherwise <span class='texttt'>matched</span> is <span class='texttt'>false</span>, and members <span class='texttt'>first</span>
and <span class='texttt'>second</span> point to the end of the sequence
that was searched. [&nbsp;<i>Note:</i> The <span class='texttt'>sub_match</span> objects representing
different sub-expressions that did not participate in a regular expression
match need not be distinct.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><pre class='codeblock'>
namespace std {
  template &lt;class BidirectionalIterator,
            class Allocator = allocator&lt;sub_match&lt;BidirectionalIterator&gt;&gt;&gt;
  class match_results {
  public:
     using value_type      = sub_match&lt;BidirectionalIterator&gt;;
     using const_reference = const value_type&amp;;
     using reference       = value_type&amp;;
     using const_iterator  = <i>implementation-defined</i>;
     using iterator        = const_iterator;
     using difference_type =
             typename iterator_traits&lt;BidirectionalIterator&gt;::difference_type;
     using size_type       = typename allocator_traits&lt;Allocator&gt;::size_type;
     using allocator_type  = Allocator;
     using char_type       =
             typename iterator_traits&lt;BidirectionalIterator&gt;::value_type;
     using string_type     = basic_string&lt;char_type&gt;;

     <span class='comment'>// <a href='re.results.const'>[re.results.const]</a>, construct/copy/destroy
</span>     explicit match_results(const Allocator&amp; a = Allocator());
     match_results(const match_results&amp; m);
     match_results(match_results&amp;&amp; m) noexcept;
     match_results&amp; operator=(const match_results&amp; m);
     match_results&amp; operator=(match_results&amp;&amp; m);
     ~match_results();

     <span class='comment'>// <a href='re.results.state'>[re.results.state]</a>, state
</span>     bool ready() const;

     <span class='comment'>// <a href='re.results.size'>[re.results.size]</a>, size
</span>     size_type size() const;
     size_type max_size() const;
     bool empty() const;

     <span class='comment'>// <a href='re.results.acc'>[re.results.acc]</a>, element access
</span>     difference_type length(size_type sub = 0) const;
     difference_type position(size_type sub = 0) const;
     string_type str(size_type sub = 0) const;
     const_reference operator[](size_type n) const;

     const_reference prefix() const;
     const_reference suffix() const;
     const_iterator begin() const;
     const_iterator end() const;
     const_iterator cbegin() const;
     const_iterator cend() const;

     <span class='comment'>// <a href='re.results.form'>[re.results.form]</a>, format
</span>     template &lt;class OutputIter&gt;
      OutputIter
      format(OutputIter out,
             const char_type* fmt_first, const char_type* fmt_last,
             regex_constants::match_flag_type flags =
              regex_constants::format_default) const;
     template &lt;class OutputIter, class ST, class SA&gt;
       OutputIter
       format(OutputIter out,
              const basic_string&lt;char_type, ST, SA&gt;&amp; fmt,
              regex_constants::match_flag_type flags =
                regex_constants::format_default) const;
     template &lt;class ST, class SA&gt;
      basic_string&lt;char_type, ST, SA&gt;
      format(const basic_string&lt;char_type, ST, SA&gt;&amp; fmt,
             regex_constants::match_flag_type flags =
               regex_constants::format_default) const;
     string_type
     format(const char_type* fmt,
            regex_constants::match_flag_type flags =
              regex_constants::format_default) const;

     <span class='comment'>// <a href='re.results.all'>[re.results.all]</a>, allocator
</span>     allocator_type get_allocator() const;

     <span class='comment'>// <a href='re.results.swap'>[re.results.swap]</a>, swap
</span>     void swap(match_results&amp; that);
  };
}
</pre></div><div id='results.const'><h3 ><a class='secnum' href='#results.const' style='min-width:103pt'>28.10.1</a> <span class='texttt'>match_results</span> constructors <a class='abbr_ref' href='re.results.const'>[re.results.const]</a></h3><div class='para' id='results.const-1'><div class='marginalizedparent'><a class='marginalized' href='#results.const-1'>1</a></div><p >In all <span class='texttt'>match_results</span> constructors, a copy of the <span class='texttt'>Allocator</span> argument
shall be used for any memory allocation performed by the constructor
or member functions during the lifetime of the object.</p><p ><span class='indexparent'><a class='index' id='match_results,constructor'></a></span><code class='itemdecl'>
match_results(const Allocator&amp; a = Allocator());
</code></p></div><div class='itemdescr'></div><div class='para' id='results.const-2'><div class='marginalizedparent'><a class='marginalized' href='#results.const-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an object of class <span class='texttt'>match_results</span>.</p></div></div><div class='para' id='results.const-3'><div class='marginalizedparent'><a class='marginalized' href='#results.const-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>ready()</span> returns <span class='texttt'>false</span>.
<span class='texttt'>size()</span> returns <span class='texttt'>0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,constructor'></a></span><code class='itemdecl'>
match_results(const match_results&amp; m);
</code></p><div class='itemdescr'></div><div class='para' id='results.const-4'><div class='marginalizedparent'><a class='marginalized' href='#results.const-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an object of class <span class='texttt'>match_results</span>, as a
copy of <span class='texttt'>m</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,constructor'></a></span><code class='itemdecl'>
match_results(match_results&amp;&amp; m) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='results.const-5'><div class='marginalizedparent'><a class='marginalized' href='#results.const-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs an object of class <span class='texttt'>match_results</span> from <span class='texttt'>m</span>
satisfying the same postconditions as Table <a href='#tab:re:results:assign'>[tab:re:results:assign]</a>. Additionally,
the stored <span class='texttt'>Allocator</span> value is move constructed from <span class='texttt'>m.get_allocator()</span>.</p></div></div><div class='para' id='results.const-6'><div class='marginalizedparent'><a class='marginalized' href='#results.const-6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,operator='></a></span><span class='indexparent'><a class='index' id='operator=,match_results'></a></span><code class='itemdecl'>
match_results&amp; operator=(const match_results&amp; m);
</code></p><div class='itemdescr'></div><div class='para' id='results.const-7'><div class='marginalizedparent'><a class='marginalized' href='#results.const-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>  Assigns <span class='texttt'>m</span> to <span class='texttt'>*this</span>. The postconditions of this
function are indicated in Table <a href='#tab:re:results:assign'>[tab:re:results:assign]</a>.
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,operator='></a></span><span class='indexparent'><a class='index' id='operator=,match_results'></a></span><code class='itemdecl'>
match_results&amp; operator=(match_results&amp;&amp; m);
</code></p><div class='itemdescr'></div><div class='para' id='results.const-8'><div class='marginalizedparent'><a class='marginalized' href='#results.const-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Move-assigns <span class='texttt'>m</span> to <span class='texttt'>*this</span>. The postconditions of this function
are indicated in Table <a href='#tab:re:results:assign'>[tab:re:results:assign]</a>.
</p></div></div><div class='numberedTable' id='tab:re:results:assign'>Table <a href='#tab:re:results:assign'>128</a> — <span class='texttt'>match_results</span> assignment operator effects<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Element</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 



<span class='texttt'>ready()</span>         </td><td class='justify'> <span class='texttt'>m.ready()</span>       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>size()</span>          </td><td class='justify'> <span class='texttt'>m.size()</span>        </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>str(n)</span>          </td><td class='justify'> <span class='texttt'>m.str(n)</span> for all integers <span class='texttt'>n &lt; m.size()</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>prefix()</span>        </td><td class='justify'> <span class='texttt'>m.prefix()</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>suffix()</span>        </td><td class='justify'> <span class='texttt'>m.suffix()</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>(*this)[n]</span>      </td><td class='justify'> <span class='texttt'>m[n]</span> for all integers <span class='texttt'>n &lt; m.size()</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>length(n)</span>       </td><td class='justify'> <span class='texttt'>m.length(n)</span> for all integers <span class='texttt'>n &lt; m.size()</span> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>position(n)</span>     </td><td class='justify'> <span class='texttt'>m.position(n)</span> for all integers <span class='texttt'>n &lt; m.size()</span> </td></tr></table></div></div><div id='results.state'><h3 ><a class='secnum' href='#results.state' style='min-width:103pt'>28.10.2</a> <span class='texttt'>match_results</span> state <a class='abbr_ref' href='re.results.state'>[re.results.state]</a></h3><p ><span class='indexparent'><a class='index' id='match_results,state'></a></span><span class='indexparent'><a class='index' id='state,match_results'></a></span><code class='itemdecl'>
bool ready() const;
</code></p><div class='itemdescr'></div><div class='para' id='results.state-1'><div class='marginalizedparent'><a class='marginalized' href='#results.state-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>*this</span> has a fully established result state, otherwise
<span class='texttt'>false</span>.
</p></div></div></div><div id='results.size'><h3 ><a class='secnum' href='#results.size' style='min-width:103pt'>28.10.3</a> <span class='texttt'>match_results</span> size <a class='abbr_ref' href='re.results.size'>[re.results.size]</a></h3><p ><span class='indexparent'><a class='index' id='match_results,size'></a></span><span class='indexparent'><a class='index' id='size,match_results'></a></span><code class='itemdecl'>
size_type size() const;
</code></p><div class='itemdescr'></div><div class='para' id='results.size-1'><div class='marginalizedparent'><a class='marginalized' href='#results.size-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> One plus the number of marked sub-expressions in the
regular expression that was matched if <span class='texttt'>*this</span> represents the
result of a successful match.  Otherwise returns <span class='texttt'>0</span>.
[&nbsp;<i>Note:</i> The state of a <span class='texttt'>match_results</span> object can be modified
only by passing that object to <span class='texttt'>regex_match</span> or <span class='texttt'>regex_search</span>.
Sections <a href='re.alg.match'>[re.alg.match]</a> and <a href='re.alg.search'>[re.alg.search]</a> specify the
effects of those algorithms on their <span class='texttt'>match_results</span> arguments.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,max_size'></a></span><span class='indexparent'><a class='index' id='max_size,match_results'></a></span><code class='itemdecl'>
size_type max_size() const;
</code></p><div class='itemdescr'></div><div class='para' id='results.size-2'><div class='marginalizedparent'><a class='marginalized' href='#results.size-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The maximum number of <span class='texttt'>sub_match</span> elements that can be
stored in <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,empty'></a></span><span class='indexparent'><a class='index' id='empty,match_results'></a></span><code class='itemdecl'>
bool empty() const;
</code></p><div class='itemdescr'></div><div class='para' id='results.size-3'><div class='marginalizedparent'><a class='marginalized' href='#results.size-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>size() == 0</span>.
</p></div></div></div><div id='results.acc'><h3 ><a class='secnum' href='#results.acc' style='min-width:103pt'>28.10.4</a> <span class='texttt'>match_results</span> element access <a class='abbr_ref' href='re.results.acc'>[re.results.acc]</a></h3><p ><span class='indexparent'><a class='index' id='length,match_results'></a></span><span class='indexparent'><a class='index' id='match_results,length'></a></span><code class='itemdecl'>
difference_type length(size_type sub = 0) const;
</code></p><div class='itemdescr'></div><div class='para' id='results.acc-1'><div class='marginalizedparent'><a class='marginalized' href='#results.acc-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>ready() == true</span>.</p></div></div><div class='para' id='results.acc-2'><div class='marginalizedparent'><a class='marginalized' href='#results.acc-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>(*this)[sub].length()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='position,match_results'></a></span><span class='indexparent'><a class='index' id='match_results,position'></a></span><code class='itemdecl'>
difference_type position(size_type sub = 0) const;
</code></p><div class='itemdescr'></div><div class='para' id='results.acc-3'><div class='marginalizedparent'><a class='marginalized' href='#results.acc-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>ready() == true</span>.</p></div></div><div class='para' id='results.acc-4'><div class='marginalizedparent'><a class='marginalized' href='#results.acc-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> The distance from the start of the target sequence
to <span class='texttt'>(*this)[sub].first</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,str'></a></span><span class='indexparent'><a class='index' id='str,match_results'></a></span><code class='itemdecl'>
string_type str(size_type sub = 0) const;
</code></p><div class='itemdescr'></div><div class='para' id='results.acc-5'><div class='marginalizedparent'><a class='marginalized' href='#results.acc-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>ready() == true</span>.</p></div></div><div class='para' id='results.acc-6'><div class='marginalizedparent'><a class='marginalized' href='#results.acc-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>string_type((*this)[sub])</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,operator[]'></a></span><span class='indexparent'><a class='index' id='operator[],match_results'></a></span><code class='itemdecl'>
const_reference operator[](size_type n) const;
</code></p><div class='itemdescr'></div><div class='para' id='results.acc-7'><div class='marginalizedparent'><a class='marginalized' href='#results.acc-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>ready() == true</span>.</p></div></div><div class='para' id='results.acc-8'><div class='marginalizedparent'><a class='marginalized' href='#results.acc-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to the <span class='texttt'>sub_match</span> object representing the
character sequence that matched marked sub-expression <span class='texttt'>n</span>. If <span class='texttt'>n == 0</span>
then returns a reference to a <span class='texttt'>sub_match</span> object representing the
character sequence that matched the whole regular expression. If
<span class='texttt'>n &gt;= size()</span> then returns a <span class='texttt'>sub_match</span> object representing an
unmatched sub-expression.
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,prefix'></a></span><span class='indexparent'><a class='index' id='prefix,match_results'></a></span><code class='itemdecl'>
const_reference prefix() const;
</code></p><div class='itemdescr'></div><div class='para' id='results.acc-9'><div class='marginalizedparent'><a class='marginalized' href='#results.acc-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>ready() == true</span>.</p></div></div><div class='para' id='results.acc-10'><div class='marginalizedparent'><a class='marginalized' href='#results.acc-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to the <span class='texttt'>sub_match</span> object representing the
character sequence from the start of the string being
matched/searched to the start of the match found. 
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,suffix'></a></span><span class='indexparent'><a class='index' id='suffix,match_results'></a></span><code class='itemdecl'>
const_reference suffix() const;
</code></p><div class='itemdescr'></div><div class='para' id='results.acc-11'><div class='marginalizedparent'><a class='marginalized' href='#results.acc-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>ready() == true</span>.</p></div></div><div class='para' id='results.acc-12'><div class='marginalizedparent'><a class='marginalized' href='#results.acc-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to the <span class='texttt'>sub_match</span> object representing the
character sequence from the end of the match found to the end of the
string being matched/searched. 
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,begin'></a></span><span class='indexparent'><a class='index' id='begin,match_results'></a></span><code class='itemdecl'>
const_iterator begin() const;
const_iterator cbegin() const;
</code></p><div class='itemdescr'></div><div class='para' id='results.acc-13'><div class='marginalizedparent'><a class='marginalized' href='#results.acc-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> A starting iterator that enumerates over all the
sub-expressions stored in <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,end'></a></span><span class='indexparent'><a class='index' id='end,match_results'></a></span><code class='itemdecl'>
const_iterator end() const;
const_iterator cend() const;
</code></p><div class='itemdescr'></div><div class='para' id='results.acc-14'><div class='marginalizedparent'><a class='marginalized' href='#results.acc-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> A terminating iterator that enumerates over all the
sub-expressions stored in <span class='texttt'>*this</span>. 
</p></div></div></div><div id='results.form'><h3 ><a class='secnum' href='#results.form' style='min-width:103pt'>28.10.5</a> <span class='texttt'>match_results</span> formatting <a class='abbr_ref' href='re.results.form'>[re.results.form]</a></h3><p ><span class='indexparent'><a class='index' id='match_results,format'></a></span><span class='indexparent'><a class='index' id='format,match_results'></a></span><code class='itemdecl'>
template &lt;class OutputIter&gt;
  OutputIter format(OutputIter out,
                    const char_type* fmt_first, const char_type* fmt_last,
                    regex_constants::match_flag_type flags =
                      regex_constants::format_default) const;
</code></p><div class='itemdescr'></div><div class='para' id='results.form-1'><div class='marginalizedparent'><a class='marginalized' href='#results.form-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>ready() == true</span> and <span class='texttt'>OutputIter</span> shall satisfy the requirements for an
Output Iterator (<a href='output.iterators'>[output.iterators]</a>).</p></div></div><div class='para' id='results.form-2'><div class='marginalizedparent'><a class='marginalized' href='#results.form-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Copies the character sequence <span class='texttt'>[fmt_first, fmt_last)</span> to
OutputIter <span class='texttt'>out</span>.  Replaces each format specifier or escape
sequence in the copied range with either the character(s) it represents or
the sequence of characters within <span class='texttt'>*this</span> to which it refers.
The bitmasks specified in <span class='texttt'>flags</span> determine which format
specifiers and escape sequences are recognized.</p></div></div><div class='para' id='results.form-3'><div class='marginalizedparent'><a class='marginalized' href='#results.form-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>out</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,format'></a></span><span class='indexparent'><a class='index' id='format,match_results'></a></span><code class='itemdecl'>
template &lt;class OutputIter, class ST, class SA&gt;
  OutputIter format(OutputIter out,
                    const basic_string&lt;char_type, ST, SA&gt;&amp; fmt,
                    regex_constants::match_flag_type flags =
                      regex_constants::format_default) const;
</code></p><div class='itemdescr'></div><div class='para' id='results.form-4'><div class='marginalizedparent'><a class='marginalized' href='#results.form-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
return format(out, fmt.data(), fmt.data() + fmt.size(), flags);
</pre></div></div><p ><span class='indexparent'><a class='index' id='match_results,format'></a></span><span class='indexparent'><a class='index' id='format,match_results'></a></span><code class='itemdecl'>
template &lt;class ST, class SA&gt;
  basic_string&lt;char_type, ST, SA&gt;
  format(const basic_string&lt;char_type, ST, SA&gt;&amp; fmt,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;
</code></p><div class='itemdescr'></div><div class='para' id='results.form-5'><div class='marginalizedparent'><a class='marginalized' href='#results.form-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>ready() == true</span>.</p></div></div><div class='para' id='results.form-6'><div class='marginalizedparent'><a class='marginalized' href='#results.form-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an empty string <span class='texttt'>result</span> of type <span class='texttt'>basic_string&lt;char_type, ST, SA&gt;</span> and
calls:
</p><pre class='codeblock'>
format(back_inserter(result), fmt, flags);
</pre></div></div><div class='para' id='results.form-7'><div class='marginalizedparent'><a class='marginalized' href='#results.form-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>result</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,format'></a></span><span class='indexparent'><a class='index' id='format,match_results'></a></span><code class='itemdecl'>
string_type
  format(const char_type* fmt,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;
</code></p><div class='itemdescr'></div><div class='para' id='results.form-8'><div class='marginalizedparent'><a class='marginalized' href='#results.form-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>ready() == true</span>.</p></div></div><div class='para' id='results.form-9'><div class='marginalizedparent'><a class='marginalized' href='#results.form-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an empty string <span class='texttt'>result</span> of type <span class='texttt'>string_type</span> and
calls:
</p><pre class='codeblock'>
format(back_inserter(result),
       fmt, fmt + char_traits&lt;char_type&gt;::length(fmt), flags);
</pre></div></div><div class='para' id='results.form-10'><div class='marginalizedparent'><a class='marginalized' href='#results.form-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>result</span>.
</p></div></div></div><div id='results.all'><h3 ><a class='secnum' href='#results.all' style='min-width:103pt'>28.10.6</a> <span class='texttt'>match_results</span> allocator <a class='abbr_ref' href='re.results.all'>[re.results.all]</a></h3><p ><span class='indexparent'><a class='index' id='get_allocator,match_results'></a></span><span class='indexparent'><a class='index' id='match_results,get_allocator'></a></span><code class='itemdecl'>
allocator_type get_allocator() const;
</code></p><div class='itemdescr'></div><div class='para' id='results.all-1'><div class='marginalizedparent'><a class='marginalized' href='#results.all-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A copy of the Allocator that was passed to the object's constructor or, if that
allocator has been replaced, a copy of the most recent replacement.
</p></div></div></div><div id='results.swap'><h3 ><a class='secnum' href='#results.swap' style='min-width:103pt'>28.10.7</a> <span class='texttt'>match_results</span> swap <a class='abbr_ref' href='re.results.swap'>[re.results.swap]</a></h3><p ><span class='indexparent'><a class='index' id='match_results,swap'></a></span><span class='indexparent'><a class='index' id='swap,match_results'></a></span><code class='itemdecl'>
void swap(match_results&amp; that);
</code></p><div class='itemdescr'></div><div class='para' id='results.swap-1'><div class='marginalizedparent'><a class='marginalized' href='#results.swap-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Swaps the contents of the two sequences.</p></div></div><div class='para' id='results.swap-2'><div class='marginalizedparent'><a class='marginalized' href='#results.swap-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>*this</span> contains the sequence of matched
sub-expressions that were in <span class='texttt'>that</span>, <span class='texttt'>that</span> contains the
sequence of matched sub-expressions that were in <span class='texttt'>*this</span>.</p></div></div><div class='para' id='results.swap-3'><div class='marginalizedparent'><a class='marginalized' href='#results.swap-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i> Constant time.
</p></div></div><p ><span class='indexparent'><a class='index' id='match_results,swap'></a></span><span class='indexparent'><a class='index' id='swap,match_results'></a></span><code class='itemdecl'>
template &lt;class BidirectionalIterator, class Allocator&gt;
  void swap(match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
            match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
</code></p><div class='para' id='results.swap-4'><div class='marginalizedparent'><a class='marginalized' href='#results.swap-4'>4</a></div><p ><i>Effects:</i> As if by <span class='texttt'>m1.swap(m2)</span>.</p></div></div><div id='results.nonmember'><h3 ><a class='secnum' href='#results.nonmember' style='min-width:103pt'>28.10.8</a> <span class='texttt'>match_results</span> non-member functions <a class='abbr_ref' href='re.results.nonmember'>[re.results.nonmember]</a></h3><p ><span class='indexparent'><a class='index' id='operator==,match_results'></a></span><span class='indexparent'><a class='index' id='match_results,operator=='></a></span><code class='itemdecl'>
template &lt;class BidirectionalIterator, class Allocator&gt;
bool operator==(const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
                const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
</code></p><div class='itemdescr'></div><div class='para' id='results.nonmember-1'><div class='marginalizedparent'><a class='marginalized' href='#results.nonmember-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span> if neither match result is ready, <span class='texttt'>false</span> if one match result is ready and the
other is not. If both match results are ready, returns <span class='texttt'>true</span> only if:</p><ul class='itemize'><li id='results.nonmember-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#results.nonmember-1.1'>(1.1)</a></div><p ><span class='texttt'>m1.empty() &amp;&amp; m2.empty()</span>, or</p></li><li id='results.nonmember-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#results.nonmember-1.2'>(1.2)</a></div><p ><span class='texttt'>!m1.empty() &amp;&amp; !m2.empty()</span>, and the following conditions are satisfied:</p><ul class='itemize'><li id='results.nonmember-1.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#results.nonmember-1.2.1'>(1.2.1)</a></div><p ><span class='texttt'>m1.prefix() == m2.prefix()</span>,</p></li><li id='results.nonmember-1.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#results.nonmember-1.2.2'>(1.2.2)</a></div><p ><span class='texttt'>m1.size() == m2.size() &amp;&amp; equal(m1.begin(), m1.end(), m2.begin())</span>, and</p></li><li id='results.nonmember-1.2.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#results.nonmember-1.2.3'>(1.2.3)</a></div><p ><span class='texttt'>m1.suffix() == m2.suffix()</span>.
</p></li></ul></li></ul><p >[&nbsp;<i>Note:</i> The algorithm <span class='texttt'>equal</span> is defined in Clause <a href='algorithms'>[algorithms]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,match_results'></a></span><span class='indexparent'><a class='index' id='match_results,operator!='></a></span><code class='itemdecl'>
template &lt;class BidirectionalIterator, class Allocator&gt;
bool operator!=(const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
                const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
</code></p><div class='itemdescr'></div><div class='para' id='results.nonmember-2'><div class='marginalizedparent'><a class='marginalized' href='#results.nonmember-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(m1 == m2)</span>.
</p></div></div></div></div><div id='alg'><h2 ><a class='secnum' href='#alg' style='min-width:88pt'>28.11</a> Regular expression algorithms <a class='abbr_ref' href='re.alg'>[re.alg]</a></h2><div id='except'><h3 ><a class='secnum' href='#except' style='min-width:103pt'>28.11.1</a> exceptions <a class='abbr_ref' href='re.except'>[re.except]</a></h3><div class='para' id='except-1'><div class='marginalizedparent'><a class='marginalized' href='#except-1'>1</a></div><p >The algorithms described in this subclause may throw an exception
of type <span class='texttt'>regex_error</span>. If such an exception <span class='texttt'>e</span> is thrown,
<span class='texttt'>e.code()</span> shall return either <span class='texttt'>regex_constants::error_complexity</span>
or <span class='texttt'>regex_constants::error_stack</span>.</p></div></div><div id='alg.match'><h3 ><a class='secnum' href='#alg.match' style='min-width:103pt'>28.11.2</a> <span class='texttt'>regex_match</span> <a class='abbr_ref' href='re.alg.match'>[re.alg.match]</a></h3><p ><span class='indexparent'><a class='index' id='regex_match'></a></span><code class='itemdecl'>
template &lt;class BidirectionalIterator, class Allocator, class charT, class traits&gt;
  bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                   match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m,
                   const basic_regex&lt;charT, traits&gt;&amp; e,
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.match-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.match-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>  The type <span class='texttt'>BidirectionalIterator</span> shall satisfy the requirements
of a Bidirectional Iterator  (<a href='bidirectional.iterators'>[bidirectional.iterators]</a>).</p></div></div><div class='para' id='alg.match-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.match-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>  Determines whether there is a match between the
regular expression <span class='texttt'>e</span>, and all of the character
sequence <span class='texttt'>[first, last)</span>. The parameter <span class='texttt'>flags</span> is
used to control how the expression is matched against the character
sequence. When determining if there is a match, only potential matches
that match the entire character sequence are considered.
Returns <span class='texttt'>true</span> if such a match exists, <span class='texttt'>false</span>
otherwise.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
std::regex re("Get|GetValue");
std::cmatch m;
regex_search("GetValue", m, re);	<span class='comment'>// returns <span class='texttt'>true</span>, and <span class='texttt'>m[0]</span> contains <span class='texttt'>"Get"</span>
</span>regex_match ("GetValue", m, re);	<span class='comment'>// returns <span class='texttt'>true</span>, and <span class='texttt'>m[0]</span> contains <span class='texttt'>"GetValue"</span>
</span>regex_search("GetValues", m, re);	<span class='comment'>// returns <span class='texttt'>true</span>, and <span class='texttt'>m[0]</span> contains <span class='texttt'>"Get"</span>
</span>regex_match ("GetValues", m, re);	<span class='comment'>// returns <span class='texttt'>false</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div class='para' id='alg.match-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.match-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>m.ready() == true</span> in all cases.
If the function returns <span class='texttt'>false</span>, then the effect
on parameter <span class='texttt'>m</span> is unspecified except that <span class='texttt'>m.size()</span>
returns <span class='texttt'>0</span> and <span class='texttt'>m.empty()</span> returns <span class='texttt'>true</span>.
Otherwise the effects on parameter <span class='texttt'>m</span> are given in
Table <a href='#tab:re:alg:match'>[tab:re:alg:match]</a>.
</p></div></div><div class='numberedTable' id='tab:re:alg:match'>Table <a href='#tab:re:alg:match'>129</a> — Effects of <span class='texttt'>regex_match</span> algorithm<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Element</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 
 



<span class='texttt'>m.size()</span>
</td><td class='justify'>
<span class='texttt'>1 + e.mark_count()</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m.empty()</span>
</td><td class='justify'>
<span class='texttt'>false</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m.prefix().first</span>
</td><td class='justify'>
<span class='texttt'>first</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m.prefix().second</span>
</td><td class='justify'>
<span class='texttt'>first</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m.prefix().matched</span>
</td><td class='justify'>
<span class='texttt'>false</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m.suffix().first</span>
</td><td class='justify'>
<span class='texttt'>last</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m.suffix().second</span>
</td><td class='justify'>
<span class='texttt'>last</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m.suffix().matched</span>
</td><td class='justify'>
<span class='texttt'>false</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m[0].first</span>
</td><td class='justify'>
<span class='texttt'>first</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m[0].second</span>
</td><td class='justify'>
<span class='texttt'>last</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m[0].matched</span>
</td><td class='justify'>
<span class='texttt'>true</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m[n].first</span>
</td><td class='justify'>
For all integers <span class='texttt'>0 &lt; n &lt; m.size()</span>, the start of the sequence that matched
sub-expression <span class='texttt'>n</span>. Alternatively, if sub-expression <span class='texttt'>n</span> did not participate
in the match, then <span class='texttt'>last</span>.
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m[n].second</span>
</td><td class='justify'>
For all integers <span class='texttt'>0 &lt; n &lt; m.size()</span>, the end of the sequence that matched
sub-expression <span class='texttt'>n</span>. Alternatively, if sub-expression <span class='texttt'>n</span> did not participate
in the match, then <span class='texttt'>last</span>.
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m[n].matched</span>
</td><td class='justify'>
For all integers <span class='texttt'>0 &lt; n &lt; m.size()</span>, <span class='texttt'>true</span> if sub-expression <span class='texttt'>n</span> participated in
the match, <span class='texttt'>false</span> otherwise.
</td></tr></table></div><p ><span class='indexparent'><a class='index' id='regex_match'></a></span><code class='itemdecl'>
template &lt;class BidirectionalIterator, class charT, class traits&gt;
  bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                   const basic_regex&lt;charT, traits&gt;&amp; e,
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.match-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.match-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>  Behaves “as if” by constructing an instance of
<span class='texttt'>match_results&lt;BidirectionalIterator&gt; what</span>, and then
returning the result of
<span class='texttt'>regex_match(first, last, what, e, flags)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_match'></a></span><code class='itemdecl'>
template &lt;class charT, class Allocator, class traits&gt;
  bool regex_match(const charT* str,
                   match_results&lt;const charT*, Allocator&gt;&amp; m,
                   const basic_regex&lt;charT, traits&gt;&amp; e,
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.match-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.match-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>regex_match(str, str + char_traits&lt;charT&gt;::length(str), m, e, flags)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_match'></a></span><code class='itemdecl'>
template &lt;class ST, class SA, class Allocator, class charT, class traits&gt;
  bool regex_match(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                   match_results&lt;
                     typename basic_string&lt;charT, ST, SA&gt;::const_iterator,
                     Allocator&gt;&amp; m,
                   const basic_regex&lt;charT, traits&gt;&amp; e,
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.match-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.match-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>regex_match(s.begin(), s.end(), m, e, flags)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_match'></a></span><code class='itemdecl'>
template &lt;class charT, class traits&gt;
  bool regex_match(const charT* str,
                   const basic_regex&lt;charT, traits&gt;&amp; e,
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.match-7'><div class='marginalizedparent'><a class='marginalized' href='#alg.match-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>regex_match(str, str + char_traits&lt;charT&gt;::length(str), e, flags)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_match'></a></span><code class='itemdecl'>
template &lt;class ST, class SA, class charT, class traits&gt;
  bool regex_match(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                   const basic_regex&lt;charT, traits&gt;&amp; e,
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.match-8'><div class='marginalizedparent'><a class='marginalized' href='#alg.match-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>regex_match(s.begin(), s.end(), e, flags)</span>.
</p></div></div></div><div id='alg.search'><h3 ><a class='secnum' href='#alg.search' style='min-width:103pt'>28.11.3</a> <span class='texttt'>regex_search</span> <a class='abbr_ref' href='re.alg.search'>[re.alg.search]</a></h3><p ><span class='indexparent'><a class='index' id='regex_search'></a></span><code class='itemdecl'>
template &lt;class BidirectionalIterator, class Allocator, class charT, class traits&gt;
  bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                    match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.search-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.search-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> Type <span class='texttt'>BidirectionalIterator</span> shall satisfy the requirements of a Bidirectional
Iterator (<a href='bidirectional.iterators'>[bidirectional.iterators]</a>).</p></div></div><div class='para' id='alg.search-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.search-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Determines whether there is some sub-sequence within <span class='texttt'>[first, last)</span> that matches
the regular expression <span class='texttt'>e</span>. The parameter <span class='texttt'>flags</span> is used to control how the
expression is matched against the character sequence. Returns <span class='texttt'>true</span> if such a sequence
exists, <span class='texttt'>false</span> otherwise.</p></div></div><div class='para' id='alg.search-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.search-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>m.ready() == true</span> in all cases.
If the function returns <span class='texttt'>false</span>, then the effect
on parameter <span class='texttt'>m</span> is unspecified except that <span class='texttt'>m.size()</span>
returns <span class='texttt'>0</span> and <span class='texttt'>m.empty()</span> returns <span class='texttt'>true</span>.  Otherwise
the effects on parameter <span class='texttt'>m</span> are given in Table <a href='#tab:re:alg:search'>[tab:re:alg:search]</a>.
</p></div></div><div class='numberedTable' id='tab:re:alg:search'>Table <a href='#tab:re:alg:search'>130</a> — Effects of <span class='texttt'>regex_search</span> algorithm<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Element</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 
 



<span class='texttt'>m.size()</span>
</td><td class='justify'>
<span class='texttt'>1 + e.mark_count()</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m.empty()</span>
</td><td class='justify'>
<span class='texttt'>false</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m.prefix().first</span>
</td><td class='justify'>
<span class='texttt'>first</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m.prefix().second</span>
</td><td class='justify'>
<span class='texttt'>m[0].first</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m.prefix().matched</span>
</td><td class='justify'>
<span class='texttt'>m.prefix().first != m.prefix().second</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m.suffix().first</span>
</td><td class='justify'>
<span class='texttt'>m[0].second</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m.suffix().second</span>
</td><td class='justify'>
<span class='texttt'>last</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m.suffix().matched</span>
</td><td class='justify'>
<span class='texttt'>m.suffix().first != m.suffix().second</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m[0].first</span>
</td><td class='justify'>
The start of the sequence of characters that matched the regular expression
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m[0].second</span>
</td><td class='justify'>
The end of the sequence of characters that matched the regular expression
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m[0].matched</span>
</td><td class='justify'>
<span class='texttt'>true</span>
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m[n].first</span>
</td><td class='justify'>
For all integers <span class='texttt'>0 &lt; n &lt; m.size()</span>, the start of the sequence that
matched sub-expression <span class='texttt'>n</span>. Alternatively, if sub-expression <span class='texttt'>n</span>
did not participate in the match, then <span class='texttt'>last</span>.
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m[n].second</span>
</td><td class='justify'>
For all integers <span class='texttt'>0 &lt; n &lt; m.size()</span>, the end of the sequence that matched
sub-expression <span class='texttt'>n</span>. Alternatively, if sub-expression <span class='texttt'>n</span> did not
participate in the match, then <span class='texttt'>last</span> .
</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>m[n].matched</span>
</td><td class='justify'>
For all integers <span class='texttt'>0 &lt; n &lt; m.size()</span>, <span class='texttt'>true</span> if sub-expression <span class='texttt'>n</span>
participated in the match, <span class='texttt'>false</span> otherwise.
</td></tr></table></div><p ><span class='indexparent'><a class='index' id='regex_search'></a></span><code class='itemdecl'>
template &lt;class charT, class Allocator, class traits&gt;
bool regex_search(const charT* str, match_results&lt;const charT*, Allocator&gt;&amp; m,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.search-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.search-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> The result of <span class='texttt'>regex_search(str,
str + char_traits&lt;charT&gt;::length(str), m, e, flags)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_search'></a></span><code class='itemdecl'>
template &lt;class ST, class SA, class Allocator, class charT, class traits&gt;
  bool regex_search(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                    match_results&lt;
                      typename basic_string&lt;charT, ST, SA&gt;::const_iterator,
                      Allocator&gt;&amp; m,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.search-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.search-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> The result of <span class='texttt'>regex_search(s.begin(), s.end(), m,
e, flags)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_search'></a></span><code class='itemdecl'>
template &lt;class BidirectionalIterator, class charT, class traits&gt;
  bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.search-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.search-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>  Behaves “as if” by constructing an object <span class='texttt'>what</span>
of type <span class='texttt'>match_results&lt;BidirectionalIterator&gt;</span>, and then returning
the result of <span class='texttt'>regex_search(first, last, what, e, flags)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_search'></a></span><code class='itemdecl'>
template &lt;class charT, class traits&gt;
  bool regex_search(const charT* str,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.search-7'><div class='marginalizedparent'><a class='marginalized' href='#alg.search-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>regex_search(str, str + char_traits&lt;charT&gt;::length(str), e, flags)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_search'></a></span><code class='itemdecl'>
template &lt;class ST, class SA, class charT, class traits&gt;
  bool regex_search(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                    const basic_regex&lt;charT, traits&gt;&amp; e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.search-8'><div class='marginalizedparent'><a class='marginalized' href='#alg.search-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>regex_search(s.begin(), s.end(), e, flags)</span>.
</p></div></div></div><div id='alg.replace'><h3 ><a class='secnum' href='#alg.replace' style='min-width:103pt'>28.11.4</a> <span class='texttt'>regex_replace</span> <a class='abbr_ref' href='re.alg.replace'>[re.alg.replace]</a></h3><p ><span class='indexparent'><a class='index' id='regex_replace'></a></span><code class='itemdecl'>
template &lt;class OutputIterator, class BidirectionalIterator,
    class traits, class charT, class ST, class SA&gt;
  OutputIterator
  regex_replace(OutputIterator out,
                BidirectionalIterator first, BidirectionalIterator last,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT, ST, SA&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
template &lt;class OutputIterator, class BidirectionalIterator,
    class traits, class charT&gt;
  OutputIterator
  regex_replace(OutputIterator out,
                BidirectionalIterator first, BidirectionalIterator last,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.replace-1'><div class='marginalizedparent'><a class='marginalized' href='#alg.replace-1'>1</a></div><div class='itemdescr'><p ><span class='indexparent'><a class='index' id='format_no_copy'></a></span><span class='indexparent'><a class='index' id='format_first_only'></a></span><i>Effects:</i>
Constructs a <span class='texttt'>regex_iterator</span> object <span class='texttt'>i</span>
as if by
</p><pre class='codeblock'>
regex_iterator&lt;BidirectionalIterator, charT, traits&gt; i(first, last, e, flags)
</pre><p >and uses <span class='texttt'>i</span> to enumerate through all
of the matches <span class='texttt'>m</span> of type <span class='texttt'>match_results&lt;BidirectionalIterator&gt;</span>
that occur within the sequence <span class='texttt'>[first, last)</span>.
If no such
matches are found and
<span class='texttt'>!(flags &amp; regex_constants::format_no_copy)</span>, then calls
</p><pre class='codeblock'>
out = copy(first, last, out)
</pre><p >If any matches are found then, for each such match:
</p><ul class='itemize'><li id='alg.replace-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#alg.replace-1.1'>(1.1)</a></div><p >If <span class='texttt'>!(flags &amp; regex_constants::format_no_copy)</span>, calls
</p><pre class='codeblock'>
out = copy(m.prefix().first, m.prefix().second, out)
</pre></li><li id='alg.replace-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#alg.replace-1.2'>(1.2)</a></div><p >Then calls
</p><pre class='codeblock'>
out = m.format(out, fmt, flags)
</pre><p >for the first form of the function and
</p><pre class='codeblock'>
out = m.format(out, fmt, fmt + char_traits&lt;charT&gt;::length(fmt), flags)
</pre><p >for the second.
</p></li></ul><p >Finally, if such a match
is found and <span class='texttt'>!(flags &amp; regex_constants::format_no_copy)</span>,
calls
</p><pre class='codeblock'>
out = copy(last_m.suffix().first, last_m.suffix().second, out)
</pre><p >where <span class='texttt'>last_m</span> is a copy of the last match
found. If <span class='texttt'>flags &amp; regex_constants::format_first_only</span>
is nonzero, then only the first match found is replaced.</p></div></div><div class='para' id='alg.replace-2'><div class='marginalizedparent'><a class='marginalized' href='#alg.replace-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>out</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_replace'></a></span><code class='itemdecl'>
template &lt;class traits, class charT, class ST, class SA, class FST, class FSA&gt;
  basic_string&lt;charT, ST, SA&gt;
  regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT, FST, FSA&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
template &lt;class traits, class charT, class ST, class SA&gt;
  basic_string&lt;charT, ST, SA&gt;
  regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.replace-3'><div class='marginalizedparent'><a class='marginalized' href='#alg.replace-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an empty string <span class='texttt'>result</span> of
type <span class='texttt'>basic_string&lt;charT, ST, SA&gt;</span> and calls:
</p><pre class='codeblock'>
regex_replace(back_inserter(result), s.begin(), s.end(), e, fmt, flags);
</pre></div></div><div class='para' id='alg.replace-4'><div class='marginalizedparent'><a class='marginalized' href='#alg.replace-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>result</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_replace'></a></span><code class='itemdecl'>
template &lt;class traits, class charT, class ST, class SA&gt;
  basic_string&lt;charT&gt;
  regex_replace(const charT* s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const basic_string&lt;charT, ST, SA&gt;&amp; fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
template &lt;class traits, class charT&gt;
  basic_string&lt;charT&gt;
  regex_replace(const charT* s,
                const basic_regex&lt;charT, traits&gt;&amp; e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='alg.replace-5'><div class='marginalizedparent'><a class='marginalized' href='#alg.replace-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an empty string <span class='texttt'>result</span> of
type <span class='texttt'>basic_string&lt;charT&gt;</span> and calls:
</p><pre class='codeblock'>
regex_replace(back_inserter(result),
              s, s + char_traits&lt;charT&gt;::length(s), e, fmt, flags);
</pre></div></div><div class='para' id='alg.replace-6'><div class='marginalizedparent'><a class='marginalized' href='#alg.replace-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>result</span>.
</p></div></div></div></div><div id='iter'><h2 ><a class='secnum' href='#iter' style='min-width:88pt'>28.12</a> Regular expression iterators <a class='abbr_ref' href='re.iter'>[re.iter]</a></h2><div id='regiter'><h3 ><a class='secnum' href='#regiter' style='min-width:103pt'>28.12.1</a> Class template <span class='texttt'>regex_iterator</span> <a class='abbr_ref' href='re.regiter'>[re.regiter]</a></h3><div class='para' id='regiter-1'><div class='marginalizedparent'><a class='marginalized' href='#regiter-1'>1</a></div><p ><span class='indexparent'><a class='index' id='regex_iterator'></a></span><span class='indexparent'><a class='index' id='match_results'></a></span>The class template <span class='texttt'>regex_iterator</span> is an iterator adaptor.
It represents a new view of an existing iterator sequence, by
enumerating all the occurrences of a regular expression within that
sequence. A <span class='texttt'>regex_iterator</span> uses  <span class='texttt'>regex_search</span> to find successive
regular expression matches within the sequence from which it was
constructed.  After the iterator is constructed, and every time <span class='texttt'>operator++</span> is
used, the iterator finds and stores a value of
<span class='texttt'>match_results&lt;BidirectionalIterator&gt;</span>. If the end of the sequence is
reached (<span class='texttt'>regex_search</span> returns <span class='texttt'>false</span>), the iterator becomes equal to
the end-of-sequence iterator value. The default constructor
constructs an end-of-sequence iterator object,
which is the only legitimate iterator to be used for the end
condition. The result of <span class='texttt'>operator*</span> on an end-of-sequence iterator is not
defined. For any other iterator value a const
<span class='texttt'>match_results&lt;BidirectionalIterator&gt;&amp;</span> is returned. The result of
<span class='texttt'>operator-&gt;</span> on an end-of-sequence iterator is not defined. For any other
iterator value a <span class='texttt'>const match_results&lt;BidirectionalIterator&gt;*</span> is
returned. It is impossible to store things into <span class='texttt'>regex_iterator</span>s. Two
end-of-sequence iterators are always equal. An end-of-sequence
iterator is not equal to a non-end-of-sequence iterator. Two
non-end-of-sequence iterators are equal when they are constructed from
the same arguments. </p><pre class='codeblock'>
namespace std {
  template &lt;class BidirectionalIterator,
            class charT = typename iterator_traits&lt;
              BidirectionalIterator&gt;::value_type,
            class traits = regex_traits&lt;charT&gt;&gt;
  class regex_iterator {
  public:
     using regex_type        = basic_regex&lt;charT, traits&gt;;
     using iterator_category = forward_iterator_tag;
     using value_type        = match_results&lt;BidirectionalIterator&gt;;
     using difference_type   = ptrdiff_t;
     using pointer           = const value_type*;
     using reference         = const value_type&amp;;

     regex_iterator();
     regex_iterator(BidirectionalIterator a, BidirectionalIterator b,
                    const regex_type&amp; re,
                    regex_constants::match_flag_type m =
                      regex_constants::match_default);
     regex_iterator(BidirectionalIterator a, BidirectionalIterator b,
                    const regex_type&amp;&amp; re,
                    regex_constants::match_flag_type m =
                      regex_constants::match_default) = delete;
     regex_iterator(const regex_iterator&amp;);
     regex_iterator&amp; operator=(const regex_iterator&amp;);
     bool operator==(const regex_iterator&amp;) const;
     bool operator!=(const regex_iterator&amp;) const;
     const value_type&amp; operator*() const;
     const value_type* operator-&gt;() const;
     regex_iterator&amp; operator++();
     regex_iterator operator++(int);

  private:
     BidirectionalIterator                begin;  <span class='comment'>// <i>exposition only</i>
</span>     BidirectionalIterator                end;    <span class='comment'>// <i>exposition only</i>
</span>     const regex_type*                    pregex; <span class='comment'>// <i>exposition only</i>
</span>     regex_constants::match_flag_type     flags;  <span class='comment'>// <i>exposition only</i>
</span>     match_results&lt;BidirectionalIterator&gt; match;  <span class='comment'>// <i>exposition only</i>
</span>  };
}
</pre></div><div class='para' id='regiter-2'><div class='marginalizedparent'><a class='marginalized' href='#regiter-2'>2</a></div><p ><span class='indexparent'><a class='index' id='regex_iterator,end-of-sequence'></a></span>An object of type <span class='texttt'>regex_iterator</span> that is not an end-of-sequence iterator
holds a <i>zero-length match</i> if <span class='texttt'>match[0].matched == true</span> and
<span class='texttt'>match[0].first == match[0].second</span>. [&nbsp;<i>Note:</i> For
example, this can occur when the part of the regular expression that
matched consists only of an assertion (such as <code >'^'</code>, <code >'&#36;'</code>,
<span class='texttt'>'<span class='math'>\</span>b'</span>, <span class='texttt'>'<span class='math'>\</span>B'</span>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='regiter.cnstr'><h4 ><a class='secnum' href='#regiter.cnstr' style='min-width:118pt'>28.12.1.1</a> <span class='texttt'>regex_iterator</span> constructors <a class='abbr_ref' href='re.regiter.cnstr'>[re.regiter.cnstr]</a></h4><p ><span class='indexparent'><a class='index' id='regex_iterator,constructor'></a></span><code class='itemdecl'>
regex_iterator();
</code></p><div class='itemdescr'></div><div class='para' id='regiter.cnstr-1'><div class='marginalizedparent'><a class='marginalized' href='#regiter.cnstr-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs an end-of-sequence iterator.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_iterator,constructor'></a></span><code class='itemdecl'>
regex_iterator(BidirectionalIterator a, BidirectionalIterator b,
               const regex_type&amp; re,
               regex_constants::match_flag_type m = regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='regiter.cnstr-2'><div class='marginalizedparent'><a class='marginalized' href='#regiter.cnstr-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>  Initializes <span class='texttt'>begin</span> and <span class='texttt'>end</span> to
<span class='texttt'>a</span> and <span class='texttt'>b</span>, respectively, sets
<span class='texttt'>pregex</span> to <span class='texttt'>&amp;re</span>, sets <span class='texttt'>flags</span> to
<span class='texttt'>m</span>, then calls <span class='texttt'>regex_search(begin, end, match, *pregex, flags)</span>. If this
call returns <span class='texttt'>false</span> the constructor sets <span class='texttt'>*this</span> to the end-of-sequence
iterator.
</p></div></div></div><div id='regiter.comp'><h4 ><a class='secnum' href='#regiter.comp' style='min-width:118pt'>28.12.1.2</a> <span class='texttt'>regex_iterator</span> comparisons <a class='abbr_ref' href='re.regiter.comp'>[re.regiter.comp]</a></h4><p ><span class='indexparent'><a class='index' id='regex_iterator,operator=='></a></span><span class='indexparent'><a class='index' id='operator==,regex_iterator'></a></span><code class='itemdecl'>
bool operator==(const regex_iterator&amp; right) const;
</code></p><div class='itemdescr'></div><div class='para' id='regiter.comp-1'><div class='marginalizedparent'><a class='marginalized' href='#regiter.comp-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>*this</span> and <span class='texttt'>right</span> are both end-of-sequence
iterators or if the following conditions all hold:
</p><ul class='itemize'><li id='regiter.comp-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#regiter.comp-1.1'>(1.1)</a></div><p ><span class='texttt'>begin == right.begin</span>,
</p></li><li id='regiter.comp-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#regiter.comp-1.2'>(1.2)</a></div><p ><span class='texttt'>end == right.end</span>,
</p></li><li id='regiter.comp-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#regiter.comp-1.3'>(1.3)</a></div><p ><span class='texttt'>pregex == right.pregex</span>,
</p></li><li id='regiter.comp-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#regiter.comp-1.4'>(1.4)</a></div><p ><span class='texttt'>flags == right.flags</span>, and
</p></li><li id='regiter.comp-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#regiter.comp-1.5'>(1.5)</a></div><p ><span class='texttt'>match[0] == right.match[0]</span>;
</p></li></ul><p >otherwise <span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_iterator,operator!='></a></span><span class='indexparent'><a class='index' id='operator!=,regex_iterator'></a></span><code class='itemdecl'>
bool operator!=(const regex_iterator&amp; right) const;
</code></p><div class='itemdescr'></div><div class='para' id='regiter.comp-2'><div class='marginalizedparent'><a class='marginalized' href='#regiter.comp-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(*this == right)</span>.
</p></div></div></div><div id='regiter.deref'><h4 ><a class='secnum' href='#regiter.deref' style='min-width:118pt'>28.12.1.3</a> <span class='texttt'>regex_iterator</span> indirection <a class='abbr_ref' href='re.regiter.deref'>[re.regiter.deref]</a></h4><p ><span class='indexparent'><a class='index' id='regex_iterator,operator*'></a></span><span class='indexparent'><a class='index' id='operator*,regex_iterator'></a></span><code class='itemdecl'>
const value_type&amp; operator*() const;
</code></p><div class='itemdescr'></div><div class='para' id='regiter.deref-1'><div class='marginalizedparent'><a class='marginalized' href='#regiter.deref-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>match</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator->,regex_iterator'></a></span><span class='indexparent'><a class='index' id='regex_iterator,operator->'></a></span><code class='itemdecl'>
const value_type* operator-&gt;() const;
</code></p><div class='itemdescr'></div><div class='para' id='regiter.deref-2'><div class='marginalizedparent'><a class='marginalized' href='#regiter.deref-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>&amp;match</span>.
</p></div></div></div><div id='regiter.incr'><h4 ><a class='secnum' href='#regiter.incr' style='min-width:118pt'>28.12.1.4</a> <span class='texttt'>regex_iterator</span> increment <a class='abbr_ref' href='re.regiter.incr'>[re.regiter.incr]</a></h4><p ><span class='indexparent'><a class='index' id='regex_iterator,operator++'></a></span><span class='indexparent'><a class='index' id='operator++,regex_iterator'></a></span><span class='indexparent'><a class='index' id='regex_iterator,increment'></a></span><code class='itemdecl'>
regex_iterator&amp; operator++();
</code></p><div class='itemdescr'></div><div class='para' id='regiter.incr-1'><div class='marginalizedparent'><a class='marginalized' href='#regiter.incr-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs a local variable <span class='texttt'>start</span> of type <span class='texttt'>BidirectionalIterator</span> and
initializes it with the value of <span class='texttt'>match[0].second</span>.</p></div></div><div class='para' id='regiter.incr-2'><div class='marginalizedparent'><a class='marginalized' href='#regiter.incr-2'>2</a></div><div class='itemdescr'><p >If the iterator holds a zero-length match and <span class='texttt'>start == end</span> the operator
sets <span class='texttt'>*this</span> to the end-of-sequence iterator and returns <span class='texttt'>*this</span>.</p></div></div><div class='para' id='regiter.incr-3'><div class='marginalizedparent'><a class='marginalized' href='#regiter.incr-3'>3</a></div><div class='itemdescr'><p ><span class='indexparent'><a class='index' id='match_not_null'></a></span><span class='indexparent'><a class='index' id='match_continuous'></a></span>Otherwise, if the iterator holds a zero-length match the operator calls
<span class='texttt'>regex_search(start, end, match, *pregex, flags <span class='math'>|</span> regex_constants::match_not_null
<span class='math'>|</span> regex_constants::match_</span><br/><span class='texttt'>continuous)</span>. If the call returns <span class='texttt'>true</span> the operator
returns <span class='texttt'>*this</span>. Otherwise the operator increments <span class='texttt'>start</span> and continues as if
the most recent match was not a zero-length match.</p></div></div><div class='para' id='regiter.incr-4'><div class='marginalizedparent'><a class='marginalized' href='#regiter.incr-4'>4</a></div><div class='itemdescr'><p ><span class='indexparent'><a class='index' id='match_prev_avail'></a></span>If the most recent match was not a zero-length match, the operator sets
<span class='texttt'>flags</span> to <span class='texttt'>flags <span class='math'>|</span> regex_constants :: match_prev_avail</span> and
calls <span class='texttt'>regex_search(start, end, match, *pregex, flags)</span>. If the call returns
<span class='texttt'>false</span> the iterator sets <span class='texttt'>*this</span> to the end-of-sequence iterator. The
iterator then returns <span class='texttt'>*this</span>.</p></div></div><div class='para' id='regiter.incr-5'><div class='marginalizedparent'><a class='marginalized' href='#regiter.incr-5'>5</a></div><div class='itemdescr'><p >In all cases in which the call to <span class='texttt'>regex_search</span> returns <span class='texttt'>true</span>,
<span class='texttt'>match.prefix().first</span> shall be equal to the previous value of
<span class='texttt'>match[0].second</span>, and for each index <span class='texttt'>i</span> in the half-open range
<span class='texttt'>[0, match.size())</span> for which <span class='texttt'>match[i].matched</span> is <span class='texttt'>true</span>,
<span class='texttt'>match.position(i)</span>
shall return <span class='texttt'>distance(begin, match[i].first)</span>.</p></div></div><div class='para' id='regiter.incr-6'><div class='marginalizedparent'><a class='marginalized' href='#regiter.incr-6'>6</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> This means that <span class='texttt'>match.position(i)</span> gives the
offset from the beginning of the target sequence, which is often not
the same as the offset from the sequence passed in the call
to <span class='texttt'>regex_search</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='regiter.incr-7'><div class='marginalizedparent'><a class='marginalized' href='#regiter.incr-7'>7</a></div><div class='itemdescr'><p >It is unspecified how the implementation makes these adjustments.</p></div></div><div class='para' id='regiter.incr-8'><div class='marginalizedparent'><a class='marginalized' href='#regiter.incr-8'>8</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> This means that a compiler may call an
implementation-specific search function, in which case a user-defined
specialization of <span class='texttt'>regex_search</span> will not be
called. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_iterator,operator++'></a></span><span class='indexparent'><a class='index' id='operator++,regex_iterator'></a></span><code class='itemdecl'>
regex_iterator operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='regiter.incr-9'><div class='marginalizedparent'><a class='marginalized' href='#regiter.incr-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
As if by:
</p><pre class='codeblock'>
regex_iterator tmp = *this;
++(*this);
return tmp;
</pre></div></div></div></div><div id='tokiter'><h3 ><a class='secnum' href='#tokiter' style='min-width:103pt'>28.12.2</a> Class template <span class='texttt'>regex_token_iterator</span> <a class='abbr_ref' href='re.tokiter'>[re.tokiter]</a></h3><div class='para' id='tokiter-1'><div class='marginalizedparent'><a class='marginalized' href='#tokiter-1'>1</a></div><p ><span class='indexparent'><a class='index' id='regex_token_iterator'></a></span>The class template <span class='texttt'>regex_token_iterator</span> is an iterator adaptor; that
is to say it represents a new view of an existing iterator sequence,
by enumerating all the occurrences of a regular expression within that
sequence, and presenting one or more sub-expressions for each match
found. Each position enumerated by the iterator is a <span class='texttt'>sub_match</span> class
template instance that represents what matched a particular sub-expression
within the regular expression.</p></div><div class='para' id='tokiter-2'><div class='marginalizedparent'><a class='marginalized' href='#tokiter-2'>2</a></div><p >When class <span class='texttt'>regex_token_iterator</span> is used to enumerate a
single sub-expression with index -1 the iterator performs field
splitting: that is to say it enumerates one sub-expression for each section of
the character container sequence that does not match the regular
expression specified.</p></div><div class='para' id='tokiter-3'><div class='marginalizedparent'><a class='marginalized' href='#tokiter-3'>3</a></div><p ><span class='indexparent'><a class='index' id='match_results'></a></span>After it is constructed, the iterator finds and stores a value
<span class='texttt'>regex_iterator&lt;BidirectionalIterator&gt; position</span>
and sets the internal count <span class='texttt'>N</span> to zero. It also maintains a sequence
<span class='texttt'>subs</span> which contains a list of the sub-expressions which will be
enumerated. Every time <span class='texttt'>operator++</span> is used
the count <span class='texttt'>N</span> is incremented; if <span class='texttt'>N</span> exceeds or equals <span class='texttt'>subs.size()</span>,
then the iterator increments member <span class='texttt'>position</span>
and sets count <span class='texttt'>N</span> to zero.</p></div><div class='para' id='tokiter-4'><div class='marginalizedparent'><a class='marginalized' href='#tokiter-4'>4</a></div><p ><span class='indexparent'><a class='index' id='regex_token_iterator,end-of-sequence'></a></span>If the end of sequence is reached (<span class='texttt'>position</span> is equal to the end of
sequence iterator), the iterator becomes equal to the end-of-sequence
iterator value, unless the sub-expression being enumerated has index -1,
in which case the iterator enumerates one last sub-expression that contains
all the characters from the end of the last regular expression match to the
end of the input sequence being enumerated, provided that this would not be an
empty sub-expression.</p></div><div class='para' id='tokiter-5'><div class='marginalizedparent'><a class='marginalized' href='#tokiter-5'>5</a></div><p ><span class='indexparent'><a class='index' id='regex_token_iterator,end-of-sequence'></a></span>The default constructor constructs
an end-of-sequence iterator object, which is the only legitimate
iterator to be used for the end condition. The result of <span class='texttt'>operator*</span> on
an end-of-sequence iterator is not defined. For any other iterator value a
<span class='texttt'>const sub_match&lt;BidirectionalIterator&gt;&amp;</span> is returned.
The result of <span class='texttt'>operator-&gt;</span> on an end-of-sequence iterator
is not defined. For any other iterator value a <span class='texttt'>const
sub_match&lt;BidirectionalIterator&gt;*</span> is returned.</p></div><div class='para' id='tokiter-6'><div class='marginalizedparent'><a class='marginalized' href='#tokiter-6'>6</a></div><p ><span class='indexparent'><a class='index' id='regex_token_iterator,operator=='></a></span><span class='indexparent'><a class='index' id='operator==,regex_token_iterator'></a></span>It is impossible to store things
into <span class='texttt'>regex_token_iterator</span>s. Two end-of-sequence iterators are always
equal. An end-of-sequence iterator is not equal to a
non-end-of-sequence iterator. Two non-end-of-sequence iterators are
equal when they are constructed from the same arguments.</p><pre class='codeblock'>
namespace std {
  template &lt;class BidirectionalIterator,
            class charT = typename iterator_traits&lt;
              BidirectionalIterator&gt;::value_type,
            class traits = regex_traits&lt;charT&gt;&gt;
  class regex_token_iterator {
  public:
    using regex_type        = basic_regex&lt;charT, traits&gt;;
    using iterator_category = forward_iterator_tag;
    using value_type        = sub_match&lt;BidirectionalIterator&gt;;
    using difference_type   = ptrdiff_t;
    using pointer           = const value_type*;
    using reference         = const value_type&amp;;

    regex_token_iterator();
    regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                        const regex_type&amp; re,
                        int submatch = 0,
                        regex_constants::match_flag_type m =
                          regex_constants::match_default);
    regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                        const regex_type&amp; re,
                        const vector&lt;int&gt;&amp; submatches,
                        regex_constants::match_flag_type m =
                          regex_constants::match_default);
    regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                        const regex_type&amp; re,
                        initializer_list&lt;int&gt; submatches,
                        regex_constants::match_flag_type m =
                          regex_constants::match_default);
    template &lt;size_t N&gt;
      regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                        const regex_type&amp; re,
                        const int (&amp;submatches)[N],
                        regex_constants::match_flag_type m =
                          regex_constants::match_default);
    regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                         const regex_type&amp;&amp; re,
                         int submatch = 0,
                         regex_constants::match_flag_type m =
                           regex_constants::match_default) = delete;
    regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                         const regex_type&amp;&amp; re,
                         const vector&lt;int&gt;&amp; submatches,
                         regex_constants::match_flag_type m =
                           regex_constants::match_default) = delete;
    regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                         const regex_type&amp;&amp; re,
                         initializer_list&lt;int&gt; submatches,
                         regex_constants::match_flag_type m =
                           regex_constants::match_default) = delete;
    template &lt;size_t N&gt;
    regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                         const regex_type&amp;&amp; re,
                         const int (&amp;submatches)[N],
                         regex_constants::match_flag_type m =
                           regex_constants::match_default) = delete;                         
    regex_token_iterator(const regex_token_iterator&amp;);
    regex_token_iterator&amp; operator=(const regex_token_iterator&amp;);
    bool operator==(const regex_token_iterator&amp;) const;
    bool operator!=(const regex_token_iterator&amp;) const;
    const value_type&amp; operator*() const;
    const value_type* operator-&gt;() const;
    regex_token_iterator&amp; operator++();
    regex_token_iterator operator++(int);

  private:
    using position_iterator =
          regex_iterator&lt;BidirectionalIterator, charT, traits&gt;; <span class='comment'>// <i>exposition only</i>
</span>    position_iterator position;                                 <span class='comment'>// <i>exposition only</i>
</span>    const value_type* result;                                   <span class='comment'>// <i>exposition only</i>
</span>    value_type suffix;                                          <span class='comment'>// <i>exposition only</i>
</span>    size_t N;                                                   <span class='comment'>// <i>exposition only</i>
</span>    vector&lt;int&gt; subs;                                           <span class='comment'>// <i>exposition only</i>
</span>  };
}
</pre></div><div class='para' id='tokiter-7'><div class='marginalizedparent'><a class='marginalized' href='#tokiter-7'>7</a></div><p >A <i>suffix iterator</i> is a <span class='texttt'>regex_token_iterator</span> object
that points to a final sequence of characters at
the end of the target sequence. In a suffix iterator the
member <span class='texttt'>result</span> holds a pointer to the data
member <span class='texttt'>suffix</span>, the value of the member <span class='texttt'>suffix.match</span>
is <span class='texttt'>true</span>, <span class='texttt'>suffix.first</span> points to the beginning of the
final sequence, and <span class='texttt'>suffix.second</span> points to the end of the
final sequence.</p></div><div class='para' id='tokiter-8'><div class='marginalizedparent'><a class='marginalized' href='#tokiter-8'>8</a></div><p >[&nbsp;<i>Note:</i> For a suffix iterator, data
member <span class='texttt'>suffix.first</span> is the same as the end of the last match
found, and <span class='texttt'>suffix.second</span> is the same as the end of the target
sequence <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='tokiter-9'><div class='marginalizedparent'><a class='marginalized' href='#tokiter-9'>9</a></div><p >The <i>current match</i> is <span class='texttt'>(*position).prefix()</span> if <span class='texttt'>subs[N] == -1</span>, or
<span class='texttt'>(*position)[subs[N]]</span> for any other value of <span class='texttt'>subs[N]</span>.</p></div><div id='tokiter.cnstr'><h4 ><a class='secnum' href='#tokiter.cnstr' style='min-width:118pt'>28.12.2.1</a> <span class='texttt'>regex_token_iterator</span> constructors <a class='abbr_ref' href='re.tokiter.cnstr'>[re.tokiter.cnstr]</a></h4><p ><span class='indexparent'><a class='index' id='regex_token_iterator,constructor'></a></span><code class='itemdecl'>
regex_token_iterator();
</code></p><div class='itemdescr'></div><div class='para' id='tokiter.cnstr-1'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.cnstr-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs the end-of-sequence iterator.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_token_iterator,constructor'></a></span><code class='itemdecl'>
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                    const regex_type&amp; re,
                    int submatch = 0,
                    regex_constants::match_flag_type m =
                     regex_constants::match_default);

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                    const regex_type&amp; re,
                    const vector&lt;int&gt;&amp; submatches,
                    regex_constants::match_flag_type m =
                     regex_constants::match_default);

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                    const regex_type&amp; re,
                    initializer_list&lt;int&gt; submatches,
                    regex_constants::match_flag_type m =
                      regex_constants::match_default);

template &lt;size_t N&gt;
  regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                    const regex_type&amp; re,
                    const int (&amp;submatches)[N],
                    regex_constants::match_flag_type m =
                     regex_constants::match_default);
</code></p><div class='itemdescr'></div><div class='para' id='tokiter.cnstr-2'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.cnstr-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> Each of the initialization values of <span class='texttt'>submatches</span> shall be <span class='texttt'>&gt;=
-1</span>.</p></div></div><div class='para' id='tokiter.cnstr-3'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.cnstr-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> The first constructor initializes the member <span class='texttt'>subs</span> to hold the single
value <span class='texttt'>submatch</span>. The second constructor initializes the member <span class='texttt'>subs</span> to
hold a copy of the argument <span class='texttt'>submatches</span>. The third and fourth constructors
initialize the member <span class='texttt'>subs</span> to hold a copy of the sequence of integer values
pointed to by the iterator range <span class='texttt'>[submatches.begin(), submatches.end())</span> and
<span class='texttt'>[&amp;submatches, &amp;submatches + N)</span>, respectively.</p></div></div><div class='para' id='tokiter.cnstr-4'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.cnstr-4'>4</a></div><div class='itemdescr'><p >Each constructor then sets <span class='texttt'>N</span> to 0, and <span class='texttt'>position</span> to
<span class='texttt'>position_iterator(a, b, re, m)</span>. If <span class='texttt'>position</span> is not an
end-of-sequence iterator the constructor sets <span class='texttt'>result</span> to the
address of the current match. Otherwise if any of the values stored
in <span class='texttt'>subs</span> is equal to -1 the constructor sets <span class='texttt'>*this</span> to a suffix
iterator that points to the range <span class='texttt'>[a, b)</span>, otherwise the constructor
sets <span class='texttt'>*this</span> to an end-of-sequence iterator.
</p></div></div></div><div id='tokiter.comp'><h4 ><a class='secnum' href='#tokiter.comp' style='min-width:118pt'>28.12.2.2</a> <span class='texttt'>regex_token_iterator</span> comparisons <a class='abbr_ref' href='re.tokiter.comp'>[re.tokiter.comp]</a></h4><p ><span class='indexparent'><a class='index' id='regex_token_iterator,operator=='></a></span><span class='indexparent'><a class='index' id='operator==,regex_token_iterator'></a></span><code class='itemdecl'>
bool operator==(const regex_token_iterator&amp; right) const;
</code></p><div class='itemdescr'></div><div class='para' id='tokiter.comp-1'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.comp-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>*this</span> and <span class='texttt'>right</span> are both end-of-sequence iterators,
or if <span class='texttt'>*this</span> and <span class='texttt'>right</span> are both suffix iterators and <span class='texttt'>suffix == right.suffix</span>;
otherwise returns <span class='texttt'>false</span> if <span class='texttt'>*this</span> or <span class='texttt'>right</span> is an end-of-sequence
iterator or a suffix iterator. Otherwise returns <span class='texttt'>true</span> if <span class='texttt'>position == right.position</span>,
<span class='texttt'>N == right.N</span>, and <span class='texttt'>subs == right.subs</span>. Otherwise returns <span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_token_iterator,operator!='></a></span><span class='indexparent'><a class='index' id='operator!=,regex_token_iterator'></a></span><code class='itemdecl'>
bool operator!=(const regex_token_iterator&amp; right) const;
</code></p><div class='itemdescr'></div><div class='para' id='tokiter.comp-2'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.comp-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(*this == right)</span>.
</p></div></div></div><div id='tokiter.deref'><h4 ><a class='secnum' href='#tokiter.deref' style='min-width:118pt'>28.12.2.3</a> <span class='texttt'>regex_token_iterator</span> indirection <a class='abbr_ref' href='re.tokiter.deref'>[re.tokiter.deref]</a></h4><p ><span class='indexparent'><a class='index' id='regex_token_iterator,operator*'></a></span><span class='indexparent'><a class='index' id='operator*,regex_token_iterator'></a></span><code class='itemdecl'>
const value_type&amp; operator*() const;
</code></p><div class='itemdescr'></div><div class='para' id='tokiter.deref-1'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.deref-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*result</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator->,regex_token_iterator'></a></span><span class='indexparent'><a class='index' id='regex_token_iterator,operator->'></a></span><code class='itemdecl'>
const value_type* operator-&gt;() const;
</code></p><div class='itemdescr'></div><div class='para' id='tokiter.deref-2'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.deref-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>result</span>.
</p></div></div></div><div id='tokiter.incr'><h4 ><a class='secnum' href='#tokiter.incr' style='min-width:118pt'>28.12.2.4</a> <span class='texttt'>regex_token_iterator</span> increment <a class='abbr_ref' href='re.tokiter.incr'>[re.tokiter.incr]</a></h4><p ><span class='indexparent'><a class='index' id='regex_token_iterator,operator++'></a></span><span class='indexparent'><a class='index' id='operator++,regex_token_iterator'></a></span><code class='itemdecl'>
regex_token_iterator&amp; operator++();
</code></p><div class='itemdescr'></div><div class='para' id='tokiter.incr-1'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.incr-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs a local variable <span class='texttt'>prev</span> of
type <span class='texttt'>position_iterator</span>, initialized with the value
of <span class='texttt'>position</span>.</p></div></div><div class='para' id='tokiter.incr-2'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.incr-2'>2</a></div><div class='itemdescr'><p >If <span class='texttt'>*this</span> is a suffix iterator, sets <span class='texttt'>*this</span> to an
end-of-sequence iterator.</p></div></div><div class='para' id='tokiter.incr-3'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.incr-3'>3</a></div><div class='itemdescr'><p >Otherwise, if <span class='texttt'>N + 1 &lt; subs.size()</span>, increments <span class='texttt'>N</span> and
sets <span class='texttt'>result</span> to the address of the current match.</p></div></div><div class='para' id='tokiter.incr-4'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.incr-4'>4</a></div><div class='itemdescr'><p >Otherwise, sets <span class='texttt'>N</span> to 0 and
increments <span class='texttt'>position</span>. If <span class='texttt'>position</span> is not an
end-of-sequence iterator the operator sets <span class='texttt'>result</span> to the
address of the current match.</p></div></div><div class='para' id='tokiter.incr-5'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.incr-5'>5</a></div><div class='itemdescr'><p >Otherwise, if any of the values stored in <span class='texttt'>subs</span> is equal to -1 and
<span class='texttt'>prev-&gt;suffix().length()</span> is not 0 the operator sets <span class='texttt'>*this</span> to a
suffix iterator that points to the range <span class='texttt'>[prev-&gt;suffix().first, prev-&gt;suffix().second)</span>.</p></div></div><div class='para' id='tokiter.incr-6'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.incr-6'>6</a></div><div class='itemdescr'><p >Otherwise, sets <span class='texttt'>*this</span> to an end-of-sequence iterator.</p></div></div><div class='para' id='tokiter.incr-7'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.incr-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_token_iterator,operator++'></a></span><span class='indexparent'><a class='index' id='operator++,regex_token_iterator'></a></span><code class='itemdecl'>
regex_token_iterator&amp; operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='tokiter.incr-8'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.incr-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i>  Constructs a copy <span class='texttt'>tmp</span> of <span class='texttt'>*this</span>, then calls <span class='texttt'>++(*this)</span>.</p></div></div><div class='para' id='tokiter.incr-9'><div class='marginalizedparent'><a class='marginalized' href='#tokiter.incr-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>tmp</span>.
</p></div></div></div></div></div><div id='grammar'><h2 ><a class='secnum' href='#grammar' style='min-width:88pt'>28.13</a> Modified ECMAScript regular expression grammar <a class='abbr_ref' href='re.grammar'>[re.grammar]</a></h2><p ><span class='indexparent'><a class='index' id='regular_expression,grammar'></a></span><span class='indexparent'><a class='index' id='grammar,regular_expression'></a></span>
</p><div class='para' id='grammar-1'><div class='marginalizedparent'><a class='marginalized' href='#grammar-1'>1</a></div><p ><span class='indexparent'><a class='index' id='basic_regex'></a></span><span class='indexparent'><a class='index' id='ECMAScript'></a></span>The regular expression grammar recognized by
<span class='texttt'>basic_regex</span> objects constructed with the ECMAScript
flag is that specified by ECMA-262, except as specified below.</p></div><div class='para' id='grammar-2'><div class='marginalizedparent'><a class='marginalized' href='#grammar-2'>2</a></div><p ><span class='indexparent'><a class='index' id='locale'></a></span><span class='indexparent'><a class='index' id='regular_expression_traits'></a></span>Objects of type specialization of <span class='texttt'>basic_regex</span> store within themselves a
default-constructed instance of their <span class='texttt'>traits</span> template parameter, henceforth
referred to as <span class='texttt'>traits_inst</span>. This <span class='texttt'>traits_inst</span> object is used to support localization
of the regular expression; <span class='texttt'>basic_regex</span> member functions shall not call
any locale dependent C or C++ API, including the formatted string input functions.
Instead they shall call the appropriate traits member function to achieve the required effect.</p></div><div class='para' id='grammar-3'><div class='marginalizedparent'><a class='marginalized' href='#grammar-3'>3</a></div><p >The following productions within the ECMAScript grammar are modified as follows:</p><pre class='codeblock'>
ClassAtom ::
  -
  ClassAtomNoDash
  ClassAtomExClass
  ClassAtomCollatingElement
  ClassAtomEquivalence

IdentityEscape ::
  SourceCharacter but not c
</pre></div><div class='para' id='grammar-4'><div class='marginalizedparent'><a class='marginalized' href='#grammar-4'>4</a></div><p >The following new productions are then added:</p><pre class='codeblock'>
ClassAtomExClass ::
  [: ClassName :]

ClassAtomCollatingElement ::
  [. ClassName .]

ClassAtomEquivalence ::
  [= ClassName =]

ClassName ::
  ClassNameCharacter
  ClassNameCharacter ClassName

ClassNameCharacter ::
  SourceCharacter but not one of "." "=" ":"
</pre></div><div class='para' id='grammar-5'><div class='marginalizedparent'><a class='marginalized' href='#grammar-5'>5</a></div><p >The productions <span class='texttt'>ClassAtomExClass</span>, <span class='texttt'>ClassAtomCollatingElement</span>
and <span class='texttt'>ClassAtomEquivalence</span> provide functionality
equivalent to that of the same features in regular expressions in POSIX.</p></div><div class='para' id='grammar-6'><div class='marginalizedparent'><a class='marginalized' href='#grammar-6'>6</a></div><p >The regular expression grammar may be modified by
any <span class='texttt'>regex_constants::syntax_option_type</span> flags specified when
constructing an object of type specialization of <span class='texttt'>basic_regex</span>
according to the rules in Table <a href='#tab:re:syntaxoption'>[tab:re:syntaxoption]</a>.</p></div><div class='para' id='grammar-7'><div class='marginalizedparent'><a class='marginalized' href='#grammar-7'>7</a></div><p >A <span class='texttt'>ClassName</span> production, when used in <span class='texttt'>ClassAtomExClass</span>,
is not valid if <span class='texttt'>traits_inst.lookup_classname</span> returns zero for
that name.  The names recognized as valid <span class='texttt'>ClassName</span>s are
determined by the type of the traits class, but at least the following
names shall be recognized:
<span class='texttt'>alnum</span>, <span class='texttt'>alpha</span>, <span class='texttt'>blank</span>, <span class='texttt'>cntrl</span>, <span class='texttt'>digit</span>,
<span class='texttt'>graph</span>, <span class='texttt'>lower</span>, <span class='texttt'>print</span>, <span class='texttt'>punct</span>, <span class='texttt'>space</span>,
<span class='texttt'>upper</span>, <span class='texttt'>xdigit</span>, <span class='texttt'>d</span>, <span class='texttt'>s</span>, <span class='texttt'>w</span>.
In addition the following expressions shall be equivalent:</p><pre class='codeblock'>
\d and [[:digit:]]

\D and [^[:digit:]]

\s and [[:space:]]

\S and [^[:space:]]

\w and [_[:alnum:]]

\W and [^_[:alnum:]]
</pre></div><div class='para' id='grammar-8'><div class='marginalizedparent'><a class='marginalized' href='#grammar-8'>8</a></div><p ><span class='indexparent'><a class='index' id='regular_expression_traits,lookup_collatename'></a></span><span class='indexparent'><a class='index' id='lookup_collatename,regular_expression_traits'></a></span>A <span class='texttt'>ClassName</span> production when used in
a <span class='texttt'>ClassAtomCollatingElement</span> production is not valid
if the value returned by <span class='texttt'>traits_inst.lookup_collatename</span> for
that name is an empty string.</p></div><div class='para' id='grammar-9'><div class='marginalizedparent'><a class='marginalized' href='#grammar-9'>9</a></div><p ><span class='indexparent'><a class='index' id='regular_expression_traits,isctype'></a></span><span class='indexparent'><a class='index' id='isctype,regular_expression_traits'></a></span><span class='indexparent'><a class='index' id='regular_expression_traits,lookup_classname'></a></span><span class='indexparent'><a class='index' id='lookup_classname,regular_expression_traits'></a></span>The results from multiple calls
to <span class='texttt'>traits_inst.lookup_classname</span> can be bitwise OR'ed
together and subsequently passed to <span class='texttt'>traits_inst.isctype</span>.</p></div><div class='para' id='grammar-10'><div class='marginalizedparent'><a class='marginalized' href='#grammar-10'>10</a></div><p ><span class='indexparent'><a class='index' id='regular_expression_traits,transform_primary'></a></span><span class='indexparent'><a class='index' id='transform_primary,regular_expression_traits'></a></span>A <span class='texttt'>ClassName</span> production when used in
a <span class='texttt'>ClassAtomEquivalence</span> production is not valid if the value
returned by <span class='texttt'>traits_inst.lookup_collatename</span> for that name is an
empty string or if the value returned by <span class='texttt'>traits_inst.transform_primary</span>
for the result of the call to <span class='texttt'>traits_inst.lookup_collatename</span>
is an empty string.</p></div><div class='para' id='grammar-11'><div class='marginalizedparent'><a class='marginalized' href='#grammar-11'>11</a></div><p ><span class='indexparent'><a class='index' id='regex_error'></a></span>When the sequence of characters being transformed to a finite state
machine contains an invalid class name the translator shall throw an
exception object of type <span class='texttt'>regex_error</span>.</p></div><div class='para' id='grammar-12'><div class='marginalizedparent'><a class='marginalized' href='#grammar-12'>12</a></div><p ><span class='indexparent'><a class='index' id='regex_error'></a></span>If the <i>CV</i> of a <i>UnicodeEscapeSequence</i> is greater than the largest
value that can be held in an object of type <span class='texttt'>charT</span> the translator shall
throw an exception object of type <span class='texttt'>regex_error</span>. [&nbsp;<i>Note:</i>
This means that values of the form <span class='texttt'>"uxxxx"</span> that do not fit in
a character are invalid.  <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='grammar-13'><div class='marginalizedparent'><a class='marginalized' href='#grammar-13'>13</a></div><p >Where the regular expression grammar requires the conversion of a sequence of characters
to an integral value, this is accomplished by calling <span class='texttt'>traits_inst.value</span>.</p></div><div class='para' id='grammar-14'><div class='marginalizedparent'><a class='marginalized' href='#grammar-14'>14</a></div><p ><span class='indexparent'><a class='index' id='match_flag_type'></a></span>The behavior of the internal finite state machine representation when used to match a
sequence of characters is as described in ECMA-262.
The behavior is modified according
to any match_flag_type flags <a href='re.matchflag'>[re.matchflag]</a> specified when using the regular expression
object in one of the regular expression algorithms <a href='re.alg'>[re.alg]</a>. The behavior is also
localized by interaction with the traits class template parameter as follows:
</p><ul class='itemize'><li id='grammar-14.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#grammar-14.1'>(14.1)</a></div><p >During matching of a regular expression finite state machine
against a sequence of characters, two characters <span class='texttt'>c</span>
and <span class='texttt'>d</span> are compared using the following rules:
</p><ul class='itemize'><li id='grammar-14.1.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#grammar-14.1.1'>(14.1.1)</a></div><p >if <span class='texttt'>(flags() &amp; regex_constants::icase)</span> the two characters are equal
if <span class='texttt'>traits_inst.translate_nocase(c) == traits_inst.translate_nocase(d)</span>;
<span class='indexparent'><a class='index' id='regular_expression_traits,translate_nocase'></a></span><span class='indexparent'><a class='index' id='translate_nocase,regular_expression_traits'></a></span></p></li><li id='grammar-14.1.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#grammar-14.1.2'>(14.1.2)</a></div><p >otherwise, if <span class='texttt'>flags() &amp; regex_constants::collate</span> the
two characters are equal if
<span class='texttt'>traits_inst.translate(c) == traits_inst.translate(d)</span>;
<span class='indexparent'><a class='index' id='syntax_option_type,collate'></a></span><span class='indexparent'><a class='index' id='regular_expression_traits,translate'></a></span><span class='indexparent'><a class='index' id='translate,regular_expression_traits'></a></span></p></li><li id='grammar-14.1.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#grammar-14.1.3'>(14.1.3)</a></div><p >otherwise, the two characters are equal if <span class='texttt'>c == d</span>.
</p></li></ul></li><li id='grammar-14.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#grammar-14.2'>(14.2)</a></div><p >During matching of a regular expression finite state machine
against a sequence of characters, comparison of a collating element
range <span class='texttt'>c1-c2</span> against a character <span class='texttt'>c</span> is
conducted as follows: if <span class='texttt'>flags() &amp; regex_constants ::
collate</span> is false then the character <span class='texttt'>c</span> is matched if <span class='texttt'>c1
&lt;= c &amp;&amp; c &lt;= c2</span>, otherwise <span class='texttt'>c</span> is matched in
accordance with the following algorithm:</p><p ><span class='indexparent'><a class='index' id='regular_expression_traits,translate'></a></span><span class='indexparent'><a class='index' id='translate,regular_expression_traits'></a></span><span class='indexparent'><a class='index' id='regular_expression_traits,translate_nocase'></a></span><span class='indexparent'><a class='index' id='translate_nocase,regular_expression_traits'></a></span><span class='indexparent'><a class='index' id='regular_expression_traits,transform'></a></span><span class='indexparent'><a class='index' id='transform,regular_expression_traits'></a></span></p><pre class='codeblock'>
string_type str1 = string_type(1,
  flags() &amp; icase ?
    traits_inst.translate_nocase(c1) : traits_inst.translate(c1);
string_type str2 = string_type(1,
  flags() &amp; icase ?
    traits_inst.translate_nocase(c2) : traits_inst.translate(c2);
string_type str = string_type(1,
  flags() &amp; icase ?
    traits_inst.translate_nocase(c) : traits_inst.translate(c);
return traits_inst.transform(str1.begin(), str1.end())
      &lt;= traits_inst.transform(str.begin(), str.end())
  &amp;&amp; traits_inst.transform(str.begin(), str.end())
      &lt;= traits_inst.transform(str2.begin(), str2.end());
</pre></li><li id='grammar-14.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#grammar-14.3'>(14.3)</a></div><p >During matching of a regular expression finite state machine against a sequence of
characters, testing whether a collating element is a member of a primary equivalence
class is conducted by first converting the collating element and the equivalence
class to sort keys using <span class='texttt'>traits::transform_primary</span>, and then comparing the sort
keys for equality.
<span class='indexparent'><a class='index' id='regular_expression_traits,transform_primary'></a></span><span class='indexparent'><a class='index' id='transform_primary,regular_expression_traits'></a></span>
</p></li><li id='grammar-14.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#grammar-14.4'>(14.4)</a></div><p >During matching of a regular expression finite state machine against a sequence
of characters, a character <span class='texttt'>c</span> is a member of a character class designated by an
iterator range <span class='texttt'>[first, last)</span> if
<span class='texttt'>traits_inst.isctype(c, traits_inst.lookup_classname(first, last, flags() &amp; icase))</span> is <span class='texttt'>true</span>.
<span class='indexparent'><a class='index' id='regular_expression_traits,lookup_classname'></a></span><span class='indexparent'><a class='index' id='lookup_classname,regular_expression_traits'></a></span></p></li></ul><p ><span class='indexparent'><a class='index' id='regular_expression'></a></span>
</p></div></div></div></div></body></html>