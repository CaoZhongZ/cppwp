<!DOCTYPE html><html lang='en'><head><title>[basic.compound]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>3.9</a> Types <a class='abbr_ref' href='basic.types#basic.compound'>[basic.types]</a></h2><div id='basic.compound'><h3 ><a class='secnum' style='min-width:103pt'>3.9.2</a> Compound types <a class='abbr_ref'>[basic.compound]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='type,compound'></a></span>Compound types can be constructed in the following ways:</p><ul ><li ><p ><span class='indexparent'><a class='index' id='type,array'></a></span><a class='hidden_link' href='#def:arrays' id='def:arrays'><i>arrays</i></a> of objects of a given type, <a href='dcl.array'>[dcl.array]</a>;</p></li><li ><p ><span class='indexparent'><a class='index' id='type,function'></a></span><a class='hidden_link' href='#def:functions' id='def:functions'><i>functions</i></a>, which have parameters of given types and return
<span class='texttt'>void</span> or references or objects of a given type, <a href='dcl.fct'>[dcl.fct]</a>;</p></li><li ><p ><span class='indexparent'><a class='index' id='type,pointer'></a></span><a class='hidden_link' href='#def:pointers' id='def:pointers'><i>pointers</i></a> to <i>cv</i> <span class='texttt'>void</span> or objects or functions (including
static members of classes) of a given type, <a href='dcl.ptr'>[dcl.ptr]</a>;</p></li><li ><p ><span class='indexparent'><a class='index' id='reference'></a></span><span class='indexparent'><a class='index' id='reference,lvalue'></a></span><span class='indexparent'><a class='index' id='reference,rvalue'></a></span><span class='indexparent'><a class='index' id='lvalue_reference'></a></span><span class='indexparent'><a class='index' id='rvalue_reference'></a></span><a class='hidden_link' href='#def:references' id='def:references'><i>references</i></a> to objects or functions of a given
type, <a href='dcl.ref'>[dcl.ref]</a>. There are two types of references:
</p><ul ><li ><p ><a class='hidden_link' href='#def:lvalue_reference' id='def:lvalue_reference'><i>lvalue reference</i></a>
</p></li><li ><p ><a class='hidden_link' href='#def:rvalue_reference' id='def:rvalue_reference'><i>rvalue reference</i></a>
</p></li></ul></li><li ><p ><span class='indexparent'><a class='index' id='class'></a></span><a class='hidden_link' href='#def:classes' id='def:classes'><i>classes</i></a> containing a sequence of objects of various types
(Clause <a href='class'>[class]</a>), a set of types, enumerations and functions for
manipulating these objects (<a href='class.mfct'>[class.mfct]</a>), and a set of restrictions
on the access to these entities (Clause <a href='class.access'>[class.access]</a>);</p></li><li ><p ><span class='indexparent'><a class='index' id='union'></a></span><a class='hidden_link' href='#def:unions' id='def:unions'><i>unions</i></a>, which are classes capable of containing objects of
different types at different times, <a href='class.union'>[class.union]</a>;</p></li><li ><p ><span class='indexparent'><a class='index' id='enum'></a></span><a class='hidden_link' href='#def:enumerations' id='def:enumerations'><i>enumerations</i></a>, which comprise a set of named constant values.
Each distinct enumeration constitutes a different
<span class='indexparent'><a class='index' id='type,enumerated'></a></span><a class='hidden_link' href='#def:enumerated_type' id='def:enumerated_type'><i>enumerated type</i></a>, <a href='dcl.enum'>[dcl.enum]</a>;</p></li><li ><p ><span class='indexparent'><a class='index' id='member_pointer_to'></a></span><span class='indexparent'><a class='index' id='pointer_to_member'></a></span><a class='hidden_link' href='#def:pointers_to_non-static' id='def:pointers_to_non-static'><i>pointers to non-static</i></a>
<a class='footnotenum' href='#footnote-53'>53</a>
<a class='hidden_link' href='#def:class_members' id='def:class_members'><i>class members</i></a>, which identify members of a given
type within objects of a given class, <a href='dcl.mptr'>[dcl.mptr]</a>.
</p></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >These methods of constructing types can be applied recursively;
restrictions are mentioned in <a href='dcl.ptr'>[dcl.ptr]</a>, <a href='dcl.array'>[dcl.array]</a>,
<a href='dcl.fct'>[dcl.fct]</a>, and <a href='dcl.ref'>[dcl.ref]</a>. Constructing a type such that the number of
bytes in its object representation exceeds the maximum value representable in
the type <span class='texttt'>std::size_t</span> (<a href='support.types'>[support.types]</a>) is ill-formed.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='terminology,pointer'></a></span>The type of a pointer to <i>cv</i> <span class='texttt'>void</span> or a pointer to an object type is
called an <a class='hidden_link' href='#def:object_pointer_type' id='def:object_pointer_type'><i>object pointer type</i></a>. [&nbsp;<i>Note:</i><span class='space'></span> A pointer to <span class='texttt'>void</span>
does not have a pointer-to-object type, however, because <span class='texttt'>void</span> is not
an object type. <i>&nbsp;—&nbsp;end note</i>&nbsp;] The type of a pointer that can designate a function
is called a <a class='hidden_link' href='#def:function_pointer_type' id='def:function_pointer_type'><i>function pointer type</i></a>.
A pointer to objects of type <span class='texttt'>T</span> is referred to as a “pointer to
<span class='texttt'>T</span>”. [&nbsp;<i>Example:</i><span class='space'></span> a pointer to an object of type <span class='texttt'>int</span> is
referred to as “pointer to <span class='texttt'>int</span> ” and a pointer to an object of
class <span class='texttt'>X</span> is called a “pointer to <span class='texttt'>X</span>”. <i>&nbsp;—&nbsp;end example</i>&nbsp;]
Except for pointers to static members, text referring to “pointers”
does not apply to pointers to members. Pointers to incomplete types are
allowed although there are restrictions on what can be done with
them (<a href='basic.align'>[basic.align]</a>).
<span class='indexparent'><a class='index' id='address'></a></span>Every value of pointer type is one of the following:
</p><ul ><li ><p >a <a class='hidden_link' href='#def:pointer_to' id='def:pointer_to'><i>pointer to</i></a> an object or function (the pointer is said to <a class='hidden_link' href='#def:point' id='def:point'><i>point</i></a> to the object or function), or
</p></li><li ><p >a <a class='hidden_link' href='#def:pointer_past_the_end_of' id='def:pointer_past_the_end_of'><i>pointer past the end of</i></a> an object (<a href='expr.add'>[expr.add]</a>), or
</p></li><li ><p >the <a class='hidden_link' href='#def:null_pointer_value' id='def:null_pointer_value'><i>null pointer value</i></a> (<a href='conv.ptr'>[conv.ptr]</a>) for that type, or
</p></li><li ><p >an <a class='hidden_link' href='#def:invalid_pointer_value' id='def:invalid_pointer_value'><i>invalid pointer value</i></a>.
</p></li></ul><p >A value of a
pointer type
that is a pointer to or past the end of an object
<a class='hidden_link' href='#def:represents_the_address' id='def:represents_the_address'><i>represents the address</i></a> of
the first byte in memory (<a href='intro.memory'>[intro.memory]</a>) occupied by the object<a class='footnotenum' href='#footnote-54'>54</a>
or the first byte in memory
after the end of the storage occupied by the object,
respectively.
[&nbsp;<i>Note:</i><span class='space'></span>
A pointer past the end of an object (<a href='expr.add'>[expr.add]</a>)
is not considered to point to an unrelated object
of the object's type
that might be located at that address.
A pointer value becomes invalid
when the storage it denotes
reaches the end of its storage duration;
see <a href='basic.stc'>[basic.stc]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
For purposes of pointer arithmetic (<a href='expr.add'>[expr.add]</a>)
and comparison (<a href='expr.rel'>[expr.rel]</a>, <a href='expr.eq'>[expr.eq]</a>),
a pointer past the end of the last element of
an array <span class='texttt'>x</span> of <span class='math'><span class='mathalpha'>n</span></span> elements
is considered to be equivalent to
a pointer to a hypothetical element <span class='math'><span class='mathtt'>x[</span><span class='mathalpha'>n</span><span class='mathtt'>]</span></span>.
The value representation of
pointer types is <span class='indexparent'><a class='index' id='value_representation_of_pointer_types'></a></span>implementation-defined. Pointers to
layout-compatible types shall
have the same value representation and alignment
requirements (<a href='basic.align'>[basic.align]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> Pointers to over-aligned types (<a href='basic.align'>[basic.align]</a>) have no special
representation, but their range of valid values is restricted by the extended
alignment requirement.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >Two objects <i>a</i> and <i>b</i> are <a class='hidden_link' href='#def:pointer-interconvertible' id='def:pointer-interconvertible'><i>pointer-interconvertible</i></a> if:
</p><ul ><li ><p >they are the same object, or
</p></li><li ><p >one is a standard-layout union object and
the other is a non-static data member of that object (<a href='class.union'>[class.union]</a>), or
</p></li><li ><p >one is a standard-layout class object and
the other is the first non-static data member of that object, or,
if the object has no non-static data members,
the first base class subobject of that object (<a href='class.mem'>[class.mem]</a>), or
</p></li><li ><p >there exists an object <i>c</i> such that
<i>a</i> and <i>c</i> are pointer-interconvertible, and
<i>c</i> and <i>b</i> are pointer-interconvertible.
</p></li></ul><p >If two objects are pointer-interconvertible,
then they have the same address,
and it is possible to obtain a pointer to one
from a pointer to the other
via a <span class='texttt'>reinterpret_cast</span> (<a href='expr.reinterpret.cast'>[expr.reinterpret.cast]</a>).
[&nbsp;<i>Note:</i><span class='space'></span>
An array object and its first element are not pointer-interconvertible,
even though they have the same address.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='pointer'></a></span><span class='indexparent'><a class='index' id='void*,type'></a></span>A pointer to <i>cv</i>-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>) or <i>cv</i>-unqualified
<span class='texttt'>void</span>
can be used to point to objects of
unknown type. Such a pointer shall be able to hold any object pointer.
An object of type <i>cv</i>
<span class='texttt'>void*</span> shall have the same representation and alignment
requirements as <i>cv</i> <span class='texttt'>char*</span>.</p></div><div class='footnote' id='footnote-53'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-53'>53)</a></div><p >Static class members are objects or functions, and pointers to them are
ordinary pointers to objects or functions.</p></div><div class='footnote' id='footnote-54'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-54'>54)</a></div><p >For an object that is not within its lifetime,
this is the first byte in memory that it will occupy or used to occupy.</p></div></div></div></body></html>