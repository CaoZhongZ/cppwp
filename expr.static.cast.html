<!DOCTYPE html><html lang='en'><head><title>[expr.static.cast]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>5.2</a> Postfix expressions <a class='abbr_ref' href='expr.post#expr.static.cast'>[expr.post]</a></h2><div id='expr.static.cast'><h3 ><a class='secnum' style='min-width:103pt'>5.2.9</a> Static cast <a class='abbr_ref'>[expr.static.cast]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5bc5cbae28d9e741ebc7df996f1f0d230ac4087e/source/expressions.tex#L2160'>#</a></div><p ><span class='indexparent'><a class='index' id='expression,static_cast'></a></span><span class='indexparent'><a class='index' id='cast,static'></a></span>The result of the expression <span class='texttt'>static_&shy;cast&lt;T&gt;(v)</span> is the result of
converting the expression <span class='texttt'>v</span> to type <span class='texttt'>T</span>.
<span class='indexparent'><a class='index' id='cast,static,lvalue'></a></span><span class='indexparent'><a class='index' id='cast,lvalue'></a></span>If <span class='texttt'>T</span> is an lvalue reference type
or an rvalue reference to function type, the result is an lvalue;
if <span class='texttt'>T</span> is an rvalue reference to object type, the result is an xvalue;
otherwise, the result is a prvalue. The <span class='texttt'>static_&shy;cast</span> operator shall not
<a href='expr.const.cast#def:casting_away_constness'>cast away constness</a>.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5bc5cbae28d9e741ebc7df996f1f0d230ac4087e/source/expressions.tex#L2173'>#</a></div><p ><span class='indexparent'><a class='index' id='cast,static,reference'></a></span><span class='indexparent'><a class='index' id='cast,reference'></a></span>An lvalue of type “<span class='textit'>cv1</span> <span class='texttt'>B</span>”, where <span class='texttt'>B</span> is a class
type, can be cast to type “reference to <span class='textit'>cv2</span> <span class='texttt'>D</span>”, where
<span class='texttt'>D</span> is a class <a href='class.derived'>derived</a> from <span class='texttt'>B</span>,
if <span class='textit'>cv2</span> is the
same cv-qualification as, or greater cv-qualification than,
<span class='textit'>cv1</span>. If <span class='texttt'>B</span> is a virtual base class of <span class='texttt'>D</span>
or a base class of a virtual base class of <span class='texttt'>D</span>,
or if no valid standard conversion from “pointer to <span class='texttt'>D</span>”
to “pointer to <span class='texttt'>B</span>” exists (<a href='conv.ptr'>[conv.ptr]</a>), the program is ill-formed.
An xvalue of type
“<span class='textit'>cv1</span> <span class='texttt'>B</span>” can be cast to type “rvalue reference to
<span class='textit'>cv2</span> <span class='texttt'>D</span>” with the same constraints as for an lvalue of
type “<span class='textit'>cv1</span> <span class='texttt'>B</span>”. If the object
of type “<span class='textit'>cv1</span> <span class='texttt'>B</span>” is actually a subobject of an object
of type <span class='texttt'>D</span>, the result refers to the enclosing object of type
<span class='texttt'>D</span>. Otherwise, the behavior is undefined.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><p ><pre class='codeblock'>
struct B { };
struct D : public B { };
D d;
B &amp;br = d;

static_cast&lt;D&amp;&gt;(br);            <span class='comment'>// produces lvalue to the original <span class='tcode_in_codeblock'>d</span> object
</span></pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5bc5cbae28d9e741ebc7df996f1f0d230ac4087e/source/expressions.tex#L2204'>#</a></div><p >An lvalue
of type “<span class='textit'>cv1</span> <span class='texttt'>T1</span>” can be cast to type “rvalue
reference to <span class='textit'>cv2</span> <span class='texttt'>T2</span>” if “<span class='textit'>cv2</span> <span class='texttt'>T2</span>” is
<a href='dcl.init.ref#def:reference-compatible'>reference-compatible</a> with “<span class='textit'>cv1</span>
<span class='texttt'>T1</span>”. If the value is not a bit-field,
the result refers to the object or the specified base class subobject
thereof; otherwise, the <a href='conv.lval'>lvalue-to-rvalue conversion</a>
is applied to the bit-field and the resulting prvalue is used as the
<i ><a href='expr.comma#nt:expression'>expression</a></i> of the <span class='texttt'>static_&shy;cast</span> for the remainder of this section.
If <span class='texttt'>T2</span> is an <a href='class.access'>inaccessible</a> or
<a href='class.member.lookup'>ambiguous</a> base class of <span class='texttt'>T1</span>,
a program that necessitates such a cast is ill-formed.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5bc5cbae28d9e741ebc7df996f1f0d230ac4087e/source/expressions.tex#L2218'>#</a></div><p >An expression <span class='texttt'>e</span> can be explicitly converted to a type <span class='texttt'>T</span>
if there is an <a href='over.best.ics'>implicit conversion sequence</a>
from <span class='texttt'>e</span> to <span class='texttt'>T</span>, or
if overload resolution for a <a href='dcl.init#def:direct-initialization'>direct-initialization</a>
of an object or reference of type <span class='texttt'>T</span> from <span class='texttt'>e</span>
would find at least one viable function (<a href='over.match.viable'>[over.match.viable]</a>).
If <span class='texttt'>T</span> is a reference type, the effect is
the same as performing the declaration and initialization
</p><p ><pre class='codeblock'>
 T t(e);</pre></p><p >for some invented temporary variable <span class='texttt'>t</span> (<a href='dcl.init'>[dcl.init]</a>)
and then using the temporary variable as the result of the conversion.
Otherwise, the result object is direct-initialized from <span class='texttt'>e</span>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
The conversion is ill-formed when attempting to convert an
expression of class type to an inaccessible or ambiguous base class.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5bc5cbae28d9e741ebc7df996f1f0d230ac4087e/source/expressions.tex#L2238'>#</a></div><p >Otherwise, the <span class='texttt'>static_&shy;cast</span> shall perform one of the conversions
listed below. No other conversion shall be performed explicitly using a
<span class='texttt'>static_&shy;cast</span>.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5bc5cbae28d9e741ebc7df996f1f0d230ac4087e/source/expressions.tex#L2243'>#</a></div><p >Any expression can be explicitly converted to type <span class='textit'>cv</span> <span class='texttt'>void</span>,
in which case it becomes a <a href='expr#def:discarded-value_expression'>discarded-value expression</a>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
However, if the value is in a <a href='class.temporary'>temporary
object</a>, the destructor for that
object is
not executed until the usual time, and the value of the object is
preserved for the purpose of executing the destructor.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5bc5cbae28d9e741ebc7df996f1f0d230ac4087e/source/expressions.tex#L2255'>#</a></div><p >The inverse of any <a href='conv'>standard conversion sequence</a> not containing an
<a href='conv.lval'>lvalue-to-rvalue</a>,
<a href='conv.array'>array-to-pointer</a>,
<a href='conv.func'>function-to-pointer</a>,
<a href='conv.ptr'>null pointer</a>, <a href='conv.mem'>null member pointer</a>,
<a href='conv.bool'>boolean</a>, or
<a href='conv.fctptr'>function pointer</a>
conversion, can be performed explicitly using <span class='texttt'>static_&shy;cast</span>. A
program is ill-formed if it uses <span class='texttt'>static_&shy;cast</span> to perform the
inverse of an ill-formed standard conversion sequence.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><p ><pre class='codeblock'>
struct B { };
struct D : private B { };
void f() {
  static_cast&lt;D*&gt;((B*)0);               <span class='comment'>// error: <span class='tcode_in_codeblock'>B</span> is a private base of <span class='tcode_in_codeblock'>D</span>
</span>  static_cast&lt;int B::*&gt;((int D::*)0);   <span class='comment'>// error: <span class='tcode_in_codeblock'>B</span> is a private base of <span class='tcode_in_codeblock'>D</span>
</span>}</pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5bc5cbae28d9e741ebc7df996f1f0d230ac4087e/source/expressions.tex#L2277'>#</a></div><p >The <a href='conv.lval'>lvalue-to-rvalue</a>,
<a href='conv.array'>array-to-pointer</a>, and
<a href='conv.func'>function-to-pointer</a> conversions are applied to the
operand. Such a <span class='texttt'>static_&shy;cast</span> is subject to the restriction that
the explicit conversion does not <a href='expr.const.cast#def:casting_away_constness'>cast away
constness</a>, and the following additional rules
for specific cases:</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5bc5cbae28d9e741ebc7df996f1f0d230ac4087e/source/expressions.tex#L2286'>#</a></div><p >A value of a <a href='dcl.enum'>scoped enumeration type</a> can be explicitly converted to an
integral type. When that type is <span class='textit'>cv</span> <span class='texttt'>bool</span>, the resulting value is
<span class='texttt'>false</span> if the original value is zero and <span class='texttt'>true</span> for all other
values. For the remaining integral types, the value is unchanged if the
original value can be represented by the
specified type. Otherwise, the resulting value is unspecified.
A value of a scoped enumeration type can also be explicitly converted to a
floating-point type; the result is the same as that of converting from the original
value to the floating-point type.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5bc5cbae28d9e741ebc7df996f1f0d230ac4087e/source/expressions.tex#L2297'>#</a></div><p ><span class='indexparent'><a class='index' id='enumeration_type,conversion_to'></a></span><span class='indexparent'><a class='index' id='enumeration_type,static_cast,conversion_to'></a></span>A value of integral or enumeration type can be explicitly converted to
a complete enumeration type. The value is unchanged if the original value is
within the range of the enumeration values (<a href='dcl.enum'>[dcl.enum]</a>). Otherwise,
the behavior is undefined.
A value of floating-point type can also be explicitly converted to an enumeration type.
The resulting value is the same as converting the original value to the
underlying type of the enumeration (<a href='conv.fpint'>[conv.fpint]</a>), and subsequently to
the enumeration type.</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5bc5cbae28d9e741ebc7df996f1f0d230ac4087e/source/expressions.tex#L2309'>#</a></div><p ><span class='indexparent'><a class='index' id='cast,base_class'></a></span><span class='indexparent'><a class='index' id='cast,derived_class'></a></span>A prvalue of type “pointer to <span class='textit'>cv1</span> <span class='texttt'>B</span>”, where <span class='texttt'>B</span>
is a class type, can be converted to a prvalue of type “pointer to
<span class='textit'>cv2</span> <span class='texttt'>D</span>”, where <span class='texttt'>D</span> is a class
<a href='class.derived'>derived</a> from <span class='texttt'>B</span>,
if <span class='textit'>cv2</span> is the same cv-qualification as,
or greater cv-qualification than, <span class='textit'>cv1</span>.
If <span class='texttt'>B</span> is a virtual base class of <span class='texttt'>D</span> or
a base class of a virtual base class of <span class='texttt'>D</span>, or
if no valid standard conversion from “pointer to <span class='texttt'>D</span>”
to “pointer to <span class='texttt'>B</span>” exists (<a href='conv.ptr'>[conv.ptr]</a>), the program is ill-formed.
The <a href='conv.ptr'>null pointer value</a> is converted to the null pointer value of the destination type. If the prvalue of type
“pointer to <span class='textit'>cv1</span> <span class='texttt'>B</span>” points to a <span class='texttt'>B</span> that is
actually a subobject of an object of type <span class='texttt'>D</span>, the resulting
pointer points to the enclosing object of type <span class='texttt'>D</span>. Otherwise, the
behavior is undefined.</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5bc5cbae28d9e741ebc7df996f1f0d230ac4087e/source/expressions.tex#L2329'>#</a></div><p ><span class='indexparent'><a class='index' id='cast,pointer-to-member'></a></span>A prvalue of type “pointer to member of <span class='texttt'>D</span> of type <span class='textit'>cv1</span>
<span class='texttt'>T</span>” can be converted to a prvalue of type “pointer to member of
<span class='texttt'>B</span> of type <span class='textit'>cv2</span> <span class='texttt'>T</span>”, where <span class='texttt'>B</span> is a <a href='class.derived'>base
class</a> of <span class='texttt'>D</span>,
if <span class='textit'>cv2</span> is the same cv-qualification
as, or greater cv-qualification than, <span class='textit'>cv1</span>.<a class='footnotenum' href='#footnote-72'>72</a>
If no valid standard conversion
from “pointer to member of <span class='texttt'>B</span> of type <span class='texttt'>T</span>”
to “pointer to member of <span class='texttt'>D</span> of type <span class='texttt'>T</span>”
exists (<a href='conv.mem'>[conv.mem]</a>), the program is ill-formed.
The <a href='conv.mem#def:null_member_pointer_value'>null member pointer value</a> is converted to the null
member pointer value of the destination type. If class <span class='texttt'>B</span>
contains the original member, or is a base or derived class of the class
containing the original member, the resulting pointer to member points
to the original member. Otherwise, the behavior is undefined.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
Although class <span class='texttt'>B</span> need not contain the original member, the
dynamic type of the object with which indirection through the pointer
to member is performed must contain the original member;
see <a href='expr.mptr.oper'>[expr.mptr.oper]</a>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5bc5cbae28d9e741ebc7df996f1f0d230ac4087e/source/expressions.tex#L2355'>#</a></div><p >A prvalue of type “pointer to <span class='textit'>cv1</span> <span class='texttt'>void</span>” can be
converted to a prvalue of type “pointer to <span class='textit'>cv2</span> <span class='texttt'>T</span>”,
where <span class='texttt'>T</span> is an object type and <span class='textit'>cv2</span> is the same
cv-qualification as, or greater cv-qualification than, <span class='textit'>cv1</span>.
If the original pointer value represents the address
<span class='texttt'>A</span> of a byte in memory and
<span class='texttt'>A</span> does not satisfy the alignment requirement of <span class='texttt'>T</span>,
then the resulting pointer value is unspecified.
Otherwise, if the original pointer value points to an object <span class='textit'>a</span>,
and there is an object <span class='textit'>b</span> of type <span class='texttt'>T</span> (ignoring cv-qualification)
that is <a href='basic.compound#def:pointer-interconvertible'>pointer-interconvertible</a> with <span class='textit'>a</span>,
the result is a pointer to <span class='textit'>b</span>.
Otherwise, the pointer value is unchanged by the conversion.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><p ><pre class='codeblock'>
T* p1 = new T;
const T* p2 = static_cast&lt;const T*&gt;(static_cast&lt;void*&gt;(p1));
bool b = p1 == p2;  <span class='comment'>// <span class='tcode_in_codeblock'>b</span> will have the value <span class='tcode_in_codeblock'>true</span>.
</span></pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='footnote' id='footnote-72'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-72'>72)</a></div><p >Function types
(including those used in pointer to member function
types) are never cv-qualified; see <a href='dcl.fct'>[dcl.fct]</a>.</p></div></div></div></body></html>