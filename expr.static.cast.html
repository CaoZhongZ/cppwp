<!DOCTYPE html><html lang='en'><head><title>[expr.static.cast]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>5.2</a> Postfix expressions <a class='abbr_ref' href='expr.post#expr.static.cast'>[expr.post]</a></h2><div id='expr.static.cast'><h3 ><a class='secnum' style='min-width:103pt'>5.2.9</a> Static cast <a class='abbr_ref'>[expr.static.cast]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/701df7eac2474300d2b602700a3c32a51ef439a7/source/expressions.tex#L2158'>#</a></div><p ><span class='indexparent'><a class='index' id='expression,static_cast'></a></span><span class='indexparent'><a class='index' id='cast,static'></a></span>The result of the expression <span class='texttt'>static_&shy;cast&lt;T&gt;(v)</span> is the result of
converting the expression <span class='texttt'>v</span> to type <span class='texttt'>T</span>.
<span class='indexparent'><a class='index' id='cast,static,lvalue'></a></span><span class='indexparent'><a class='index' id='cast,lvalue'></a></span>If <span class='texttt'>T</span> is an lvalue reference type
or an rvalue reference to function type, the result is an lvalue;
if <span class='texttt'>T</span> is an rvalue reference to object type, the result is an xvalue;
otherwise, the result is a prvalue. The <span class='texttt'>static_&shy;cast</span> operator shall not cast
away constness (<a href='expr.const.cast'>[expr.const.cast]</a>).</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/701df7eac2474300d2b602700a3c32a51ef439a7/source/expressions.tex#L2171'>#</a></div><p ><span class='indexparent'><a class='index' id='cast,static,reference'></a></span><span class='indexparent'><a class='index' id='cast,reference'></a></span>An lvalue of type “<span class='textit'>cv1</span> <span class='texttt'>B</span>”, where <span class='texttt'>B</span> is a class
type, can be cast to type “reference to <span class='textit'>cv2</span> <span class='texttt'>D</span>”, where
<span class='texttt'>D</span> is a class derived (Clause <a href='class.derived'>[class.derived]</a>) from <span class='texttt'>B</span>,
if <span class='textit'>cv2</span> is the
same cv-qualification as, or greater cv-qualification than,
<span class='textit'>cv1</span>. If <span class='texttt'>B</span> is a virtual base class of <span class='texttt'>D</span>
or a base class of a virtual base class of <span class='texttt'>D</span>,
or if no valid standard conversion from “pointer to <span class='texttt'>D</span>”
to “pointer to <span class='texttt'>B</span>” exists (<a href='conv.ptr'>[conv.ptr]</a>), the program is ill-formed.
An xvalue of type
“<span class='textit'>cv1</span> <span class='texttt'>B</span>” can be cast to type “rvalue reference to
<span class='textit'>cv2</span> <span class='texttt'>D</span>” with the same constraints as for an lvalue of
type “<span class='textit'>cv1</span> <span class='texttt'>B</span>”. If the object
of type “<span class='textit'>cv1</span> <span class='texttt'>B</span>” is actually a subobject of an object
of type <span class='texttt'>D</span>, the result refers to the enclosing object of type
<span class='texttt'>D</span>. Otherwise, the behavior is undefined.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span></p><pre class='codeblock'>
struct B { };
struct D : public B { };
D d;
B &amp;br = d;

static_cast&lt;D&amp;&gt;(br);            <span class='comment'>// produces lvalue to the original <span class='tcode_in_codeblock'>d</span> object
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/701df7eac2474300d2b602700a3c32a51ef439a7/source/expressions.tex#L2202'>#</a></div><p >An lvalue
of type “<span class='textit'>cv1</span> <span class='texttt'>T1</span>” can be cast to type “rvalue
reference to <span class='textit'>cv2</span> <span class='texttt'>T2</span>” if “<span class='textit'>cv2</span> <span class='texttt'>T2</span>” is
reference-compatible with “<span class='textit'>cv1</span>
<span class='texttt'>T1</span>” (<a href='dcl.init.ref'>[dcl.init.ref]</a>). If the value is not a bit-field,
the result refers to the object or the specified base class subobject
thereof; otherwise, the lvalue-to-rvalue conversion (<a href='conv.lval'>[conv.lval]</a>)
is applied to the bit-field and the resulting prvalue is used as the
<i ><a href='expr.comma#nt:expression'>expression</a></i> of the <span class='texttt'>static_&shy;cast</span> for the remainder of this section.
If <span class='texttt'>T2</span> is an inaccessible (Clause <a href='class.access'>[class.access]</a>) or
ambiguous (<a href='class.member.lookup'>[class.member.lookup]</a>) base class of <span class='texttt'>T1</span>,
a program that necessitates such a cast is ill-formed.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/701df7eac2474300d2b602700a3c32a51ef439a7/source/expressions.tex#L2216'>#</a></div><p >An expression <span class='texttt'>e</span> can be explicitly converted to a type <span class='texttt'>T</span>
if there is an implicit conversion sequence (<a href='over.best.ics'>[over.best.ics]</a>)
from <span class='texttt'>e</span> to <span class='texttt'>T</span>, or
if overload resolution for a direct-initialization (<a href='dcl.init'>[dcl.init]</a>)
of an object or reference of type <span class='texttt'>T</span> from <span class='texttt'>e</span>
would find at least one viable function (<a href='over.match.viable'>[over.match.viable]</a>). 
If <span class='texttt'>T</span> is a reference type, the effect is
the same as performing the declaration and initialization
</p><pre class='codeblock'>
 T t(e);</pre><p >for some invented temporary variable <span class='texttt'>t</span> (<a href='dcl.init'>[dcl.init]</a>)
and then using the temporary variable as the result of the conversion.
Otherwise, the result object is direct-initialized from <span class='texttt'>e</span>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
The conversion is ill-formed when attempting to convert an
expression of class type to an inaccessible or ambiguous base class.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/701df7eac2474300d2b602700a3c32a51ef439a7/source/expressions.tex#L2236'>#</a></div><p >Otherwise, the <span class='texttt'>static_&shy;cast</span> shall perform one of the conversions
listed below. No other conversion shall be performed explicitly using a
<span class='texttt'>static_&shy;cast</span>.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/701df7eac2474300d2b602700a3c32a51ef439a7/source/expressions.tex#L2241'>#</a></div><p >Any expression can be explicitly converted to type <span class='textit'>cv</span> <span class='texttt'>void</span>,
in which case it becomes a discarded-value
expression (Clause <a href='expr'>[expr]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
However, if the value is in a temporary
object (<a href='class.temporary'>[class.temporary]</a>), the destructor for that
object is
not executed until the usual time, and the value of the object is
preserved for the purpose of executing the destructor.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/701df7eac2474300d2b602700a3c32a51ef439a7/source/expressions.tex#L2254'>#</a></div><p >The inverse of any standard conversion sequence (Clause <a href='conv'>[conv]</a>) not containing an
lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>),
array-to-pointer (<a href='conv.array'>[conv.array]</a>),
function-to-pointer (<a href='conv.func'>[conv.func]</a>),
null pointer (<a href='conv.ptr'>[conv.ptr]</a>), null member pointer (<a href='conv.mem'>[conv.mem]</a>),
boolean (<a href='conv.bool'>[conv.bool]</a>), or
function pointer (<a href='conv.fctptr'>[conv.fctptr]</a>)
conversion, can be performed explicitly using <span class='texttt'>static_&shy;cast</span>. A
program is ill-formed if it uses <span class='texttt'>static_&shy;cast</span> to perform the
inverse of an ill-formed standard conversion sequence.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><pre class='codeblock'>
struct B { };
struct D : private B { };
void f() {
  static_cast&lt;D*&gt;((B*)0);               <span class='comment'>// error: <span class='tcode_in_codeblock'>B</span> is a private base of <span class='tcode_in_codeblock'>D</span>
</span>  static_cast&lt;int B::*&gt;((int D::*)0);   <span class='comment'>// error: <span class='tcode_in_codeblock'>B</span> is a private base of <span class='tcode_in_codeblock'>D</span>
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/701df7eac2474300d2b602700a3c32a51ef439a7/source/expressions.tex#L2276'>#</a></div><p >The lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>),
array-to-pointer (<a href='conv.array'>[conv.array]</a>), and
function-to-pointer (<a href='conv.func'>[conv.func]</a>) conversions are applied to the
operand. Such a <span class='texttt'>static_&shy;cast</span> is subject to the restriction that
the explicit conversion does not cast away
constness (<a href='expr.const.cast'>[expr.const.cast]</a>), and the following additional rules
for specific cases:</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/701df7eac2474300d2b602700a3c32a51ef439a7/source/expressions.tex#L2285'>#</a></div><p >A value of a scoped enumeration type (<a href='dcl.enum'>[dcl.enum]</a>) can be explicitly converted to an
integral type. When that type is <span class='textit'>cv</span> <span class='texttt'>bool</span>, the resulting value is
<span class='texttt'>false</span> if the original value is zero and <span class='texttt'>true</span> for all other
values. For the remaining integral types, the value is unchanged if the
original value can be represented by the
specified type. Otherwise, the resulting value is unspecified.
A value of a scoped enumeration type can also be explicitly converted to a
floating-point type; the result is the same as that of converting from the original
value to the floating-point type.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/701df7eac2474300d2b602700a3c32a51ef439a7/source/expressions.tex#L2296'>#</a></div><p ><span class='indexparent'><a class='index' id='enumeration_type,conversion_to'></a></span><span class='indexparent'><a class='index' id='enumeration_type,static_cast,conversion_to'></a></span>A value of integral or enumeration type can be explicitly converted to
a complete enumeration type. The value is unchanged if the original value is
within the range of the enumeration values (<a href='dcl.enum'>[dcl.enum]</a>). Otherwise,
the behavior is undefined.
A value of floating-point type can also be explicitly converted to an enumeration type.
The resulting value is the same as converting the original value to the
underlying type of the enumeration (<a href='conv.fpint'>[conv.fpint]</a>), and subsequently to
the enumeration type.</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/701df7eac2474300d2b602700a3c32a51ef439a7/source/expressions.tex#L2308'>#</a></div><p ><span class='indexparent'><a class='index' id='cast,base_class'></a></span><span class='indexparent'><a class='index' id='cast,derived_class'></a></span>A prvalue of type “pointer to <span class='textit'>cv1</span> <span class='texttt'>B</span>”, where <span class='texttt'>B</span>
is a class type, can be converted to a prvalue of type “pointer to
<span class='textit'>cv2</span> <span class='texttt'>D</span>”, where <span class='texttt'>D</span> is a class derived
(Clause <a href='class.derived'>[class.derived]</a>) from <span class='texttt'>B</span>,
if <span class='textit'>cv2</span> is the same cv-qualification as,
or greater cv-qualification than, <span class='textit'>cv1</span>.
If <span class='texttt'>B</span> is a virtual base class of <span class='texttt'>D</span> or
a base class of a virtual base class of <span class='texttt'>D</span>, or
if no valid standard conversion from “pointer to <span class='texttt'>D</span>”
to “pointer to <span class='texttt'>B</span>” exists (<a href='conv.ptr'>[conv.ptr]</a>), the program is ill-formed. 
The null pointer value (<a href='conv.ptr'>[conv.ptr]</a>) is converted
to the null pointer value of the destination type. If the prvalue of type
“pointer to <span class='textit'>cv1</span> <span class='texttt'>B</span>” points to a <span class='texttt'>B</span> that is
actually a subobject of an object of type <span class='texttt'>D</span>, the resulting
pointer points to the enclosing object of type <span class='texttt'>D</span>. Otherwise, the
behavior is undefined.</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/701df7eac2474300d2b602700a3c32a51ef439a7/source/expressions.tex#L2328'>#</a></div><p ><span class='indexparent'><a class='index' id='cast,pointer-to-member'></a></span>A prvalue of type “pointer to member of <span class='texttt'>D</span> of type <span class='textit'>cv1</span>
<span class='texttt'>T</span>” can be converted to a prvalue of type “pointer to member of
<span class='texttt'>B</span> of type <span class='textit'>cv2</span> <span class='texttt'>T</span>”, where <span class='texttt'>B</span> is a base
class (Clause <a href='class.derived'>[class.derived]</a>) of <span class='texttt'>D</span>,
if <span class='textit'>cv2</span> is the same cv-qualification
as, or greater cv-qualification than, <span class='textit'>cv1</span>.<a class='footnotenum' href='#footnote-72'>72</a>
If no valid standard conversion
from “pointer to member of <span class='texttt'>B</span> of type <span class='texttt'>T</span>”
to “pointer to member of <span class='texttt'>D</span> of type <span class='texttt'>T</span>”
exists (<a href='conv.mem'>[conv.mem]</a>), the program is ill-formed.
The null member pointer value (<a href='conv.mem'>[conv.mem]</a>) is converted to the null
member pointer value of the destination type. If class <span class='texttt'>B</span>
contains the original member, or is a base or derived class of the class
containing the original member, the resulting pointer to member points
to the original member. Otherwise, the behavior is undefined.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
Although class <span class='texttt'>B</span> need not contain the original member, the
dynamic type of the object with which indirection through the pointer
to member is performed must contain the original member;
see <a href='expr.mptr.oper'>[expr.mptr.oper]</a>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/701df7eac2474300d2b602700a3c32a51ef439a7/source/expressions.tex#L2354'>#</a></div><p >A prvalue of type “pointer to <span class='textit'>cv1</span> <span class='texttt'>void</span>” can be
converted to a prvalue of type “pointer to <span class='textit'>cv2</span> <span class='texttt'>T</span>”,
where <span class='texttt'>T</span> is an object type and <span class='textit'>cv2</span> is the same
cv-qualification as, or greater cv-qualification than, <span class='textit'>cv1</span>.
If the original pointer value represents the address
<span class='texttt'>A</span> of a byte in memory and
<span class='texttt'>A</span> does not satisfy the alignment requirement of <span class='texttt'>T</span>,
then the resulting pointer value is unspecified.
Otherwise, if the original pointer value points to an object <span class='textit'>a</span>,
and there is an object <span class='textit'>b</span> of type <span class='texttt'>T</span> (ignoring cv-qualification)
that is pointer-interconvertible (<a href='basic.compound'>[basic.compound]</a>) with <span class='textit'>a</span>,
the result is a pointer to <span class='textit'>b</span>.
Otherwise, the pointer value is unchanged by the conversion. 
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span></p><pre class='codeblock'>
T* p1 = new T;
const T* p2 = static_cast&lt;const T*&gt;(static_cast&lt;void*&gt;(p1));
bool b = p1 == p2;  <span class='comment'>// <span class='tcode_in_codeblock'>b</span> will have the value <span class='tcode_in_codeblock'>true</span>.
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='footnote' id='footnote-72'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-72'>72)</a></div><p >Function types
(including those used in pointer to member function
types) are never cv-qualified; see <a href='dcl.fct'>[dcl.fct]</a>.</p></div></div></div></body></html>