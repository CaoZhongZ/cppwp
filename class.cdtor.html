<!DOCTYPE html><html lang='en'><head><title>[class.cdtor]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>10</a> Classes <a class='abbr_ref' href='./#class'>[class]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>10.9</a> Initialization <a class='abbr_ref' href='class.init#class.cdtor'>[class.init]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>10.9.4</a> Construction and destruction <a class='abbr_ref'>[class.cdtor]</a></h3><span class='indexparent'><a class='index' id=':construction'></a></span><span class='indexparent'><a class='index' id=':destruction'></a></span><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L6202'>#</a></div><div id='1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':construction,member_access'></a></span><span class='indexparent'><a class='index' id=':destruction,member_access'></a></span>For an object with a non-trivial constructor, referring to any non-static member
or base class of the object before the constructor begins execution results in
undefined behavior<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>For an object with a non-trivial destructor, referring to
any non-static member or base class of the object after the destructor finishes
execution results in undefined behavior<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#1.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct X { int i; };
struct Y : X { Y(); };                  <span class='comment'>// non-trivial
</span>struct A { int a; };
struct B : public A { int j; Y y; };    <span class='comment'>// non-trivial
</span>
extern B bobj;
B* pb = &amp;bobj;                          <span class='comment'>// OK
</span>int* p1 = &amp;bobj.a;                      <span class='comment'>// undefined, refers to base class member
</span>int* p2 = &amp;bobj.y.i;                    <span class='comment'>// undefined, refers to member's member
</span>
A* pa = &amp;bobj;                          <span class='comment'>// undefined, upcast to a base class type
</span>B bobj;                                 <span class='comment'>// definition of <span class='tcode_in_codeblock'>bobj</span>
</span>
extern X xobj;
int* p3 = &amp;xobj.i;                      <span class='comment'>// OK, <span class='tcode_in_codeblock'>X</span> is a trivial class
</span>X xobj;</pre> <div id='1.sentence-3' class='sentence'>
For another example,
<pre class='codeblock'>
struct W { int j; };
struct X : public virtual W { };
struct Y {
  int* p;
  X x;
  Y() : p(&amp;x.j) {   <span class='comment'>// undefined, <span class='tcode_in_codeblock'>x</span> is not yet constructed
</span>    }
};</pre></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L6242'>#</a></div><div id='2.sentence-1' class='sentence'>During the construction of an object,
if the value of the object or any of its subobjects is
accessed through a glvalue that is not obtained, directly or indirectly, from
the constructor's
<span class='texttt'>this</span>
pointer, the value of the object or subobject thus obtained is unspecified<a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct C;
void no_opt(C*);

struct C {
  int c;
  C() : c(0) { no_opt(this); }
};

const C cobj;

void no_opt(C* cptr) {
  int i = cobj.c * 100;         <span class='comment'>// value of <span class='tcode_in_codeblock'>cobj.c</span> is unspecified
</span>  cptr-&gt;c = 1;
  cout &lt;&lt; cobj.c * 100          <span class='comment'>// value of <span class='tcode_in_codeblock'>cobj.c</span> is unspecified
</span>       &lt;&lt; '\n';
}

extern struct D d;
struct D {
  D(int a) : a(a), b(d.a) {}
  int a, b;
};
D d = D(1);                     <span class='comment'>// value of <span class='tcode_in_codeblock'>d.b</span> is unspecified
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L6278'>#</a></div><div id='3.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':construction,pointer_to_member_or_base'></a></span><span class='indexparent'><a class='index' id=':destruction,pointer_to_member_or_base'></a></span>To explicitly or implicitly convert a pointer (a glvalue) referring to
an object of class
<span class='texttt'>X</span>
to a pointer (reference) to a direct or indirect base class
<span class='texttt'>B</span>
of
<span class='texttt'>X</span>,
the construction of
<span class='texttt'>X</span>
and the construction of all of its direct or indirect bases that directly or
indirectly derive from
<span class='texttt'>B</span>
shall have started and the destruction of these classes shall not have
completed, otherwise the conversion results in undefined behavior<a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.sentence-2' class='sentence'>To form a pointer to (or access the value of) a direct non-static member of
an object
<span class='texttt'>obj</span>,
the construction of
<span class='texttt'>obj</span>
shall have started and its destruction shall not have completed,
otherwise the computation of the pointer value (or accessing the member
value) results in undefined behavior<a class='hidden_link' href='#3.sentence-2'>.</a></div> <div id='3.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#3.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A { };
struct B : virtual A { };
struct C : B { };
struct D : virtual A { D(A*); };
struct X { X(A*); };

struct E : C, D, X {
  E() : D(this),    <span class='comment'>// undefined: upcast from <span class='tcode_in_codeblock'>E*</span> to <span class='tcode_in_codeblock'>A*</span> might use path <span class='tcode_in_codeblock'>E*</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>D*</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>A*</span>
</span>                    <span class='comment'>// but <span class='tcode_in_codeblock'>D</span> is not constructed
</span>
                    <span class='comment'>// “<span class='tcode_in_codeblock'>D((C*)this)</span>” would be defined: <span class='tcode_in_codeblock'>E*</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>C*</span> is defined because <span class='tcode_in_codeblock'>E()</span> has started,
</span>                    <span class='comment'>// and <span class='tcode_in_codeblock'>C*</span> <span class='math'>→</span> <span class='tcode_in_codeblock'>A*</span> is defined because <span class='tcode_in_codeblock'>C</span> is fully constructed
</span>
  X(this) {}        <span class='comment'>// defined: upon construction of <span class='tcode_in_codeblock'>X</span>, <span class='tcode_in_codeblock'>C/B/D/A</span> sublattice is fully constructed
</span>};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L6323'>#</a></div><div id='4.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':virtual_function_call,constructor_and'></a></span><span class='indexparent'><a class='index' id=':virtual_function_call,destructor_and'></a></span><span class='indexparent'><a class='index' id=':construction,virtual_function_call'></a></span><span class='indexparent'><a class='index' id=':destruction,virtual_function_call'></a></span>Member functions, including virtual functions (<a href='class.virtual'>[class.virtual]</a>), can be called
during construction or destruction (<a href='class.base.init'>[class.base.init]</a>)<a class='hidden_link' href='#4.sentence-1'>.</a></div> <div id='4.sentence-2' class='sentence'>When a virtual function is called directly or indirectly from a constructor
or from a destructor,
including during the construction or destruction of the class's non-static data
members,
and the object to which the call applies is the object (call it <span class='texttt'>x</span>) under construction or
destruction,
the function called is the
final overrider in the constructor's or destructor's class and not one
overriding it in a more-derived class<a class='hidden_link' href='#4.sentence-2'>.</a></div> <div id='4.sentence-3' class='sentence'>If the virtual function call uses an explicit class member access (<a href='expr.ref'>[expr.ref]</a>)
and the object expression refers to
the complete object of <span class='texttt'>x</span> or one of that object's base class subobjects
but not <span class='texttt'>x</span> or one of its base class subobjects, the behavior
is undefined<a class='hidden_link' href='#4.sentence-3'>.</a></div> <div id='4.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct V {
  virtual void f();
  virtual void g();
};

struct A : virtual V {
  virtual void f();
};

struct B : virtual V {
  virtual void g();
  B(V*, A*);
};

struct D : A, B {
  virtual void f();
  virtual void g();
  D() : B((A*)this, this) { }
};

B::B(V* v, A* a) {
  f();              <span class='comment'>// calls <span class='tcode_in_codeblock'>V&#x200b;::&#x200b;f</span>, not <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;f</span>
</span>  g();              <span class='comment'>// calls <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;g</span>, not <span class='tcode_in_codeblock'>D&#x200b;::&#x200b;g</span>
</span>  v-&gt;g();           <span class='comment'>// <span class='tcode_in_codeblock'>v</span> is base of <span class='tcode_in_codeblock'>B</span>, the call is well-defined, calls <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;g</span>
</span>  a-&gt;f();           <span class='comment'>// undefined behavior, <span class='tcode_in_codeblock'>a</span>'s type not a base of <span class='tcode_in_codeblock'>B</span>
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L6376'>#</a></div><div id='5.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':construction,typeid_operator'></a></span><span class='indexparent'><a class='index' id=':destruction,typeid_operator'></a></span><span class='indexparent'><a class='index' id=':typeid,construction_and'></a></span><span class='indexparent'><a class='index' id=':typeid,destruction_and'></a></span>The
<span class='texttt'>typeid</span>
operator (<a href='expr.typeid'>[expr.typeid]</a>) can be used during construction or destruction (<a href='class.base.init'>[class.base.init]</a>)<a class='hidden_link' href='#5.sentence-1'>.</a></div> <div id='5.sentence-2' class='sentence'>When
<span class='texttt'>typeid</span>
is used in a constructor (including the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> or default member initializer (<a href='class.mem'>[class.mem]</a>)
for a non-static data member)
or in a destructor, or used in a function called (directly or indirectly) from
a constructor or destructor, if the operand of
<span class='texttt'>typeid</span>
refers to the object under construction or destruction,
<span class='texttt'>typeid</span>
yields the
<span class='texttt'>std&#x200b;::&#x200b;type_&shy;info</span>
object representing the constructor or destructor's class<a class='hidden_link' href='#5.sentence-2'>.</a></div> <div id='5.sentence-3' class='sentence'>If the operand of
<span class='texttt'>typeid</span>
refers to the object under construction or destruction and the static type of
the operand is neither the constructor or destructor's class nor one of its
bases, the behavior is undefined<a class='hidden_link' href='#5.sentence-3'>.</a></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/72f1bb19b4700cf4c6478b84a517150a43a91dd2/source/classes.tex#L6403'>#</a></div><div id='6.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':construction,dynamic_cast_and'></a></span><span class='indexparent'><a class='index' id=':destruction,dynamic_cast_and'></a></span><span class='indexparent'><a class='index' id=':cast,dynamic,construction_and'></a></span><span class='indexparent'><a class='index' id=':cast,dynamic,destruction_and'></a></span><span class='texttt'>dynamic_&shy;cast</span>s (<a href='expr.dynamic.cast'>[expr.dynamic.cast]</a>) can be used during construction
or destruction (<a href='class.base.init'>[class.base.init]</a>)<a class='hidden_link' href='#6.sentence-1'>.</a></div> <div id='6.sentence-2' class='sentence'>When a
<span class='texttt'>dynamic_&shy;cast</span>
is used in a constructor (including the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> or default member initializer
for a non-static data member)
or in a destructor, or used in a function called (directly or indirectly) from
a constructor or destructor, if the operand of the
<span class='texttt'>dynamic_&shy;cast</span>
refers to the object under construction or destruction, this object is
considered to be a most derived object that has the type of the constructor or
destructor's class<a class='hidden_link' href='#6.sentence-2'>.</a></div> <div id='6.sentence-3' class='sentence'>If the operand of the
<span class='texttt'>dynamic_&shy;cast</span>
refers to the object under construction or destruction and the static type of
the operand is not a pointer to or object of the constructor or destructor's
own class or one of its bases, the
<span class='texttt'>dynamic_&shy;cast</span>
results in undefined behavior<a class='hidden_link' href='#6.sentence-3'>.</a></div> <div id='6.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#6.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct V {
  virtual void f();
};

struct A : virtual V { };

struct B : virtual V {
  B(V*, A*);
};

struct D : A, B {
  D() : B((A*)this, this) { }
};

B::B(V* v, A* a) {
  typeid(*this);                <span class='comment'>// <span class='tcode_in_codeblock'>type_&shy;info</span> for <span class='tcode_in_codeblock'>B</span>
</span>  typeid(*v);                   <span class='comment'>// well-defined: <span class='tcode_in_codeblock'>*v</span> has type <span class='tcode_in_codeblock'>V</span>, a base of <span class='tcode_in_codeblock'>B</span> yields <span class='tcode_in_codeblock'>type_&shy;info</span> for <span class='tcode_in_codeblock'>B</span>
</span>  typeid(*a);                   <span class='comment'>// undefined behavior: type <span class='tcode_in_codeblock'>A</span> not a base of <span class='tcode_in_codeblock'>B</span>
</span>  dynamic_cast&lt;B*&gt;(v);          <span class='comment'>// well-defined: <span class='tcode_in_codeblock'>v</span> of type <span class='tcode_in_codeblock'>V*</span>, <span class='tcode_in_codeblock'>V</span> base of <span class='tcode_in_codeblock'>B</span> results in <span class='tcode_in_codeblock'>B*</span>
</span>  dynamic_cast&lt;B*&gt;(a);          <span class='comment'>// undefined behavior, <span class='tcode_in_codeblock'>a</span> has type <span class='tcode_in_codeblock'>A*</span>, <span class='tcode_in_codeblock'>A</span> not a base of <span class='tcode_in_codeblock'>B</span>
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  </div></div></body></html>