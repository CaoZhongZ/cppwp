<!DOCTYPE html><html lang='en'><head><title>[dcl.type.cv]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Declarations <a class='abbr_ref' href='./#dcl.dcl'>[dcl.dcl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>7.1</a> Specifiers <a class='abbr_ref' href='dcl.spec#dcl.type.cv'>[dcl.spec]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>7.1.7</a> Type specifiers <a class='abbr_ref' href='dcl.type#cv'>[dcl.type]</a></h3><div id='dcl.type.cv'><h4 ><a class='secnum' style='min-width:118pt'>7.1.7.1</a> The <span class='grammarterm'>cv-qualifier</span>s <a class='abbr_ref'>[dcl.type.cv]</a></h4><p ><span class='indexparent'><a class='index' id='specifier,cv-qualifier'></a></span><span class='indexparent'><a class='index' id='initialization,const'></a></span><span class='indexparent'><a class='index' id='type_specifier,const'></a></span><span class='indexparent'><a class='index' id='type_specifier,volatile'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/88657c99d3781984bf06d1f89e6e32d3b0051830/source/declarations.tex#L1126'>#</a></div><p >There are two <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i>s, <span class='texttt'>const</span> and
<span class='texttt'>volatile</span>. Each <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i> shall appear at most once in
a <i ><a href='dcl.decl#nt:cv-qualifier-seq'>cv-qualifier-seq</a></i>. If a <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i> appears in a
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, the <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i>
or <i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i> of
the declaration shall not be empty.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
<a href='basic.type.qualifier'>[basic.type.qualifier]</a> and <a href='dcl.fct'>[dcl.fct]</a> describe how cv-qualifiers affect object and
function types.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
Redundant cv-qualifications are ignored. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> For example,
these could be introduced by typedefs.<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/88657c99d3781984bf06d1f89e6e32d3b0051830/source/declarations.tex#L1140'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
Declaring a variable <span class='texttt'>const</span> can affect its linkage (<a href='dcl.stc'>[dcl.stc]</a>)
and its usability in <a href='expr.const'>constant expressions</a>. As
described in <a href='dcl.init'>[dcl.init]</a>, the definition of an object or subobject
of const-qualified type must specify an initializer or be subject to
default-initialization.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/88657c99d3781984bf06d1f89e6e32d3b0051830/source/declarations.tex#L1149'>#</a></div><p >A pointer or reference to a cv-qualified type need not actually point or
refer to a cv-qualified object, but it is treated as if it does; a
const-qualified access path cannot be used to modify an object even if
the object referenced is a non-const object and can be modified through
some other access path.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
Cv-qualifiers are supported by the type system so that they cannot be
subverted without <a href='expr.const.cast'>casting</a>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/88657c99d3781984bf06d1f89e6e32d3b0051830/source/declarations.tex#L1160'>#</a></div><p ><span class='indexparent'><a class='index' id='const_object,undefined_change_to'></a></span>Except that any class member declared <a href='dcl.stc#mutable'><span class='texttt'>mutable</span></a>
can be modified, any attempt to modify a <span class='texttt'>const</span> object during its
<a href='basic.life#def:lifetime'>lifetime</a> results in undefined behavior.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><p ><pre class='codeblock'>
const int ci = 3;                       <span class='comment'>// cv-qualified (initialized as required)
</span>ci = 4;                                 <span class='comment'>// ill-formed: attempt to modify <span class='tcode_in_codeblock'>const</span>
</span>
int i = 2;                              <span class='comment'>// not cv-qualified
</span>const int* cip;                         <span class='comment'>// pointer to <span class='tcode_in_codeblock'>const int</span>
</span>cip = &amp;i;                               <span class='comment'>// OK: cv-qualified access path to unqualified
</span>*cip = 4;                               <span class='comment'>// ill-formed: attempt to modify through ptr to <span class='tcode_in_codeblock'>const</span>
</span>
int* ip;
ip = const_cast&lt;int*&gt;(cip);             <span class='comment'>// cast needed to convert <span class='tcode_in_codeblock'>const int*</span> to <span class='tcode_in_codeblock'>int*</span>
</span>*ip = 4;                                <span class='comment'>// defined: <span class='tcode_in_codeblock'>*ip</span> points to <span class='tcode_in_codeblock'>i</span>, a non-<span class='tcode_in_codeblock'>const</span> object
</span>
const int* ciq = new const int (3);     <span class='comment'>// initialized as required
</span>int* iq = const_cast&lt;int*&gt;(ciq);        <span class='comment'>// cast required
</span>*iq = 4;                                <span class='comment'>// undefined: modifies a <span class='tcode_in_codeblock'>const</span> object
</span></pre></p><p >For another example,
</p><p ><pre class='codeblock'>
struct X {
  mutable int i;
  int j;
};
struct Y {
  X x;
  Y();
};

const Y y;
y.x.i++;                                <span class='comment'>// well-formed: <span class='tcode_in_codeblock'>mutable</span> member can be modified
</span>y.x.j++;                                <span class='comment'>// ill-formed: const-qualified member modified
</span>Y* p = const_cast&lt;Y*&gt;(&amp;y);              <span class='comment'>// cast away const-ness of <span class='tcode_in_codeblock'>y</span>
</span>p-&gt;x.i = 99;                            <span class='comment'>// well-formed: <span class='tcode_in_codeblock'>mutable</span> member can be modified
</span>p-&gt;x.j = 99;                            <span class='comment'>// undefined: modifies a <span class='tcode_in_codeblock'>const</span> member
</span></pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/88657c99d3781984bf06d1f89e6e32d3b0051830/source/declarations.tex#L1203'>#</a></div><p >What constitutes an access to an object that has volatile-qualified type is
<span class='indexparent'><a class='index' id='what_constitutes_an_access_to_an_object_that_has_volatile-qualified_type'></a></span>implementation-defined.
If an attempt is made to refer to an object defined with a
volatile-qualified type through the use of a glvalue with a
non-volatile-qualified type, the behavior is undefined.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/88657c99d3781984bf06d1f89e6e32d3b0051830/source/declarations.tex#L1210'>#</a></div><p ><span class='indexparent'><a class='index' id='type_specifier,volatile'></a></span><span class='indexparent'><a class='index' id='volatile,implementation-defined'></a></span>[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
<span class='texttt'>volatile</span> is a hint to the implementation to avoid aggressive
optimization involving the object because the value of the object might
be changed by means undetectable by an implementation.
Furthermore, for some implementations, <span class='texttt'>volatile</span> might indicate that
special hardware instructions are required to access the object.
See <a href='intro.execution'>[intro.execution]</a> for detailed semantics. In general, the
semantics of <span class='texttt'>volatile</span> are intended to be the same in C++ as
they are in C.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div></div></body></html>