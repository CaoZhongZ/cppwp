<!DOCTYPE html><html lang='en'><head><title>[new.delete]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>18</a> Language support library <a class='abbr_ref' href='./#language.support'>[language.support]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>18.6</a> Dynamic memory management <a class='abbr_ref' href='support.dynamic#new.delete'>[support.dynamic]</a></h2><div id='new.delete'><h3 ><a class='secnum' style='min-width:103pt'>18.6.2</a> Storage allocation and deallocation <a class='abbr_ref'>[new.delete]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Except where otherwise specified, the provisions of (<a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>)
apply to the library versions of <span class='texttt'>operator new</span> and <span class='texttt'>operator
delete</span>.
If the value of an alignment argument
passed to any of these functions
is not a valid alignment value,
the behavior is undefined.</p></div><div id='single'><h4 ><a class='secnum' href='#single' style='min-width:118pt'>18.6.2.1</a> Single-object forms <a class='abbr_ref' href='new.delete.single'>[new.delete.single]</a></h4><p ><span class='indexparent'><a class='index' id='new,operator'></a></span><code class='itemdecl'>
void* operator new(std::size_t size);
void* operator new(std::size_t size, std::align_val_t alignment);
</code></p><div class='itemdescr'></div><div class='para' id='single-1'><div class='marginalizedparent'><a class='marginalized' href='#single-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
The
allocation functions (<a href='basic.stc.dynamic.allocation'>[basic.stc.dynamic.allocation]</a>)
called by a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> (<a href='expr.new'>[expr.new]</a>)
to allocate
<span class='texttt'>size</span> bytes of storage.
The second form is called for a type with new-extended alignment,
and allocates storage
with the specified alignment.
The first form is called otherwise,
and allocates storage
suitably aligned to represent any object of that size
provided the object's type does not have new-extended alignment.</p></div></div><div class='para' id='single-2'><div class='marginalizedparent'><a class='marginalized' href='#single-2'>2</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with either of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.</p></div></div><div class='para' id='single-3'><div class='marginalizedparent'><a class='marginalized' href='#single-3'>3</a></div><div class='itemdescr'><p ><i>Required behavior:</i> 
Return a non-null pointer to suitably aligned storage (<a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>),
or else throw a
<span class='texttt'>bad_alloc</span>
<span class='indexparent'><a class='index' id='bad_alloc'></a></span>exception.
This requirement is binding on any replacement versions of these functions.</p></div></div><div class='para' id='single-4'><div class='marginalizedparent'><a class='marginalized' href='#single-4'>4</a></div><div class='itemdescr'><p ><i>Default behavior:</i></p><ul class='itemize'><li id='single-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#single-4.1'>(4.1)</a></div><p >Executes a loop:
Within the loop, the function first attempts to allocate the requested storage.
Whether the attempt involves a call to the C standard library functions
<span class='texttt'>malloc</span> or <span class='texttt'>aligned_alloc</span>
is unspecified.
<span class='indexparent'><a class='index' id='unspecified'></a></span></p></li><li id='single-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#single-4.2'>(4.2)</a></div><p >Returns a pointer to the allocated storage if the attempt is successful.
Otherwise, if the
current <span class='texttt'>new_handler</span> (<a href='get.new.handler'>[get.new.handler]</a>) is
a null pointer value, throws
<span class='texttt'>bad_alloc</span>.
</p></li><li id='single-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#single-4.3'>(4.3)</a></div><p >Otherwise, the function calls the current
<span class='texttt'>new_handler</span> function (<a href='new.handler'>[new.handler]</a>).
If the called function returns, the loop repeats.
</p></li><li id='single-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#single-4.4'>(4.4)</a></div><p >The loop terminates when an attempt to allocate the requested storage is
successful or when a called
<span class='texttt'>new_handler</span>
function does not return.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='new,operator'></a></span><code class='itemdecl'>
void* operator new(std::size_t size, const std::nothrow_t&amp;) noexcept;
void* operator new(std::size_t size, std::align_val_t alignment, const std::nothrow_t&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='single-5'><div class='marginalizedparent'><a class='marginalized' href='#single-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Same as above, except that these are called by a placement version of a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i>
when a C++ program prefers a null pointer result as an error indication,
instead of a
<span class='texttt'>bad_alloc</span>
exception.</p></div></div><div class='para' id='single-6'><div class='marginalizedparent'><a class='marginalized' href='#single-6'>6</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with either of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.</p></div></div><div class='para' id='single-7'><div class='marginalizedparent'><a class='marginalized' href='#single-7'>7</a></div><div class='itemdescr'><p ><i>Required behavior:</i>
Return a non-null pointer to suitably aligned storage (<a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>),
or else return a null pointer.
Each of these nothrow versions of
<span class='texttt'>operator new</span>
returns a pointer obtained as if
acquired from the (possibly replaced)
corresponding non-placement function.
This requirement is binding on any replacement versions of these functions.</p></div></div><div class='para' id='single-8'><div class='marginalizedparent'><a class='marginalized' href='#single-8'>8</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
Calls <span class='texttt'>operator new(size)</span>,
or <span class='texttt'>operator new(size, alignment)</span>,
respectively.
If the call returns normally,
returns the result of that call.
Otherwise, returns a null pointer.</p></div></div><div class='para' id='single-9'><div class='marginalizedparent'><a class='marginalized' href='#single-9'>9</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
T* p1 = new T;                  <span class='comment'>// throws <span class='texttt'>bad_alloc</span> if it fails
</span>T* p2 = new(nothrow) T;         <span class='comment'>// returns <span class='texttt'>nullptr</span> if it fails
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='delete,operator'></a></span><code class='itemdecl'>
void operator delete(void* ptr) noexcept;
void operator delete(void* ptr, std::size_t size) noexcept;
void operator delete(void* ptr, std::align_val_t alignment) noexcept;
void operator delete(void* ptr, std::size_t size, std::align_val_t alignment) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='single-10'><div class='marginalizedparent'><a class='marginalized' href='#single-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
The
deallocation functions (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>)
called by a
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>
to render the value of <span class='texttt'>ptr</span> invalid.</p></div></div><div class='para' id='single-11'><div class='marginalizedparent'><a class='marginalized' href='#single-11'>11</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with any of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.
If a function without a <span class='texttt'>size</span> parameter is defined,
the program should also define
the corresponding function with a <span class='texttt'>size</span> parameter.
If a function with a <span class='texttt'>size</span> parameter is defined,
the program shall also define
the corresponding version without the <span class='texttt'>size</span> parameter.
[&nbsp;<i>Note:</i>
The default behavior below may change in the future, which will require
replacing both deallocation functions when replacing the allocation function.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='single-12'><div class='marginalizedparent'><a class='marginalized' href='#single-12'>12</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>ptr</span> shall be a null pointer or
its value shall represent the address of
a block of memory allocated by
an earlier call to a (possibly replaced)
<span class='texttt'>operator new(std::size_t)</span>
or
<span class='texttt'>operator new(std::size_t, std::align_val_t)</span>
which has not been invalidated by an intervening call to
<span class='texttt'>operator delete</span>.</p></div></div><div class='para' id='single-13'><div class='marginalizedparent'><a class='marginalized' href='#single-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i>
If an implementation has strict pointer safety (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>)
then <span class='texttt'>ptr</span> shall be a safely-derived pointer.</p></div></div><div class='para' id='single-14'><div class='marginalizedparent'><a class='marginalized' href='#single-14'>14</a></div><div class='itemdescr'><p ><i>Requires:</i>
If the <span class='texttt'>alignment</span> parameter is not present,
<span class='texttt'>ptr</span> shall have been returned by an allocation function
without an <span class='texttt'>alignment</span> parameter.
If present, the <span class='texttt'>alignment</span> argument
shall equal the <span class='texttt'>alignment</span> argument
passed to the allocation function that returned <span class='texttt'>ptr</span>.
If present, the <span class='texttt'>size</span> argument
shall equal the <span class='texttt'>size</span> argument
passed to the allocation function that returned <span class='texttt'>ptr</span>.</p></div></div><div class='para' id='single-15'><div class='marginalizedparent'><a class='marginalized' href='#single-15'>15</a></div><div class='itemdescr'><p ><i>Required behavior:</i>
A call to an <span class='texttt'>operator delete</span>
with a <span class='texttt'>size</span> parameter
may be changed to
a call to the corresponding <span class='texttt'>operator delete</span>
without a <span class='texttt'>size</span> parameter,
without affecting memory allocation.
[&nbsp;<i>Note:</i> A conforming implementation is for
<span class='texttt'>operator delete(void* ptr, std::size_t size)</span> to simply call
<span class='texttt'>operator delete(ptr)</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='single-16'><div class='marginalizedparent'><a class='marginalized' href='#single-16'>16</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
The functions that have a <span class='texttt'>size</span> parameter
forward their other parameters
to the corresponding function without a <span class='texttt'>size</span> parameter.
[&nbsp;<i>Note:</i> See the note in the above <i>Replaceable</i> paragraph. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='single-17'><div class='marginalizedparent'><a class='marginalized' href='#single-17'>17</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
If <span class='texttt'>ptr</span> is null, does nothing. Otherwise, reclaims the
storage allocated by the earlier call to <span class='texttt'>operator new</span>.</p></div></div><div class='para' id='single-18'><div class='marginalizedparent'><a class='marginalized' href='#single-18'>18</a></div><div class='itemdescr'><p ><i>Remarks:</i>
It is unspecified under what conditions part or all of such
<span class='indexparent'><a class='index' id='unspecified'></a></span>reclaimed storage will be allocated by subsequent
calls to
<span class='texttt'>operator new</span>
or any of
<span class='texttt'>aligned_alloc</span>,
<span class='texttt'>calloc</span>,
<span class='texttt'>malloc</span>,
or
<span class='texttt'>realloc</span>,
declared in
<span class='texttt'>&lt;cstdlib&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='delete,operator'></a></span><code class='itemdecl'>
void operator delete(void* ptr, const std::nothrow_t&amp;) noexcept;
void operator delete(void* ptr, std::align_val_t alignment, const std::nothrow_t&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='single-19'><div class='marginalizedparent'><a class='marginalized' href='#single-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i>
The
deallocation functions (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>)
called by the implementation
to render the value of <span class='texttt'>ptr</span> invalid
when the constructor invoked from a nothrow
placement version of the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> throws an exception.</p></div></div><div class='para' id='single-20'><div class='marginalizedparent'><a class='marginalized' href='#single-20'>20</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with either of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.</p></div></div><div class='para' id='single-21'><div class='marginalizedparent'><a class='marginalized' href='#single-21'>21</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>ptr</span> shall be a null pointer or
its value shall represent the address of
a block of memory allocated by
an earlier call to a (possibly replaced)
<span class='texttt'>operator new(std::size_t)</span>
or
<span class='texttt'>operator new(std::size_t, std::align_val_t)</span>
which has not been invalidated by an intervening call to
<span class='texttt'>operator delete</span>.</p></div></div><div class='para' id='single-22'><div class='marginalizedparent'><a class='marginalized' href='#single-22'>22</a></div><div class='itemdescr'><p ><i>Requires:</i>
If an implementation has strict pointer safety (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>)
then <span class='texttt'>ptr</span> shall be a safely-derived pointer.</p></div></div><div class='para' id='single-23'><div class='marginalizedparent'><a class='marginalized' href='#single-23'>23</a></div><div class='itemdescr'><p ><i>Requires:</i>
If the <span class='texttt'>alignment</span> parameter is not present,
<span class='texttt'>ptr</span> shall have been returned by an allocation function
without an <span class='texttt'>alignment</span> parameter.
If present, the <span class='texttt'>alignment</span> argument
shall equal the <span class='texttt'>alignment</span> argument
passed to the allocation function that returned <span class='texttt'>ptr</span>.</p></div></div><div class='para' id='single-24'><div class='marginalizedparent'><a class='marginalized' href='#single-24'>24</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
Calls <span class='texttt'>operator delete(ptr)</span>,
or <span class='texttt'>operator delete(ptr, alignment)</span>,
respectively.
</p></div></div></div><div id='array'><h4 ><a class='secnum' href='#array' style='min-width:118pt'>18.6.2.2</a> Array forms <a class='abbr_ref' href='new.delete.array'>[new.delete.array]</a></h4><p ><span class='indexparent'><a class='index' id='new,operator'></a></span><code class='itemdecl'>
void* operator new[](std::size_t size);
void* operator new[](std::size_t size, std::align_val_t alignment);
</code></p><div class='itemdescr'></div><div class='para' id='array-1'><div class='marginalizedparent'><a class='marginalized' href='#array-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
The
allocation functions (<a href='basic.stc.dynamic.allocation'>[basic.stc.dynamic.allocation]</a>)
called by the array form of a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> (<a href='expr.new'>[expr.new]</a>)
to allocate
<span class='texttt'>size</span> bytes of storage.
The second form is called for a type with new-extended alignment,
and allocates storage
with the specified alignment.
The first form is called otherwise,
and allocates storage
suitably aligned to represent any array object of that size or smaller,
provided the object's type does not have new-extended alignment.<a class='footnotenum' href='#footnote-220'>220</a></p></div></div><div class='para' id='array-2'><div class='marginalizedparent'><a class='marginalized' href='#array-2'>2</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with either of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.</p></div></div><div class='para' id='array-3'><div class='marginalizedparent'><a class='marginalized' href='#array-3'>3</a></div><div class='itemdescr'><p ><i>Required behavior:</i>
Same as for
the corresponding single-object forms.
This requirement is binding on any replacement versions of these functions.</p></div></div><div class='para' id='array-4'><div class='marginalizedparent'><a class='marginalized' href='#array-4'>4</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
Returns
<span class='texttt'>operator new(size)</span>,
or
<span class='texttt'>operator new(size, alignment)</span>,
respectively.
</p></div></div><p ><span class='indexparent'><a class='index' id='new,operator'></a></span><code class='itemdecl'>
void* operator new[](std::size_t size, const std::nothrow_t&amp;) noexcept;
void* operator new[](std::size_t size, std::align_val_t alignment, const std::nothrow_t&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='array-5'><div class='marginalizedparent'><a class='marginalized' href='#array-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Same as above, except that these are called by a placement version of a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i>
when a C++ program prefers a null pointer result as an error indication,
instead of a
<span class='texttt'>bad_alloc</span>
exception.</p></div></div><div class='para' id='array-6'><div class='marginalizedparent'><a class='marginalized' href='#array-6'>6</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with either of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.</p></div></div><div class='para' id='array-7'><div class='marginalizedparent'><a class='marginalized' href='#array-7'>7</a></div><div class='itemdescr'><p ><i>Required behavior:</i>
Return a non-null pointer to suitably aligned storage (<a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>),
or else return a null pointer.
Each of these nothrow versions of
<span class='texttt'>operator new[]</span>
returns a pointer obtained as if
acquired from the (possibly replaced)
corresponding non-placement function.
This requirement is binding on any replacement versions of these functions.</p></div></div><div class='para' id='array-8'><div class='marginalizedparent'><a class='marginalized' href='#array-8'>8</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
Calls <span class='texttt'>operator new[](size)</span>,
or <span class='texttt'>operator new[](size, alignment)</span>,
respectively.
If the call returns normally,
returns the result of that call.
Otherwise, returns a null pointer.
</p></div></div><p ><span class='indexparent'><a class='index' id='delete,operator'></a></span><code class='itemdecl'>
void operator delete[](void* ptr) noexcept;
void operator delete[](void* ptr, std::size_t size) noexcept;
void operator delete[](void* ptr, std::align_val_t alignment) noexcept;
void operator delete[](void* ptr, std::size_t size, std::align_val_t alignment) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='array-9'><div class='marginalizedparent'><a class='marginalized' href='#array-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
The
deallocation functions (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>)
called by the array form of a
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>
to render the value of <span class='texttt'>ptr</span> invalid.</p></div></div><div class='para' id='array-10'><div class='marginalizedparent'><a class='marginalized' href='#array-10'>10</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with any of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.
If a function without a <span class='texttt'>size</span> parameter is defined,
the program should also define
the corresponding function with a <span class='texttt'>size</span> parameter.
If a function with a <span class='texttt'>size</span> parameter is defined,
the program shall also define
the corresponding version without the <span class='texttt'>size</span> parameter.
[&nbsp;<i>Note:</i>
The default behavior below may change in the future, which will require
replacing both deallocation functions when replacing the allocation function.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='array-11'><div class='marginalizedparent'><a class='marginalized' href='#array-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>ptr</span> shall be a null pointer or
its value shall represent the address of
a block of memory allocated by
an earlier call to a (possibly replaced)
<span class='texttt'>operator new[](std::size_t)</span>
or
<span class='texttt'>operator new[](std::size_t, std::align_val_t)</span>
which has not been invalidated by an intervening call to
<span class='texttt'>operator delete[]</span>.</p></div></div><div class='para' id='array-12'><div class='marginalizedparent'><a class='marginalized' href='#array-12'>12</a></div><div class='itemdescr'><p ><i>Requires:</i>
If an implementation has strict pointer safety (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>)
then <span class='texttt'>ptr</span> shall be a safely-derived pointer.</p></div></div><div class='para' id='array-13'><div class='marginalizedparent'><a class='marginalized' href='#array-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i>
If the <span class='texttt'>alignment</span> parameter is not present,
<span class='texttt'>ptr</span> shall have been returned by an allocation function
without an <span class='texttt'>alignment</span> parameter.
If present, the <span class='texttt'>alignment</span> argument
shall equal the <span class='texttt'>alignment</span> argument
passed to the allocation function that returned <span class='texttt'>ptr</span>.
If present, the <span class='texttt'>size</span> argument
shall equal the <span class='texttt'>size</span> argument
passed to the allocation function that returned <span class='texttt'>ptr</span>.</p></div></div><div class='para' id='array-14'><div class='marginalizedparent'><a class='marginalized' href='#array-14'>14</a></div><div class='itemdescr'><p ><i>Required behavior:</i>
A call to an <span class='texttt'>operator delete[]</span>
with a <span class='texttt'>size</span> parameter
may be changed to
a call to the corresponding <span class='texttt'>operator delete[]</span>
without a <span class='texttt'>size</span> parameter,
without affecting memory allocation.
[&nbsp;<i>Note:</i> A conforming implementation is for
<span class='texttt'>operator delete[](void* ptr, std::size_t size)</span> to simply call
<span class='texttt'>operator delete[](ptr)</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='array-15'><div class='marginalizedparent'><a class='marginalized' href='#array-15'>15</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
The functions that have a <span class='texttt'>size</span> parameter
forward their other parameters
to the corresponding function without a <span class='texttt'>size</span> parameter.
The functions that do not have a <span class='texttt'>size</span> parameter
forward their parameters
to the corresponding <span class='texttt'>operator delete</span> (single-object) function.
</p></div></div><p ><span class='indexparent'><a class='index' id='delete,operator'></a></span><code class='itemdecl'>
void operator delete[](void* ptr, const std::nothrow_t&amp;) noexcept;
void operator delete[](void* ptr, std::align_val_t alignment, const std::nothrow_t&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='array-16'><div class='marginalizedparent'><a class='marginalized' href='#array-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i>
The
deallocation functions (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>)
called by the implementation
to render the value of <span class='texttt'>ptr</span> invalid
when the constructor invoked from a nothrow
placement version of the array <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> throws an exception.</p></div></div><div class='para' id='array-17'><div class='marginalizedparent'><a class='marginalized' href='#array-17'>17</a></div><div class='itemdescr'><p ><i>Replaceable:</i>
A C++ program may define functions with either of these function signatures,
and thereby displace the default versions defined by the
C++ standard library.</p></div></div><div class='para' id='array-18'><div class='marginalizedparent'><a class='marginalized' href='#array-18'>18</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>ptr</span> shall be a null pointer or
its value shall represent the address of
a block of memory allocated by
an earlier call to a (possibly replaced)
<span class='texttt'>operator new[](std::size_t)</span>
or
<span class='texttt'>operator new[](std::size_t, std::align_val_t)</span>
which has not been invalidated by an intervening call to
<span class='texttt'>operator delete[]</span>.</p></div></div><div class='para' id='array-19'><div class='marginalizedparent'><a class='marginalized' href='#array-19'>19</a></div><div class='itemdescr'><p ><i>Requires:</i>
If an implementation has strict pointer safety (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>)
then <span class='texttt'>ptr</span> shall be a safely-derived pointer.</p></div></div><div class='para' id='array-20'><div class='marginalizedparent'><a class='marginalized' href='#array-20'>20</a></div><div class='itemdescr'><p ><i>Requires:</i>
If the <span class='texttt'>alignment</span> parameter is not present,
<span class='texttt'>ptr</span> shall have been returned by an allocation function
without an <span class='texttt'>alignment</span> parameter.
If present, the <span class='texttt'>alignment</span> argument
shall equal the <span class='texttt'>alignment</span> argument
passed to the allocation function that returned <span class='texttt'>ptr</span>.</p></div></div><div class='para' id='array-21'><div class='marginalizedparent'><a class='marginalized' href='#array-21'>21</a></div><div class='itemdescr'><p ><i>Default behavior:</i>
Calls <span class='texttt'>operator delete[](ptr)</span>,
or <span class='texttt'>operator delete[](ptr, alignment)</span>,
respectively.
</p></div></div><div class='footnote' id='footnote-220'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-220'>220)</a></div><p >It is not the direct responsibility of
<span class='texttt'>operator new[]</span>
or
<span class='texttt'>operator delete[]</span>
to note the repetition count or element size of the array.
Those operations are performed elsewhere in the array
<span class='texttt'>new</span>
and
<span class='texttt'>delete</span>
expressions.
The array
<span class='texttt'>new</span>
expression, may, however, increase the <span class='texttt'>size</span> argument to
<span class='texttt'>operator new[]</span>
to obtain space to store supplemental information.</p></div></div><div id='placement'><h4 ><a class='secnum' href='#placement' style='min-width:118pt'>18.6.2.3</a> Non-allocating forms <a class='abbr_ref' href='new.delete.placement'>[new.delete.placement]</a></h4><div class='para' id='placement-1'><div class='marginalizedparent'><a class='marginalized' href='#placement-1'>1</a></div><p >These functions are reserved, a C++ program may not define functions that displace
the versions in the C++ standard library (<a href='constraints'>[constraints]</a>).
The provisions of (<a href='basic.stc.dynamic'>[basic.stc.dynamic]</a>) do not apply to these reserved
placement forms of <span class='texttt'>operator new</span> and <span class='texttt'>operator delete</span>.</p><p ><span class='indexparent'><a class='index' id='new,operator'></a></span><code class='itemdecl'>
void* operator new(std::size_t size, void* ptr) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='placement-2'><div class='marginalizedparent'><a class='marginalized' href='#placement-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>ptr</span>.</p></div></div><div class='para' id='placement-3'><div class='marginalizedparent'><a class='marginalized' href='#placement-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Intentionally performs no other action.</p></div></div><div class='para' id='placement-4'><div class='marginalizedparent'><a class='marginalized' href='#placement-4'>4</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
This can be useful for constructing an object at a known address:</p><pre class='codeblock'>
void* place = operator new(sizeof(Something));
Something* p = new (place) Something();
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='new,operator'></a></span><code class='itemdecl'>
void* operator new[](std::size_t size, void* ptr) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='placement-5'><div class='marginalizedparent'><a class='marginalized' href='#placement-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>ptr</span>.</p></div></div><div class='para' id='placement-6'><div class='marginalizedparent'><a class='marginalized' href='#placement-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Intentionally performs no other action.
</p></div></div><p ><span class='indexparent'><a class='index' id='delete,operator'></a></span><code class='itemdecl'>
void operator delete(void* ptr, void*) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='placement-7'><div class='marginalizedparent'><a class='marginalized' href='#placement-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Intentionally performs no action.</p></div></div><div class='para' id='placement-8'><div class='marginalizedparent'><a class='marginalized' href='#placement-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i>
If an implementation has strict pointer safety (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>)
then <span class='texttt'>ptr</span> shall be a safely-derived pointer.</p></div></div><div class='para' id='placement-9'><div class='marginalizedparent'><a class='marginalized' href='#placement-9'>9</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Default function called when any part of the initialization in a
placement <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> that invokes the library's
non-array placement operator new
terminates by throwing an exception (<a href='expr.new'>[expr.new]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='delete,operator'></a></span><code class='itemdecl'>
void operator delete[](void* ptr, void*) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='placement-10'><div class='marginalizedparent'><a class='marginalized' href='#placement-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
Intentionally performs no action.</p></div></div><div class='para' id='placement-11'><div class='marginalizedparent'><a class='marginalized' href='#placement-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i>
If an implementation has strict pointer safety (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>)
then <span class='texttt'>ptr</span> shall be a safely-derived pointer.</p></div></div><div class='para' id='placement-12'><div class='marginalizedparent'><a class='marginalized' href='#placement-12'>12</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Default function called when any part of the initialization in a
placement <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> that invokes the library's
array placement operator new
terminates by throwing an exception (<a href='expr.new'>[expr.new]</a>).
</p></div></div></div><div id='dataraces'><h4 ><a class='secnum' href='#dataraces' style='min-width:118pt'>18.6.2.4</a> Data races <a class='abbr_ref' href='new.delete.dataraces'>[new.delete.dataraces]</a></h4><div class='para' id='dataraces-1'><div class='marginalizedparent'><a class='marginalized' href='#dataraces-1'>1</a></div><p >For purposes of determining the existence of data races, the library versions
of <span class='texttt'>operator new</span>, user replacement versions of global <span class='texttt'>operator new</span>,
the C standard library functions
<span class='texttt'>aligned_alloc</span>, <span class='texttt'>calloc</span>, and <span class='texttt'>malloc</span>,
the library
versions of <span class='texttt'>operator delete</span>, user replacement
versions of <span class='texttt'>operator delete</span>, the C standard library function
<span class='texttt'>free</span>, and the C standard library function <span class='texttt'>realloc</span> shall not
introduce a data race (<a href='res.on.data.races'>[res.on.data.races]</a>).
Calls to these functions that allocate or deallocate a particular unit
of storage shall occur in a single total order, and each such deallocation call
shall happen before (<a href='intro.multithread'>[intro.multithread]</a>) the next allocation (if any) in
this order.</p></div></div></div></div></body></html>