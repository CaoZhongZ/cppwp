<!DOCTYPE html><html lang='en'><head><title>[dcl.init]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Declarators <a class='abbr_ref' href='./#dcl.decl'>[dcl.decl]</a></h1><div id='dcl.init'><h2 ><a class='secnum' style='min-width:88pt'>8.6</a> Initializers <a class='abbr_ref'>[dcl.init]</a></h2><p ><span class='indexparent'><a class='index' id='initialization'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A declarator can specify an initial value for the
identifier being declared.
The identifier designates a variable being initialized.
The process of initialization described in the
remainder of <a href='dcl.init'>[dcl.init]</a>
applies also to initializations
specified by other syntactic contexts, such as the initialization
of function parameters with argument expressions (<a href='expr.call'>[expr.call]</a>) or
the initialization of return values (<a href='stmt.return'>[stmt.return]</a>).</p><pre class='bnf'><a id='nt:initializer'>initializer:</a>
    <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i>
    <span class='terminal'>(</span> <i ><a href='expr.post#nt:expression-list'>expression-list</a></i> <span class='terminal'>)</span></pre><pre class='bnf'><a id='nt:brace-or-equal-initializer'>brace-or-equal-initializer:</a>
    <span class='terminal'>=</span> <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
    <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i></pre><pre class='bnf'><a id='nt:initializer-clause'>initializer-clause:</a>
    <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
    <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i></pre><pre class='bnf'><a id='nt:initializer-list'>initializer-list:</a>
    <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> <span class='terminal'>,</span> <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:braced-init-list'>braced-init-list:</a>
    <span class='terminal'>{</span> <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> <span class='terminal'>,<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <span class='terminal'>}</span>
    <span class='terminal'>{</span> <span class='terminal'>}</span></pre><pre class='bnf'><a id='nt:expr-or-braced-init-list'>expr-or-braced-init-list:</a>
    <i ><a href='expr.comma#nt:expression'>expression</a></i>
    <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i></pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Except for objects declared with the <span class='texttt'>constexpr</span> specifier, for which see <a href='dcl.constexpr'>[dcl.constexpr]</a>,
an <i ><a href='dcl.init#nt:initializer'>initializer</a></i> in the definition of a variable can consist of
arbitrary
<span class='indexparent'><a class='index' id='initialization,automatic_object'></a></span><span class='indexparent'><a class='index' id='initialization,static_object'></a></span>expressions involving literals and previously declared
variables and functions,
regardless of the variable's storage duration.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int f(int);
int a = 2;
int b = f(a);
int c(b);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Default arguments are more restricted; see <a href='dcl.fct.default'>[dcl.fct.default]</a>.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The order of initialization of variables with static storage duration is described in <a href='basic.start'>[basic.start]</a>
and <a href='stmt.dcl'>[stmt.dcl]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A declaration of a block-scope variable with external or internal
linkage that has an <i ><a href='dcl.init#nt:initializer'>initializer</a></i> is ill-formed.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='initialization,static_object'></a></span><span class='indexparent'><a class='index' id='initialization,default'></a></span><span class='indexparent'><a class='index' id='variable,indeterminate_uninitialized'></a></span><span class='indexparent'><a class='index' id='initialization,zero-initialization'></a></span><span class='indexparent'><a class='index' id='zero-initialization'></a></span>To
<span class='grammarterm'>zero-initialize</span>
an object or reference of type
<span class='texttt'>T</span>
means:</p><ul ><li ><p >if
<span class='texttt'>T</span>
is a scalar type (<a href='basic.types'>[basic.types]</a>), the
object
is initialized to the value obtained by converting the integer literal <span class='texttt'>0</span>
(zero) to
<span class='texttt'>T</span>;<a class='footnotenum' href='#footnote-103'>103</a></p></li><li ><p >if
<span class='texttt'>T</span>
is a (possibly cv-qualified) non-union class type,
each non-static data member and each
base-class subobject is zero-initialized and padding is initialized to zero bits;</p></li><li ><p >if
<span class='texttt'>T</span>
is a (possibly cv-qualified) union type,
the
object's first non-static named
data member
is zero-initialized and padding is initialized to zero bits;</p></li><li ><p >if
<span class='texttt'>T</span>
is an array type,
each element is zero-initialized;
</p></li><li ><p >if
<span class='texttt'>T</span>
is a reference type, no initialization is performed.
</p></li></ul></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p ><span class='indexparent'><a class='index' id='default-initialization'></a></span>To
<span class='grammarterm'>default-initialize</span>
an object of type
<span class='texttt'>T</span>
means:</p><ul ><li ><p >If
<span class='texttt'>T</span>
is a (possibly cv-qualified) class type (Clause <a href='class'>[class]</a>),
constructors are considered. The applicable constructors are
enumerated (<a href='over.match.ctor'>[over.match.ctor]</a>), and the best one for the
<i ><a href='dcl.init#nt:initializer'>initializer</a></i> <span class='texttt'>()</span> is chosen through
overload resolution (<a href='over.match'>[over.match]</a>). The constructor thus selected
is called, with an empty argument list, to initialize the object.</p></li><li ><p >If
<span class='texttt'>T</span>
is an array type, each element is default-initialized.</p></li><li ><p >Otherwise,
no initialization is performed.
</p></li></ul><p >If a program calls for the default-initialization of an object of a
const-qualified type <span class='texttt'>T</span>, <span class='texttt'>T</span> shall be a class type with a user-provided default constructor.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p ><span class='indexparent'><a class='index' id='value-initialization'></a></span>To
<a id='value-initialize'><i>value-initialize</i></a>
an object of type
<span class='texttt'>T</span>
means:</p><ul ><li ><p >if
<span class='texttt'>T</span>
is a (possibly cv-qualified) class type (Clause <a href='class'>[class]</a>) with
either no default constructor (<a href='class.ctor'>[class.ctor]</a>) or a default
constructor that is user-provided or deleted, then the object is default-initialized;</p></li><li ><p >if
<span class='texttt'>T</span>
is a (possibly cv-qualified) class type without a
user-provided or deleted default constructor,
then the object is zero-initialized and the semantic constraints for
default-initialization are checked, and if <span class='texttt'>T</span> has a
non-trivial default constructor, the object is default-initialized;</p></li><li ><p >if
<span class='texttt'>T</span>
is an array type, then each element is value-initialized;</p></li><li ><p >otherwise, the object is zero-initialized.
</p></li></ul><p >An object that is value-initialized is deemed to be constructed and thus subject to
provisions of this International Standard applying to “constructed” objects, objects
“for which the constructor has completed,” etc., even if no constructor is invoked
for the object's initialization.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >A program that calls for default-initialization
or value-initialization
of an entity
of reference type is ill-formed.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Every
object of static storage duration is
zero-initialized at program startup before any other initialization
takes place.
In some cases, additional initialization is done later.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >An object whose initializer is an empty set of parentheses, i.e.,
<span class='texttt'>()</span>,
shall be
value-initialized.</p><p ><span class='indexparent'><a class='index' id='ambiguity,function_declaration'></a></span>[&nbsp;<i>Note:</i><span class='space'></span>
Since
<span class='texttt'>()</span>
is not permitted by the syntax for
<i ><a href='dcl.init#nt:initializer'>initializer</a></i>,</p><pre class='codeblock'>
X a();
</pre><p >is not the declaration of an object of class
<span class='texttt'>X</span>,
but the declaration of a function taking no argument and returning an
<span class='texttt'>X</span>.
The form
<span class='texttt'>()</span>
is permitted in certain other initialization contexts (<a href='expr.new'>[expr.new]</a>,
<a href='expr.type.conv'>[expr.type.conv]</a>, <a href='class.base.init'>[class.base.init]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p ><span class='indexparent'><a class='index' id='value,indeterminate'></a></span><span class='indexparent'><a class='index' id='indeterminate_value'></a></span>If no initializer is specified for an object, the object is default-initialized.
When storage for an object with automatic or dynamic storage duration
is obtained, the object has an <i>indeterminate value</i>, and if
no initialization is performed for the object, that object retains an
indeterminate value until that value is replaced (<a href='expr.ass'>[expr.ass]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> Objects with static or thread storage duration are zero-initialized,
see <a href='basic.start.static'>[basic.start.static]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
If an indeterminate value is produced by an evaluation, the behavior is
undefined except in the following cases:</p><ul ><li ><p >If an indeterminate value of unsigned narrow character
type (<a href='basic.fundamental'>[basic.fundamental]</a>) is produced by the evaluation of:
</p><ul ><li ><p >the second or third operand of a conditional expression (<a href='expr.cond'>[expr.cond]</a>),
</p></li><li ><p >the right operand of a comma expression (<a href='expr.comma'>[expr.comma]</a>),
</p></li><li ><p >the operand of a cast or conversion to an unsigned narrow character
type (<a href='conv.integral'>[conv.integral]</a>, <a href='expr.type.conv'>[expr.type.conv]</a>, <a href='expr.static.cast'>[expr.static.cast]</a>,
<a href='expr.cast'>[expr.cast]</a>), or
</p></li><li ><p >a discarded-value expression (Clause <a href='expr'>[expr]</a>),
</p></li></ul><p >then the result of the operation is an indeterminate value.</p></li><li ><p >If an indeterminate value of unsigned narrow character
type is produced by the evaluation of the right
operand of a simple assignment operator (<a href='expr.ass'>[expr.ass]</a>) whose first operand
is an lvalue of unsigned narrow character type, an indeterminate value replaces
the value of the object referred to by the left operand.</p></li><li ><p >If an indeterminate value of unsigned narrow character type is produced by the
evaluation of the initialization expression when initializing an object of
unsigned narrow character type, that object is initialized to an indeterminate
value.
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
  int f(bool b) {
    unsigned char c;
    unsigned char d = c; <span class='comment'>// OK, <span class='texttt'>d</span> has an indeterminate value
</span>    int e = d;           <span class='comment'>// undefined behavior
</span>    return b ? d : 0;    <span class='comment'>// undefined behavior if <span class='texttt'>b</span> is <span class='texttt'>true</span>
</span>  }
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p ><span class='indexparent'><a class='index' id='initialization,class_member'></a></span>An initializer for a static member is in the scope of the member's class.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int a;

struct X {
  static int a;
  static int b;
};

int X::a = 1;
int X::b = a;       <span class='comment'>// <span class='texttt'>X::b = X::a</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><p >If the entity being initialized does not have class type, the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i> in a
parenthesized initializer shall be a single expression.</p></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><p ><span class='indexparent'><a class='index' id='initialization,copy'></a></span><span class='indexparent'><a class='index' id='initialization,direct'></a></span>The initialization that occurs in the <span class='texttt'>=</span> form of a
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> or
<i ><a href='stmt.stmt#nt:condition'>condition</a></i> (<a href='stmt.select'>[stmt.select]</a>),
as well as in argument passing, function return,
throwing an exception (<a href='except.throw'>[except.throw]</a>),
handling an exception (<a href='except.handle'>[except.handle]</a>),
and aggregate member initialization (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>),
is called
<a id='copy-initialization'><i>copy-initialization</i></a>.
[&nbsp;<i>Note:</i><span class='space'></span> Copy-initialization may invoke a move (<a href='class.copy'>[class.copy]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><p >The initialization that occurs in the forms</p><pre class='codeblock'>
T x(a);
T x{a};
</pre><p >as well as in
<span class='texttt'>new</span>
expressions (<a href='expr.new'>[expr.new]</a>),
<span class='texttt'>static_cast</span>
expressions (<a href='expr.static.cast'>[expr.static.cast]</a>),
functional notation type conversions (<a href='expr.type.conv'>[expr.type.conv]</a>),
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializers</a></i> (<a href='class.base.init'>[class.base.init]</a>), and
the <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> form of a <i ><a href='stmt.stmt#nt:condition'>condition</a></i>
is called
<span class='grammarterm'>direct-initialization</span>.</p></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><p >The semantics of initializers are as follows.
The
<span class='indexparent'><a class='index' id='type,destination'></a></span><i>destination type</i>
is the type of the object or reference being initialized and the
<i>source type</i>
is the type of the initializer expression.
If the initializer is not a single (possibly parenthesized) expression, the
source type is not defined.</p><ul ><li ><p >If the initializer is a (non-parenthesized) <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>, the object or reference
is list-initialized (<a href='dcl.init.list'>[dcl.init.list]</a>).
</p></li><li ><p >If the destination type is a reference type, see <a href='dcl.init.ref'>[dcl.init.ref]</a>.
</p></li><li ><p >If the destination type is an array of characters,
an array of <span class='texttt'>char16_t</span>,
an array of <span class='texttt'>char32_t</span>,
or an array of
<span class='texttt'>wchar_t</span>,
and the initializer is a string literal, see <a href='dcl.init.string'>[dcl.init.string]</a>.
</p></li><li ><p >If the initializer is <span class='texttt'>()</span>, the object is value-initialized.
</p></li><li ><p >Otherwise, if the destination type is an array, the program is ill-formed.
</p></li><li ><p >If the destination type is a (possibly cv-qualified) class type:</p><ul ><li ><p >If the initializer expression is a prvalue
and the cv-unqualified version of the source type
is the same class as the class of the destination,
the initializer expression is used to initialize the destination object.
[&nbsp;<i>Example:</i><span class='space'></span>
<span class='texttt'>T x = T(T(T()));</span> calls the <span class='texttt'>T</span> default constructor to initialize <span class='texttt'>x</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li ><p >Otherwise, if the initialization is direct-initialization,
or if it is copy-initialization where the cv-unqualified version of the source
type is the same class as, or a derived class of, the class of the destination,
constructors are considered.
The applicable constructors
are enumerated (<a href='over.match.ctor'>[over.match.ctor]</a>), and the best one is chosen
through overload resolution (<a href='over.match'>[over.match]</a>).
The constructor so selected
is called to initialize the object, with the initializer
expression or <i ><a href='expr.post#nt:expression-list'>expression-list</a></i> as its argument(s).
If no constructor applies, or the overload resolution is
ambiguous, the initialization is ill-formed.
</p></li><li ><p >Otherwise (i.e., for the remaining copy-initialization cases),
user-defined conversion sequences that can convert from the
source type to the destination type or (when a conversion function
is used) to a derived class thereof are enumerated as described in <a href='over.match.copy'>[over.match.copy]</a>, and the best one is chosen through overload
resolution (<a href='over.match'>[over.match]</a>).  If the conversion cannot be done or
is ambiguous, the initialization is ill-formed.  The function
selected is called with the initializer expression as its
argument; if the function is a constructor, the call is a prvalue
of the cv-unqualified version of the
destination type whose result object is initialized by the constructor.
The call is used
to direct-initialize, according to the rules above, the object
that is the destination of the copy-initialization.
</p></li></ul></li><li ><p >Otherwise, if the source type
is a (possibly cv-qualified) class type, conversion functions are
considered.
The applicable conversion functions are enumerated
(<a href='over.match.conv'>[over.match.conv]</a>), and the best one is chosen through overload
resolution (<a href='over.match'>[over.match]</a>).
The user-defined conversion so selected
is called to convert the initializer expression into the
object being initialized.
If the conversion cannot be done or is
ambiguous, the initialization is ill-formed.
</p></li><li ><p >Otherwise, the initial value of the object being initialized is
the (possibly converted) value of the initializer expression.
Standard conversions (Clause <a href='conv'>[conv]</a>) will be used, if necessary,
to convert the initializer expression to the cv-unqualified version of
the destination type;
no user-defined conversions are considered.
If the conversion cannot
be done, the initialization is ill-formed.
When initializing a bit-field with a value that it cannot represent, the
resulting value of the bit-field is
<span class='indexparent'><a class='index' id='value_of_bit-field_that_cannot_represent,initializer'></a></span>implementation-defined.
<span class='indexparent'><a class='index' id='initialization,const'></a></span>[&nbsp;<i>Note:</i><span class='space'></span>
An expression of type
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T</span>”
can initialize an object of type
“<span class='small'></span><span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T</span>”
independently of
the cv-qualifiers
<span class='small'></span><span class='rmfamily'></span><i> cv1</i>
and <span class='small'></span><span class='rmfamily'></span><i> cv2</i>.</p><pre class='codeblock'>
int a;
const int b = a;
int c = b;
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><p >An <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> followed by an ellipsis is a
pack expansion (<a href='temp.variadic'>[temp.variadic]</a>).</p></div><div class='para' id='19'><div class='marginalizedparent'><a class='marginalized' href='#19'>19</a></div><p >If the initializer is a parenthesized <i ><a href='expr.post#nt:expression-list'>expression-list</a></i>,
the expressions are evaluated in the order
specified for function calls (<a href='expr.call'>[expr.call]</a>).</p></div><div class='footnote' id='footnote-103'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-103'>103)</a></div><p >As specified in <a href='conv.ptr'>[conv.ptr]</a>, converting an integer
literal whose value is
<span class='texttt'>0</span>
to a pointer type results in a null pointer value.
</p></div><div id='aggr'><h3 ><a class='secnum' href='#aggr' style='min-width:103pt'>8.6.1</a> Aggregates <a class='abbr_ref' href='dcl.init.aggr'>[dcl.init.aggr]</a></h3><p ><span class='indexparent'><a class='index' id='aggregate'></a></span><span class='indexparent'><a class='index' id='initialization,aggregate'></a></span><span class='indexparent'><a class='index' id='aggregate_initialization'></a></span><span class='indexparent'><a class='index' id='initialization,array'></a></span><span class='indexparent'><a class='index' id='initialization,class_object'></a></span><span class='indexparent'><a class='index' id='class_object_initialization'></a></span><span class='indexparent'><a class='index' id='{},initializer_list'></a></span></p><div class='para' id='aggr-1'><div class='marginalizedparent'><a class='marginalized' href='#aggr-1'>1</a></div><p >An <a id='aggregate'><i>aggregate</i></a> is an array or a class (Clause <a href='class'>[class]</a>) with
</p><ul ><li ><p >no user-provided, <span class='texttt'>explicit</span>, or inherited constructors (<a href='class.ctor'>[class.ctor]</a>),
</p></li><li ><p >no private or protected non-static data members (Clause <a href='class.access'>[class.access]</a>),
</p></li><li ><p >no virtual functions (<a href='class.virtual'>[class.virtual]</a>), and
</p></li><li ><p >no virtual, private, or protected base classes (<a href='class.mi'>[class.mi]</a>).
</p></li></ul><p >[&nbsp;<i>Note:</i><span class='space'></span>
Aggregate initialization does not allow accessing
protected and private base class' members or constructors.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='aggr-2'><div class='marginalizedparent'><a class='marginalized' href='#aggr-2'>2</a></div><p ><span class='indexparent'><a class='index' id='aggregate,elements'></a></span>The <i>elements</i> of an aggregate are:
</p><ul ><li ><p >for an array, the array elements in increasing subscript order, or
</p></li><li ><p >for a class, the direct base classes in declaration order
followed by the direct members in declaration order.
</p></li></ul></div><div class='para' id='aggr-3'><div class='marginalizedparent'><a class='marginalized' href='#aggr-3'>3</a></div><p >When an aggregate is initialized by an initializer list
as specified in <a href='dcl.init.list'>[dcl.init.list]</a>,
the elements of the initializer list are taken as initializers
for the elements of the aggregate, in order.
Each element is copy-initialized
from the corresponding <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>.
If the <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> is an expression and
a narrowing conversion (<a href='dcl.init.list'>[dcl.init.list]</a>) is required
to convert the expression, the program is ill-formed.
[&nbsp;<i>Note:</i><span class='space'></span> If an <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> is itself an initializer list,
the element is list-initialized, which will result in a recursive application
of the rules in this section if the element is an aggregate. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A {
  int x;
  struct B {
    int i;
    int j;
  } b;
} a = { 1, { 2, 3 } };
</pre><p >initializes
<span class='texttt'>a.x</span>
with 1,
<span class='texttt'>a.b.i</span>
with 2,
<span class='texttt'>a.b.j</span>
with 3.</p><pre class='codeblock'>
struct base1 { int b1, b2 = 42; };
struct base2 {
  base2() {
    b3 = 42;
  }
  int b3;
};
struct derived : base1, base2 {
  int d;
};

derived d1{{1, 2}, {}, 4};
derived d2{{}, {}, 4};
</pre><p >initializes
<span class='texttt'>d1.b1</span> with 1,
<span class='texttt'>d1.b2</span> with 2,
<span class='texttt'>d1.b3</span> with 42,
<span class='texttt'>d1.d</span> with 4, and
<span class='texttt'>d2.b1</span> with 0,
<span class='texttt'>d2.b2</span> with 42,
<span class='texttt'>d2.b3</span> with 42,
<span class='texttt'>d2.d</span> with 4.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-4'><div class='marginalizedparent'><a class='marginalized' href='#aggr-4'>4</a></div><p >An aggregate that is a class can also be initialized with a single
expression not enclosed in braces, as described in <a href='dcl.init'>[dcl.init]</a>.</p></div><div class='para' id='aggr-5'><div class='marginalizedparent'><a class='marginalized' href='#aggr-5'>5</a></div><p >An array of unknown size initialized with a
brace-enclosed
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
containing
<span class='texttt'>n</span>
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>,
where
<span class='texttt'>n</span>
shall be greater than zero, is defined as having
<span class='texttt'>n</span>
elements (<a href='dcl.array'>[dcl.array]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int x[] = { 1, 3, 5 };
</pre><p >declares and initializes
<span class='texttt'>x</span>
as a one-dimensional array that has three elements
since no size was specified and there are three initializers.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
An empty initializer list
<span class='texttt'>{}</span>
shall not be used as the <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
for an array of unknown bound.<a class='footnotenum' href='#footnote-104'>104</a></p></div><div class='para' id='aggr-6'><div class='marginalizedparent'><a class='marginalized' href='#aggr-6'>6</a></div><p >Static data members and anonymous bit-fields are not considered
members of the class for purposes of aggregate initialization.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A {
  int i;
  static int s;
  int j;
  int :17;
  int k;
} a = { 1, 2, 3 };
</pre><p >Here, the second initializer 2 initializes
<span class='texttt'>a.j</span>
and not the static data member
<span class='texttt'>A::s</span>, and the third initializer 3 initializes <span class='texttt'>a.k</span>
and not the anonymous bit-field before it.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-7'><div class='marginalizedparent'><a class='marginalized' href='#aggr-7'>7</a></div><p >An
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
is ill-formed if the number of
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i> 
exceeds the number of members or elements to initialize.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
char cv[4] = { 'a', 's', 'd', 'f', 0 };     <span class='comment'>// error
</span></pre><p >is ill-formed.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-8'><div class='marginalizedparent'><a class='marginalized' href='#aggr-8'>8</a></div><p >If there are fewer <i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i> in the list than there
are elements in the aggregate, then each element not explicitly initialized
shall be initialized from its default member initializer (<a href='class.mem'>[class.mem]</a>) or,
if there is no default member initializer, from an empty
initializer list (<a href='dcl.init.list'>[dcl.init.list]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct S { int a; const char* b; int c; int d = b[a]; };
S ss = { 1, "asdf" };
</pre><p >initializes
<span class='texttt'>ss.a</span>
with 1,
<span class='texttt'>ss.b</span>
with <span class='texttt'>"asdf"</span>,
<span class='texttt'>ss.c</span>
with the value of an expression of the form
<span class='texttt'>int{}</span>
(that is, <span class='texttt'>0</span>), and <span class='texttt'>ss.d</span> with the value of <span class='texttt'>ss.b[ss.a]</span>
(that is, <span class='texttt'>'s'</span>), and in</p><pre class='codeblock'>
struct X { int i, j, k = 42; };
X a[] = { 1, 2, 3, 4, 5, 6 };
X b[2] = { { 1, 2, 3 }, { 4, 5, 6 } };
</pre><p ><span class='texttt'>a</span> and <span class='texttt'>b</span> have the same value
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-9'><div class='marginalizedparent'><a class='marginalized' href='#aggr-9'>9</a></div><p >If a reference member is initialized from its default member initializer
and a potentially-evaluated subexpression thereof is an aggregate
initialization that would use that default member initializer,
the program is ill-formed.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
  struct A;
  extern A a;
  struct A {
    const A&amp; a1 { A{a,a} };   <span class='comment'>// OK
</span>    const A&amp; a2 { A{} };      <span class='comment'>// error
</span>  };
  A a{a,a};                   <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-10'><div class='marginalizedparent'><a class='marginalized' href='#aggr-10'>10</a></div><p >If an aggregate class <span class='texttt'>C</span> contains a subaggregate element
<span class='texttt'>e</span> that has no elements for purposes of aggregate initialization,
the <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> for <span class='texttt'>e</span> shall not be
omitted from an <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> for an object of type
<span class='texttt'>C</span> unless the <i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i> for all
elements of <span class='texttt'>C</span> following <span class='texttt'>e</span> are also omitted.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct S { } s;
struct A {
  S s1;
  int i1;
  S s2;
  int i2;
  S s3;
  int i3;
} a = {
  { },      <span class='comment'>// Required initialization
</span>  0,
  s,        <span class='comment'>// Required initialization
</span>  0
};          <span class='comment'>// Initialization not required for <span class='texttt'>A::s3</span> because <span class='texttt'>A::i3</span> is also not initialized
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-11'><div class='marginalizedparent'><a class='marginalized' href='#aggr-11'>11</a></div><p >If an incomplete or empty
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
leaves a member of reference type uninitialized, the program is ill-formed.</p></div><div class='para' id='aggr-12'><div class='marginalizedparent'><a class='marginalized' href='#aggr-12'>12</a></div><p >When initializing a multi-dimensional array,
the
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
initialize the elements with the last (rightmost) index of the array
varying the fastest (<a href='dcl.array'>[dcl.array]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int x[2][2] = { 3, 1, 4, 2 };
</pre><p >initializes
<span class='texttt'>x[0][0]</span>
to
<span class='texttt'>3</span>,
<span class='texttt'>x[0][1]</span>
to
<span class='texttt'>1</span>,
<span class='texttt'>x[1][0]</span>
to
<span class='texttt'>4</span>,
and
<span class='texttt'>x[1][1]</span>
to
<span class='texttt'>2</span>.
On the other hand,</p><pre class='codeblock'>
float y[4][3] = {
  { 1 }, { 2 }, { 3 }, { 4 }
};
</pre><p >initializes the first column of
<span class='texttt'>y</span>
(regarded as a two-dimensional array)
and leaves the rest zero.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-13'><div class='marginalizedparent'><a class='marginalized' href='#aggr-13'>13</a></div><p >Braces can be elided in an
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
as follows.
If the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
begins with a left brace,
then the succeeding comma-separated list of
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
initializes the elements of a subaggregate;
it is erroneous for there to be more
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
than elements.
If, however, the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
for a subaggregate does not begin with a left brace,
then only enough
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
from the list are taken to initialize the elements of the subaggregate;
any remaining
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
are left to initialize the next element of the aggregate
of which the current subaggregate is an element.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
float y[4][3] = {
  { 1, 3, 5 },
  { 2, 4, 6 },
  { 3, 5, 7 },
};
</pre><p >is a completely-braced initialization:
1, 3, and 5 initialize the first row of the array
<span class='texttt'>y[0]</span>,
namely
<span class='texttt'>y[0][0]</span>,
<span class='texttt'>y[0][1]</span>,
and
<span class='texttt'>y[0][2]</span>.
Likewise the next two lines initialize
<span class='texttt'>y[1]</span>
and
<span class='texttt'>y[2]</span>.
The initializer ends early and therefore
<span class='texttt'>y[3]</span>s
elements are initialized as if explicitly initialized with an
expression of the form
<span class='texttt'>float()</span>,
that is, are initialized with
<span class='texttt'>0.0</span>.
In the following example, braces in the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
are elided;
however the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
has the same effect as the completely-braced
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
of the above example,</p><pre class='codeblock'>
float y[4][3] = {
  1, 3, 5, 2, 4, 6, 3, 5, 7
};
</pre><p >The initializer for
<span class='texttt'>y</span>
begins with a left brace, but the one for
<span class='texttt'>y[0]</span>
does not,
therefore three elements from the list are used.
Likewise the next three are taken successively for
<span class='texttt'>y[1]</span>
and
<span class='texttt'>y[2]</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-14'><div class='marginalizedparent'><a class='marginalized' href='#aggr-14'>14</a></div><p >All implicit type conversions (Clause <a href='conv'>[conv]</a>) are considered when
initializing the element with an <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>.
If the
<i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
can initialize an element, the element is initialized.
Otherwise, if the element is itself a subaggregate,
brace elision is assumed and the
<i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
is considered for the initialization of the first element of the subaggregate.
[&nbsp;<i>Note:</i><span class='space'></span> As specified above, brace elision cannot apply to
subaggregates with no elements for purposes of aggregate initialization; an
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> for the entire subobject is
required.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A {
  int i;
  operator int();
};
struct B {
  A a1, a2;
  int z;
};
A a;
B b = { 4, a, a };
</pre><p >Braces are elided around the
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
for
<span class='texttt'>b.a1.i</span>.
<span class='texttt'>b.a1.i</span>
is initialized with 4,
<span class='texttt'>b.a2</span>
is initialized with
<span class='texttt'>a</span>,
<span class='texttt'>b.z</span>
is initialized with whatever
<span class='texttt'>a.operator int()</span>
returns.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-15'><div class='marginalizedparent'><a class='marginalized' href='#aggr-15'>15</a></div><p ><span class='indexparent'><a class='index' id='initialization,array_of_class_objects'></a></span>[&nbsp;<i>Note:</i><span class='space'></span>
An aggregate array or an aggregate class may contain elements of a
class type with a user-provided constructor (<a href='class.ctor'>[class.ctor]</a>).
Initialization of these aggregate objects is described in <a href='class.expl.init'>[class.expl.init]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='aggr-16'><div class='marginalizedparent'><a class='marginalized' href='#aggr-16'>16</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Whether the initialization of aggregates with static storage duration
is static or dynamic is specified
in <a href='basic.start.static'>[basic.start.static]</a>, <a href='basic.start.dynamic'>[basic.start.dynamic]</a>, and <a href='stmt.dcl'>[stmt.dcl]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='aggr-17'><div class='marginalizedparent'><a class='marginalized' href='#aggr-17'>17</a></div><p ><span class='indexparent'><a class='index' id='initialization,union'></a></span>When a union is initialized with a brace-enclosed initializer,
the braces shall only contain an
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
for the first non-static data member of the union.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
union u { int a; const char* b; };
u a = { 1 };
u b = a;
u c = 1;                        <span class='comment'>// error
</span>u d = { 0, "asdf" };            <span class='comment'>// error
</span>u e = { "asdf" };               <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-18'><div class='marginalizedparent'><a class='marginalized' href='#aggr-18'>18</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
As described above,
the braces around the
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
for a union member can be omitted if the
union is a member of another aggregate.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-104'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-104'>104)</a></div><p >The syntax provides for empty
<i ><a href='dcl.init#nt:initializer-list'>initializer-lists</a></i>,
but nonetheless C++ does not have zero length arrays.</p></div></div><div id='string'><h3 ><a class='secnum' href='#string' style='min-width:103pt'>8.6.2</a> Character arrays <a class='abbr_ref' href='dcl.init.string'>[dcl.init.string]</a></h3><p ><span class='indexparent'><a class='index' id='initialization,character_array'></a></span></p><div class='para' id='string-1'><div class='marginalizedparent'><a class='marginalized' href='#string-1'>1</a></div><p >An array of narrow character type (<a href='basic.fundamental'>[basic.fundamental]</a>),
<span class='texttt'>char16_t</span> array,
<span class='texttt'>char32_t</span> array,
or <span class='texttt'>wchar_t</span> array
can be initialized by a
narrow string literal, <span class='texttt'>char16_t</span> string literal, <span class='texttt'>char32_t</span> string
literal, or wide string literal,
respectively, or by an appropriately-typed string literal enclosed in
braces (<a href='lex.string'>[lex.string]</a>).
<span class='indexparent'><a class='index' id='initialization,character_array'></a></span>Successive
characters of the
value of the string literal
initialize the elements of the array.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
char msg[] = "Syntax error on line %s\n";
</pre><p >shows a character array whose members are initialized
with a
<i ><a href='lex.string#nt:string-literal'>string-literal</a></i>.
Note that because
<span class='texttt'>'\n'</span>
is a single character and
because a trailing
<span class='texttt'>'\0'</span>
is appended,
<span class='texttt'>sizeof(msg)</span>
is
<span class='texttt'>25</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='string-2'><div class='marginalizedparent'><a class='marginalized' href='#string-2'>2</a></div><p >There shall not be more initializers than there are array elements.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
char cv[4] = "asdf";            <span class='comment'>// error
</span></pre><p >is ill-formed since there is no space for the implied trailing
<span class='texttt'>'\0'</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='string-3'><div class='marginalizedparent'><a class='marginalized' href='#string-3'>3</a></div><p >If there are fewer initializers than there are array elements, each element not
explicitly initialized shall be zero-initialized (<a href='dcl.init'>[dcl.init]</a>).</p></div></div><div id='ref'><h3 ><a class='secnum' href='#ref' style='min-width:103pt'>8.6.3</a> References <a class='abbr_ref' href='dcl.init.ref'>[dcl.init.ref]</a></h3><p ><span class='indexparent'><a class='index' id='initialization,reference'></a></span></p><div class='para' id='ref-1'><div class='marginalizedparent'><a class='marginalized' href='#ref-1'>1</a></div><p >A variable whose declared type is
“reference to type <span class='texttt'>T</span>” (<a href='dcl.ref'>[dcl.ref]</a>)
shall be initialized.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int g(int) noexcept;
void f() {
  int i;
  int&amp; r = i;                   <span class='comment'>// <span class='texttt'>r</span> refers to <span class='texttt'>i</span>
</span>  r = 1;                        <span class='comment'>// the value of <span class='texttt'>i</span> becomes <span class='texttt'>1</span>
</span>  int* p = &amp;r;                  <span class='comment'>// <span class='texttt'>p</span> points to <span class='texttt'>i</span>
</span>  int&amp; rr = r;                  <span class='comment'>// <span class='texttt'>rr</span> refers to what <span class='texttt'>r</span> refers to, that is, to <span class='texttt'>i</span>
</span>  int (&amp;rg)(int) = g;           <span class='comment'>// <span class='texttt'>rg</span> refers to the function <span class='texttt'>g</span>
</span>  rg(i);                        <span class='comment'>// calls function <span class='texttt'>g</span>
</span>  int a[3];
  int (&amp;ra)[3] = a;             <span class='comment'>// <span class='texttt'>ra</span> refers to the array <span class='texttt'>a</span>
</span>  ra[1] = i;                    <span class='comment'>// modifies <span class='texttt'>a[1]</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='ref-2'><div class='marginalizedparent'><a class='marginalized' href='#ref-2'>2</a></div><p >A reference cannot be changed to refer to another object after initialization.
<span class='indexparent'><a class='index' id='assignment,reference'></a></span>[&nbsp;<i>Note:</i><span class='space'></span>
Assignment to a reference assigns to the object referred to by the reference (<a href='expr.ass'>[expr.ass]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
<span class='indexparent'><a class='index' id='argument_passing,reference_and'></a></span>Argument passing (<a href='expr.call'>[expr.call]</a>)
<span class='indexparent'><a class='index' id='return,reference_and'></a></span>and function value return (<a href='stmt.return'>[stmt.return]</a>) are initializations.</p></div><div class='para' id='ref-3'><div class='marginalizedparent'><a class='marginalized' href='#ref-3'>3</a></div><p >The initializer can be omitted for a reference only in a parameter declaration
(<a href='dcl.fct'>[dcl.fct]</a>), in the declaration of a function return type, in the declaration of
a class member within its class definition (<a href='class.mem'>[class.mem]</a>), and where the
<span class='texttt'>extern</span>
specifier is explicitly used.
<span class='indexparent'><a class='index' id='declaration,extern'></a></span>[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int&amp; r1;                        <span class='comment'>// error: initializer missing
</span>extern int&amp; r2;                 <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='ref-4'><div class='marginalizedparent'><a class='marginalized' href='#ref-4'>4</a></div><p >Given types “<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” and “<span class='small'></span><span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>”,
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is <span class='small'></span><span class='rmfamily'></span><i> reference-related</i> to
<span class='indexparent'><a class='index' id='reference-related'></a></span>“<span class='small'></span><span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>” if
<span class='texttt'>T1</span> is the same type as <span class='texttt'>T2</span>, or
<span class='texttt'>T1</span> is a base class of <span class='texttt'>T2</span>.
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is <span class='small'></span><span class='rmfamily'></span><i> reference-compatible</i>
<span class='indexparent'><a class='index' id='reference-compatible'></a></span>with “<span class='small'></span><span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>” if
</p><ul ><li ><p ><span class='texttt'>T1</span> is reference-related to <span class='texttt'>T2</span>, or
</p></li><li ><p ><span class='texttt'>T2</span> is “<span class='texttt'>noexcept</span> function” and <span class='texttt'>T1</span> is “function”,
where the function types are otherwise the same,
</p></li></ul><p >and
<i>cv1</i>
is the same cv-qualification as, or greater cv-qualification than,
<i>cv2</i>.
In all cases where the reference-related or reference-compatible relationship
of two types is used to establish the validity of a reference binding, and
<span class='texttt'>T1</span>
is a base class of
<span class='texttt'>T2</span>,
a program that necessitates such a binding is ill-formed if
<span class='texttt'>T1</span>
is an inaccessible (Clause <a href='class.access'>[class.access]</a>) or ambiguous (<a href='class.member.lookup'>[class.member.lookup]</a>)
base class of
<span class='texttt'>T2</span>.</p></div><div class='para' id='ref-5'><div class='marginalizedparent'><a class='marginalized' href='#ref-5'>5</a></div><p >A reference to type “<i>cv1</i> <span class='texttt'>T1</span>” is initialized by
an expression of type “<i>cv2</i> <span class='texttt'>T2</span>” as follows:<span class='indexparent'><a class='index' id='binding,reference'></a></span></p><ul ><li ><p >If the reference is an lvalue reference and the initializer expression</p><ul ><li ><p >is an lvalue (but is not a
bit-field), and
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is reference-compatible with
“<span class='small'></span><span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>”, or
</p></li><li ><p >has a class type (i.e.,
<span class='texttt'>T2</span>
is a class type), where <span class='texttt'>T1</span> is not reference-related to <span class='texttt'>T2</span>, and can be converted
to an lvalue of type “<span class='small'></span><span class='rmfamily'></span><i> cv3</i> <span class='texttt'>T3</span>”, where
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is reference-compatible with
“<span class='small'></span><span class='rmfamily'></span><i> cv3</i> <span class='texttt'>T3</span>”<a class='footnotenum' href='#footnote-105'>105</a>
(this conversion is selected by enumerating the applicable conversion
functions (<a href='over.match.ref'>[over.match.ref]</a>) and choosing the best one through overload
resolution (<a href='over.match'>[over.match]</a>)),
</p></li></ul><p >then the reference is bound to the initializer expression lvalue in the
first case and to the lvalue result of the conversion
in the second case (or, in either case, to the appropriate base class subobject of the object).
[&nbsp;<i>Note:</i><span class='space'></span>
The usual lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>), array-to-pointer
(<a href='conv.array'>[conv.array]</a>), and function-to-pointer (<a href='conv.func'>[conv.func]</a>) standard
conversions are not needed, and therefore are suppressed, when such
direct bindings to lvalues are done.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
double d = 2.0;
double&amp; rd = d;                 <span class='comment'>// <span class='texttt'>rd</span> refers to <span class='texttt'>d</span>
</span>const double&amp; rcd = d;          <span class='comment'>// <span class='texttt'>rcd</span> refers to <span class='texttt'>d</span>
</span>
struct A { };
struct B : A { operator int&amp;(); } b;
A&amp; ra = b;                      <span class='comment'>// <span class='texttt'>ra</span> refers to <span class='texttt'>A</span> subobject in <span class='texttt'>b</span>
</span>const A&amp; rca = b;               <span class='comment'>// <span class='texttt'>rca</span> refers to <span class='texttt'>A</span> subobject in <span class='texttt'>b</span>
</span>int&amp; ir = B();                  <span class='comment'>// <span class='texttt'>ir</span> refers to the result of <span class='texttt'>B::operator int&amp;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise, the reference shall be an lvalue reference to a non-volatile
const type (i.e.,
<i>cv1</i>
shall be
<span class='texttt'>const</span>), or the reference shall be an rvalue reference.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
double&amp; rd2 = 2.0;              <span class='comment'>// error: not an lvalue and reference not <span class='texttt'>const</span>
</span>int  i = 2;
double&amp; rd3 = i;                <span class='comment'>// error: type mismatch and reference not <span class='texttt'>const</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><ul ><li ><p >If the initializer expression</p><ul ><li ><p >is an rvalue (but not a bit-field) or function lvalue and
“<i>cv1</i> <span class='texttt'>T1</span>” is
reference-compatible with “<i>cv2</i> <span class='texttt'>T2</span>”, or</p></li><li ><p >has a class type (i.e., <span class='texttt'>T2</span> is a class type), where <span class='texttt'>T1</span>
is not reference-related to <span class='texttt'>T2</span>, and can be converted to
an rvalue or function lvalue of type “<i>cv3</i> <span class='texttt'>T3</span>”,
where “<i>cv1</i> <span class='texttt'>T1</span>” is
reference-compatible with “<i>cv3</i> <span class='texttt'>T3</span>” (see <a href='over.match.ref'>[over.match.ref]</a>),</p></li></ul><p >then the reference is bound to the value of the initializer expression in the first
case and to the result of the conversion in the second case (or, in either case, to
an appropriate base class subobject) after applying the temporary materialization conversion (<a href='conv.rval'>[conv.rval]</a>).</p><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A { };
struct B : A { } b;
extern B f();
const A&amp; rca2 = f();                <span class='comment'>// bound to the <span class='texttt'>A</span> subobject of the <span class='texttt'>B</span> rvalue.
</span>A&amp;&amp; rra = f();                      <span class='comment'>// same as above
</span>struct X {
  operator B();
  operator int&amp;();
} x;
const A&amp; r = x;                     <span class='comment'>// bound to the <span class='texttt'>A</span> subobject of the result of the conversion
</span>int i2 = 42;
int&amp;&amp; rri = static_cast&lt;int&amp;&amp;&gt;(i2); <span class='comment'>// bound directly to <span class='texttt'>i2</span>
</span>B&amp;&amp; rrb = x;                        <span class='comment'>// bound directly to the result of <span class='texttt'>operator B</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise:
</p><ul ><li ><p >If <span class='texttt'>T1</span> or <span class='texttt'>T2</span> is a class type and
<span class='texttt'>T1</span> is not reference-related to <span class='texttt'>T2</span>,
user-defined conversions are considered
using the rules for copy-initialization of an object of type 
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” by
user-defined conversion
(<a href='dcl.init'>[dcl.init]</a>, <a href='over.match.copy'>[over.match.copy]</a>, <a href='over.match.conv'>[over.match.conv]</a>);
the program is ill-formed if the corresponding non-reference
copy-initialization would be ill-formed. The result of the call to the
conversion function, as described for the non-reference
copy-initialization, is then used to direct-initialize the reference.
For this direct-initialization, user-defined conversions are not considered.
</p></li><li ><p >Otherwise,
the initializer expression is implicitly converted to a prvalue
of type “<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>”.
The temporary materialization conversion is applied and the reference is
bound to the result.
</p></li></ul><p >If
<span class='texttt'>T1</span>
is reference-related to
<span class='texttt'>T2</span>:
</p><ul ><li ><p ><i>cv1</i>
shall be the same cv-qualification as, or greater cv-qualification than,
<i>cv2</i>; and
</p></li><li ><p >if the reference is an rvalue reference,
the initializer expression shall not be an lvalue.
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct Banana { };
struct Enigma { operator const Banana(); };
struct Alaska { operator Banana&amp;(); };
void enigmatic() {
  typedef const Banana ConstBanana;
  Banana &amp;&amp;banana1 = ConstBanana(); <span class='comment'>// ill-formed
</span>  Banana &amp;&amp;banana2 = Enigma();      <span class='comment'>// ill-formed
</span>  Banana &amp;&amp;banana3 = Alaska();      <span class='comment'>// ill-formed
</span>}

const double&amp; rcd2 = 2;         <span class='comment'>// <span class='texttt'>rcd2</span> refers to temporary with value <span class='texttt'>2.0</span>
</span>double&amp;&amp; rrd = 2;               <span class='comment'>// <span class='texttt'>rrd</span> refers to temporary with value <span class='texttt'>2.0</span>
</span>const volatile int cvi = 1;
const int&amp; r2 = cvi;            <span class='comment'>// error: type qualifiers dropped
</span>struct A { operator volatile int&amp;(); } a;
const int&amp; r3 = a;              <span class='comment'>// error: type qualifiers dropped
</span>                                <span class='comment'>// from result of conversion function
</span>double d2 = 1.0;
double&amp;&amp; rrd2 = d2;             <span class='comment'>// error: initializer is lvalue of related type
</span>struct X { operator int&amp;(); };
int&amp;&amp; rri2 = X();               <span class='comment'>// error: result of conversion function is lvalue of related type
</span>int i3 = 2;
double&amp;&amp; rrd3 = i3;             <span class='comment'>// <span class='texttt'>rrd3</span> refers to temporary with value <span class='texttt'>2.0</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li></ul></li></ul><p >In all cases except the last
(i.e., implicitly converting the initializer expression
to the underlying type of the reference),
the reference is said to <a id='bind_directly'><i>bind directly</i></a> to the
initializer expression.</p></div><div class='para' id='ref-6'><div class='marginalizedparent'><a class='marginalized' href='#ref-6'>6</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
<a href='class.temporary'>[class.temporary]</a> describes the lifetime of temporaries bound to references.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-105'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-105'>105)</a></div><p >This requires a conversion
function (<a href='class.conv.fct'>[class.conv.fct]</a>) returning a reference type.</p></div></div><div id='list'><h3 ><a class='secnum' href='#list' style='min-width:103pt'>8.6.4</a> List-initialization <a class='abbr_ref' href='dcl.init.list'>[dcl.init.list]</a></h3><p ><span class='indexparent'><a class='index' id='initialization,list-initialization'></a></span></p><div class='para' id='list-1'><div class='marginalizedparent'><a class='marginalized' href='#list-1'>1</a></div><p ><span class='grammarterm'>List-initialization</span> is initialization of an object or reference from a
<i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>. Such an initializer is called an <i>initializer
list</i>, and the comma-separated <i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i> of the list are
called the <i>elements</i> of the initializer list. An initializer list may be empty.
List-initialization can occur in direct-initialization or copy-initialization contexts;
list-initialization in a direct-initialization context is called
<span class='grammarterm'>direct-list-initialization</span> and list-initialization in a
copy-initialization context is called <span class='grammarterm'>copy-list-initialization</span>. [&nbsp;<i>Note:</i><span class='space'></span>
List-initialization can be used</p><ul ><li ><p >as the initializer in a variable definition (<a href='dcl.init'>[dcl.init]</a>)
</p></li><li ><p >as the initializer in a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> (<a href='expr.new'>[expr.new]</a>)
</p></li><li ><p >in a return statement (<a href='stmt.return'>[stmt.return]</a>)
</p></li><li ><p >as a <i ><a href='stmt.iter#nt:for-range-initializer'>for-range-initializer</a></i> (<a href='stmt.iter'>[stmt.iter]</a>)
</p></li><li ><p >as a function argument (<a href='expr.call'>[expr.call]</a>)
</p></li><li ><p >as a subscript (<a href='expr.sub'>[expr.sub]</a>)
</p></li><li ><p >as an argument to a constructor invocation (<a href='dcl.init'>[dcl.init]</a>, <a href='expr.type.conv'>[expr.type.conv]</a>)
</p></li><li ><p >as an initializer for a non-static data member (<a href='class.mem'>[class.mem]</a>)
</p></li><li ><p >in a <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> (<a href='class.base.init'>[class.base.init]</a>)
</p></li><li ><p >on the right-hand side of an assignment (<a href='expr.ass'>[expr.ass]</a>)
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
int a = {1};
std::complex&lt;double&gt; z{1,2};
new std::vector&lt;std::string&gt;{"once", "upon", "a", "time"};  <span class='comment'>// 4 string elements
</span>f( {"Nicholas","Annemarie"} );  <span class='comment'>// pass list of two elements
</span>return { "Norah" };             <span class='comment'>// return list of one element
</span>int* e {};                      <span class='comment'>// initialization to zero / null pointer
</span>x = double{1};                  <span class='comment'>// explicitly construct a double 
</span>std::map&lt;std::string,int&gt; anim = { {"bear",4}, {"cassowary",2}, {"tiger",7} };
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;] <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='list-2'><div class='marginalizedparent'><a class='marginalized' href='#list-2'>2</a></div><p >A constructor is an <span class='grammarterm'>initializer-list constructor</span> if its first parameter is
of type <span class='texttt'>std::initializer_list&lt;E&gt;</span> or reference to possibly cv-qualified
<span class='texttt'>std::initializer_list&lt;E&gt;</span> for some type <span class='texttt'>E</span>, and either there are no other
parameters or else all other parameters have default arguments (<a href='dcl.fct.default'>[dcl.fct.default]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> Initializer-list constructors are favored over other constructors in
list-initialization (<a href='over.match.list'>[over.match.list]</a>). Passing an initializer list as the argument
to the constructor template <span class='texttt'>template&lt;class T&gt; C(T)</span> of a class <span class='texttt'>C</span> does not
create an initializer-list constructor, because an initializer list argument causes the 
corresponding parameter to be a non-deduced context (<a href='temp.deduct.call'>[temp.deduct.call]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]
The template
<span class='texttt'>std::initializer_list</span> is not predefined; if the header
<span class='texttt'>&lt;initializer_list&gt;</span> is not included prior to a use of
<span class='texttt'>std::initializer_list</span> — even an implicit use in which the type is not
named (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>) — the program is ill-formed.</p></div><div class='para' id='list-3'><div class='marginalizedparent'><a class='marginalized' href='#list-3'>3</a></div><p >List-initialization of an object or reference of type <span class='texttt'>T</span> is defined as follows:
</p><ul ><li ><p >If <span class='texttt'>T</span> is an aggregate class and the initializer list has a single element
of type <i>cv</i> <span class='texttt'>U</span>,
where <span class='texttt'>U</span> is <span class='texttt'>T</span> or a class derived from <span class='texttt'>T</span>,
the object is initialized from that element (by copy-initialization for
copy-list-initialization, or by direct-initialization for
direct-list-initialization).</p></li><li ><p >Otherwise, if <span class='texttt'>T</span> is a character array and the initializer list has a
single element that is an appropriately-typed string literal (<a href='dcl.init.string'>[dcl.init.string]</a>),
initialization is performed as described in that section.</p></li><li ><p >Otherwise, if <span class='texttt'>T</span> is an aggregate, aggregate initialization is
performed (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>).</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
double ad[] = { 1, 2.0 };           <span class='comment'>// OK
</span>int ai[] = { 1, 2.0 };              <span class='comment'>// error: narrowing
</span>
struct S2 {
  int m1;
  double m2, m3;
};
S2 s21 = { 1, 2, 3.0 };             <span class='comment'>// OK
</span>S2 s22 { 1.0, 2, 3 };               <span class='comment'>// error: narrowing
</span>S2 s23 { };                         <span class='comment'>// OK: default to 0,0,0
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise, if the initializer list has no elements and <span class='texttt'>T</span> is a class type with a
default constructor, the object is value-initialized.</p></li><li ><p >Otherwise, if <span class='texttt'>T</span> is a specialization of <span class='texttt'>std::initializer_list&lt;E&gt;</span>,
the object is constructed as described below.</p></li><li ><p >Otherwise, if <span class='texttt'>T</span> is a class type, constructors are considered.
The applicable constructors are enumerated and
the best one is chosen through overload resolution (<a href='over.match'>[over.match]</a>, <a href='over.match.list'>[over.match.list]</a>). If a narrowing
conversion (see below) is required to convert any of the arguments, the program is
ill-formed.</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct S {
  S(std::initializer_list&lt;double&gt;); <span class='comment'>// #1
</span>  S(std::initializer_list&lt;int&gt;);    <span class='comment'>// #2
</span>  S();                              <span class='comment'>// #3
</span>  <span class='comment'>// ...
</span>};
S s1 = { 1.0, 2.0, 3.0 };           <span class='comment'>// invoke #1
</span>S s2 = { 1, 2, 3 };                 <span class='comment'>// invoke #2
</span>S s3 = { };                         <span class='comment'>// invoke #3
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct Map {
  Map(std::initializer_list&lt;std::pair&lt;std::string,int&gt;&gt;);
};
Map ship = {{"Sophie",14}, {"Surprise",28}};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct S {
  <span class='comment'>// no initializer-list constructors
</span>  S(int, double, double);           <span class='comment'>// #1
</span>  S();                              <span class='comment'>// #2
</span>  <span class='comment'>// ...
</span>};
S s1 = { 1, 2, 3.0 };               <span class='comment'>// OK: invoke #1
</span>S s2 { 1.0, 2, 3 };                 <span class='comment'>// error: narrowing
</span>S s3 { };                           <span class='comment'>// OK: invoke #2
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise, if
the initializer list has a single element of type <span class='texttt'>E</span> and either
<span class='texttt'>T</span> is not a reference type or its referenced type is
reference-related to <span class='texttt'>E</span>, the object or reference is initialized
from that element (by copy-initialization for copy-list-initialization,
or by direct-initialization for direct-list-initialization);
if a narrowing conversion (see below) is required
to convert the element to <span class='texttt'>T</span>, the program is ill-formed.</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
int x1 {2};                         <span class='comment'>// OK
</span>int x2 {2.0};                       <span class='comment'>// error: narrowing
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise, if <span class='texttt'>T</span> is a reference type, a prvalue of the type
referenced by <span class='texttt'>T</span> is generated.
The prvalue initializes its result object by
copy-list-initialization or direct-list-initialization,
depending on the kind of initialization for the reference.
The prvalue is then used to direct-initialize the reference.
[&nbsp;<i>Note:</i><span class='space'></span> As usual, the binding will fail and the program is ill-formed if
the reference type is an lvalue reference to a non-const type. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct S {
  S(std::initializer_list&lt;double&gt;); <span class='comment'>// #1
</span>  S(const std::string&amp;);            <span class='comment'>// #2
</span>  <span class='comment'>// ...
</span>};
const S&amp; r1 = { 1, 2, 3.0 };        <span class='comment'>// OK: invoke #1
</span>const S&amp; r2 { "Spinach" };          <span class='comment'>// OK: invoke #2
</span>S&amp; r3 = { 1, 2, 3 };                <span class='comment'>// error: initializer is not an lvalue
</span>const int&amp; i1 = { 1 };              <span class='comment'>// OK
</span>const int&amp; i2 = { 1.1 };            <span class='comment'>// error: narrowing
</span>const int (&amp;iar)[2] = { 1, 2 };     <span class='comment'>// OK: <span class='texttt'>iar</span> is bound to temporary array
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise, if <span class='texttt'>T</span> is an enumeration
with a fixed underlying type (<a href='dcl.enum'>[dcl.enum]</a>),
the <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> has a single element <span class='texttt'>v</span>, and
the initialization is direct-list-initialization,
the object is initialized with the value <span class='texttt'>T(v)</span> (<a href='expr.type.conv'>[expr.type.conv]</a>);
if a narrowing conversion is required to convert <span class='texttt'>v</span>
to the underlying type of <span class='texttt'>T</span>, the program is ill-formed.</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
enum byte : unsigned char { };
byte b { 42 };                      <span class='comment'>// OK
</span>byte c = { 42 };                    <span class='comment'>// error
</span>byte d = byte{ 42 };                <span class='comment'>// OK; same value as <span class='texttt'>b</span>
</span>byte e { -1 };                      <span class='comment'>// error
</span>
struct A { byte b; };
A a1 = { { 42 } };                  <span class='comment'>// error
</span>A a2 = { byte{ 42 } };              <span class='comment'>// OK
</span>
void f(byte);
f({ 42 });                          <span class='comment'>// error
</span>
enum class Handle : uint32_t { Invalid = 0 };
Handle h { 42 };                    <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise, if the initializer list has no elements, the object is
value-initialized.</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
int** pp {};                        <span class='comment'>// initialized to null pointer
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise, the program is ill-formed.</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A { int i; int j; };
A a1 { 1, 2 };                      <span class='comment'>// aggregate initialization 
</span>A a2 { 1.2 };                       <span class='comment'>// error: narrowing
</span>struct B {
  B(std::initializer_list&lt;int&gt;);
};
B b1 { 1, 2 };                      <span class='comment'>// creates <span class='texttt'>initializer_list&lt;int&gt;</span> and calls constructor
</span>B b2 { 1, 2.0 };                    <span class='comment'>// error: narrowing
</span>struct C {
  C(int i, double j);
};
C c1 = { 1, 2.2 };                  <span class='comment'>// calls constructor with arguments (1, 2.2) 
</span>C c2 = { 1.1, 2 };                  <span class='comment'>// error: narrowing
</span>
int j { 1 };                        <span class='comment'>// initialize to 1
</span>int k { };                          <span class='comment'>// initialize to 0
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li></ul></div><div class='para' id='list-4'><div class='marginalizedparent'><a class='marginalized' href='#list-4'>4</a></div><p >Within the <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> of a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>,
the <i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>, including any that result from pack
expansions (<a href='temp.variadic'>[temp.variadic]</a>), are evaluated in the order in which they
appear. That is, every value computation and side effect associated with a
given <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> is sequenced before every value
computation and side effect associated with any <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
that follows it in the comma-separated list of the <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span> This evaluation ordering holds regardless of the semantics of the
initialization; for example, it applies when the elements of the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> are interpreted as arguments of a constructor
call, even though ordinarily there are no sequencing constraints on the
arguments of a call. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='list-5'><div class='marginalizedparent'><a class='marginalized' href='#list-5'>5</a></div><p >An object of type <span class='texttt'>std::initializer_list&lt;E&gt;</span> is constructed from
an initializer list as if
the implementation generated and materialized (<a href='conv.rval'>[conv.rval]</a>)
a prvalue of type “array of <span class='math'><span class='mathalpha'>N</span></span> <span class='texttt'>const E</span>”,
where <span class='math'><span class='mathalpha'>N</span></span> is the number of elements in the
initializer list. Each element of that array is copy-initialized with the
corresponding element of the initializer list, and the
<span class='texttt'>std::initializer_list&lt;E&gt;</span> object is constructed to refer to that array.
[&nbsp;<i>Note:</i><span class='space'></span> A constructor or conversion function selected for the copy shall be
accessible (Clause <a href='class.access'>[class.access]</a>) in the context of the initializer list.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If a narrowing conversion is required to initialize any of the elements, the program is ill-formed.[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct X {
  X(std::initializer_list&lt;double&gt; v);
};
X x{ 1,2,3 };
</pre><p >The initialization will be implemented in a way roughly equivalent to this:</p><pre class='codeblock'>
const double __a[3] = {double{1}, double{2}, double{3}};
X x(std::initializer_list&lt;double&gt;(__a, __a+3));
</pre><p >assuming that the implementation can construct an <span class='texttt'>initializer_list</span> object with a pair of pointers. <i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='list-6'><div class='marginalizedparent'><a class='marginalized' href='#list-6'>6</a></div><p >The array has the same lifetime as any other temporary
object (<a href='class.temporary'>[class.temporary]</a>), except that initializing an
<span class='texttt'>initializer_list</span> object from the array extends the lifetime of
the array exactly like binding a reference to a temporary.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
typedef std::complex&lt;double&gt; cmplx;
std::vector&lt;cmplx&gt; v1 = { 1, 2, 3 };

void f() {
  std::vector&lt;cmplx&gt; v2{ 1, 2, 3 };
  std::initializer_list&lt;int&gt; i3 = { 1, 2, 3 };
}

struct A {
  std::initializer_list&lt;int&gt; i4;
  A() : i4{ 1, 2, 3 } {}  <span class='comment'>// ill-formed, would create a dangling reference
</span>};
</pre><p >For <span class='texttt'>v1</span> and <span class='texttt'>v2</span>, the <span class='texttt'>initializer_list</span> object
is a parameter in a function call, so the array created for
<span class='texttt'>{ 1, 2, 3 }</span> has full-expression lifetime.
For <span class='texttt'>i3</span>, the <span class='texttt'>initializer_list</span> object is a variable,
so the array persists for the lifetime of the variable.
For <span class='texttt'>i4</span>, the <span class='texttt'>initializer_list</span> object is initialized in
the constructor's <i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i> as if by binding
a temporary array to a reference member, so the program is
ill-formed (<a href='class.base.init'>[class.base.init]</a>).
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
The implementation is free to allocate the array in read-only memory if an explicit array with the same initializer could be so allocated. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='list-7'><div class='marginalizedparent'><a class='marginalized' href='#list-7'>7</a></div><p >A
<span class='indexparent'><a class='index' id='narrowing_conversion'></a></span><span class='indexparent'><a class='index' id='conversion,narrowing'></a></span><i>narrowing conversion</i> is an implicit conversion</p><ul ><li ><p >from a floating-point type to an integer type, or</p></li><li ><p >from <span class='texttt'>long double</span> to <span class='texttt'>double</span> or <span class='texttt'>float</span>, or from
<span class='texttt'>double</span> to <span class='texttt'>float</span>, except where the source is a constant expression and
the actual value after conversion
is within the range of values that can be represented (even if it cannot be represented exactly),
or</p></li><li ><p >from an integer type or unscoped enumeration type to a floating-point type, except
where the source is a constant expression and the actual value after conversion will fit
into the target type and will produce the original value when converted back to the
original type, or</p></li><li ><p >from an integer type or unscoped enumeration type to an integer type that cannot
represent all the values of the original type, except where the source is a constant
expression whose value after integral promotions will fit into the target type.
</p></li></ul><p >[&nbsp;<i>Note:</i><span class='space'></span> As indicated above, such conversions are not allowed at the top level in
list-initializations.<i>&nbsp;—&nbsp;end note</i>&nbsp;] [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int x = 999;              <span class='comment'>// x is not a constant expression
</span>const int y = 999;
const int z = 99;
char c1 = x;              <span class='comment'>// OK, though it might narrow (in this case, it does narrow)
</span>char c2{x};               <span class='comment'>// error: might narrow
</span>char c3{y};               <span class='comment'>// error: narrows (assuming <span class='texttt'>char</span> is 8 bits)
</span>char c4{z};               <span class='comment'>// OK: no narrowing needed
</span>unsigned char uc1 = {5};  <span class='comment'>// OK: no narrowing needed
</span>unsigned char uc2 = {-1}; <span class='comment'>// error: narrows
</span>unsigned int ui1 = {-1};  <span class='comment'>// error: narrows
</span>signed int si1 =
  { (unsigned int)-1 };   <span class='comment'>// error: narrows
</span>int ii = {2.0};           <span class='comment'>// error: narrows
</span>float f1 { x };           <span class='comment'>// error: might narrow
</span>float f2 { 7 };           <span class='comment'>// OK: 7 can be exactly represented as a float
</span>int f(int);
int a[] =
  { 2, f(2), f(2.0) };    <span class='comment'>// OK: the double-to-int conversion is not at the top level
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='initialization,list-initialization'></a></span><span class='indexparent'><a class='index' id='initialization'></a></span><span class='indexparent'><a class='index' id='declarator'></a></span>
</p></div></div></div></div></body></html>