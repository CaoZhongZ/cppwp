<!DOCTYPE html><html lang='en'><head><title>[temp.res]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><div id='temp.res'><h2 ><a class='secnum' style='min-width:88pt'>14.6</a> Name resolution <a class='abbr_ref'>[temp.res]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='overloading,resolution,template_name'></a></span><span class='indexparent'><a class='index' id='lookup,template_name'></a></span>Three kinds of names can be used within a template definition:</p><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p >The name of the template itself,
and names declared within the template itself.
</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p >Names dependent on a
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> (<a href='temp.dep'>[temp.dep]</a>).
</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p >Names from scopes which are visible within the template definition.
</p></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A name used in a template declaration or definition and that is
dependent on a
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
is assumed not to name a type unless
the applicable name lookup finds a type name or the name
is qualified by the keyword
<span class='texttt'>typename</span>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
<span class='comment'>// no <span class='texttt'>B</span> declared here
</span>
class X;

template&lt;class T&gt; class Y {
  class Z;                      <span class='comment'>// forward declaration of member class
</span>
  void f() {
    X* a1;                      <span class='comment'>// declare pointer to <span class='texttt'>X</span>
</span>    T* a2;                      <span class='comment'>// declare pointer to <span class='texttt'>T</span>
</span>    Y* a3;                      <span class='comment'>// declare pointer to <span class='texttt'>Y&lt;T&gt;</span>
</span>    Z* a4;                      <span class='comment'>// declare pointer to <span class='texttt'>Z</span>
</span>    typedef typename T::A TA;
    TA* a5;                     <span class='comment'>// declare pointer to <span class='texttt'>T</span>'s <span class='texttt'>A</span>
</span>    typename T::A* a6;          <span class='comment'>// declare pointer to <span class='texttt'>T</span>'s <span class='texttt'>A</span>
</span>    T::A* a7;                   <span class='comment'>// <span class='texttt'>T::A</span> is not a type name:
</span>                                <span class='comment'>// multiply <span class='texttt'>T::A</span> by <span class='texttt'>a7</span>; ill-formed,
</span>                                <span class='comment'>// no visible declaration of <span class='texttt'>a7</span>
</span>    B* a8;                      <span class='comment'>// <span class='texttt'>B</span> is not a type name:
</span>                                <span class='comment'>// multiply <span class='texttt'>B</span> by <span class='texttt'>a8</span>; ill-formed,
</span>                                <span class='comment'>// no visible declarations of <span class='texttt'>B</span> and <span class='texttt'>a8</span>
</span>  }
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >When a <span class='small'></span><span class='rmfamily'></span><i> qualified-id</i> is intended to refer to a type
that is not a member of the current instantiation (<a href='temp.dep.type'>[temp.dep.type]</a>)
and its <span class='small'></span><span class='rmfamily'></span><i> nested-name-specifier</i>
refers to a dependent type,
it shall be
prefixed by the keyword <span class='texttt'>typename</span>, forming a
<span class='small'></span><span class='rmfamily'></span><i> typename-specifier</i>.
If the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> in a <i ><a href='temp.res#nt:typename-specifier'>typename-specifier</a></i>
does not denote a type
or a class template,
the program is ill-formed.</p><pre class='bnf'><a id='nt:typename-specifier'>typename-specifier:</a>
  <span class='terminal'>typename</span> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <i ><a href='lex.name#nt:identifier'>identifier</a></i>
  <span class='terminal'>typename</span> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <span class='terminal'>template<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i></pre></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >If a specialization of a template is instantiated for a set of
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>
such that the
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
prefixed by
<span class='texttt'>typename</span>
does not denote a type
or a class template,
the specialization is ill-formed.
The usual qualified name lookup (<a href='basic.lookup.qual'>[basic.lookup.qual]</a>) is used to find the
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
even in the presence of
<span class='texttt'>typename</span>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A {
  struct X { };
  int X;
};
struct B {
  struct X { };
};
template&lt;class T&gt; void f(T t) {
  typename T::X x;
}
void foo() {
  A a;
  B b;
  f(b);             <span class='comment'>// OK: <span class='texttt'>T::X</span> refers to <span class='texttt'>B::X</span>
</span>  f(a);             <span class='comment'>// error: <span class='texttt'>T::X</span> refers to the data member <span class='texttt'>A::X</span> not the struct <span class='texttt'>A::X</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A qualified name used as the name in a
<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i>,
a
<i ><a href='class.derived#nt:base-specifier'>base-specifier</a></i>,
or an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>
is implicitly assumed to name a type, without the use of the
<span class='texttt'>typename</span>
keyword.
In a <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> that immediately contains a <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
that depends on a template parameter, the <i ><a href='lex.name#nt:identifier'>identifier</a></i> or <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
is implicitly assumed to name a type, without the use of the <span class='texttt'>typename</span> keyword.
[&nbsp;<i>Note:</i><span class='space'></span>
The
<span class='texttt'>typename</span>
keyword is not permitted by the syntax of these constructs.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >If, for a given set of template arguments, a specialization of a template is
instantiated
that refers to a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
that denotes a type
or a class template,
and the
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> refers to a member of an unknown specialization,
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> shall either be
prefixed by <span class='texttt'>typename</span> or shall be used in a context in which it
implicitly names a type as described above. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; void f(int i) {
  T::x * i;         <span class='comment'>// <span class='texttt'>T::x</span> must not be a type
</span>}

struct Foo {
  typedef int x;
};

struct Bar {
  static int const x = 5;
};

int main() {
  f&lt;Bar&gt;(1);        <span class='comment'>// OK
</span>  f&lt;Foo&gt;(1);        <span class='comment'>// error: <span class='texttt'>Foo::x</span> is a type
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >Within the definition of a class template or within the definition of a
member of a class template following the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i>, the keyword
<span class='texttt'>typename</span>
is not required when referring to the name of a previously
declared member of the class template that declares a type
or a class template.
[&nbsp;<i>Note:</i><span class='space'></span> such names can be found using unqualified name lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>),
class member lookup (<a href='class.qual'>[class.qual]</a>) into the current instantiation (<a href='temp.dep.type'>[temp.dep.type]</a>),
or class member access expression lookup (<a href='basic.lookup.classref'>[basic.lookup.classref]</a>) when the
type of the object expression is the current instantiation (<a href='temp.dep.expr'>[temp.dep.expr]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  typedef int B;
  B b;              <span class='comment'>// OK, no typename required
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p ><span class='indexparent'><a class='index' id='checking,syntax'></a></span><span class='indexparent'><a class='index' id='checking,point_of_error'></a></span>Knowing which names are type names allows the syntax of every template
to be checked.
The program is ill-formed, no diagnostic required, if:</p><ul class='itemize'><li id='8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.1'>(8.1)</a></div><p >no valid specialization can be generated for a template
or a substatement of a constexpr if statement (<a href='stmt.if'>[stmt.if]</a>) within a template
and the template is not instantiated, or
</p></li><li id='8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.2'>(8.2)</a></div><p >every valid specialization of a variadic template requires an empty template
parameter pack, or
</p></li><li id='8.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.3'>(8.3)</a></div><p >a hypothetical instantiation of a template
immediately following its definition
would be ill-formed
due to a construct that does not depend on a template parameter, or
</p></li><li id='8.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.4'>(8.4)</a></div><p >the interpretation of such a construct
in the hypothetical instantiation
is different from
the interpretation of the corresponding construct
in any actual instantiation of the template.
[&nbsp;<i>Note:</i><span class='space'></span>
This can happen in situations including the following:
</p><ul class='itemize'><li id='8.4.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#8.4.1'>(8.4.1)</a></div><p >a type used in a non-dependent name is incomplete at the point at which a
template is defined but is complete at the point at which an instantiation is
performed, or</p></li><li id='8.4.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#8.4.2'>(8.4.2)</a></div><p >an instantiation uses a default argument or default template argument
that had not been defined at the point at which the template was defined, or</p></li><li id='8.4.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#8.4.3'>(8.4.3)</a></div><p >constant expression evaluation (<a href='expr.const'>[expr.const]</a>) within the template
instantiation uses
  </p><ul class='itemize'><li id='8.4.3.1'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#8.4.3.1'>(8.4.3.1)</a></div><p >the value of a <span class='texttt'>const</span> object of integral or unscoped enumeration type or
  </p></li><li id='8.4.3.2'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#8.4.3.2'>(8.4.3.2)</a></div><p >the value of a <span class='texttt'>constexpr</span> object or
  </p></li><li id='8.4.3.3'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#8.4.3.3'>(8.4.3.3)</a></div><p >the value of a reference or
  </p></li><li id='8.4.3.4'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#8.4.3.4'>(8.4.3.4)</a></div><p >the definition of a <span class='texttt'>constexpr</span> function,
  </p></li></ul><p >and that entity was not defined when the template was defined, or</p></li><li id='8.4.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#8.4.4'>(8.4.4)</a></div><p >a class template specialization or variable template specialization that
is specified by a non-dependent <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> is used by
the template, and either it is instantiated from a partial specialization that
was not defined when the template was defined or it names an explicit
specialization that was not declared when the template was defined.
</p></li></ul><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >Otherwise, no diagnostic shall be issued for a template
for which a valid specialization can be generated.
[&nbsp;<i>Note:</i><span class='space'></span>
If a template is instantiated, errors will be diagnosed according
to the other rules in this Standard.
Exactly when these errors are diagnosed is a quality of implementation issue.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int j;
template&lt;class T&gt; class X {
  void f(T t, int i, char* p) {
    t = i;          <span class='comment'>// diagnosed if <span class='texttt'>X::f</span> is instantiated
</span>                    <span class='comment'>// and the assignment to <span class='texttt'>t</span> is an error
</span>    p = i;          <span class='comment'>// may be diagnosed even if <span class='texttt'>X::f</span> is
</span>                    <span class='comment'>// not instantiated
</span>    p = j;          <span class='comment'>// may be diagnosed even if <span class='texttt'>X::f</span> is
</span>                    <span class='comment'>// not instantiated
</span>  }
  void g(T t) {
    +;              <span class='comment'>// may be diagnosed even if <span class='texttt'>X::g</span> is
</span>                    <span class='comment'>// not instantiated
</span>  }
};

template&lt;class... T&gt; struct A {
  void operator++(int, T... t);                 <span class='comment'>// error: too many parameters
</span>};
template&lt;class... T&gt; union X : T... { };        <span class='comment'>// error: union with base class
</span>template&lt;class... T&gt; struct A : T...,  T... { };<span class='comment'>// error: duplicate base class
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >When looking for the declaration of a name used in a template definition,
the usual lookup rules (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>, <a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>)
are used for non-dependent names.
The lookup of names dependent on the template parameters
is postponed until the actual template argument is known (<a href='temp.dep'>[temp.dep]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
#include &lt;iostream&gt;
using namespace std;

template&lt;class T&gt; class Set {
  T* p;
  int cnt;
public:
  Set();
  Set&lt;T&gt;(const Set&lt;T&gt;&amp;);
  void printall() {
    for (int i = 0; i&lt;cnt; i++)
      cout &lt;&lt; p[i] &lt;&lt; '\n';
  }
};
</pre><p >in the example,
<span class='texttt'>i</span>
is the local variable
<span class='texttt'>i</span>
declared in
<span class='texttt'>printall</span>,
<span class='texttt'>cnt</span>
is the member
<span class='texttt'>cnt</span>
declared in
<span class='texttt'>Set</span>,
and
<span class='texttt'>cout</span>
is the standard output stream declared in
<span class='texttt'>iostream</span>.
However, not every declaration can be found this way; the resolution of
some names must be postponed
until the actual
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>
are known.
For example, even though the name
<span class='texttt'>operator&lt;&lt;</span>
is known within the definition of
<span class='texttt'>printall()</span>
and a declaration of it can be found in
<span class='texttt'>&lt;iostream&gt;</span>,
the actual declaration of
<span class='texttt'>operator&lt;&lt;</span>
needed to print
<span class='texttt'>p[i]</span>
cannot be known until it is known what type
<span class='texttt'>T</span>
is (<a href='temp.dep'>[temp.dep]</a>).
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >If a name does not depend on a
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
(as defined in <a href='temp.dep'>[temp.dep]</a>), a declaration (or set of declarations) for that
name shall be in scope at the point where the name appears in the template
definition; the name is bound to the declaration (or declarations) found
at that point and this binding is not affected by declarations that are
visible at the point of instantiation.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
void f(char);

template&lt;class T&gt; void g(T t) {
  f(1);             <span class='comment'>// <span class='texttt'>f(char)</span>
</span>  f(T(1));          <span class='comment'>// dependent
</span>  f(t);             <span class='comment'>// dependent
</span>  dd++;             <span class='comment'>// not dependent
</span>                    <span class='comment'>// error: declaration for dd not found
</span>}

enum E { e };
void f(E);

double dd;
void h() {
  g(e);             <span class='comment'>// will cause one call of <span class='texttt'>f(char)</span> followed
</span>                    <span class='comment'>// by two calls of <span class='texttt'>f(E)</span>
</span>  g('a');           <span class='comment'>// will cause three calls of <span class='texttt'>f(char)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
For purposes of name lookup, default arguments and
<i ><a href='except.spec#nt:exception-specification'>exception-specifications</a></i> of function templates and default
arguments and <i ><a href='except.spec#nt:exception-specification'>exception-specifications</a></i> of
member functions of class templates are considered definitions (<a href='temp.decls'>[temp.decls]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='temp.local'><h3 ><a class='secnum' href='#temp.local' style='min-width:103pt'>14.6.1</a> Locally declared names <a class='abbr_ref' href='temp.local'>[temp.local]</a></h3><div class='para' id='temp.local-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.local-1'>1</a></div><p >Like normal (non-template) classes, class templates have an
injected-class-name (Clause <a href='class'>[class]</a>).
The
injected-class-name can be used
as a <i ><a href='temp.names#nt:template-name'>template-name</a></i> or a <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>.
When it is used with a
<i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i>,
as a <i ><a href='temp.names#nt:template-argument'>template-argument</a></i> for a template <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>,
or as the final identifier in the <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> of
a friend class template declaration,
it refers to the
class template itself. Otherwise, it is equivalent to the <i ><a href='temp.names#nt:template-name'>template-name</a></i>
followed by the <i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i> of the class template
enclosed in <span class='texttt'>&lt;&gt;</span>.</p></div><div class='para' id='temp.local-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.local-2'>2</a></div><p >Within the scope of a class template specialization or
partial specialization, when the injected-class-name is
used as a <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>,
it is equivalent to the <i ><a href='temp.names#nt:template-name'>template-name</a></i> followed by the
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>
of the class template specialization or partial
specialization enclosed in
<span class='texttt'>&lt;&gt;</span>.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;template&lt;class&gt; class T&gt; class A { };
template&lt;class T&gt; class Y;
template&lt;&gt; class Y&lt;int&gt; {
  Y* p;                               <span class='comment'>// meaning <span class='texttt'>Y&lt;int&gt;</span>
</span>  Y&lt;char&gt;* q;                         <span class='comment'>// meaning <span class='texttt'>Y&lt;char&gt;</span>
</span>  A&lt;Y&gt;* a;                            <span class='comment'>// meaning <span class='texttt'>A&lt;::Y&gt;</span>
</span>  class B {
    template&lt;class&gt; friend class Y;   <span class='comment'>// meaning <span class='texttt'>::Y</span>
</span>  };
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.local-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.local-3'>3</a></div><p >The injected-class-name of a class template or class
template specialization can be used either
as a <i ><a href='temp.names#nt:template-name'>template-name</a></i> or a <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>
wherever it is in scope.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; struct Base {
  Base* p;
};

template &lt;class T&gt; struct Derived: public Base&lt;T&gt; {
  typename Derived::Base* p;    <span class='comment'>// meaning <span class='texttt'>Derived::Base&lt;T&gt;</span>
</span>};

template&lt;class T, template&lt;class&gt; class U = T::template Base&gt; struct Third { };
Third&lt;Base&lt;int&gt; &gt; t;            <span class='comment'>// OK: default argument uses injected-class-name as a template
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.local-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.local-4'>4</a></div><p >A lookup that finds an injected-class-name (<a href='class.member.lookup'>[class.member.lookup]</a>) can result in an ambiguity in
certain cases (for example, if it is found in more than one
base class).
If all of the injected-class-names that are
found refer to specializations of the same class template,
and if the name
is used as a <i ><a href='temp.names#nt:template-name'>template-name</a></i>,
the reference refers to the class template itself and not a
specialization thereof, and is not ambiguous.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; struct Base { };
template &lt;class T&gt; struct Derived: Base&lt;int&gt;, Base&lt;char&gt; {
  typename Derived::Base b;             <span class='comment'>// error: ambiguous
</span>  typename Derived::Base&lt;double&gt; d;     <span class='comment'>// OK
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.local-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.local-5'>5</a></div><p >When the normal name of the template (i.e., the name from
the enclosing scope, not the injected-class-name) is
used,
it always refers to the class template itself and not a
specialization of the template.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class X {
  X* p;             <span class='comment'>// meaning <span class='texttt'>X&lt;T&gt;</span>
</span>  X&lt;T&gt;* p2;
  X&lt;int&gt;* p3;
  ::X* p4;          <span class='comment'>// error: missing template argument list
</span>                    <span class='comment'>// <span class='texttt'>::X</span> does not refer to the injected-class-name
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.local-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.local-6'>6</a></div><p >A
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
shall not be redeclared within its scope (including nested scopes).
A
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
shall not have the same name as the template name.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T, int i&gt; class Y {
  int T;            <span class='comment'>// error: template-parameter redeclared
</span>  void f() {
    char T;         <span class='comment'>// error: template-parameter redeclared
</span>  }
};

template&lt;class X&gt; class X;      <span class='comment'>// error: template-parameter redeclared
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.local-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.local-7'>7</a></div><p >In the definition of a member of
a class template that appears outside of the class template definition,
the name of a member of the class template hides the name of a
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
of any enclosing class templates (but not a <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> of the
member if the member is a class or function template).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  struct B <span class='texttt'>{ /* ... */ };</span>
  typedef void C;
  void f();
  template&lt;class U&gt; void g(U);
};

template&lt;class B&gt; void A&lt;B&gt;::f() {
  B b;              <span class='comment'>// <span class='texttt'>A</span>'s <span class='texttt'>B</span>, not the template parameter
</span>}

template&lt;class B&gt; template&lt;class C&gt; void A&lt;B&gt;::g(C) {
  B b;              <span class='comment'>// <span class='texttt'>A</span>'s <span class='texttt'>B</span>, not the template parameter
</span>  C c;              <span class='comment'>// the template parameter <span class='texttt'>C</span>, not <span class='texttt'>A</span>'s <span class='texttt'>C</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.local-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.local-8'>8</a></div><p >In the definition of a member of a class template that appears outside of the
namespace containing the class template definition,
the name of a
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
hides the name of a member of this namespace.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace N {
  class C { };
  template&lt;class T&gt; class B {
    void f(T);
  };
}
template&lt;class C&gt; void N::B&lt;C&gt;::f(C) {
  C b;              <span class='comment'>// <span class='texttt'>C</span> is the template parameter, not <span class='texttt'>N::C</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.local-9'><div class='marginalizedparent'><a class='marginalized' href='#temp.local-9'>9</a></div><p >In the definition of a class template or in the definition of a member of such
a template that appears outside of the template definition,
for each non-dependent base class (<a href='temp.dep.type'>[temp.dep.type]</a>),
if the name of the base class
or the name of a member of the
base class is the same as the name of a
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>,
the base class name or member name hides the
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
name (<a href='basic.scope.hiding'>[basic.scope.hiding]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A {
  struct B { <span class='comment'>/* ... */</span> };
  int a;
  int Y;
};

template&lt;class B, class a&gt; struct X : A {
  B b;              <span class='comment'>// <span class='texttt'>A</span>'s <span class='texttt'>B</span>
</span>  a b;              <span class='comment'>// error: <span class='texttt'>A</span>'s <span class='texttt'>a</span> isn't a type name
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='temp.dep'><h3 ><a class='secnum' href='#temp.dep' style='min-width:103pt'>14.6.2</a> Dependent names <a class='abbr_ref' href='temp.dep'>[temp.dep]</a></h3><div class='para' id='temp.dep-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep-1'>1</a></div><p ><span class='indexparent'><a class='index' id='name,dependent'></a></span>Inside a template, some constructs have semantics which may differ from one
instantiation to another.
Such a construct
<a class='hidden_link' href='#def:depends' id='def:depends'><i>depends</i></a>
on the template parameters.
In particular, types and expressions may depend on the type
and/or
value of
template parameters (as determined by the template arguments) and this determines
the context for name lookup for certain names.
An expressions may be
<span class='grammarterm'>type-dependent</span>
(that is, its type may depend on a template parameter) or
<span class='grammarterm'>value-dependent</span>
(that is, its value when evaluated as a constant expression (<a href='expr.const'>[expr.const]</a>)
may depend on a template parameter)
as described in this subclause.
In an expression of the form:</p><pre class='bnf'><i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#nt:expression-list'>expression-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span></pre><p >where the
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>
is an
<i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i>,
the
<i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i>
denotes a
<span class='indexparent'><a class='index' id='name,dependent'></a></span><a class='hidden_link' href='#def:dependent_name' id='def:dependent_name'><i>dependent name</i></a>
if</p><ul class='itemize'><li id='temp.dep-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep-1.1'>(1.1)</a></div><p >any of the expressions in the <i ><a href='expr.post#nt:expression-list'>expression-list</a></i> is a pack
expansion (<a href='temp.variadic'>[temp.variadic]</a>),</p></li><li id='temp.dep-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep-1.2'>(1.2)</a></div><p >any of the expressions
or <i ><a href='dcl.init#nt:braced-init-list'>braced-init-lists</a></i>
in the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
is type-dependent (<a href='temp.dep.expr'>[temp.dep.expr]</a>), or</p></li><li id='temp.dep-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep-1.3'>(1.3)</a></div><p >the <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i>
is a <i ><a href='temp.names#nt:template-id'>template-id</a></i> in which any of the template arguments depends
on a template parameter.
</p></li></ul><p >If an operand of an operator is a type-dependent expression, the operator
also denotes a dependent name.
Such names are unbound and
are looked up at the point of the template instantiation (<a href='temp.point'>[temp.point]</a>) in
both the context of the template definition and the
context of the point of instantiation.</p></div><div class='para' id='temp.dep-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep-2'>2</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; struct X : B&lt;T&gt; {
  typename T::A* pa;
  void f(B&lt;T&gt;* pb) {
    static int i = B&lt;T&gt;::i;
    pb-&gt;j++;
  }
};
</pre><p >the base class name
<span class='texttt'>B&lt;T&gt;</span>,
the type name
<span class='texttt'>T::A</span>,
the names
<span class='texttt'>B&lt;T&gt;::i</span>
and
<span class='texttt'>pb-&gt;j</span>
explicitly depend on the
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.dep-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep-3'>3</a></div><p >In the definition of a class or class template,
the scope of a dependent base class (<a href='temp.dep.type'>[temp.dep.type]</a>)
is not examined during unqualified
name lookup either at the point of definition of the
class template or member or during an instantiation of
the class template or member.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
typedef double A;
template&lt;class T&gt; class B {
  typedef int A;
};
template&lt;class T&gt; struct X : B&lt;T&gt; {
  A a;              <span class='comment'>// <span class='texttt'>a</span> has type <span class='texttt'>double</span>
</span>};
</pre><p >The type name
<span class='texttt'>A</span>
in the definition of
<span class='texttt'>X&lt;T&gt;</span>
binds to the typedef name defined in the global
namespace scope, not to the typedef name
defined in the base class
<span class='texttt'>B&lt;T&gt;</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A {
  struct B { <span class='comment'>/* ... */</span> };
  int a;
  int Y;
};

int a;

template&lt;class T&gt; struct Y : T {
  struct B { <span class='comment'>/* ... */</span> };
  B b;                          <span class='comment'>// The <span class='texttt'>B</span> defined in <span class='texttt'>Y</span>
</span>  void f(int i) { a = i; }      <span class='comment'>// <span class='texttt'>::a</span>
</span>  Y* p;                         <span class='comment'>// <span class='texttt'>Y&lt;T&gt;</span>
</span>};

Y&lt;A&gt; ya;
</pre><p >The members
<span class='texttt'>A::B</span>,
<span class='texttt'>A::a</span>,
and
<span class='texttt'>A::Y</span>
of the template argument
<span class='texttt'>A</span>
do not affect the binding of names in
<span class='texttt'>Y&lt;A&gt;</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='temp.dep.type'><h4 ><a class='secnum' href='#temp.dep.type' style='min-width:118pt'>14.6.2.1</a> Dependent types <a class='abbr_ref' href='temp.dep.type'>[temp.dep.type]</a></h4><div class='para' id='temp.dep.type-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.type-1'>1</a></div><p >A name refers to the
<a class='hidden_link' href='#def:current_instantiation' id='def:current_instantiation'><i>current instantiation</i></a>
if it is</p><ul class='itemize'><li id='temp.dep.type-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-1.1'>(1.1)</a></div><p >in the definition of a class template, a nested class of a class template,
a member of a class template, or a member of a nested class of a class template,
the injected-class-name (Clause <a href='class'>[class]</a>) of the class template or nested class,
</p></li><li id='temp.dep.type-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-1.2'>(1.2)</a></div><p >in the definition of a primary class template
or a member of a primary class template, the name of the
class template followed by the template argument list of the
primary template (as described below) enclosed in
<span class='texttt'>&lt;&gt;</span> (or an equivalent template alias specialization),
</p></li><li id='temp.dep.type-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-1.3'>(1.3)</a></div><p >in the definition of a nested class of a class template,
the name of the nested class referenced as a member of the
current instantiation, or
</p></li><li id='temp.dep.type-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-1.4'>(1.4)</a></div><p >in the definition of a partial specialization
or a member of a partial specialization, the name of
the class template followed by the template argument list of
the partial specialization enclosed in
<span class='texttt'>&lt;&gt;</span> (or an equivalent template alias specialization).
If the <i>n</i>th template parameter is
a parameter pack, the <i>n</i>th template argument is a pack
expansion (<a href='temp.variadic'>[temp.variadic]</a>) whose pattern is the name of
the parameter pack.
</p></li></ul></div><div class='para' id='temp.dep.type-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.type-2'>2</a></div><p >The template argument list of a primary template is a
template argument list in which the
<i>n</i>th
template argument has the value of the
<i>n</i>th
template parameter of the class template.
If the <i>n</i>th template parameter is a template
parameter pack (<a href='temp.variadic'>[temp.variadic]</a>), the <i>n</i>th template argument is a pack
expansion (<a href='temp.variadic'>[temp.variadic]</a>) whose pattern is the name of
the template parameter pack.</p></div><div class='para' id='temp.dep.type-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.type-3'>3</a></div><p >A template argument that is equivalent to a template
parameter (i.e., has the same constant value or the same type
as the template parameter) can be used in place of that
template parameter in a reference to the current
instantiation. In the case of a non-type template argument,
the argument must have been given the value of the
template parameter and not an expression in which the
template parameter appears as a subexpression.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T&gt; class A {
  A* p1;                        <span class='comment'>// <span class='texttt'>A</span> is the current instantiation
</span>  A&lt;T&gt;* p2;                     <span class='comment'>// <span class='texttt'>A&lt;T&gt;</span> is the current instantiation
</span>  A&lt;T*&gt; p3;                     <span class='comment'>// <span class='texttt'>A&lt;T*&gt;</span> is not the current instantiation
</span>  ::A&lt;T&gt;* p4;                   <span class='comment'>// <span class='texttt'>::A&lt;T&gt;</span> is the current instantiation
</span>  class B {
    B* p1;                      <span class='comment'>// <span class='texttt'>B</span> is the current instantiation
</span>    A&lt;T&gt;::B* p2;                <span class='comment'>// <span class='texttt'>A&lt;T&gt;::B</span> is the current instantiation
</span>    typename A&lt;T*&gt;::B* p3;      <span class='comment'>// <span class='texttt'>A&lt;T*&gt;::B</span> is not the
</span>                                <span class='comment'>// current instantiation
</span>  };
};

template &lt;class T&gt; class A&lt;T*&gt; {
  A&lt;T*&gt;* p1;                    <span class='comment'>// <span class='texttt'>A&lt;T*&gt;</span> is the current instantiation
</span>  A&lt;T&gt;* p2;                     <span class='comment'>// <span class='texttt'>A&lt;T&gt;</span> is not the current instantiation
</span>};

template &lt;class T1, class T2, int I&gt; struct B {
  B&lt;T1, T2, I&gt;* b1;             <span class='comment'>// refers to the current instantiation
</span>  B&lt;T2, T1, I&gt;* b2;             <span class='comment'>// not the current instantiation
</span>  typedef T1 my_T1;
  static const int my_I = I;
  static const int my_I2 = I+0;
  static const int my_I3 = my_I;
  B&lt;my_T1, T2, my_I&gt;* b3;       <span class='comment'>// refers to the current instantiation
</span>  B&lt;my_T1, T2, my_I2&gt;* b4;      <span class='comment'>// not the current instantiation
</span>  B&lt;my_T1, T2, my_I3&gt;* b5;      <span class='comment'>// refers to the current instantiation
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.dep.type-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.type-4'>4</a></div><p ><span class='indexparent'><a class='index' id='base_class,dependent'></a></span>A <a class='hidden_link' href='#def:dependent_base_class' id='def:dependent_base_class'><i>dependent base class</i></a> is a base class that is a dependent type and is
not the current instantiation.
[&nbsp;<i>Note:</i><span class='space'></span>
a base class can be the current instantiation in the case of a nested class
naming an enclosing class as a base.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  typedef int M;
  struct B {
    typedef void M;
    struct C;
  };
};

template&lt;class T&gt; struct A&lt;T&gt;::B::C : A&lt;T&gt; {
  M m; <span class='comment'>// OK, <span class='texttt'>A&lt;T&gt;::M</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.dep.type-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.type-5'>5</a></div><p ><span class='indexparent'><a class='index' id='instantiation,member_of_the_current'></a></span>A name is a
<a class='hidden_link' href='#def:member_of_the_current_instantiation' id='def:member_of_the_current_instantiation'><i>member of the current instantiation</i></a>
if it is</p><ul class='itemize'><li id='temp.dep.type-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-5.1'>(5.1)</a></div><p >An unqualified name that, when looked up, refers to
at least one member of a class that is
the current instantiation or a non-dependent base class thereof.
[&nbsp;<i>Note:</i><span class='space'></span>
This can only occur when looking up a name in a scope enclosed by the
definition of a class template.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li><li id='temp.dep.type-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-5.2'>(5.2)</a></div><p >A
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
in which the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation
and that, when looked up, refers to at least one member of a class that is
the current
instantiation or a non-dependent base class thereof. [&nbsp;<i>Note:</i><span class='space'></span> if no such
member is found, and the current instantiation has any dependent base classes,
then the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> is a member of an unknown specialization;
see below. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li id='temp.dep.type-5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-5.3'>(5.3)</a></div><p >An <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> denoting the member in a class member access
expression (<a href='expr.ref'>[expr.ref]</a>) for which the type of the object expression is the
current instantiation, and the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>, when looked
up (<a href='basic.lookup.classref'>[basic.lookup.classref]</a>), refers to at least one member of a class
that is the current
instantiation or a non-dependent base class thereof. [&nbsp;<i>Note:</i><span class='space'></span> if no such
member is found, and the current instantiation has any dependent base classes,
then the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> is a member of an unknown specialization;
see below. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template &lt;class T&gt; class A {
  static const int i = 5;
  int n1[i];        <span class='comment'>// <span class='texttt'>i</span> refers to a member of the current instantiation
</span>  int n2[A::i];     <span class='comment'>// <span class='texttt'>A::i</span> refers to a member of the current instantiation
</span>  int n3[A&lt;T&gt;::i];  <span class='comment'>// <span class='texttt'>A&lt;T&gt;::i</span> refers to a member of the current instantiation
</span>  int f();
};

template &lt;class T&gt; int A&lt;T&gt;::f() {
  return i;         <span class='comment'>// <span class='texttt'>i</span> refers to a member of the current instantiation
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='instantiation,dependent_member_of_the_current'></a></span>A name is a <a class='hidden_link' href='#def:dependent_member_of_the_current_instantiation' id='def:dependent_member_of_the_current_instantiation'><i>dependent member of the current instantiation</i></a> if it is a
member of the current instantiation that, when looked up, refers to at least
one member of a class that is the current instantiation.</p></div><div class='para' id='temp.dep.type-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.type-6'>6</a></div><p >A name is a
<a class='hidden_link' href='#def:member_of_an_unknown_specialization' id='def:member_of_an_unknown_specialization'><i>member of an unknown specialization</i></a>
if it is</p><ul class='itemize'><li id='temp.dep.type-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-6.1'>(6.1)</a></div><p >A
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
in which the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
names a dependent type that is not the current instantiation.</p></li><li id='temp.dep.type-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-6.2'>(6.2)</a></div><p >A <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> in which the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation, the current instantiation has at least one
dependent base class, and name lookup of the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> does not
find any member of a class that is the current instantiation or a non-dependent
base class thereof.</p></li><li id='temp.dep.type-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-6.3'>(6.3)</a></div><p >An <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> denoting the member in a class member access
expression (<a href='expr.ref'>[expr.ref]</a>) in which either
</p><ul class='itemize'><li id='temp.dep.type-6.3.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#temp.dep.type-6.3.1'>(6.3.1)</a></div><p >the type of the object expression is the current instantiation, the
current instantiation has at least one dependent base class, and name lookup
of the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> does not find a member of a class that is
the current instantiation or a non-dependent base class thereof; or</p></li><li id='temp.dep.type-6.3.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#temp.dep.type-6.3.2'>(6.3.2)</a></div><p >the type of the object expression is dependent and is not the current
instantiation.
</p></li></ul></li></ul></div><div class='para' id='temp.dep.type-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.type-7'>7</a></div><p >If a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> in which the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation is not a member of the current instantiation
or a member of an unknown specialization, the program is ill-formed even if the
template containing the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> is not instantiated; no
diagnostic required. Similarly, if the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> in a class
member access expression for which the type of the object expression is the
current instantiation does not refer to a member of the current instantiation
or a member of an unknown specialization, the program is ill-formed even if the
template containing the member access expression is not instantiated; no diagnostic
required. [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; class A {
  typedef int type;
  void f() {
    A&lt;T&gt;::type i;           <span class='comment'>// OK: refers to a member of the current instantiation
</span>    typename A&lt;T&gt;::other j; <span class='comment'>// error: neither a member of the current instantiation nor
</span>                            <span class='comment'>// a member of an unknown specialization
</span>  }
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.dep.type-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.type-8'>8</a></div><p >If, for a given set of template arguments, a specialization of a template is
instantiated that refers to a member of the current instantiation with a
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> or class member access expression, the name in the
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> or class member access expression is looked up in the
template instantiation context. If the result of this lookup differs from the
result of name lookup in the template definition context, name lookup is
ambiguous.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A {
  int m;
};

struct B {
  int m;
};

template&lt;typename T&gt;
struct C : A, T {
  int f() { return this-&gt;m; }  <span class='comment'>// finds <span class='texttt'>A::m</span> in the template definition context
</span>  int g() { return m; }        <span class='comment'>// finds <span class='texttt'>A::m</span> in the template definition context
</span>};

template int C&lt;B&gt;::f();        <span class='comment'>// error: finds both <span class='texttt'>A::m</span> and <span class='texttt'>B::m</span>
</span>template int C&lt;B&gt;::g();        <span class='comment'>// OK: transformation to class member access syntax
</span>                               <span class='comment'>// does not occur in the template definition context; see <a href='class.mfct.non-static'>[class.mfct.non-static]</a>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.dep.type-9'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.type-9'>9</a></div><p >A type is dependent if it is
</p><ul class='itemize'><li id='temp.dep.type-9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-9.1'>(9.1)</a></div><p >a template parameter,
</p></li><li id='temp.dep.type-9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-9.2'>(9.2)</a></div><p >a member of an unknown specialization,
</p></li><li id='temp.dep.type-9.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-9.3'>(9.3)</a></div><p >a nested class or enumeration that is a dependent member of the current
instantiation,
</p></li><li id='temp.dep.type-9.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-9.4'>(9.4)</a></div><p >a cv-qualified type where the cv-unqualified type is dependent,
</p></li><li id='temp.dep.type-9.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-9.5'>(9.5)</a></div><p >a compound type constructed from any dependent type,
</p></li><li id='temp.dep.type-9.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-9.6'>(9.6)</a></div><p >an array type whose element type is dependent or whose
bound (if any) is value-dependent,
</p></li><li id='temp.dep.type-9.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-9.7'>(9.7)</a></div><p >a
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
in which either the template name is a template parameter or any of the
template arguments is a dependent type or an expression that is type-dependent
or value-dependent or is a pack expansion, or
</p></li><li id='temp.dep.type-9.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.type-9.8'>(9.8)</a></div><p >denoted by <span class='texttt'>decltype(</span><i ><a href='expr.comma#nt:expression'>expression</a></i><span class='texttt'>)</span>,
where <i ><a href='expr.comma#nt:expression'>expression</a></i> is type-dependent (<a href='temp.dep.expr'>[temp.dep.expr]</a>).
</p></li></ul></div><div class='para' id='temp.dep.type-10'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.type-10'>10</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Because typedefs do not introduce new types, but
instead simply refer to other types, a name that refers to a
typedef that is a member of the current instantiation is dependent
only if the type referred to is dependent.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='temp.dep.expr'><h4 ><a class='secnum' href='#temp.dep.expr' style='min-width:118pt'>14.6.2.2</a> Type-dependent expressions <a class='abbr_ref' href='temp.dep.expr'>[temp.dep.expr]</a></h4><div class='para' id='temp.dep.expr-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.expr-1'>1</a></div><p >Except as described below, an expression is type-dependent if any
subexpression is type-dependent.</p></div><div class='para' id='temp.dep.expr-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.expr-2'>2</a></div><p ><span class='texttt'>this</span>
is type-dependent if the class type of the enclosing member function is
dependent (<a href='temp.dep.type'>[temp.dep.type]</a>).</p></div><div class='para' id='temp.dep.expr-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.expr-3'>3</a></div><p >An
<i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
is type-dependent if it contains</p><ul class='itemize'><li id='temp.dep.expr-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.expr-3.1'>(3.1)</a></div><p >an
<i ><a href='lex.name#nt:identifier'>identifier</a></i>
associated by name lookup with one or more declarations
declared with a dependent type,</p></li><li id='temp.dep.expr-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.expr-3.2'>(3.2)</a></div><p >an
<i ><a href='lex.name#nt:identifier'>identifier</a></i>
associated by name lookup with
a non-type <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
declared with a type
that contains a placeholder type (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>),</p></li><li id='temp.dep.expr-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.expr-3.3'>(3.3)</a></div><p >an <i ><a href='lex.name#nt:identifier'>identifier</a></i> associated by name lookup with one or more
declarations of member functions of the current instantiation declared
with a return type that contains a placeholder type,</p></li><li id='temp.dep.expr-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.expr-3.4'>(3.4)</a></div><p >an <i ><a href='lex.name#nt:identifier'>identifier</a></i> associated by name lookup with a decomposition
declaration (<a href='dcl.decomp'>[dcl.decomp]</a>) whose <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i>
is type-dependent,</p></li><li id='temp.dep.expr-3.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.expr-3.5'>(3.5)</a></div><p >the
<i ><a href='lex.name#nt:identifier'>identifier</a></i>
<span class='texttt'>__func__</span> (<a href='dcl.fct.def.general'>[dcl.fct.def.general]</a>), where any enclosing function is a
template, a member of a class template, or a generic lambda,</p></li><li id='temp.dep.expr-3.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.expr-3.6'>(3.6)</a></div><p >a
<i ><a href='temp.names#nt:template-id'>template-id</a></i>
that is dependent,</p></li><li id='temp.dep.expr-3.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.expr-3.7'>(3.7)</a></div><p >a
<i ><a href='class.conv.fct#nt:conversion-function-id'>conversion-function-id</a></i>
that specifies a dependent type, or</p></li><li id='temp.dep.expr-3.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.expr-3.8'>(3.8)</a></div><p >a
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
or a
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
that names a member of an unknown specialization;
</p></li></ul><p >or if it names a dependent member of the current instantiation that is a static
data member of type
“array of unknown bound of <span class='texttt'>T</span>” for some <span class='texttt'>T</span> (<a href='temp.static'>[temp.static]</a>).
Expressions of the following forms are type-dependent only if the type
specified by the
<i ><a href='dcl.name#nt:type-id'>type-id</a></i>,
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i>
or
<i ><a href='expr.new#nt:new-type-id'>new-type-id</a></i>
is dependent, even if any subexpression is type-dependent:</p><pre class='bnf'><i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#nt:expression-list'>expression-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> new</span> <i ><a href='expr.new#nt:new-placement'>new-placement</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='expr.new#nt:new-type-id'>new-type-id</a></i> <i ><a href='expr.new#nt:new-initializer'>new-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> new</span> <i ><a href='expr.new#nt:new-placement'>new-placement</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>(</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span> <i ><a href='expr.new#nt:new-initializer'>new-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='terminal'>dynamic_cast &lt;</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>static_cast &lt;</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>const_cast &lt;</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>reinterpret_cast &lt;</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>(</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i></pre></div><div class='para' id='temp.dep.expr-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.expr-4'>4</a></div><p >Expressions of the following forms are never type-dependent (because the type
of the expression cannot be dependent):</p><pre class='bnf'><i ><a href='lex.literal.kinds#nt:literal'>literal</a></i>
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>.</span> <i ><a href='expr.post#nt:pseudo-destructor-name'>pseudo-destructor-name</a></i>
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>-&gt;</span> <i ><a href='expr.post#nt:pseudo-destructor-name'>pseudo-destructor-name</a></i>
<span class='terminal'>sizeof</span> <i ><a href='expr.unary#nt:unary-expression'>unary-expression</a></i>
<span class='terminal'>sizeof (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>sizeof</span> <span class='terminal'>...</span> <span class='terminal'>(</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>)</span>
<span class='terminal'>alignof (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>typeid (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>typeid (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> delete</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> delete [ ]</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
<span class='terminal'>throw</span> <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='terminal'>noexcept</span> <span class='terminal'>(</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span></pre><p >[&nbsp;<i>Note:</i><span class='space'></span> For the standard library macro <span class='texttt'>offsetof</span>,
see <a href='support.types'>[support.types]</a>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.dep.expr-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.expr-5'>5</a></div><p >A class member access expression (<a href='expr.ref'>[expr.ref]</a>) is
type-dependent if
the expression refers to a member of the current instantiation and
the type of the referenced member is dependent, or the class member access
expression refers to a member of an unknown specialization.
[&nbsp;<i>Note:</i><span class='space'></span>
In an expression of the form
<span class='texttt'>x.y</span>
or
<span class='texttt'>xp-&gt;y</span>
the type of the expression is usually the type of the member
<span class='texttt'>y</span>
of the class of
<span class='texttt'>x</span>
(or the class pointed to by
<span class='texttt'>xp</span>).
However, if
<span class='texttt'>x</span>
or
<span class='texttt'>xp</span>
refers to a dependent type that is not the current instantiation,
the type of
<span class='texttt'>y</span>
is always dependent. If
<span class='texttt'>x</span>
or <span class='texttt'>xp</span>
refers to a non-dependent type or refers to the current instantiation, the
type of
<span class='texttt'>y</span>
is the type of the class member access expression.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.dep.expr-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.expr-6'>6</a></div><p >A <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> is type-dependent if any element is
type-dependent or is a pack expansion.</p></div><div class='para' id='temp.dep.expr-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.expr-7'>7</a></div><p >A <i ><a href='expr.prim.fold#nt:fold-expression'>fold-expression</a></i> is type-dependent.</p></div></div><div id='temp.dep.constexpr'><h4 ><a class='secnum' href='#temp.dep.constexpr' style='min-width:118pt'>14.6.2.3</a> Value-dependent expressions <a class='abbr_ref' href='temp.dep.constexpr'>[temp.dep.constexpr]</a></h4><div class='para' id='temp.dep.constexpr-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.constexpr-1'>1</a></div><p >Except as described below, an expression used in a context where a
constant expression is required is value-dependent if any
subexpression is value-dependent.</p></div><div class='para' id='temp.dep.constexpr-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.constexpr-2'>2</a></div><p >An
<i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
is value-dependent if:</p><ul class='itemize'><li id='temp.dep.constexpr-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.constexpr-2.1'>(2.1)</a></div><p >it is type-dependent,
</p></li><li id='temp.dep.constexpr-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.constexpr-2.2'>(2.2)</a></div><p >it is the name of a non-type template parameter,
</p></li><li id='temp.dep.constexpr-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.constexpr-2.3'>(2.3)</a></div><p >it names a static data member that is a dependent member of the current
instantiation and is not initialized in a <i ><a href='class.mem#nt:member-declarator'>member-declarator</a></i>,
</p></li><li id='temp.dep.constexpr-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.constexpr-2.4'>(2.4)</a></div><p >it names a static member function that is a dependent member of the current
instantiation, or
</p></li><li id='temp.dep.constexpr-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.constexpr-2.5'>(2.5)</a></div><p >it is a constant with literal type and is initialized with an
expression that is value-dependent.
</p></li></ul><p >Expressions of the following form are value-dependent if the
<i ><a href='expr.unary#nt:unary-expression'>unary-expression</a></i> or <i ><a href='expr.comma#nt:expression'>expression</a></i>
is type-dependent or the
<i ><a href='dcl.name#nt:type-id'>type-id</a></i>
is dependent:</p><pre class='bnf'><span class='terminal'>sizeof</span> <i ><a href='expr.unary#nt:unary-expression'>unary-expression</a></i>
<span class='terminal'>sizeof (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>typeid (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>typeid (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>alignof (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>noexcept</span> <span class='terminal'>(</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span></pre><p >[&nbsp;<i>Note:</i><span class='space'></span> For the standard library macro <span class='texttt'>offsetof</span>,
see <a href='support.types'>[support.types]</a>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.dep.constexpr-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.constexpr-3'>3</a></div><p >Expressions of the following form are value-dependent if either the
<i ><a href='dcl.name#nt:type-id'>type-id</a></i>
or
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i>
is dependent or the
<i ><a href='expr.comma#nt:expression'>expression</a></i>
or
<i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
is value-dependent:</p><pre class='bnf'><i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#nt:expression-list'>expression-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span>
<span class='terminal'>static_cast &lt;</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>const_cast &lt;</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>reinterpret_cast &lt;</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>(</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i></pre></div><div class='para' id='temp.dep.constexpr-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.constexpr-4'>4</a></div><p >Expressions of the following form are value-dependent:</p><pre class='bnf'><span class='terminal'>sizeof</span> <span class='terminal'>...</span> <span class='terminal'>(</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>)</span>
<i ><a href='expr.prim.fold#nt:fold-expression'>fold-expression</a></i></pre></div><div class='para' id='temp.dep.constexpr-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.constexpr-5'>5</a></div><p >An expression of the form <span class='texttt'>&amp;</span><i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> where the
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> names a dependent member of the current
instantiation is value-dependent.</p></div></div><div id='temp.dep.temp'><h4 ><a class='secnum' href='#temp.dep.temp' style='min-width:118pt'>14.6.2.4</a> Dependent template arguments <a class='abbr_ref' href='temp.dep.temp'>[temp.dep.temp]</a></h4><div class='para' id='temp.dep.temp-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.temp-1'>1</a></div><p >A type
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
is dependent if the type it specifies is dependent.</p></div><div class='para' id='temp.dep.temp-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.temp-2'>2</a></div><p >A non-type
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
is dependent if its type is dependent or the constant
expression it specifies is value-dependent.</p></div><div class='para' id='temp.dep.temp-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.temp-3'>3</a></div><p >Furthermore, a non-type
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
is dependent if the corresponding non-type <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
is of reference or pointer type and the <i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
designates or points to a member of the current instantiation or a member of
a dependent type.</p></div><div class='para' id='temp.dep.temp-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.temp-4'>4</a></div><p >A template
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
is dependent if it names a
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
or is a
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
that refers to a member of an unknown specialization.</p></div></div></div><div id='temp.nondep'><h3 ><a class='secnum' href='#temp.nondep' style='min-width:103pt'>14.6.3</a> Non-dependent names <a class='abbr_ref' href='temp.nondep'>[temp.nondep]</a></h3><div class='para' id='temp.nondep-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.nondep-1'>1</a></div><p >Non-dependent names used in a template definition are found using the
usual name lookup and bound at the point they are used.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
void g(double);
void h();

template&lt;class T&gt; class Z {
public:
  void f() {
    g(1);           <span class='comment'>// calls <span class='texttt'>g(double)</span>
</span>    h++;            <span class='comment'>// ill-formed: cannot increment function;
</span>                    <span class='comment'>// this could be diagnosed either here or
</span>                    <span class='comment'>// at the point of instantiation
</span>  }
};

void g(int);        <span class='comment'>// not in scope at the point of the template
</span>                    <span class='comment'>// definition, not considered for the call <span class='texttt'>g(1)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='temp.dep.res'><h3 ><a class='secnum' href='#temp.dep.res' style='min-width:103pt'>14.6.4</a> Dependent name resolution <a class='abbr_ref' href='temp.dep.res'>[temp.dep.res]</a></h3><div class='para' id='temp.dep.res-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.res-1'>1</a></div><p ><span class='indexparent'><a class='index' id='name,dependent'></a></span>In resolving dependent names, names from the following sources are considered:</p><ul class='itemize'><li id='temp.dep.res-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.res-1.1'>(1.1)</a></div><p >Declarations that are visible at the point of definition of the
template.
</p></li><li id='temp.dep.res-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.res-1.2'>(1.2)</a></div><p >Declarations from namespaces associated with the types of the
function arguments both from the instantiation context (<a href='temp.point'>[temp.point]</a>)
and from the definition context.
</p></li></ul></div><div id='temp.point'><h4 ><a class='secnum' href='#temp.point' style='min-width:118pt'>14.6.4.1</a> Point of instantiation <a class='abbr_ref' href='temp.point'>[temp.point]</a></h4><div class='para' id='temp.point-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.point-1'>1</a></div><p ><span class='indexparent'><a class='index' id='instantiation,point_of'></a></span>For a function template specialization, a member function template
specialization, or a specialization for a member function or static data member
of a class template,
if the specialization is implicitly instantiated because it is referenced
from within another template specialization and
the context from which it is referenced depends on a template parameter,
the point of instantiation of the specialization is the point of instantiation
of the enclosing specialization.
Otherwise, the point of instantiation for such a specialization immediately
follows the namespace scope declaration
or definition that refers to the specialization.</p></div><div class='para' id='temp.point-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.point-2'>2</a></div><p >If a function template or member function of a class template is called
in a way which uses the definition of a default argument of that function
template or member function,
the point of instantiation of the default argument is the point of
instantiation of the function template or member function specialization.</p></div><div class='para' id='temp.point-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.point-3'>3</a></div><p >For an <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> of a function template
specialization or specialization of a member function of a class template, if
the <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> is implicitly instantiated because
it is needed by another template specialization and the context that requires
it depends on a template parameter, the point of instantiation of the
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> is the point of instantiation of the
specialization that requires it. Otherwise, the point of instantiation for such
an <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> immediately follows the namespace
scope declaration or definition that requires the
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>.</p></div><div class='para' id='temp.point-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.point-4'>4</a></div><p >For a class template specialization, a class member template specialization,
or a specialization for a class member of a class template,
if the specialization is implicitly instantiated because it is referenced
from within another template specialization,
if the context from which the specialization is referenced depends on a
template parameter,
and if the specialization is not instantiated previous to the instantiation of
the enclosing template,
the point of instantiation is immediately before the point of instantiation of
the enclosing template.
Otherwise, the point of instantiation for such a specialization immediately
precedes the namespace scope declaration
or definition that refers to the specialization.</p></div><div class='para' id='temp.point-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.point-5'>5</a></div><p >If a virtual function is implicitly instantiated, its point of instantiation
is immediately following the point of instantiation of its enclosing class
template specialization.</p></div><div class='para' id='temp.point-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.point-6'>6</a></div><p >An explicit instantiation definition is an instantiation
point for the specialization or specializations specified by the explicit
instantiation.</p></div><div class='para' id='temp.point-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.point-7'>7</a></div><p >The instantiation context of an expression that depends on the template
arguments is the set of declarations with external linkage declared prior to the
point of instantiation of the template specialization in the same translation
unit.</p></div><div class='para' id='temp.point-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.point-8'>8</a></div><p >A specialization for a function template, a member function template,
or of a member function or static data member of a class template may have
multiple points of instantiations within a translation unit, and in addition
to the points of instantiation described above, for any such specialization
that has a point of instantiation within the translation unit, the end of the
translation unit is also considered a point of instantiation.
A specialization for a class template has at most one point of instantiation
within a translation unit.
A specialization for any template may have points of instantiation in multiple
translation units.
If two different points of instantiation give a template specialization
different meanings according to the one-definition rule (<a href='basic.def.odr'>[basic.def.odr]</a>),
the program is ill-formed, no diagnostic required.</p></div></div><div id='temp.dep.candidate'><h4 ><a class='secnum' href='#temp.dep.candidate' style='min-width:118pt'>14.6.4.2</a> Candidate functions <a class='abbr_ref' href='temp.dep.candidate'>[temp.dep.candidate]</a></h4><div class='para' id='temp.dep.candidate-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.dep.candidate-1'>1</a></div><p ><span class='indexparent'><a class='index' id='functions,candidate'></a></span>For a function call where the <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> is a
dependent name,
the candidate functions are found using the usual lookup
rules (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>, <a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>) except that:</p><ul class='itemize'><li id='temp.dep.candidate-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.candidate-1.1'>(1.1)</a></div><p >For the part of the lookup using unqualified name lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>),
only function declarations
from the template definition context are found.
</p></li><li id='temp.dep.candidate-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.dep.candidate-1.2'>(1.2)</a></div><p >For the part of the lookup using associated namespaces (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>),
only function declarations found in either the template
definition context or the template instantiation context are found.
</p></li></ul><p >If
the call would be ill-formed or would find a better match had the lookup
within the associated namespaces considered all the function declarations with
external linkage introduced in those namespaces in all translation units,
not just considering those declarations found in the template definition and
template instantiation contexts, then the program has undefined behavior.</p></div></div></div><div id='temp.inject'><h3 ><a class='secnum' href='#temp.inject' style='min-width:103pt'>14.6.5</a> Friend names declared within a class template <a class='abbr_ref' href='temp.inject'>[temp.inject]</a></h3><div class='para' id='temp.inject-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.inject-1'>1</a></div><p >Friend classes or functions can be declared within a class template.
When a template is instantiated, the names of its friends are treated
as if the specialization had been explicitly declared at its point of
instantiation.</p></div><div class='para' id='temp.inject-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.inject-2'>2</a></div><p >As with non-template classes, the names of namespace-scope friend
functions of a class template specialization are not visible during
an ordinary lookup unless explicitly declared at namespace scope (<a href='class.friend'>[class.friend]</a>).
Such names may be found under the rules for associated
classes (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>).<a class='footnotenum' href='#footnote-141'>141</a>
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;typename T&gt; struct number {
  number(int);
  friend number gcd(number x, number y) { return 0; };
};

void g() {
  number&lt;double&gt; a(3), b(4);
  a = gcd(a,b);     <span class='comment'>// finds <span class='texttt'>gcd</span> because <span class='texttt'>number&lt;double&gt;</span> is an
</span>                    <span class='comment'>// associated class, making <span class='texttt'>gcd</span> visible
</span>                    <span class='comment'>// in its namespace (global scope)
</span>  b = gcd(3,4);     <span class='comment'>// ill-formed; <span class='texttt'>gcd</span> is not visible
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='footnote' id='footnote-141'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-141'>141)</a></div><p >Friend declarations do not
introduce new names into any scope, either
when the template is declared or when it is instantiated.</p></div></div></div></div></body></html>