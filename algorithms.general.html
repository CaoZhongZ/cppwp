<!DOCTYPE html><html lang='en'><head><title>[algorithms.general]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>25</a> Algorithms library <a class='abbr_ref' href='./#algorithms'>[algorithms]</a></h1><div id='algorithms.general'><h2 ><a class='secnum' style='min-width:88pt'>25.1</a> General <a class='abbr_ref'>[algorithms.general]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >This Clause describes components that C++ programs may use to perform
algorithmic operations on containers (Clause <a href='containers'>[containers]</a>) and other sequences.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The following subclauses describe components for
non-modifying sequence operations,
modifying sequence operations,
sorting and related operations,
and algorithms from the ISO C library,
as summarized in Table <a href='#tab:algorithms.summary'>[tab:algorithms.summary]</a>.</p><div class='numberedTable' id='tab:algorithms.summary'>Table <a href='#tab:algorithms.summary'>95</a> â€” Algorithms library summary<br><table ><tr class='rowsep'><td colspan='2' class='center'><b>Subclause</b></td><td class='left'>	<b>Header(s)</b>	</td></tr><tr class='capsep'><td class='left'> 


<a href='alg.nonmodifying'>[alg.nonmodifying]</a> </td><td class='left'> Non-modifying sequence operations  </td><td class='left'>           </td></tr><tr ><td class='left'>
<a href='alg.modifying.operations'>[alg.modifying.operations]</a> </td><td class='left'> Mutating sequence operations </td><td class='left'> <span class='texttt'>&lt;algorithm&gt;</span> </td></tr><tr ><td class='left'>
<a href='alg.sorting'>[alg.sorting]</a> </td><td class='left'> Sorting and related operations      </td><td class='left'>           </td></tr><tr class='rowsep'><td class='left'> 
<a href='alg.c.library'>[alg.c.library]</a> </td><td class='left'> C library algorithms          </td><td class='left'> <span class='texttt'>&lt;cstdlib&gt;</span> </td></tr></table></div><p ><b>Header <span class='texttt'>&lt;algorithm&gt;</span> synopsis</b>
<span class='indexparent'><a class='index' id='algorithm'></a></span>
</p><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// <a href='alg.nonmodifying'>[alg.nonmodifying]</a>, non-modifying sequence operations
</span>  template &lt;class InputIterator, class Predicate&gt;
    bool all_of(InputIterator first, InputIterator last, Predicate pred);
  template &lt;class ExecutionPolicy, class InputIterator, class Predicate&gt;
    bool all_of(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                InputIterator first, InputIterator last, Predicate pred);
  template &lt;class InputIterator, class Predicate&gt;
    bool any_of(InputIterator first, InputIterator last, Predicate pred);
  template &lt;class ExecutionPolicy, class InputIterator, class Predicate&gt;
    bool any_of(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                InputIterator first, InputIterator last, Predicate pred);
  template &lt;class InputIterator, class Predicate&gt;
    bool none_of(InputIterator first, InputIterator last, Predicate pred);
  template &lt;class ExecutionPolicy, class InputIterator, class Predicate&gt;
    bool none_of(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                 InputIterator first, InputIterator last, Predicate pred);

  template&lt;class InputIterator, class Function&gt;
    Function for_each(InputIterator first, InputIterator last, Function f);
  template&lt;class ExecutionPolicy, class InputIterator, class Function&gt;
    void for_each(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                  InputIterator first, InputIterator last, Function f);
  template&lt;class InputIterator, class Size, class Function&gt;
    InputIterator for_each_n(InputIterator first, Size n, Function f);
  template&lt;class ExecutionPolicy, class InputIterator, class Size, class Function&gt;
    InputIterator for_each_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                             InputIterator first, Size n, Function f);

  template&lt;class InputIterator, class T&gt;
    InputIterator find(InputIterator first, InputIterator last,
                       const T&amp; value);
  template&lt;class ExecutionPolicy, class InputIterator, class T&gt;
    InputIterator find(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                       InputIterator first, InputIterator last,
                       const T&amp; value);
  template&lt;class InputIterator, class Predicate&gt;
    InputIterator find_if(InputIterator first, InputIterator last,
                          Predicate pred);
  template&lt;class ExecutionPolicy, class InputIterator, class Predicate&gt;
    InputIterator find_if(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                          InputIterator first, InputIterator last,
                          Predicate pred);
  template&lt;class InputIterator, class Predicate&gt;
    InputIterator find_if_not(InputIterator first, InputIterator last,
                              Predicate pred);
  template&lt;class ExecutionPolicy, class InputIterator, class Predicate&gt;
    InputIterator find_if_not(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                              InputIterator first, InputIterator last,
                              Predicate pred);
  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator1
      find_end(ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
    ForwardIterator1
      find_end(ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator1
      find_end(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2, class BinaryPredicate&gt;
    ForwardIterator1
      find_end(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);

  template&lt;class InputIterator, class ForwardIterator&gt;
    InputIterator
      find_first_of(InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2);
  template&lt;class InputIterator, class ForwardIterator, class BinaryPredicate&gt;
    InputIterator
      find_first_of(InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2,
                    BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class InputIterator, class ForwardIterator&gt;
    InputIterator
      find_first_of(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                    InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2);
  template&lt;class ExecutionPolicy, class InputIterator,
           class ForwardIterator, class BinaryPredicate&gt;
    InputIterator
      find_first_of(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                    InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2,
                    BinaryPredicate pred);

  template&lt;class ForwardIterator&gt;
    ForwardIterator adjacent_find(ForwardIterator first,
                                  ForwardIterator last);
  template&lt;class ForwardIterator, class BinaryPredicate&gt;
    ForwardIterator adjacent_find(ForwardIterator first,
                                  ForwardIterator last,
                                  BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator adjacent_find(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                  ForwardIterator first,
                                  ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class BinaryPredicate&gt;
    ForwardIterator adjacent_find(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                  ForwardIterator first,
                                  ForwardIterator last,
                                  BinaryPredicate pred);

  template&lt;class InputIterator, class T&gt;
    typename iterator_traits&lt;InputIterator&gt;::difference_type
      count(InputIterator first, InputIterator last, const T&amp; value);
  template&lt;class ExecutionPolicy, class InputIterator, class T&gt;
    typename iterator_traits&lt;InputIterator&gt;::difference_type
      count(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>            InputIterator first, InputIterator last, const T&amp; value);
  template&lt;class InputIterator, class Predicate&gt;
    typename iterator_traits&lt;InputIterator&gt;::difference_type
      count_if(InputIterator first, InputIterator last, Predicate pred);
  template&lt;class ExecutionPolicy, class InputIterator, class Predicate&gt;
    typename iterator_traits&lt;InputIterator&gt;::difference_type
      count_if(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>            InputIterator first, InputIterator last, Predicate pred);

  template&lt;class InputIterator1, class InputIterator2&gt;
    pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2);
  template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
    pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, BinaryPredicate pred);
  template&lt;class InputIterator1, class InputIterator2&gt;
    pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2);
  template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
    pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2,
               BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2&gt;
    pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>               InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class BinaryPredicate&gt;
    pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>               InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2&gt;
    pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>               InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class BinaryPredicate&gt;
    pair&lt;InputIterator1, InputIterator2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>               InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2,
               BinaryPredicate pred);

  template&lt;class InputIterator1, class InputIterator2&gt;
    bool equal(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2);
  template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
    bool equal(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, BinaryPredicate pred);
  template&lt;class InputIterator1, class InputIterator2&gt;
    bool equal(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2);
  template&lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
    bool equal(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2,
               BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>               InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class BinaryPredicate&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>               InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>               InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class BinaryPredicate&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>               InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2,
               BinaryPredicate pred);

  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                        ForwardIterator2 first2);
  template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
    bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                        ForwardIterator2 first2, BinaryPredicate pred);

  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                        ForwardIterator2 first2, ForwardIterator2 last2);

  template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
    bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                        ForwardIterator2 first2, ForwardIterator2 last2,
                        BinaryPredicate pred);

  <span class='comment'>// <a href='alg.search'>[alg.search]</a>, search
</span>  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator1 search(
      ForwardIterator1 first1, ForwardIterator1 last1,
      ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
    ForwardIterator1 search(
      ForwardIterator1 first1, ForwardIterator1 last1,
      ForwardIterator2 first2, ForwardIterator2 last2,
      BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator1 search(
      ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>      ForwardIterator1 first1, ForwardIterator1 last1,
      ForwardIterator2 first2, ForwardIterator2 last2);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate&gt;
    ForwardIterator1 search(
      ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>      ForwardIterator1 first1, ForwardIterator1 last1,
      ForwardIterator2 first2, ForwardIterator2 last2,
      BinaryPredicate pred);
  template&lt;class ForwardIterator, class Size, class T&gt;
    ForwardIterator search_n(ForwardIterator first, ForwardIterator last,
                             Size count, const T&amp; value);
  template&lt;class ForwardIterator, class Size, class T, class BinaryPredicate&gt;
    ForwardIterator search_n(ForwardIterator first, ForwardIterator last,
                             Size count, const T&amp; value,
                             BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Size, class T&gt;
    ForwardIterator search_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                             ForwardIterator first, ForwardIterator last,
                             Size count, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Size, class T,
           class BinaryPredicate&gt;
    ForwardIterator search_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                             ForwardIterator first, ForwardIterator last,
                             Size count, const T&amp; value,
                             BinaryPredicate pred);

  template &lt;class ForwardIterator, class Searcher&gt;
    ForwardIterator search(ForwardIterator first, ForwardIterator last,
                           const Searcher &amp;searcher);

  <span class='comment'>// <a href='alg.modifying.operations'>[alg.modifying.operations]</a>, modifying sequence operations
</span>  <span class='comment'>// <a href='alg.copy'>[alg.copy]</a>, copy
</span>  template&lt;class InputIterator, class OutputIterator&gt;
    OutputIterator copy(InputIterator first, InputIterator last,
                        OutputIterator result);
  template&lt;class ExecutionPolicy, class InputIterator, class OutputIterator&gt;
    OutputIterator copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                        InputIterator first, InputIterator last,
                        OutputIterator result);
  template&lt;class InputIterator, class Size, class OutputIterator&gt;
    OutputIterator copy_n(InputIterator first, Size n,
                          OutputIterator result);
  template&lt;class ExecutionPolicy, class InputIterator, class Size,
           class OutputIterator&gt;
    OutputIterator copy_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                          InputIterator first, Size n,
                          OutputIterator result);
  template&lt;class InputIterator, class OutputIterator, class Predicate&gt;
    OutputIterator copy_if(InputIterator first, InputIterator last,
                           OutputIterator result, Predicate pred);
  template&lt;class ExecutionPolicy, class InputIterator, class OutputIterator,
           class Predicate&gt;
    OutputIterator copy_if(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                           InputIterator first, InputIterator last,
                           OutputIterator result, Predicate pred);
  template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
    BidirectionalIterator2 copy_backward(
      BidirectionalIterator1 first, BidirectionalIterator1 last,
      BidirectionalIterator2 result);

  <span class='comment'>// <a href='alg.move'>[alg.move]</a>, move
</span>  template&lt;class InputIterator, class OutputIterator&gt;
    OutputIterator move(InputIterator first, InputIterator last,
                        OutputIterator result);
  template&lt;class ExecutionPolicy, class InputIterator,
           class OutputIterator&gt;
    OutputIterator move(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                        InputIterator first, InputIterator last,
                        OutputIterator result);
  template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
    BidirectionalIterator2 move_backward(
      BidirectionalIterator1 first, BidirectionalIterator1 last,
      BidirectionalIterator2 result);

  <span class='comment'>// <a href='alg.swap'>[alg.swap]</a>, swap
</span>  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
                                 ForwardIterator2 first2);
  template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
    ForwardIterator2 swap_ranges(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                 ForwardIterator1 first1, ForwardIterator1 last1,
                                 ForwardIterator2 first2);
  template&lt;class ForwardIterator1, class ForwardIterator2&gt;
    void iter_swap(ForwardIterator1 a, ForwardIterator2 b);

  template&lt;class InputIterator, class OutputIterator, class UnaryOperation&gt;
    OutputIterator transform(InputIterator first, InputIterator last,
                             OutputIterator result, UnaryOperation op);
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator,
           class BinaryOperation&gt;
    OutputIterator transform(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, OutputIterator result,
                             BinaryOperation binary_op);
  template&lt;class ExecutionPolicy, class InputIterator, class OutputIterator,
           class UnaryOperation&gt;
    OutputIterator transform(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                             InputIterator first, InputIterator last,
                             OutputIterator result, UnaryOperation op);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class OutputIterator, class BinaryOperation&gt;
    OutputIterator transform(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                             InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, OutputIterator result,
                             BinaryOperation binary_op);

  template&lt;class ForwardIterator, class T&gt;
    void replace(ForwardIterator first, ForwardIterator last,
                 const T&amp; old_value, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class ForwardIterator, class T&gt;
    void replace(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                 ForwardIterator first, ForwardIterator last,
                 const T&amp; old_value, const T&amp; new_value);
  template&lt;class ForwardIterator, class Predicate, class T&gt;
    void replace_if(ForwardIterator first, ForwardIterator last,
                    Predicate pred, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate, class T&gt;
    void replace_if(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                    ForwardIterator first, ForwardIterator last,
                    Predicate pred, const T&amp; new_value);
  template&lt;class InputIterator, class OutputIterator, class T&gt;
    OutputIterator replace_copy(InputIterator first, InputIterator last,
                                OutputIterator result,
                                const T&amp; old_value, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class InputIterator, class OutputIterator, class T&gt;
    OutputIterator replace_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                InputIterator first, InputIterator last,
                                OutputIterator result,
                                const T&amp; old_value, const T&amp; new_value);
  template&lt;class InputIterator, class OutputIterator, class Predicate, class T&gt;
    OutputIterator replace_copy_if(InputIterator first, InputIterator last,
                                   OutputIterator result,
                                   Predicate pred, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class InputIterator, class OutputIterator,
           class Predicate, class T&gt;
    OutputIterator replace_copy_if(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                   InputIterator first, InputIterator last,
                                   OutputIterator result,
                                   Predicate pred, const T&amp; new_value);

  template&lt;class ForwardIterator, class T&gt;
    void fill(ForwardIterator first, ForwardIterator last, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIterator,
           class T&gt;
    void fill(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>              ForwardIterator first, ForwardIterator last, const T&amp; value);
  template&lt;class OutputIterator, class Size, class T&gt;
    OutputIterator fill_n(OutputIterator first, Size n, const T&amp; value);
  template&lt;class ExecutionPolicy, class OutputIterator,
           class Size, class T&gt;
    OutputIterator fill_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                          OutputIterator first, Size n, const T&amp; value);

  template&lt;class ForwardIterator, class Generator&gt;
    void generate(ForwardIterator first, ForwardIterator last,
                  Generator gen);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Generator&gt;
    void generate(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                  ForwardIterator first, ForwardIterator last,
                  Generator gen);
  template&lt;class OutputIterator, class Size, class Generator&gt;
    OutputIterator generate_n(OutputIterator first, Size n, Generator gen);
  template&lt;class ExecutionPolicy, class OutputIterator, class Size, class Generator&gt;
    OutputIterator generate_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                              OutputIterator first, Size n, Generator gen);

  template&lt;class ForwardIterator, class T&gt;
    ForwardIterator remove(ForwardIterator first, ForwardIterator last,
                           const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIterator, class T&gt;
    ForwardIterator remove(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                           ForwardIterator first, ForwardIterator last,
                           const T&amp; value);
  template&lt;class ForwardIterator, class Predicate&gt;
    ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
                              Predicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate&gt;
    ForwardIterator remove_if(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                              ForwardIterator first, ForwardIterator last,
                              Predicate pred);
  template&lt;class InputIterator, class OutputIterator, class T&gt;
    OutputIterator remove_copy(InputIterator first, InputIterator last,
                               OutputIterator result, const T&amp; value);
  template&lt;class ExecutionPolicy, class InputIterator, class OutputIterator,
           class T&gt;
    OutputIterator remove_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                               InputIterator first, InputIterator last,
                               OutputIterator result, const T&amp; value);
  template&lt;class InputIterator, class OutputIterator, class Predicate&gt;
    OutputIterator remove_copy_if(InputIterator first, InputIterator last,
                                  OutputIterator result, Predicate pred);
  template&lt;class ExecutionPolicy, class InputIterator, class OutputIterator,
           class Predicate&gt;
    OutputIterator remove_copy_if(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                  InputIterator first, InputIterator last,
                                  OutputIterator result, Predicate pred);

  template&lt;class ForwardIterator&gt;
    ForwardIterator unique(ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class BinaryPredicate&gt;
    ForwardIterator unique(ForwardIterator first, ForwardIterator last,
                           BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator unique(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                           ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class BinaryPredicate&gt;
    ForwardIterator unique(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                           ForwardIterator first, ForwardIterator last,
                           BinaryPredicate pred);
  template&lt;class InputIterator, class OutputIterator&gt;
    OutputIterator unique_copy(InputIterator first, InputIterator last,
                               OutputIterator result);
  template&lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;
    OutputIterator unique_copy(InputIterator first, InputIterator last,
                               OutputIterator result, BinaryPredicate pred);
  template&lt;class ExecutionPolicy, class InputIterator, class OutputIterator&gt;
    OutputIterator unique_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                               InputIterator first, InputIterator last,
                               OutputIterator result);
  template&lt;class ExecutionPolicy, class InputIterator, class OutputIterator,
           class BinaryPredicate&gt;
    OutputIterator unique_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                               InputIterator first, InputIterator last,
                               OutputIterator result, BinaryPredicate pred);

  template&lt;class BidirectionalIterator&gt;
    void reverse(BidirectionalIterator first, BidirectionalIterator last);
  template&lt;class ExecutionPolicy, class BidirectionalIterator&gt;
    void reverse(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                 BidirectionalIterator first, BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class OutputIterator&gt;
    OutputIterator reverse_copy(BidirectionalIterator first,
                                BidirectionalIterator last,
                                OutputIterator result);
  template&lt;class ExecutionPolicy, class BidirectionalIterator, class OutputIterator&gt;
    OutputIterator reverse_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                BidirectionalIterator first,
                                BidirectionalIterator last,
                                OutputIterator result);

  template&lt;class ForwardIterator&gt;
    ForwardIterator rotate(ForwardIterator first,
                           ForwardIterator middle,
                           ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator rotate(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                           ForwardIterator first,
                           ForwardIterator middle,
                           ForwardIterator last);
  template&lt;class ForwardIterator, class OutputIterator&gt;
    OutputIterator rotate_copy(
      ForwardIterator first, ForwardIterator middle,
      ForwardIterator last, OutputIterator result);
  template&lt;class ExecutionPolicy, class ForwardIterator, class OutputIterator&gt;
    OutputIterator rotate_copy(
      ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>      ForwardIterator first, ForwardIterator middle,
      ForwardIterator last, OutputIterator result);

  <span class='comment'>// <a href='alg.random.sample'>[alg.random.sample]</a>, sample
</span>  template&lt;class PopulationIterator, class SampleIterator,
           class Distance, class UniformRandomBitGenerator&gt;
    SampleIterator sample(PopulationIterator first, PopulationIterator last,
                          SampleIterator out, Distance n,
                          UniformRandomBitGenerator&amp;&amp; g);

  <span class='comment'>// <a href='alg.random.shuffle'>[alg.random.shuffle]</a>, shuffle
</span>  template&lt;class RandomAccessIterator, class UniformRandomBitGenerator&gt;
    void shuffle(RandomAccessIterator first,
                 RandomAccessIterator last,
                 UniformRandomBitGenerator&amp;&amp; g);

  <span class='comment'>// <a href='alg.partitions'>[alg.partitions]</a>, partitions
</span>  template &lt;class InputIterator, class Predicate&gt;
    bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
  template &lt;class ExecutionPolicy, class InputIterator, class Predicate&gt;
    bool is_partitioned(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                        InputIterator first, InputIterator last, Predicate pred);

  template&lt;class ForwardIterator, class Predicate&gt;
    ForwardIterator partition(ForwardIterator first,
                              ForwardIterator last,
                              Predicate pred);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Predicate&gt;
    ForwardIterator partition(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                              ForwardIterator first,
                              ForwardIterator last,
                              Predicate pred);
  template&lt;class BidirectionalIterator, class Predicate&gt;
    BidirectionalIterator stable_partition(BidirectionalIterator first,
                                           BidirectionalIterator last,
                                           Predicate pred);
  template&lt;class ExecutionPolicy, class BidirectionalIterator, class Predicate&gt;
    BidirectionalIterator stable_partition(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                           BidirectionalIterator first,
                                           BidirectionalIterator last,
                                           Predicate pred);
  template &lt;class InputIterator, class OutputIterator1,
            class OutputIterator2, class Predicate&gt;
    pair&lt;OutputIterator1, OutputIterator2&gt;
    partition_copy(InputIterator first, InputIterator last,
                   OutputIterator1 out_true, OutputIterator2 out_false,
                   Predicate pred);
  template &lt;class ExecutionPolicy, class InputIterator, class OutputIterator1,
            class OutputIterator2, class Predicate&gt;
    pair&lt;OutputIterator1, OutputIterator2&gt;
    partition_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                   InputIterator first, InputIterator last,
                   OutputIterator1 out_true, OutputIterator2 out_false,
                   Predicate pred);
  template&lt;class ForwardIterator, class Predicate&gt;
    ForwardIterator partition_point(ForwardIterator first,
                                    ForwardIterator last,
                                    Predicate pred);

  <span class='comment'>// <a href='alg.sorting'>[alg.sorting]</a>, sorting and related operations
</span>  <span class='comment'>// <a href='alg.sort'>[alg.sort]</a>, sorting
</span>  template&lt;class RandomAccessIterator&gt;
    void sort(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void sort(RandomAccessIterator first, RandomAccessIterator last,
              Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    void sort(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>              RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    void sort(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>              RandomAccessIterator first, RandomAccessIterator last,
              Compare comp);

  template&lt;class RandomAccessIterator&gt;
    void stable_sort(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void stable_sort(RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    void stable_sort(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                     RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    void stable_sort(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                     RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);

  template&lt;class RandomAccessIterator&gt;
    void partial_sort(RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void partial_sort(RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last, Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    void partial_sort(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                      RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    void partial_sort(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                      RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last, Compare comp);
  template&lt;class InputIterator, class RandomAccessIterator&gt;
    RandomAccessIterator partial_sort_copy(
      InputIterator first, InputIterator last,
      RandomAccessIterator result_first,
      RandomAccessIterator result_last);
  template&lt;class InputIterator, class RandomAccessIterator, class Compare&gt;
    RandomAccessIterator partial_sort_copy(
      InputIterator first, InputIterator last,
      RandomAccessIterator result_first,
      RandomAccessIterator result_last,
      Compare comp);
  template&lt;class ExecutionPolicy, class InputIterator, class RandomAccessIterator&gt;
    RandomAccessIterator partial_sort_copy(
      ExecutionPolicy&amp;&amp; exec,  <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>      InputIterator first, InputIterator last,
      RandomAccessIterator result_first,
      RandomAccessIterator result_last);
  template&lt;class ExecutionPolicy, class InputIterator, class RandomAccessIterator, class Compare&gt;
    RandomAccessIterator partial_sort_copy(
      ExecutionPolicy&amp;&amp; exec,  <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>      InputIterator first, InputIterator last,
      RandomAccessIterator result_first,
      RandomAccessIterator result_last,
      Compare comp);
  template&lt;class ForwardIterator&gt;
    bool is_sorted(ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class Compare&gt;
    bool is_sorted(ForwardIterator first, ForwardIterator last,
                   Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    bool is_sorted(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                   ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    bool is_sorted(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                   ForwardIterator first, ForwardIterator last,
                   Compare comp);
  template&lt;class ForwardIterator&gt;
    ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class Compare&gt;
    ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last,
                                    Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator is_sorted_until(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                    ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    ForwardIterator is_sorted_until(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                    ForwardIterator first, ForwardIterator last,
                                    Compare comp);

  template&lt;class RandomAccessIterator&gt;
    void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last, Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    void nth_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    void nth_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last, Compare comp);

  <span class='comment'>// <a href='alg.binary.search'>[alg.binary.search]</a>, binary search
</span>  template&lt;class ForwardIterator, class T&gt;
    ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,
                                const T&amp; value);
  template&lt;class ForwardIterator, class T, class Compare&gt;
    ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,
                                const T&amp; value, Compare comp);

  template&lt;class ForwardIterator, class T&gt;
    ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,
                                const T&amp; value);
  template&lt;class ForwardIterator, class T, class Compare&gt;
    ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,
                                const T&amp; value, Compare comp);

  template&lt;class ForwardIterator, class T&gt;
    pair&lt;ForwardIterator, ForwardIterator&gt;
      equal_range(ForwardIterator first, ForwardIterator last,
                  const T&amp; value);
  template&lt;class ForwardIterator, class T, class Compare&gt;
    pair&lt;ForwardIterator, ForwardIterator&gt;
      equal_range(ForwardIterator first, ForwardIterator last,
                  const T&amp; value, Compare comp);

  template&lt;class ForwardIterator, class T&gt;
    bool binary_search(ForwardIterator first, ForwardIterator last,
                       const T&amp; value);
  template&lt;class ForwardIterator, class T, class Compare&gt;
    bool binary_search(ForwardIterator first, ForwardIterator last,
                       const T&amp; value, Compare comp);

  <span class='comment'>// <a href='alg.merge'>[alg.merge]</a>, merge
</span>  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result);
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator,
           class Compare&gt;
    OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result, Compare comp);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class OutputIterator&gt;
    OutputIterator merge(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                         InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class OutputIterator, class Compare&gt;
    OutputIterator merge(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                         InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result, Compare comp);

  template&lt;class BidirectionalIterator&gt;
    void inplace_merge(BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class Compare&gt;
    void inplace_merge(BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last, Compare comp);
  template&lt;class ExecutionPolicy, class BidirectionalIterator&gt;
    void inplace_merge(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last);
  template&lt;class ExecutionPolicy, class BidirectionalIterator, class Compare&gt;
    void inplace_merge(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last, Compare comp);

  <span class='comment'>// <a href='alg.set.operations'>[alg.set.operations]</a>, set operations
</span>  template&lt;class InputIterator1, class InputIterator2&gt;
    bool includes(InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2, InputIterator2 last2);
  template&lt;class InputIterator1, class InputIterator2, class Compare&gt;
    bool includes(InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2, InputIterator2 last2, Compare comp);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2&gt;
    bool includes(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                  InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2, InputIterator2 last2);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2, class Compare&gt;
    bool includes(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                  InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2, InputIterator2 last2, Compare comp);

  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2,
                             OutputIterator result);
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
    OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2,
                             OutputIterator result, Compare comp);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class OutputIterator&gt;
    OutputIterator set_union(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                             InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2,
                             OutputIterator result);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class OutputIterator, class Compare&gt;
    OutputIterator set_union(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                             InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2,
                             OutputIterator result, Compare comp);

  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    OutputIterator set_intersection(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result);
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
    OutputIterator set_intersection(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result, Compare comp);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class OutputIterator&gt;
    OutputIterator set_intersection(
      ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class OutputIterator, class Compare&gt;
    OutputIterator set_intersection(
      ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result, Compare comp);

  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    OutputIterator set_difference(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result);
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
    OutputIterator set_difference(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result, Compare comp);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class OutputIterator&gt;
    OutputIterator set_difference(
      ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class OutputIterator, class Compare&gt;
    OutputIterator set_difference(
      ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result, Compare comp);

  template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
    OutputIterator set_symmetric_difference(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result);
  template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
    OutputIterator set_symmetric_difference(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result, Compare comp);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class OutputIterator&gt;
    OutputIterator set_symmetric_difference(
      ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2,
           class OutputIterator, class Compare&gt;
    OutputIterator set_symmetric_difference(
      ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      OutputIterator result, Compare comp);

  <span class='comment'>// <a href='alg.heap.operations'>[alg.heap.operations]</a>, heap operations
</span>  template&lt;class RandomAccessIterator&gt;
    void push_heap(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void push_heap(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);

  template&lt;class RandomAccessIterator&gt;
    void pop_heap(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
                  Compare comp);

  template&lt;class RandomAccessIterator&gt;
    void make_heap(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void make_heap(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);

  template&lt;class RandomAccessIterator&gt;
    void sort_heap(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);

  template&lt;class RandomAccessIterator&gt;
    bool is_heap(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    bool is_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    bool is_heap(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                 RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    bool is_heap(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                 RandomAccessIterator first, RandomAccessIterator last, Compare comp);
  template&lt;class RandomAccessIterator&gt;
    RandomAccessIterator is_heap_until(RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class RandomAccessIterator, class Compare&gt;
    RandomAccessIterator is_heap_until(RandomAccessIterator first, RandomAccessIterator last,
                                       Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
    RandomAccessIterator is_heap_until(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                       RandomAccessIterator first, RandomAccessIterator last);
  template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
    RandomAccessIterator is_heap_until(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                       RandomAccessIterator first, RandomAccessIterator last,
                                       Compare comp);

  <span class='comment'>// <a href='alg.min.max'>[alg.min.max]</a>, minimum and maximum
</span>  template&lt;class T&gt; constexpr const T&amp; min(const T&amp; a, const T&amp; b);
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
  template&lt;class T&gt;
    constexpr T min(initializer_list&lt;T&gt; t);
  template&lt;class T, class Compare&gt;
    constexpr T min(initializer_list&lt;T&gt; t, Compare comp);

  template&lt;class T&gt; constexpr const T&amp; max(const T&amp; a, const T&amp; b);
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
  template&lt;class T&gt;
    constexpr T max(initializer_list&lt;T&gt; t);
  template&lt;class T, class Compare&gt;
    constexpr T max(initializer_list&lt;T&gt; t, Compare comp);

  template&lt;class T&gt; constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b);
  template&lt;class T, class Compare&gt;
    constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
  template&lt;class T&gt;
    constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t);
  template&lt;class T, class Compare&gt;
    constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t, Compare comp);

  template&lt;class ForwardIterator&gt;
    constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class Compare&gt;
    constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
                                          Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator min_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    ForwardIterator min_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                ForwardIterator first, ForwardIterator last,
                                Compare comp);
  template&lt;class ForwardIterator&gt;
    constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class Compare&gt;
    constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
                                          Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    ForwardIterator max_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    ForwardIterator max_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                ForwardIterator first, ForwardIterator last,
                                Compare comp);
  template&lt;class ForwardIterator&gt;
    constexpr pair&lt;ForwardIterator, ForwardIterator&gt;
      minmax_element(ForwardIterator first, ForwardIterator last);
  template&lt;class ForwardIterator, class Compare&gt;
    constexpr pair&lt;ForwardIterator, ForwardIterator&gt;
      minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIterator&gt;
    pair&lt;ForwardIterator, ForwardIterator&gt;
      minmax_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                     ForwardIterator first, ForwardIterator last);
  template&lt;class ExecutionPolicy, class ForwardIterator, class Compare&gt;
    pair&lt;ForwardIterator, ForwardIterator&gt;
      minmax_element(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                     ForwardIterator first, ForwardIterator last, Compare comp);

  <span class='comment'>// <a href='alg.clamp'>[alg.clamp]</a>, bounded value
</span>  template&lt;class T&gt;
    constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi);
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi, Compare comp);

  <span class='comment'>// <a href='alg.lex.comparison'>[alg.lex.comparison]</a>, lexicographical comparison
</span>  template&lt;class InputIterator1, class InputIterator2&gt;
    bool lexicographical_compare(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2);
  template&lt;class InputIterator1, class InputIterator2, class Compare&gt;
    bool lexicographical_compare(
      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      Compare comp);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2&gt;
    bool lexicographical_compare(
      ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2);
  template&lt;class ExecutionPolicy, class InputIterator1, class InputIterator2, class Compare&gt;
    bool lexicographical_compare(
      ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>      InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2,
      Compare comp);

  <span class='comment'>// <a href='alg.permutation.generators'>[alg.permutation.generators]</a>, permutations
</span>  template&lt;class BidirectionalIterator&gt;
    bool next_permutation(BidirectionalIterator first,
                          BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class Compare&gt;
    bool next_permutation(BidirectionalIterator first,
                          BidirectionalIterator last, Compare comp);
  template&lt;class BidirectionalIterator&gt;
    bool prev_permutation(BidirectionalIterator first,
                          BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class Compare&gt;
    bool prev_permutation(BidirectionalIterator first,
                          BidirectionalIterator last, Compare comp);
}
</pre></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >All of the algorithms are separated from the particular implementations of data structures and are
parameterized by iterator types.
Because of this, they can work with program-defined data structures, as long
as these data structures have iterator types satisfying the assumptions on the algorithms.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >For purposes of determining the existence of data races, algorithms shall
not modify objects referenced through an iterator argument unless the
specification requires such modification.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >Throughout this Clause, the names of template parameters
are used to express type requirements.
</p><ul class='itemize'><li id='5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.1'>(5.1)</a></div><p >If an algorithm's template parameter is named
<span class='texttt'>InputIterator</span>,
<span class='texttt'>InputIterator1</span>,
or
<span class='texttt'>InputIterator2</span>,
the template argument shall satisfy the
requirements of an input iterator (<a href='input.iterators'>[input.iterators]</a>).
</p></li><li id='5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.2'>(5.2)</a></div><p >If an algorithm's template parameter is named
<span class='texttt'>OutputIterator</span>,
<span class='texttt'>OutputIterator1</span>,
or
<span class='texttt'>OutputIterator2</span>,
the template argument shall satisfy the requirements
of an output iterator (<a href='output.iterators'>[output.iterators]</a>).
</p></li><li id='5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.3'>(5.3)</a></div><p >If an algorithm's template parameter is named
<span class='texttt'>ForwardIterator</span>,
<span class='texttt'>ForwardIterator1</span>,
or
<span class='texttt'>ForwardIterator2</span>,
the template argument shall satisfy the requirements
of a forward iterator (<a href='forward.iterators'>[forward.iterators]</a>).
</p></li><li id='5.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.4'>(5.4)</a></div><p >If an algorithm's template parameter is named
<span class='texttt'>BidirectionalIterator</span>,
<span class='texttt'>BidirectionalIterator1</span>,
or
<span class='texttt'>BidirectionalIterator2</span>,
the template argument shall satisfy the requirements
of a bidirectional iterator (<a href='bidirectional.iterators'>[bidirectional.iterators]</a>).
</p></li><li id='5.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.5'>(5.5)</a></div><p >If an algorithm's template parameter is named
<span class='texttt'>RandomAccessIterator</span>,
<span class='texttt'>RandomAccessIterator1</span>,
or
<span class='texttt'>RandomAccessIterator2</span>,
the template argument shall satisfy the requirements
of a random-access iterator (<a href='random.access.iterators'>[random.access.iterators]</a>).
</p></li></ul></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >If an algorithm's
<i>Effects:</i>
section says that a value pointed to by any iterator passed
as an argument is modified, then that algorithm has an additional
type requirement:
The type of that argument shall satisfy the requirements
of a mutable iterator (<a href='iterator.requirements'>[iterator.requirements]</a>).
[&nbsp;<i>Note:</i>
This requirement does not affect arguments that are named
<span class='texttt'>OutputIterator</span>,
<span class='texttt'>OutputIterator1</span>,
or
<span class='texttt'>OutputIterator2</span>,
because output iterators must always be mutable.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >Both in-place and copying versions are provided for certain
algorithms.<a class='footnotenum' href='#footnote-263'>263</a>
When such a version is provided for <i>algorithm</i> it is called
<i>algorithm<span class='texttt'>_copy</span></i>. Algorithms that take predicates end with the
suffix <span class='texttt'>_if</span> (which follows the suffix <span class='texttt'>_copy</span>).</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >The
<span class='texttt'>Predicate</span>
parameter is used whenever an algorithm expects a function object (<a href='function.objects'>[function.objects]</a>)
that, when applied to the result
of dereferencing the corresponding iterator, returns a value testable as
<span class='texttt'>true</span>.
In other words, if an algorithm
takes
<span class='texttt'>Predicate pred</span>
as its argument and <span class='texttt'>first</span>
as its iterator argument, it should work correctly in the
construct
<span class='texttt'>pred(*first)</span> contextually converted to <span class='texttt'>bool</span> (Clause <a href='conv'>[conv]</a>).
The function object
<span class='texttt'>pred</span>
shall not apply any non-constant
function through the dereferenced iterator.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >The
<span class='texttt'>BinaryPredicate</span>
parameter is used whenever an algorithm expects a function object that when applied to
the result of dereferencing two corresponding iterators or to dereferencing an
iterator and type
<span class='texttt'>T</span>
when
<span class='texttt'>T</span>
is part of the signature returns a value testable as
<span class='texttt'>true</span>.
In other words, if an algorithm takes
<span class='texttt'>BinaryPredicate binary_pred</span>
as its argument and <span class='texttt'>first1</span> and <span class='texttt'>first2</span> as
its iterator arguments, it should work correctly in
the construct
<span class='texttt'>binary_pred(*first1, *first2)</span> contextually converted to <span class='texttt'>bool</span> (Clause <a href='conv'>[conv]</a>).
<span class='texttt'>BinaryPredicate</span>
always takes the first
iterator's <span class='texttt'>value_type</span>
as its first argument, that is, in those cases when
<span class='texttt'>T value</span>
is part of the signature, it should work
correctly in the
construct <span class='texttt'>binary_pred(*first1, value)</span> contextually converted to <span class='texttt'>bool</span> (Clause <a href='conv'>[conv]</a>).
<span class='texttt'>binary_pred</span> shall not
apply any non-constant function through the dereferenced iterators.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >[&nbsp;<i>Note:</i>
Unless otherwise specified, algorithms that take function objects as arguments
are permitted to copy those function objects freely. Programmers for whom object
identity is important should consider using a wrapper class that points to a
noncopied implementation object such as <span class='texttt'>reference_wrapper&lt;T&gt;</span> (<a href='refwrap'>[refwrap]</a>), or some equivalent solution.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >When the description of an algorithm gives an expression such as
<span class='texttt'>*first == value</span>
for a condition, the expression shall evaluate to
either <span class='texttt'>true</span> or <span class='texttt'>false</span> in boolean contexts.</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >In the description of the algorithms operators
<span class='texttt'>+</span>
and
<span class='texttt'>-</span>
are used for some of the iterator categories for which
they do not have to be defined.
In these cases the semantics of
<span class='texttt'>a+n</span>
is the same as that of</p><pre class='codeblock'>
X tmp = a;
advance(tmp, n);
return tmp;
</pre><p >and that of
<span class='texttt'>b-a</span>
is the same as of</p><pre class='codeblock'>
return distance(a, b);
</pre></div><div class='footnote' id='footnote-263'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-263'>263)</a></div><p >The decision whether to include a copying version was
usually based on complexity considerations. When the cost of doing the operation
dominates the cost of copy, the copying version is not included. For example,
<span class='texttt'>sort_copy</span> is not included because the cost of sorting is much more
significant, and users might as well do <span class='texttt'>copy</span> followed by <span class='texttt'>sort</span>.</p></div></div></div></body></html>