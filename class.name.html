<!DOCTYPE html><html lang='en'><head><title>[class.name]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>12</a> Classes <a class='abbr_ref' href='./#class'>[class]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>12.1</a> Class names <a class='abbr_ref'>[class.name]</a></h2><p ><span class='indexparent'><a class='index' id=':definition,class_name_as_type'></a></span><span class='indexparent'><a class='index' id=':equivalence,type'></a></span>
</p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/classes.tex#L286'>#</a></div><p >A class definition introduces a new type.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><pre class='codeblock'>
struct X { int a; };
struct Y { int a; };
X a1;
Y a2;
int a3;</pre><p >declares three variables of three different types. This implies that</p><pre class='codeblock'>
a1 = a2;                        <span class='comment'>// error: <span class='tcode_in_codeblock'>Y</span> assigned to <span class='tcode_in_codeblock'>X</span>
</span>a1 = a3;                        <span class='comment'>// error: <span class='tcode_in_codeblock'>int</span> assigned to <span class='tcode_in_codeblock'>X</span>
</span></pre><p >are type mismatches, and that</p><pre class='codeblock'>
int f(X);
int f(Y);</pre><p ><span class='indexparent'><a class='index' id=':overloading'></a></span>declare an <a href='over'>overloaded</a> function <span class='texttt'>f()</span> and not
simply a single function <span class='texttt'>f()</span> twice. For the same reason,</p><pre class='codeblock'>
struct S { int a; };
struct S { int a; };            <span class='comment'>// error, double definition
</span></pre><p >is ill-formed because it defines <span class='texttt'>S</span> twice.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/classes.tex#L324'>#</a></div><p ><span class='indexparent'><a class='index' id=':definition,scope_of_class'></a></span><span class='indexparent'><a class='index' id=':class_name,scope_of'></a></span>A class declaration introduces the class name into the scope where
<span class='indexparent'><a class='index' id=':name_hiding,class_definition'></a></span>it is declared and hides any
class, variable, function, or other declaration of that name in an
enclosing <a href='basic.scope'>scope</a>. If a class name is declared in a
scope where a variable, function, or enumerator of the same name is also
declared, then when both declarations are in scope, the class can be
referred to only using an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> (<a href='basic.lookup.elab'>[basic.lookup.elab]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
struct stat {
  <span class='comment'>// ...
</span>};

stat gstat;                     <span class='comment'>// use plain <span class='tcode_in_codeblock'>stat</span> to define variable
</span>
int stat(struct stat*);         <span class='comment'>// redeclare <span class='tcode_in_codeblock'>stat</span> as function
</span>
void f() {
  struct stat* ps;              <span class='comment'>// <span class='tcode_in_codeblock'>struct</span> prefix needed to name <span class='tcode_in_codeblock'>struct stat</span>
</span>  stat(ps);                     <span class='comment'>// call <span class='tcode_in_codeblock'>stat()</span>
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] 
<span class='indexparent'><a class='index' id=':class_name,elaborated'></a></span><span class='indexparent'><a class='index' id=':declaration,forward_class'></a></span>A <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> consisting solely of <i ><a href='class#nt:class-key'>class-key</a></i>
<i ><a href='lex.name#nt:identifier'>identifier</a></i><span class='texttt'>;</span> is either a redeclaration of the name in the current scope
or a forward declaration of the identifier as a class name. It
introduces the class name into the current scope.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
struct s { int a; };

void g() {
  struct s;                     <span class='comment'>// hide global <span class='tcode_in_codeblock'>struct s</span> with a block-scope declaration
</span>  s* p;                         <span class='comment'>// refer to local <span class='tcode_in_codeblock'>struct s</span>
</span>  struct s { char* p; };        <span class='comment'>// define local <span class='tcode_in_codeblock'>struct s</span>
</span>  struct s;                     <span class='comment'>// redeclaration, has no effect
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] 
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
Such declarations allow definition of classes that refer to each other.
<span class='indexparent'><a class='index' id=':example,friend'></a></span>[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
class Vector;

class Matrix {
  <span class='comment'>// ...
</span>  friend Vector operator*(const Matrix&amp;, const Vector&amp;);
};

class Vector {
  <span class='comment'>// ...
</span>  friend Vector operator*(const Matrix&amp;, const Vector&amp;);
};</pre><p >Declaration of <span class='texttt'>friend</span>s is described in <a href='class.friend'>[class.friend]</a>,
operator functions in <a href='over.oper'>[over.oper]</a>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] 
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/classes.tex#L392'>#</a></div><p ><span class='indexparent'><a class='index' id=':class_name,elaborated_'></a></span>[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
An <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> can also
be used as a <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> as part of a declaration. It
differs from a class declaration in that if a class of the elaborated
name is in scope the elaborated name will refer to it.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><pre class='codeblock'>
struct s { int a; };

void g(int s) {
  struct s* p = new struct s;   <span class='comment'>// global <span class='tcode_in_codeblock'>s</span>
</span>  p-&gt;a = s;                     <span class='comment'>// parameter <span class='tcode_in_codeblock'>s</span>
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/classes.tex#L413'>#</a></div><p ><span class='indexparent'><a class='index' id=':class_name,point_of_declaration'></a></span>[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
The declaration of a class name takes effect immediately after the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> is seen in the class definition or
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>. For example,</p><pre class='codeblock'>
class A * A;</pre><p >first specifies <span class='texttt'>A</span> to be the name of a class and then redefines
it as the name of a pointer to an object of that class. This means that
the elaborated form <span class='texttt'>class</span> <span class='texttt'>A</span> must be used to refer to the
class. Such artistry with names can be confusing and is best avoided.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/classes.tex#L430'>#</a></div><p ><span class='indexparent'><a class='index' id=':class_name,typedef'></a></span>A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> that names a class type,
or a cv-qualified version thereof, is also a <i ><a href='class#nt:class-name'>class-name</a></i>. If a
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> that names a cv-qualified class type is used
where a <i ><a href='class#nt:class-name'>class-name</a></i> is required, the cv-qualifiers are
ignored. A <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> shall not be used as the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> in a <i ><a href='class#nt:class-head'>class-head</a></i>.</p></div></div></body></html>