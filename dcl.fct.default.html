<!DOCTYPE html><html lang='en'><head><title>[dcl.fct.default]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Declarators <a class='abbr_ref' href='./#dcl.decl'>[dcl.decl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>8.3</a> Meaning of declarators <a class='abbr_ref' href='dcl.meaning#dcl.fct.default'>[dcl.meaning]</a></h2><div id='dcl.fct.default'><h3 ><a class='secnum' style='min-width:103pt'>8.3.6</a> Default arguments <a class='abbr_ref'>[dcl.fct.default]</a></h3><p ><span class='indexparent'><a class='index' id='declaration!default argument'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >If an <i ><a href='dcl.init#initializer-clause'>initializer-clause</a></i> is specified in a
<i ><a href='dcl.fct#parameter-declaration'>parameter-declaration</a></i> this
<i ><a href='dcl.init#initializer-clause'>initializer-clause</a></i>
is used as a default argument.
Default arguments will be used in calls where trailing arguments are missing.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='argument!example~of default'></a></span>[&nbsp;<i>Example:</i><span class='space'></span>
the declaration</p><pre class='codeblock'>
void point(int = 3, int = 4);
</pre><p >declares a function that can be called with zero, one, or two arguments of type
<span class='texttt'>int</span>.
It can be called in any of these ways:</p><pre class='codeblock'>
point(1,2);  point(1);  point();
</pre><p >The last two calls are equivalent to
<span class='texttt'>point(1,4)</span>
and
<span class='texttt'>point(3,4)</span>,
respectively.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A default argument shall be specified only in the
<i ><a href='dcl.fct#parameter-declaration-clause'>parameter-declaration-clause</a></i>
of a function declaration
or <i ><a href='expr.prim.lambda#lambda-declarator'>lambda-declarator</a></i>
or in a
<i ><a href='temp.param#template-parameter'>template-parameter</a></i>
(<a href='temp.param'>[temp.param]</a>);
in the latter case, the <i ><a href='dcl.init#initializer-clause'>initializer-clause</a></i> shall be an
<i ><a href='expr.ass#assignment-expression'>assignment-expression</a></i>.
A default argument shall not be specified for a parameter pack.
If it is specified in a
<i ><a href='dcl.fct#parameter-declaration-clause'>parameter-declaration-clause</a></i>,
it shall not occur within a
<i ><a href='dcl.decl#declarator'>declarator</a></i>
or
<i ><a href='dcl.name#abstract-declarator'>abstract-declarator</a></i>
of a
<i ><a href='dcl.fct#parameter-declaration'>parameter-declaration</a></i>.<a class='footnotenum' href='#footnote-101'>101</a></p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >For non-template functions, default arguments can be added in later
declarations of a
function in the same scope.
Declarations in different
scopes have completely distinct sets of default arguments.
That
is, declarations in inner scopes do not acquire default
arguments from declarations in outer scopes, and vice versa.
In
a given function declaration, each parameter subsequent to a
parameter with a default argument shall have a default argument
supplied in this or a previous declaration
or shall be a function parameter pack.
A default argument
shall not be redefined by a later declaration (not even to the
same value).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
void g(int = 0, ...);           <span class='comment'>// OK, ellipsis is not a parameter so it can follow
</span>                                <span class='comment'>// a parameter with a default argument
</span>void f(int, int);
void f(int, int = 7);
void h() {
  f(3);                         <span class='comment'>// OK, calls <span class='texttt'>f(3, 7)</span>
</span>  void f(int = 1, int);         <span class='comment'>// error: does not use default
</span>                                <span class='comment'>// from surrounding scope
</span>}
void m() {
  void f(int, int);             <span class='comment'>// has no defaults
</span>  f(4);                         <span class='comment'>// error: wrong number of arguments
</span>  void f(int, int = 5);         <span class='comment'>// OK
</span>  f(4);                         <span class='comment'>// OK, calls <span class='texttt'>f(4, 5);</span>
</span>  void f(int, int = 5);         <span class='comment'>// error: cannot redefine, even to
</span>                                <span class='comment'>// same value
</span>}
void n() {
  f(6);                         <span class='comment'>// OK, calls <span class='texttt'>f(6, 7)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
For a given inline function defined in different translation units,
the accumulated sets of default arguments at the end of the
translation units shall be the same;
see <a href='basic.def.odr'>[basic.def.odr]</a>.
If a friend declaration specifies a default argument expression,
that declaration shall be a definition and shall be the only
declaration of the function or function template in the translation unit.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='argument!type~checking~of default'></a></span><span class='indexparent'><a class='index' id='argument!binding~of default'></a></span><span class='indexparent'><a class='index' id='argument!evaluation~of default'></a></span>The default argument has the
same semantic constraints as the initializer in a
declaration of a variable of the parameter type, using the
copy-initialization semantics (<a href='dcl.init'>[dcl.init]</a>).
The names in the
default argument are bound, and the semantic constraints are checked,
at the point where the default argument appears.
Name lookup and checking of semantic constraints for default
arguments in function templates and in member functions of
class templates are performed as described in <a href='temp.inst'>[temp.inst]</a>.
[&nbsp;<i>Example:</i><span class='space'></span>
in the following code,
<span class='indexparent'><a class='index' id='argument!example~of default'></a></span><span class='texttt'>g</span>
will be called with the value
<span class='texttt'>f(2)</span>:</p><pre class='codeblock'>
int a = 1;
int f(int);
int g(int x = f(a));            <span class='comment'>// default argument: <span class='texttt'>f(::a)</span>
</span>
void h() {
  a = 2;
  {
  int a = 3;
  g();                          <span class='comment'>// <span class='texttt'>g(f(::a))</span>
</span>  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
In member function declarations,
names in default arguments are looked up
as described in <a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>.
Access checking applies to names in default arguments as
described in Clause <a href='class.access'>[class.access]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >Except for member functions of class templates, the
default arguments in a member function definition that appears
outside of the class definition
are added to the set of default arguments provided by the
member function declaration in the class definition;
the program is ill-formed if a default constructor (<a href='class.ctor'>[class.ctor]</a>),
copy or move constructor, or copy or move assignment operator (<a href='class.copy'>[class.copy]</a>)
is so declared.
Default arguments for a member function of a class template
shall be specified on the initial declaration of the member
function within the class template.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class C {
  void f(int i = 3);
  void g(int i, int j = 99);
};

void C::f(int i = 3) {          <span class='comment'>// error: default argument already
</span>}                               <span class='comment'>// specified in class scope
</span>void C::g(int i = 88, int j) {  <span class='comment'>// in this translation unit,
</span>}                               <span class='comment'>// <span class='texttt'>C::g</span> can be called with no argument
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >A local variable shall not appear as a potentially-evaluated expression
in a default argument.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
void f() {
  int i;
  extern void g(int x = i);          <span class='comment'>// error
</span>  extern void h(int x = sizeof(i));  <span class='comment'>// OK
</span>  <span class='comment'>// ...
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
The keyword
<span class='texttt'>this</span>
may not appear in a default argument of a member function;
see <a href='expr.prim.this'>[expr.prim.this]</a>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class A {
  void f(A* p = this) { }       <span class='comment'>// error
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p ><span class='indexparent'><a class='index' id='argument!evaluation~of default'></a></span>A default argument is evaluated each time the function is called
with no argument for the corresponding parameter.
<span class='indexparent'><a class='index' id='argument!scope~of default'></a></span>A parameter shall not appear as a potentially-evaluated expression
in a default argument.
<span class='indexparent'><a class='index' id='argument~and~name~hiding!default'></a></span>Parameters of a function declared before a default argument
are in scope and can hide namespace and class member names.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int a;
int f(int a, int b = a);            <span class='comment'>// error: parameter <span class='texttt'>a</span>
</span>                                    <span class='comment'>// used as default argument
</span>typedef int I;
int g(float I, int b = I(2));       <span class='comment'>// error: parameter <span class='texttt'>I</span> found
</span>int h(int a, int b = sizeof(a));    <span class='comment'>// OK, unevaluated operand
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
A non-static member shall not appear in a default argument unless it appears as
the <i ><a href='expr.prim.id#id-expression'>id-expression</a></i> of a class member access expression (<a href='expr.ref'>[expr.ref]</a>) or
unless it is used to form a pointer to member (<a href='expr.unary.op'>[expr.unary.op]</a>).
[&nbsp;<i>Example:</i><span class='space'></span>
the declaration of
<span class='texttt'>X::mem1()</span>
in the following example is ill-formed because no object is supplied for the
non-static member
<span class='texttt'>X::a</span>
used as an initializer.</p><pre class='codeblock'>
int b;
class X {
  int a;
  int mem1(int i = a);          <span class='comment'>// error: non-static member <span class='texttt'>a</span>
</span>                                <span class='comment'>// used as default argument
</span>  int mem2(int i = b);          <span class='comment'>// OK;  use <span class='texttt'>X::b</span>
</span>  static int b;
};
</pre><p >The declaration of
<span class='texttt'>X::mem2()</span>
is meaningful, however, since no object is needed to access the static member
<span class='texttt'>X::b</span>.
Classes, objects, and members are described in Clause <a href='class'>[class]</a>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
A default argument is not part of the
type of a function.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int f(int = 0);

void h() {
  int j = f(1);
  int k = f();                  <span class='comment'>// OK, means <span class='texttt'>f(0)</span>
</span>}

int (*p1)(int) = &amp;f;
int (*p2)() = &amp;f;               <span class='comment'>// error: type mismatch
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
When a declaration of a function is introduced by way of a
<i ><a href='namespace.udecl#using-declaration'>using-declaration</a></i>
(<a href='namespace.udecl'>[namespace.udecl]</a>), any default argument information associated
with the declaration is made known as well.
If the function is redeclared
thereafter in the namespace with additional default arguments,
the additional arguments are also known at any point following
the redeclaration where the
<i ><a href='namespace.udecl#using-declaration'>using-declaration</a></i>
is in scope.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p ><span class='indexparent'><a class='index' id='argument~and~virtual~function!default'></a></span>A virtual function call (<a href='class.virtual'>[class.virtual]</a>) uses the default
arguments in the declaration of the virtual function determined
by the static type of the pointer or reference denoting the
object.
An overriding function in a derived class does not
acquire default arguments from the function it overrides.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A {
  virtual void f(int a = 7);
};
struct B : public A {
  void f(int a);
};
void m() {
  B* pb = new B;
  A* pa = pb;
  pa-&gt;f();          <span class='comment'>// OK, calls <span class='texttt'>pa-&gt;B::f(7)</span>
</span>  pb-&gt;f();          <span class='comment'>// error: wrong number of arguments for <span class='texttt'>B::f()</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='declaration!default argument'></a></span><span class='indexparent'><a class='index' id='declarator!meaning~of'></a></span></p></div><div class='footnote' id='footnote-101'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-101'>101)</a></div><p >This means that default
arguments cannot appear,
for example, in declarations of pointers to functions,
references to functions, or
<span class='texttt'>typedef</span>
declarations.
</p></div></div></div></body></html>