<!DOCTYPE html><html lang='en'><head><title>[class.conv.fct]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>12</a> Special member functions <a class='abbr_ref' href='./#special'>[special]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>12.3</a> Conversions <a class='abbr_ref' href='class.conv#fct'>[class.conv]</a></h2><div id='class.conv.fct'><h3 ><a class='secnum' style='min-width:103pt'>12.3.2</a> Conversion functions <a class='abbr_ref'>[class.conv.fct]</a></h3><p ><span class='indexparent'><a class='index' id='function,conversion'></a></span><span class='indexparent'><a class='index' id='fundamental_type_conversion'></a></span><span class='indexparent'><a class='index' id='conversion,user-defined'></a></span><span class='indexparent'><a class='index' id='conversion_operator'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A member function of a class <span class='texttt'>X</span> having no parameters with a name of the form</p><pre class='bnf'><a id='nt:conversion-function-id'>conversion-function-id:</a>
    <span class='terminal'>operator</span> <i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i></pre><pre class='bnf'><a id='nt:conversion-type-id'>conversion-type-id:</a>
    <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i> <i ><a href='class.conv.fct#nt:conversion-declarator'>conversion-declarator</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:conversion-declarator'>conversion-declarator:</a>
    <i ><a href='dcl.decl#nt:ptr-operator'>ptr-operator</a></i> <i ><a href='class.conv.fct#nt:conversion-declarator'>conversion-declarator</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><p >specifies a conversion from
<span class='texttt'>X</span>
to the type specified by the
<i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>.
Such functions are called <a id='conversion_function'><i>conversion function</i></a>s.
A <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i> in the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
of a conversion function (if any) shall be neither
a <i ><a href='dcl.type#nt:defining-type-specifier'>defining-type-specifier</a></i> nor <span class='texttt'>static</span>.
<span class='indexparent'><a class='index' id='conversion,type_of'></a></span>The type of the conversion function (<a href='dcl.fct'>[dcl.fct]</a>) is
“function taking no parameter returning
<i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>”.
A conversion function is never used to convert a (possibly cv-qualified) object
to the (possibly cv-qualified) same object type (or a reference to it),
to a (possibly cv-qualified) base class of that type (or a reference to it),
or to (possibly cv-qualified) void.<a class='footnotenum' href='#footnote-116'>116</a></p><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct X {
  operator int();
};

void f(X a) {
  int i = int(a);
  i = (int)a;
  i = a;
}
</pre><p >In all three cases the value assigned will be converted by
<span class='texttt'>X::operator int()</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A conversion function may be explicit (<a href='dcl.fct.spec'>[dcl.fct.spec]</a>), in which case it is only considered as a user-defined conversion for direct-initialization (<a href='dcl.init'>[dcl.init]</a>). Otherwise, user-defined conversions are not restricted to use in assignments and initializations.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class Y { };
struct Z {
  explicit operator Y() const;
};

void h(Z z) {
  Y y1(z);          <span class='comment'>// OK: direct-initialization
</span>  Y y2 = z;         <span class='comment'>// ill-formed: copy-initialization
</span>  Y y3 = (Y)z;      <span class='comment'>// OK: cast notation
</span>}

void g(X a, X b) {
  int i = (a) ? 1+a : 0;
  int j = (a&amp;&amp;b) ? a+b : i;
  if (a) {
  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The
<i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>
shall not represent a function type nor an array type.
The
<i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>
in a
<i ><a href='class.conv.fct#nt:conversion-function-id'>conversion-function-id</a></i>
is the longest sequence of
tokens that could possibly form a <i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span>
This prevents ambiguities between the declarator operator <span class='texttt'>*</span> and its expression
counterparts.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
&amp;ac.operator int*i; <span class='comment'>// syntax error:
</span>                    <span class='comment'>// parsed as: <span class='texttt'>&amp;(ac.operator int *)i</span>
</span>                    <span class='comment'>// not as: <span class='texttt'>&amp;(ac.operator int)*i</span>
</span></pre><p >The <span class='texttt'>*</span> is the pointer declarator and not the multiplication operator.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >This rule also prevents ambiguities for attributes. 
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
operator int [[noreturn]] (); <span class='comment'>// error: <span class='texttt'>noreturn</span> attribute applied to a type
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='conversion,inheritance_of_user-defined'></a></span>Conversion functions are inherited.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='conversion,virtual_user-defined'></a></span>Conversion functions can be virtual.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='conversion,deduced_return_type_of_user-defined'></a></span>A conversion function template shall not have a
deduced return type (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>).</p></div><div class='footnote' id='footnote-116'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-116'>116)</a></div><p >These conversions are considered
as standard conversions for the purposes of overload resolution (<a href='over.best.ics'>[over.best.ics]</a>, <a href='over.ics.ref'>[over.ics.ref]</a>) and therefore initialization (<a href='dcl.init'>[dcl.init]</a>) and explicit casts (<a href='expr.static.cast'>[expr.static.cast]</a>). A conversion to <span class='texttt'>void</span> does not invoke any conversion function (<a href='expr.static.cast'>[expr.static.cast]</a>).
Even though never directly called to perform a conversion,
such conversion functions can be declared and can potentially
be reached through a call to a virtual conversion function in a base class.</p></div></div></div></body></html>