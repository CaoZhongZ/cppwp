<!DOCTYPE html><html lang='en'><head><title>[expr.reinterpret.cast]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>5.2</a> Postfix expressions <a class='abbr_ref' href='expr.post#expr.reinterpret.cast'>[expr.post]</a></h2><div id='expr.reinterpret.cast'><h3 ><a class='secnum' style='min-width:103pt'>5.2.10</a> Reinterpret cast <a class='abbr_ref'>[expr.reinterpret.cast]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression!reinterpret~cast'></a></span>
<span class='indexparent'><a class='index' id='cast!reinterpret'></a></span>The result of the expression <span class='texttt'>reinterpret_cast&lt;T&gt;(v)</span> is the
result of converting the expression <span class='texttt'>v</span> to type <span class='texttt'>T</span>.
<span class='indexparent'><a class='index' id='cast!reinterpret!lvalue'></a></span><span class='indexparent'><a class='index' id='cast!lvalue'></a></span>If <span class='texttt'>T</span> is an lvalue reference type or an rvalue reference to function type, the result is an lvalue;
if <span class='texttt'>T</span> is an rvalue reference to object type, the result is an xvalue;
otherwise, the result is a prvalue and the
lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>), array-to-pointer (<a href='conv.array'>[conv.array]</a>),
and function-to-pointer (<a href='conv.func'>[conv.func]</a>) standard conversions are
performed on the expression <span class='texttt'>v</span>. Conversions that can be performed explicitly
using <span class='texttt'>reinterpret_cast</span> are listed below. No other conversion can
be performed explicitly using <span class='texttt'>reinterpret_cast</span>.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The <span class='texttt'>reinterpret_cast</span> operator shall not cast away constness (<a href='expr.const.cast'>[expr.const.cast]</a>).
An expression of integral, enumeration, pointer, or pointer-to-member type
can be explicitly converted to its own type; such a cast yields the value of
its operand.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
The mapping performed by <span class='texttt'>reinterpret_cast</span> might, or might not, produce a
representation different from the original value.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='cast!reinterpret!pointer to integer'></a></span><span class='indexparent'><a class='index' id='cast!pointer~to integer'></a></span>A pointer can be explicitly converted to any integral type large enough
to hold it.
<span class='indexparent'><a class='index' id='conversion!implementation~defined pointer integer'></a></span>The mapping function is implementation-defined.
[&nbsp;<i>Note:</i><span class='space'></span>
It is intended to be unsurprising to those who know the addressing
structure of the underlying machine.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] A value of type <span class='texttt'>std::nullptr_t</span> can be converted to an integral
type; the conversion has the same meaning and validity as a conversion of
<span class='texttt'>(void*)0</span> to the integral type. [&nbsp;<i>Note:</i><span class='space'></span> A <span class='texttt'>reinterpret_cast</span>
cannot be used to convert a value of any type to the type
<span class='texttt'>std::nullptr_t</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='cast!reinterpret!integer~to pointer'></a></span><span class='indexparent'><a class='index' id='cast!integer~to pointer'></a></span>A value of integral type or enumeration type can be explicitly converted
to a pointer. A pointer converted to an integer of sufficient size (if
any such exists on the implementation) and back to the same pointer type
will have its original value;
<span class='indexparent'><a class='index' id='conversion!implementation~defined pointer integer'></a></span>mappings between pointers and integers are otherwise
<span class='indexparent'><a class='index' id='conversions between pointers and integers'></a></span>implementation-defined.
[&nbsp;<i>Note:</i><span class='space'></span> Except as described in <a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>, the result of
such a conversion will not be a safely-derived pointer value. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='cast!reinterpret!pointer-to-function'></a></span><span class='indexparent'><a class='index' id='cast!pointer-to-function'></a></span><span class='indexparent'><a class='index' id='cast!undefined pointer-to-function'></a></span>A function pointer can be explicitly converted
to a function pointer of a different type.
<span class='indexparent'><a class='index' id='function~call!undefined'></a></span>The effect of calling a function through a pointer to a function
type (<a href='dcl.fct'>[dcl.fct]</a>) that is not the same as the type used in the
definition of the function is undefined. Except that converting
a prvalue of type “pointer to <span class='texttt'>T1</span>” to the type “pointer to
<span class='texttt'>T2</span>” (where <span class='texttt'>T1</span> and <span class='texttt'>T2</span> are function types) and
back to its original type yields the original pointer value, the result
of such a pointer conversion is unspecified.
[&nbsp;<i>Note:</i><span class='space'></span>
see also <a href='conv.ptr'>[conv.ptr]</a> for more details of pointer conversions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >An object pointer
can be explicitly converted to an object pointer of a different type.<a class='footnotenum' href='#footnote-72'>72</a>
When a prvalue <span class='texttt'>v</span> of object pointer type is converted to
the object pointer type “pointer to <i>cv</i> <span class='texttt'>T</span>”, the result is <span class='texttt'>static_cast&lt;<i>cv</i> T*&gt;(static_cast&lt;<i>cv</i>
void*&gt;(v))</span>.
Converting a prvalue of type “pointer to <span class='texttt'>T1</span>” to
the type “pointer to <span class='texttt'>T2</span>” (where <span class='texttt'>T1</span> and <span class='texttt'>T2</span> are
object types and where the alignment requirements of <span class='texttt'>T2</span> are no
stricter than those of <span class='texttt'>T1</span>) and back to its original type yields
the original pointer value.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >Converting a function pointer to an object pointer
type or vice versa is
conditionally-supported. The meaning of such a conversion is
<span class='indexparent'><a class='index' id='converting function pointer to object pointer and vice versa'></a></span>implementation-defined,
except that if an implementation
supports conversions in both directions, converting a prvalue of one type to the other
type and back, possibly with different cv-qualification, shall yield the original
pointer value.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >The null pointer value (<a href='conv.ptr'>[conv.ptr]</a>) is converted to the null pointer value
of the destination type.
[&nbsp;<i>Note:</i><span class='space'></span>
A null pointer constant of type <span class='texttt'>std::nullptr_t</span> cannot be converted to a
pointer type, and a null pointer constant of integral type is not necessarily
converted to a null pointer value.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p ><span class='indexparent'><a class='index' id='cast!reinterpret!pointer-to-member'></a></span><span class='indexparent'><a class='index' id='cast!pointer-to-member'></a></span>A prvalue of type “pointer to member of <span class='texttt'>X</span> of type <span class='texttt'>T1</span>”
can be explicitly converted to a prvalue of a different type “pointer to member of
<span class='texttt'>Y</span> of type <span class='texttt'>T2</span>” if <span class='texttt'>T1</span> and <span class='texttt'>T2</span> are both
function types or both object types.<a class='footnotenum' href='#footnote-73'>73</a> The null member pointer value (<a href='conv.mem'>[conv.mem]</a>) is converted to the
null member pointer value of the destination type. The result of this
conversion is unspecified, except in the following cases:</p><ul ><li ><p >converting a prvalue of type “pointer to member function” to a
different pointer to member function type and back to its original type
yields the original pointer to member value.</p></li><li ><p >converting a prvalue of type “pointer to data member of <span class='texttt'>X</span>
of type <span class='texttt'>T1</span>” to the type “pointer to data member of <span class='texttt'>Y</span>
of type <span class='texttt'>T2</span>” (where the alignment requirements of <span class='texttt'>T2</span> are
no stricter than those of <span class='texttt'>T1</span>) and back to its original type
yields the original pointer to member value.
</p></li></ul></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p ><span class='indexparent'><a class='index' id='cast!reinterpret!reference'></a></span><span class='indexparent'><a class='index' id='cast!reference'></a></span>A glvalue expression of type <span class='texttt'>T1</span> can be cast to the type
“reference to <span class='texttt'>T2</span>” if an expression of type “pointer to
<span class='texttt'>T1</span>” can be explicitly converted to the type “pointer to
<span class='texttt'>T2</span>” using a <span class='texttt'>reinterpret_cast</span>. The result refers to
the same object as the source glvalue, but with the specified
type. [&nbsp;<i>Note:</i><span class='space'></span> That is, for lvalues, a reference cast
<span class='texttt'>reinterpret_cast&lt;T&amp;&gt;(x)</span> has the same effect as the conversion
<span class='texttt'>*reinterpret_cast&lt;T*&gt;(&amp;x)</span> with the built-in <span class='texttt'>&amp;</span> and
<span class='texttt'>*</span> operators (and similarly for
<span class='texttt'>reinterpret_cast&lt;T&amp;&amp;&gt;(x)</span>). <i>&nbsp;—&nbsp;end note</i>&nbsp;] No
temporary is created, no copy is made, and
constructors (<a href='class.ctor'>[class.ctor]</a>) or conversion
functions (<a href='class.conv'>[class.conv]</a>) are not called.<a class='footnotenum' href='#footnote-74'>74</a></p></div><div class='footnote' id='footnote-72'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-72'>72)</a></div><p >The
types may have different <i>cv</i>-qualifiers, subject to
the overall
restriction that a <span class='texttt'>reinterpret_cast</span> cannot cast away constness.</p></div><div class='footnote' id='footnote-73'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-73'>73)</a></div><p ><span class='texttt'>T1</span> and <span class='texttt'>T2</span> may have
different <i>cv</i>-qualifiers, subject to
the overall restriction that a <span class='texttt'>reinterpret_cast</span> cannot cast away
constness.</p></div><div class='footnote' id='footnote-74'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-74'>74)</a></div><p >This
is sometimes referred to as a <a id='type~pun'><i>type pun</i></a>.</p></div></div></div></body></html>