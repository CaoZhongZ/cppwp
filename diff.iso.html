<!DOCTYPE html><html lang='en'><head><title>[diff.iso]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='annexnum' style='min-width:73pt'>Annex C&emsp;(informative)</a> Compatibility <a class='abbr_ref' href='./#diff'>[diff]</a></h1><div id='diff.iso'><h2 ><a class='secnum' style='min-width:88pt'>C.1</a> C++ and ISO C <a class='abbr_ref'>[diff.iso]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/701df7eac2474300d2b602700a3c32a51ef439a7/source/compatibility.tex#L6'>#</a></div><p ><span class='indexparent'><a class='index' id='summary,compatibility_with_ISO_C'></a></span>This subclause lists the differences between C++ and
ISO C, by the chapters of this document.</p></div><div id='diff.lex'><h3 ><a class='secnum' href='#diff.lex' style='min-width:103pt'>C.1.1</a> Clause <a href='lex'>[lex]</a>: lexical conventions <a class='abbr_ref' href='diff.lex'>[diff.lex]</a></h3><p ><a href='lex.key'>[lex.key]</a>
<br/><b>Change:</b> New Keywords<br/>
New keywords are added to C++;
see <a href='lex.key'>[lex.key]</a>.
<br/><b>Rationale:</b>
These keywords were added in order to implement the new
semantics of C++.
<br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
Any ISO C programs that used any of these keywords as identifiers
are not valid C++ programs.
<br/><b>Difficulty of converting:</b>
Syntactic transformation.
Converting one specific program is easy.
Converting a large collection
of related programs takes more work.
<br/><b>How widely used:</b>
Common.</p><p ><a href='lex.ccon'>[lex.ccon]</a>
<br/><b>Change:</b> Type of character literal is changed from <span class='texttt'>int</span> to <span class='texttt'>char</span>.
<br/><b>Rationale:</b>
This is needed for improved overloaded function argument type
matching.
For example:</p><pre class='codeblock'>
int function( int i );
int function( char c );

function( 'x' );</pre><p >It is preferable that this call match the second version of
function rather than the first.
<br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
ISO C programs which depend on</p><pre class='codeblock'>
sizeof('x') == sizeof(int)</pre><p >will not work the same as C++ programs.
<br/><b>Difficulty of converting:</b>
Simple.
<br/><b>How widely used:</b>
Programs which depend upon <span class='texttt'>sizeof('x')</span> are probably rare.</p><p >Subclause <a href='lex.string'>[lex.string]</a>:
<br/><b>Change:</b> String literals made const.<br/>
The type of a string literal is changed
from “array of <span class='texttt'>char</span>”
to “array of <span class='texttt'>const char</span>”.
The type of a <span class='texttt'>char16_&shy;t</span> string literal is changed
from “array of <span class='textit'>some-integer-type</span>”
to “array of <span class='texttt'>const char16_&shy;t</span>”.
The type of a <span class='texttt'>char32_&shy;t</span> string literal is changed
from “array of <span class='textit'>some-integer-type</span>”
to “array of <span class='texttt'>const char32_&shy;t</span>”.
The type of a wide string literal is changed
from “array of <span class='texttt'>wchar_&shy;t</span>”
to “array of <span class='texttt'>const wchar_&shy;t</span>”.
<br/><b>Rationale:</b>
This avoids calling an inappropriate overloaded function,
which might expect to be able to modify its argument.
<br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<br/><b>Difficulty of converting:</b>
Syntactic transformation. The fix is to add a cast:</p><pre class='codeblock'>
char* p = "abc";                <span class='comment'>// valid in C, invalid in C++
</span>void f(char*) {
  char* p = (char*)"abc";       <span class='comment'>// OK: cast added
</span>  f(p);
  f((char*)"def");              <span class='comment'>// OK: cast added
</span>}</pre><p ><br/><b>How widely used:</b>
Programs that have a legitimate reason to treat string literals
as pointers to potentially modifiable memory are probably rare.</p></div><div id='diff.basic'><h3 ><a class='secnum' href='#diff.basic' style='min-width:103pt'>C.1.2</a> Clause <a href='basic'>[basic]</a>: basic concepts <a class='abbr_ref' href='diff.basic'>[diff.basic]</a></h3><p ><a href='basic.def'>[basic.def]</a>
<br/><b>Change:</b> C++ does not have “tentative definitions” as in C.<br/>
E.g., at file scope,</p><pre class='codeblock'>
int i;
int i;</pre><p >is valid in C, invalid in C++.
This makes it impossible to define
mutually referential file-local static objects, if initializers are
restricted to the syntactic forms of C. 
For example,</p><pre class='codeblock'>
struct X { int i; struct X* next; };

static struct X a;
static struct X b = { 0, &amp;a };
static struct X a = { 1, &amp;b };</pre><p ><br/><b>Rationale:</b>
This avoids having different initialization rules for
fundamental types and user-defined types.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
In C++, the initializer for one of a set of
mutually-referential file-local static objects must invoke a function
call to achieve the initialization.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='basic.scope'>[basic.scope]</a>
<br/><b>Change:</b> A <span class='texttt'>struct</span> is a scope in C++, not in C.
<br/><b>Rationale:</b>
Class scope is crucial to C++, and a struct is a class.
<br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
<br/><b>How widely used:</b>
C programs use <span class='texttt'>struct</span> extremely frequently, but the
change is only noticeable when <span class='texttt'>struct</span>, enumeration, or enumerator
names are referred to outside the <span class='texttt'>struct</span>.
The latter is probably rare.</p><p ><a href='basic.link'>[basic.link]</a> [also <a href='dcl.type'>[dcl.type]</a>] 
<br/><b>Change:</b> A name of file scope that is explicitly declared <span class='texttt'>const</span>, and not explicitly
declared <span class='texttt'>extern</span>, has internal linkage, while in C it would have external linkage.
<br/><b>Rationale:</b>
Because <span class='texttt'>const</span> objects may be used as values during translation in
C++, this feature urges programmers to provide an explicit initializer
for each <span class='texttt'>const</span> object.
This feature allows the user to put <span class='texttt'>const</span> objects in source files that are included
in more than one translation unit.
<br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='basic.start'>[basic.start]</a>
<br/><b>Change:</b> The <span class='texttt'>main</span> function cannot be called recursively and cannot have its address taken.
<br/><b>Rationale:</b>
The  main  function may require special actions.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Trivial: create an intermediary function such as
<span class='texttt'>mymain(argc, argv)</span>.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='basic.types'>[basic.types]</a>
<br/><b>Change:</b> C allows “compatible types” in several places, C++ does not.<br/>
For example,
otherwise-identical <span class='texttt'>struct</span> types with different tag names
are “compatible” in C but are distinctly different types
in C++.
<br/><b>Rationale:</b>
Stricter type checking is essential for C++.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
The “typesafe linkage” mechanism will find many, but not all,
of such problems.
Those problems not found by typesafe linkage will continue to
function properly,
according to the “layout compatibility rules” of this
International Standard.
<br/><b>How widely used:</b>
Common.</p></div><div id='diff.conv'><h3 ><a class='secnum' href='#diff.conv' style='min-width:103pt'>C.1.3</a> Clause <a href='conv'>[conv]</a>: standard conversions <a class='abbr_ref' href='diff.conv'>[diff.conv]</a></h3><p ><a href='conv.ptr'>[conv.ptr]</a>
<br/><b>Change:</b> Converting <span class='texttt'>void*</span> to a pointer-to-object type requires casting.</p><pre class='codeblock'>
char a[10];
void* b=a;
void foo() {
  char* c=b;
}</pre><p >ISO C will accept this usage of pointer to void being assigned
to a pointer to object type.
C++ will not.
<br/><b>Rationale:</b>
C++ tries harder than C to enforce compile-time type safety.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Could be automated.
Violations will be diagnosed by the C++ translator.
The
fix is to add a  cast.
For example:</p><pre class='codeblock'>
char* c = (char*) b;</pre><p ><br/><b>How widely used:</b>
This is fairly widely used but it is good
programming practice to add the cast when assigning pointer-to-void to pointer-to-object.
Some ISO C translators will give a warning
if the cast is not used.</p></div><div id='diff.expr'><h3 ><a class='secnum' href='#diff.expr' style='min-width:103pt'>C.1.4</a> Clause <a href='expr'>[expr]</a>: expressions <a class='abbr_ref' href='diff.expr'>[diff.expr]</a></h3><p ><a href='expr.call'>[expr.call]</a>
<br/><b>Change:</b> Implicit declaration of functions is not allowed.
<br/><b>Rationale:</b>
The type-safe nature of C++.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
Note: the original feature was labeled as “obsolescent” in ISO C.
<br/><b>Difficulty of converting:</b>
Syntactic transformation.
Facilities for producing explicit function declarations are fairly
widespread commercially.
<br/><b>How widely used:</b>
Common.</p><p ><a href='expr.post.incr'>[expr.post.incr]</a>, <a href='expr.pre.incr'>[expr.pre.incr]</a>
<br/><b>Change:</b>
Decrement operator is not allowed with <span class='texttt'>bool</span> operand.
<br/><b>Rationale:</b> Feature with surprising semantics.
<br/><b>Effect on original feature:</b> A valid ISO C expression utilizing the decrement operator on
a <span class='texttt'>bool</span> lvalue (for instance, via the C typedef in <span class='texttt'>&lt;stdbool.h&gt;</span>)
is ill-formed in this International Standard.</p><p ><a href='expr.sizeof'>[expr.sizeof]</a>, <a href='expr.cast'>[expr.cast]</a>
<br/><b>Change:</b> Types must be defined in declarations, not in expressions.<br/>
In C, a sizeof expression or cast expression may define a new type.
For example,
</p><pre class='codeblock'>
p = (void*)(struct x {int i;} *)0;</pre><p >defines a new type, struct <span class='texttt'>x</span>.
<br/><b>Rationale:</b>
This prohibition helps to clarify the location of
definitions in the source code.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Syntactic transformation.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='expr.cond'>[expr.cond]</a>, <a href='expr.ass'>[expr.ass]</a>, <a href='expr.comma'>[expr.comma]</a>
<span class='indexparent'><a class='index' id='conversion,lvalue-to-rvalue'></a></span><span class='indexparent'><a class='index' id='rvalue,lvalue_conversion_to'></a></span><span class='indexparent'><a class='index' id='lvalue'></a></span><br/><b>Change:</b> The result of a conditional expression, an assignment expression, or a comma expression may be an lvalue.
<br/><b>Rationale:</b>
C++ is an object-oriented language, placing relatively
more emphasis on lvalues.  For example, functions may
return lvalues.
<br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.  Some C
expressions that implicitly rely on lvalue-to-rvalue
conversions will yield different results.  For example,</p><pre class='codeblock'>
char arr[100];
sizeof(0, arr)</pre><p >yields
<span class='texttt'>100</span>
in C++ and
<span class='texttt'>sizeof(char*)</span>
in C.
<br/><b>Difficulty of converting:</b>
Programs must add explicit casts to the appropriate rvalue.
<br/><b>How widely used:</b>
Rare.</p></div><div id='diff.stat'><h3 ><a class='secnum' href='#diff.stat' style='min-width:103pt'>C.1.5</a> Clause <a href='stmt.stmt'>[stmt.stmt]</a>: statements <a class='abbr_ref' href='diff.stat'>[diff.stat]</a></h3><p ><a href='stmt.switch'>[stmt.switch]</a>, <a href='stmt.goto'>[stmt.goto]</a>
<br/><b>Change:</b> It is now invalid to jump past a declaration with explicit or implicit initializer (except across entire block not entered).
<br/><b>Rationale:</b>
Constructors used in initializers may allocate
resources which need to be de-allocated upon leaving the
block.
Allowing jump past initializers would require
complicated runtime determination of allocation.
Furthermore, any use of the uninitialized object could be a
disaster.
With this simple compile-time rule, C++ assures that
if an initialized variable is in scope, then it has assuredly been
initialized.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='stmt.return'>[stmt.return]</a>
<br/><b>Change:</b> It is now invalid to return (explicitly or implicitly) from a function which is
declared to return a value without actually returning a value.
<br/><b>Rationale:</b>
The caller and callee may assume fairly elaborate
return-value mechanisms for the return of class objects.
If
some flow paths execute a return without specifying any value,
the implementation must embody many more complications.
Besides,
promising to return a value of a given type, and then not returning
such a value, has always been recognized to be a questionable
practice, tolerated only because very-old C had no distinction between
void  functions and  int  functions.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
Add an appropriate return value to the source code, such as zero.
<br/><b>How widely used:</b>
Seldom.
For several years, many existing C implementations have produced warnings in
this case.</p></div><div id='diff.dcl'><h3 ><a class='secnum' href='#diff.dcl' style='min-width:103pt'>C.1.6</a> Clause <a href='dcl.dcl'>[dcl.dcl]</a>: declarations <a class='abbr_ref' href='diff.dcl'>[diff.dcl]</a></h3><p ><a href='dcl.stc'>[dcl.stc]</a>
<br/><b>Change:</b> In C++, the <span class='texttt'>static</span> or <span class='texttt'>extern</span> specifiers can only be applied to names of objects or functions.<br/>
Using these specifiers with type declarations is illegal in C++.
In C, these specifiers are ignored when used on type declarations.</p><p >Example:</p><pre class='codeblock'>
static struct S {               <span class='comment'>// valid C, invalid in C++
</span>  int i;
};</pre><p ><br/><b>Rationale:</b>
Storage class specifiers don't have any meaning when associated
with a type.
In C++, class members can be declared with the <span class='texttt'>static</span> storage
class specifier.
Allowing storage class specifiers on type
declarations could render the code confusing for users.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Syntactic transformation.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='dcl.stc'>[dcl.stc]</a>
<br/><b>Change:</b> In C++, <span class='texttt'>register</span> is not a storage class specifier.
<br/><b>Rationale:</b>
The storage class specifier had no effect in C++.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Syntactic transformation.
<br/><b>How widely used:</b>
Common.</p><p ><a href='dcl.typedef'>[dcl.typedef]</a>
<br/><b>Change:</b> A C++ typedef name must be different from any class type name declared
in the same scope (except if the typedef is a synonym of the class name with the
same name). In C, a typedef name and a struct tag name declared in the same scope
can have the same name (because they have different name spaces).</p><p >Example:
</p><pre class='codeblock'>
typedef struct name1 { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> } name1;         <span class='comment'>// valid C and C++
</span>struct name { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };
typedef int name;               <span class='comment'>// valid C, invalid C++
</span></pre><p ><br/><b>Rationale:</b>
For ease of use, C++ doesn't require that a type name be prefixed
with the keywords <span class='texttt'>class</span>, <span class='texttt'>struct</span> or <span class='texttt'>union</span> when used in object
declarations or type casts.</p><p >Example:
</p><pre class='codeblock'>
class name { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> };
name i;                         <span class='comment'>// <span class='tcode_in_codeblock'>i</span> has type <span class='tcode_in_codeblock'>class name</span>
</span></pre><p ><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
One of the 2 types has to be renamed.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='dcl.type'>[dcl.type]</a> [see also <a href='basic.link'>[basic.link]</a>]
<br/><b>Change:</b> <span class='texttt'>const</span> objects must be initialized in C++ but can be left uninitialized in C.
<br/><b>Rationale:</b>
A const object cannot be assigned to so it must be initialized
to hold a useful value.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='dcl.type'>[dcl.type]</a>
<br/><b>Change:</b> Banning implicit <span class='texttt'>int</span>.</p><p >In C++ a
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
must contain a
<i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>, unless
it is followed by a declarator for a constructor, a destructor, or a
conversion function.
In the following example, the
left-hand column presents valid C;
the right-hand column presents
equivalent C++:</p><pre class='codeblock'>
void f(const parm);            void f(const int parm);
const n = 3;                   const int n = 3;
main()                         int main()
    <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span>                      <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span></pre><p ><br/><b>Rationale:</b>
In C++, implicit int creates several opportunities for
ambiguity between expressions involving function-like
casts and declarations.
Explicit declaration is increasingly considered
to be proper style.
Liaison with WG14 (C) indicated support for (at least)
deprecating implicit int in the next revision of C.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Syntactic transformation.
Could be automated.
<br/><b>How widely used:</b>
Common.</p><p ><a href='dcl.spec.auto'>[dcl.spec.auto]</a>
<br/><b>Change:</b>
The keyword <span class='texttt'>auto</span> cannot be used as a storage class specifier.</p><pre class='codeblock'>
void f() {
  auto int x;     <span class='comment'>// valid C, invalid C++
</span>}</pre><p ><br/><b>Rationale:</b> Allowing the use of <span class='texttt'>auto</span> to deduce the type
of a variable from its initializer results in undesired interpretations of
<span class='texttt'>auto</span> as a storage class specifier in certain contexts.
<br/><b>Effect on original feature:</b> Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b> Syntactic transformation.
<br/><b>How widely used:</b> Rare.</p><p ><a href='dcl.enum'>[dcl.enum]</a>
<br/><b>Change:</b> C++ objects of enumeration type can only be assigned values of the same enumeration type.
In C, objects of enumeration type can be assigned values of any integral type.</p><p >Example:
</p><pre class='codeblock'>
enum color { red, blue, green };
enum color c = 1;               <span class='comment'>// valid C, invalid C++
</span></pre><p ><br/><b>Rationale:</b>
The type-safe nature of C++.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Syntactic transformation.
(The type error produced by the assignment can be automatically
corrected by applying an explicit cast.)
<br/><b>How widely used:</b>
Common.</p><p ><a href='dcl.enum'>[dcl.enum]</a>
<br/><b>Change:</b> In C++, the type of an enumerator is its enumeration. In C, the type of an enumerator is <span class='texttt'>int</span>.</p><p >Example:</p><pre class='codeblock'>
enum e { A };
sizeof(A) == sizeof(int)        <span class='comment'>// in C
</span>sizeof(A) == sizeof(e)          <span class='comment'>// in C++
</span><span class='comment'>/* <span class='textit'><span class='textrm'>and <span class='tcode_in_codeblock'>sizeof(int)</span> is not necessarily equal to <span class='tcode_in_codeblock'>sizeof(e)</span></span></span> */</span></pre><p ><br/><b>Rationale:</b>
In C++, an enumeration is a distinct type.
<br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
<br/><b>How widely used:</b>
Seldom.
The only time this affects existing C code is when the size of an
enumerator is taken.
Taking the size of an enumerator is not a
common C coding practice.</p></div><div id='diff.decl'><h3 ><a class='secnum' href='#diff.decl' style='min-width:103pt'>C.1.7</a> Clause <a href='dcl.decl'>[dcl.decl]</a>: declarators <a class='abbr_ref' href='diff.decl'>[diff.decl]</a></h3><p ><a href='dcl.fct'>[dcl.fct]</a>
<br/><b>Change:</b> In C++, a function declared with an empty parameter list takes no arguments.
In C, an empty parameter list means that the number and type of the function arguments are unknown.</p><p >Example:</p><pre class='codeblock'>
int f();            <span class='comment'>// means   <span class='tcode_in_codeblock'>int f(void)</span> in C++
</span>                    <span class='comment'>// <span class='tcode_in_codeblock'>int f(</span> unknown <span class='tcode_in_codeblock'>)</span> in C
</span></pre><p ><br/><b>Rationale:</b>
This is to avoid erroneous function calls (i.e., function calls
with the wrong number or type of arguments).
<br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
This feature was marked as “obsolescent” in C.
<br/><b>Difficulty of converting:</b>
Syntactic transformation.
The function declarations using C incomplete declaration style must
be completed to become full prototype declarations.
A program may need to be updated further if different calls to the
same (non-prototype) function have different numbers of arguments or
if the type of corresponding arguments differed.
<br/><b>How widely used:</b>
Common.</p><p ><a href='dcl.fct'>[dcl.fct]</a> [see <a href='expr.sizeof'>[expr.sizeof]</a>]
<br/><b>Change:</b> In C++, types may not be defined in return or parameter types.
In C, these type definitions are allowed.</p><p >Example:</p><pre class='codeblock'>
void f( struct S { int a; } arg ) {}    <span class='comment'>// valid C, invalid C++
</span>enum E { A, B, C } f() {}               <span class='comment'>// valid C, invalid C++
</span></pre><p ><br/><b>Rationale:</b>
When comparing types in different translation units, C++ relies
on name equivalence when C relies on structural equivalence.
Regarding parameter types: since the type defined in an parameter list
would be in the scope of the function, the only legal calls in C++
would be from within the function itself.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
The type definitions must be moved to file scope, or in header files.
<br/><b>How widely used:</b>
Seldom.
This style of type definition is seen as poor coding style.</p><p ><a href='dcl.fct.def'>[dcl.fct.def]</a>
<br/><b>Change:</b> In C++, the syntax for function definition excludes the “old-style” C function.
In C, “old-style” syntax is allowed, but deprecated as “obsolescent”.
<br/><b>Rationale:</b>
Prototypes are essential to type safety.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Syntactic transformation.
<br/><b>How widely used:</b>
Common in old programs, but already known to be obsolescent.</p><p ><a href='dcl.init.string'>[dcl.init.string]</a>
<br/><b>Change:</b> In C++, when initializing an array of character with a string, the number of
characters in the string (including the terminating <span class='texttt'>'\0'</span>) must not exceed the
number of elements in the array. In C, an array can be initialized with a string even if
the array is not large enough to contain the string-terminating <span class='texttt'>'\0'</span>.</p><p >Example:</p><pre class='codeblock'>
char array[4] = "abcd";         <span class='comment'>// valid C, invalid C++
</span></pre><p ><br/><b>Rationale:</b>
When these non-terminated arrays are manipulated by standard
string functions, there is potential for major catastrophe.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
The arrays must be declared one element bigger to contain the
string terminating <span class='texttt'>'\0'</span>.
<br/><b>How widely used:</b>
Seldom.
This style of array initialization is seen as poor coding style.</p></div><div id='diff.class'><h3 ><a class='secnum' href='#diff.class' style='min-width:103pt'>C.1.8</a> Clause <a href='class'>[class]</a>: classes <a class='abbr_ref' href='diff.class'>[diff.class]</a></h3><p ><a href='class.name'>[class.name]</a> [see also <a href='dcl.typedef'>[dcl.typedef]</a>]
<br/><b>Change:</b> In C++, a class declaration introduces the class name into the scope where it is
declared and hides any object, function or other declaration of that name in an enclosing
scope. In C, an inner scope declaration of a struct tag name never hides the name of an
object or function in an outer scope.</p><p >Example:</p><pre class='codeblock'>
int x[99];
void f() {
  struct x { int a; };
  sizeof(x);  <span class='comment'>/* <span class='textit'><span class='textrm'>size of the array in C</span></span> */</span>
  <span class='comment'>/* <span class='textit'><span class='textrm'>size of the struct in C++</span></span> */</span>
}</pre><p ><br/><b>Rationale:</b>
This is one of the few incompatibilities between C and C++ that
can be attributed to the new C++ name space definition where a
name can be declared as a type and as a non-type in a single scope
causing the non-type name to hide the type name and requiring that
the keywords <span class='texttt'>class</span>, <span class='texttt'>struct</span>, <span class='texttt'>union</span> or <span class='texttt'>enum</span> be used to refer to the type name.
This new name space definition provides important notational
conveniences to C++ programmers and helps making the use of the
user-defined types as similar as possible to the use of fundamental
types.
The advantages of the new name space definition were judged to
outweigh by far the incompatibility with C described above.
<br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
If the hidden name that needs to be accessed is at global scope,
the <span class='texttt'>&#x200b;::&#x200b;</span> C++ operator can be used.
If the hidden name is at block scope, either the type or the struct
tag has to be renamed.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='class.bit'>[class.bit]</a>
<br/><b>Change:</b>
<span class='indexparent'><a class='index' id='bit-field,implementation-defined_sign_of'></a></span>Bit-fields of type plain <span class='texttt'>int</span> are signed.
<br/><b>Rationale:</b>
Leaving the choice of signedness to implementations could lead to
inconsistent definitions of template specializations. For consistency,
the implementation freedom was eliminated for non-dependent types,
too.
<br/><b>Effect on original feature:</b>
The choice is implementation-defined in C, but not so in C++.
<br/><b>Difficulty of converting:</b>
Syntactic transformation.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='class.nest'>[class.nest]</a>
<br/><b>Change:</b> In C++, the name of a nested class is local to its enclosing class. In C
the name of the nested class belongs to the same scope as the name of the outermost enclosing class.</p><p >Example:</p><pre class='codeblock'>
struct X {
  struct Y { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> } y;
};
struct Y yy;                    <span class='comment'>// valid C, invalid C++
</span></pre><p ><br/><b>Rationale:</b>
C++ classes have member functions which require that classes
establish scopes.
The C rule would leave classes as an incomplete scope mechanism
which would prevent C++ programmers from maintaining locality
within a class.
A coherent set of scope rules for C++ based on the C rule would
be very complicated and C++ programmers would be unable to predict
reliably the meanings of nontrivial examples involving nested or
local functions.
<br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
To make the struct type name visible in the scope of the enclosing
struct, the struct tag could be declared in the scope of the
enclosing struct, before the enclosing struct is defined.
Example:</p><pre class='codeblock'>
struct Y;                       <span class='comment'>// <span class='tcode_in_codeblock'>struct Y</span> and <span class='tcode_in_codeblock'>struct X</span> are at the same scope
</span>struct X {
  struct Y { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> } y;
};</pre><p >All the definitions of C struct types enclosed in other struct
definitions and accessed outside the scope of the enclosing
struct could be exported to the scope of the enclosing struct.
Note: this is a consequence of the difference in scope rules,
which is documented in <a href='basic.scope'>[basic.scope]</a>.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='class.nested.type'>[class.nested.type]</a>
<br/><b>Change:</b> In C++, a typedef name may not be redeclared in a class definition after being used in that definition.</p><p >Example:</p><pre class='codeblock'>
typedef int I;
struct S {
  I i;
  int I;                  <span class='comment'>// valid C, invalid C++
</span>};</pre><p ><br/><b>Rationale:</b>
When classes become complicated, allowing such a redefinition
after the type has been used can create confusion for C++
programmers as to what the meaning of 'I' really is.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
Either the type or the struct member has to be renamed.
<br/><b>How widely used:</b>
Seldom.</p></div><div id='diff.special'><h3 ><a class='secnum' href='#diff.special' style='min-width:103pt'>C.1.9</a> Clause <a href='special'>[special]</a>: special member functions <a class='abbr_ref' href='diff.special'>[diff.special]</a></h3><p ><a href='class.copy'>[class.copy]</a>
<br/><b>Change:</b> Copying volatile objects.</p><p >The implicitly-declared copy constructor and
implicitly-declared copy assignment operator
cannot make a copy of a volatile lvalue.
For example, the following is valid in ISO C:</p><pre class='codeblock'>
struct X { int i; };
volatile struct X x1 = {0};
struct X x2 = x1;               <span class='comment'>// invalid C++
</span>struct X x3;
x3 = x1;                        <span class='comment'>// also invalid C++
</span></pre><p ><br/><b>Rationale:</b>
Several alternatives were debated at length.
Changing the parameter to
<span class='texttt'>volatile</span>
<span class='texttt'>const</span>
<span class='texttt'>X&amp;</span>
would greatly complicate the generation of
efficient code for class objects.
Discussion of
providing two alternative signatures for these
implicitly-defined operations raised
unanswered concerns about creating
ambiguities and complicating
the rules that specify the formation of
these operators according to the bases and
members.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
If volatile semantics are required for the copy,
a user-declared constructor or assignment must
be provided.
If non-volatile semantics are required,
an explicit
<span class='texttt'>const_&shy;cast</span>
can be used.
<br/><b>How widely used:</b>
Seldom.</p></div><div id='diff.cpp'><h3 ><a class='secnum' href='#diff.cpp' style='min-width:103pt'>C.1.10</a> Clause <a href='cpp'>[cpp]</a>: preprocessing directives <a class='abbr_ref' href='diff.cpp'>[diff.cpp]</a></h3><p ><a href='cpp.predefined'>[cpp.predefined]</a>
<br/><b>Change:</b> Whether <span class='texttt'>_&shy;_&shy;STDC_&shy;_&shy;</span> is defined and if so, what its value is, are
<span class='indexparent'><a class='index' id='definition_and_meaning_of___STDC__'></a></span>implementation-defined.
<br/><b>Rationale:</b>
C++ is not identical to ISO C. 
Mandating that <span class='texttt'>_&shy;_&shy;STDC_&shy;_&shy;</span>
be defined would require that translators make an incorrect claim.
Each implementation must choose the behavior that will be most
useful to its marketplace.
<br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
<br/><b>How widely used:</b>
Programs and headers that reference <span class='texttt'>_&shy;_&shy;STDC_&shy;_&shy;</span> are
quite common.</p></div></div></div></body></html>