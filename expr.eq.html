<!DOCTYPE html><html lang='en'><head><title>[expr.eq]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>8.10</a> Equality operators <a class='abbr_ref'>[expr.eq]</a></h2><p ><span class='indexparent'><a class='index' id=':expression,equality_operators'></a></span><span class='indexparent'><a class='index' id=':operator,equality'></a></span><span class='indexparent'><a class='index' id=':operator,inequality'></a></span></p><pre class='bnf'><a class='nontermdef' id='nt:equality-expression'>equality-expression:</a>
&#9;<i ><a href='expr.rel#nt:relational-expression'>relational-expression</a></i>
&#9;<i ><a href='expr.eq#nt:equality-expression'>equality-expression</a></i> <span class='terminal'>==</span> <i ><a href='expr.rel#nt:relational-expression'>relational-expression</a></i>
&#9;<i ><a href='expr.eq#nt:equality-expression'>equality-expression</a></i> <span class='terminal'>!=</span> <i ><a href='expr.rel#nt:relational-expression'>relational-expression</a></i>
</pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L4309'>#</a></div><p >The <span class='texttt'>==</span> (equal to) and the <span class='texttt'>!=</span> (not equal to) operators
group left-to-right. The operands shall have arithmetic, enumeration, pointer,
or pointer to member type, or type <span class='texttt'>std&#x200b;::&#x200b;nullptr_&shy;t</span>. The operators
<span class='texttt'>==</span> and <span class='texttt'>!=</span> both yield <span class='texttt'>true</span> or <span class='texttt'>false</span>, i.e., a
result of type <span class='texttt'>bool</span>. In each case below, the operands shall have the
same type after the specified conversions have been applied.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L4317'>#</a></div><p ><span class='indexparent'><a class='index' id=':comparison,pointer'></a></span><span class='indexparent'><a class='index' id=':comparison,pointer_to_function'></a></span>If at least one of the operands is a pointer,
<a href='conv.ptr'>pointer conversions</a>,
<a href='conv.fctptr'>function pointer conversions</a>, and
<a href='conv.qual'>qualification conversions</a>
are performed on both operands to bring them to their
<a href='expr#def:composite_pointer_type'>composite pointer type</a>.
Comparing pointers is defined as follows:</p><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><p >If one pointer represents the address of a complete object, and another
pointer represents the address one past the last element of a different
complete object,<a class='footnotenum' href='#footnote-88'>88</a> the result of the comparison is unspecified.
</p></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><p >Otherwise, if the pointers are both null, both point to the same
<span class='indexparent'><a class='index' id=':address'></a></span>function, or both
<a href='basic.compound#def:represents_the_address'>represent the same address</a>,
they compare equal.
</p></li><li id='2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.3'>(2.3)</a></div><p >Otherwise, the pointers compare unequal.
</p></li></ul></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L4345'>#</a></div><p >If at least one of the operands is a pointer to member, <a href='conv.mem'>pointer to member
conversions</a> and <a href='conv.qual'>qualification
conversions</a> are performed on both operands to bring them to
their <a href='expr#def:composite_pointer_type'>composite pointer type</a>.
Comparing pointers to members is defined as follows:</p><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >If two pointers to members are both the null member pointer value, they compare
equal.</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p >If only one of two pointers to members is the null member pointer value, they
compare unequal.</p></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><p >If either is a pointer to a virtual member function, the result is unspecified.</p></li><li id='3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.4'>(3.4)</a></div><p >If one refers to a member of class <span class='texttt'>C1</span> and the other refers to a member
of a different class <span class='texttt'>C2</span>, where neither is a base class of the other,
the result is unspecified.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
struct A {};
struct B : A { int x; };
struct C : A { int x; };

int A::*bx = (int(A::*))&amp;B::x;
int A::*cx = (int(A::*))&amp;C::x;

bool b1 = (bx == cx);   <span class='comment'>// unspecified
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></li><li id='3.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.5'>(3.5)</a></div><p >If both refer to (possibly different) members of the same <a href='class.union'>union</a>,
they compare equal.</p></li><li id='3.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.6'>(3.6)</a></div><p >Otherwise, two pointers to members compare equal if they would refer to the same member of
the same <a href='intro.object#def:most_derived_object'>most derived object</a> or the same subobject if
indirection with a hypothetical object of the associated
class type were performed, otherwise they compare unequal.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><pre class='codeblock'>
struct B {
  int f();
};
struct L : B { };
struct R : B { };
struct D : L, R { };

int (B::*pb)() = &amp;B::f;
int (L::*pl)() = pb;
int (R::*pr)() = pb;
int (D::*pdl)() = pl;
int (D::*pdr)() = pr;
bool x = (pdl == pdr);          <span class='comment'>// <span class='tcode_in_codeblock'>false</span>
</span>bool y = (pb == pl);            <span class='comment'>// <span class='tcode_in_codeblock'>true</span>
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] 
</p></li></ul></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L4411'>#</a></div><p >Two operands of type <span class='texttt'>std&#x200b;::&#x200b;nullptr_&shy;t</span> or one operand of type
<span class='texttt'>std&#x200b;::&#x200b;nullptr_&shy;t</span> and the other a null pointer constant compare equal.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L4415'>#</a></div><p >If two operands compare equal, the result is <span class='texttt'>true</span> for
the <span class='texttt'>==</span> operator and <span class='texttt'>false</span> for the <span class='texttt'>!=</span> operator. If two operands
compare unequal, the result is <span class='texttt'>false</span> for the <span class='texttt'>==</span> operator and
<span class='texttt'>true</span> for the <span class='texttt'>!=</span> operator. Otherwise, the result of each of the
operators is unspecified.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L4422'>#</a></div><p >If both operands are of arithmetic or enumeration type, the usual arithmetic
conversions are performed on both operands; each of the operators shall yield
<span class='texttt'>true</span> if the specified relationship is true and <span class='texttt'>false</span> if it is
false.</p></div><div class='footnote' id='footnote-88'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-88'>88)</a></div><p >An object that is not an array element is
considered to belong to a single-element array for this purpose;
see <a href='expr.unary.op'>[expr.unary.op]</a>.</p></div></div></body></html>