<!DOCTYPE html><html lang='en'><head><title>[associative.reqmts]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>23</a> Containers library <a class='abbr_ref' href='./#containers'>[containers]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>23.2</a> Container requirements <a class='abbr_ref' href='container.requirements#associative.reqmts'>[container.requirements]</a></h2><div id='associative.reqmts'><h3 ><a class='secnum' style='min-width:103pt'>23.2.6</a> Associative containers <a class='abbr_ref'>[associative.reqmts]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Associative containers provide fast retrieval of data based on keys.
The library provides four basic kinds of associative containers:
<span class='texttt'>set</span>,
<span class='texttt'>multiset</span>,
<span class='texttt'>map</span>
and
<span class='texttt'>multimap</span>.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Each associative container is parameterized on
<span class='texttt'>Key</span>
and an ordering relation
<span class='texttt'>Compare</span>
that induces a strict weak ordering (<a href='alg.sorting'>[alg.sorting]</a>) on
elements of
<span class='texttt'>Key</span>.
In addition,
<span class='texttt'>map</span>
and
<span class='texttt'>multimap</span>
associate an arbitrary <a class='hidden_link' href='#def:mapped_type' id='def:mapped_type'><i>mapped type</i></a>
<span class='texttt'>T</span>
with the
<span class='texttt'>Key</span>.
The object of type
<span class='texttt'>Compare</span>
is called the
<a class='hidden_link' href='#def:comparison_object' id='def:comparison_object'><i>comparison object</i></a>
of a container.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The phrase “equivalence of keys” means the equivalence relation imposed by the
comparison and
<i>not</i>
the
<span class='texttt'>operator==</span>
on keys.
That is, two keys
<span class='texttt'>k1</span>
and
<span class='texttt'>k2</span>
are considered to be equivalent if for the
comparison object
<span class='texttt'>comp</span>,
<span class='texttt'>comp(k1, k2) == false &amp;&amp; comp(k2, k1) == false</span>.
For any two keys
<span class='texttt'>k1</span>
and
<span class='texttt'>k2</span>
in the same container, calling
<span class='texttt'>comp(k1, k2)</span>
shall always return the same value.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >An associative container supports <a class='hidden_link' href='#def:unique_keys' id='def:unique_keys'><i>unique keys</i></a> if it may contain at
most one element for each key. Otherwise, it supports <a class='hidden_link' href='#def:equivalent_keys' id='def:equivalent_keys'><i>equivalent keys</i></a>.
The <span class='texttt'>set</span> and <span class='texttt'>map</span> classes support unique keys; the <span class='texttt'>multiset</span>
and <span class='texttt'>multimap</span> classes support equivalent keys.
For <span class='texttt'>multiset</span> and <span class='texttt'>multimap</span>,
<span class='texttt'>insert</span>, <span class='texttt'>emplace</span>, and <span class='texttt'>erase</span> preserve the relative ordering
of equivalent elements.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >For <span class='texttt'>set</span> and <span class='texttt'>multiset</span> the value type is the same as the key type.
For <span class='texttt'>map</span> and <span class='texttt'>multimap</span> it is equal to <span class='texttt'>pair&lt;const Key, T&gt;</span>.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='texttt'>iterator</span>
of an associative container is of the bidirectional iterator category.
For associative containers where the value type is the same as the key type, both
<span class='texttt'>iterator</span>
and
<span class='texttt'>const_iterator</span>
are constant iterators. It is unspecified whether or not
<span class='texttt'>iterator</span>
and
<span class='texttt'>const_iterator</span>
are the same type.
[&nbsp;<i>Note:</i> <span class='texttt'>iterator</span> and <span class='texttt'>const_iterator</span> have identical semantics in this case, and <span class='texttt'>iterator</span> is convertible to <span class='texttt'>const_iterator</span>. Users can avoid violating the one-definition rule by always using <span class='texttt'>const_iterator</span> in their function parameter lists. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >The associative containers meet all the requirements of Allocator-aware
containers (<a href='container.requirements.general'>[container.requirements.general]</a>), except that for
<span class='texttt'>map</span> and <span class='texttt'>multimap</span>, the requirements placed on <span class='texttt'>value_type</span>
in Table <a href='container.requirements.general#tab:containers.container.requirements'>[tab:containers.container.requirements]</a> apply instead to <span class='texttt'>key_type</span>
and <span class='texttt'>mapped_type</span>. [&nbsp;<i>Note:</i> For example, in some cases <span class='texttt'>key_type</span> and <span class='texttt'>mapped_type</span>
are required to be <span class='texttt'>CopyAssignable</span> even though the associated
<span class='texttt'>value_type</span>, <span class='texttt'>pair&lt;const key_type, mapped_type&gt;</span>, is not
<span class='texttt'>CopyAssignable</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >In Table <a href='#tab:containers.associative.requirements'>[tab:containers.associative.requirements]</a>,
<span class='texttt'>X</span> denotes an associative container class,
<span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>a2</span> denotes a value of a type with nodes compatible with type
<span class='texttt'>X</span> (Table <a href='container.node.overview#tab:containers.node.compat'>[tab:containers.node.compat]</a>),
<span class='texttt'>b</span> denotes a possibly <span class='texttt'>const</span> value of type <span class='texttt'>X</span>,
<span class='texttt'>u</span> denotes the name of a variable being declared,
<span class='texttt'>a_uniq</span> denotes a value of type <span class='texttt'>X</span>
when <span class='texttt'>X</span> supports unique keys,
<span class='texttt'>a_eq</span> denotes a value of type <span class='texttt'>X</span>
when <span class='texttt'>X</span> supports multiple keys,
<span class='texttt'>a_tran</span> denotes a possibly <span class='texttt'>const</span> value of type <span class='texttt'>X</span>
when the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
<span class='texttt'>X::key_compare::is_transparent</span> is valid
and denotes a type (<a href='temp.deduct'>[temp.deduct]</a>),
<span class='texttt'>i</span> and <span class='texttt'>j</span>
satisfy input iterator requirements and refer to elements
implicitly convertible to
<span class='texttt'>value_type</span>, <span class='texttt'>[i, j)</span>
denotes a valid range,
<span class='texttt'>p</span> denotes a valid constant iterator to <span class='texttt'>a</span>,
<span class='texttt'>q</span> denotes a valid dereferenceable constant iterator to <span class='texttt'>a</span>,
<span class='texttt'>r</span> denotes a valid dereferenceable iterator to <span class='texttt'>a</span>,
<span class='texttt'>[q1, q2)</span> denotes a valid range of constant iterators in <span class='texttt'>a</span>,
<span class='texttt'>il</span> designates an object of type <span class='texttt'>initializer_list&lt;value_type&gt;</span>,
<span class='texttt'>t</span> denotes a value of type <span class='texttt'>X::value_type</span>,
<span class='texttt'>k</span> denotes a value of type <span class='texttt'>X::key_type</span>
and <span class='texttt'>c</span> denotes a possibly <span class='texttt'>const</span> value of type <span class='texttt'>X::key_compare</span>;
<span class='texttt'>kl</span> is a value such that <span class='texttt'>a</span> is partitioned (<a href='alg.sorting'>[alg.sorting]</a>)
with respect to <span class='texttt'>c(r, kl)</span>, with <span class='texttt'>r</span> the key value of <span class='texttt'>e</span>
and <span class='texttt'>e</span> in <span class='texttt'>a</span>;
<span class='texttt'>ku</span> is a value such that <span class='texttt'>a</span> is partitioned with respect to
<span class='texttt'>!c(ku, r)</span>;
<span class='texttt'>ke</span> is a value such that <span class='texttt'>a</span> is partitioned with respect to
<span class='texttt'>c(r, ke)</span> and <span class='texttt'>!c(ke, r)</span>, with <span class='texttt'>c(r, ke)</span> implying
<span class='texttt'>!c(ke, r)</span>.
<span class='texttt'>A</span> denotes the storage allocator used by <span class='texttt'>X</span>, if any, or <span class='texttt'>allocator&lt;X::value_type&gt;</span> otherwise,
<span class='texttt'>m</span> denotes an allocator of a type convertible to <span class='texttt'>A</span>,
and <span class='texttt'>nh</span> denotes a non-const rvalue of type <span class='texttt'>X::node_type</span>.</p><div class='numberedTable' id='tab:containers.associative.requirements'>Table <a href='#tab:containers.associative.requirements'>85</a> — Associative container requirements (in addition to container)<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Assertion/note</b></td><td colspan='1' class='center'><b>Complexity</b></td></tr><tr ><td class='left'>
                        </td><td class='left'>                       </td><td colspan='1' class='center'><b>pre-/post-condition</b></td><td class='left'>                       </td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::key_type</span>     </td><td class='left'>
 <span class='texttt'>Key</span>            </td><td class='left'>
                        </td><td class='left'>
  compile time </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::mapped_type</span> (<span class='texttt'>map</span> and <span class='texttt'>multimap</span> only) </td><td class='left'>
  <span class='texttt'>T</span>             </td><td class='left'>
                        </td><td class='left'>
  compile time          </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::value_type</span> (<span class='texttt'>set</span> and <span class='texttt'>multiset</span> only) </td><td class='left'>
 <span class='texttt'>Key</span>            </td><td class='left'>
  <i>Requires:</i> <span class='texttt'>value_type</span> is <span class='texttt'>Erasable</span> from <span class='texttt'>X</span> </td><td class='left'>
  compile time </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::value_type</span> (<span class='texttt'>map</span> and <span class='texttt'>multimap</span> only) </td><td class='left'>
 <span class='texttt'>pair&lt;const Key, T&gt;</span>            </td><td class='left'>
  <i>Requires:</i> <span class='texttt'>value_type</span> is <span class='texttt'>Erasable</span> from <span class='texttt'>X</span> </td><td class='left'>
  compile time </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::key_compare</span>  </td><td class='left'>
  <span class='texttt'>Compare</span>       </td><td class='left'>
  <i>Requires:</i> <span class='texttt'>key_compare</span> is <span class='texttt'>CopyConstructible</span>. </td><td class='left'>
  compile time   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::value_compare</span>           </td><td class='left'>
 a binary predicate type           </td><td class='left'>
 is the same as <span class='texttt'>key_compare</span> for <span class='texttt'>set</span> and
 <span class='texttt'>multiset</span>; is an ordering relation on pairs induced by the
 first component (i.e., <span class='texttt'>Key</span>) for <span class='texttt'>map</span> and <span class='texttt'>multimap</span>. </td><td class='left'>
 compile time                       </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::node_type</span> </td><td class='left'>
 a specialization of a <span class='texttt'><i>node_handle</i></span>
 class template, such that the public nested types are
 the same types as the corresponding types in <span class='texttt'>X</span>. </td><td class='left'>
 see <a href='container.node'>[container.node]</a> </td><td class='left'>
 compile time </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X(c)</span><br/>
<span class='texttt'>X u(c);</span>                         </td><td class='left'>
                                        </td><td class='left'>
  <i>Effects:</i> Constructs an empty container.
  Uses a copy of <span class='texttt'>c</span> as a comparison object.  </td><td class='left'>
 constant                               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X()</span><br/><span class='texttt'>X u;</span>                      </td><td class='left'>
                                                </td><td class='left'>
  <i>Requires:</i> <span class='texttt'>key_compare</span> is <span class='texttt'>DefaultConstructible</span>.<br/>
  <i>Effects:</i> Constructs an empty container.
  Uses <span class='texttt'>Compare()</span> as a comparison object  </td><td class='left'>
  constant                                       </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X(i,j,c)</span><br/>
<span class='texttt'>X u(i,j,c);</span>     </td><td class='left'>
                        </td><td class='left'>
  <i>Requires:</i> <span class='texttt'>value_type</span> is <span class='texttt'>EmplaceConstructible</span> into <span class='texttt'>X</span> from <span class='texttt'>*i</span>.<br/>
  <i>Effects:</i> Constructs an empty container and inserts elements from the
  range <span class='texttt'>[i, j)</span> into it; uses <span class='texttt'>c</span> as a comparison object. </td><td class='left'>
  <span class='math'><span class='mathalpha'>N</span> <span class="mathrm">log</span> <span class='mathalpha'>N</span></span> in general, where <span class='math'><span class='mathalpha'>N</span></span> has the value <span class='texttt'>distance(i, j)</span>;
  linear if <span class='texttt'>[i, j)</span> is sorted with <span class='texttt'>value_comp()</span> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X(i,j)</span><br/><span class='texttt'>X u(i,j);</span>    </td><td class='left'>
                                    </td><td class='left'>
  <i>Requires:</i> <span class='texttt'>key_compare</span> is <span class='texttt'>DefaultConstructible</span>.
  <span class='texttt'>value_type</span> is <span class='texttt'>EmplaceConstructible</span> into <span class='texttt'>X</span> from <span class='texttt'>*i</span>.<br/>
  <i>Effects:</i> Same as above, but uses <span class='texttt'>Compare()</span> as a comparison object.  </td><td class='left'>
  same as above                      </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X(il)</span>            </td><td class='left'>
                          </td><td class='left'>
  Same as <span class='texttt'>X(il.begin(), il.end())</span>.  </td><td class='left'>
  Same as <span class='texttt'>X(il.begin(), il.end())</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X(il,c)</span>          </td><td class='left'>
                          </td><td class='left'>
  Same as <span class='texttt'>X(il.begin(), il.end(), c)</span>.  </td><td class='left'>
  Same as <span class='texttt'>X(il.begin(), il.end(), c)</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a = il</span>     </td><td class='left'>
  <span class='texttt'>X&amp;</span>               </td><td class='left'>
  <i>Requires:</i> <span class='texttt'>value_type</span> is
  <span class='texttt'>CopyInsertable</span> into <span class='texttt'>X</span>
  and <span class='texttt'>CopyAssignable</span>.<br/>
  <i>Effects:</i> Assigns the range <span class='texttt'>[il.begin(), il.end())</span> into <span class='texttt'>a</span>. All
  existing elements of <span class='texttt'>a</span> are either assigned to or destroyed. </td><td class='left'>
  <span class='math'><span class='mathalpha'>N</span> <span class="mathrm">log</span> <span class='mathalpha'>N</span></span> in general, where <span class='math'><span class='mathalpha'>N</span></span> has the value <span class='texttt'>il.size() + a.size()</span>;
  linear if <span class='texttt'>[il.begin(), il.end())</span> is sorted with <span class='texttt'>value_comp()</span>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.key_comp()</span>       </td><td class='left'>
 <span class='texttt'>X::key_compare</span>    </td><td class='left'>
 returns the comparison object out of which <span class='texttt'>b</span> was constructed. </td><td class='left'>
 constant                   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.value_comp()</span>     </td><td class='left'>
 <span class='texttt'>X::value_compare</span>  </td><td class='left'>
 returns an object of <span class='texttt'>value_compare</span> constructed out of the comparison object </td><td class='left'>
 constant                   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a_uniq.</span> <span class='texttt'>emplace(args)</span> </td><td class='left'>
 <span class='texttt'>pair&lt;iterator,</span> <span class='texttt'>bool&gt;</span> </td><td class='left'>
  <i>Requires:</i> <span class='texttt'>value_type</span> shall be <span class='texttt'>EmplaceConstructible</span> into <span class='texttt'>X</span> from <span class='texttt'>args</span>.<br/>
  <i>Effects:</i> Inserts a <span class='texttt'>value_type</span> object <span class='texttt'>t</span> constructed with
  <span class='texttt'>std::forward&lt;Args&gt;(args)...</span> if and only if there is no
  element in the container with key equivalent to the key of <span class='texttt'>t</span>.
  The <span class='texttt'>bool</span> component of the returned
  pair is <span class='texttt'>true</span> if and only if the insertion takes place, and the iterator
  component of the pair points to the element with key equivalent to the
  key of <span class='texttt'>t</span>.  </td><td class='left'>
  logarithmic </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a_eq.</span> <span class='texttt'>emplace(args)</span>  </td><td class='left'>
 <span class='texttt'>iterator</span>    </td><td class='left'>
 <i>Requires:</i> <span class='texttt'>value_type</span> shall be <span class='texttt'>EmplaceConstructible</span> into <span class='texttt'>X</span> from <span class='texttt'>args</span>.<br/>
 <i>Effects:</i> Inserts a <span class='texttt'>value_type</span> object <span class='texttt'>t</span> constructed with
 <span class='texttt'>std::forward&lt;Args&gt;(args)...</span> and returns the iterator pointing
 to the newly inserted element.
 If a range containing elements equivalent to <span class='texttt'>t</span> exists in <span class='texttt'>a_eq</span>,
 <span class='texttt'>t</span> is inserted at the end of that range. </td><td class='left'>
 logarithmic    </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.emplace_hint(p, args)</span>  </td><td class='left'>
 <span class='texttt'>iterator</span>    </td><td class='left'>
 equivalent to <span class='texttt'>a.emplace(</span> <span class='texttt'>std::forward&lt;Args&gt;(args)...)</span>.
 Return value is an iterator pointing to the element with the key equivalent
 to the newly inserted element.
 The element is inserted as close as possible to the position just prior
 to <span class='texttt'>p</span>.  </td><td class='left'>
 logarithmic in general, but amortized constant if the element
 is inserted right before <span class='texttt'>p</span>    </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a_uniq.</span> <span class='texttt'>insert(t)</span>      </td><td class='left'>
  <span class='texttt'>pair&lt;iterator, bool&gt;</span>   </td><td class='left'>
  <i>Requires:</i> If <span class='texttt'>t</span> is a non-const rvalue expression, <span class='texttt'>value_type</span> shall be
  <span class='texttt'>MoveInsertable</span> into <span class='texttt'>X</span>; otherwise, <span class='texttt'>value_type</span> shall be
  <span class='texttt'>CopyInsertable</span> into <span class='texttt'>X</span>.<br/>
  <i>Effects:</i> Inserts <span class='texttt'>t</span> if and only if there is no element in the container
  with key equivalent to the key of <span class='texttt'>t</span>. The <span class='texttt'>bool</span> component of
  the returned pair is <span class='texttt'>true</span> if and only if the insertion
  takes place, and the <span class='texttt'>iterator</span>
  component of the pair points to the element with key
  equivalent to the key of <span class='texttt'>t</span>.    </td><td class='left'>
  logarithmic                    </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a_eq.insert(t)</span>        </td><td class='left'>
  <span class='texttt'>iterator</span>               </td><td class='left'>
  <i>Requires:</i> If <span class='texttt'>t</span> is a non-const rvalue expression, <span class='texttt'>value_type</span> shall be
  <span class='texttt'>MoveInsertable</span> into <span class='texttt'>X</span>; otherwise, <span class='texttt'>value_type</span> shall be
  <span class='texttt'>CopyInsertable</span> into <span class='texttt'>X</span>.<br/>
  <i>Effects:</i> Inserts <span class='texttt'>t</span> and returns the iterator pointing
  to the newly inserted element.
  If a range containing elements equivalent to
  <span class='texttt'>t</span> exists in <span class='texttt'>a_eq</span>, <span class='texttt'>t</span>
  is inserted at the end of that range. </td><td class='left'>
  logarithmic                    </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.insert(</span><br/>
  <span class='texttt'>p, t)</span>                         </td><td class='left'>
  <span class='texttt'>iterator</span>               </td><td class='left'>
  <i>Requires:</i> If <span class='texttt'>t</span> is a non-const rvalue expression, <span class='texttt'>value_type</span> shall be
  <span class='texttt'>MoveInsertable</span> into <span class='texttt'>X</span>; otherwise, <span class='texttt'>value_type</span> shall be
  <span class='texttt'>CopyInsertable</span> into <span class='texttt'>X</span>.<br/>
  <i>Effects:</i> Inserts <span class='texttt'>t</span> if and only if there is no element with key
  equivalent to the key of <span class='texttt'>t</span> in containers with unique keys;
  always inserts <span class='texttt'>t</span> in containers with equivalent keys. Always
  returns the iterator pointing to the element with key equivalent to
  the key of <span class='texttt'>t</span>. <span class='texttt'>t</span> is inserted as close as possible to the position
  just prior to <span class='texttt'>p</span>.</td><td class='left'>
  logarithmic in general, but amortized constant if <span class='texttt'>t</span>
  is inserted right before <span class='texttt'>p</span>. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.insert(</span><br/>
  <span class='texttt'>i, j)</span>          </td><td class='left'>
  <span class='texttt'>void</span>                   </td><td class='left'>
  <i>Requires:</i> <span class='texttt'>value_type</span> shall be <span class='texttt'>EmplaceConstructible</span> into <span class='texttt'>X</span> from <span class='texttt'>*i</span>.<br/>
  pre: <span class='texttt'>i</span>, <span class='texttt'>j</span> are not iterators into <span class='texttt'>a</span>.
  inserts each element from the range <span class='texttt'>[i, j)</span> if and only if there
  is no element with key equivalent to the key of that element in containers
  with unique keys; always inserts that element in containers with equivalent keys.  </td><td class='left'>
  <span class='math'><span class='mathalpha'>N</span><span class="mathrm">log</span> (<span class='texttt'>a.size()</span> + <span class='mathalpha'>N</span>)</span>, where <span class='math'><span class='mathalpha'>N</span></span> has the value <span class='texttt'>distance(i, j)</span> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.insert(il)</span>           </td><td class='left'>
  <span class='texttt'>void</span>                  </td><td class='left'>
  Equivalent to <span class='texttt'>a.insert(il.begin(), il.end())</span>. </td><td class='left'>
                                          </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a_uniq.</span><br/>
 <span class='texttt'>insert(nh)</span>           </td><td class='left'>
 <span class='texttt'>insert_return_type</span>   </td><td class='left'>
 pre: <span class='texttt'>nh</span> is empty or
 <span class='texttt'>a_uniq.get_allocator() == nh.get_allocator()</span>.<br/>
 <i>Effects:</i> If <span class='texttt'>nh</span> is empty, has no effect. Otherwise, inserts the
 element owned by <span class='texttt'>nh</span> if and only if there is no element in the
 container with a key equivalent to <span class='texttt'>nh.key()</span>.<br/>
 post: If <span class='texttt'>nh</span> is empty, <span class='texttt'>inserted</span> is <span class='texttt'>false</span>,
 <span class='texttt'>position</span> is <span class='texttt'>end()</span>, and <span class='texttt'>node</span> is empty.
 Otherwise if the insertion took place, <span class='texttt'>inserted</span> is <span class='texttt'>true</span>,
 <span class='texttt'>position</span> points to the inserted element, and <span class='texttt'>node</span> is empty;
 if the insertion failed, <span class='texttt'>inserted</span> is <span class='texttt'>false</span>,
 <span class='texttt'>node</span> has the previous value of <span class='texttt'>nh</span>, and <span class='texttt'>position</span>
 points to an element with a key equivalent to <span class='texttt'>nh.key()</span>. </td><td class='left'>
 logarithmic                             </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a_eq.</span><br/>
 <span class='texttt'>insert(nh)</span>           </td><td class='left'>
 <span class='texttt'>iterator</span>   </td><td class='left'>
 pre: <span class='texttt'>nh</span> is empty or
 <span class='texttt'>a_eq.get_allocator() == nh.get_allocator()</span>.<br/>
 <i>Effects:</i> If <span class='texttt'>nh</span> is empty, has no effect and returns <span class='texttt'>a_eq.end()</span>.
 Otherwise, inserts the element owned by <span class='texttt'>nh</span> and returns an iterator
 pointing to the newly inserted element. If a range containing elements with
 keys equivalent to <span class='texttt'>nh.key()</span> exists in <span class='texttt'>a_eq</span>, the element is
 inserted at the end of that range.<br/>
 post: <span class='texttt'>nh</span> is empty. </td><td class='left'>
 logarithmic                             </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.insert(p, nh)</span>           </td><td class='left'>
 <span class='texttt'>iterator</span>   </td><td class='left'>
 pre: <span class='texttt'>nh</span> is empty or
 <span class='texttt'>a.get_allocator() == nh.get_allocator()</span>.<br/>
 <i>Effects:</i> If <span class='texttt'>nh</span> is empty, has no effect and returns <span class='texttt'>a.end()</span>.
 Otherwise, inserts the element owned by <span class='texttt'>nh</span> if and only if there
 is no element with key equivalent to <span class='texttt'>nh.key()</span> in containers with
 unique keys; always inserts the element owned by <span class='texttt'>nh</span> in containers
 with equivalent keys. Always returns the iterator pointing to the element
 with key equivalent to <span class='texttt'>nh.key()</span>. The element is inserted as close
 as possible to the position just prior to <span class='texttt'>p</span>.<br/>
 post: <span class='texttt'>nh</span> is empty if insertion succeeds, unchanged if insertion fails.  </td><td class='left'>
 logarithmic in general, but amortized constant if the element is inserted right
 before <span class='texttt'>p</span>.                             </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.extract(k)</span>              </td><td class='left'>
 <span class='texttt'>node_type</span>             </td><td class='left'>
 Removes the first element in the container with key equivalent to <span class='texttt'>k</span>.
 Returns a <span class='texttt'>node_type</span> owning the element if found, otherwise an empty
 <span class='texttt'>node_type</span>. </td><td class='left'>
 <span class='math'><span class="mathrm">log</span> (<span class='texttt'>a.size()</span>)</span>       </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.extract(q)</span>              </td><td class='left'>
 <span class='texttt'>node_type</span>             </td><td class='left'>
 Removes the element pointed to by <span class='texttt'>q</span>.
 Returns a <span class='texttt'>node_type</span> owning that element. </td><td class='left'>
 amortized constant       </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.merge(a2)</span>              </td><td class='left'>
 <span class='texttt'>void</span>             </td><td class='left'>
 pre: <span class='texttt'>a.get_allocator() == a2.get_allocator()</span>.<br/>
 Attempts to extract each element in <span class='texttt'>a2</span> and insert it into <span class='texttt'>a</span>
 using the comparison object of <span class='texttt'>a</span>. In containers with unique keys,
 if there is an element in <span class='texttt'>a</span> with key equivalent to the key of an
 element from <span class='texttt'>a2</span>, then that element is not extracted from <span class='texttt'>a2</span>.<br/>
 post: Pointers and references to the transferred elements of <span class='texttt'>a2</span>
 refer to those same elements but as members of <span class='texttt'>a</span>. Iterators referring
 to the transferred elements will continue to refer to their elements, but
 they now behave as iterators into <span class='texttt'>a</span>, not into <span class='texttt'>a2</span>.<br/>
 <i>Throws:</i> Nothing unless the comparison object throws.  </td><td class='left'>
 <span class='math'><span class='mathalpha'>N</span> <span class="mathrm">log</span>(<span class='texttt'>a.size()+</span> <span class='mathalpha'>N</span>)</span>, where <span class='math'><span class='mathalpha'>N</span></span> has the value <span class='texttt'>a2.size()</span>.    </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.erase(k)</span>              </td><td class='left'>
 <span class='texttt'>size_type</span>             </td><td class='left'>
 erases all elements in the container with key equivalent to
 <span class='texttt'>k</span>. returns the number of erased elements.  </td><td class='left'>
 <span class='math'><span class="mathrm">log</span> (<span class='texttt'>a.size()</span>) + <span class='texttt'>a.count(k)</span></span>       </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.erase(q)</span>              </td><td class='left'>
 <span class='texttt'>iterator</span>               </td><td class='left'>
 erases the element pointed to by <span class='texttt'>q</span>. Returns an iterator pointing to
 the element immediately following <span class='texttt'>q</span> prior to the element being erased.
 If no such element exists, returns <span class='texttt'>a.end()</span>.     </td><td class='left'>
 amortized constant             </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.erase(r)</span>              </td><td class='left'>
 <span class='texttt'>iterator</span>               </td><td class='left'>
 erases the element pointed to by <span class='texttt'>r</span>. Returns an iterator pointing to
 the element immediately following <span class='texttt'>r</span> prior to the element being erased.
 If no such element exists, returns <span class='texttt'>a.end()</span>.     </td><td class='left'>
 amortized constant             </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.erase(</span><br/>
 <span class='texttt'>q1, q2)</span>  </td><td class='left'>
 <span class='texttt'>iterator</span>        </td><td class='left'>
 erases all the elements in the range <span class='texttt'>[q1, q2)</span>. Returns an iterator pointing to
 the element pointed to by <span class='texttt'>q2</span> prior to any elements being erased. If no such element
 exists, <span class='texttt'>a.end()</span> is returned.  </td><td class='left'>
 <span class='math'><span class="mathrm">log</span>(<span class='texttt'>a.size()</span>) + <span class='mathalpha'>N</span></span>, where <span class='math'><span class='mathalpha'>N</span></span> has the value <span class='texttt'>distance(q1, q2)</span>.    </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.clear()</span>       </td><td class='left'>
 <span class='texttt'>void</span>           </td><td class='left'>
 <span class='texttt'>a.erase(a.begin(),a.end())</span><br/>
 post: <span class='texttt'>a.empty()</span> returns <span class='texttt'>true</span>.  </td><td class='left'>
 linear in <span class='texttt'>a.size()</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.find(k)</span>       </td><td class='left'>
 <span class='texttt'>iterator</span>; <span class='texttt'>const_iterator</span> for constant <span class='texttt'>b</span>.  </td><td class='left'>
 returns an iterator pointing to an element with the key equivalent
 to <span class='texttt'>k</span>, or <span class='texttt'>b.end()</span> if such an element is not found    </td><td class='left'>
 logarithmic            </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a_tran.</span><br/>
 <span class='texttt'>find(ke)</span>       </td><td class='left'>
 <span class='texttt'>iterator</span>; <span class='texttt'>const_iterator</span> for constant <span class='texttt'>a_tran</span>.  </td><td class='left'>
 returns an iterator pointing to an element with key <span class='texttt'>r</span> such that
 <span class='texttt'>!c(r, ke) &amp;&amp; !c(ke, r)</span>, or <span class='texttt'>a_tran.end()</span> if such an element
 is not found    </td><td class='left'>
 logarithmic            </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.count(k)</span>        </td><td class='left'>
 <span class='texttt'>size_type</span>        </td><td class='left'>
 returns the number of elements with key equivalent to <span class='texttt'>k</span>    </td><td class='left'>
 <span class='math'><span class="mathrm">log</span> (<span class='texttt'>b.size()</span>) + <span class='texttt'>b.count(k)</span></span>   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a_tran.</span><br/>
 <span class='texttt'>count(ke)</span>        </td><td class='left'>
 <span class='texttt'>size_type</span>        </td><td class='left'>
 returns the number of elements with key <span class='texttt'>r</span> such that
 <span class='texttt'>!c(r, ke) &amp;&amp; !c(ke, r)</span>    </td><td class='left'>
 <span class='math'><span class="mathrm">log</span> (<span class='texttt'>a_tran.size()</span>) + <span class='texttt'>a_tran.count(ke)</span></span>   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.lower_bound(k)</span>   </td><td class='left'>
 <span class='texttt'>iterator</span>; <span class='texttt'>const_iterator</span> for constant <span class='texttt'>b</span>.  </td><td class='left'>
 returns an iterator pointing to the first element with
 key not less than <span class='texttt'>k</span>,
 or <span class='texttt'>b.end()</span> if such an element is not found.   </td><td class='left'>
 logarithmic            </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a_tran.</span><br/>
 <span class='texttt'>lower_bound(kl)</span>   </td><td class='left'>
 <span class='texttt'>iterator</span>; <span class='texttt'>const_iterator</span> for constant <span class='texttt'>a_tran</span>.  </td><td class='left'>
 returns an iterator pointing to the first element with
 key <span class='texttt'>r</span> such that <span class='texttt'>!c(r, kl)</span>,
 or <span class='texttt'>a_tran.end()</span> if such an element is not found.   </td><td class='left'>
 logarithmic            </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.upper_bound(k)</span>       </td><td class='left'>
 <span class='texttt'>iterator</span>; <span class='texttt'>const_iterator</span> for constant <span class='texttt'>b</span>.  </td><td class='left'>
 returns an iterator pointing to the first element with
 key greater than <span class='texttt'>k</span>,
 or <span class='texttt'>b.end()</span> if such an element is not found.   </td><td class='left'>
 logarithmic                    </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a_tran.</span><br/>
 <span class='texttt'>upper_bound(ku)</span>       </td><td class='left'>
 <span class='texttt'>iterator</span>; <span class='texttt'>const_iterator</span> for constant <span class='texttt'>a_tran</span>.  </td><td class='left'>
 returns an iterator pointing to the first element with
 key <span class='texttt'>r</span> such that <span class='texttt'>c(ku, r)</span>,
 or <span class='texttt'>a_tran.end()</span> if such an element is not found.   </td><td class='left'>
 logarithmic                    </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.equal_range(k)</span>       </td><td class='left'>
 <span class='texttt'>pair&lt;iterator, iterator&gt;</span>;
 <span class='texttt'>pair&lt;const_iterator, const_iterator&gt;</span> for constant <span class='texttt'>b</span>.     </td><td class='left'>
 equivalent to <span class='texttt'>make_pair(b.lower_bound(k), b.upper_bound(k))</span>.    </td><td class='left'>
 logarithmic                    </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a_tran.</span><br/>
 <span class='texttt'>equal_range(ke)</span>       </td><td class='left'>
 <span class='texttt'>pair&lt;iterator, iterator&gt;</span>;
 <span class='texttt'>pair&lt;const_iterator, const_iterator&gt;</span> for constant <span class='texttt'>a_tran</span>.     </td><td class='left'>
 equivalent to <span class='texttt'>make_pair(</span><br/>
 <span class='texttt'>a_tran.lower_bound(ke), a_tran.upper_bound(ke))</span>.    </td><td class='left'>
 logarithmic                    </td></tr></table></div></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >The <span class='texttt'>insert</span> and <span class='texttt'>emplace</span> members shall not affect the validity of
iterators and references to the container,
and the <span class='texttt'>erase</span> members shall invalidate only iterators and
references to the erased elements.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >The <span class='texttt'>extract</span> members invalidate only iterators to the removed element;
pointers and references to the removed element remain valid. However, accessing
the element through such pointers and references while the element is owned by
a <span class='texttt'>node_type</span> is undefined behavior. References and pointers to an element
obtained while it is owned by a <span class='texttt'>node_type</span> are invalidated if the element
is successfully inserted.</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >The fundamental property of iterators of associative containers is that they iterate through the containers
in the non-descending order of keys where non-descending is defined by the comparison that was used to
construct them.
For any two dereferenceable iterators
<span class='texttt'>i</span>
and
<span class='texttt'>j</span>
such that distance from
<span class='texttt'>i</span>
to
<span class='texttt'>j</span>
is positive, the following condition holds:</p><pre class='codeblock'>
value_comp(*j, *i) == false
</pre></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >For associative containers with unique keys the stronger condition holds:</p><pre class='codeblock'>
value_comp(*i, *j) != false
</pre></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p >When an associative container is constructed by passing a comparison object the
container shall not store a pointer or reference to the passed object,
even if that object is passed by reference.
When an associative container is copied, either through a copy constructor
or an assignment operator,
the target container shall then use the comparison object from the container
being copied,
as if that comparison object had been passed to the target container in
its constructor.</p></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><p >The member function templates <span class='texttt'>find</span>, <span class='texttt'>count</span>, <span class='texttt'>lower_bound</span>,
<span class='texttt'>upper_bound</span>, and <span class='texttt'>equal_range</span> shall not participate in overload
resolution unless the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Compare::is_transparent</span> is valid
and denotes a type (<a href='temp.deduct'>[temp.deduct]</a>).</p><p ><span class='indexparent'><a class='index' id='associative_containers,exception_safety'></a></span><span class='indexparent'><a class='index' id='associative_containers,requirements'></a></span></p></div><div id='except'><h4 ><a class='secnum' href='#except' style='min-width:118pt'>23.2.6.1</a> Exception safety guarantees <a class='abbr_ref' href='associative.reqmts.except'>[associative.reqmts.except]</a></h4><div class='para' id='except-1'><div class='marginalizedparent'><a class='marginalized' href='#except-1'>1</a></div><p >For associative containers, no <span class='texttt'>clear()</span> function throws an exception.
<span class='texttt'>erase(k)</span> does not throw an exception unless that exception is thrown
by the container's <span class='texttt'>Compare</span> object (if any).</p></div><div class='para' id='except-2'><div class='marginalizedparent'><a class='marginalized' href='#except-2'>2</a></div><p >For associative containers, if an exception is thrown by any operation from
within an <span class='texttt'>insert</span> or <span class='texttt'>emplace</span> function inserting a single element, the
insertion has no effect.</p></div><div class='para' id='except-3'><div class='marginalizedparent'><a class='marginalized' href='#except-3'>3</a></div><p >For associative containers, no <span class='texttt'>swap</span> function throws an exception unless
that exception is thrown by the
swap of the container's <span class='texttt'>Compare</span> object (if any).</p><p ><span class='indexparent'><a class='index' id='unordered_associative_containers'></a></span>
<span class='indexparent'><a class='index' id='associative_containers,unordered'></a></span>
<span class='indexparent'><a class='index' id='hash_tables'></a></span>
</p></div></div></div></div></body></html>