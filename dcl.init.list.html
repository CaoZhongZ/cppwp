<!DOCTYPE html><html lang='en'><head><title>[dcl.init.list]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Declarators <a class='abbr_ref' href='./#dcl.decl'>[dcl.decl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>8.6</a> Initializers <a class='abbr_ref' href='dcl.init#list'>[dcl.init]</a></h2><div id='dcl.init.list'><h3 ><a class='secnum' style='min-width:103pt'>8.6.4</a> List-initialization <a class='abbr_ref'>[dcl.init.list]</a></h3><p ><span class='indexparent'><a class='index' id='initialization,list-initialization'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/cdefe2d0e11ad1081871542bc312fd93bbfd6ca0/source/declarators.tex#L3693'>#</a></div><p ><span class='grammarterm'>List-initialization</span> is initialization of an object or reference from a
<i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>. Such an initializer is called an <a class='hidden_link' href='#def:initializer
list' id='def:initializer
list'><i>initializer
list</i></a>, and the comma-separated <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>s of the list are
called the <a class='hidden_link' href='#def:elements' id='def:elements'><i>elements</i></a> of the initializer list. An initializer list may be empty.
List-initialization can occur in direct-initialization or copy-initialization contexts;
list-initialization in a direct-initialization context is called
<span class='grammarterm'>direct-list-initialization</span> and list-initialization in a
copy-initialization context is called <span class='grammarterm'>copy-list-initialization</span>. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
List-initialization can be used</p><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p >as the initializer in a variable definition (<a href='dcl.init'>[dcl.init]</a>)
</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p >as the initializer in a <i><a href="expr.new#nt:new-expression">new-expression</a></i>
</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p >in a <a href='stmt.return'>return statement</a>
</p></li><li id='1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.4'>(1.4)</a></div><p >as a <i><a href="stmt.iter#nt:for-range-initializer">for-range-initializer</a></i>
</p></li><li id='1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.5'>(1.5)</a></div><p >as a function argument (<a href='expr.call'>[expr.call]</a>)
</p></li><li id='1.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.6'>(1.6)</a></div><p >as a <a href='expr.sub'>subscript</a>
</p></li><li id='1.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.7'>(1.7)</a></div><p >as an argument to a constructor invocation (<a href='dcl.init'>[dcl.init]</a>, <a href='expr.type.conv'>[expr.type.conv]</a>)
</p></li><li id='1.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.8'>(1.8)</a></div><p >as an initializer for a <a href='class.mem#def:non-static_data_member'>non-static data member</a>
</p></li><li id='1.9'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.9'>(1.9)</a></div><p >in a <i><a href="class.base.init#nt:mem-initializer">mem-initializer</a></i>
</p></li><li id='1.10'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.10'>(1.10)</a></div><p >on the right-hand side of an <a href='expr.ass'>assignment</a>
</p></li></ul><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><p ><pre class='codeblock'>
int a = {1};
std::complex&lt;double&gt; z{1,2};
new std::vector&lt;std::string&gt;{"once", "upon", "a", "time"};  <span class='comment'>// 4 string elements
</span>f( {"Nicholas","Annemarie"} );  <span class='comment'>// pass list of two elements
</span>return { "Norah" };             <span class='comment'>// return list of one element
</span>int* e {};                      <span class='comment'>// initialization to zero / null pointer
</span>x = double{1};                  <span class='comment'>// explicitly construct a <span class='tcode_in_codeblock'>double</span> 
</span>std::map&lt;std::string,int&gt; anim = { {"bear",4}, {"cassowary",2}, {"tiger",7} };</pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/cdefe2d0e11ad1081871542bc312fd93bbfd6ca0/source/declarators.tex#L3730'>#</a></div><p >A constructor is an <span class='grammarterm'>initializer-list constructor</span> if its first parameter is
of type <span class='texttt'>std&#x200b;::&#x200b;initializer_&shy;list&lt;E&gt;</span> or reference to possibly cv-qualified
<span class='texttt'>std&#x200b;::&#x200b;initializer_&shy;list&lt;E&gt;</span> for some type <span class='texttt'>E</span>, and either there are no other
parameters or else all other parameters have default arguments (<a href='dcl.fct.default'>[dcl.fct.default]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> Initializer-list constructors are favored over other constructors in
list-initialization (<a href='over.match.list'>[over.match.list]</a>). Passing an initializer list as the argument
to the constructor template <span class='texttt'>template&lt;class T&gt; C(T)</span> of a class <span class='texttt'>C</span> does not
create an initializer-list constructor, because an initializer list argument causes the 
corresponding parameter to be a non-deduced context (<a href='temp.deduct.call'>[temp.deduct.call]</a>). <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
The template
<span class='texttt'>std&#x200b;::&#x200b;initializer_&shy;list</span> is not predefined; if the header
<span class='texttt'>&lt;initializer_&shy;list&gt;</span> is not included prior to a use of
<span class='texttt'>std&#x200b;::&#x200b;initializer_&shy;list</span> — even an implicit use in which the type is not
named (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>) — the program is ill-formed.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/cdefe2d0e11ad1081871542bc312fd93bbfd6ca0/source/declarators.tex#L3746'>#</a></div><p >List-initialization of an object or reference of type <span class='texttt'>T</span> is defined as follows:
</p><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >If <span class='texttt'>T</span> is an aggregate class and the initializer list has a single element
of type <span class='textit'>cv</span> <span class='texttt'>U</span>,
where <span class='texttt'>U</span> is <span class='texttt'>T</span> or a class derived from <span class='texttt'>T</span>,
the object is initialized from that element (by copy-initialization for
copy-list-initialization, or by direct-initialization for
direct-list-initialization).</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p >Otherwise, if <span class='texttt'>T</span> is a character array and the initializer list has a
single element that is an appropriately-typed string literal (<a href='dcl.init.string'>[dcl.init.string]</a>),
initialization is performed as described in that section.</p></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><p >Otherwise, if <span class='texttt'>T</span> is an aggregate, aggregate initialization is
performed (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>).</p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><p ><pre class='codeblock'>
double ad[] = { 1, 2.0 };           <span class='comment'>// OK
</span>int ai[] = { 1, 2.0 };              <span class='comment'>// error: narrowing
</span>
struct S2 {
  int m1;
  double m2, m3;
};
S2 s21 = { 1, 2, 3.0 };             <span class='comment'>// OK
</span>S2 s22 { 1.0, 2, 3 };               <span class='comment'>// error: narrowing
</span>S2 s23 { };                         <span class='comment'>// OK: default to 0,0,0
</span></pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></li><li id='3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.4'>(3.4)</a></div><p >Otherwise, if the initializer list has no elements and <span class='texttt'>T</span> is a class type with a
default constructor, the object is value-initialized.</p></li><li id='3.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.5'>(3.5)</a></div><p >Otherwise, if <span class='texttt'>T</span> is a specialization of <span class='texttt'>std&#x200b;::&#x200b;initializer_&shy;list&lt;E&gt;</span>,
the object is constructed as described below.</p></li><li id='3.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.6'>(3.6)</a></div><p >Otherwise, if <span class='texttt'>T</span> is a class type, constructors are considered.
The applicable constructors are enumerated and
the best one is chosen through overload resolution (<a href='over.match'>[over.match]</a>, <a href='over.match.list'>[over.match.list]</a>). If a narrowing
conversion (see below) is required to convert any of the arguments, the program is
ill-formed.</p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><p ><pre class='codeblock'>
struct S {
  S(std::initializer_list&lt;double&gt;); <span class='comment'>// #1
</span>  S(std::initializer_list&lt;int&gt;);    <span class='comment'>// #2
</span>  S();                              <span class='comment'>// #3
</span>  <span class='comment'>// ...
</span>};
S s1 = { 1.0, 2.0, 3.0 };           <span class='comment'>// invoke #1
</span>S s2 = { 1, 2, 3 };                 <span class='comment'>// invoke #2
</span>S s3 = { };                         <span class='comment'>// invoke #3
</span></pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><p ><pre class='codeblock'>
struct Map {
  Map(std::initializer_list&lt;std::pair&lt;std::string,int&gt;&gt;);
};
Map ship = {{"Sophie",14}, {"Surprise",28}};</pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><p ><pre class='codeblock'>
struct S {
  <span class='comment'>// no initializer-list constructors
</span>  S(int, double, double);           <span class='comment'>// #1
</span>  S();                              <span class='comment'>// #2
</span>  <span class='comment'>// ...
</span>};
S s1 = { 1, 2, 3.0 };               <span class='comment'>// OK: invoke #1
</span>S s2 { 1.0, 2, 3 };                 <span class='comment'>// error: narrowing
</span>S s3 { };                           <span class='comment'>// OK: invoke #2
</span></pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></li><li id='3.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.7'>(3.7)</a></div><p >Otherwise, if
the initializer list has a single element of type <span class='texttt'>E</span> and either
<span class='texttt'>T</span> is not a reference type or its referenced type is
reference-related to <span class='texttt'>E</span>, the object or reference is initialized
from that element (by copy-initialization for copy-list-initialization,
or by direct-initialization for direct-list-initialization);
if a narrowing conversion (see below) is required
to convert the element to <span class='texttt'>T</span>, the program is ill-formed.</p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><p ><pre class='codeblock'>
int x1 {2};                         <span class='comment'>// OK
</span>int x2 {2.0};                       <span class='comment'>// error: narrowing
</span></pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></li><li id='3.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.8'>(3.8)</a></div><p >Otherwise, if <span class='texttt'>T</span> is a reference type, a prvalue of the type
referenced by <span class='texttt'>T</span> is generated.
The prvalue initializes its result object by
copy-list-initialization or direct-list-initialization,
depending on the kind of initialization for the reference.
The prvalue is then used to direct-initialize the reference.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> As usual, the binding will fail and the program is ill-formed if
the reference type is an lvalue reference to a non-const type. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><p ><pre class='codeblock'>
struct S {
  S(std::initializer_list&lt;double&gt;); <span class='comment'>// #1
</span>  S(const std::string&amp;);            <span class='comment'>// #2
</span>  <span class='comment'>// ...
</span>};
const S&amp; r1 = { 1, 2, 3.0 };        <span class='comment'>// OK: invoke #1
</span>const S&amp; r2 { "Spinach" };          <span class='comment'>// OK: invoke #2
</span>S&amp; r3 = { 1, 2, 3 };                <span class='comment'>// error: initializer is not an lvalue
</span>const int&amp; i1 = { 1 };              <span class='comment'>// OK
</span>const int&amp; i2 = { 1.1 };            <span class='comment'>// error: narrowing
</span>const int (&amp;iar)[2] = { 1, 2 };     <span class='comment'>// OK: <span class='tcode_in_codeblock'>iar</span> is bound to temporary array
</span></pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></li><li id='3.9'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.9'>(3.9)</a></div><p >Otherwise, if <span class='texttt'>T</span> is an enumeration
with a fixed underlying type (<a href='dcl.enum'>[dcl.enum]</a>),
the <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> has a single element <span class='texttt'>v</span>, and
the initialization is direct-list-initialization,
the object is initialized with the value <span class='texttt'>T(v)</span> (<a href='expr.type.conv'>[expr.type.conv]</a>);
if a narrowing conversion is required to convert <span class='texttt'>v</span>
to the underlying type of <span class='texttt'>T</span>, the program is ill-formed.</p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><p ><pre class='codeblock'>
enum byte : unsigned char { };
byte b { 42 };                      <span class='comment'>// OK
</span>byte c = { 42 };                    <span class='comment'>// error
</span>byte d = byte{ 42 };                <span class='comment'>// OK; same value as <span class='tcode_in_codeblock'>b</span>
</span>byte e { -1 };                      <span class='comment'>// error
</span>
struct A { byte b; };
A a1 = { { 42 } };                  <span class='comment'>// error
</span>A a2 = { byte{ 42 } };              <span class='comment'>// OK
</span>
void f(byte);
f({ 42 });                          <span class='comment'>// error
</span>
enum class Handle : uint32_t { Invalid = 0 };
Handle h { 42 };                    <span class='comment'>// OK
</span></pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></li><li id='3.10'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.10'>(3.10)</a></div><p >Otherwise, if the initializer list has no elements, the object is
value-initialized.</p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><p ><pre class='codeblock'>
int** pp {};                        <span class='comment'>// initialized to null pointer
</span></pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></li><li id='3.11'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.11'>(3.11)</a></div><p >Otherwise, the program is ill-formed.</p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><p ><pre class='codeblock'>
struct A { int i; int j; };
A a1 { 1, 2 };                      <span class='comment'>// aggregate initialization 
</span>A a2 { 1.2 };                       <span class='comment'>// error: narrowing
</span>struct B {
  B(std::initializer_list&lt;int&gt;);
};
B b1 { 1, 2 };                      <span class='comment'>// creates <span class='tcode_in_codeblock'>initializer_&shy;list&lt;int&gt;</span> and calls constructor
</span>B b2 { 1, 2.0 };                    <span class='comment'>// error: narrowing
</span>struct C {
  C(int i, double j);
};
C c1 = { 1, 2.2 };                  <span class='comment'>// calls constructor with arguments (1, 2.2) 
</span>C c2 = { 1.1, 2 };                  <span class='comment'>// error: narrowing
</span>
int j { 1 };                        <span class='comment'>// initialize to 1
</span>int k { };                          <span class='comment'>// initialize to 0
</span></pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></li></ul></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/cdefe2d0e11ad1081871542bc312fd93bbfd6ca0/source/declarators.tex#L3931'>#</a></div><p >Within the <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> of a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>,
the <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>s, including any that result from pack
expansions (<a href='temp.variadic'>[temp.variadic]</a>), are evaluated in the order in which they
appear. That is, every value computation and side effect associated with a
given <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> is sequenced before every value
computation and side effect associated with any <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
that follows it in the comma-separated list of the <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> This evaluation ordering holds regardless of the semantics of the
initialization; for example, it applies when the elements of the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> are interpreted as arguments of a constructor
call, even though ordinarily there are no sequencing constraints on the
arguments of a call. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/cdefe2d0e11ad1081871542bc312fd93bbfd6ca0/source/declarators.tex#L3945'>#</a></div><p >An object of type <span class='texttt'>std&#x200b;::&#x200b;initializer_&shy;list&lt;E&gt;</span> is constructed from
an initializer list as if
the implementation generated and materialized (<a href='conv.rval'>[conv.rval]</a>)
a prvalue of type “array of <span class='math'><span class='mathalpha'>N</span></span> <span class='texttt'>const E</span>”,
where <span class='math'><span class='mathalpha'>N</span></span> is the number of elements in the
initializer list. Each element of that array is copy-initialized with the
corresponding element of the initializer list, and the
<span class='texttt'>std&#x200b;::&#x200b;initializer_&shy;list&lt;E&gt;</span> object is constructed to refer to that array.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> A constructor or conversion function selected for the copy shall be
accessible (Clause <a href='class.access'>[class.access]</a>) in the context of the initializer list.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
If a narrowing conversion is required to initialize any of the elements, the program is ill-formed. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><p ><pre class='codeblock'>
struct X {
  X(std::initializer_list&lt;double&gt; v);
};
X x{ 1,2,3 };</pre></p><p >The initialization will be implemented in a way roughly equivalent to this:</p><p ><pre class='codeblock'>
const double __a[3] = {double{1}, double{2}, double{3}};
X x(std::initializer_list&lt;double&gt;(__a, __a+3));</pre></p><p >assuming that the implementation can construct an <span class='texttt'>initializer_&shy;list</span> object with a pair of pointers. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/cdefe2d0e11ad1081871542bc312fd93bbfd6ca0/source/declarators.tex#L3974'>#</a></div><p >The array has the same lifetime as any other temporary
object (<a href='class.temporary'>[class.temporary]</a>), except that initializing an
<span class='texttt'>initializer_&shy;list</span> object from the array extends the lifetime of
the array exactly like binding a reference to a temporary.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span></p><p ><pre class='codeblock'>
typedef std::complex&lt;double&gt; cmplx;
std::vector&lt;cmplx&gt; v1 = { 1, 2, 3 };

void f() {
  std::vector&lt;cmplx&gt; v2{ 1, 2, 3 };
  std::initializer_list&lt;int&gt; i3 = { 1, 2, 3 };
}

struct A {
  std::initializer_list&lt;int&gt; i4;
  A() : i4{ 1, 2, 3 } {}  <span class='comment'>// ill-formed, would create a dangling reference
</span>};</pre></p><p >For <span class='texttt'>v1</span> and <span class='texttt'>v2</span>, the <span class='texttt'>initializer_&shy;list</span> object
is a parameter in a function call, so the array created for
<span class='texttt'>{ 1, 2, 3 }</span> has full-expression lifetime.
For <span class='texttt'>i3</span>, the <span class='texttt'>initializer_&shy;list</span> object is a variable,
so the array persists for the lifetime of the variable.
For <span class='texttt'>i4</span>, the <span class='texttt'>initializer_&shy;list</span> object is initialized in
the constructor's <i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i> as if by binding
a temporary array to a reference member, so the program is
ill-formed (<a href='class.base.init'>[class.base.init]</a>).
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
The implementation is free to allocate the array in read-only memory if an explicit array with the same initializer could be so allocated. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/cdefe2d0e11ad1081871542bc312fd93bbfd6ca0/source/declarators.tex#L4009'>#</a></div><p >A
<span class='indexparent'><a class='index' id='conversion,narrowing'></a></span><a class='hidden_link' href='#def:narrowing_conversion' id='def:narrowing_conversion'><i>narrowing conversion</i></a> is an implicit conversion</p><ul class='itemize'><li id='7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.1'>(7.1)</a></div><p >from a floating-point type to an integer type, or</p></li><li id='7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.2'>(7.2)</a></div><p >from <span class='texttt'>long double</span> to <span class='texttt'>double</span> or <span class='texttt'>float</span>, or from
<span class='texttt'>double</span> to <span class='texttt'>float</span>, except where the source is a constant expression and
the actual value after conversion
is within the range of values that can be represented (even if it cannot be represented exactly),
or</p></li><li id='7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.3'>(7.3)</a></div><p >from an integer type or unscoped enumeration type to a floating-point type, except
where the source is a constant expression and the actual value after conversion will fit
into the target type and will produce the original value when converted back to the
original type, or</p></li><li id='7.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.4'>(7.4)</a></div><p >from an integer type or unscoped enumeration type to an integer type that cannot
represent all the values of the original type, except where the source is a constant
expression whose value after integral promotions will fit into the target type.
</p></li></ul><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> As indicated above, such conversions are not allowed at the top level in
list-initializations.<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span></p><p ><pre class='codeblock'>
int x = 999;              <span class='comment'>// <span class='tcode_in_codeblock'>x</span> is not a constant expression
</span>const int y = 999;
const int z = 99;
char c1 = x;              <span class='comment'>// OK, though it might narrow (in this case, it does narrow)
</span>char c2{x};               <span class='comment'>// error: might narrow
</span>char c3{y};               <span class='comment'>// error: narrows (assuming <span class='tcode_in_codeblock'>char</span> is 8 bits)
</span>char c4{z};               <span class='comment'>// OK: no narrowing needed
</span>unsigned char uc1 = {5};  <span class='comment'>// OK: no narrowing needed
</span>unsigned char uc2 = {-1}; <span class='comment'>// error: narrows
</span>unsigned int ui1 = {-1};  <span class='comment'>// error: narrows
</span>signed int si1 =
  { (unsigned int)-1 };   <span class='comment'>// error: narrows
</span>int ii = {2.0};           <span class='comment'>// error: narrows
</span>float f1 { x };           <span class='comment'>// error: might narrow
</span>float f2 { 7 };           <span class='comment'>// OK: 7 can be exactly represented as a <span class='tcode_in_codeblock'>float</span>
</span>int f(int);
int a[] =
  { 2, f(2), f(2.0) };    <span class='comment'>// OK: the <span class='tcode_in_codeblock'>double</span>-to-<span class='tcode_in_codeblock'>int</span> conversion is not at the top level
</span></pre></p><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]
</p></div></div></div></body></html>