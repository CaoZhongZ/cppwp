<!DOCTYPE html><html lang='en'><head><title>[temp.class.spec]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.5</a> Template declarations <a class='abbr_ref' href='temp.decls#temp.class.spec'>[temp.decls]</a></h2><div id='temp.class.spec'><h3 ><a class='secnum' style='min-width:103pt'>14.5.5</a> Class template partial specializations <a class='abbr_ref'>[temp.class.spec]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='specialization,class_template_partial'></a></span><span class='indexparent'><a class='index' id='template,primary'></a></span>A
<a class='hidden_link' href='#def:primary' id='def:primary'><i>primary</i></a>
class template declaration is one in which the class template name is an
identifier.
A template declaration in which the class template name is a
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
is a
<a class='hidden_link' href='#def:partial_specialization' id='def:partial_specialization'><i>partial specialization</i></a>
of the class template named in the
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>.
A partial specialization of a class template provides an alternative definition
of the template that is used instead of the primary definition when the
arguments in a specialization match those given in the partial
specialization (<a href='temp.class.spec.match'>[temp.class.spec.match]</a>).
The primary template shall be declared before any specializations of
that template.
A partial specialization shall be declared before the first use of a class template
specialization that would make use of the partial specialization as the result of
an implicit or explicit instantiation in every translation unit in which such a use
occurs; no diagnostic is required.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Each class template partial specialization is a distinct template and
definitions shall be provided for the members of a template partial
specialization (<a href='temp.class.spec.mfunc'>[temp.class.spec.mfunc]</a>).</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T1, class T2, int I&gt; class A             { };
template&lt;class T, int I&gt;            class A&lt;T, T*, I&gt;   { };
template&lt;class T1, class T2, int I&gt; class A&lt;T1*, T2, I&gt; { };
template&lt;class T&gt;                   class A&lt;int, T*, 5&gt; { };
template&lt;class T1, class T2, int I&gt; class A&lt;T1, T2*, I&gt; { };
</pre><p >The first declaration declares the primary (unspecialized) class template.
The second and subsequent declarations declare partial specializations of
the primary template.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The template parameters are specified in the angle bracket enclosed list
that immediately follows the keyword
<span class='texttt'>template</span>.
For partial specializations, the template argument list is explicitly
written immediately following the class template name.
For primary templates, this list is implicitly described by the
template parameter list.
Specifically, the order of the template arguments is the sequence in
which they appear in the template parameter list.
[&nbsp;<i>Example:</i>
the template argument list for the primary template in the example
above is
<span class='texttt'>&lt;T1,</span>
<span class='texttt'>T2,</span>
<span class='texttt'>I&gt;</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
The template argument list shall not be specified in the primary template
declaration.
For example,</p><pre class='codeblock'>
template&lt;class T1, class T2, int I&gt; class A&lt;T1, T2, I&gt;  { };    <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A class template partial specialization may be declared or redeclared in any
namespace scope in which the corresponding primary template
may be defined (<a href='namespace.memdef'>[namespace.memdef]</a> and <a href='temp.mem'>[temp.mem]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  struct C {
    template&lt;class T2&gt; struct B { };
  };
};

<span class='comment'>// partial specialization of <span class='texttt'>A&lt;T&gt;::C::B&lt;T2&gt;</span>
</span>template&lt;class T&gt; template&lt;class T2&gt;
  struct A&lt;T&gt;::C::B&lt;T2*&gt; { };

A&lt;short&gt;::C::B&lt;int*&gt; absip;     <span class='comment'>// uses partial specialization
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >Partial specialization declarations themselves are not found by name lookup.
Rather, when the primary template name is used, any previously-declared partial
specializations of the primary template are also considered.
One consequence is
that a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>
which refers to a class template does not restrict the set of partial specializations
which may be found through the
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace N {
  template&lt;class T1, class T2&gt; class A { };         <span class='comment'>// primary template
</span>}

using N::A;                             <span class='comment'>// refers to the primary template
</span>
namespace N {
  template&lt;class T&gt; class A&lt;T, T*&gt; { }; <span class='comment'>// partial specialization
</span>}

A&lt;int,int*&gt; a;                  <span class='comment'>// uses the partial specialization, which is found through
</span>                                <span class='comment'>// the using declaration which refers to the primary template
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >A non-type argument is non-specialized if it is the name of a non-type
parameter.
All other non-type arguments are specialized.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >Within the argument list of a class template partial specialization,
the following restrictions apply:</p><ul class='itemize'><li id='8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.1'>(8.1)</a></div><p >The type of a template parameter corresponding to a specialized non-type argument
shall not be dependent on a parameter of the specialization.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template &lt;class T, T t&gt; struct C {};
template &lt;class T&gt; struct C&lt;T, 1&gt;;                  <span class='comment'>// error
</span>
template&lt; int X, int (*array_ptr)[X] &gt; class A {};
int array[5];
template&lt; int X &gt; class A&lt;X,&amp;array&gt; { };            <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li><li id='8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.2'>(8.2)</a></div><p >The specialization shall be more specialized than the primary
template (<a href='temp.class.order'>[temp.class.order]</a>).</p></li><li id='8.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.3'>(8.3)</a></div><p >The template parameter list of a specialization shall not contain default
template argument values.<a class='footnotenum' href='#footnote-140'>140</a>
</p></li><li id='8.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.4'>(8.4)</a></div><p >An argument shall not contain an unexpanded parameter pack. If
an argument is a pack expansion (<a href='temp.variadic'>[temp.variadic]</a>), it shall be
the last argument in the template argument list.
</p></li></ul></div><div class='footnote' id='footnote-140'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-140'>140)</a></div><p >There is no way in which they could be used.</p></div><div id='match'><h4 ><a class='secnum' href='#match' style='min-width:118pt'>14.5.5.1</a> Matching of class template partial specializations <a class='abbr_ref' href='temp.class.spec.match'>[temp.class.spec.match]</a></h4><div class='para' id='match-1'><div class='marginalizedparent'><a class='marginalized' href='#match-1'>1</a></div><p >When a class template is used in a context that requires an instantiation of
the class,
it is necessary to determine whether the instantiation is to be generated
using the primary template or one of the partial specializations.
This is done by matching the template arguments of the class template
specialization with the template argument lists of the partial
specializations.</p><ul class='itemize'><li id='match-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#match-1.1'>(1.1)</a></div><p >If exactly one matching specialization is found, the instantiation is
generated from that specialization.
</p></li><li id='match-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#match-1.2'>(1.2)</a></div><p >If more than one matching specialization is found,
the partial order rules (<a href='temp.class.order'>[temp.class.order]</a>) are used to determine
whether one of the specializations is more specialized than the
others.
If none of the specializations is more specialized than all of the
other matching specializations, then the use of the class template
is ambiguous and the program is ill-formed.
</p></li><li id='match-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#match-1.3'>(1.3)</a></div><p >If no matches are found, the instantiation is generated from the
primary template.
</p></li></ul></div><div class='para' id='match-2'><div class='marginalizedparent'><a class='marginalized' href='#match-2'>2</a></div><p >A partial specialization matches a given actual template argument
list if the template arguments of the partial specialization can be
deduced from the actual template argument list (<a href='temp.deduct'>[temp.deduct]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T1, class T2, int I&gt; class A             { };    <span class='comment'>// #1
</span>template&lt;class T, int I&gt;            class A&lt;T, T*, I&gt;   { };    <span class='comment'>// #2
</span>template&lt;class T1, class T2, int I&gt; class A&lt;T1*, T2, I&gt; { };    <span class='comment'>// #3
</span>template&lt;class T&gt;                   class A&lt;int, T*, 5&gt; { };    <span class='comment'>// #4
</span>template&lt;class T1, class T2, int I&gt; class A&lt;T1, T2*, I&gt; { };    <span class='comment'>// #5
</span>
A&lt;int, int, 1&gt;   a1;            <span class='comment'>// uses #1
</span>A&lt;int, int*, 1&gt;  a2;            <span class='comment'>// uses #2, <span class='texttt'>T</span> is <span class='texttt'>int</span>, <span class='texttt'>I</span> is <span class='texttt'>1</span>
</span>A&lt;int, char*, 5&gt; a3;            <span class='comment'>// uses #4, <span class='texttt'>T</span> is <span class='texttt'>char</span>
</span>A&lt;int, char*, 1&gt; a4;            <span class='comment'>// uses #5, <span class='texttt'>T1</span> is <span class='texttt'>int</span>, <span class='texttt'>T2</span> is <span class='texttt'>char</span>, <span class='texttt'>I</span> is <span class='texttt'>1</span>
</span>A&lt;int*, int*, 2&gt; a5;            <span class='comment'>// ambiguous: matches #3 and #5
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='match-3'><div class='marginalizedparent'><a class='marginalized' href='#match-3'>3</a></div><p >If the template arguments of a partial specialization cannot be deduced
because of the structure of its <i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i>
and the <i ><a href='temp.names#nt:template-id'>template-id</a></i>,
the program is ill-formed.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;int I, int J&gt; struct A {};
template &lt;int I&gt; struct A&lt;I+5, I*2&gt; {};     <span class='comment'>// error
</span>
template &lt;int I&gt; struct A&lt;I, I&gt; {};         <span class='comment'>// OK
</span>
template &lt;int I, int J, int K&gt; struct B {};
template &lt;int I&gt; struct B&lt;I, I*2, 2&gt; {};    <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='match-4'><div class='marginalizedparent'><a class='marginalized' href='#match-4'>4</a></div><p >In a type name that refers to a class template specialization, (e.g.,
<span class='texttt'>A&lt;int, int, 1&gt;</span>)
the argument list shall match the template parameter list of the primary
template.
The template arguments of a specialization are deduced from the arguments
of the primary template.</p></div></div><div id='temp.class.order'><h4 ><a class='secnum' href='#temp.class.order' style='min-width:118pt'>14.5.5.2</a> Partial ordering of class template specializations <a class='abbr_ref' href='temp.class.order'>[temp.class.order]</a></h4><div class='para' id='temp.class.order-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.order-1'>1</a></div><p ><span class='indexparent'><a class='index' id='more_specialized,class_template'></a></span>For two class template partial specializations,
the first is <a class='hidden_link' href='#def:more_specialized' id='def:more_specialized'><i>more specialized</i></a> than the second if, given the following
rewrite to two function templates, the first function template is more
specialized than the second according to the ordering rules for function
templates (<a href='temp.func.order'>[temp.func.order]</a>):</p><ul class='itemize'><li id='temp.class.order-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.class.order-1.1'>(1.1)</a></div><p >Each of the two
function templates has the same template parameters as
the corresponding partial specialization.
</p></li><li id='temp.class.order-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#temp.class.order-1.2'>(1.2)</a></div><p >Each function template
has a single function parameter
whose type is a class template specialization where the template arguments
are the corresponding template parameters from the function template
for each template argument
in the <i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i>
of the <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
of the partial specialization.
</p></li></ul></div><div class='para' id='temp.class.order-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.class.order-2'>2</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;int I, int J, class T&gt; class X { };
template&lt;int I, int J&gt;          class X&lt;I, J, int&gt; { }; <span class='comment'>// #1
</span>template&lt;int I&gt;                 class X&lt;I, I, int&gt; { }; <span class='comment'>// #2
</span>
template&lt;int I0, int J0&gt; void f(X&lt;I0, J0, int&gt;);        <span class='comment'>// A
</span>template&lt;int I0&gt;         void f(X&lt;I0, I0, int&gt;);        <span class='comment'>// B
</span>
template &lt;auto v&gt;    class Y { };
template &lt;auto* p&gt;   class Y&lt;p&gt; { };                    <span class='comment'>// #3
</span>template &lt;auto** pp&gt; class Y&lt;pp&gt; { };                   <span class='comment'>// #4
</span>
template &lt;auto* p0&gt;   void g(Y&lt;p0&gt;);                    <span class='comment'>// C
</span>template &lt;auto** pp0&gt; void g(Y&lt;pp0&gt;);                   <span class='comment'>// D
</span></pre><p >According to the ordering rules for function templates,
the function template
<span class='texttt'>B</span>
is more specialized than the function template
<span class='texttt'>A</span>
and
the function template
<span class='texttt'>D</span>
is more specialized than the function template
<span class='texttt'>C</span>.
Therefore,
the partial specialization
<span class='texttt'>#2</span>
is more specialized than the partial specialization
<span class='texttt'>#1</span>
and
the partial specialization
<span class='texttt'>#4</span>
is more specialized than the partial specialization
<span class='texttt'>#3</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='mfunc'><h4 ><a class='secnum' href='#mfunc' style='min-width:118pt'>14.5.5.3</a> Members of class template specializations <a class='abbr_ref' href='temp.class.spec.mfunc'>[temp.class.spec.mfunc]</a></h4><div class='para' id='mfunc-1'><div class='marginalizedparent'><a class='marginalized' href='#mfunc-1'>1</a></div><p >The template parameter list of a member of a class template partial
specialization shall match the template parameter list of the class template
partial specialization.
The template argument list of a member of a class template partial
specialization shall match the template argument list of the class template
partial specialization.
A class template specialization is a distinct template.
The members of the class template partial specialization are
unrelated to the members of the primary template.
Class template partial specialization members that are used in a way that
requires a definition shall be defined; the definitions of members of the
primary template are never used as definitions for members of a class
template partial specialization.
An explicit specialization of a member of a class template partial
specialization is declared in the same way as an explicit specialization of
the primary template.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
<span class='comment'>// primary template
</span>template&lt;class T, int I&gt; struct A {
  void f();
};

template&lt;class T, int I&gt; void A&lt;T,I&gt;::f() { }

<span class='comment'>// class template partial specialization
</span>template&lt;class T&gt; struct A&lt;T,2&gt; {
  void f();
  void g();
  void h();
};

<span class='comment'>// member of class template partial specialization
</span>template&lt;class T&gt; void A&lt;T,2&gt;::g() { }

<span class='comment'>// explicit specialization
</span>template&lt;&gt; void A&lt;char,2&gt;::h() { }

int main() {
  A&lt;char,0&gt; a0;
  A&lt;char,2&gt; a2;
  a0.f();                       <span class='comment'>// OK, uses definition of primary template's member
</span>  a2.g();                       <span class='comment'>// OK, uses definition of
</span>                                <span class='comment'>// partial specialization's member
</span>  a2.h();                       <span class='comment'>// OK, uses definition of
</span>                                <span class='comment'>// explicit specialization's member
</span>  a2.f();                       <span class='comment'>// ill-formed, no definition of <span class='texttt'>f</span> for <span class='texttt'>A&lt;T,2&gt;</span>
</span>                                <span class='comment'>// the primary template is not used here
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='mfunc-2'><div class='marginalizedparent'><a class='marginalized' href='#mfunc-2'>2</a></div><p >If a member template of a class template is partially specialized,
the member template partial specializations are member templates of
the enclosing class template;
if the enclosing class template is instantiated (<a href='temp.inst'>[temp.inst]</a>, <a href='temp.explicit'>[temp.explicit]</a>),
a declaration for every member template partial specialization is also
instantiated as part of creating the members of the class template
specialization.
If the primary member template is explicitly specialized for a given
(implicit) specialization of the enclosing class template,
the partial specializations of the member template are ignored for this
specialization of the enclosing class template.
If a partial specialization of the member template is explicitly specialized
for a given (implicit) specialization of the enclosing class template,
the primary member template and its other partial specializations are
still considered for this specialization of the enclosing class template.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  template&lt;class T2&gt; struct B {};                     <span class='comment'>// #1
</span>  template&lt;class T2&gt; struct B&lt;T2*&gt; {};                <span class='comment'>// #2
</span>};

template&lt;&gt; template&lt;class T2&gt; struct A&lt;short&gt;::B {};  <span class='comment'>// #3
</span>
A&lt;char&gt;::B&lt;int*&gt;  abcip;  <span class='comment'>// uses #2
</span>A&lt;short&gt;::B&lt;int*&gt; absip;  <span class='comment'>// uses #3
</span>A&lt;char&gt;::B&lt;int&gt;  abci;    <span class='comment'>// uses #1
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></div></body></html>