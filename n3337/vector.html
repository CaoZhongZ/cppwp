<!DOCTYPE html><html lang='en'><head><title>[vector]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>23</a> Containers library <a class='abbr_ref' href='./#containers'>[containers]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>23.3</a> Sequence containers <a class='abbr_ref' href='sequences#vector'>[sequences]</a></h2><div id='vector'><h3 ><a class='secnum' style='min-width:103pt'>23.3.6</a> Class template <span class='texttt'>vector</span> <a class='abbr_ref'>[vector]</a></h3><div id='overview'><h4 ><a class='secnum' href='#overview' style='min-width:118pt'>23.3.6.1</a> Class template <span class='texttt'>vector</span> overview <a class='abbr_ref' href='vector.overview'>[vector.overview]</a></h4><div class='para' id='overview-1'><div class='marginalizedparent'><a class='marginalized' href='#overview-1'>1</a></div><p ><span class='indexparent'><a class='index' id='vector'></a></span>A
<span class='texttt'>vector</span>
is a sequence container that supports random access iterators.
In addition, it supports (amortized) constant time insert and erase operations at the end;
insert and erase in the middle take linear time.
Storage management is handled automatically, though hints can be given
to improve efficiency.
The elements of a vector are stored contiguously, meaning that if
<span class='texttt'>v</span>
is a
<span class='texttt'>vector&lt;T, Allocator&gt;</span>
where
<span class='texttt'>T</span>
is some type other than
<span class='texttt'>bool</span>,
then it obeys the identity
<span class='texttt'>&amp;v[n] == &amp;v[0] + n</span>
for all
<span class='texttt'>0 &lt;= n &lt; v.size()</span>.</p></div><div class='para' id='overview-2'><div class='marginalizedparent'><a class='marginalized' href='#overview-2'>2</a></div><p >A <span class='texttt'>vector</span> satisfies all of the requirements of a container and of a
reversible container (given in two tables in <a href='container.requirements'>[container.requirements]</a>), of a
sequence container, including most of the optional sequence container
requirements (<a href='sequence.reqmts'>[sequence.reqmts]</a>), and of an allocator-aware container
(Table <a href='container.requirements.general#tab:containers.allocatoraware'>[tab:containers.allocatoraware]</a>). The exceptions are the
<span class='texttt'>push_front</span>, <span class='texttt'>pop_front</span>, and <span class='texttt'>emplace_front</span> member functions, which are not
provided. Descriptions are provided here only for operations on <span class='texttt'>vector</span>
that are not described in one of these tables or for operations where there is
additional semantic information.</p><pre class='codeblock'>
namespace std {
  template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
  class vector {
  public:
    <span class='comment'>// types:
</span>    typedef value_type&amp;                           reference;
    typedef const value_type&amp;                     const_reference;
    typedef <i>implementation-defined</i>                iterator;       <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    typedef <i>implementation-defined</i>                const_iterator; <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    typedef <i>implementation-defined</i>                size_type;      <span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    typedef <i>implementation-defined</i>                difference_type;<span class='comment'>// see <a href='container.requirements'>[container.requirements]</a>
</span>    typedef T                                     value_type;
    typedef Allocator                             allocator_type;
    typedef typename allocator_traits&lt;Allocator&gt;::pointer           pointer;
    typedef typename allocator_traits&lt;Allocator&gt;::const_pointer     const_pointer;
    typedef std::reverse_iterator&lt;iterator&gt;       reverse_iterator;
    typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;

    <span class='comment'>// <a href='vector.cons'>[vector.cons]</a>, construct/copy/destroy:
</span>    explicit vector(const Allocator&amp; = Allocator());
    explicit vector(size_type n);
    vector(size_type n, const T&amp; value, const Allocator&amp; = Allocator());
    template &lt;class InputIterator&gt;
      vector(InputIterator first, InputIterator last,
             const Allocator&amp; = Allocator());
    vector(const vector&amp; x);
    vector(vector&amp;&amp;);
    vector(const vector&amp;, const Allocator&amp;);
    vector(vector&amp;&amp;, const Allocator&amp;);
    vector(initializer_list&lt;T&gt;, const Allocator&amp; = Allocator());
   ~vector();
    vector&amp; operator=(const vector&amp; x);
    vector&amp; operator=(vector&amp;&amp; x);
    vector&amp; operator=(initializer_list&lt;T&gt;);
    template &lt;class InputIterator&gt;
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T&amp; u);
    void assign(initializer_list&lt;T&gt;);
    allocator_type get_allocator() const noexcept;

    <span class='comment'>// iterators:
</span>    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    <span class='comment'>// <a href='vector.capacity'>[vector.capacity]</a>, capacity:
</span>    size_type size() const noexcept;
    size_type max_size() const noexcept;
    void      resize(size_type sz);
    void      resize(size_type sz, const T&amp; c);
    size_type capacity() const noexcept;
    bool      empty() const noexcept;
    void      reserve(size_type n);
    void      shrink_to_fit();

    <span class='comment'>// element access:
</span>    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    <span class='comment'>// <a href='vector.data'>[vector.data]</a>, data access
</span>    T*         data() noexcept;
    const T*  data() const noexcept;

    <span class='comment'>// <a href='vector.modifiers'>[vector.modifiers]</a>, modifiers:
</span>    template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);
    void push_back(const T&amp; x);
    void push_back(T&amp;&amp; x);
    void pop_back();

    template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
    iterator insert(const_iterator position, const T&amp; x);
    iterator     insert(const_iterator position, T&amp;&amp; x);
    iterator     insert(const_iterator position, size_type n, const T&amp; x);
    template &lt;class InputIterator&gt;
        iterator insert(const_iterator position,
                        InputIterator first, InputIterator last);
    iterator     insert(const_iterator position, initializer_list&lt;T&gt; il);
    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void     swap(vector&amp;);
    void     clear() noexcept;
  };

  template &lt;class T, class Allocator&gt;
    bool operator==(const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt; (const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator!=(const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt; (const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt;=(const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt;=(const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y);

  <span class='comment'>// <a href='vector.special'>[vector.special]</a>, specialized algorithms:
</span>  template &lt;class T, class Allocator&gt;
    void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
}
</pre><p ><span class='indexparent'><a class='index' id='vector,operator=='></a></span><span class='indexparent'><a class='index' id='vector,operator<'></a></span></p></div></div><div id='cons'><h4 ><a class='secnum' href='#cons' style='min-width:118pt'>23.3.6.2</a> <span class='texttt'>vector</span> constructors, copy, and assignment <a class='abbr_ref' href='vector.cons'>[vector.cons]</a></h4><p ><span class='indexparent'><a class='index' id='vector,vector'></a></span>
<code class='itemdecl'>
explicit vector(const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='cons-1'><div class='marginalizedparent'><a class='marginalized' href='#cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an empty <span class='texttt'>vector</span>, using the
specified allocator.</p></div></div><div class='para' id='cons-2'><div class='marginalizedparent'><a class='marginalized' href='#cons-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i> Constant.
</p></div></div><p ><span class='indexparent'><a class='index' id='vector,vector'></a></span>
<code class='itemdecl'>
explicit vector(size_type n);
</code></p><div class='itemdescr'></div><div class='para' id='cons-3'><div class='marginalizedparent'><a class='marginalized' href='#cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>vector</span> with <span class='texttt'>n</span>
value-initialized elements.</p></div></div><div class='para' id='cons-4'><div class='marginalizedparent'><a class='marginalized' href='#cons-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>DefaultConstructible</span>.</p></div></div><div class='para' id='cons-5'><div class='marginalizedparent'><a class='marginalized' href='#cons-5'>5</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear in <span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='vector,vector'></a></span>
<code class='itemdecl'>
vector(size_type n, const T&amp; value,
       const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='cons-6'><div class='marginalizedparent'><a class='marginalized' href='#cons-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>vector</span> with <span class='texttt'>n</span>
copies of <span class='texttt'>value</span>, using the specified allocator.</p></div></div><div class='para' id='cons-7'><div class='marginalizedparent'><a class='marginalized' href='#cons-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be
<span class='texttt'>CopyInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='cons-8'><div class='marginalizedparent'><a class='marginalized' href='#cons-8'>8</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear in <span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='vector,vector'></a></span>
<code class='itemdecl'>
template &lt;class InputIterator&gt;
  vector(InputIterator first, InputIterator last,
         const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='cons-9'><div class='marginalizedparent'><a class='marginalized' href='#cons-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>vector</span> equal to the
range <span class='texttt'>[<span class='discretionary'></span>first,<span class='discretionary'></span>last<span class='discretionary'></span>)</span>, using the specified allocator.</p></div></div><div class='para' id='cons-10'><div class='marginalizedparent'><a class='marginalized' href='#cons-10'>10</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Makes only <span class='math'><span class='mathalpha'>N</span></span>
calls to the copy constructor of
<span class='texttt'>T</span>
(where <span class='math'><span class='mathalpha'>N</span></span>
is the distance between
<span class='texttt'>first</span>
and
<span class='texttt'>last</span>)
and no reallocations if iterators first and last are of forward, bidirectional, or random access categories.
It makes order
<span class='texttt'>N</span>
calls to the copy constructor of
<span class='texttt'>T</span>
and order
<span class='math'><span class="mathrm">log</span>(<span class='mathalpha'>N</span>)</span>
reallocations if they are just input iterators.
</p></div></div><p ><span class='indexparent'><a class='index' id='assign,vector'></a></span><code class='itemdecl'>
template &lt;class InputIterator&gt;
  void assign(InputIterator first, InputIterator last);
</code></p><div class='itemdescr'></div><div class='para' id='cons-11'><div class='marginalizedparent'><a class='marginalized' href='#cons-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
erase(begin(), end());
insert(begin(), first, last);
</pre></div></div><p ><span class='indexparent'><a class='index' id='assign,vector'></a></span><span class='indexparent'><a class='index' id='vector,assign'></a></span><code class='itemdecl'>
void assign(size_type n, const T&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='cons-12'><div class='marginalizedparent'><a class='marginalized' href='#cons-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
erase(begin(), end());
insert(begin(), n, t);
</pre></div></div></div><div id='capacity'><h4 ><a class='secnum' href='#capacity' style='min-width:118pt'>23.3.6.3</a> <span class='texttt'>vector</span> capacity <a class='abbr_ref' href='vector.capacity'>[vector.capacity]</a></h4><p ><span class='indexparent'><a class='index' id='capacity,vector'></a></span><code class='itemdecl'>
size_type capacity() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='capacity-1'><div class='marginalizedparent'><a class='marginalized' href='#capacity-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
The total number of elements that the vector can hold
without requiring reallocation.
</p></div></div><p ><span class='indexparent'><a class='index' id='reserve,vector'></a></span><code class='itemdecl'>
void reserve(size_type n);
</code></p><div class='itemdescr'></div><div class='para' id='capacity-2'><div class='marginalizedparent'><a class='marginalized' href='#capacity-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
A directive that informs a
<span class='texttt'>vector</span>
of a planned change in size, so that it can manage the storage allocation accordingly.
After
<span class='texttt'>reserve()</span>,
<span class='texttt'>capacity()</span>
is greater or equal to the argument of
<span class='texttt'>reserve</span>
if reallocation happens; and equal to the previous value of
<span class='texttt'>capacity()</span>
otherwise.
Reallocation happens at this point if and only if the current capacity is less than the
argument of
<span class='texttt'>reserve()</span>. If an exception is thrown
other than by the move constructor of a non-<span class='texttt'>CopyInsertable</span> type,
there are no effects.</p></div></div><div class='para' id='capacity-3'><div class='marginalizedparent'><a class='marginalized' href='#capacity-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
It does not change the size of the sequence and takes at most linear
time in the size of the sequence.</p></div></div><div class='para' id='capacity-4'><div class='marginalizedparent'><a class='marginalized' href='#capacity-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>length_error</span> if <span class='texttt'>n &gt;
max_size()</span>.<a class='footnotenum' href='#footnote-267'>267</a></p></div></div><div class='para' id='capacity-5'><div class='marginalizedparent'><a class='marginalized' href='#capacity-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Reallocation invalidates all the references, pointers, and iterators
referring to the elements in the sequence.
It is guaranteed that no reallocation takes place during insertions that happen
after a call to
<span class='texttt'>reserve()</span>
until the time when an insertion would make the size of the vector
greater than the value of
<span class='texttt'>capacity()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shrink_to_fit,vector'></a></span><code class='itemdecl'>
void shrink_to_fit();
</code></p><div class='itemdescr'></div><div class='para' id='capacity-6'><div class='marginalizedparent'><a class='marginalized' href='#capacity-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>shrink_to_fit</span> is a non-binding request to reduce <span class='texttt'>capacity()</span> to <span class='texttt'>size()</span>. [&nbsp;<i>Note:</i> The request is non-binding to allow latitude for implementation-specific optimizations. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,vector'></a></span><code class='itemdecl'>
void swap(vector&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='capacity-7'><div class='marginalizedparent'><a class='marginalized' href='#capacity-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Exchanges the contents and
<span class='texttt'>capacity()</span>
of
<span class='texttt'>*this</span>
with that of <span class='texttt'>x</span>.</p></div></div><div class='para' id='capacity-8'><div class='marginalizedparent'><a class='marginalized' href='#capacity-8'>8</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Constant time.
</p></div></div><p ><span class='indexparent'><a class='index' id='resize,vector'></a></span><code class='itemdecl'>
void resize(size_type sz);
</code></p><div class='itemdescr'></div><div class='para' id='capacity-9'><div class='marginalizedparent'><a class='marginalized' href='#capacity-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>sz &lt;= size()</span>, equivalent to
<span class='texttt'>erase(begin() + sz, end());</span>. If <span class='texttt'>size() &lt; sz</span>,
appends <span class='texttt'>sz - size()</span> value-initialized elements to the
sequence.</p></div></div><div class='para' id='capacity-10'><div class='marginalizedparent'><a class='marginalized' href='#capacity-10'>10</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be
<span class='texttt'>CopyInsertable</span> into <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='resize,vector'></a></span><code class='itemdecl'>
void resize(size_type sz, const T&amp; c);
</code></p><div class='itemdescr'></div><div class='para' id='capacity-11'><div class='marginalizedparent'><a class='marginalized' href='#capacity-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
if (sz &gt; size())
  insert(end(), sz-size(), c);
else if (sz &lt; size())
  erase(begin()+sz, end());
else
  ;                 <span class='comment'>// do nothing
</span></pre></div></div><div class='para' id='capacity-12'><div class='marginalizedparent'><a class='marginalized' href='#capacity-12'>12</a></div><div class='itemdescr'><p ><i>Requires:</i> If an exception is thrown other than by the move constructor of a
non-<span class='texttt'>CopyInsertable</span> <span class='texttt'>T</span> there are no effects.
</p></div></div><div class='footnote' id='footnote-266'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-266'>266)</a></div><p ><span class='texttt'>reserve()</span> uses <span class='texttt'>Allocator::allocate()</span> which
may throw an appropriate exception.</p></div></div><div id='data'><h4 ><a class='secnum' href='#data' style='min-width:118pt'>23.3.6.4</a> <span class='texttt'>vector</span> data <a class='abbr_ref' href='vector.data'>[vector.data]</a></h4><p ><span class='indexparent'><a class='index' id='data,vector'></a></span><code class='itemdecl'>
T*         data() noexcept;
const T*   data() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='data-1'><div class='marginalizedparent'><a class='marginalized' href='#data-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
A pointer such that <span class='texttt'>[<span class='discretionary'></span>data(),<span class='discretionary'></span>data() + size()<span class='discretionary'></span>)</span> is a valid range. For a
non-empty vector, <span class='texttt'>data()</span> <span class='texttt'>==</span> <span class='texttt'>&amp;front()</span>.</p></div></div><div class='para' id='data-2'><div class='marginalizedparent'><a class='marginalized' href='#data-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Constant time.
</p></div></div></div><div id='modifiers'><h4 ><a class='secnum' href='#modifiers' style='min-width:118pt'>23.3.6.5</a> <span class='texttt'>vector</span> modifiers <a class='abbr_ref' href='vector.modifiers'>[vector.modifiers]</a></h4><p ><span class='indexparent'><a class='index' id='insert,vector'></a></span><code class='itemdecl'>
iterator insert(const_iterator position, const T&amp; x);
iterator insert(const_iterator position, T&amp;&amp; x);
iterator insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;
  iterator insert(const_iterator position, InputIterator first, InputIterator last);
iterator insert(const_iterator position, initializer_list&lt;T&gt;);

template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='modifiers-1'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-1'>1</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Causes reallocation if the new size is greater than the old capacity.
If no reallocation happens, all the iterators and references before the insertion point remain valid.
If an exception is thrown other than by
the copy constructor, move constructor,
assignment operator, or move assignment operator of
<span class='texttt'>T</span> or by any <span class='texttt'>InputIterator</span> operation
there are no effects.
If an exception is thrown by the move constructor of a non-<span class='texttt'>CopyInsertable</span>
<span class='texttt'>T</span>, the effects are unspecified.</p></div></div><div class='para' id='modifiers-2'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
The complexity is linear in the number of elements inserted plus the distance
to the end of the vector.
</p></div></div><p ><span class='indexparent'><a class='index' id='erase,vector'></a></span><code class='itemdecl'>
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
</code></p><div class='itemdescr'></div><div class='para' id='modifiers-3'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Invalidates iterators and references at or after the point of the erase.</p></div></div><div class='para' id='modifiers-4'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
The destructor of <span class='texttt'>T</span> is called the number of times equal to the
number of the elements erased, but the move assignment operator
of <span class='texttt'>T</span> is called the number of times equal to the number of
elements in the vector after the erased elements.</p></div></div><div class='para' id='modifiers-5'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i>
Nothing unless an exception is thrown by the
copy constructor, move constructor,
assignment operator, or move assignment operator of
<span class='texttt'>T</span>.
</p></div></div></div><div id='special'><h4 ><a class='secnum' href='#special' style='min-width:118pt'>23.3.6.6</a> <span class='texttt'>vector</span> specialized algorithms <a class='abbr_ref' href='vector.special'>[vector.special]</a></h4><p ><span class='indexparent'><a class='index' id='swap,vector'></a></span><span class='indexparent'><a class='index' id='vector,swap'></a></span><code class='itemdecl'>
template &lt;class T, class Allocator&gt;
  void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='special-1'><div class='marginalizedparent'><a class='marginalized' href='#special-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
x.swap(y);
</pre></div></div></div></div></div></body></html>