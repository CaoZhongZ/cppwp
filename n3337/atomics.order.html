<!DOCTYPE html><html lang='en'><head><title>[atomics.order]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>29</a> Atomic operations library <a class='abbr_ref' href='./#atomics'>[atomics]</a></h1><div id='atomics.order'><h2 ><a class='secnum' style='min-width:88pt'>29.3</a> Order and consistency <a class='abbr_ref'>[atomics.order]</a></h2><pre class='codeblock'>
namespace std {
  typedef enum memory_order {
    memory_order_relaxed, memory_order_consume, memory_order_acquire, 
    memory_order_release, memory_order_acq_rel, memory_order_seq_cst
  } memory_order;
}
</pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The enumeration <span class='texttt'>memory_order</span> specifies the detailed regular
(non-atomic) memory synchronization order as defined in
<a href='intro.multithread'>[intro.multithread]</a> and may provide for operation ordering. Its
enumerated values and their meanings are as follows:</p><ul ><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p ><span class='texttt'>memory_order_relaxed</span>: no operation orders memory.</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p ><span class='texttt'>memory_order_release</span>, <span class='texttt'>memory_order_acq_rel</span>, and
<span class='texttt'>memory_order_seq_cst</span>: a store operation performs a release operation on the
affected memory location.</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p ><span class='texttt'>memory_order_consume</span>: a load operation performs a consume operation on the
affected memory location.</p></li><li id='1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.4'>(1.4)</a></div><p ><span class='texttt'>memory_order_acquire</span>, <span class='texttt'>memory_order_acq_rel</span>, and
<span class='texttt'>memory_order_seq_cst</span>: a load operation performs an acquire operation on the
affected memory location.
</p></li></ul><p >[&nbsp;<i>Note:</i> Atomic operations specifying <span class='texttt'>memory_order_relaxed</span> are relaxed
with respect to memory ordering. Implementations must still guarantee that any
given atomic access to a particular atomic object be indivisible with respect
to all other atomic accesses to that object. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >An atomic operation <a class='hidden_link' href='#def:A' id='def:A'><i>A</i></a> that performs a release operation on an atomic
object <a class='hidden_link' href='#def:M' id='def:M'><i>M</i></a> synchronizes with an atomic operation <a class='hidden_link' href='#def:B' id='def:B'><i>B</i></a> that performs
an acquire operation on <a class='hidden_link' href='#def:M' id='def:M'><i>M</i></a> and takes its value from any side effect in the
release sequence headed by <a class='hidden_link' href='#def:A' id='def:A'><i>A</i></a>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >There shall be a single total order <i>S</i> on all <span class='texttt'>memory_order_seq_cst</span>
operations, consistent with the “happens before” order and modification orders for all
affected locations, such that each <span class='texttt'>memory_order_seq_cst</span> operation
<i>B</i> that loads a
value from an atomic object <i>M</i>
observes one of the following values:</p><ul ><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >the result of the last modification <i>A</i> of <i>M</i> that precedes
<i>B</i> in <i>S</i>, if it exists, or</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p >if <i>A</i> exists, the result of some modification of <i>M</i> in the
visible sequence of side effects with respect to <i>B</i> that is not
<span class='texttt'>memory_order_seq_cst</span> and that does not happen before <i>A</i>, or</p></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><p >if <i>A</i> does not exist, the result of some modification of <i>M</i>
in the visible sequence of side effects with respect to <i>B</i> that is not
<span class='texttt'>memory_order_seq_cst</span>.
</p></li></ul><p >[&nbsp;<i>Note:</i> Although it is not explicitly required that <i>S</i> include locks, it can
always be extended to an order that does include lock and unlock operations, since the
ordering between those is already included in the “happens before” ordering. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >For an atomic operation <i>B</i> that reads the value of an atomic object <i>M</i>,
if there is a <span class='texttt'>memory_order_seq_cst</span> fence <i>X</i> sequenced before <i>B</i>,
then <i>B</i> observes either the last <span class='texttt'>memory_order_seq_cst</span> modification of
<i>M</i> preceding <i>X</i> in the total order <i>S</i> or a later modification of
<i>M</i> in its modification order.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >For atomic operations <i>A</i> and <i>B</i> on an atomic object <i>M</i>, where
<i>A</i> modifies <i>M</i> and <i>B</i> takes its value, if there is a
<span class='texttt'>memory_order_seq_cst</span> fence <i>X</i> such that <i>A</i> is sequenced before
<i>X</i> and <i>B</i> follows <i>X</i> in <i>S</i>, then <i>B</i> observes
either the effects of <i>A</i> or a later modification of <i>M</i> in its
modification order.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >For atomic operations <i>A</i> and <i>B</i> on an atomic object <i>M</i>, where
<i>A</i> modifies <i>M</i> and <i>B</i> takes its value, if there are
<span class='texttt'>memory_order_seq_cst</span> fences <i>X</i> and <i>Y</i> such that <i>A</i> is
sequenced before <i>X</i>, <i>Y</i> is sequenced before <i>B</i>, and <i>X</i>
precedes <i>Y</i> in <i>S</i>, then <i>B</i> observes either the effects of
<i>A</i> or a later modification of <i>M</i> in its modification order.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >For atomic operations <i>A</i> and <i>B</i> on an atomic object <i>M</i>, if there
are <span class='texttt'>memory_order_seq_cst</span> fences <span class='texttt'>X</span> and <span class='texttt'>Y</span> such that <i>A</i> is
sequenced before <i>X</i>, <i>Y</i> is sequenced before <i>B</i>, and <i>X</i>
precedes <i>Y</i> in <i>S</i>, then <i>B</i> occurs later than <i>A</i> in the
modification order of <i>M</i>.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >[&nbsp;<i>Note:</i> <span class='texttt'>memory_order_seq_cst</span> ensures sequential consistency only for a
program that is free of data races and uses exclusively <span class='texttt'>memory_order_seq_cst</span>
operations. Any use of weaker ordering will invalidate this guarantee unless extreme
care is used. In particular, <span class='texttt'>memory_order_seq_cst</span> fences ensure a total order
only for the fences themselves. Fences cannot, in general, be used to restore sequential
consistency for atomic operations with weaker ordering specifications. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >An atomic store shall only store a value that has been computed from constants and
program input values by a finite sequence of program evaluations, such that each
evaluation observes the values of variables as computed by the last prior assignment in
the sequence. The ordering of evaluations in this sequence shall be such that:</p><ul ><li id='9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.1'>(9.1)</a></div><p >if an evaluation <i>B</i> observes a value computed by <i>A</i> in a
different thread, then <i>B</i> does not happen before <i>A</i>, and</p></li><li id='9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.2'>(9.2)</a></div><p >if an evaluation <i>A</i> is included in the sequence, then every
evaluation that assigns to the same variable and happens before <i>A</i> is
included.
</p></li></ul></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >[&nbsp;<i>Note:</i> The second requirement disallows “out-of-thin-air” or “speculative” stores of atomics when relaxed atomics are used. Since unordered operations are involved, evaluations may appear in this sequence out of thread order. For example, with <span class='texttt'>x</span> and <span class='texttt'>y</span> initially zero,</p><pre class='codeblock'>
<span class='comment'>// Thread 1:
</span>r1 = y.load(memory_order_relaxed);
x.store(r1, memory_order_relaxed);
</pre><pre class='codeblock'>
<span class='comment'>// Thread 2:
</span>r2 = x.load(memory_order_relaxed);
y.store(42, memory_order_relaxed);
</pre><p >is allowed to produce <span class='texttt'>r1 = r2 = 42</span>. The sequence of evaluations justifying this consists of:</p><pre class='codeblock'>
y.store(42, memory_order_relaxed);
r1 = y.load(memory_order_relaxed);
x.store(r1, memory_order_relaxed);
r2 = x.load(memory_order_relaxed);
</pre><p >On the other hand,</p><pre class='codeblock'>
<span class='comment'>// Thread 1:
</span>r1 = y.load(memory_order_relaxed);
x.store(r1, memory_order_relaxed);
</pre><pre class='codeblock'>
<span class='comment'>// Thread 2:
</span>r2 = x.load(memory_order_relaxed);
y.store(r2, memory_order_relaxed);
</pre><p >may not produce <span class='texttt'>r1 = r2 = 42</span>, since there is no sequence of evaluations that
results in the computation of 42. In the absence of “relaxed” operations and
read-modify-write operations with weaker than <span class='texttt'>memory_order_acq_rel</span> ordering, the
second requirement has no impact.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >[&nbsp;<i>Note:</i> The requirements do allow <span class='texttt'>r1 == r2 == 42</span> in the following example,
with <span class='texttt'>x</span> and <span class='texttt'>y</span> initially zero:</p><pre class='codeblock'>
<span class='comment'>// Thread 1:
</span>r1 = x.load(memory_order_relaxed);
if (r1 == 42) y.store(r1, memory_order_relaxed);
</pre><pre class='codeblock'>
<span class='comment'>// Thread 2:
</span>r2 = y.load(memory_order_relaxed);
if (r2 == 42) x.store(42, memory_order_relaxed);
</pre><p >However, implementations should not allow such behavior.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >Atomic read-modify-write operations shall always read the last value
(in the modification order) written before the write associated with
the read-modify-write operation.</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p >Implementations should make atomic stores visible to atomic loads within a reasonable
amount of time.</p><p ><span class='indexparent'><a class='index' id='kill_dependency'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  T kill_dependency(T y) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> The argument does not carry a dependency to the return
value (<a href='intro.multithread'>[intro.multithread]</a>).</p></div></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>y</span>.
</p></div></div></div></div></body></html>