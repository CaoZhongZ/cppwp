<!DOCTYPE html><html lang='en'><head><title>[unique.ptr.single]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>20.7</a> Smart pointers <a class='abbr_ref' href='smartptr#unique.ptr.single'>[smartptr]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>20.7.1</a> Class template <span class='texttt'>unique_ptr</span> <a class='abbr_ref' href='unique.ptr#single'>[unique.ptr]</a></h3><div id='unique.ptr.single'><h4 ><a class='secnum' style='min-width:118pt'>20.7.1.2</a> <span class='texttt'>unique_ptr</span> for single objects <a class='abbr_ref'>[unique.ptr.single]</a></h4><pre class='codeblock'>
namespace std {
  template &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr {
  public:
    typedef <i><span class='texttt'>see below</span></i> pointer;
    typedef T element_type;
    typedef D deleter_type;

    <span class='comment'>// <a href='unique.ptr.single.ctor'>[unique.ptr.single.ctor]</a>, constructors
</span>    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, <i><span class='texttt'>see below</span></i> d1) noexcept;
    unique_ptr(pointer p, <i><span class='texttt'>see below</span></i> d2) noexcept;
    unique_ptr(unique_ptr&amp;&amp; u) noexcept;
    constexpr unique_ptr(nullptr_t) noexcept
      : unique_ptr() { }
    template &lt;class U, class E&gt;
      unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
    template &lt;class U&gt;
      unique_ptr(auto_ptr&lt;U&gt;&amp;&amp; u) noexcept;

    <span class='comment'>// <a href='unique.ptr.single.dtor'>[unique.ptr.single.dtor]</a>, destructor
</span>    ~unique_ptr();

    <span class='comment'>// <a href='unique.ptr.single.asgn'>[unique.ptr.single.asgn]</a>, assignment
</span>    unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;
    template &lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
    unique_ptr&amp; operator=(nullptr_t) noexcept;

    <span class='comment'>// <a href='unique.ptr.single.observers'>[unique.ptr.single.observers]</a>, observers
</span>    typename add_lvalue_reference&lt;T&gt;::type operator*() const;
    pointer operator-&gt;() const noexcept;
    pointer get() const noexcept;
    deleter_type&amp; get_deleter() noexcept;
    const deleter_type&amp; get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    <span class='comment'>// <a href='unique.ptr.single.modifiers'>[unique.ptr.single.modifiers]</a> modifiers
</span>    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void swap(unique_ptr&amp; u) noexcept;

    <span class='comment'>// disable copy from lvalue
</span>    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
  };
}
</pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The default type for the template parameter <span class='texttt'>D</span> is
<span class='texttt'>default_delete</span>. A client-supplied template argument
<span class='texttt'>D</span> shall be a function
object type (<a href='function.objects'>[function.objects]</a>), lvalue-reference to function, or
lvalue-reference to function object type
for which, given
a value <span class='texttt'>d</span> of type <span class='texttt'>D</span> and a value
<span class='texttt'>ptr</span> of type <span class='texttt'>unique_ptr&lt;T, D&gt;::pointer</span>, the expression
<span class='texttt'>d(ptr)</span> is valid and has the effect of disposing of the
pointer as appropriate for that deleter.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >If the deleter's type <span class='texttt'>D</span> is not a reference type, <span class='texttt'>D</span> shall satisfy
the requirements of <span class='texttt'>Destructible</span> (Table <a href='destructible'>[destructible]</a>).</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >If the type <span class='texttt'>remove_reference&lt;D&gt;::type::pointer</span> exists, then <span class='texttt'>unique_ptr&lt;T,
D&gt;::pointer</span> shall be a synonym for <span class='texttt'>remove_reference&lt;D&gt;::type::pointer</span>. Otherwise
<span class='texttt'>unique_ptr&lt;T, D&gt;::pointer</span> shall be a synonym for <span class='texttt'>T*</span>. The type <span class='texttt'>unique_ptr&lt;T,
D&gt;::pointer</span> shall
satisfy the requirements of <span class='texttt'>NullablePointer</span> (<a href='nullablepointer.requirements'>[nullablepointer.requirements]</a>).</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >[&nbsp;<i>Example:</i> Given an allocator type <span class='texttt'>X</span> (<a href='allocator.requirements'>[allocator.requirements]</a>) and
letting <span class='texttt'>A</span> be a synonym for <span class='texttt'>allocator_traits&lt;X&gt;</span>, the types <span class='texttt'>A::pointer</span>,
<span class='texttt'>A::const_pointer</span>, <span class='texttt'>A::void_pointer</span>, and <span class='texttt'>A::const_void_pointer</span>
may be used as <span class='texttt'>unique_ptr&lt;T, D&gt;::pointer</span>. <i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p></div><div id='ctor'><h4 ><a class='secnum' href='#ctor' style='min-width:133pt'>20.7.1.2.1</a> <span class='texttt'>unique_ptr</span> constructors <a class='abbr_ref' href='unique.ptr.single.ctor'>[unique.ptr.single.ctor]</a></h4><p ><span class='indexparent'><a class='index' id='unique_ptr,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,unique_ptr'></a></span>
<code class='itemdecl'>
constexpr unique_ptr() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ctor-1'><div class='marginalizedparent'><a class='marginalized' href='#ctor-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>D</span> shall
satisfy the requirements of <span class='texttt'>DefaultConstructible</span> (Table <a href='defaultconstructible'>[defaultconstructible]</a>),
and that construction shall not throw an exception.</p></div></div><div class='para' id='ctor-2'><div class='marginalizedparent'><a class='marginalized' href='#ctor-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>unique_ptr</span> object that owns
nothing, value-initializing the stored pointer and the stored deleter.</p></div></div><div class='para' id='ctor-3'><div class='marginalizedparent'><a class='marginalized' href='#ctor-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get() == nullptr</span>. <span class='texttt'>get_deleter()</span>
returns a reference to the stored deleter.</p></div></div><div class='para' id='ctor-4'><div class='marginalizedparent'><a class='marginalized' href='#ctor-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> If this constructor is instantiated with a pointer type or reference type
for the template argument <span class='texttt'>D</span>, the program is ill-formed.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_ptr,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,unique_ptr'></a></span>
<code class='itemdecl'>
explicit unique_ptr(pointer p) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ctor-5'><div class='marginalizedparent'><a class='marginalized' href='#ctor-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>D</span> shall
satisfy the requirements of <span class='texttt'>DefaultConstructible</span> (Table <a href='defaultconstructible'>[defaultconstructible]</a>),
and that construction shall not throw an exception.</p></div></div><div class='para' id='ctor-6'><div class='marginalizedparent'><a class='marginalized' href='#ctor-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>unique_ptr</span> which owns
<span class='texttt'>p</span>, initializing the stored pointer with <span class='texttt'>p</span> and
value-initializing the stored deleter.</p></div></div><div class='para' id='ctor-7'><div class='marginalizedparent'><a class='marginalized' href='#ctor-7'>7</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get() == p</span>. <span class='texttt'>get_deleter()</span>
returns a reference to the stored deleter.</p></div></div><div class='para' id='ctor-8'><div class='marginalizedparent'><a class='marginalized' href='#ctor-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> If this constructor is instantiated with a pointer type or reference type
for the template argument <span class='texttt'>D</span>, the program is ill-formed.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_ptr,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,unique_ptr'></a></span>
<code class='itemdecl'>
unique_ptr(pointer p, <i><span class='texttt'>see below</span></i> d1) noexcept;
unique_ptr(pointer p, <i><span class='texttt'>see below</span></i> d2) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ctor-9'><div class='marginalizedparent'><a class='marginalized' href='#ctor-9'>9</a></div><div class='itemdescr'><p >The signature of these constructors depends upon whether <span class='texttt'>D</span>
is a reference type. If <span class='texttt'>D</span> is non-reference type
<span class='texttt'>A</span>, then the signatures are:</p><pre class='codeblock'>
unique_ptr(pointer p, const A&amp; d);
unique_ptr(pointer p, A&amp;&amp; d);
</pre></div></div><div class='para' id='ctor-10'><div class='marginalizedparent'><a class='marginalized' href='#ctor-10'>10</a></div><div class='itemdescr'><p >If <span class='texttt'>D</span> is an lvalue-reference type <span class='texttt'>A&amp;</span>,
then the signatures are:</p><pre class='codeblock'>
unique_ptr(pointer p, A&amp; d);
unique_ptr(pointer p, A&amp;&amp; d);
</pre></div></div><div class='para' id='ctor-11'><div class='marginalizedparent'><a class='marginalized' href='#ctor-11'>11</a></div><div class='itemdescr'><p >If <span class='texttt'>D</span> is an lvalue-reference type <span class='texttt'>const A&amp;</span>,
then the signatures are:</p><pre class='codeblock'>
unique_ptr(pointer p, const A&amp; d);
unique_ptr(pointer p, const A&amp;&amp; d);
</pre></div></div><div class='para' id='ctor-12'><div class='marginalizedparent'><a class='marginalized' href='#ctor-12'>12</a></div><div class='itemdescr'><p ><i>Requires:</i>
</p><ul ><li ><p >If <span class='texttt'>D</span> is not an lvalue-reference type then</p><ul ><li ><p >If <span class='texttt'>d</span> is an lvalue or <span class='texttt'>const</span> rvalue then
the first constructor of this pair will be selected. <span class='texttt'>D</span>
shall satisfy the requirements of
<span class='texttt'>CopyConstructible</span> (Table <a href='copyconstructible'>[copyconstructible]</a>), and
the copy constructor of <span class='texttt'>D</span> shall
not throw an exception.
This <span class='texttt'>unique_ptr</span> will hold
a copy of <span class='texttt'>d</span>.</p></li><li ><p >Otherwise, <span class='texttt'>d</span> is a non-const rvalue and the second
constructor of this pair will be selected. <span class='texttt'>D</span>
shall satisfy the requirements of
<span class='texttt'>MoveConstructible</span> (Table <a href='moveconstructible'>[moveconstructible]</a>), and the
move constructor of <span class='texttt'>D</span> shall not throw an exception.
This <span class='texttt'>unique_ptr</span> will
hold a value move constructed from <span class='texttt'>d</span>.
</p></li></ul></li><li ><p >Otherwise <span class='texttt'>D</span> is an lvalue-reference type. <span class='texttt'>d</span>
shall be reference-compatible with one of the constructors. If <span class='texttt'>d</span> is
an rvalue, it will bind to the second constructor of this pair and the program is
ill-formed. [&nbsp;<i>Note:</i> The diagnostic could
be implemented using a <span class='texttt'>static_assert</span> which assures that
<span class='texttt'>D</span> is not a reference type. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;] Else <span class='texttt'>d</span>
is an lvalue and will bind to the first constructor of this pair. The type
which <span class='texttt'>D</span> references need not be <span class='texttt'>CopyConstructible</span>
nor <span class='texttt'>MoveConstructible</span>. This <span class='texttt'>unique_ptr</span> will
hold a <span class='texttt'>D</span> which refers to the lvalue <span class='texttt'>d</span>.
[&nbsp;<i>Note:</i> <span class='texttt'>D</span> may not be an rvalue-reference type.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
</p></li></ul></div></div><div class='para' id='ctor-13'><div class='marginalizedparent'><a class='marginalized' href='#ctor-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>unique_ptr</span> object which owns <span class='texttt'>p</span>, initializing
the stored pointer with <span class='texttt'>p</span> and initializing the deleter as described above.</p></div></div><div class='para' id='ctor-14'><div class='marginalizedparent'><a class='marginalized' href='#ctor-14'>14</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get() == p</span>.
<span class='texttt'>get_deleter()</span> returns a reference to the stored
deleter. If <span class='texttt'>D</span> is a reference type then <span class='texttt'>get_deleter()</span>
returns a reference to the lvalue <span class='texttt'>d</span>.</p><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
D d;
unique_ptr&lt;int, D&gt; p1(new int, D());        <span class='comment'>// <span class='texttt'>D</span> must be <span class='texttt'>MoveConstructible</span>
</span>unique_ptr&lt;int, D&gt; p2(new int, d);          <span class='comment'>// <span class='texttt'>D</span> must be <span class='texttt'>CopyConstructible</span>
</span>unique_ptr&lt;int, D&amp;&gt; p3(new int, d);         <span class='comment'>// <span class='texttt'>p3</span> holds a reference to <span class='texttt'>d</span>
</span>unique_ptr&lt;int, const D&amp;&gt; p4(new int, D()); <span class='comment'>// error: rvalue deleter object combined
</span>                                            <span class='comment'>// with reference deleter type
</span></pre><p ><i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p></div></div><p ><span class='indexparent'><a class='index' id='unique_ptr,constructor'></a></span><code class='itemdecl'>
unique_ptr(unique_ptr&amp;&amp; u) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ctor-15'><div class='marginalizedparent'><a class='marginalized' href='#ctor-15'>15</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>D</span> is not a reference type,
<span class='texttt'>D</span> shall satisfy the requirements of <span class='texttt'>MoveConstructible</span>
(Table <a href='moveconstructible'>[moveconstructible]</a>).
Construction
of the deleter from an rvalue of type <span class='texttt'>D</span> shall not
throw an exception.</p></div></div><div class='para' id='ctor-16'><div class='marginalizedparent'><a class='marginalized' href='#ctor-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>unique_ptr</span> by transferring ownership from
<span class='texttt'>u</span> to <span class='texttt'>*this</span>. If <span class='texttt'>D</span> is a reference type, this
deleter is copy constructed from <span class='texttt'>u</span>'s deleter; otherwise, this
deleter is move constructed from <span class='texttt'>u</span>'s deleter. [&nbsp;<i>Note:</i> The
deleter constructor can be implemented with <span class='texttt'>std::forward&lt;D&gt;</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='ctor-17'><div class='marginalizedparent'><a class='marginalized' href='#ctor-17'>17</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get()</span> yields the value <span class='texttt'>u.get()</span>
yielded before the construction. <span class='texttt'>get_deleter()</span> returns a reference
to the stored deleter that was constructed from
<span class='texttt'>u.get_deleter()</span>. If <span class='texttt'>D</span> is a reference type then
<span class='texttt'>get_deleter()</span> and <span class='texttt'>u.get_deleter()</span> both reference
the same lvalue deleter.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_ptr,constructor'></a></span><code class='itemdecl'>
template &lt;class U, class E&gt; unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ctor-18'><div class='marginalizedparent'><a class='marginalized' href='#ctor-18'>18</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>E</span> is not a reference type,
construction of the deleter from an rvalue of type
<span class='texttt'>E</span> shall be well formed and shall not throw an exception.
Otherwise, <span class='texttt'>E</span> is a reference type and construction of the deleter from an
lvalue of type <span class='texttt'>E</span> shall be well formed and shall not throw an exception.</p></div></div><div class='para' id='ctor-19'><div class='marginalizedparent'><a class='marginalized' href='#ctor-19'>19</a></div><div class='itemdescr'><p ><i>Remarks:</i> This constructor shall not participate in overload resolution unless:</p><ul ><li ><p ><span class='texttt'>unique_ptr&lt;U, E&gt;::pointer</span> is implicitly convertible to <span class='texttt'>pointer</span>,
</p></li><li ><p ><span class='texttt'>U</span> is not an array type, and
</p></li><li ><p >either <span class='texttt'>D</span> is a reference type and <span class='texttt'>E</span> is the same type as <span class='texttt'>D</span>, or
<span class='texttt'>D</span> is not a reference type and <span class='texttt'>E</span> is implicitly convertible to <span class='texttt'>D</span>.
</p></li></ul></div></div><div class='para' id='ctor-20'><div class='marginalizedparent'><a class='marginalized' href='#ctor-20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>unique_ptr</span> by transferring ownership from <span class='texttt'>u</span>
to <span class='texttt'>*this</span>. If <span class='texttt'>E</span> is a reference type, this deleter is copy constructed from
<span class='texttt'>u</span>'s deleter; otherwise, this deleter is move constructed from <span class='texttt'>u</span>'s
deleter. [&nbsp;<i>Note:</i> The deleter constructor can be implemented with
<span class='texttt'>std::forward&lt;E&gt;</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='ctor-21'><div class='marginalizedparent'><a class='marginalized' href='#ctor-21'>21</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get()</span> yields the value <span class='texttt'>u.get()</span>
yielded before the construction.
<span class='texttt'>get_deleter()</span> returns a reference
to the stored deleter that was constructed from
<span class='texttt'>u.get_deleter()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_ptr,constructor'></a></span><code class='itemdecl'>
template &lt;class U&gt;
  unique_ptr(auto_ptr&lt;U&gt;&amp;&amp; u) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ctor-22'><div class='marginalizedparent'><a class='marginalized' href='#ctor-22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>unique_ptr</span> object, initializing the
stored pointer with <span class='texttt'>u.release()</span> and value-initializing the stored deleter.</p></div></div><div class='para' id='ctor-23'><div class='marginalizedparent'><a class='marginalized' href='#ctor-23'>23</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get()</span> yields the value <span class='texttt'>u.get()</span> yielded
before the construction.
<span class='texttt'>u.get() == nullptr</span>.
<span class='texttt'>get_deleter()</span> returns a reference to the stored deleter.</p></div></div><div class='para' id='ctor-24'><div class='marginalizedparent'><a class='marginalized' href='#ctor-24'>24</a></div><div class='itemdescr'><p ><i>Remarks:</i> This constructor shall not participate in overload resolution unless
<span class='texttt'>U*</span> is implicitly convertible to <span class='texttt'>T*</span> and <span class='texttt'>D</span> is
the same type as <span class='texttt'>default_delete&lt;T&gt;</span>.
</p></div></div></div><div id='dtor'><h4 ><a class='secnum' href='#dtor' style='min-width:133pt'>20.7.1.2.2</a> <span class='texttt'>unique_ptr</span> destructor <a class='abbr_ref' href='unique.ptr.single.dtor'>[unique.ptr.single.dtor]</a></h4><p ><span class='indexparent'><a class='index' id='unique_ptr,destructor'></a></span>
<code class='itemdecl'>
~unique_ptr();
</code></p><div class='itemdescr'></div><div class='para' id='dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#dtor-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> The expression <span class='texttt'>get_deleter()(get())</span> shall be well formed,
shall have well-defined behavior, and shall not throw exceptions. [&nbsp;<i>Note:</i> The
use of <span class='texttt'>default_delete</span> requires <span class='texttt'>T</span> to be a complete type.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='dtor-2'><div class='marginalizedparent'><a class='marginalized' href='#dtor-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>get() == nullptr</span> there are no effects.
Otherwise <span class='texttt'>get_deleter()(get())</span>.
</p></div></div></div><div id='asgn'><h4 ><a class='secnum' href='#asgn' style='min-width:133pt'>20.7.1.2.3</a> <span class='texttt'>unique_ptr</span> assignment <a class='abbr_ref' href='unique.ptr.single.asgn'>[unique.ptr.single.asgn]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,operator='></a></span>
<code class='itemdecl'>
unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='asgn-1'><div class='marginalizedparent'><a class='marginalized' href='#asgn-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>D</span> is not a reference type, <span class='texttt'>D</span> shall satisfy the
requirements of <span class='texttt'>MoveAssignable</span> (Table <a href='moveassignable'>[moveassignable]</a>) and assignment
of the deleter from an rvalue of type <span class='texttt'>D</span> shall not throw an exception.
Otherwise, <span class='texttt'>D</span> is a reference type;
<span class='texttt'>remove_reference&lt;D&gt;::type</span> shall satisfy the <span class='texttt'>CopyAssignable</span>
requirements and assignment of the deleter from an
lvalue of type <span class='texttt'>D</span> shall not throw an exception.</p></div></div><div class='para' id='asgn-2'><div class='marginalizedparent'><a class='marginalized' href='#asgn-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Transfers ownership from <span class='texttt'>u</span> to <span class='texttt'>*this</span> as if by calling
<span class='texttt'>reset(u.release())</span> followed by an assignment from
<span class='texttt'>std::forward&lt;D&gt;(u.get_deleter())</span>.</p></div></div><div class='para' id='asgn-3'><div class='marginalizedparent'><a class='marginalized' href='#asgn-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,operator='></a></span>
<code class='itemdecl'>
template &lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='asgn-4'><div class='marginalizedparent'><a class='marginalized' href='#asgn-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>E</span> is not a reference type, assignment of the deleter from
an rvalue of type <span class='texttt'>E</span> shall be well-formed and shall not throw an exception.
Otherwise, <span class='texttt'>E</span> is a reference type and assignment of the deleter from an lvalue
of type <span class='texttt'>E</span> shall be well-formed and shall not throw an exception.</p></div></div><div class='para' id='asgn-5'><div class='marginalizedparent'><a class='marginalized' href='#asgn-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> This operator shall not participate in overload resolution unless:</p><ul ><li ><p ><span class='texttt'>unique_ptr&lt;U, E&gt;::pointer</span> is implicitly convertible to <span class='texttt'>pointer</span> and
</p></li><li ><p ><span class='texttt'>U</span> is not an array type.
</p></li></ul></div></div><div class='para' id='asgn-6'><div class='marginalizedparent'><a class='marginalized' href='#asgn-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Transfers ownership from <span class='texttt'>u</span> to <span class='texttt'>*this</span> as if by calling
<span class='texttt'>reset(u.release())</span> followed by an assignment from
<span class='texttt'>std::forward&lt;D&gt;(u.get_deleter())</span>.</p></div></div><div class='para' id='asgn-7'><div class='marginalizedparent'><a class='marginalized' href='#asgn-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,operator='></a></span>
<code class='itemdecl'>
unique_ptr&amp; operator=(nullptr_t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='asgn-8'><div class='marginalizedparent'><a class='marginalized' href='#asgn-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>reset()</span>.</p></div></div><div class='para' id='asgn-9'><div class='marginalizedparent'><a class='marginalized' href='#asgn-9'>9</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>get() == nullptr</span></p></div></div><div class='para' id='asgn-10'><div class='marginalizedparent'><a class='marginalized' href='#asgn-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='observers'><h4 ><a class='secnum' href='#observers' style='min-width:133pt'>20.7.1.2.4</a> <span class='texttt'>unique_ptr</span> observers <a class='abbr_ref' href='unique.ptr.single.observers'>[unique.ptr.single.observers]</a></h4><p ><span class='indexparent'><a class='index' id='operator*,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,operator*'></a></span>
<code class='itemdecl'>
typename add_lvalue_reference&lt;T&gt;::type operator*() const;
</code></p><div class='itemdescr'></div><div class='para' id='observers-1'><div class='marginalizedparent'><a class='marginalized' href='#observers-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>get() != nullptr</span>.</p></div></div><div class='para' id='observers-2'><div class='marginalizedparent'><a class='marginalized' href='#observers-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*get()</span>.</p></div></div><p ><span class='indexparent'><a class='index' id='operator->,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,operator->'></a></span>
<code class='itemdecl'>
pointer operator-&gt;() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='observers-3'><div class='marginalizedparent'><a class='marginalized' href='#observers-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>get() != nullptr</span>.</p></div></div><div class='para' id='observers-4'><div class='marginalizedparent'><a class='marginalized' href='#observers-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get()</span>.</p></div></div><div class='para' id='observers-5'><div class='marginalizedparent'><a class='marginalized' href='#observers-5'>5</a></div><div class='itemdescr'><p ><i>Note:</i> use typically requires that <span class='texttt'>T</span> be a complete type.
</p></div></div><p ><span class='indexparent'><a class='index' id='get,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,get'></a></span>
<code class='itemdecl'>
pointer get() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='observers-6'><div class='marginalizedparent'><a class='marginalized' href='#observers-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> The stored pointer.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_deleter,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,get_deleter'></a></span>
<code class='itemdecl'>
deleter_type&amp; get_deleter() noexcept;
const deleter_type&amp; get_deleter() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='observers-7'><div class='marginalizedparent'><a class='marginalized' href='#observers-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to the stored deleter.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator_bool,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,operator_bool'></a></span>
<code class='itemdecl'>
explicit operator bool() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='observers-8'><div class='marginalizedparent'><a class='marginalized' href='#observers-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get() != nullptr</span>.
</p></div></div></div><div id='modifiers'><h4 ><a class='secnum' href='#modifiers' style='min-width:133pt'>20.7.1.2.5</a> <span class='texttt'>unique_ptr</span> modifiers <a class='abbr_ref' href='unique.ptr.single.modifiers'>[unique.ptr.single.modifiers]</a></h4><p ><span class='indexparent'><a class='index' id='release,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,release'></a></span>
<code class='itemdecl'>
pointer release() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='modifiers-1'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-1'>1</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>get() == nullptr</span>.</p></div></div><div class='para' id='modifiers-2'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The value <span class='texttt'>get()</span> had at the start of
the call to <span class='texttt'>release</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reset,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,reset'></a></span>
<code class='itemdecl'>
void reset(pointer p = pointer()) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='modifiers-3'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> The expression <span class='texttt'>get_deleter()(get())</span> shall be well formed, shall have
well-defined behavior, and shall not throw exceptions.</p></div></div><div class='para' id='modifiers-4'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> assigns <span class='texttt'>p</span> to the stored pointer, and then if the old value of the
stored pointer, <span class='texttt'>old_p</span>, was not equal to <span class='texttt'>nullptr</span>, calls
<span class='texttt'>get_deleter()(old_p)</span>. [&nbsp;<i>Note:</i> The order of these operations is significant
because the call to <span class='texttt'>get_deleter()</span> may destroy <span class='texttt'>*this</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='modifiers-5'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get() == p</span>.
[&nbsp;<i>Note:</i> The postcondition does not hold if the call to <span class='texttt'>get_deleter()</span>
destroys <span class='texttt'>*this</span> since <span class='texttt'>this-&gt;get()</span> is no longer a valid expression.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,unique_ptr'></a></span>
<span class='indexparent'><a class='index' id='unique_ptr,swap'></a></span>
<code class='itemdecl'>
void swap(unique_ptr&amp; u) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='modifiers-6'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>get_deleter()</span> shall be
swappable (<a href='swappable.requirements'>[swappable.requirements]</a>) and shall
not throw an exception
under <span class='texttt'>swap</span>.</p></div></div><div class='para' id='modifiers-7'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Invokes <span class='texttt'>swap</span> on the stored pointers and on the stored
deleters of <span class='texttt'>*this</span> and <span class='texttt'>u</span>.
</p></div></div></div></div></div></body></html>