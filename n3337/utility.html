<!DOCTYPE html><html lang='en'><head><title>[utility]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><div id='utility'><h2 ><a class='secnum' style='min-width:88pt'>20.2</a> Utility components <a class='abbr_ref'>[utility]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >This subclause contains some basic function and class templates that are used
throughout the rest of the library.</p><p ><span class='indexparent'><a class='index' id='utility'></a></span><span class='indexparent'><a class='index' id='rel_ops'></a></span><b>Header <span class='texttt'>&lt;utility&gt;</span> synopsis</b></p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The header <span class='texttt'>&lt;utility&gt;</span> defines several types and function templates
that are described in this Clause. It also defines the template <span class='texttt'>pair</span>
and various function templates that operate on <span class='texttt'>pair</span> objects.</p><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// <a href='operators'>[operators]</a>, operators:
</span>  namespace rel_ops {
    template&lt;class T&gt; bool operator!=(const T&amp;, const T&amp;);
    template&lt;class T&gt; bool operator&gt; (const T&amp;, const T&amp;);
    template&lt;class T&gt; bool operator&lt;=(const T&amp;, const T&amp;);
    template&lt;class T&gt; bool operator&gt;=(const T&amp;, const T&amp;);
  }

  <span class='comment'>// <a href='utility.swap'>[utility.swap]</a>, swap:
</span>  template&lt;class T&gt; void swap(T&amp; a, T&amp; b) noexcept(<i><span class='texttt'>see below</span></i>);
  template &lt;class T, size_t N&gt; void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(noexcept(swap(*a, *b)));

  <span class='comment'>// <a href='forward'>[forward]</a>, forward/move:
</span>  template &lt;class T&gt; T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; t) noexcept;
  template &lt;class T&gt; T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp;&amp; t) noexcept;
  template &lt;class T&gt; typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp;) noexcept;
  template &lt;class T&gt; typename conditional&lt;
    !is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; is_copy_constructible&lt;T&gt;::value,
    const T&amp;, T&amp;&amp;&gt;::type move_if_noexcept(T&amp; x) noexcept;

  <span class='comment'>// <a href='declval'>[declval]</a>, declval:
</span>  template &lt;class T&gt;
    typename add_rvalue_reference&lt;T&gt;::type declval() noexcept;  <span class='comment'>// as unevaluated operand
</span>
  <span class='comment'>// <a href='pairs'>[pairs]</a>, pairs:
</span>  template &lt;class T1, class T2&gt; struct pair;

  <span class='comment'>// <a href='pairs.spec'>[pairs.spec]</a>, pair specialized algorithms:
</span>  template &lt;class T1, class T2&gt;
    bool operator==(const pair&lt;T1,T2&gt;&amp;, const pair&lt;T1,T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    bool operator&lt; (const pair&lt;T1,T2&gt;&amp;, const pair&lt;T1,T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    bool operator!=(const pair&lt;T1,T2&gt;&amp;, const pair&lt;T1,T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    bool operator&gt; (const pair&lt;T1,T2&gt;&amp;, const pair&lt;T1,T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    bool operator&gt;=(const pair&lt;T1,T2&gt;&amp;, const pair&lt;T1,T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    bool operator&lt;=(const pair&lt;T1,T2&gt;&amp;, const pair&lt;T1,T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    void swap(pair&lt;T1,T2&gt;&amp; x, pair&lt;T1,T2&gt;&amp; y) noexcept(noexcept(x.swap(y)));
  template &lt;class T1, class T2&gt;
    <i><span class='texttt'>see below</span></i> make_pair(T1&amp;&amp;, T2&amp;&amp;);

  <span class='comment'>// <a href='pair.astuple'>[pair.astuple]</a>, tuple-like access to pair:
</span>  template &lt;class T&gt; class tuple_size;
  template &lt;size_t I, class T&gt; class tuple_element;

  template &lt;class T1, class T2&gt; struct tuple_size&lt;std::pair&lt;T1, T2&gt; &gt;;
  template &lt;class T1, class T2&gt; struct tuple_element&lt;0, std::pair&lt;T1, T2&gt; &gt;;
  template &lt;class T1, class T2&gt; struct tuple_element&lt;1, std::pair&lt;T1, T2&gt; &gt;;

  template&lt;size_t I, class T1, class T2&gt;
    typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type&amp; get(std::pair&lt;T1, T2&gt;&amp;) noexcept;
  template&lt;size_t I, class T1, class T2&gt;
    typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type&amp;&amp; get(std::pair&lt;T1, T2&gt;&amp;&amp;) noexcept;
  template&lt;size_t I, class T1, class T2&gt;
    const typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type&amp;
      get(const std::pair&lt;T1, T2&gt;&amp;) noexcept;

  <span class='comment'>// <a href='pair.piecewise'>[pair.piecewise]</a>, pair piecewise construction
</span>  struct piecewise_construct_t { };
  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
  template &lt;class... Types&gt; class tuple;  <span class='comment'>// defined in <span class='texttt'>&lt;tuple&gt;</span>
</span>}
</pre></div><div id='operators'><h3 ><a class='secnum' href='#operators' style='min-width:103pt'>20.2.1</a> Operators <a class='abbr_ref' href='operators'>[operators]</a></h3><div class='para' id='operators-1'><div class='marginalizedparent'><a class='marginalized' href='#operators-1'>1</a></div><p >To avoid redundant definitions of <span class='texttt'>operator!=</span> out of <span class='texttt'>operator==</span>
and operators <span class='texttt'>&gt;</span>, <span class='texttt'>&lt;=</span>, and <span class='texttt'>&gt;=</span> out of <span class='texttt'>operator&lt;</span>,
the library provides the following:</p><p ><span class='indexparent'><a class='index' id='operator!='></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator!=(const T&amp; x, const T&amp; y);
</code></p></div><div class='itemdescr'></div><div class='para' id='operators-2'><div class='marginalizedparent'><a class='marginalized' href='#operators-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>EqualityComparable</span> (Table <a href='equalitycomparable'>[equalitycomparable]</a>).</p></div></div><div class='para' id='operators-3'><div class='marginalizedparent'><a class='marginalized' href='#operators-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!(x == y)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>'></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator&gt;(const T&amp; x, const T&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='operators-4'><div class='marginalizedparent'><a class='marginalized' href='#operators-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>LessThanComparable</span> (Table <a href='lessthancomparable'>[lessthancomparable]</a>).</p></div></div><div class='para' id='operators-5'><div class='marginalizedparent'><a class='marginalized' href='#operators-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>y &lt; x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<='></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator&lt;=(const T&amp; x, const T&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='operators-6'><div class='marginalizedparent'><a class='marginalized' href='#operators-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>LessThanComparable</span> (Table <a href='lessthancomparable'>[lessthancomparable]</a>).</p></div></div><div class='para' id='operators-7'><div class='marginalizedparent'><a class='marginalized' href='#operators-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!(y &lt; x)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>='></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator&gt;=(const T&amp; x, const T&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='operators-8'><div class='marginalizedparent'><a class='marginalized' href='#operators-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>LessThanComparable</span> (Table <a href='lessthancomparable'>[lessthancomparable]</a>).</p></div></div><div class='para' id='operators-9'><div class='marginalizedparent'><a class='marginalized' href='#operators-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!(x &lt; y)</span>.
</p></div></div><div class='para' id='operators-10'><div class='marginalizedparent'><a class='marginalized' href='#operators-10'>10</a></div><p >In this library, whenever a declaration is provided for an <span class='texttt'>operator!=</span>,
<span class='texttt'>operator&gt;</span>, <span class='texttt'>operator&gt;=</span>, or <span class='texttt'>operator&lt;=</span>,
and requirements and semantics are not explicitly provided,
the requirements and semantics are as specified in this Clause.</p></div></div><div id='swap'><h3 ><a class='secnum' href='#swap' style='min-width:103pt'>20.2.2</a> swap <a class='abbr_ref' href='utility.swap'>[utility.swap]</a></h3><p ><span class='indexparent'><a class='index' id='swap'></a></span><code class='itemdecl'>
template&lt;class T&gt; void swap(T&amp; a, T&amp; b) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='swap-1'><div class='marginalizedparent'><a class='marginalized' href='#swap-1'>1</a></div><div class='itemdescr'><p ><i>Remark:</i> The expression inside <span class='texttt'>noexcept</span> is equivalent to:</p><pre class='codeblock'>
is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp;
is_nothrow_move_assignable&lt;T&gt;::value
</pre></div></div><div class='para' id='swap-2'><div class='marginalizedparent'><a class='marginalized' href='#swap-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type
<span class='texttt'>T</span>
shall be
<span class='texttt'>MoveConstructible</span> (Table <a href='moveconstructible'>[moveconstructible]</a>)
and
<span class='texttt'>MoveAssignable</span> (Table <a href='moveassignable'>[moveassignable]</a>).</p></div></div><div class='para' id='swap-3'><div class='marginalizedparent'><a class='marginalized' href='#swap-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Exchanges values stored in two locations.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap'></a></span><code class='itemdecl'>
template&lt;class T, size_t N&gt;
  void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(noexcept(swap(*a, *b)));
</code></p><div class='itemdescr'></div><div class='para' id='swap-4'><div class='marginalizedparent'><a class='marginalized' href='#swap-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>a[i]</span> shall be swappable with (<a href='swappable.requirements'>[swappable.requirements]</a>) <span class='texttt'>b[i]</span>
for all <span class='texttt'>i</span> in the range <span class='texttt'>[0,N)</span>.</p></div></div><div class='para' id='swap-5'><div class='marginalizedparent'><a class='marginalized' href='#swap-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>swap_ranges(a, a + N, b)</span>
</p></div></div></div><div id='forward'><h3 ><a class='secnum' href='#forward' style='min-width:103pt'>20.2.3</a> forward/move helpers <a class='abbr_ref' href='forward'>[forward]</a></h3><div class='para' id='forward-1'><div class='marginalizedparent'><a class='marginalized' href='#forward-1'>1</a></div><p >The library provides templated helper functions to simplify
applying move semantics to an lvalue and to simplify the implementation
of forwarding functions.</p><p ><span class='indexparent'><a class='index' id='forward'></a></span><code class='itemdecl'>
template &lt;class T&gt; T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; t) noexcept;
template &lt;class T&gt; T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp;&amp; t) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='forward-2'><div class='marginalizedparent'><a class='marginalized' href='#forward-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>static_cast&lt;T&amp;&amp;&gt;(t)</span>.</p></div></div><div class='para' id='forward-3'><div class='marginalizedparent'><a class='marginalized' href='#forward-3'>3</a></div><div class='itemdescr'><p >if the second form is instantiated with an lvalue reference type, the program is ill-formed.</p></div></div><div class='para' id='forward-4'><div class='marginalizedparent'><a class='marginalized' href='#forward-4'>4</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T, class A1, class A2&gt;
shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1, A2&amp;&amp; a2) {
  return shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1), std::forward&lt;A2&gt;(a2)));
}

struct A {
  A(int&amp;, const double&amp;);
};

void g() {
  shared_ptr&lt;A&gt; sp1 = factory&lt;A&gt;(2, 1.414); <span class='comment'>// error: 2 will not bind to <span class='texttt'>int&amp;</span>
</span>  int i = 2;
  shared_ptr&lt;A&gt; sp2 = factory&lt;A&gt;(i, 1.414); <span class='comment'>// OK
</span>}
</pre></div></div><div class='para' id='forward-5'><div class='marginalizedparent'><a class='marginalized' href='#forward-5'>5</a></div><div class='itemdescr'><p >In the first call to <span class='texttt'>factory</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>int</span>, so 2 is forwarded
to <span class='texttt'>A</span>'s constructor as an rvalue.
In the second call to <span class='texttt'>factory</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>int&amp;</span>, so <span class='texttt'>i</span> is forwarded
to <span class='texttt'>A</span>'s constructor as an lvalue. In
both cases, <span class='texttt'>A2</span> is deduced as <span class='texttt'>double</span>, so
1.414 is forwarded to <span class='texttt'>A</span>'s constructor as an rvalue.</p><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='move'></a></span><code class='itemdecl'>
template &lt;class T&gt; typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t) noexcept;
</code></p><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t)</span>.</p></div><div class='para' id='forward-6'><div class='marginalizedparent'><a class='marginalized' href='#forward-6'>6</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T, class A1&gt;
shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) {
  return shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1)));
}

struct A {
  A();
  A(const A&amp;);  <span class='comment'>// copies from lvalues
</span>  A(A&amp;&amp;);       <span class='comment'>// moves from rvalues
</span>};

void g() {
  A a;
  shared_ptr&lt;A&gt; sp1 = factory&lt;A&gt;(a);              <span class='comment'>// “<span class='texttt'>a</span>” binds to <span class='texttt'>A(const A&amp;)</span>
</span>  shared_ptr&lt;A&gt; sp1 = factory&lt;A&gt;(std::move(a));   <span class='comment'>// “<span class='texttt'>a</span>” binds to <span class='texttt'>A(A&amp;&amp;)</span>
</span>}
</pre></div></div><div class='para' id='forward-7'><div class='marginalizedparent'><a class='marginalized' href='#forward-7'>7</a></div><div class='itemdescr'><p >In the first call to <span class='texttt'>factory</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>A&amp;</span>, so <span class='texttt'>a</span> is forwarded
as a non-const lvalue. This binds to the constructor <span class='texttt'>A(const A&amp;)</span>,
which copies the value from <span class='texttt'>a</span>.
In the second call to <span class='texttt'>factory</span>, because of the call
<span class='texttt'>std::move(a)</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>A</span>, so <span class='texttt'>a</span> is forwarded
as an rvalue. This binds to the constructor <span class='texttt'>A(A&amp;&amp;)</span>,
which moves the value from <span class='texttt'>a</span>.</p><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='move_if_noexcept'></a></span><code class='itemdecl'>
template &lt;class T&gt; typename conditional&lt;
  !is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; is_copy_constructible&lt;T&gt;::value,
  const T&amp;, T&amp;&amp;&gt;::type move_if_noexcept(T&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='forward-8'><div class='marginalizedparent'><a class='marginalized' href='#forward-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>std::move(x)</span>
</p></div></div></div><div id='declval'><h3 ><a class='secnum' href='#declval' style='min-width:103pt'>20.2.4</a> Function template <span class='texttt'>declval</span> <a class='abbr_ref' href='declval'>[declval]</a></h3><div class='para' id='declval-1'><div class='marginalizedparent'><a class='marginalized' href='#declval-1'>1</a></div><p >The library provides the function template <span class='texttt'>declval</span> to simplify the definition of
expressions which occur as unevaluated operands (Clause <a href='expr'>[expr]</a>).</p><p ><span class='indexparent'><a class='index' id='declval'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  typename add_rvalue_reference&lt;T&gt;::type declval() noexcept;  <span class='comment'>// as unevaluated operand
</span></code></p></div><div class='itemdescr'></div><div class='para' id='declval-2'><div class='marginalizedparent'><a class='marginalized' href='#declval-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> If this function is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>), the program is ill-formed.</p></div></div><div class='para' id='declval-3'><div class='marginalizedparent'><a class='marginalized' href='#declval-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> The template parameter <span class='texttt'>T</span> of <span class='texttt'>declval</span> may be an incomplete type.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class To, class From&gt;
  decltype(static_cast&lt;To&gt;(declval&lt;From&gt;())) convert(From&amp;&amp;);
</pre><p >declares a function template <span class='texttt'>convert</span> which only participates in overloading if the
type <span class='texttt'>From</span> can be explicitly converted to type <span class='texttt'>To</span>. For another example see class
template <span class='texttt'>common_type</span> (<a href='meta.trans.other'>[meta.trans.other]</a>).
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div></div></div></div></body></html>