<!DOCTYPE html><html lang='en'><head><title>[stmt.jump]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>6</a> Statements <a class='abbr_ref' href='./#stmt.stmt'>[stmt.stmt]</a></h1><div id='stmt.jump'><h2 ><a class='secnum' style='min-width:88pt'>6.6</a> Jump statements <a class='abbr_ref'>[stmt.jump]</a></h2><p ><span class='indexparent'><a class='index' id='statement,jump'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Jump statements unconditionally transfer control.
<span class='indexparent'><a class='index' id='statement,jump'></a></span>
<span class='indexparent'><a class='index' id='statement,break'></a></span><span class='indexparent'><a class='index' id='statement,continue'></a></span><span class='indexparent'><a class='index' id='return_statement'></a></span><span class='indexparent'><a class='index' id='return'></a></span><span class='indexparent'><a class='index' id='statement,goto'></a></span></p><pre class='bnf'><a id='nt:jump-statement'>jump-statement:</a>
    <span class='terminal'>break ;</span>
    <span class='terminal'>continue ;</span>
    <span class='terminal'>return</span> <i ><a href='expr.comma#nt:expression'>expression</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>;</span>
    <span class='terminal'>return</span> <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> <span class='terminal'>;</span>
    <span class='terminal'>goto</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span></pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='local_variable,destruction_of'></a></span><span class='indexparent'><a class='index' id='scope,destructor_and_exit_from'></a></span>On exit from a scope (however accomplished), objects with automatic storage
duration (<a href='basic.stc.auto'>[basic.stc.auto]</a>) that have been constructed in that scope are destroyed
in the reverse order of their construction. [&nbsp;<i>Note:</i> For temporaries,
see <a href='class.temporary'>[class.temporary]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Transfer out of a loop, out of a block, or back
past
an initialized variable with automatic storage duration involves the
destruction of objects with automatic storage duration that are in
scope at the point transferred from but not at the point transferred to.
(See <a href='stmt.dcl'>[stmt.dcl]</a> for transfers into blocks).
[&nbsp;<i>Note:</i>
However, the program can be terminated (by calling
<span class='indexparent'><a class='index' id='exit'></a></span><span class='indexparent'><a class='index' id='exit'></a></span><span class='texttt'>std::exit()</span> or
<span class='indexparent'><a class='index' id='abort'></a></span><span class='indexparent'><a class='index' id='abort'></a></span><span class='texttt'>std::abort()</span> (<a href='support.start.term'>[support.start.term]</a>), for example) without
destroying class objects with automatic storage duration.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='stmt.break'><h3 ><a class='secnum' href='#stmt.break' style='min-width:103pt'>6.6.1</a> The <span class='texttt'>break</span> statement <a class='abbr_ref' href='stmt.break'>[stmt.break]</a></h3><p ><span class='indexparent'><a class='index' id='statement,break'></a></span></p><div class='para' id='stmt.break-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.break-1'>1</a></div><p >The <span class='texttt'>break</span> statement shall occur only in an
<span class='indexparent'><a class='index' id='iteration-statement'></a></span><span class='indexparent'><a class='index' id='statement,switch'></a></span><i ><a href='stmt.iter#nt:iteration-statement'>iteration-statement</a></i> or a <span class='texttt'>switch</span> statement and causes
termination of the smallest enclosing <i ><a href='stmt.iter#nt:iteration-statement'>iteration-statement</a></i> or
<span class='texttt'>switch</span> statement; control passes to the statement following the
terminated statement, if any.</p></div></div><div id='stmt.cont'><h3 ><a class='secnum' href='#stmt.cont' style='min-width:103pt'>6.6.2</a> The <span class='texttt'>continue</span> statement <a class='abbr_ref' href='stmt.cont'>[stmt.cont]</a></h3><p ><span class='indexparent'><a class='index' id='statement,continue'></a></span></p><div class='para' id='stmt.cont-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.cont-1'>1</a></div><p >The
<span class='texttt'>continue</span>
statement shall occur only in an
<span class='indexparent'><a class='index' id='iteration-statement'></a></span><i ><a href='stmt.iter#nt:iteration-statement'>iteration-statement</a></i>
and causes control to pass to the loop-continuation portion of the
smallest enclosing <i ><a href='stmt.iter#nt:iteration-statement'>iteration-statement</a></i>, that is, to the end
of the loop. More precisely, in each of the statements</p><div class='minipage'><pre class='codeblock'>
while (foo) {
  {
    <span class='comment'>// ...
</span>  }
contin: ;
}
</pre></div><div class='minipage'><pre class='codeblock'>
do {
  {
    <span class='comment'>// ...
</span>  }
contin: ;
} while (foo);
</pre></div><div class='minipage'><pre class='codeblock'>
for (;;) {
  {
    <span class='comment'>// ...
</span>  }
contin: ;
}
</pre></div><p >a <span class='texttt'>continue</span> not contained in an enclosed iteration statement is
equivalent to <span class='texttt'>goto</span> <span class='texttt'>contin</span>.</p></div></div><div id='stmt.return'><h3 ><a class='secnum' href='#stmt.return' style='min-width:103pt'>6.6.3</a> The <span class='texttt'>return</span> statement <a class='abbr_ref' href='stmt.return'>[stmt.return]</a></h3><p ><span class='indexparent'><a class='index' id='return'></a></span><span class='indexparent'><a class='index' id='function_return'></a></span>
</p><div class='para' id='stmt.return-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.return-1'>1</a></div><p >A function returns to its caller by the <span class='texttt'>return</span> statement.</p></div><div class='para' id='stmt.return-2'><div class='marginalizedparent'><a class='marginalized' href='#stmt.return-2'>2</a></div><p >A return statement
with neither an <i ><a href='expr.comma#nt:expression'>expression</a></i> nor a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>
can be used only in functions
that do not return a value, that is, a function with the return type
<span class='texttt'>void</span>, a constructor (<a href='class.ctor'>[class.ctor]</a>), or a
destructor (<a href='class.dtor'>[class.dtor]</a>).
<span class='indexparent'><a class='index' id='return,constructor_and'></a></span><span class='indexparent'><a class='index' id='return,constructor_and'></a></span>A return statement with an expression of non-void type can be used only
in functions returning a value; the value of the expression is returned
to the caller of the function.
<span class='indexparent'><a class='index' id='conversion,return_type'></a></span>The value of the expression is implicitly converted to the return type of the
function in which it appears. A return statement can involve the
construction and copy or move of a temporary object (<a href='class.temporary'>[class.temporary]</a>).
[&nbsp;<i>Note:</i>
A copy or move operation associated with a return statement may be elided or
considered as an rvalue for the purpose of overload resolution in
selecting a constructor (<a href='class.copy'>[class.copy]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;] A return statement with a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> initializes the object or reference to be returned from the function by copy-list-initialization (<a href='dcl.init.list'>[dcl.init.list]</a>) from the specified initializer list. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
std::pair&lt;std::string,int&gt; f(const char* p, int x) {
  return {p,x};
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >Flowing off the end of a function is equivalent to a <span class='texttt'>return</span> with
no value; this results in undefined behavior in a value-returning
function.</p></div><div class='para' id='stmt.return-3'><div class='marginalizedparent'><a class='marginalized' href='#stmt.return-3'>3</a></div><p >A return statement with an expression of type <span class='texttt'>void</span>
can be used only in functions with a return type of
<i>cv</i> <span class='texttt'>void</span>; the expression is evaluated just before the function
returns to its caller.</p></div></div><div id='stmt.goto'><h3 ><a class='secnum' href='#stmt.goto' style='min-width:103pt'>6.6.4</a> The <span class='texttt'>goto</span> statement <a class='abbr_ref' href='stmt.goto'>[stmt.goto]</a></h3><p ><span class='indexparent'><a class='index' id='statement,goto'></a></span></p><div class='para' id='stmt.goto-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.goto-1'>1</a></div><p >The <span class='texttt'>goto</span> statement unconditionally transfers control to the
statement labeled by the identifier. The identifier shall be a
<span class='indexparent'><a class='index' id='label'></a></span>label (<a href='stmt.label'>[stmt.label]</a>) located in the current function.</p></div></div></div></div></body></html>