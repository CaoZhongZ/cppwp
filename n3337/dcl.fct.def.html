<!DOCTYPE html><html lang='en'><head><title>[dcl.fct.def]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Declarators <a class='abbr_ref' href='./#dcl.decl'>[dcl.decl]</a></h1><div id='dcl.fct.def'><h2 ><a class='secnum' style='min-width:88pt'>8.4</a> Function definitions <a class='abbr_ref'>[dcl.fct.def]</a></h2><p ><span class='indexparent'><a class='index' id='definition,function'></a></span></p><div id='general'><h3 ><a class='secnum' href='#general' style='min-width:103pt'>8.4.1</a> In general <a class='abbr_ref' href='dcl.fct.def.general'>[dcl.fct.def.general]</a></h3><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p ><span class='indexparent'><a class='index' id='body,function'></a></span>Function definitions have the form</p><p ><span class='indexparent'><a class='index' id='function-definition'></a></span></p><pre class='bnf'><a id='nt:function-definition'>function-definition:</a>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.decl#nt:declarator'>declarator</a></i> <i ><a href='class.mem#nt:virt-specifier-seq'>virt-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> function-body</pre><pre class='bnf'>function-body:
    <i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i>
    <i ><a href='except#nt:function-try-block'>function-try-block</a></i>
    <span class='terminal'>= default ;</span>
    <span class='terminal'>= delete ;</span></pre><p >Any informal reference to the body of a function should be interpreted as a reference to
the non-terminal <span class='grammarterm'>function-body</span>.
The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a <i ><a href='dcl.fct.def.general#nt:function-definition'>function-definition</a></i>
appertains to the function.
A <i ><a href='class.mem#nt:virt-specifier-seq'>virt-specifier-seq</a></i> can be part of a <i ><a href='dcl.fct.def.general#nt:function-definition'>function-definition</a></i>
only if it is a <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i> (<a href='class.mem'>[class.mem]</a>).</p></div><div class='para' id='general-2'><div class='marginalizedparent'><a class='marginalized' href='#general-2'>2</a></div><p >The
<i ><a href='dcl.decl#nt:declarator'>declarator</a></i>
in a
<i ><a href='dcl.fct.def.general#nt:function-definition'>function-definition</a></i>
shall have the form</p><pre class='bnf'><span class='terminal'>D1 (</span> <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> <span class='terminal'>)</span> <i ><a href='dcl.decl#nt:cv-qualifier-seq'>cv-qualifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>   
    <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><p >as described in <a href='dcl.fct'>[dcl.fct]</a>.
A function shall be defined only in namespace or class scope.</p></div><div class='para' id='general-3'><div class='marginalizedparent'><a class='marginalized' href='#general-3'>3</a></div><p >[&nbsp;<i>Example:</i>
a simple example of a complete function definition is</p><p ><span class='indexparent'><a class='index' id='example,function_definition'></a></span></p><pre class='codeblock'>
int max(int a, int b, int c) {
  int m = (a &gt; b) ? a : b;
  return (m &gt; c) ? m : c;
}
</pre><p >Here
<span class='texttt'>int</span>
is the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>;
<span class='texttt'>max(int</span>
<span class='texttt'>a,</span>
<span class='texttt'>int</span>
<span class='texttt'>b,</span>
<span class='texttt'>int</span>
<span class='texttt'>c)</span>
is the
<i ><a href='dcl.decl#nt:declarator'>declarator</a></i>;
<span class='texttt'>{ /* ... */ }</span>
is the
<span class='grammarterm'>function-body</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='general-4'><div class='marginalizedparent'><a class='marginalized' href='#general-4'>4</a></div><p ><span class='indexparent'><a class='index' id='initializer,base_class'></a></span><span class='indexparent'><a class='index' id='initializer,member'></a></span><span class='indexparent'><a class='index' id='definition,constructor'></a></span>A
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>
is used only in a constructor; see <a href='class.ctor'>[class.ctor]</a> and <a href='class.init'>[class.init]</a>.</p></div><div class='para' id='general-5'><div class='marginalizedparent'><a class='marginalized' href='#general-5'>5</a></div><p >A
<i ><a href='dcl.decl#nt:cv-qualifier-seq'>cv-qualifier-seq</a></i> or a <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> (or both)
can be part of a non-static member function declaration, non-static member function definition,
or pointer to member function only (<a href='dcl.fct'>[dcl.fct]</a>); see <a href='class.this'>[class.this]</a>.</p></div><div class='para' id='general-6'><div class='marginalizedparent'><a class='marginalized' href='#general-6'>6</a></div><p >[&nbsp;<i>Note:</i>
Unused parameters need not be named.
For example,</p><p ><span class='indexparent'><a class='index' id='example,unnamed_parameter'></a></span></p><pre class='codeblock'>
void print(int a, int) {
  std::printf("a = %d\n",a);
}
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='general-7'><div class='marginalizedparent'><a class='marginalized' href='#general-7'>7</a></div><p >In the <span class='grammarterm'>function-body</span>, a
<span class='grammarterm'>function-local predefined variable</span> denotes a block-scope object of static
storage duration that is implicitly defined (see <a href='basic.scope.local'>[basic.scope.local]</a>).</p></div><div class='para' id='general-8'><div class='marginalizedparent'><a class='marginalized' href='#general-8'>8</a></div><p >The function-local predefined variable <span class='texttt'>__func__</span> is
defined as if a definition of the form</p><pre class='codeblock'>
static const char __func__[] = "<span class='grammarterm'>function-name</span>";
</pre><p >had been provided, where <span class='grammarterm'>function-name</span> is an <span class='indexparent'><a class='index' id='string_resulting_from___func__'></a></span>implementation-defined string. It is unspecified whether such a variable has an address
distinct from that of any other object in the program.<a class='footnotenum' href='#footnote-102'>102</a></p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct S {
  S() : s(__func__) { }             <span class='comment'>// OK
</span>  const char *s;
};
void f(const char * s = __func__);  <span class='comment'>// error: <span class='texttt'>__func__</span> is undeclared
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='footnote' id='footnote-102'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-102'>102)</a></div><p >Implementations are
permitted to provide additional predefined variables with names that are reserved to the
implementation (<a href='global.names'>[global.names]</a>). If a predefined variable is not
odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>), its string value need not be present in the program image.</p></div></div><div id='default'><h3 ><a class='secnum' href='#default' style='min-width:103pt'>8.4.2</a> Explicitly-defaulted functions <a class='abbr_ref' href='dcl.fct.def.default'>[dcl.fct.def.default]</a></h3><p ><span class='indexparent'><a class='index' id='definition,function,explicitly-defaulted'></a></span></p><div class='para' id='default-1'><div class='marginalizedparent'><a class='marginalized' href='#default-1'>1</a></div><p >A function definition of the form:</p><pre class='bnf'><i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.decl#nt:declarator'>declarator</a></i> <span class='terminal'> = default ;</span></pre><p >is called an <span class='grammarterm'>explicitly-defaulted</span> definition.
A function that is explicitly defaulted shall</p><ul ><li id='default-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#default-1.1'>(1.1)</a></div><p >be a special member function,</p></li><li id='default-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#default-1.2'>(1.2)</a></div><p >have the same declared function type (except for possibly differing
<i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifiers</a></i> and except that in the case of a copy constructor or
copy assignment operator, the parameter type may be “reference to non-const <span class='texttt'>T</span>”,
where <span class='texttt'>T</span> is the name of the member function's class) as if it had been implicitly
declared, and</p></li><li id='default-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#default-1.3'>(1.3)</a></div><p >not have default arguments.
</p></li></ul></div><div class='para' id='default-2'><div class='marginalizedparent'><a class='marginalized' href='#default-2'>2</a></div><p >An explicitly-defaulted function may be declared
<span class='texttt'>constexpr</span> only if it would have been implicitly declared as
<span class='texttt'>constexpr</span>,
and may have an explicit <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> only if it is
compatible (<a href='except.spec'>[except.spec]</a>) with the <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>
on the implicit declaration. If
a function is explicitly defaulted on its first declaration,</p><ul ><li id='default-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#default-2.1'>(2.1)</a></div><p >it is implicitly considered to be <span class='texttt'>constexpr</span> if the implicit
declaration would be,
</p></li><li id='default-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#default-2.2'>(2.2)</a></div><p >it is implicitly considered to have the same <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>
as if it had been implicitly declared (<a href='except.spec'>[except.spec]</a>), and
</p></li><li id='default-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#default-2.3'>(2.3)</a></div><p >in the case of a copy constructor, move constructor,
copy assignment operator, or move assignment operator, it shall have the
same parameter type as if it had been implicitly declared.
</p></li></ul></div><div class='para' id='default-3'><div class='marginalizedparent'><a class='marginalized' href='#default-3'>3</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct S {
  constexpr S() = default;                  <span class='comment'>// ill-formed: implicit <span class='texttt'>S()</span> is not <span class='texttt'>constexpr</span>
</span>  S(int a = 0) = default;                   <span class='comment'>// ill-formed: default argument
</span>  void operator=(const S&amp;) = default;       <span class='comment'>// ill-formed: non-matching return type
</span>  ~S() throw(int) = default;                <span class='comment'>// ill-formed: exception specification does not match
</span>private:
  int i;
  S(S&amp;);                                    <span class='comment'>// OK: private copy constructor
</span>};
S::S(S&amp;) = default;                         <span class='comment'>// OK: defines copy constructor
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='default-4'><div class='marginalizedparent'><a class='marginalized' href='#default-4'>4</a></div><p >Explicitly-defaulted functions and implicitly-declared functions are collectively
called <a class='hidden_link' href='#def:defaulted' id='def:defaulted'><i>defaulted</i></a> functions, and the implementation
shall provide implicit definitions
for them (<a href='class.ctor'>[class.ctor]</a>
<a href='class.dtor'>[class.dtor]</a>, <a href='class.copy'>[class.copy]</a>), which might mean defining them as deleted.
A special member function is
<a class='hidden_link' href='#def:user-provided' id='def:user-provided'><i>user-provided</i></a> if it is user-declared and not explicitly
defaulted or deleted on its first declaration. A user-provided explicitly-defaulted function
(i.e., explicitly defaulted after its first declaration)
is defined at the point where it is explicitly defaulted; if such a function is implicitly
defined as deleted, the program is ill-formed.
[&nbsp;<i>Note:</i>
Declaring a function as defaulted after its first declaration can provide
efficient execution and concise
definition while enabling a stable binary interface to an evolving code
base.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='default-5'><div class='marginalizedparent'><a class='marginalized' href='#default-5'>5</a></div><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct trivial {
  trivial() = default;
  trivial(const trivial&amp;) = default;
  trivial(trivial&amp;&amp;) = default;
  trivial&amp; operator=(const trivial&amp;) = default;
  trivial&amp; operator=(trivial&amp;&amp;) = default;
  ~trivial() = default;
};

struct nontrivial1 {
  nontrivial1();
};
nontrivial1::nontrivial1() = default;           <span class='comment'>// not first declaration
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='delete'><h3 ><a class='secnum' href='#delete' style='min-width:103pt'>8.4.3</a> Deleted definitions <a class='abbr_ref' href='dcl.fct.def.delete'>[dcl.fct.def.delete]</a></h3><p ><span class='indexparent'><a class='index' id='definition,function,deleted'></a></span></p><div class='para' id='delete-1'><div class='marginalizedparent'><a class='marginalized' href='#delete-1'>1</a></div><p >A function definition of the form:</p><pre class='bnf'><i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.decl#nt:declarator'>declarator</a></i> <span class='terminal'> = delete ;</span></pre><p >is called a <a class='hidden_link' href='#def:deleted_definition' id='def:deleted_definition'><i>deleted definition</i></a>. A function with a
deleted definition is also called a <a class='hidden_link' href='#def:deleted_function' id='def:deleted_function'><i>deleted function</i></a>.</p></div><div class='para' id='delete-2'><div class='marginalizedparent'><a class='marginalized' href='#delete-2'>2</a></div><p >A program that refers to a deleted function implicitly or explicitly, other
than to declare it, is ill-formed. [&nbsp;<i>Note:</i> This includes calling the function
implicitly or explicitly and forming a pointer or pointer-to-member to the
function. It applies even for references in expressions that are not
potentially-evaluated. If a function is overloaded, it is referenced only if the
function is selected by overload resolution. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='delete-3'><div class='marginalizedparent'><a class='marginalized' href='#delete-3'>3</a></div><p >[&nbsp;<i>Example:</i> One can enforce non-default initialization and non-integral
initialization with</p><pre class='codeblock'>
struct onlydouble {
  onlydouble() = delete;              <span class='comment'>// OK, but redundant
</span>  onlydouble(std::intmax_t) = delete;
  onlydouble(double);
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i> One can prevent use of a
class in certain <span class='texttt'>new</span> expressions by using deleted definitions
of a user-declared <span class='texttt'>operator new</span> for that class.</p><pre class='codeblock'>
struct sometype {
  void *operator new(std::size_t) = delete;
  void *operator new[](std::size_t) = delete;
};
sometype *p = new sometype;     <span class='comment'>// error, deleted class <span class='texttt'>operator new</span>
</span>sometype *q = new sometype[3];  <span class='comment'>// error, deleted class <span class='texttt'>operator new[]</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i> One can make a class uncopyable, i.e. move-only, by using deleted
definitions of the copy constructor and copy assignment operator, and then
providing defaulted definitions of the move constructor and move assignment operator.</p><pre class='codeblock'>
struct moveonly {
  moveonly() = default;
  moveonly(const moveonly&amp;) = delete;
  moveonly(moveonly&amp;&amp;) = default;
  moveonly&amp; operator=(const moveonly&amp;) = delete;
  moveonly&amp; operator=(moveonly&amp;&amp;) = default;
  ~moveonly() = default;
};
moveonly *p;
moveonly q(*p); <span class='comment'>// error, deleted copy constructor
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='delete-4'><div class='marginalizedparent'><a class='marginalized' href='#delete-4'>4</a></div><p >A deleted function is implicitly inline. [&nbsp;<i>Note:</i> The
one-definition rule (<a href='basic.def.odr'>[basic.def.odr]</a>) applies to deleted definitions. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
A deleted definition of a function shall be the first declaration of the function or,
for an explicit specialization of a function template, the first declaration of that
specialization.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct sometype {
  sometype();
};
sometype::sometype() = delete;      <span class='comment'>// ill-formed; not first declaration
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='definition,function'></a></span></p></div></div></div></div></body></html>