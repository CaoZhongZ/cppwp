<!DOCTYPE html><html lang='en'><head><title>[basic.align]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><div id='basic.align'><h2 ><a class='secnum' style='min-width:88pt'>3.11</a> Alignment <a class='abbr_ref'>[basic.align]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='alignment_requirement,implementation-defined'></a></span>Object types have <a class='hidden_link' href='#def:alignment_requirements' id='def:alignment_requirements'><i>alignment requirements</i></a> (<a href='basic.fundamental'>[basic.fundamental]</a>, <a href='basic.compound'>[basic.compound]</a>)
which place restrictions on the addresses at which an object of that type
may be allocated. An <a class='hidden_link' href='#def:alignment' id='def:alignment'><i>alignment</i></a> is an <span class='indexparent'><a class='index' id='alignment'></a></span>implementation-defined
integer value representing the number of bytes between successive addresses
at which a given object can be allocated. An object type imposes an alignment
requirement on every object of that type; stricter alignment can be requested
using the alignment specifier (<a href='dcl.align'>[dcl.align]</a>).</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='fundamental_alignment'></a></span><span class='indexparent'><a class='index' id='alignment,fundamental'></a></span>A <a class='hidden_link' href='#def:fundamental_alignment' id='def:fundamental_alignment'><i>fundamental alignment</i></a> is represented by an alignment
less than or equal to the greatest alignment supported by the implementation in
all contexts, which is equal to
<span class='texttt'>alignof(std::max_align_t)</span> (<a href='support.types'>[support.types]</a>).
The alignment required for a type might be different when it is used as the type
of a complete object and when it is used as the type of a subobject. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct B { long double d; };
struct D : virtual B { char c; }
</pre><p >When <span class='texttt'>D</span> is the type of a complete object, it will have a subobject of
type <span class='texttt'>B</span>, so it must be aligned appropriately for a <span class='texttt'>long double</span>.
If <span class='texttt'>D</span> appears as a subobject of another object that also has <span class='texttt'>B</span>
as a virtual base class, the <span class='texttt'>B</span> subobject might be part of a different
subobject, reducing the alignment requirements on the <span class='texttt'>D</span> subobject.
<i>&nbsp;—&nbsp;end example</i>&nbsp;] The result of the <span class='texttt'>alignof</span> operator reflects the alignment
requirement of the type in the complete-object case.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='extended_alignment'></a></span><span class='indexparent'><a class='index' id='alignment,extended'></a></span><span class='indexparent'><a class='index' id='over-aligned_type'></a></span><span class='indexparent'><a class='index' id='type,over-aligned'></a></span>An <a class='hidden_link' href='#def:extended_alignment' id='def:extended_alignment'><i>extended alignment</i></a> is represented by an alignment
greater than <span class='texttt'>alignof(std::max_align_t)</span>. It is implementation-defined
whether any extended alignments are supported and the contexts in which they are
supported (<a href='dcl.align'>[dcl.align]</a>). A type having an extended alignment
requirement is an <span class='grammarterm'>over-aligned type</span>. [&nbsp;<i>Note:</i>
every over-aligned type is or contains a class type
to which extended alignment applies (possibly through a non-static data member).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >Alignments are represented as values of the type <span class='texttt'>std::size_t</span>.
Valid alignments include only those values returned by an <span class='texttt'>alignof</span>
expression for the fundamental types plus an additional <span class='indexparent'><a class='index' id='alignment_additional_values'></a></span>implementation-defined
set of values, which may be empty.
Every alignment value shall be a non-negative integral power of two.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >Alignments have an order from <a class='hidden_link' href='#def:weaker' id='def:weaker'><i>weaker</i></a> to
<a class='hidden_link' href='#def:stronger' id='def:stronger'><i>stronger</i></a> or <a class='hidden_link' href='#def:stricter' id='def:stricter'><i>stricter</i></a> alignments. Stricter
alignments have larger alignment values. An address that satisfies an alignment
requirement also satisfies any weaker valid alignment requirement.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >The alignment requirement of a complete type can be queried using an
<span class='texttt'>alignof</span> expression (<a href='expr.alignof'>[expr.alignof]</a>). Furthermore,
the types <span class='texttt'>char</span>, <span class='texttt'>signed char</span>, and
<span class='texttt'>unsigned char</span> shall have the weakest alignment requirement.
[&nbsp;<i>Note:</i> This enables the character types to be used as the
underlying type for an aligned memory area (<a href='dcl.align'>[dcl.align]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >Comparing alignments is meaningful and provides the obvious results:</p><ul class='itemize'><li id='7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.1'>(7.1)</a></div><p >Two alignments are equal when their numeric values are equal.
</p></li><li id='7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.2'>(7.2)</a></div><p >Two alignments are different when their numeric values are not equal.
</p></li><li id='7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.3'>(7.3)</a></div><p >When an alignment is larger than another it represents a stricter alignment.
</p></li></ul></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >[&nbsp;<i>Note:</i> The runtime pointer alignment function (<a href='ptr.align'>[ptr.align]</a>)
can be used to obtain an aligned pointer within a buffer; the aligned-storage templates
in the library (<a href='meta.trans.other'>[meta.trans.other]</a>) can be used to obtain aligned storage.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >If a request for a specific extended alignment in a specific context is not
supported by an implementation, the program is ill-formed. Additionally, a
request for runtime allocation of dynamic storage for which the requested
alignment cannot be honored shall be treated as an allocation failure.
</p></div></div></div></body></html>