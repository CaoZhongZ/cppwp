<!DOCTYPE html><html lang='en'><head><title>[expr.prim.lambda]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>5.1</a> Primary expressions <a class='abbr_ref' href='expr.prim#lambda'>[expr.prim]</a></h2><div id='expr.prim.lambda'><h3 ><a class='secnum' style='min-width:103pt'>5.1.2</a> Lambda expressions <a class='abbr_ref'>[expr.prim.lambda]</a></h3><p ><span class='indexparent'><a class='index' id='expression,lambda'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Lambda expressions provide a concise way to create simple function objects.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
void abssort(float *x, unsigned N) {
  std::sort(x, x + N,
    [](float a, float b) {
      return std::abs(a) &lt; std::abs(b);
    });
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><pre class='bnf'><a id='nt:lambda-expression'>lambda-expression:</a>
    <i ><a href='expr.prim.lambda#nt:lambda-introducer'>lambda-introducer</a></i> <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i></pre><pre class='bnf'><a id='nt:lambda-introducer'>lambda-introducer:</a>
    <span class='terminal'>[</span> <i ><a href='expr.prim.lambda#nt:lambda-capture'>lambda-capture</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>]</span></pre><pre class='bnf'><a id='nt:lambda-capture'>lambda-capture:</a>
    <i ><a href='expr.prim.lambda#nt:capture-default'>capture-default</a></i>
    <i ><a href='expr.prim.lambda#nt:capture-list'>capture-list</a></i>
    <i ><a href='expr.prim.lambda#nt:capture-default'>capture-default</a></i> <span class='terminal'>,</span> <i ><a href='expr.prim.lambda#nt:capture-list'>capture-list</a></i></pre><pre class='bnf'><a id='nt:capture-default'>capture-default:</a>
    <span class='terminal'>&amp;</span>
    <span class='terminal'>=</span></pre><pre class='bnf'><a id='nt:capture-list'>capture-list:</a>
    <i ><a href='expr.prim.lambda#nt:capture'>capture</a></i> <span class='terminal'>...<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span>
    <i ><a href='expr.prim.lambda#nt:capture-list'>capture-list</a></i> <span class='terminal'>,</span> <i ><a href='expr.prim.lambda#nt:capture'>capture</a></i> <span class='terminal'>...<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span></pre><pre class='bnf'><a id='nt:capture'>capture:</a>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i>
    <span class='terminal'>&amp;</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i>
    <span class='terminal'>this</span></pre><pre class='bnf'><a id='nt:lambda-declarator'>lambda-declarator:</a>
    <span class='terminal'>(</span> <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> <span class='terminal'>)</span> <span class='terminal'>mutable</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The evaluation of a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> results in a prvalue
temporary (<a href='class.temporary'>[class.temporary]</a>). This temporary is called the <a class='hidden_link' href='#def:closure_object' id='def:closure_object'><i>closure object</i></a>. A
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> shall not appear in an unevaluated operand
(Clause <a href='expr'>[expr]</a>). [&nbsp;<i>Note:</i> A closure object behaves like a function
object (<a href='function.objects'>[function.objects]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The type of the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> (which is also the type of the
closure object) is a unique, unnamed non-union class type — called the <a class='hidden_link' href='#def:closure_type' id='def:closure_type'><i>closure
type</i></a> — whose properties are described below. This class type is not an
aggregate (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>). The closure type is declared in the smallest block
scope, class scope, or namespace scope that contains the corresponding
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>. [&nbsp;<i>Note:</i> This determines the set of namespaces and
classes associated with the closure type (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>). The parameter
types of a <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i> do not affect these associated namespaces and
classes. <i>&nbsp;—&nbsp;end note</i>&nbsp;] An implementation may define the closure type differently from what
is described below provided this does not alter the observable behavior of the program
other than by changing:</p><ul ><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >the size and/or alignment of the closure type,</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p >whether the closure type is trivially copyable (Clause <a href='class'>[class]</a>),</p></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><p >whether the closure type is a standard-layout class (Clause <a href='class'>[class]</a>),
or</p></li><li id='3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.4'>(3.4)</a></div><p >whether the closure type is a POD class (Clause <a href='class'>[class]</a>).
</p></li></ul><p >An implementation shall not add members of rvalue reference type to the closure
type.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >If a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> does not include a
<i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i>, it is as if the <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i> were
<span class='texttt'>()</span>. If a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> does not include a
<i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i>, it is as if the <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i>
denotes the following type:</p><ul ><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><p >if the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> is of the form</p><pre class='bnf'><span class='terminal'>{</span> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>return</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>;</span> <span class='terminal'>}</span></pre><p >the type of the returned expression after lvalue-to-rvalue
conversion (<a href='conv.lval'>[conv.lval]</a>), array-to-pointer conversion (<a href='conv.array'>[conv.array]</a>),
and function-to-pointer conversion (<a href='conv.func'>[conv.func]</a>);</p></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><p >otherwise, <span class='texttt'>void</span>.
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto x1 = [](int i){ return i; }; <span class='comment'>// OK: return type is <span class='texttt'>int</span>
</span>auto x2 = []{ return { 1, 2 }; }; <span class='comment'>// error: the return type is <span class='texttt'>void</span> (a
</span>                                  <span class='comment'>// <span class='grammarterm'>braced-init-list</span> is not an expression)
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >The closure type for a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> has a public
<span class='texttt'>inline</span> function call operator (<a href='over.call'>[over.call]</a>) whose parameters and return type
are described by the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> and <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i>
respectively. This function call operator is declared
<span class='texttt'>const</span> (<a href='class.mfct.non-static'>[class.mfct.non-static]</a>) if and only if the
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> is not
followed by <span class='texttt'>mutable</span>. It is neither virtual nor declared <span class='texttt'>volatile</span>. Default
arguments (<a href='dcl.fct.default'>[dcl.fct.default]</a>) shall not be specified in the
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> of a <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i>. Any
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> specified on a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>
applies to the corresponding function call operator.
An <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i> appertains
to the type of the corresponding function call operator. [&nbsp;<i>Note:</i> Names referenced in
the <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i> are looked up in the context in which the
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> appears. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >The closure type for a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> with no <i ><a href='expr.prim.lambda#nt:lambda-capture'>lambda-capture</a></i>
has a public non-virtual non-explicit const conversion function to pointer to function having
the same parameter and return types as the closure type's function call operator. The
value returned by this conversion function shall be the address of a function that, when
invoked, has the same effect as invoking the closure type's function call operator.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >The <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> yields the
<span class='grammarterm'>function-body</span> (<a href='dcl.fct.def'>[dcl.fct.def]</a>) of the function call operator, but for
purposes of name lookup (<a href='basic.lookup'>[basic.lookup]</a>), determining the type and value of
<span class='texttt'>this</span> (<a href='class.this'>[class.this]</a>) and transforming <i ><a href='expr.prim.general#nt:id-expression'>id-expressions</a></i>
referring to non-static class members into class member access expressions using
<span class='texttt'>(*this)</span> (<a href='class.mfct.non-static'>[class.mfct.non-static]</a>), the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> is
considered in the context of the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct S1 {
  int x, y;
  int operator()(int);
  void f() {
    [=]()-&gt;int {
      return operator()(this-&gt;x + y); <span class='comment'>// equivalent to <span class='texttt'>S1::operator()(this-&gt;x + (*this).y)</span>
</span>                                      <span class='comment'>// <span class='texttt'>this</span> has type <span class='texttt'>S1*</span>
</span>    };
  }
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >If a <i ><a href='expr.prim.lambda#nt:lambda-capture'>lambda-capture</a></i> includes a <i ><a href='expr.prim.lambda#nt:capture-default'>capture-default</a></i> that
is <span class='texttt'>&amp;</span>, the identifiers in the <i ><a href='expr.prim.lambda#nt:lambda-capture'>lambda-capture</a></i> shall not be preceded
by <span class='texttt'>&amp;</span>. If a <i ><a href='expr.prim.lambda#nt:lambda-capture'>lambda-capture</a></i> includes a
<i ><a href='expr.prim.lambda#nt:capture-default'>capture-default</a></i> that is <span class='texttt'>=</span>, the <i ><a href='expr.prim.lambda#nt:lambda-capture'>lambda-capture</a></i> shall
not contain <span class='texttt'>this</span> and each identifier it contains shall be preceded by
<span class='texttt'>&amp;</span>. An identifier or <span class='texttt'>this</span> shall not appear more than once in a
<i ><a href='expr.prim.lambda#nt:lambda-capture'>lambda-capture</a></i>. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct S2 { void f(int i); };
void S2::f(int i) {
  [&amp;, i]{ };    <span class='comment'>// OK
</span>  [&amp;, &amp;i]{ };   <span class='comment'>// error: <span class='texttt'>i</span> preceded by <span class='texttt'>&amp;</span> when <span class='texttt'>&amp;</span> is the default
</span>  [=, this]{ }; <span class='comment'>// error: <span class='texttt'>this</span> when <span class='texttt'>=</span> is the default
</span>  [i, i]{ };    <span class='comment'>// error: <span class='texttt'>i</span> repeated
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >A <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> whose smallest enclosing scope is a block
scope (<a href='basic.scope.local'>[basic.scope.local]</a>) is a <a class='hidden_link' href='#def:local_lambda_expression' id='def:local_lambda_expression'><i>local lambda expression</i></a>; any other
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> shall not have a <i ><a href='expr.prim.lambda#nt:capture-list'>capture-list</a></i> in its
<i ><a href='expr.prim.lambda#nt:lambda-introducer'>lambda-introducer</a></i>. The <a class='hidden_link' href='#def:reaching_scope' id='def:reaching_scope'><i>reaching scope</i></a> of a local lambda expression
is the set of enclosing scopes up to and including the innermost enclosing function and
its parameters. [&nbsp;<i>Note:</i> This reaching scope includes any intervening
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expressions</a></i>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >The <span class='grammarterm'>identifiers</span> in a <i ><a href='expr.prim.lambda#nt:capture-list'>capture-list</a></i> are looked up using the
usual rules for unqualified name lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>); each such lookup
shall find a variable with automatic storage duration declared in
the reaching scope of the local lambda expression. An entity (i.e. a variable or
<span class='texttt'>this</span>) is said to be <a class='hidden_link' href='#def:explicitly_captured' id='def:explicitly_captured'><i>explicitly captured</i></a> if it appears in the
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s <i ><a href='expr.prim.lambda#nt:capture-list'>capture-list</a></i>.</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >If a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> has an associated <i ><a href='expr.prim.lambda#nt:capture-default'>capture-default</a></i> and
its <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> odr-uses (<a href='basic.def.odr'>[basic.def.odr]</a>) <span class='texttt'>this</span> or a
variable with automatic storage duration and the odr-used entity is not explicitly
captured, then the odr-used entity is said to be <a class='hidden_link' href='#def:implicitly_captured' id='def:implicitly_captured'><i>implicitly captured</i></a>; such
entities shall be declared within the reaching scope of the lambda expression.
[&nbsp;<i>Note:</i> The implicit capture of an entity by a nested
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> can cause its implicit capture by the containing
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> (see below). Implicit odr-uses of <span class='texttt'>this</span> can result
in implicit capture. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >An entity is <a class='hidden_link' href='#def:captured' id='def:captured'><i>captured</i></a> if it is captured explicitly or implicitly. An entity
captured by a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>) in the scope
containing the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>. If <span class='texttt'>this</span> is captured by a local
lambda expression, its nearest enclosing function shall be a non-static member function.
If a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> odr-uses (<a href='basic.def.odr'>[basic.def.odr]</a>) <span class='texttt'>this</span> or a
variable with automatic storage duration from its reaching scope, that
entity shall be captured by the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>. If a
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> captures an entity and that entity is not defined or
captured in the immediately enclosing lambda expression or function, the program is
ill-formed. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
void f1(int i) {
  int const N = 20;
  auto m1 = [=]{
    int const M = 30;
    auto m2 = [i]{
      int x[N][M];              <span class='comment'>// OK: <span class='texttt'>N</span> and <span class='texttt'>M</span> are not odr-used
</span>      x[0][0] = i;              <span class='comment'>// OK: <span class='texttt'>i</span> is explicitly captured by <span class='texttt'>m2</span>
</span>                                <span class='comment'>// and implicitly captured by <span class='texttt'>m1</span>
</span>    };
  };
  struct s1 {
    int f;
    void work(int n) {
      int m = n*n;
      int j = 40;
      auto m3 = [this,m] {
        auto m4 = [&amp;,j] {       <span class='comment'>// error: <span class='texttt'>j</span> not captured by <span class='texttt'>m3</span>
</span>          int x = n;            <span class='comment'>// error: <span class='texttt'>n</span> implicitly captured by <span class='texttt'>m4</span>
</span>                                <span class='comment'>// but not captured by <span class='texttt'>m3</span>
</span>          x += m;               <span class='comment'>// OK: <span class='texttt'>m</span> implicitly captured by <span class='texttt'>m4</span>
</span>                                <span class='comment'>// and explicitly captured by <span class='texttt'>m3</span>
</span>          x += i;               <span class='comment'>// error: <span class='texttt'>i</span> is outside of the reaching scope
</span>          x += f;               <span class='comment'>// OK: <span class='texttt'>this</span> captured implicitly by <span class='texttt'>m4</span>
</span>                                <span class='comment'>// and explicitly by <span class='texttt'>m3</span>
</span>        };
      };
    }
  };
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p >A <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> appearing in a default argument shall not
implicitly or explicitly capture any entity. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
void f2() {
  int i = 1;
  void g1(int = ([i]{ return i; })());        <span class='comment'>// ill-formed
</span>  void g2(int = ([i]{ return 0; })());        <span class='comment'>// ill-formed
</span>  void g3(int = ([=]{ return i; })());        <span class='comment'>// ill-formed
</span>  void g4(int = ([=]{ return 0; })());        <span class='comment'>// OK
</span>  void g5(int = ([]{ return sizeof i; })());  <span class='comment'>// OK
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><p >An entity is <span class='indexparent'><a class='index' id='captured,by_copy'></a></span><a class='hidden_link' href='#def:captured_by_copy' id='def:captured_by_copy'><i>captured by copy</i></a> if it is implicitly captured and the
<i ><a href='expr.prim.lambda#nt:capture-default'>capture-default</a></i> is <span class='texttt'>=</span> or if it is explicitly captured with a
capture that does not include an <span class='texttt'>&amp;</span>. For each entity captured by copy, an
unnamed non-static data member is declared in the closure type. The declaration order of
these members is unspecified. The type of such a data member is the type of the
corresponding captured entity if the entity is not a reference to an object, or the
referenced type otherwise. [&nbsp;<i>Note:</i> If the captured entity is a reference to a
function, the corresponding data member is also a reference to a function. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><p >An entity is <span class='indexparent'><a class='index' id='captured,by_reference'></a></span><a class='hidden_link' href='#def:captured_by_reference' id='def:captured_by_reference'><i>captured by reference</i></a> if it is implicitly or explicitly
captured but not captured by copy. It is unspecified whether additional unnamed
non-static data members are declared in the closure type for entities captured by
reference.</p></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><p >If a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> <span class='texttt'>m2</span> captures an entity and that entity is
captured by an immediately enclosing <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>
<span class='texttt'>m1</span>, then
<span class='texttt'>m2</span>'s capture is transformed as follows:</p><ul ><li id='16.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#16.1'>(16.1)</a></div><p >if <span class='texttt'>m1</span> captures the entity by copy,
<span class='texttt'>m2</span> captures the corresponding
non-static data member of <span class='texttt'>m1</span>'s closure type;</p></li><li id='16.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#16.2'>(16.2)</a></div><p >if <span class='texttt'>m1</span> captures the entity by reference,
<span class='texttt'>m2</span> captures the same
entity captured by <span class='texttt'>m1</span>.
</p></li></ul><p >[&nbsp;<i>Example:</i> the nested lambda expressions and invocations below will output
<span class='texttt'>123234</span>.
</p><pre class='codeblock'>
int a = 1, b = 1, c = 1;
auto m1 = [a, &amp;b, &amp;c]() mutable {
  auto m2 = [a, b, &amp;c]() mutable {
    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;
    a = 4; b = 4; c = 4;
  };
  a = 3; b = 3; c = 3;
  m2();
};
a = 2; b = 2; c = 2;
m1();
std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><p >Every <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> that is an odr-use (<a href='basic.def.odr'>[basic.def.odr]</a>) of an
entity captured by copy is transformed into an access to the corresponding unnamed data
member of the closure type.
[&nbsp;<i>Note:</i> An <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> that is not an odr-use refers to
the original entity, never to a member of the closure type. Furthermore, such
an <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> does not cause the implicit capture of the
entity. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
If <span class='texttt'>this</span> is captured, each odr-use of <span class='texttt'>this</span> is
transformed into an access to the corresponding unnamed data member of the closure type,
cast (<a href='expr.cast'>[expr.cast]</a>) to the type of <span class='texttt'>this</span>. [&nbsp;<i>Note:</i> The cast ensures that the
transformed expression is a prvalue. <i>&nbsp;—&nbsp;end note</i>&nbsp;] [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
void f(const int*);
void g() {
  const int N = 10;
  [=] {
    int arr[N];             <span class='comment'>// OK: not an odr-use, refers to automatic variable
</span>    f(&amp;N);                  <span class='comment'>// OK: causes <span class='texttt'>N</span> to be captured; <span class='texttt'>&amp;N</span> points to the
</span>                            <span class='comment'>// corresponding member of the closure type
</span>  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><p >Every occurrence of <span class='texttt'>decltype((x))</span> where <span class='texttt'>x</span> is a possibly
parenthesized <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> that names an entity of automatic storage
duration is treated as if <span class='texttt'>x</span> were transformed into an access to a corresponding
data member of the closure type that would have been declared if <span class='texttt'>x</span> were an odr-use of
the denoted entity. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
void f3() {
  float x, &amp;r = x;
  [=] {                     <span class='comment'>// <span class='texttt'>x</span> and <span class='texttt'>r</span> are not captured (appearance in a <span class='texttt'>decltype</span> operand is not an odr-use)
</span>    decltype(x) y1;         <span class='comment'>// <span class='texttt'>y1</span> has type <span class='texttt'>float</span>
</span>    decltype((x)) y2 = y1;  <span class='comment'>// <span class='texttt'>y2</span> has type <span class='texttt'>float const&amp;</span> because this lambda
</span>                            <span class='comment'>// is not <span class='texttt'>mutable</span> and <span class='texttt'>x</span> is an lvalue
</span>    decltype(r) r1 = y1;    <span class='comment'>// <span class='texttt'>r1</span> has type <span class='texttt'>float&amp;</span> (transformation not considered)
</span>    decltype((r)) r2 = y2;  <span class='comment'>// <span class='texttt'>r2</span> has type <span class='texttt'>float const&amp;</span>
</span>  };
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='19'><div class='marginalizedparent'><a class='marginalized' href='#19'>19</a></div><p >The closure type associated with a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> has a
deleted (<a href='dcl.fct.def.delete'>[dcl.fct.def.delete]</a>)
default constructor and a deleted copy assignment operator. It has an
implicitly-declared copy constructor (<a href='class.copy'>[class.copy]</a>)
and may have an implicitly-declared move constructor (<a href='class.copy'>[class.copy]</a>).
[&nbsp;<i>Note:</i> The copy/move constructor
is implicitly defined in the same way as any other implicitly declared copy/move constructor
would be implicitly defined. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='20'><div class='marginalizedparent'><a class='marginalized' href='#20'>20</a></div><p >The closure type associated with a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> has an
implicitly-declared destructor (<a href='class.dtor'>[class.dtor]</a>).</p></div><div class='para' id='21'><div class='marginalizedparent'><a class='marginalized' href='#21'>21</a></div><p >When the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> is evaluated, the entities that are
captured by copy are used to direct-initialize each corresponding non-static data member
of the resulting closure object. (For array members, the array elements are
direct-initialized in increasing subscript order.) These initializations are performed
in the (unspecified) order in which the non-static data members are declared. [&nbsp;<i>Note:</i>
This ensures that the destructions will occur in the reverse order of the constructions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='22'><div class='marginalizedparent'><a class='marginalized' href='#22'>22</a></div><p >[&nbsp;<i>Note:</i> If an entity is implicitly or explicitly captured by reference,
invoking the function call operator of the corresponding <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>
after the lifetime of the entity has ended is likely to result in undefined behavior.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='23'><div class='marginalizedparent'><a class='marginalized' href='#23'>23</a></div><p >A <i ><a href='expr.prim.lambda#nt:capture'>capture</a></i> followed by an ellipsis is a pack expansion (<a href='temp.variadic'>[temp.variadic]</a>).
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class... Args&gt;
void f(Args... args) {
  auto lm = [&amp;, args...] { return g(args...); };
  lm();
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='expression,lambda'></a></span><span class='indexparent'><a class='index' id='expression,primary'></a></span></p></div></div></div></body></html>