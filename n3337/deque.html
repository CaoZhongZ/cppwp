<!DOCTYPE html><html lang='en'><head><title>[deque]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>23</a> Containers library <a class='abbr_ref' href='./#containers'>[containers]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>23.3</a> Sequence containers <a class='abbr_ref' href='sequences#deque'>[sequences]</a></h2><div id='deque'><h3 ><a class='secnum' style='min-width:103pt'>23.3.3</a> Class template <span class='texttt'>deque</span> <a class='abbr_ref'>[deque]</a></h3><div id='overview'><h4 ><a class='secnum' href='#overview' style='min-width:118pt'>23.3.3.1</a> Class template <span class='texttt'>deque</span> overview <a class='abbr_ref' href='deque.overview'>[deque.overview]</a></h4><div class='para' id='overview-1'><div class='marginalizedparent'><a class='marginalized' href='#overview-1'>1</a></div><p >A
<span class='indexparent'><a class='index' id='deque'></a></span><span class='texttt'>deque</span>
is a sequence container that, like a
<span class='texttt'>vector</span> (<a href='vector'>[vector]</a>), supports random access iterators.
In addition, it supports constant time insert and erase operations at the beginning or the end;
insert and erase in the middle take linear time.
That is, a deque is especially optimized for pushing and popping elements at the beginning and end.
As with vectors, storage management is handled automatically.</p></div><div class='para' id='overview-2'><div class='marginalizedparent'><a class='marginalized' href='#overview-2'>2</a></div><p >A
<span class='texttt'>deque</span>
satisfies all of the requirements of a container, of a reversible container
(given in tables in <a href='container.requirements'>[container.requirements]</a>), of a sequence container,
including the optional sequence container requirements (<a href='sequence.reqmts'>[sequence.reqmts]</a>), and of an allocator-aware container (Table <a href='container.requirements.general#tab:containers.allocatoraware'>[tab:containers.allocatoraware]</a>).
Descriptions are provided here only for operations on
<span class='texttt'>deque</span>
that are not described in one of these tables
or for operations where there is additional semantic information.</p><pre class='codeblock'>
namespace std {
  template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
  class deque {
  public:
    <span class='comment'>// types:
</span>    typedef value_type&amp;                           reference;
    typedef const value_type&amp;                     const_reference;
    typedef <i>implementation-defined</i>                iterator;       <span class='comment'>// See <a href='container.requirements'>[container.requirements]</a>
</span>    typedef <i>implementation-defined</i>                const_iterator; <span class='comment'>// See <a href='container.requirements'>[container.requirements]</a>
</span>    typedef <i>implementation-defined</i>                size_type;      <span class='comment'>// See <a href='container.requirements'>[container.requirements]</a>
</span>    typedef <i>implementation-defined</i>                difference_type;<span class='comment'>// See <a href='container.requirements'>[container.requirements]</a>
</span>    typedef T                                     value_type;
    typedef Allocator                             allocator_type;
    typedef typename allocator_traits&lt;Allocator&gt;::pointer           pointer;
    typedef typename allocator_traits&lt;Allocator&gt;::const_pointer     const_pointer;
    typedef std::reverse_iterator&lt;iterator&gt;       reverse_iterator;
    typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;

    <span class='comment'>// <a href='deque.cons'>[deque.cons]</a>, construct/copy/destroy:
</span>    explicit deque(const Allocator&amp; = Allocator());
    explicit deque(size_type n);
    deque(size_type n, const T&amp; value,const Allocator&amp; = Allocator());
    template &lt;class InputIterator&gt;
      deque(InputIterator first, InputIterator last,const Allocator&amp; = Allocator());
    deque(const deque&amp; x);
    deque(deque&amp;&amp;);
    deque(const deque&amp;, const Allocator&amp;);
    deque(deque&amp;&amp;, const Allocator&amp;);
    deque(initializer_list&lt;T&gt;, const Allocator&amp; = Allocator());

    ~deque();
    deque&amp; operator=(const deque&amp; x);
    deque&amp; operator=(deque&amp;&amp; x);
    deque&amp; operator=(initializer_list&lt;T&gt;);
    template &lt;class InputIterator&gt;
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T&amp; t);
    void assign(initializer_list&lt;T&gt;);
    allocator_type get_allocator() const noexcept;

    <span class='comment'>// iterators:
</span>    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    <span class='comment'>// <a href='deque.capacity'>[deque.capacity]</a>, capacity:
</span>    size_type size() const noexcept;
    size_type max_size() const noexcept;
    void      resize(size_type sz);
    void      resize(size_type sz, const T&amp; c);
    void      shrink_to_fit();
    bool      empty() const noexcept;

    <span class='comment'>// element access:
</span>    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    reference       at(size_type n);
    const_reference at(size_type n) const;
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    <span class='comment'>// <a href='deque.modifiers'>[deque.modifiers]</a>, modifiers:
</span>    template &lt;class... Args&gt; void emplace_front(Args&amp;&amp;... args);
    template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);
    template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);

    void push_front(const T&amp; x);
    void push_front(T&amp;&amp; x);
    void push_back(const T&amp; x);
    void push_back(T&amp;&amp; x);

    iterator insert(const_iterator position, const T&amp; x);
    iterator insert(const_iterator position, T&amp;&amp; x);
    iterator insert(const_iterator position, size_type n, const T&amp; x);
    template &lt;class InputIterator&gt;
      iterator insert (const_iterator position, InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list&lt;T&gt;);

    void pop_front();
    void pop_back();

    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void     swap(deque&amp;);
    void     clear() noexcept;
  };

  template &lt;class T, class Allocator&gt;
    bool operator==(const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt; (const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator!=(const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt; (const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&gt;=(const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y);
  template &lt;class T, class Allocator&gt;
    bool operator&lt;=(const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y);

  <span class='comment'>// specialized algorithms:
</span>  template &lt;class T, class Allocator&gt;
    void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
}
</pre></div></div><div id='cons'><h4 ><a class='secnum' href='#cons' style='min-width:118pt'>23.3.3.2</a> <span class='texttt'>deque</span> constructors, copy, and assignment <a class='abbr_ref' href='deque.cons'>[deque.cons]</a></h4><p ><span class='indexparent'><a class='index' id='deque,deque'></a></span><span class='indexparent'><a class='index' id='deque,deque'></a></span><code class='itemdecl'>
explicit deque(const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='cons-1'><div class='marginalizedparent'><a class='marginalized' href='#cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an empty
<span class='texttt'>deque</span>,
using the specified allocator.</p></div></div><div class='para' id='cons-2'><div class='marginalizedparent'><a class='marginalized' href='#cons-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Constant.
</p></div></div><p ><span class='indexparent'><a class='index' id='deque,deque'></a></span><span class='indexparent'><a class='index' id='deque,deque'></a></span><code class='itemdecl'>
explicit deque(size_type n);
</code></p><div class='itemdescr'></div><div class='para' id='cons-3'><div class='marginalizedparent'><a class='marginalized' href='#cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>deque</span> with
<span class='texttt'>n</span> value-initialized elements.</p></div></div><div class='para' id='cons-4'><div class='marginalizedparent'><a class='marginalized' href='#cons-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>DefaultConstructible</span>.</p></div></div><div class='para' id='cons-5'><div class='marginalizedparent'><a class='marginalized' href='#cons-5'>5</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear in <span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='deque,deque'></a></span><span class='indexparent'><a class='index' id='deque,deque'></a></span><code class='itemdecl'>
deque(size_type n, const T&amp; value,
      const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='cons-6'><div class='marginalizedparent'><a class='marginalized' href='#cons-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a
<span class='texttt'>deque</span>
with <span class='texttt'>n</span> copies of <span class='texttt'>value</span>,
using the specified allocator.</p></div></div><div class='para' id='cons-7'><div class='marginalizedparent'><a class='marginalized' href='#cons-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>CopyInsertable</span> into <span class='texttt'>*this</span>.</p></div></div><div class='para' id='cons-8'><div class='marginalizedparent'><a class='marginalized' href='#cons-8'>8</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Linear in <span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='deque,deque'></a></span><span class='indexparent'><a class='index' id='deque,deque'></a></span><code class='itemdecl'>
template &lt;class InputIterator&gt;
  deque(InputIterator first, InputIterator last,
        const Allocator&amp; = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='cons-9'><div class='marginalizedparent'><a class='marginalized' href='#cons-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a
<span class='texttt'>deque</span>
equal to the range
<span class='texttt'>[<span class='discretionary'></span>first,<span class='discretionary'></span>last<span class='discretionary'></span>)</span>,
using the specified allocator.</p></div></div><div class='para' id='cons-10'><div class='marginalizedparent'><a class='marginalized' href='#cons-10'>10</a></div><div class='itemdescr'><p ><i>Complexity:</i>
<span class='texttt'>distance(first, last)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='assign,deque'></a></span><code class='itemdecl'>
template &lt;class InputIterator&gt;
  void assign(InputIterator first, InputIterator last);
</code></p><div class='itemdescr'></div><div class='para' id='cons-11'><div class='marginalizedparent'><a class='marginalized' href='#cons-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
erase(begin(), end());
insert(begin(), first, last);
</pre></div></div><p ><span class='indexparent'><a class='index' id='assign,deque'></a></span><span class='indexparent'><a class='index' id='deque,assign'></a></span><code class='itemdecl'>
void assign(size_type n, const T&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='cons-12'><div class='marginalizedparent'><a class='marginalized' href='#cons-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
erase(begin(), end());
insert(begin(), n, t);
</pre></div></div></div><div id='capacity'><h4 ><a class='secnum' href='#capacity' style='min-width:118pt'>23.3.3.3</a> <span class='texttt'>deque</span> capacity <a class='abbr_ref' href='deque.capacity'>[deque.capacity]</a></h4><p ><span class='indexparent'><a class='index' id='resize,deque'></a></span><code class='itemdecl'>
void resize(size_type sz);
</code></p><div class='itemdescr'></div><div class='para' id='capacity-1'><div class='marginalizedparent'><a class='marginalized' href='#capacity-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>sz &lt;= size()</span>, equivalent to
<span class='texttt'>erase(begin() + sz, end());</span>. If <span class='texttt'>size() &lt; sz</span>,
appends <span class='texttt'>sz - size()</span> value-initialized elements to the
sequence.</p></div></div><div class='para' id='capacity-2'><div class='marginalizedparent'><a class='marginalized' href='#capacity-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be
<span class='texttt'>DefaultConstructible</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='resize,deque'></a></span><code class='itemdecl'>
void resize(size_type sz, const T&amp; c);
</code></p><div class='itemdescr'></div><div class='para' id='capacity-3'><div class='marginalizedparent'><a class='marginalized' href='#capacity-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
if (sz &gt; size())
  insert(end(), sz-size(), c);
else if (sz &lt; size())
  erase(begin()+sz, end());
else
  ;                 <span class='comment'>// do nothing
</span></pre></div></div><div class='para' id='capacity-4'><div class='marginalizedparent'><a class='marginalized' href='#capacity-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be <span class='texttt'>CopyInsertable</span> into <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shrink_to_fit,deque'></a></span><span class='indexparent'><a class='index' id='deque,shrink_to_fit'></a></span><code class='itemdecl'>
void shrink_to_fit();
</code></p><div class='itemdescr'></div><div class='para' id='capacity-5'><div class='marginalizedparent'><a class='marginalized' href='#capacity-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>shrink_to_fit</span> is a non-binding request to reduce memory use. [&nbsp;<i>Note:</i> The request is non-binding to allow latitude for implementation-specific optimizations. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='modifiers'><h4 ><a class='secnum' href='#modifiers' style='min-width:118pt'>23.3.3.4</a> <span class='texttt'>deque</span> modifiers <a class='abbr_ref' href='deque.modifiers'>[deque.modifiers]</a></h4><p ><span class='indexparent'><a class='index' id='insert,deque'></a></span><span class='indexparent'><a class='index' id='insert,deque'></a></span><span class='indexparent'><a class='index' id='insert,deque'></a></span><span class='indexparent'><a class='index' id='insert,deque'></a></span><code class='itemdecl'>
iterator insert(const_iterator position, const T&amp; x);
iterator insert(const_iterator position, T&amp;&amp; x);
iterator insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;
  iterator insert(const_iterator position,
                  InputIterator first, InputIterator last);
iterator insert(const_iterator position, initializer_list&lt;T&gt;);

template &lt;class... Args&gt; void emplace_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
void push_front(const T&amp; x);
void push_front(T&amp;&amp; x);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='modifiers-1'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
An insertion in the middle of the deque invalidates all the iterators and
references to elements of the deque.
An insertion at either end of the
deque invalidates all the iterators to the deque, but has no effect on
the validity of references to elements of the deque.</p></div></div><div class='para' id='modifiers-2'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If an exception is thrown other than by the
copy constructor, move constructor,
assignment operator, or move assignment operator of
<span class='texttt'>T</span>
there are no effects.
If an exception is thrown by the move constructor of a
non-<span class='texttt'>CopyInsertable</span>
<span class='texttt'>T</span>, the effects are unspecified.</p></div></div><div class='para' id='modifiers-3'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
The complexity is linear in the number of elements inserted plus the lesser
of the distances to the beginning and end of the deque.
Inserting a single element either at the beginning or end of a deque always takes constant time
and causes a single call to a constructor of
<span class='texttt'>T</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='erase,deque'></a></span><code class='itemdecl'>
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
</code></p><div class='itemdescr'></div><div class='para' id='modifiers-4'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
An erase operation that erases the last element of a deque invalidates only the past-the-end iterator
and all iterators and references to the erased elements. An erase operation that erases the first
element of a deque but not the last element invalidates only the erased elements. An erase operation
that erases neither the first element nor the last element of a deque invalidates the past-the-end
iterator and all iterators and references to all the elements of the deque.</p></div></div><div class='para' id='modifiers-5'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-5'>5</a></div><div class='itemdescr'><p ><i>Complexity:</i>
The number of calls to the destructor is the same as the
number of elements erased, but the number of calls to the assignment operator is
no more than the lesser of the number of elements before the erased elements and the number of elements after the erased elements.</p></div></div><div class='para' id='modifiers-6'><div class='marginalizedparent'><a class='marginalized' href='#modifiers-6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i>
Nothing unless an exception is thrown by the copy constructor, move constructor,
assignment operator, or move assignment operator of
<span class='texttt'>T</span>.
</p></div></div></div><div id='special'><h4 ><a class='secnum' href='#special' style='min-width:118pt'>23.3.3.5</a> <span class='texttt'>deque</span> specialized algorithms <a class='abbr_ref' href='deque.special'>[deque.special]</a></h4><p ><span class='indexparent'><a class='index' id='swap,deque'></a></span><span class='indexparent'><a class='index' id='deque,swap'></a></span><code class='itemdecl'>
template &lt;class T, class Allocator&gt;
  void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='special-1'><div class='marginalizedparent'><a class='marginalized' href='#special-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
x.swap(y);
</pre></div></div></div></div></div></body></html>