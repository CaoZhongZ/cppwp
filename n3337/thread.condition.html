<!DOCTYPE html><html lang='en'><head><title>[thread.condition]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>30</a> Thread support library <a class='abbr_ref' href='./#thread'>[thread]</a></h1><div id='thread.condition'><h2 ><a class='secnum' style='min-width:88pt'>30.5</a> Condition variables <a class='abbr_ref'>[thread.condition]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Condition variables provide synchronization primitives used to block a thread until
notified by some other thread that some condition is met or until a system time is
reached. Class <span class='texttt'>condition_variable</span> provides a condition variable that can only
wait on an object of type <span class='texttt'>unique_lock&lt;mutex&gt;</span>, allowing maximum efficiency on some
platforms. Class <span class='texttt'>condition_variable_any</span> provides a general condition variable
that can wait on objects of user-supplied lock types.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Condition variables permit concurrent invocation of the <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>,
<span class='texttt'>wait_until</span>, <span class='texttt'>notify_one</span> and <span class='texttt'>notify_all</span> member functions.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The execution of <span class='texttt'>notify_one</span> and <span class='texttt'>notify_all</span> shall be atomic. The
execution of <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, and <span class='texttt'>wait_until</span> shall be performed
in three atomic parts:</p><ol class='enumerate'><li ><p >the release of the mutex and entry into the waiting state;
</p></li><li ><p >the unblocking of the wait; and
</p></li><li ><p >the reacquisition of the lock.
</p></li></ol></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The implementation shall behave as if <span class='texttt'>notify_one</span>, <span class='texttt'>notify_all</span>, and each
part of the <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, and <span class='texttt'>wait_until</span> executions are
executed in some unspecified total order.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >Condition variable construction and destruction need not be synchronized.</p><p ><b>Header <span class='texttt'>condition_variable</span> synopsis</b>
<span class='indexparent'><a class='index' id='condition_variable'></a></span>
</p><pre class='codeblock'>
namespace std {
  class condition_variable;
  class condition_variable_any;

  void notify_all_at_thread_exit(condition_variable&amp; cond, unique_lock&lt;mutex&gt; lk);

  enum class cv_status { no_timeout, timeout };
}
</pre><p ><span class='indexparent'><a class='index' id='notify_all_at_thread_exit'></a></span><code class='itemdecl'>
void notify_all_at_thread_exit(condition_variable&amp; cond, unique_lock&lt;mutex&gt; lk);
</code></p></div><div class='itemdescr'></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lk</span> is locked by the calling thread and either</p><ul class='itemize'><li id='6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.1'>(6.1)</a></div><p >no other thread is waiting on <span class='texttt'>cond</span>, or
</p></li><li id='6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.2'>(6.2)</a></div><p ><span class='texttt'>lk.mutex()</span> returns the same value for each of the lock arguments
supplied by all concurrently waiting (via <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>,
or <span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> transfers ownership of the lock associated with <span class='texttt'>lk</span> into
internal storage and schedules <span class='texttt'>cond</span> to be notified when the current
thread exits, after all objects of thread storage duration associated with
the current thread have been destroyed. This notification shall be as if
</p><pre class='codeblock'>
lk.unlock();
cond.notify_all();
</pre></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='itemdescr'><p ><i>Synchronization:</i> The call to <span class='texttt'>notify_all_at_thread_exit</span> and the completion of the
destructors for all the current thread's variables of thread storage
duration synchronize with (<a href='intro.multithread'>[intro.multithread]</a>) calls to functions
waiting on <span class='texttt'>cond</span>.</p></div></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='itemdescr'><p ><i>Note:</i> The supplied lock will be held until the thread exits, and care
must be taken to ensure that this does not cause deadlock due to lock
ordering issues. After calling <span class='texttt'>notify_all_at_thread_exit</span> it is
recommended that the thread should be exited as soon as possible, and
that no blocking or time-consuming tasks are run on that thread.</p></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='itemdescr'><p ><i>Note:</i> It is the user's responsibility to ensure that waiting threads
do not erroneously assume that the thread has finished if they experience
spurious wakeups. This typically requires that the condition being waited
for is satisfied while holding the lock on <span class='texttt'>lk</span>, and that this lock
is not released and reacquired prior to calling <span class='texttt'>notify_all_at_thread_exit</span>.
</p></div></div><div id='condvar'><h3 ><a class='secnum' href='#condvar' style='min-width:103pt'>30.5.1</a> Class <span class='texttt'>condition_variable</span> <a class='abbr_ref' href='thread.condition.condvar'>[thread.condition.condvar]</a></h3><pre class='codeblock'>
namespace std {
  class condition_variable {
  public:

    condition_variable();
    ~condition_variable();

    condition_variable(const condition_variable&amp;) = delete;
    condition_variable&amp; operator=(const condition_variable&amp;) = delete;

    void notify_one() noexcept;
    void notify_all() noexcept;
    void wait(unique_lock&lt;mutex&gt;&amp; lock);
    template &lt;class Predicate&gt;
      void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
    template &lt;class Clock, class Duration&gt;
      cv_status wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                           const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    template &lt;class Clock, class Duration, class Predicate&gt;
      bool wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                      const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
                      Predicate pred);

    template &lt;class Rep, class Period&gt;
      cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                         const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template &lt;class Rep, class Period, class Predicate&gt;
      bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                    const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
                    Predicate pred);

    typedef <i>implementation-defined</i> native_handle_type; <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>    native_handle_type native_handle();                <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>  };
}
</pre><div class='para' id='condvar-1'><div class='marginalizedparent'><a class='marginalized' href='#condvar-1'>1</a></div><p >The class <span class='texttt'>condition_variable</span> shall be a standard-layout class (Clause <a href='class'>[class]</a>).</p><p ><span class='indexparent'><a class='index' id='condition_variable,constructor'></a></span><code class='itemdecl'>
condition_variable();
</code></p></div><div class='itemdescr'></div><div class='para' id='condvar-2'><div class='marginalizedparent'><a class='marginalized' href='#condvar-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>condition_variable</span>.</p></div></div><div class='para' id='condvar-3'><div class='marginalizedparent'><a class='marginalized' href='#condvar-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='condvar-4'><div class='marginalizedparent'><a class='marginalized' href='#condvar-4'>4</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='condvar-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-4.1'>(4.1)</a></div><p ><span class='texttt'>resource_unavailable_try_again</span> â€” if some non-memory resource
limitation prevents initialization.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='condition_variable,destructor'></a></span><code class='itemdecl'>
~condition_variable();
</code></p><div class='itemdescr'></div><div class='para' id='condvar-5'><div class='marginalizedparent'><a class='marginalized' href='#condvar-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> There shall be no thread blocked on <span class='texttt'>*this</span>. [&nbsp;<i>Note:</i> That is, all
threads shall have been notified; they may subsequently block on the lock specified in the
wait.
This relaxes the usual rules, which would have required all wait calls to happen before
destruction. Only the notification to unblock the wait must happen before destruction.
The user must take care to ensure that no threads wait on <span class='texttt'>*this</span> once the destructor has
been started, especially when the waiting threads are calling the wait functions in a loop or
using the overloads of <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span> that take a predicate.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condvar-6'><div class='marginalizedparent'><a class='marginalized' href='#condvar-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys the object.
</p></div></div><p ><span class='indexparent'><a class='index' id='condition_variable,notify_one'></a></span><span class='indexparent'><a class='index' id='notify_one,condition_variable'></a></span><code class='itemdecl'>
void notify_one() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='condvar-7'><div class='marginalizedparent'><a class='marginalized' href='#condvar-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> If any threads are blocked waiting for <span class='texttt'>*this</span>, unblocks one of those threads.
</p></div></div><p ><span class='indexparent'><a class='index' id='condition_variable,notify_all'></a></span><span class='indexparent'><a class='index' id='notify_all,condition_variable'></a></span><code class='itemdecl'>
void notify_all() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='condvar-8'><div class='marginalizedparent'><a class='marginalized' href='#condvar-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Unblocks all threads that are blocked waiting for <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='condition_variable,wait'></a></span><span class='indexparent'><a class='index' id='wait,condition_variable'></a></span><code class='itemdecl'>
void wait(unique_lock&lt;mutex&gt;&amp; lock);
</code></p><div class='itemdescr'></div><div class='para' id='condvar-9'><div class='marginalizedparent'><a class='marginalized' href='#condvar-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread, and either
</p><ul class='itemize'><li id='condvar-9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-9.1'>(9.1)</a></div><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li id='condvar-9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-9.2'>(9.2)</a></div><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span>
arguments supplied by all concurrently waiting (via <span class='texttt'>wait</span> or
<span class='texttt'>timed_wait</span>) threads.
</p></li></ul></div></div><div class='para' id='condvar-10'><div class='marginalizedparent'><a class='marginalized' href='#condvar-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='condvar-10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-10.1'>(10.1)</a></div><p >Atomically calls <span class='texttt'>lock.unlock()</span> and blocks on <span class='texttt'>*this</span>.
</p></li><li id='condvar-10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-10.2'>(10.2)</a></div><p >When unblocked, calls <span class='texttt'>lock.lock()</span> (possibly blocking on the lock), then returns.
</p></li><li id='condvar-10.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-10.3'>(10.3)</a></div><p >The function will unblock when signaled by a call to <span class='texttt'>notify_one()</span>
or a call to <span class='texttt'>notify_all()</span>, or spuriously.
</p></li><li id='condvar-10.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-10.4'>(10.4)</a></div><p >If the function exits via an exception, <span class='texttt'>lock.lock()</span> shall be
called prior to exiting the function scope.
</p></li></ul></div></div><div class='para' id='condvar-11'><div class='marginalizedparent'><a class='marginalized' href='#condvar-11'>11</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='condvar-12'><div class='marginalizedparent'><a class='marginalized' href='#condvar-12'>12</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='condvar-13'><div class='marginalizedparent'><a class='marginalized' href='#condvar-13'>13</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='condvar-13.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-13.1'>(13.1)</a></div><p >equivalent error condition from <span class='texttt'>lock.lock()</span> or <span class='texttt'>lock.unlock()</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='condition_variable,wait'></a></span><span class='indexparent'><a class='index' id='wait,condition_variable'></a></span><code class='itemdecl'>
template &lt;class Predicate&gt;
  void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='condvar-14'><div class='marginalizedparent'><a class='marginalized' href='#condvar-14'>14</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span> is
locked by the calling thread, and either</p><ul class='itemize'><li id='condvar-14.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-14.1'>(14.1)</a></div><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li id='condvar-14.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-14.2'>(14.2)</a></div><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span>
arguments supplied by all concurrently waiting (via <span class='texttt'>wait</span> or
<span class='texttt'>timed_wait</span>) threads.
</p></li></ul></div></div><div class='para' id='condvar-15'><div class='marginalizedparent'><a class='marginalized' href='#condvar-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
while (!pred())
  wait(lock);
</pre></div></div><div class='para' id='condvar-16'><div class='marginalizedparent'><a class='marginalized' href='#condvar-16'>16</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='condvar-17'><div class='marginalizedparent'><a class='marginalized' href='#condvar-17'>17</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>std::system_error</span> when an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='condvar-18'><div class='marginalizedparent'><a class='marginalized' href='#condvar-18'>18</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='condvar-18.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-18.1'>(18.1)</a></div><p >equivalent error condition from <span class='texttt'>lock.lock()</span> or
<span class='texttt'>lock.unlock()</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='condition_variable,wait_until'></a></span><span class='indexparent'><a class='index' id='wait_until,condition_variable'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration&gt;
  cv_status wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                       const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</code></p><div class='itemdescr'></div><div class='para' id='condvar-19'><div class='marginalizedparent'><a class='marginalized' href='#condvar-19'>19</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread, and either
</p><ul class='itemize'><li id='condvar-19.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-19.1'>(19.1)</a></div><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li id='condvar-19.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-19.2'>(19.2)</a></div><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span>
arguments supplied by all concurrently waiting (via <span class='texttt'>wait</span>,
<span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='condvar-20'><div class='marginalizedparent'><a class='marginalized' href='#condvar-20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='condvar-20.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-20.1'>(20.1)</a></div><p >Atomically calls <span class='texttt'>lock.unlock()</span> and blocks on <span class='texttt'>*this</span>.</p></li><li id='condvar-20.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-20.2'>(20.2)</a></div><p >When unblocked, calls <span class='texttt'>lock.lock()</span> (possibly blocking on the lock), then returns.</p></li><li id='condvar-20.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-20.3'>(20.3)</a></div><p >The function will unblock when signaled by a call to <span class='texttt'>notify_one()</span>, a call to <span class='texttt'>notify_all()</span>,
expiration of the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span>,
or spuriously.</p></li><li id='condvar-20.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-20.4'>(20.4)</a></div><p >If the function exits via an exception, <span class='texttt'>lock.lock()</span> shall be called prior to exiting the function scope.
</p></li></ul></div></div><div class='para' id='condvar-21'><div class='marginalizedparent'><a class='marginalized' href='#condvar-21'>21</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='condvar-22'><div class='marginalizedparent'><a class='marginalized' href='#condvar-22'>22</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cv_status::timeout</span> if
the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span> expired,
otherwise <span class='texttt'>cv_status::no_timeout</span>.</p></div></div><div class='para' id='condvar-23'><div class='marginalizedparent'><a class='marginalized' href='#condvar-23'>23</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='condvar-24'><div class='marginalizedparent'><a class='marginalized' href='#condvar-24'>24</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='condvar-24.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-24.1'>(24.1)</a></div><p >equivalent error condition from <span class='texttt'>lock.lock()</span> or <span class='texttt'>lock.unlock()</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='condition_variable,wait_for'></a></span><span class='indexparent'><a class='index' id='wait_for,condition_variable'></a></span><code class='itemdecl'>
template &lt;class Rep, class Period&gt;
  cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                     const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></p><div class='itemdescr'></div><div class='para' id='condvar-25'><div class='marginalizedparent'><a class='marginalized' href='#condvar-25'>25</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread, and either
</p><ul class='itemize'><li id='condvar-25.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-25.1'>(25.1)</a></div><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li id='condvar-25.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-25.2'>(25.2)</a></div><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span> arguments
supplied by all concurrently waiting (via <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, or
<span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='condvar-26'><div class='marginalizedparent'><a class='marginalized' href='#condvar-26'>26</a></div><div class='itemdescr'><p ><i>Effects:</i> as if</p><pre class='codeblock'>
return wait_until(lock, chrono::steady_clock::now() + rel_time);
</pre></div></div><div class='para' id='condvar-27'><div class='marginalizedparent'><a class='marginalized' href='#condvar-27'>27</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cv_status::timeout</span> if
the relative timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>rel_time</span> expired,
otherwise <span class='texttt'>cv_status::no_timeout</span>.</p></div></div><div class='para' id='condvar-28'><div class='marginalizedparent'><a class='marginalized' href='#condvar-28'>28</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='condvar-29'><div class='marginalizedparent'><a class='marginalized' href='#condvar-29'>29</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='condvar-30'><div class='marginalizedparent'><a class='marginalized' href='#condvar-30'>30</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='condvar-30.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-30.1'>(30.1)</a></div><p >equivalent error condition from <span class='texttt'>lock.lock()</span> or <span class='texttt'>lock.unlock()</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='condition_variable,wait_until'></a></span><span class='indexparent'><a class='index' id='wait_until,condition_variable'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration, class Predicate&gt;
  bool wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
                  Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='condvar-31'><div class='marginalizedparent'><a class='marginalized' href='#condvar-31'>31</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span> is
locked by the calling thread, and either</p><ul class='itemize'><li id='condvar-31.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-31.1'>(31.1)</a></div><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li id='condvar-31.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-31.2'>(31.2)</a></div><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span>
arguments supplied by all concurrently waiting (via <span class='texttt'>wait</span> or
<span class='texttt'>timed_wait</span>) threads.
</p></li></ul></div></div><div class='para' id='condvar-32'><div class='marginalizedparent'><a class='marginalized' href='#condvar-32'>32</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
while (!pred())
  if (wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
return true;
</pre></div></div><div class='para' id='condvar-33'><div class='marginalizedparent'><a class='marginalized' href='#condvar-33'>33</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>pred()</span></p></div></div><div class='para' id='condvar-34'><div class='marginalizedparent'><a class='marginalized' href='#condvar-34'>34</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='condvar-35'><div class='marginalizedparent'><a class='marginalized' href='#condvar-35'>35</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The returned value indicates whether the predicate evaluated to
<span class='texttt'>true</span> regardless of whether the timeout was triggered. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condvar-36'><div class='marginalizedparent'><a class='marginalized' href='#condvar-36'>36</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>std::system_error</span> when an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='condvar-37'><div class='marginalizedparent'><a class='marginalized' href='#condvar-37'>37</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='condvar-37.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-37.1'>(37.1)</a></div><p >equivalent error condition from <span class='texttt'>lock.lock()</span> or
<span class='texttt'>lock.unlock()</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='condition_variable,wait_for'></a></span><span class='indexparent'><a class='index' id='wait_for,condition_variable'></a></span><code class='itemdecl'>
template &lt;class Rep, class Period, class Predicate&gt;
  bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
                Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='condvar-38'><div class='marginalizedparent'><a class='marginalized' href='#condvar-38'>38</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread, and either
</p><ul class='itemize'><li id='condvar-38.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-38.1'>(38.1)</a></div><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or</p></li><li id='condvar-38.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-38.2'>(38.2)</a></div><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span> arguments
supplied by all concurrently waiting (via <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, or
<span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='condvar-39'><div class='marginalizedparent'><a class='marginalized' href='#condvar-39'>39</a></div><div class='itemdescr'><p ><i>Effects:</i> as if</p><pre class='codeblock'>
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));
</pre></div></div><div class='para' id='condvar-40'><div class='marginalizedparent'><a class='marginalized' href='#condvar-40'>40</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> There is no blocking if <span class='texttt'>pred()</span> is initially <span class='texttt'>true</span>, even if the
timeout has already expired. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condvar-41'><div class='marginalizedparent'><a class='marginalized' href='#condvar-41'>41</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='condvar-42'><div class='marginalizedparent'><a class='marginalized' href='#condvar-42'>42</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>pred()</span></p></div></div><div class='para' id='condvar-43'><div class='marginalizedparent'><a class='marginalized' href='#condvar-43'>43</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The returned value indicates whether the predicate evaluates to <span class='texttt'>true</span>
regardless of whether the timeout was triggered. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condvar-44'><div class='marginalizedparent'><a class='marginalized' href='#condvar-44'>44</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='condvar-45'><div class='marginalizedparent'><a class='marginalized' href='#condvar-45'>45</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='condvar-45.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvar-45.1'>(45.1)</a></div><p >equivalent error condition from <span class='texttt'>lock.lock()</span> or <span class='texttt'>lock.unlock()</span>.
</p></li></ul></div></div></div><div id='condvarany'><h3 ><a class='secnum' href='#condvarany' style='min-width:103pt'>30.5.2</a> Class <span class='texttt'>condition_variable_any</span> <a class='abbr_ref' href='thread.condition.condvarany'>[thread.condition.condvarany]</a></h3><div class='para' id='condvarany-1'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-1'>1</a></div><p >A <span class='texttt'>Lock</span> type shall meet the <span class='texttt'>BasicLockable</span>
requirements (<a href='thread.req.lockable.basic'>[thread.req.lockable.basic]</a>). [&nbsp;<i>Note:</i> All of the standard
mutex types meet this requirement. If a <span class='texttt'>Lock</span> type other than one of the
standard mutex types or a <span class='texttt'>unique_lock</span> wrapper for a standard mutex type
is used with <span class='texttt'>condition_variable_any</span>, the user must ensure that any
necessary synchronization is in place with respect to the predicate associated
with the <span class='texttt'>condition_variable_any</span> instance. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p><pre class='codeblock'>
namespace std {
  class condition_variable_any {
  public:
    condition_variable_any();
    ~condition_variable_any();

    condition_variable_any(const condition_variable_any&amp;) = delete;
    condition_variable_any&amp; operator=(const condition_variable_any&amp;) = delete;

    void notify_one() noexcept;
    void notify_all() noexcept;
    template &lt;class Lock&gt;
      void wait(Lock&amp; lock);
    template &lt;class Lock, class Predicate&gt;
      void wait(Lock&amp; lock, Predicate pred);

    template &lt;class Lock, class Clock, class Duration&gt;
      cv_status wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    template &lt;class Lock, class Clock, class Duration, class Predicate&gt;
      bool wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
        Predicate pred);
    template &lt;class Lock, class Rep, class Period&gt;
      cv_status wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template &lt;class Lock, class Rep, class Period, class Predicate&gt;
      bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
        Predicate pred);
  };
}
</pre><p ><span class='indexparent'><a class='index' id='condition_variable_any,constructor'></a></span><code class='itemdecl'>
condition_variable_any();
</code></p></div><div class='itemdescr'></div><div class='para' id='condvarany-2'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>condition_variable_any</span>.</p></div></div><div class='para' id='condvarany-3'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>bad_alloc</span> or <span class='texttt'>system_error</span> when an exception is
required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='condvarany-4'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-4'>4</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='condvarany-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvarany-4.1'>(4.1)</a></div><p ><span class='texttt'>resource_unavailable_try_again</span> â€” if any native handle type
manipulated is not available.</p></li><li id='condvarany-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvarany-4.2'>(4.2)</a></div><p ><span class='texttt'>operation_not_permitted</span> â€” if the thread does not have the
privilege to perform the operation.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any,destructor'></a></span><code class='itemdecl'>
~condition_variable_any();
</code></p><div class='itemdescr'></div><div class='para' id='condvarany-5'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> There shall be no thread blocked on <span class='texttt'>*this</span>. [&nbsp;<i>Note:</i> That is, all
threads shall have been notified; they may subsequently block on the lock specified in the
wait.
This relaxes the usual rules, which would have required all wait calls to happen before
destruction. Only the notification to unblock the wait must happen before destruction.
The user must take care to ensure that no threads wait on <span class='texttt'>*this</span> once the destructor has
been started, especially when the waiting threads are calling the wait functions in a loop or
using the overloads of <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span> that take a predicate.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condvarany-6'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys the object.
</p></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any,notify_one'></a></span><span class='indexparent'><a class='index' id='notify_one,condition_variable_any'></a></span><code class='itemdecl'>
void notify_one() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='condvarany-7'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> If any threads are blocked waiting for <span class='texttt'>*this</span>, unblocks one of those threads.
</p></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any,notify_all'></a></span><span class='indexparent'><a class='index' id='notify_all,condition_variable_any'></a></span><code class='itemdecl'>
void notify_all() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='condvarany-8'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Unblocks all threads that are blocked waiting for <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any,wait'></a></span><span class='indexparent'><a class='index' id='wait,condition_variable_any'></a></span><code class='itemdecl'>
template &lt;class Lock&gt;
  void wait(Lock&amp; lock);
</code></p><div class='itemdescr'></div><div class='para' id='condvarany-9'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-9'>9</a></div><div class='itemdescr'><p ><i>Note:</i> if any of the <span class='texttt'>wait</span> functions exits via an exception, it is
unspecified whether the <span class='texttt'>Lock</span> is held. One can use a <span class='texttt'>Lock</span> type
that allows to query that, such as the <span class='texttt'>unique_lock</span> wrapper.</p></div></div><div class='para' id='condvarany-10'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='condvarany-10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvarany-10.1'>(10.1)</a></div><p >Atomically calls <span class='texttt'>lock.unlock()</span> and blocks on <span class='texttt'>*this</span>.
</p></li><li id='condvarany-10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvarany-10.2'>(10.2)</a></div><p >When unblocked, calls <span class='texttt'>lock.lock()</span> (possibly blocking on the lock) and returns.
</p></li><li id='condvarany-10.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvarany-10.3'>(10.3)</a></div><p >The function will unblock when signaled by a call to <span class='texttt'>notify_one()</span>,
a call to <span class='texttt'>notify_all()</span>, or spuriously.
</p></li><li id='condvarany-10.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvarany-10.4'>(10.4)</a></div><p >If the function exits via an exception, <span class='texttt'>lock.lock()</span> shall be
called prior to exiting the function scope.
</p></li></ul></div></div><div class='para' id='condvarany-11'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-11'>11</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>lock</span> is locked by the calling thread.</p></div></div><div class='para' id='condvarany-12'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-12'>12</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='condvarany-13'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-13'>13</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='condvarany-13.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvarany-13.1'>(13.1)</a></div><p >equivalent error condition from <span class='texttt'>lock.lock()</span> or <span class='texttt'>lock.unlock()</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any,wait'></a></span><span class='indexparent'><a class='index' id='wait,condition_variable_any'></a></span><code class='itemdecl'>
template &lt;class Lock, class Predicate&gt;
  void wait(Lock&amp; lock, Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='condvarany-14'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
while (!pred())
  wait(lock);
</pre></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any,wait_until'></a></span><span class='indexparent'><a class='index' id='wait_until,condition_variable_any'></a></span><code class='itemdecl'>
template &lt;class Lock, class Clock, class Duration&gt;
  cv_status wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</code></p><div class='itemdescr'></div><div class='para' id='condvarany-15'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i></p><ul class='itemize'><li id='condvarany-15.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvarany-15.1'>(15.1)</a></div><p >Atomically calls <span class='texttt'>lock.unlock()</span> and blocks on <span class='texttt'>*this</span>.</p></li><li id='condvarany-15.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvarany-15.2'>(15.2)</a></div><p >When unblocked, calls <span class='texttt'>lock.lock()</span> (possibly blocking on the lock) and returns.</p></li><li id='condvarany-15.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvarany-15.3'>(15.3)</a></div><p >The function will unblock when signaled by a call to <span class='texttt'>notify_one()</span>, a call to <span class='texttt'>notify_all()</span>,
expiration of the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span>,
or spuriously.</p></li><li id='condvarany-15.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvarany-15.4'>(15.4)</a></div><p >If the function exits via an exception, <span class='texttt'>lock.lock()</span> shall be called prior to exiting the function scope.
</p></li></ul></div></div><div class='para' id='condvarany-16'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-16'>16</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>lock</span> is locked by the calling thread.</p></div></div><div class='para' id='condvarany-17'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-17'>17</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cv_status::timeout</span> if
the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span> expired,
otherwise <span class='texttt'>cv_status::no_timeout</span>.</p></div></div><div class='para' id='condvarany-18'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-18'>18</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='condvarany-19'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-19'>19</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='condvarany-19.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvarany-19.1'>(19.1)</a></div><p >equivalent error condition from <span class='texttt'>lock.lock()</span> or <span class='texttt'>lock.unlock()</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any,wait_for'></a></span><span class='indexparent'><a class='index' id='wait_for,condition_variable_any'></a></span><code class='itemdecl'>
template &lt;class Lock, class Rep, class Period&gt;
  cv_status wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></p><div class='itemdescr'></div><div class='para' id='condvarany-20'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i> as if</p><pre class='codeblock'>
return wait_until(lock, chrono::steady_clock::now() + rel_time);
</pre></div></div><div class='para' id='condvarany-21'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-21'>21</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cv_status::timeout</span> if
the relative timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>rel_time</span> expired,
otherwise <span class='texttt'>cv_status::no_timeout</span>.</p></div></div><div class='para' id='condvarany-22'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-22'>22</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>lock</span> is locked by the calling thread.</p></div></div><div class='para' id='condvarany-23'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-23'>23</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='condvarany-24'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-24'>24</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='condvarany-24.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvarany-24.1'>(24.1)</a></div><p >equivalent error condition from <span class='texttt'>lock.lock()</span> or <span class='texttt'>lock.unlock()</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any,wait_until'></a></span><span class='indexparent'><a class='index' id='wait_until,condition_variable_any'></a></span><code class='itemdecl'>
template &lt;class Lock, class Clock, class Duration, class Predicate&gt;
  bool wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='condvarany-25'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-25'>25</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
while (!pred())
  if (wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
return true;
</pre></div></div><div class='para' id='condvarany-26'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-26'>26</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>pred()</span></p></div></div><div class='para' id='condvarany-27'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-27'>27</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The returned value indicates whether the predicate evaluates to <span class='texttt'>true</span>
regardless of whether the timeout was triggered. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any,wait_for'></a></span><span class='indexparent'><a class='index' id='wait_for,condition_variable_any'></a></span><code class='itemdecl'>
template &lt;class Lock, class Rep, class Period, class Predicate&gt;
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='condvarany-28'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-28'>28</a></div><div class='itemdescr'><p ><i>Effects:</i> as if</p><pre class='codeblock'>
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));
</pre></div></div><div class='para' id='condvarany-29'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-29'>29</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> There is no blocking if <span class='texttt'>pred()</span> is initially <span class='texttt'>true</span>, even if the
timeout has already expired. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condvarany-30'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-30'>30</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>lock</span> is locked by the calling thread.</p></div></div><div class='para' id='condvarany-31'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-31'>31</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>pred()</span></p></div></div><div class='para' id='condvarany-32'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-32'>32</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The returned value indicates whether the predicate evaluates to <span class='texttt'>true</span>
regardless of whether the timeout was triggered. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condvarany-33'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-33'>33</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='condvarany-34'><div class='marginalizedparent'><a class='marginalized' href='#condvarany-34'>34</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='condvarany-34.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#condvarany-34.1'>(34.1)</a></div><p >equivalent error condition from <span class='texttt'>lock.lock()</span> or <span class='texttt'>lock.unlock()</span>.
</p></li></ul></div></div></div></div></div></body></html>