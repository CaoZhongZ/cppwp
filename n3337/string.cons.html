<!DOCTYPE html><html lang='en'><head><title>[string.cons]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>21</a> Strings library <a class='abbr_ref' href='./#strings'>[strings]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>21.4</a> Class template <span class='texttt'>basic_string</span> <a class='abbr_ref' href='basic.string#string.cons'>[basic.string]</a></h2><div id='string.cons'><h3 ><a class='secnum' style='min-width:103pt'>21.4.2</a> <span class='texttt'>basic_string</span> constructors and assignment operators <a class='abbr_ref'>[string.cons]</a></h3><p ><span class='indexparent'><a class='index' id='basic_string,constructor'></a></span><code class='itemdecl'>
explicit basic_string(const Allocator&amp; a = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>basic_string</span>.
The postconditions of this function are indicated in Table <a href='#tab:strings.ctr.1'>[tab:strings.ctr.1]</a>.</p><div class='numberedTable' id='tab:strings.ctr.1'>Table <a href='#tab:strings.ctr.1'>63</a> — <span class='texttt'>basic_string(const Allocator&amp;)</span> effects<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Element</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 



<span class='texttt'>data()</span>      </td><td class='justify'>   a non-null pointer that is copyable and can have 0 added to it  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>size()</span>      </td><td class='justify'>   0                                                               </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>capacity()</span>  </td><td class='justify'>   an unspecified value                                            </td></tr></table></div></div></div><p ><span class='indexparent'><a class='index' id='basic_string,constructor'></a></span><code class='itemdecl'>
basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
basic_string(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; str) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>basic_string</span>
as indicated in Table <a href='#tab:strings.ctr.cpy'>[tab:strings.ctr.cpy]</a>.
In the second form, <span class='texttt'>str</span>
is left in a valid state with an unspecified value.</p></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i> The second form throws nothing if the allocator's
move constructor throws nothing.</p><div class='numberedTable' id='tab:strings.ctr.cpy'>Table <a href='#tab:strings.ctr.cpy'>64</a> — <span class='texttt'>basic_string(const basic_string&amp;)</span> effects<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Element</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 



<span class='texttt'>data()</span>      </td><td class='justify'>
points at the first element of an allocated copy of the array
whose first element is pointed at by <span class='texttt'>str.data()</span> </td></tr><tr ><td class='left'>
<span class='texttt'>size()</span>      </td><td class='justify'>   <span class='texttt'>str.size()</span>                                                  </td></tr><tr ><td class='left'>
<span class='texttt'>capacity()</span>  </td><td class='justify'>   a value at least as large as <span class='texttt'>size()</span>                     </td></tr></table></div></div></div><p ><span class='indexparent'><a class='index' id='basic_string,constructor'></a></span><code class='itemdecl'>
basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str,
             size_type pos, size_type n = npos,
             const Allocator&amp; a = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>pos &lt;= str.size()</span></p></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>out_of_range</span>
if
<span class='texttt'>pos &gt; str.size()</span>.</p></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>basic_string</span>
and determines the effective length <span class='texttt'>rlen</span> of the initial string
value as the smaller of <span class='texttt'>n</span> and
<span class='texttt'>str.size() - pos</span>,
as indicated in Table <a href='#tab:strings.ctr.2'>[tab:strings.ctr.2]</a>.</p><div class='numberedTable' id='tab:strings.ctr.2'>Table <a href='#tab:strings.ctr.2'>65</a> — <span class='texttt'>basic_string(const basic_string&amp;, size_type, size_type, const Allocator&amp;)</span> effects<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Element</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 



<span class='texttt'>data()</span>      </td><td class='justify'>
points at the first element of an allocated copy of <span class='texttt'>rlen</span> consecutive elements
of the string controlled by <span class='texttt'>str</span> beginning at position <span class='texttt'>pos</span>              </td></tr><tr ><td class='left'>
<span class='texttt'>size()</span>      </td><td class='justify'>   <span class='texttt'>rlen</span>                                                    </td></tr><tr ><td class='left'>
<span class='texttt'>capacity()</span>  </td><td class='justify'>   a value at least as large as <span class='texttt'>size()</span>                     </td></tr></table></div></div></div><p ><span class='indexparent'><a class='index' id='basic_string,constructor'></a></span><code class='itemdecl'>
basic_string(const charT* s, size_type n,
             const Allocator&amp; a = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>s</span> shall not be a null pointer and
<span class='texttt'>n &lt; npos</span>.</p></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>basic_string</span>
and determines its initial string value from the array of
<span class='texttt'>charT</span>
of length <span class='texttt'>n</span> whose first element is designated by <span class='texttt'>s</span>,
as indicated in Table <a href='#tab:strings.ctr.3'>[tab:strings.ctr.3]</a>.</p><div class='numberedTable' id='tab:strings.ctr.3'>Table <a href='#tab:strings.ctr.3'>66</a> — <span class='texttt'>basic_string(const charT*, size_type, const Allocator&amp;)</span> effects<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Element</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 



<span class='texttt'>data()</span>      </td><td class='justify'>
points at the first element of an allocated copy of the array whose first element
is pointed at by <span class='texttt'>s</span>                                                              </td></tr><tr ><td class='left'>
<span class='texttt'>size()</span>      </td><td class='justify'>   <span class='texttt'>n</span>                                                       </td></tr><tr ><td class='left'>
<span class='texttt'>capacity()</span>  </td><td class='justify'>   a value at least as large as <span class='texttt'>size()</span>                     </td></tr></table></div></div></div><p ><span class='indexparent'><a class='index' id='basic_string,constructor'></a></span><code class='itemdecl'>
basic_string(const charT* s, const Allocator&amp; a = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>s</span> shall not be a null pointer.</p></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>basic_string</span>
and determines its initial string value from the array of
<span class='texttt'>charT</span>
of length
<span class='texttt'>traits::length(s)</span>
whose first element is designated
by <span class='texttt'>s</span>,
as indicated in Table <a href='#tab:strings.ctr.4'>[tab:strings.ctr.4]</a>.</p><div class='numberedTable' id='tab:strings.ctr.4'>Table <a href='#tab:strings.ctr.4'>67</a> — <span class='texttt'>basic_string(const charT*, const Allocator&amp;)</span> effects<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Element</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 



<span class='texttt'>data()</span>      </td><td class='justify'>
points at the first element of an allocated copy of the array whose first element
is pointed at by <span class='texttt'>s</span>                                                              </td></tr><tr ><td class='left'>
<span class='texttt'>size()</span>      </td><td class='justify'>   <span class='texttt'>traits::length(s)</span>                                       </td></tr><tr ><td class='left'>
<span class='texttt'>capacity()</span>  </td><td class='justify'>   a value at least as large as <span class='texttt'>size()</span>                     </td></tr></table></div></div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Uses
<span class='texttt'>traits::length()</span>.
<span class='indexparent'><a class='index' id='length,char_traits'></a></span></p></div></div><p ><span class='indexparent'><a class='index' id='basic_string,constructor'></a></span><code class='itemdecl'>
basic_string(size_type n, charT c, const Allocator&amp; a = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>n &lt; npos</span></p></div></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>basic_string</span>
and determines its initial string value by repeating the char-like
object <span class='texttt'>c</span> for all <span class='texttt'>n</span> elements,
as indicated in Table <a href='#tab:strings.ctr.5'>[tab:strings.ctr.5]</a>.</p><div class='numberedTable' id='tab:strings.ctr.5'>Table <a href='#tab:strings.ctr.5'>68</a> — <span class='texttt'>basic_string(size_t, charT, const Allocator&amp;)</span> effects<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Element</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 



<span class='texttt'>data()</span>      </td><td class='justify'>
points at the first element of an allocated array of <span class='texttt'>n</span> elements, each
storing the initial value <span class='texttt'>c</span>                                                     </td></tr><tr ><td class='left'>
<span class='texttt'>size()</span>      </td><td class='justify'>   <span class='texttt'>n</span>                                                       </td></tr><tr ><td class='left'>
<span class='texttt'>capacity()</span>  </td><td class='justify'>   a value at least as large as <span class='texttt'>size()</span>                     </td></tr></table></div></div></div><p ><span class='indexparent'><a class='index' id='basic_string,constructor'></a></span><code class='itemdecl'>
template&lt;class InputIterator&gt;
  basic_string(InputIterator begin, InputIterator end,
               const Allocator&amp; a = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i>
If <span class='texttt'>InputIterator</span> is an integral type,
equivalent to</p><pre class='codeblock'>
basic_string(static_cast&lt;size_type&gt;(begin), static_cast&lt;value_type&gt;(end), a)
</pre></div></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><div class='itemdescr'><p >Otherwise constructs a string from the values in the range [<span class='texttt'>begin</span>, <span class='texttt'>end</span>),
as indicated in the Sequence Requirements table
(see <a href='sequence.reqmts'>[sequence.reqmts]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_string,constructor'></a></span><code class='itemdecl'>
basic_string(initializer_list&lt;charT&gt; il, const Allocator&amp; a = Allocator());
</code></p><div class='itemdescr'></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> Same as <span class='texttt'>basic_string(il.begin(), il.end(), a)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_string,constructor'></a></span><code class='itemdecl'>
basic_string(const basic_string&amp; str, const Allocator&amp; alloc);
basic_string(basic_string&amp;&amp; str, const Allocator&amp; alloc);
</code></p><div class='itemdescr'></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of class <span class='texttt'>basic_string</span> as indicated in
Table <a href='#tab:strings.ctr.6'>[tab:strings.ctr.6]</a>. The stored allocator is constructed from
<span class='texttt'>alloc</span>. In the second form, <span class='texttt'>str</span> is left in a valid state with an
unspecified value.</p><div class='numberedTable' id='tab:strings.ctr.6'>Table <a href='#tab:strings.ctr.6'>69</a> — <span class='texttt'>basic_string(const basic_string&amp;, const Allocator&amp;)</span> and
<span class='texttt'>basic_string(basic_string&amp;&amp;, const Allocator&amp;)</span> effects<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Element</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 



<span class='texttt'>data()</span>      </td><td class='justify'>
points at the first element of an allocated copy of the array whose first
element is pointed at by the original value of <span class='texttt'>str.data()</span>. </td></tr><tr ><td class='left'>
<span class='texttt'>size()</span>      </td><td class='justify'>   the original value of <span class='texttt'>str.size()</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>capacity()</span>  </td><td class='justify'>   a value at least as large as <span class='texttt'>size()</span>                     </td></tr><tr ><td class='left'>
<span class='texttt'>get_allocator()</span> </td><td class='justify'>	<span class='texttt'>alloc</span> </td></tr></table></div></div></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><div class='itemdescr'><p ><i>Throws:</i> The second form throws nothing if <span class='texttt'>alloc == str.get_allocator()</span>
unless the copy constructor for <span class='texttt'>Allocator</span> throws.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,basic_string'></a></span><span class='indexparent'><a class='index' id='basic_string,operator='></a></span><code class='itemdecl'>
basic_string&lt;charT,traits,Allocator&gt;&amp;
  operator=(const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</code></p><div class='itemdescr'></div><div class='para' id='19'><div class='marginalizedparent'><a class='marginalized' href='#19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i>
If
<span class='texttt'>*this</span>
and <span class='texttt'>str</span> are not the same object,
modifies
<span class='texttt'>*this</span>
as shown in Table <a href='#tab:strings.op='>[tab:strings.op=]</a>.</p></div></div><div class='para' id='20'><div class='marginalizedparent'><a class='marginalized' href='#20'>20</a></div><div class='itemdescr'><p >If
<span class='texttt'>*this</span>
and <span class='texttt'>str</span> are the same object,
the member has no effect.</p></div></div><div class='para' id='21'><div class='marginalizedparent'><a class='marginalized' href='#21'>21</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span></p><div class='numberedTable' id='tab:strings.op='>Table <a href='#tab:strings.op='>70</a> — <span class='texttt'>operator=(const basic_string&lt;charT, traits, Allocator&gt;&amp;)</span> effects<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Element</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 



<span class='texttt'>data()</span>      </td><td class='justify'>
points at the first element of an allocated copy of the array whose first
element is pointed at by <span class='texttt'>str.data()</span>                                             </td></tr><tr ><td class='left'>
<span class='texttt'>size()</span>      </td><td class='justify'>   <span class='texttt'>str.size()</span>                                              </td></tr><tr ><td class='left'>
<span class='texttt'>capacity()</span>  </td><td class='justify'>   a value at least as large as <span class='texttt'>size()</span>                     </td></tr></table></div></div></div><p ><span class='indexparent'><a class='index' id='operator=,basic_string'></a></span><span class='indexparent'><a class='index' id='basic_string,operator='></a></span><code class='itemdecl'>
basic_string&lt;charT,traits,Allocator&gt;&amp;
  operator=(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; str) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='22'><div class='marginalizedparent'><a class='marginalized' href='#22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i>
If
<span class='texttt'>*this</span>
and <span class='texttt'>str</span> are not the same object,
modifies
<span class='texttt'>*this</span>
as shown in Table <a href='#tab:strings.op=rv'>[tab:strings.op=rv]</a>.
[&nbsp;<i>Note:</i> A valid implementation is
<span class='texttt'>swap(str)</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='23'><div class='marginalizedparent'><a class='marginalized' href='#23'>23</a></div><div class='itemdescr'><p >If
<span class='texttt'>*this</span>
and <span class='texttt'>str</span> are the same object,
the member has no effect.</p></div></div><div class='para' id='24'><div class='marginalizedparent'><a class='marginalized' href='#24'>24</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span></p><div class='numberedTable' id='tab:strings.op=rv'>Table <a href='#tab:strings.op=rv'>71</a> — <span class='texttt'>operator=(const basic_string&lt;charT, traits, Allocator&gt;&amp;&amp;)</span> effects<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Element</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 



<span class='texttt'>data()</span>      </td><td class='justify'>
points at the array whose first
element was pointed at by <span class='texttt'>str.data()</span>                                            </td></tr><tr ><td class='left'>
<span class='texttt'>size()</span>      </td><td class='justify'>   previous value of <span class='texttt'>str.size()</span>                            </td></tr><tr ><td class='left'>
<span class='texttt'>capacity()</span>  </td><td class='justify'>   a value at least as large as <span class='texttt'>size()</span>                     </td></tr></table></div></div></div><p ><span class='indexparent'><a class='index' id='operator=,basic_string'></a></span><span class='indexparent'><a class='index' id='basic_string,operator='></a></span><code class='itemdecl'>
basic_string&lt;charT,traits,Allocator&gt;&amp;
  operator=(const charT* s);
</code></p><div class='itemdescr'></div><div class='para' id='25'><div class='marginalizedparent'><a class='marginalized' href='#25'>25</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this = basic_string&lt;charT,traits,Allocator&gt;(s)</span>.</p></div></div><div class='para' id='26'><div class='marginalizedparent'><a class='marginalized' href='#26'>26</a></div><div class='itemdescr'><p ><i>Remarks:</i>
Uses
<span class='indexparent'><a class='index' id='length,char_traits'></a></span><span class='texttt'>traits::length()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,basic_string'></a></span><span class='indexparent'><a class='index' id='basic_string,operator='></a></span><code class='itemdecl'>
basic_string&lt;charT,traits,Allocator&gt;&amp; operator=(charT c);
</code></p><div class='itemdescr'></div><div class='para' id='27'><div class='marginalizedparent'><a class='marginalized' href='#27'>27</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this = basic_string&lt;charT,traits,Allocator&gt;(1,c)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,basic_string'></a></span><span class='indexparent'><a class='index' id='basic_string,operator='></a></span><code class='itemdecl'>
basic_string&amp; operator=(initializer_list&lt;charT&gt; il);
</code></p><div class='itemdescr'></div><div class='para' id='28'><div class='marginalizedparent'><a class='marginalized' href='#28'>28</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>*this = basic_string(il)</span>.</p></div></div><div class='para' id='29'><div class='marginalizedparent'><a class='marginalized' href='#29'>29</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div></div></body></html>