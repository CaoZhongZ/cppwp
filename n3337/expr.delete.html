<!DOCTYPE html><html lang='en'><head><title>[expr.delete]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>5.3</a> Unary expressions <a class='abbr_ref' href='expr.unary#expr.delete'>[expr.unary]</a></h2><div id='expr.delete'><h3 ><a class='secnum' style='min-width:103pt'>5.3.5</a> Delete <a class='abbr_ref'>[expr.delete]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,delete'></a></span><span class='indexparent'><a class='index' id='delete'></a></span>The <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> operator destroys a most derived
object (<a href='intro.object'>[intro.object]</a>) or array created by a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.</p><pre class='bnf'><a id='nt:delete-expression'>delete-expression:</a>
    <span class='terminal'>::</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>delete</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
    <span class='terminal'>::</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>delete [ ]</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i></pre><p >The first alternative is for non-array objects, and the second is for arrays. Whenever
the <span class='texttt'>delete</span> keyword is immediately followed by empty square brackets, it shall be
interpreted as the second alternative.<a class='footnotenum' href='#footnote-77'>77</a>
The operand shall have a pointer to object type, or a class type having a single
non-explicit conversion function (<a href='class.conv.fct'>[class.conv.fct]</a>) to a pointer to object
type. The result has type <span class='texttt'>void</span>.<a class='footnotenum' href='#footnote-78'>78</a></p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='delete,object'></a></span>
If the operand has a class type, the operand is converted to a pointer
type by calling the above-mentioned conversion function, and the
converted operand is used in place of the original operand for the
remainder of this section.
<span class='indexparent'><a class='index' id='object,delete'></a></span>In the first alternative
(<a class='hidden_link' href='#def:delete_object' id='def:delete_object'><i>delete object</i></a>), the value of the operand of <span class='texttt'>delete</span> may
be a null pointer value, a pointer to a non-array object
created by a previous <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>,
or a pointer to a
subobject (<a href='intro.object'>[intro.object]</a>) representing a base class of such an
object (Clause <a href='class.derived'>[class.derived]</a>). If not, the behavior is undefined.
<span class='indexparent'><a class='index' id='array,delete'></a></span><span class='indexparent'><a class='index' id='delete,array'></a></span>In the second alternative (<a class='hidden_link' href='#def:delete_array' id='def:delete_array'><i>delete array</i></a>), the value of the
operand of <span class='texttt'>delete</span>
may be a null pointer value or a pointer value
that resulted from
a previous array <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.<a class='footnotenum' href='#footnote-79'>79</a>
If not, the behavior is undefined.
[&nbsp;<i>Note:</i> 
this means that the syntax of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> must
match the type of the object allocated by <span class='texttt'>new</span>, not the syntax of the
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] 
[&nbsp;<i>Note:</i> 
a pointer to a <span class='texttt'>const</span> type can be the operand of a
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>; it is not necessary to cast away the
constness (<a href='expr.const.cast'>[expr.const.cast]</a>) of the pointer expression before it is
used as the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='delete,undefined'></a></span>In the first alternative (<a class='hidden_link' href='#def:delete_object' id='def:delete_object'><i>delete object</i></a>), if the static type of
the object to be deleted is different from its dynamic type, the static type shall be
a base class of the dynamic type of the object to be deleted and the static type shall
have a virtual destructor or the behavior is undefined. In the second
alternative (<a class='hidden_link' href='#def:delete_array' id='def:delete_array'><i>delete array</i></a>) if the dynamic type of the object to
be deleted differs from its static type, the behavior is undefined.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i> in a <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> shall
be evaluated exactly once.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='type,incomplete'></a></span>If the object being deleted has incomplete class type at the point of
deletion and the complete class has a non-trivial destructor or a
deallocation function, the behavior is undefined.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='delete,destructor_and'></a></span>If the value of the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is not a
null pointer value, the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> will invoke the
destructor (if any) for the object or the elements of the array being
deleted. In the case of an array, the elements will be destroyed in
order of decreasing address (that is, in reverse order of the completion
of their constructor; see <a href='class.base.init'>[class.base.init]</a>).</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >If the value of the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is not a
null pointer value, the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> will call a
<span class='indexparent'><a class='index' id='function,deallocation'></a></span><span class='indexparent'><a class='index' id='deallocation'></a></span><span class='indexparent'><a class='index' id='delete'></a></span>
<a class='hidden_link' href='#def:deallocation_function' id='def:deallocation_function'><i>deallocation function</i></a> (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>).
Otherwise, it is unspecified whether the deallocation function will be
called.
[&nbsp;<i>Note:</i>
The deallocation function is called regardless of whether the destructor
for the object or some element of the array throws an exception.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >[&nbsp;<i>Note:</i> 
An implementation provides default definitions of the global
deallocation functions <span class='texttt'>operator delete()</span> for
non-arrays (<a href='new.delete.single'>[new.delete.single]</a>) and
<span class='indexparent'><a class='index' id='operator_'></a></span><span class='indexparent'><a class='index' id='operator_delete'></a></span><span class='texttt'>operator delete[]()</span> for arrays (<a href='new.delete.array'>[new.delete.array]</a>). A C++
program can provide alternative definitions of these
functions (<a href='replacement.functions'>[replacement.functions]</a>), and/or class-specific
versions (<a href='class.free'>[class.free]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >When the keyword <span class='texttt'>delete</span> in a <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is
preceded by the unary <span class='texttt'>::</span> operator, the global deallocation
function is used to deallocate the storage.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >Access and ambiguity control are done for both the deallocation function
and the destructor (<a href='class.dtor'>[class.dtor]</a>, <a href='class.free'>[class.free]</a>).</p></div><div class='footnote' id='footnote-77'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-77'>77)</a></div><p >A lambda expression with a
<i ><a href='expr.prim.lambda#nt:lambda-introducer'>lambda-introducer</a></i> that consists of
empty square brackets can follow the <span class='texttt'>delete</span> keyword if the lambda expression is
enclosed in parentheses.</p></div><div class='footnote' id='footnote-78'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-78'>78)</a></div><p >This implies that an object
cannot be deleted using a pointer of type
<span class='texttt'>void*</span> because <span class='texttt'>void</span> is not an object type.</p></div><div class='footnote' id='footnote-79'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-79'>79)</a></div><p >For non-zero-length
arrays, this is the same as a pointer to the first
element of the array created by that <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.
Zero-length arrays do not have a first element.</p></div></div></div></body></html>