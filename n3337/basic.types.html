<!DOCTYPE html><html lang='en'><head><title>[basic.types]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><div id='basic.types'><h2 ><a class='secnum' style='min-width:88pt'>3.9</a> Types <a class='abbr_ref'>[basic.types]</a></h2><p ><span class='indexparent'><a class='index' id='type'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >[&nbsp;<i>Note:</i>
<a href='basic.types'>[basic.types]</a> and the subclauses thereof
impose requirements on implementations regarding the representation
of types.
There are two kinds of types: fundamental types and compound types.
Types describe objects (<a href='intro.object'>[intro.object]</a>),
references (<a href='dcl.ref'>[dcl.ref]</a>),
or functions (<a href='dcl.fct'>[dcl.fct]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='object,byte_copying_and'></a></span><span class='indexparent'><a class='index' id='type,trivially_copyable'></a></span>For any object (other than a base-class subobject) of trivially copyable type
<span class='texttt'>T</span>, whether or not the object holds a valid value of type
<span class='texttt'>T</span>, the underlying bytes (<a href='intro.memory'>[intro.memory]</a>) making up the
object can be copied into an array of <span class='texttt'>char</span> or <span class='texttt'>unsigned</span>
<span class='texttt'>char</span>.<a class='footnotenum' href='#footnote-40'>40</a>
If the content of the array of <span class='texttt'>char</span> or <span class='texttt'>unsigned</span>
<span class='texttt'>char</span> is copied back into the object, the object shall
subsequently hold its original value. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
#define N sizeof(T)
char buf[N];
T obj;                          <span class='comment'>// <span class='texttt'>obj</span> initialized to its original value
</span>std::memcpy(buf, &amp;obj, N);      <span class='comment'>// between these two calls to <span class='texttt'>std::memcpy</span>,
</span>                                <span class='comment'>// <span class='texttt'>obj</span> might be modified
</span>std::memcpy(&amp;obj, buf, N);      <span class='comment'>// at this point, each subobject of <span class='texttt'>obj</span> of scalar type
</span>                                <span class='comment'>// holds its original value
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;] </p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >For any trivially copyable type <span class='texttt'>T</span>, if two pointers to <span class='texttt'>T</span> point to
distinct <span class='texttt'>T</span> objects <span class='texttt'>obj1</span> and <span class='texttt'>obj2</span>, where neither
<span class='texttt'>obj1</span> nor <span class='texttt'>obj2</span> is a base-class subobject, if the underlying
bytes (<a href='intro.memory'>[intro.memory]</a>) making up
<span class='texttt'>obj1</span> are copied into <span class='texttt'>obj2</span>,<a class='footnotenum' href='#footnote-41'>41</a>
 <span class='texttt'>obj2</span> shall subsequently hold the same value as
<span class='texttt'>obj1</span>. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
T* t1p;
T* t2p;
    <span class='comment'>// provided that <span class='texttt'>t2p</span> points to an initialized object ...
</span>std::memcpy(t1p, t2p, sizeof(T));
    <span class='comment'>// at this point, every subobject of trivially copyable type in <span class='texttt'>*t1p</span> contains
</span>    <span class='comment'>// the same value as the corresponding subobject in <span class='texttt'>*t2p</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='object,byte_copying_and'></a></span></p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The <a class='hidden_link' href='#def:object_representation' id='def:object_representation'><i>object representation</i></a>
<span class='indexparent'><a class='index' id='representation,object'></a></span>of an object of type <span class='texttt'>T</span> is the
sequence of <a class='hidden_link' href='#def:N' id='def:N'><i>N</i></a> <span class='texttt'>unsigned</span> <span class='texttt'>char</span> objects taken up
by the object of type <span class='texttt'>T</span>, where <a class='hidden_link' href='#def:N' id='def:N'><i>N</i></a> equals
<span class='texttt'>sizeof(T)</span>. The
<span class='indexparent'><a class='index' id='representation,value'></a></span><a class='hidden_link' href='#def:value_representation' id='def:value_representation'><i>value representation</i></a>
of an object is the set of bits that hold
the value of type <span class='texttt'>T</span>. For trivially copyable types, the value representation is
a set of bits in the object representation that determines a
<a class='hidden_link' href='#def:value' id='def:value'><i>value</i></a>, which is one discrete element of an
<span class='indexparent'><a class='index' id='values_of_a_trivially_copyable_type'></a></span>implementation-defined set of values.<a class='footnotenum' href='#footnote-42'>42</a></p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='type,incomplete'></a></span>A class that has been declared but not defined, or an array of unknown
size or of incomplete element type, is an incompletely-defined object
type.<a class='footnotenum' href='#footnote-43'>43</a>
Incompletely-defined object types and the void types are incomplete
types (<a href='basic.fundamental'>[basic.fundamental]</a>). Objects shall not be defined to have an
incomplete type.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >A class type (such as “<span class='texttt'>class X</span>”) might be incomplete at one
point in a translation unit and complete later on; the type
“<span class='texttt'>class X</span>” is the same type at both points. The declared type
of an array object might be an array of incomplete class type and
therefore incomplete; if the class type is completed later on in the
translation unit, the array type becomes complete; the array type at
those two points is the same type. The declared type of an array object
might be an array of unknown size and therefore be incomplete at one
point in a translation unit and complete later on; the array types at
those two points (“array of unknown bound of <span class='texttt'>T</span>” and “array of
N <span class='texttt'>T</span>”) are different types. The type of a pointer to array of
unknown size, or of a type defined by a <span class='texttt'>typedef</span> declaration to
be an array of unknown size, cannot be completed. [&nbsp;<i>Example:</i></p><p ><span class='indexparent'><a class='index' id='type,example_of_incomplete'></a></span></p><pre class='codeblock'>
class X;                        <span class='comment'>// <span class='texttt'>X</span> is an incomplete type
</span>extern X* xp;                   <span class='comment'>// <span class='texttt'>xp</span> is a pointer to an incomplete type
</span>extern int arr[];               <span class='comment'>// the type of arr is incomplete
</span>typedef int UNKA[];             <span class='comment'>// <span class='texttt'>UNKA</span> is an incomplete type
</span>UNKA* arrp;                     <span class='comment'>// <span class='texttt'>arrp</span> is a pointer to an incomplete type
</span>UNKA** arrpp;

void foo() {
  xp++;                         <span class='comment'>// ill-formed: <span class='texttt'>X</span> is incomplete
</span>  arrp++;                       <span class='comment'>// ill-formed: incomplete type
</span>  arrpp++;                      <span class='comment'>// OK: sizeof <span class='texttt'>UNKA*</span> is known
</span>}

struct X { int i; };            <span class='comment'>// now <span class='texttt'>X</span> is a complete type
</span>int  arr[10];                   <span class='comment'>// now the type of <span class='texttt'>arr</span> is complete
</span>
X x;
void bar() {
  xp = &amp;x;                      <span class='comment'>// OK; type is “pointer to <span class='texttt'>X</span>”
</span>  arrp = &amp;arr;                  <span class='comment'>// ill-formed: different types
</span>  xp++;                         <span class='comment'>// OK:  <span class='texttt'>X</span> is complete
</span>  arrp++;                       <span class='comment'>// ill-formed: <span class='texttt'>UNKA</span> can't be completed
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;] </p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >[&nbsp;<i>Note:</i> The rules for declarations and expressions describe in which
contexts incomplete types are prohibited. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p ><span class='indexparent'><a class='index' id='object_type'></a></span>An <a class='hidden_link' href='#def:object_type' id='def:object_type'><i>object type</i></a> is a (possibly cv-qualified) type that is not
a function type, not a reference type, and not a void type.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >Arithmetic types (<a href='basic.fundamental'>[basic.fundamental]</a>), enumeration types, pointer
types, pointer to member types (<a href='basic.compound'>[basic.compound]</a>),
<span class='texttt'>std::nullptr_t</span>,
and
cv-qualified versions of these
types (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>) are collectively called
<span class='indexparent'><a class='index' id='scalar_type'></a></span><a class='hidden_link' href='#def:scalar_types' id='def:scalar_types'><i>scalar types</i></a>. Scalar types,
POD classes (Clause <a href='class'>[class]</a>), arrays of such types and
<span class='grammarterm'>cv-qualified</span> versions of these
types (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>) are collectively called
<span class='indexparent'><a class='index' id='type,POD'></a></span><a class='hidden_link' href='#def:POD_types' id='def:POD_types'><i>POD types</i></a>.
Scalar types, trivially copyable class types (Clause <a href='class'>[class]</a>), arrays of
such types, and cv-qualified versions of these
types (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>) are collectively called <a class='hidden_link' href='#def:trivially_copyable_types' id='def:trivially_copyable_types'><i>trivially
copyable types</i></a>.
Scalar types, trivial class types (Clause <a href='class'>[class]</a>),
arrays of such types and cv-qualified versions of these
types (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>) are collectively called
<a class='hidden_link' href='#def:trivial_types' id='def:trivial_types'><i>trivial types</i></a>. Scalar types, standard-layout class
types (Clause <a href='class'>[class]</a>), arrays of such types and
cv-qualified versions of these types (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>)
are collectively called <a class='hidden_link' href='#def:standard-layout_types' id='def:standard-layout_types'><i>standard-layout types</i></a>.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >A type is a <a class='hidden_link' href='#def:literal_type' id='def:literal_type'><i>literal type</i></a> if it is:</p><ul ><li id='10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.1'>(10.1)</a></div><p >a scalar type; or
</p></li><li id='10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.2'>(10.2)</a></div><p >a reference type referring to a literal type; or
</p></li><li id='10.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.3'>(10.3)</a></div><p >an array of literal type; or
</p></li><li id='10.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.4'>(10.4)</a></div><p >a class type (Clause <a href='class'>[class]</a>) that
has all of the following properties:
</p><ul ><li id='10.4.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#10.4.1'>(10.4.1)</a></div><p >it has a trivial destructor,
</p></li><li id='10.4.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#10.4.2'>(10.4.2)</a></div><p >every constructor call and full-expression in the
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializers</a></i> for non-static data members
(if any) is a constant expression (<a href='expr.const'>[expr.const]</a>),
</p></li><li id='10.4.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#10.4.3'>(10.4.3)</a></div><p >it is an aggregate type (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>) or has
at least one <span class='texttt'>constexpr</span> constructor or constructor template that is not a copy or move constructor, and
</p></li><li id='10.4.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#10.4.4'>(10.4.4)</a></div><p >all of its non-static data members and base classes are
of literal types.
</p></li></ul></li></ul></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p ><span class='indexparent'><a class='index' id='layout-compatible_type'></a></span>If two types <span class='texttt'>T1</span> and <span class='texttt'>T2</span> are the same type, then
<span class='texttt'>T1</span> and <span class='texttt'>T2</span> are <span class='grammarterm'>layout-compatible</span> types.
[&nbsp;<i>Note:</i> Layout-compatible enumerations are described
in <a href='dcl.enum'>[dcl.enum]</a>. Layout-compatible standard-layout
structs and standard-layout unions are
described in <a href='class.mem'>[class.mem]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-40'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-40'>40)</a></div><p >By using, for example, the library
functions (<a href='headers'>[headers]</a>) <span class='texttt'>std::memcpy</span> or <span class='texttt'>std::memmove</span>.</p></div><div class='footnote' id='footnote-41'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-41'>41)</a></div><p >By using, for example,
the library functions (<a href='headers'>[headers]</a>) <span class='texttt'>std::memcpy</span> or <span class='texttt'>std::memmove</span>.</p></div><div class='footnote' id='footnote-42'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-42'>42)</a></div><p >The
intent is that the memory model of C++ is compatible
with that of ISO/IEC 9899 Programming Language C.</p></div><div class='footnote' id='footnote-43'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-43'>43)</a></div><p >The size and layout of an instance of an incompletely-defined
object type is unknown.</p></div><div id='basic.fundamental'><h3 ><a class='secnum' href='#basic.fundamental' style='min-width:103pt'>3.9.1</a> Fundamental types <a class='abbr_ref' href='basic.fundamental'>[basic.fundamental]</a></h3><div class='para' id='basic.fundamental-1'><div class='marginalizedparent'><a class='marginalized' href='#basic.fundamental-1'>1</a></div><p ><span class='indexparent'><a class='index' id='type,fundamental'></a></span><span class='indexparent'><a class='index' id='type,integral'></a></span><span class='indexparent'><a class='index' id='type,floating_point'></a></span><span class='indexparent'><a class='index' id='type,implementation-defined_'></a></span><span class='indexparent'><a class='index' id='type,Boolean'></a></span><span class='indexparent'><a class='index' id='type,char'></a></span><span class='indexparent'><a class='index' id='type,character'></a></span>Objects declared as characters (<span class='texttt'>char</span>) shall be large enough to
store any member of the implementation's basic character set. If a
character from this set is stored in a character object, the integral
value of that character object is equal to the value of the single
character literal form of that character. It is <span class='indexparent'><a class='index' id='signedness_of_char'></a></span>implementation-defined
whether a <span class='texttt'>char</span> object can hold negative values.
<span class='indexparent'><a class='index' id='char,implementation-defined_sign_of'></a></span><span class='indexparent'><a class='index' id='type,signed_char'></a></span><span class='indexparent'><a class='index' id='type,unsigned_char'></a></span>Characters can be explicitly declared <span class='texttt'>unsigned</span> or
<span class='texttt'>signed</span>.
<span class='indexparent'><a class='index' id='character,signed'></a></span>Plain <span class='texttt'>char</span>, <span class='texttt'>signed char</span>, and <span class='texttt'>unsigned char</span> are
three distinct types. A <span class='texttt'>char</span>, a <span class='texttt'>signed char</span>, and an
<span class='texttt'>unsigned char</span> occupy the same amount of storage and have the
same alignment requirements (<a href='basic.align'>[basic.align]</a>); that is, they have the
same object representation. For character types, all bits of the object
representation participate in the value representation. For unsigned
character types, all possible bit patterns of the value representation
represent numbers. These requirements do not hold for other types. In
any particular implementation, a plain <span class='texttt'>char</span> object can take on
either the same values as a <span class='texttt'>signed char</span> or an <span class='texttt'>unsigned
char</span>; which one is <span class='indexparent'><a class='index' id='representation_of_char'></a></span>implementation-defined.</p></div><div class='para' id='basic.fundamental-2'><div class='marginalizedparent'><a class='marginalized' href='#basic.fundamental-2'>2</a></div><p ><span class='indexparent'><a class='index' id='type,standard_signed_integer'></a></span><span class='indexparent'><a class='index' id='standard_signed_integer_type'></a></span>There are five <a class='hidden_link' href='#def:standard_signed_integer_types' id='def:standard_signed_integer_types'><i>standard signed integer types</i></a> :
<span class='indexparent'><a class='index' id='type,signed_char'></a></span><span class='indexparent'><a class='index' id='type,short'></a></span><span class='indexparent'><a class='index' id='type,int'></a></span><span class='indexparent'><a class='index' id='type,long'></a></span><span class='indexparent'><a class='index' id='type,long_long'></a></span>“<span class='texttt'>signed char</span>”, “<span class='texttt'>short int</span>”, “<span class='texttt'>int</span>”,
“<span class='texttt'>long int</span>”, and “<span class='texttt'>long</span> <span class='texttt'>long</span> <span class='texttt'>int</span>”. In
this list, each type provides at least as much storage as those
preceding it in the list.
<span class='indexparent'><a class='index' id='type,extended_signed_integer'></a></span><span class='indexparent'><a class='index' id='extended_signed_integer_type'></a></span><span class='indexparent'><a class='index' id='type,signed_integer'></a></span><span class='indexparent'><a class='index' id='signed_integer_type'></a></span>There may also be <span class='indexparent'><a class='index' id='extended_signed_integer_types'></a></span>implementation-defined <a class='hidden_link' href='#def:extended_signed
integer_types' id='def:extended_signed
integer_types'><i>extended signed
integer types</i></a>. The standard and
extended signed integer types are collectively called <a class='hidden_link' href='#def:signed_integer_types' id='def:signed_integer_types'><i>signed integer types</i></a>.
<span class='indexparent'><a class='index' id='integral_type,implementation-defined_'></a></span>Plain
<span class='texttt'>int</span>s have the natural size suggested by the architecture of the
execution environment<a class='footnotenum' href='#footnote-44'>44</a>;
the other signed integer types are provided to meet special needs.</p></div><div class='para' id='basic.fundamental-3'><div class='marginalizedparent'><a class='marginalized' href='#basic.fundamental-3'>3</a></div><p ><span class='indexparent'><a class='index' id='type,unsigned'></a></span>For each of the standard signed integer types,
there exists a corresponding (but different)
<span class='indexparent'><a class='index' id='type,standard_unsigned_integer'></a></span><span class='indexparent'><a class='index' id='standard_unsigned_integer_type'></a></span><a class='hidden_link' href='#def:standard_unsigned_integer_type' id='def:standard_unsigned_integer_type'><i>standard unsigned integer type</i></a>:
<span class='indexparent'><a class='index' id='type,unsigned_char'></a></span><span class='indexparent'><a class='index' id='type,unsigned_short'></a></span><span class='indexparent'><a class='index' id='type,unsigned_int'></a></span><span class='indexparent'><a class='index' id='type,unsigned_long'></a></span><span class='indexparent'><a class='index' id='type,unsigned_long_long'></a></span>“<span class='texttt'>unsigned char</span>”, “<span class='texttt'>unsigned short int</span>”,
“<span class='texttt'>unsigned int</span>”, “<span class='texttt'>unsigned long int</span>”, and
“<span class='texttt'>unsigned</span> <span class='texttt'>long</span> <span class='texttt'>long</span> <span class='texttt'>int</span>”, each of
which occupies the same amount of storage and has the same alignment
requirements (<a href='basic.align'>[basic.align]</a>) as the corresponding signed integer
type<a class='footnotenum' href='#footnote-45'>45</a>;
that is, each signed integer type has the same object representation as
its corresponding unsigned integer type.
<span class='indexparent'><a class='index' id='type,extended_unsigned_integer'></a></span><span class='indexparent'><a class='index' id='extended_unsigned_integer_type'></a></span><span class='indexparent'><a class='index' id='type,unsigned_integer'></a></span><span class='indexparent'><a class='index' id='unsigned_integer_type'></a></span>Likewise, for each of the extended signed integer types there exists a
corresponding <a class='hidden_link' href='#def:extended_unsigned_integer_type' id='def:extended_unsigned_integer_type'><i>extended unsigned integer type</i></a> with the same amount of storage and alignment
requirements. The standard and extended unsigned integer types are
collectively called <a class='hidden_link' href='#def:unsigned_integer_types' id='def:unsigned_integer_types'><i>unsigned integer types</i></a>. The range of non-negative
values of a <a class='hidden_link' href='#def:signed_integer' id='def:signed_integer'><i>signed integer</i></a> type is a subrange of the corresponding
<a class='hidden_link' href='#def:unsigned_integer' id='def:unsigned_integer'><i>unsigned integer</i></a> type, and the value
representation of each corresponding signed/unsigned type shall be the
same.
<span class='indexparent'><a class='index' id='type,standard_integer'></a></span><span class='indexparent'><a class='index' id='standard_integer_type'></a></span><span class='indexparent'><a class='index' id='type,extended_integer'></a></span><span class='indexparent'><a class='index' id='extended_integer_type'></a></span>The standard signed integer types and standard unsigned integer types
are collectively called the <a class='hidden_link' href='#def:standard_integer_types' id='def:standard_integer_types'><i>standard integer types</i></a>, and the extended
signed integer types and extended
unsigned integer types are collectively called the <a class='hidden_link' href='#def:extended_integer_types' id='def:extended_integer_types'><i>extended integer types</i></a>.</p></div><div class='para' id='basic.fundamental-4'><div class='marginalizedparent'><a class='marginalized' href='#basic.fundamental-4'>4</a></div><p ><span class='indexparent'><a class='index' id='arithmetic,unsigned'></a></span>Unsigned integers, declared <span class='texttt'>unsigned</span>, shall obey the laws of
arithmetic modulo <span class='math'>2<sup ><span class='mathalpha'>n</span></sup></span> where <span class='math'><span class='mathalpha'>n</span></span> is the number of bits in the value
representation of that particular size of integer.<a class='footnotenum' href='#footnote-46'>46</a></p></div><div class='para' id='basic.fundamental-5'><div class='marginalizedparent'><a class='marginalized' href='#basic.fundamental-5'>5</a></div><p ><span class='indexparent'><a class='index' id='type,char16_t'></a></span><span class='indexparent'><a class='index' id='type,char32_t'></a></span><span class='indexparent'><a class='index' id='wchar_t,implementation-defined'></a></span><span class='indexparent'><a class='index' id='type,wchar_t'></a></span><span class='indexparent'><a class='index' id='type,underlying_wchar_t'></a></span>Type <span class='texttt'>wchar_t</span> is a distinct type whose values can represent
distinct codes for all members of the largest extended character set
specified among the supported locales (<a href='locale'>[locale]</a>). Type
<span class='texttt'>wchar_t</span> shall have the same size, signedness, and alignment
requirements (<a href='basic.align'>[basic.align]</a>) as one of the other integral types,
called its <a class='hidden_link' href='#def:underlying_type' id='def:underlying_type'><i>underlying type</i></a>. Types <span class='texttt'>char16_t</span> and
<span class='texttt'>char32_t</span> denote distinct types with the same size, signedness,
and alignment as <span class='texttt'>uint_least16_t</span> and <span class='texttt'>uint_least32_t</span>,
respectively, in <span class='texttt'>&lt;stdint.h&gt;</span>, called the underlying types.</p></div><div class='para' id='basic.fundamental-6'><div class='marginalizedparent'><a class='marginalized' href='#basic.fundamental-6'>6</a></div><p ><span class='indexparent'><a class='index' id='Boolean_type'></a></span>Values of type <span class='texttt'>bool</span> are either <span class='texttt'>true</span> or
<span class='texttt'>false</span>.<a class='footnotenum' href='#footnote-47'>47</a>
[&nbsp;<i>Note:</i> There are no <span class='texttt'>signed</span>, <span class='texttt'>unsigned</span>, <span class='texttt'>short</span>,
or <span class='texttt'>long bool</span> types or values. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Values of type
<span class='texttt'>bool</span> participate in integral promotions (<a href='conv.prom'>[conv.prom]</a>).</p></div><div class='para' id='basic.fundamental-7'><div class='marginalizedparent'><a class='marginalized' href='#basic.fundamental-7'>7</a></div><p >Types <span class='texttt'>bool</span>, <span class='texttt'>char</span>, <span class='texttt'>char16_t</span>, <span class='texttt'>char32_t</span>,
<span class='texttt'>wchar_t</span>, and the signed and unsigned integer types are
collectively called
<span class='indexparent'><a class='index' id='integral_type'></a></span><a class='hidden_link' href='#def:integral' id='def:integral'><i>integral</i></a> types.<a class='footnotenum' href='#footnote-48'>48</a>
A synonym for integral type is
<span class='indexparent'><a class='index' id='integer_type'></a></span><a class='hidden_link' href='#def:integer_type' id='def:integer_type'><i>integer type</i></a>. The representations of integral types shall
define values by use of  a pure binary numeration system.<a class='footnotenum' href='#footnote-49'>49</a>
[&nbsp;<i>Example:</i> this International Standard permits 2's complement, 1's
complement and signed magnitude representations for integral types.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='basic.fundamental-8'><div class='marginalizedparent'><a class='marginalized' href='#basic.fundamental-8'>8</a></div><p ><span class='indexparent'><a class='index' id='floating_point_type'></a></span>There are three <a class='hidden_link' href='#def:floating_point' id='def:floating_point'><i>floating point</i></a> types:
<span class='indexparent'><a class='index' id='type,float'></a></span><span class='texttt'>float</span>,
<span class='indexparent'><a class='index' id='type,double'></a></span><span class='texttt'>double</span>,
and
<span class='indexparent'><a class='index' id='type,long_double'></a></span><span class='texttt'>long double</span>. The type <span class='texttt'>double</span> provides at least as much
precision as <span class='texttt'>float</span>, and the type <span class='texttt'>long double</span> provides at
least as much precision as <span class='texttt'>double</span>. The set of values of the type
<span class='texttt'>float</span> is a subset of the set of values of the type
<span class='texttt'>double</span>; the set of values of the type <span class='texttt'>double</span> is a subset
of the set of values of the type <span class='texttt'>long</span> <span class='texttt'>double</span>. The value
representation of floating-point types is <span class='indexparent'><a class='index' id='value_representation_of_floating-point_types'></a></span>implementation-defined.
<span class='indexparent'><a class='index' id='floating_point_type,implementation-defined'></a></span><span class='indexparent'><a class='index' id='type,arithmetic'></a></span><a class='hidden_link' href='#def:Integral' id='def:Integral'><i>Integral</i></a> and <a class='hidden_link' href='#def:floating' id='def:floating'><i>floating</i></a> types are collectively
called <a class='hidden_link' href='#def:arithmetic' id='def:arithmetic'><i>arithmetic</i></a> types.
<span class='indexparent'><a class='index' id='numeric_limits'></a></span>Specializations of the standard template
<span class='texttt'>std::numeric_limits</span> (<a href='support.limits'>[support.limits]</a>) shall specify the
maximum and minimum values of each arithmetic type for an
implementation.</p></div><div class='para' id='basic.fundamental-9'><div class='marginalizedparent'><a class='marginalized' href='#basic.fundamental-9'>9</a></div><p ><span class='indexparent'><a class='index' id='type,void'></a></span>The <span class='texttt'>void</span> type has an empty set of values. The <span class='texttt'>void</span> type
is an incomplete type that cannot be completed. It is used as the return
type for functions that do not return a value. Any expression can be
explicitly converted to type <a class='hidden_link' href='#def:cv' id='def:cv'><i>cv</i></a>
<span class='texttt'>void</span> (<a href='expr.cast'>[expr.cast]</a>). An expression of type <span class='texttt'>void</span> shall
be used only as an expression statement (<a href='stmt.expr'>[stmt.expr]</a>), as an operand
of a comma expression (<a href='expr.comma'>[expr.comma]</a>), as a second or third operand
of <span class='texttt'>?:</span> (<a href='expr.cond'>[expr.cond]</a>), as the operand of
<span class='texttt'>typeid</span> or <span class='texttt'>decltype</span>, as
the expression in a return statement (<a href='stmt.return'>[stmt.return]</a>) for a function
with the return type <span class='texttt'>void</span>, or as the operand of an explicit conversion
to type <i>cv</i> <span class='texttt'>void</span>.</p></div><div class='para' id='basic.fundamental-10'><div class='marginalizedparent'><a class='marginalized' href='#basic.fundamental-10'>10</a></div><p >A value of type <span class='texttt'>std::nullptr_t</span> is a null pointer
constant (<a href='conv.ptr'>[conv.ptr]</a>). Such values participate in the pointer and the
pointer to member conversions (<a href='conv.ptr'>[conv.ptr]</a>, <a href='conv.mem'>[conv.mem]</a>).
<span class='texttt'>sizeof(std::nullptr_t)</span> shall be equal to <span class='texttt'>sizeof(void*)</span>.</p></div><div class='para' id='basic.fundamental-11'><div class='marginalizedparent'><a class='marginalized' href='#basic.fundamental-11'>11</a></div><p >[&nbsp;<i>Note:</i> 
Even if the implementation defines two or more basic types to have the
same value representation, they are nevertheless different types.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='footnote' id='footnote-44'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-44'>44)</a></div><p >that is, large enough to contain any value in the range of
<span class='texttt'>INT_MIN</span> and <span class='texttt'>INT_MAX</span>, as defined in the header
<span class='texttt'>&lt;climits&gt;</span>.</p></div><div class='footnote' id='footnote-45'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-45'>45)</a></div><p >See <a href='dcl.type.simple'>[dcl.type.simple]</a> regarding the correspondence between types and
the sequences of <i ><a href='dcl.type#nt:type-specifier'>type-specifiers</a></i> that designate them.</p></div><div class='footnote' id='footnote-46'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-46'>46)</a></div><p >This implies that
unsigned arithmetic does not overflow because a result
that cannot be represented by the resulting unsigned integer type is
reduced modulo the number that is one greater than the largest value
that can be represented by the resulting unsigned integer type.</p></div><div class='footnote' id='footnote-47'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-47'>47)</a></div><p >Using a <span class='texttt'>bool</span> value in ways described by this International
Standard as “undefined,” such as by examining the value of an
uninitialized automatic object, might cause it to behave as if it is
neither <span class='texttt'>true</span> nor <span class='texttt'>false</span>.</p></div><div class='footnote' id='footnote-48'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-48'>48)</a></div><p >Therefore, enumerations (<a href='dcl.enum'>[dcl.enum]</a>) are not integral; however,
enumerations can be promoted to integral types as specified
in <a href='conv.prom'>[conv.prom]</a>.</p></div><div class='footnote' id='footnote-49'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-49'>49)</a></div><p >A positional
representation for integers that uses the binary digits 0
and 1, in which the values represented by successive bits are additive,
begin with 1, and are multiplied by successive integral power of 2,
except perhaps for the bit with the highest position. (Adapted from the
<i>American National Dictionary for Information Processing Systems</i>.)</p></div></div><div id='basic.compound'><h3 ><a class='secnum' href='#basic.compound' style='min-width:103pt'>3.9.2</a> Compound types <a class='abbr_ref' href='basic.compound'>[basic.compound]</a></h3><div class='para' id='basic.compound-1'><div class='marginalizedparent'><a class='marginalized' href='#basic.compound-1'>1</a></div><p ><span class='indexparent'><a class='index' id='type,compound'></a></span>Compound types can be constructed in the following ways:</p><ul ><li id='basic.compound-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#basic.compound-1.1'>(1.1)</a></div><p ><span class='indexparent'><a class='index' id='type,array'></a></span><a class='hidden_link' href='#def:arrays' id='def:arrays'><i>arrays</i></a> of objects of a given type, <a href='dcl.array'>[dcl.array]</a>;</p></li><li id='basic.compound-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#basic.compound-1.2'>(1.2)</a></div><p ><span class='indexparent'><a class='index' id='type,function'></a></span><a class='hidden_link' href='#def:functions' id='def:functions'><i>functions</i></a>, which have parameters of given types and return
<span class='texttt'>void</span> or references or objects of a given type, <a href='dcl.fct'>[dcl.fct]</a>;</p></li><li id='basic.compound-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#basic.compound-1.3'>(1.3)</a></div><p ><span class='indexparent'><a class='index' id='type,pointer'></a></span><a class='hidden_link' href='#def:pointers' id='def:pointers'><i>pointers</i></a> to <span class='texttt'>void</span> or objects or functions (including
static members of classes) of a given type, <a href='dcl.ptr'>[dcl.ptr]</a>;</p></li><li id='basic.compound-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#basic.compound-1.4'>(1.4)</a></div><p ><span class='indexparent'><a class='index' id='reference'></a></span><span class='indexparent'><a class='index' id='reference,lvalue'></a></span><span class='indexparent'><a class='index' id='reference,rvalue'></a></span><span class='indexparent'><a class='index' id='lvalue_reference'></a></span><span class='indexparent'><a class='index' id='rvalue_reference'></a></span><a class='hidden_link' href='#def:references' id='def:references'><i>references</i></a> to objects or functions of a given
type, <a href='dcl.ref'>[dcl.ref]</a>. There are two types of references:
</p><ul ><li id='basic.compound-1.4.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#basic.compound-1.4.1'>(1.4.1)</a></div><p ><a class='hidden_link' href='#def:lvalue_reference' id='def:lvalue_reference'><i>lvalue reference</i></a>
</p></li><li id='basic.compound-1.4.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#basic.compound-1.4.2'>(1.4.2)</a></div><p ><a class='hidden_link' href='#def:rvalue_reference' id='def:rvalue_reference'><i>rvalue reference</i></a>
</p></li></ul></li><li id='basic.compound-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#basic.compound-1.5'>(1.5)</a></div><p ><span class='indexparent'><a class='index' id='class'></a></span><a class='hidden_link' href='#def:classes' id='def:classes'><i>classes</i></a> containing a sequence of objects of various types
(Clause <a href='class'>[class]</a>), a set of types, enumerations and functions for
manipulating these objects (<a href='class.mfct'>[class.mfct]</a>), and a set of restrictions
on the access to these entities (Clause <a href='class.access'>[class.access]</a>);</p></li><li id='basic.compound-1.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#basic.compound-1.6'>(1.6)</a></div><p ><span class='indexparent'><a class='index' id='union'></a></span><a class='hidden_link' href='#def:unions' id='def:unions'><i>unions</i></a>, which are classes capable of containing objects of
different types at different times, <a href='class.union'>[class.union]</a>;</p></li><li id='basic.compound-1.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#basic.compound-1.7'>(1.7)</a></div><p ><span class='indexparent'><a class='index' id='enum'></a></span><a class='hidden_link' href='#def:enumerations' id='def:enumerations'><i>enumerations</i></a>, which comprise a set of named constant values.
Each distinct enumeration constitutes a different
<span class='indexparent'><a class='index' id='type,enumerated'></a></span><a class='hidden_link' href='#def:enumerated_type' id='def:enumerated_type'><i>enumerated type</i></a>, <a href='dcl.enum'>[dcl.enum]</a>;</p></li><li id='basic.compound-1.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#basic.compound-1.8'>(1.8)</a></div><p ><span class='indexparent'><a class='index' id='member_pointer_to'></a></span><span class='indexparent'><a class='index' id='pointer_to_member'></a></span><a class='hidden_link' href='#def:pointers_to_non-static' id='def:pointers_to_non-static'><i>pointers to non-static</i></a>
<a class='footnotenum' href='#footnote-50'>50</a>
<a class='hidden_link' href='#def:class_members' id='def:class_members'><i>class members</i></a>, which identify members of a given
type within objects of a given class, <a href='dcl.mptr'>[dcl.mptr]</a>.
</p></li></ul></div><div class='para' id='basic.compound-2'><div class='marginalizedparent'><a class='marginalized' href='#basic.compound-2'>2</a></div><p >These methods of constructing types can be applied recursively;
restrictions are mentioned in <a href='dcl.ptr'>[dcl.ptr]</a>, <a href='dcl.array'>[dcl.array]</a>,
<a href='dcl.fct'>[dcl.fct]</a>, and <a href='dcl.ref'>[dcl.ref]</a>.</p></div><div class='para' id='basic.compound-3'><div class='marginalizedparent'><a class='marginalized' href='#basic.compound-3'>3</a></div><p ><span class='indexparent'><a class='index' id='terminology,pointer'></a></span>The type of a pointer to <span class='texttt'>void</span> or a pointer to an object type is
called an <a class='hidden_link' href='#def:object_pointer_type' id='def:object_pointer_type'><i>object pointer type</i></a>. [&nbsp;<i>Note:</i> A pointer to <span class='texttt'>void</span>
does not have a pointer-to-object type, however, because <span class='texttt'>void</span> is not
an object type. <i>&nbsp;—&nbsp;end note</i>&nbsp;] The type of a pointer that can designate a function
is called a <a class='hidden_link' href='#def:function_pointer_type' id='def:function_pointer_type'><i>function pointer type</i></a>.
A pointer to objects of type <span class='texttt'>T</span> is referred to as a “pointer to
<span class='texttt'>T</span>.” [&nbsp;<i>Example:</i> a pointer to an object of type <span class='texttt'>int</span> is
referred to as “pointer to <span class='texttt'>int</span> ” and a pointer to an object of
class <span class='texttt'>X</span> is called a “pointer to <span class='texttt'>X</span>.” <i>&nbsp;—&nbsp;end example</i>&nbsp;]
Except for pointers to static members, text referring to “pointers”
does not apply to pointers to members. Pointers to incomplete types are
allowed although there are restrictions on what can be done with
them (<a href='basic.align'>[basic.align]</a>).
<span class='indexparent'><a class='index' id='address'></a></span>A valid value of an object
pointer type represents either the address of a byte in
memory (<a href='intro.memory'>[intro.memory]</a>) or a null pointer (<a href='conv.ptr'>[conv.ptr]</a>). If an
object of type <span class='texttt'>T</span> is located at an address <span class='texttt'>A</span>, a pointer
of type <a class='hidden_link' href='#def:cv' id='def:cv'><i>cv</i></a> <span class='texttt'>T*</span> whose value is the address <span class='texttt'>A</span> is
said to <a class='hidden_link' href='#def:point_to' id='def:point_to'><i>point to</i></a> that object, regardless of how the value was
obtained. [&nbsp;<i>Note:</i> For instance, the address one past the end of an
array (<a href='expr.add'>[expr.add]</a>) would be considered to point to an unrelated
object of the array's element type that might be located at that
address. There are further restrictions on pointers to objects with dynamic storage
duration; see <a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] The value representation of
pointer types is <span class='indexparent'><a class='index' id='value_representation_of_pointer_types'></a></span>implementation-defined. Pointers to
cv-qualified and cv-unqualified
versions (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>) of layout-compatible types shall
have the same value representation and alignment
requirements (<a href='basic.align'>[basic.align]</a>).
[&nbsp;<i>Note:</i> Pointers to over-aligned types (<a href='basic.align'>[basic.align]</a>) have no special
representation, but their range of valid values is restricted by the extended
alignment requirement. This International Standard specifies only two ways
of obtaining such a pointer: taking the address of a valid object with
an over-aligned type, and using one of the runtime pointer alignment functions.
An implementation may provide other means of obtaining a valid pointer value
for an over-aligned type.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='basic.compound-4'><div class='marginalizedparent'><a class='marginalized' href='#basic.compound-4'>4</a></div><p ><span class='indexparent'><a class='index' id='pointer'></a></span><span class='indexparent'><a class='index' id='void*,type'></a></span>A pointer to <i>cv</i>-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>) or <i>cv</i>-unqualified
<span class='texttt'>void</span>
can be used to point to objects of
unknown type. Such a pointer shall be able to hold any object pointer.
An object of type <i>cv</i>
<span class='texttt'>void*</span> shall have the same representation and alignment
requirements as <i>cv</i> <span class='texttt'>char*</span>.</p></div><div class='footnote' id='footnote-50'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-50'>50)</a></div><p >Static class members are objects or functions, and pointers to them are
ordinary pointers to objects or functions.</p></div></div><div id='basic.type.qualifier'><h3 ><a class='secnum' href='#basic.type.qualifier' style='min-width:103pt'>3.9.3</a> CV-qualifiers <a class='abbr_ref' href='basic.type.qualifier'>[basic.type.qualifier]</a></h3><div class='para' id='basic.type.qualifier-1'><div class='marginalizedparent'><a class='marginalized' href='#basic.type.qualifier-1'>1</a></div><p ><span class='indexparent'><a class='index' id='cv-qualifier'></a></span><span class='indexparent'><a class='index' id='const'></a></span><span class='indexparent'><a class='index' id='volatile'></a></span>A type mentioned in <a href='basic.fundamental'>[basic.fundamental]</a> and <a href='basic.compound'>[basic.compound]</a> is
a <a class='hidden_link' href='#def:cv-unqualified_type' id='def:cv-unqualified_type'><i>cv-unqualified type</i></a>. Each type which is a
cv-unqualified complete or incomplete object type or is
<span class='texttt'>void</span> (<a href='basic.types'>[basic.types]</a>) has three corresponding cv-qualified
versions of its type: a <span class='grammarterm'>const-qualified</span> version, a
<a class='hidden_link' href='#def:volatile-qualified' id='def:volatile-qualified'><i>volatile-qualified</i></a> version, and a
<a class='hidden_link' href='#def:const-volatile-qualified' id='def:const-volatile-qualified'><i>const-volatile-qualified</i></a> version. The term
<a class='hidden_link' href='#def:object_type' id='def:object_type'><i>object type</i></a> (<a href='intro.object'>[intro.object]</a>) includes the cv-qualifiers
specified when the object is created. The presence of a <span class='texttt'>const</span>
specifier in a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> declares an object of
<a class='hidden_link' href='#def:const-qualified_object_type' id='def:const-qualified_object_type'><i>const-qualified object type</i></a>; such
object is called a <a class='hidden_link' href='#def:const_object' id='def:const_object'><i>const object</i></a>. The presence of a
<span class='texttt'>volatile</span> specifier in a <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> declares
an object of <span class='grammarterm'>volatile-qualified</span> <a class='hidden_link' href='#def:object_type' id='def:object_type'><i>object type</i></a>; such object
is called a <a class='hidden_link' href='#def:volatile_object' id='def:volatile_object'><i>volatile object</i></a>. The presence of both <span class='grammarterm'>cv-qualifiers</span> in a
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> declares an object of
<a class='hidden_link' href='#def:const-volatile-qualified_object_type' id='def:const-volatile-qualified_object_type'><i>const-volatile-qualified object type</i></a>;
such object is called a <a class='hidden_link' href='#def:const_volatile_object' id='def:const_volatile_object'><i>const volatile object</i></a>. The cv-qualified or
cv-unqualified versions of a type
are distinct types; however, they shall have the same representation and
alignment requirements (<a href='basic.types'>[basic.types]</a>).<a class='footnotenum' href='#footnote-51'>51</a></p></div><div class='para' id='basic.type.qualifier-2'><div class='marginalizedparent'><a class='marginalized' href='#basic.type.qualifier-2'>2</a></div><p ><span class='indexparent'><a class='index' id='array,const'></a></span>A compound type (<a href='basic.compound'>[basic.compound]</a>) is not cv-qualified by the
cv-qualifiers (if any) of the types from which it is compounded. Any
cv-qualifiers applied to an array type affect the array element type,
not the array type (<a href='dcl.array'>[dcl.array]</a>).</p></div><div class='para' id='basic.type.qualifier-3'><div class='marginalizedparent'><a class='marginalized' href='#basic.type.qualifier-3'>3</a></div><p ><span class='indexparent'><a class='index' id='class_object,const'></a></span>Each non-static, non-mutable, non-reference data member of a
const-qualified class object is const-qualified, each non-static,
non-reference data member of a volatile-qualified class object is
volatile-qualified and similarly for members of a const-volatile class.
See <a href='dcl.fct'>[dcl.fct]</a> and <a href='class.this'>[class.this]</a> regarding function
types that have <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifiers</a></i>.</p></div><div class='para' id='basic.type.qualifier-4'><div class='marginalizedparent'><a class='marginalized' href='#basic.type.qualifier-4'>4</a></div><p >There is a partial ordering on cv-qualifiers, so that a type can be
said to be <span class='grammarterm'>more cv-qualified</span> than another.
Table <a href='#tab:relations.on.const.and.volatile'>[tab:relations.on.const.and.volatile]</a> shows the relations that
constitute this ordering.</p><div class='numberedTable' id='tab:relations.on.const.and.volatile'>Table <a href='#tab:relations.on.const.and.volatile'>9</a> — Relations on <span class='texttt'>const</span> and <span class='texttt'>volatile</span><br><table ><tr class='rowsep'><td class='center'>



<i>no cv-qualifier</i>    </td><td class='center'>&lt;</td><td class='center'> <span class='texttt'>const</span>           </td></tr><tr ><td class='center'>
<i>no cv-qualifier</i>    </td><td class='center'>&lt;</td><td class='center'> <span class='texttt'>volatile</span>        </td></tr><tr ><td class='center'>
<i>no cv-qualifier</i>    </td><td class='center'>&lt;</td><td class='center'> <span class='texttt'>const volatile</span>  </td></tr><tr ><td class='center'>
<span class='texttt'>const</span>               </td><td class='center'>&lt;</td><td class='center'> <span class='texttt'>const volatile</span>  </td></tr><tr ><td class='center'>
<span class='texttt'>volatile</span>            </td><td class='center'>&lt;</td><td class='center'> <span class='texttt'>const volatile</span>  </td></tr></table></div></div><div class='para' id='basic.type.qualifier-5'><div class='marginalizedparent'><a class='marginalized' href='#basic.type.qualifier-5'>5</a></div><p >In this International Standard, the notation <a class='hidden_link' href='#def:cv' id='def:cv'><i>cv</i></a> (or
<a class='hidden_link' href='#def:cv1' id='def:cv1'><i>cv1</i></a>, <a class='hidden_link' href='#def:cv2' id='def:cv2'><i>cv2</i></a>, etc.), used in the description of types,
represents an arbitrary set of cv-qualifiers, i.e., one of
{<span class='texttt'>const</span>}, {<span class='texttt'>volatile</span>}, {<span class='texttt'>const</span>,
<span class='texttt'>volatile</span>}, or the empty set. Cv-qualifiers applied to an array
type attach to the underlying element type, so the notation
“<a class='hidden_link' href='#def:cv' id='def:cv'><i>cv</i></a> <span class='texttt'>T</span>,” where <span class='texttt'>T</span> is an array type, refers to
an array whose elements are so-qualified. Such array types can be said
to be more (or less) cv-qualified than other types based on the
cv-qualification of the underlying element types.<span class='indexparent'><a class='index' id='type'></a></span></p></div><div class='footnote' id='footnote-51'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-51'>51)</a></div><p >The same representation
and alignment requirements are meant to imply
interchangeability as arguments to functions, return values from
functions, and non-static data members of unions.</p></div></div></div></div></body></html>