<!DOCTYPE html><html lang='en'><head><title>[expr.static.cast]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>5.2</a> Postfix expressions <a class='abbr_ref' href='expr.post#expr.static.cast'>[expr.post]</a></h2><div id='expr.static.cast'><h3 ><a class='secnum' style='min-width:103pt'>5.2.9</a> Static cast <a class='abbr_ref'>[expr.static.cast]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,static_cast'></a></span><span class='indexparent'><a class='index' id='cast,static'></a></span>The result of the expression <span class='texttt'>static_cast&lt;T&gt;(v)</span> is the result of
converting the expression <span class='texttt'>v</span> to type <span class='texttt'>T</span>.
<span class='indexparent'><a class='index' id='cast,static,lvalue'></a></span><span class='indexparent'><a class='index' id='cast,lvalue'></a></span>If <span class='texttt'>T</span> is an lvalue reference type
or an rvalue reference to function type, the result is an lvalue;
if <span class='texttt'>T</span> is an rvalue reference to object type, the result is an xvalue;
otherwise, the result is a prvalue. The <span class='texttt'>static_cast</span> operator shall not cast
away constness (<a href='expr.const.cast'>[expr.const.cast]</a>).</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='cast,static,reference'></a></span><span class='indexparent'><a class='index' id='cast,reference'></a></span>An lvalue of type “<i>cv1</i> <span class='texttt'>B</span>,” where <span class='texttt'>B</span> is a class
type, can be cast to type “reference to <i>cv2</i> <span class='texttt'>D</span>,” where
<span class='texttt'>D</span> is a class derived (Clause <a href='class.derived'>[class.derived]</a>) from
<span class='texttt'>B</span>, if a valid standard conversion from “pointer to <span class='texttt'>D</span>”
to “pointer to <span class='texttt'>B</span>” exists (<a href='conv.ptr'>[conv.ptr]</a>), <i>cv2</i> is the
same cv-qualification as, or greater cv-qualification than,
<i>cv1</i>, and <span class='texttt'>B</span> is neither a virtual base class of <span class='texttt'>D</span>
nor a base class of a virtual base class of <span class='texttt'>D</span>. The result has
type “<i>cv2</i> <span class='texttt'>D</span>.” An xvalue of type
“<i>cv1</i> <span class='texttt'>B</span>” may be cast to type “rvalue reference to
<i>cv2</i> <span class='texttt'>D</span>” with the same constraints as for an lvalue of
type “<i>cv1</i> <span class='texttt'>B</span>.” If the object
of type “<i>cv1</i> <span class='texttt'>B</span>” is actually a subobject of an object
of type <span class='texttt'>D</span>, the result refers to the enclosing object of type
<span class='texttt'>D</span>. Otherwise, the result of the cast is undefined.
[&nbsp;<i>Example:</i> </p><pre class='codeblock'>
struct B { };
struct D : public B { };
D d;
B &amp;br = d;

static_cast&lt;D&amp;&gt;(br);            <span class='comment'>// produces lvalue to the original <span class='texttt'>d</span> object
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;] </p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A glvalue of type “<i>cv1</i> <span class='texttt'>T1</span>” can be cast to type “rvalue
reference to <i>cv2</i> <span class='texttt'>T2</span>” if “<i>cv2</i> <span class='texttt'>T2</span>” is
reference-compatible with “<i>cv1</i> <span class='texttt'>T1</span>” (<a href='dcl.init.ref'>[dcl.init.ref]</a>). The
result refers to the object or the specified base class subobject thereof. If
<span class='texttt'>T2</span> is an inaccessible (Clause <a href='class.access'>[class.access]</a>) or
ambiguous (<a href='class.member.lookup'>[class.member.lookup]</a>) base class of <span class='texttt'>T1</span>,
a program that necessitates such a cast is ill-formed.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >Otherwise, an expression <span class='texttt'>e</span> can be explicitly converted to a type
<span class='texttt'>T</span> using a <span class='texttt'>static_cast</span> of the form
<span class='texttt'>static_cast&lt;T&gt;(e)</span> if the declaration <span class='texttt'>T t(e);</span> is
well-formed, for some invented temporary variable
<span class='texttt'>t</span> (<a href='dcl.init'>[dcl.init]</a>). The effect of such an explicit conversion is
the same as performing the declaration and initialization and then using
the temporary variable as the result of the conversion. The expression
<span class='texttt'>e</span> is used as a glvalue if and
only if the initialization uses it as a glvalue.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >Otherwise, the <span class='texttt'>static_cast</span> shall perform one of the conversions
listed below. No other conversion shall be performed explicitly using a
<span class='texttt'>static_cast</span>.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >Any expression can be explicitly converted to type <i>cv</i>
<span class='texttt'>void</span>, in which case it becomes a discarded-value
expression (Clause <a href='expr'>[expr]</a>).
[&nbsp;<i>Note:</i> 
however, if the value is in a temporary
object (<a href='class.temporary'>[class.temporary]</a>), the destructor for that
object is
not executed until the usual time, and the value of the object is
preserved for the purpose of executing the destructor.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >The inverse of any standard conversion sequence (Clause <a href='conv'>[conv]</a>) not containing an
lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>),
array-to-pointer (<a href='conv.array'>[conv.array]</a>),
function-to-pointer (<a href='conv.func'>[conv.func]</a>),
null pointer (<a href='conv.ptr'>[conv.ptr]</a>), null member pointer (<a href='conv.mem'>[conv.mem]</a>), or
boolean (<a href='conv.bool'>[conv.bool]</a>)
conversion, can be performed explicitly using <span class='texttt'>static_cast</span>. A
program is ill-formed if it uses <span class='texttt'>static_cast</span> to perform the
inverse of an ill-formed standard conversion sequence.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct B { };
struct D : private B { };
void f() {
  static_cast&lt;D*&gt;((B*)0);               <span class='comment'>// Error: B is a private base of D.
</span>  static_cast&lt;int B::*&gt;((int D::*)0);   <span class='comment'>// Error: B is a private base of D.
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >The lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>),
array-to-pointer (<a href='conv.array'>[conv.array]</a>), and
function-to-pointer (<a href='conv.func'>[conv.func]</a>) conversions are applied to the
operand. Such a <span class='texttt'>static_cast</span> is subject to the restriction that
the explicit conversion does not cast away
constness (<a href='expr.const.cast'>[expr.const.cast]</a>), and the following additional rules
for specific cases:</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >A value of a scoped enumeration type (<a href='dcl.enum'>[dcl.enum]</a>) can be explicitly converted to an
integral type. The value is unchanged if the original value can be represented by the
specified type. Otherwise, the resulting value is unspecified.
A value of a scoped enumeration type can also be explicitly converted to a
floating-point type; the result is the same as that of converting from the original
value to the floating-point type.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p ><span class='indexparent'><a class='index' id='enumeration_type,conversion_to'></a></span><span class='indexparent'><a class='index' id='enumeration_type,static_cast,conversion_to'></a></span>A value of integral or enumeration type can be explicitly converted to
an enumeration type. The value is unchanged if the original value is
within the range of the enumeration values (<a href='dcl.enum'>[dcl.enum]</a>). Otherwise,
the resulting value is unspecified (and might not be
in that range).
A value of floating-point type can also be converted to an enumeration type.
The resulting value is the same as converting the original value to the
underlying type of the enumeration (<a href='conv.fpint'>[conv.fpint]</a>), and subsequently to
the enumeration type.</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p ><span class='indexparent'><a class='index' id='cast,base_class'></a></span><span class='indexparent'><a class='index' id='cast,derived_class'></a></span>A prvalue of type “pointer to <i>cv1</i> <span class='texttt'>B</span>,” where <span class='texttt'>B</span>
is a class type, can be converted to a prvalue of type “pointer to
<i>cv2</i> <span class='texttt'>D</span>,” where <span class='texttt'>D</span> is a class derived
(Clause <a href='class.derived'>[class.derived]</a>) from <span class='texttt'>B</span>, if a valid standard
conversion from “pointer to <span class='texttt'>D</span>” to “pointer to <span class='texttt'>B</span>”
exists (<a href='conv.ptr'>[conv.ptr]</a>), <i>cv2</i> is the same cv-qualification as,
or greater cv-qualification than, <i>cv1</i>, and <span class='texttt'>B</span> is neither
a virtual base class of <span class='texttt'>D</span> nor a base class of a virtual base
class of <span class='texttt'>D</span>. The null pointer value (<a href='conv.ptr'>[conv.ptr]</a>) is converted
to the null pointer value of the destination type. If the prvalue of type
“pointer to <i>cv1</i> <span class='texttt'>B</span>” points to a <span class='texttt'>B</span> that is
actually a subobject of an object of type <span class='texttt'>D</span>, the resulting
pointer points to the enclosing object of type <span class='texttt'>D</span>. Otherwise, the
result of the cast is undefined.</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p ><span class='indexparent'><a class='index' id='cast,pointer-to-member'></a></span>A prvalue of type “pointer to member of <span class='texttt'>D</span> of type <i>cv1</i>
<span class='texttt'>T</span>” can be converted to a prvalue of type “pointer to member of
<span class='texttt'>B</span>” of type <i>cv2</i> <span class='texttt'>T</span>, where <span class='texttt'>B</span> is a base
class (Clause <a href='class.derived'>[class.derived]</a>) of <span class='texttt'>D</span>, if a valid standard
conversion from “pointer to member of <span class='texttt'>B</span> of type <span class='texttt'>T</span>” to
“pointer to member of <span class='texttt'>D</span> of type <span class='texttt'>T</span>”
exists (<a href='conv.mem'>[conv.mem]</a>), and <i>cv2</i> is the same cv-qualification
as, or greater cv-qualification than, <i>cv1</i>.<a class='footnotenum' href='#footnote-69'>69</a>
The null member pointer value (<a href='conv.mem'>[conv.mem]</a>) is converted to the null
member pointer value of the destination type. If class <span class='texttt'>B</span>
contains the original member, or is a base or derived class of the class
containing the original member, the resulting pointer to member points
to the original member. Otherwise, the result of the cast is undefined.
[&nbsp;<i>Note:</i> 
although class <span class='texttt'>B</span> need not contain the original member, the
dynamic type of the object on which the pointer to member is
dereferenced must contain the original member; see <a href='expr.mptr.oper'>[expr.mptr.oper]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p >A prvalue of type “pointer to <i>cv1</i> <span class='texttt'>void</span>” can be
converted to a prvalue of type “pointer to <i>cv2</i> <span class='texttt'>T</span>,”
where <span class='texttt'>T</span> is an object type and <i>cv2</i> is the same
cv-qualification as, or greater cv-qualification than, <i>cv1</i>. The
null pointer value is converted to the null pointer value of the
destination type. A value of type pointer to object converted to
“pointer to <i>cv</i> <span class='texttt'>void</span>” and back, possibly with
different cv-qualification, shall have its original value.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
T* p1 = new T;
const T* p2 = static_cast&lt;const T*&gt;(static_cast&lt;void*&gt;(p1));
bool b = p1 == p2;  <span class='comment'>// <span class='texttt'>b</span> will have the value <span class='texttt'>true</span>.
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='footnote' id='footnote-69'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-69'>69)</a></div><p >Function types
(including those used in pointer to member function
types) are never cv-qualified; see <a href='dcl.fct'>[dcl.fct]</a>.</p></div></div></div></body></html>