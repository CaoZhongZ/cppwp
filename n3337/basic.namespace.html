<!DOCTYPE html><html lang='en'><head><title>[basic.namespace]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Declarations <a class='abbr_ref' href='./#dcl.dcl'>[dcl.dcl]</a></h1><div id='basic.namespace'><h2 ><a class='secnum' style='min-width:88pt'>7.3</a> Namespaces <a class='abbr_ref'>[basic.namespace]</a></h2><p ><span class='indexparent'><a class='index' id='namespaces'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A namespace is an optionally-named declarative region. The name of a
namespace can be used to access entities declared in that namespace;
that is, the members of the namespace. Unlike other declarative regions,
the definition of a namespace can be split over several parts of one or
more translation units.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The outermost declarative region of a translation unit is a namespace;
see <a href='basic.scope.namespace'>[basic.scope.namespace]</a>.</p></div><div id='namespace.def'><h3 ><a class='secnum' href='#namespace.def' style='min-width:103pt'>7.3.1</a> Namespace definition <a class='abbr_ref' href='namespace.def'>[namespace.def]</a></h3><p ><span class='indexparent'><a class='index' id='definition,namespace'></a></span><span class='indexparent'><a class='index' id='namespace,definition'></a></span></p><div class='para' id='namespace.def-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-1'>1</a></div><p >The grammar for a
<i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i>
is</p><pre class='bnf'><a id='nt:namespace-name'>namespace-name:</a>
        <i ><a href='namespace.def#nt:original-namespace-name'>original-namespace-name</a></i>
        <i ><a href='namespace.alias#nt:namespace-alias'>namespace-alias</a></i></pre><pre class='bnf'><a id='nt:original-namespace-name'>original-namespace-name:</a>
        <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><pre class='bnf'><a id='nt:namespace-definition'>namespace-definition:</a>
        <i ><a href='namespace.def#nt:named-namespace-definition'>named-namespace-definition</a></i>
        <i ><a href='namespace.def#nt:unnamed-namespace-definition'>unnamed-namespace-definition</a></i></pre><pre class='bnf'><a id='nt:named-namespace-definition'>named-namespace-definition:</a>
        <i ><a href='namespace.def#nt:original-namespace-definition'>original-namespace-definition</a></i>
        <i ><a href='namespace.def#nt:extension-namespace-definition'>extension-namespace-definition</a></i></pre><pre class='bnf'><a id='nt:original-namespace-definition'>original-namespace-definition:</a>
        <span class='terminal'>inline<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <span class='terminal'>namespace</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>{</span> <i ><a href='namespace.def#nt:namespace-body'>namespace-body</a></i> <span class='terminal'>}</span></pre><pre class='bnf'><a id='nt:extension-namespace-definition'>extension-namespace-definition:</a>
        <span class='terminal'>inline<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <span class='terminal'>namespace</span> <i ><a href='namespace.def#nt:original-namespace-name'>original-namespace-name</a></i> <span class='terminal'>{</span> <i ><a href='namespace.def#nt:namespace-body'>namespace-body</a></i> <span class='terminal'>}</span></pre><pre class='bnf'><a id='nt:unnamed-namespace-definition'>unnamed-namespace-definition:</a>
        <span class='terminal'>inline<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <span class='terminal'>namespace {</span> <i ><a href='namespace.def#nt:namespace-body'>namespace-body</a></i> <span class='terminal'>}</span></pre><pre class='bnf'><a id='nt:namespace-body'>namespace-body:</a>
        <i ><a href='dcl.dcl#nt:declaration-seq'>declaration-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre></div><div class='para' id='namespace.def-2'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-2'>2</a></div><p >The <i ><a href='lex.name#nt:identifier'>identifier</a></i> in an <i ><a href='namespace.def#nt:original-namespace-definition'>original-namespace-definition</a></i>
shall not have been previously defined in the declarative region in
which the <i ><a href='namespace.def#nt:original-namespace-definition'>original-namespace-definition</a></i> appears. The
<i ><a href='lex.name#nt:identifier'>identifier</a></i> in an <i ><a href='namespace.def#nt:original-namespace-definition'>original-namespace-definition</a></i> is
the name of the namespace. Subsequently in that declarative region, it
is treated as an <i ><a href='namespace.def#nt:original-namespace-name'>original-namespace-name</a></i>.</p></div><div class='para' id='namespace.def-3'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-3'>3</a></div><p >The <i ><a href='namespace.def#nt:original-namespace-name'>original-namespace-name</a></i> in an
<i ><a href='namespace.def#nt:extension-namespace-definition'>extension-namespace-definition</a></i> shall have previously been
defined in an <i ><a href='namespace.def#nt:original-namespace-definition'>original-namespace-definition</a></i> in the same
declarative region.</p></div><div class='para' id='namespace.def-4'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-4'>4</a></div><p >Every <i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i> shall appear in the global scope
or in a namespace scope (<a href='basic.scope.namespace'>[basic.scope.namespace]</a>).</p></div><div class='para' id='namespace.def-5'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-5'>5</a></div><p >Because a <i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i> contains
<i ><a href='dcl.dcl#nt:declaration'>declarations</a></i> in its <i ><a href='namespace.def#nt:namespace-body'>namespace-body</a></i> and a
<i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i> is itself a <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i>, it
follows that <span class='grammarterm'>namespace-definitions</span> can be nested.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace Outer {
  int i;
  namespace Inner {
    void f() { i++; }           <span class='comment'>// <span class='texttt'>Outer::i</span>
</span>    int i;
    void g() { i++; }           <span class='comment'>// <span class='texttt'>Inner::i</span>
</span>  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.def-6'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-6'>6</a></div><p >The <a class='hidden_link' href='#def:enclosing_namespaces' id='def:enclosing_namespaces'><i>enclosing namespaces</i></a> of a declaration are those
namespaces in which the declaration lexically appears, except for a
redeclaration of a namespace member outside its original namespace
(e.g., a definition as specified in <a href='namespace.memdef'>[namespace.memdef]</a>). Such a
redeclaration has the same enclosing namespaces as the original
declaration.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
namespace Q {
  namespace V {
    void f();   <span class='comment'>// enclosing namespaces are the global namespace, <span class='texttt'>Q</span>, and <span class='texttt'>Q::V</span>
</span>    class C { void m(); };
  }
  void V::f() { <span class='comment'>// enclosing namespaces are the global namespace, <span class='texttt'>Q</span>, and <span class='texttt'>Q::V</span>
</span>    extern void h();  <span class='comment'>// ... so this declares <span class='texttt'>Q::V::h</span>
</span>  }
  void V::C::m() { <span class='comment'>// enclosing namespaces are the global namespace, <span class='texttt'>Q</span>, and <span class='texttt'>Q::V</span>
</span>  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.def-7'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-7'>7</a></div><p >If the optional initial <span class='texttt'>inline</span> keyword appears in a
<i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i> for a particular namespace, that namespace is
declared to be an <a class='hidden_link' href='#def:inline_namespace' id='def:inline_namespace'><i>inline namespace</i></a>. The <span class='texttt'>inline</span> keyword may be
used on an <i ><a href='namespace.def#nt:extension-namespace-definition'>extension-namespace-definition</a></i> only if it was
previously used on the <i ><a href='namespace.def#nt:original-namespace-definition'>original-namespace-definition</a></i> for that
namespace.</p></div><div class='para' id='namespace.def-8'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-8'>8</a></div><p >Members of an inline namespace can be used in most respects as though they were members
of the enclosing namespace. Specifically, the inline namespace and its enclosing
namespace are both added to the set of associated namespaces used in
argument-dependent lookup (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>) whenever one of them is,
and a <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> (<a href='namespace.udir'>[namespace.udir]</a>) that names the inline
namespace is implicitly inserted into the enclosing namespace as for an unnamed
namespace (<a href='namespace.unnamed'>[namespace.unnamed]</a>). Furthermore, each
member of the inline namespace can subsequently be explicitly
instantiated (<a href='temp.explicit'>[temp.explicit]</a>) or explicitly specialized (<a href='temp.expl.spec'>[temp.expl.spec]</a>) as
though it were a member of the enclosing namespace. Finally, looking up a name in the
enclosing namespace via explicit qualification (<a href='namespace.qual'>[namespace.qual]</a>) will include
members of the inline namespace brought in by the <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> even if
there are declarations of that name in the enclosing namespace.</p></div><div class='para' id='namespace.def-9'><div class='marginalizedparent'><a class='marginalized' href='#namespace.def-9'>9</a></div><p >These properties are transitive: if a namespace <span class='texttt'>N</span> contains an inline namespace
<span class='texttt'>M</span>, which in turn contains an inline namespace <span class='texttt'>O</span>, then the members of
<span class='texttt'>O</span> can be used as though they were members of <span class='texttt'>M</span> or <span class='texttt'>N</span>.
The <a class='hidden_link' href='#def:inline_namespace_set' id='def:inline_namespace_set'><i>inline namespace set</i></a> of <span class='texttt'>N</span> is the transitive closure of all
inline namespaces in <span class='texttt'>N</span>.
The <a class='hidden_link' href='#def:enclosing_namespace_set' id='def:enclosing_namespace_set'><i>enclosing namespace set</i></a> of <span class='texttt'>O</span> is the set of namespaces
consisting of the innermost non-inline namespace enclosing
an inline namespace <span class='texttt'>O</span>, together with any intervening inline namespaces.</p></div><div id='namespace.unnamed'><h4 ><a class='secnum' href='#namespace.unnamed' style='min-width:118pt'>7.3.1.1</a> Unnamed namespaces <a class='abbr_ref' href='namespace.unnamed'>[namespace.unnamed]</a></h4><p ><span class='indexparent'><a class='index' id='namespace,unnamed'></a></span></p><div class='para' id='namespace.unnamed-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace.unnamed-1'>1</a></div><p >An <i ><a href='namespace.def#nt:unnamed-namespace-definition'>unnamed-namespace-definition</a></i> behaves as if it were
replaced by</p><pre class='bnf'><span class='terminal'>inline</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>namespace</span> <span class='textrm'><i><b>unique</b></i></span>  <span class='terminal'>{ /* empty body */ }</span>
<span class='terminal'>using namespace</span> <span class='textrm'><i><b>unique</b></i></span>  <span class='terminal'>;</span>
<span class='terminal'>namespace</span> <span class='textrm'><i><b>unique</b></i></span>  <span class='terminal'>{</span> <i ><a href='namespace.def#nt:namespace-body'>namespace-body</a></i> <span class='terminal'>}</span></pre><p >where
<span class='texttt'>inline</span> appears if and only if it appears in the
<i ><a href='namespace.def#nt:unnamed-namespace-definition'>unnamed-namespace-definition</a></i>,
all occurrences of <span class='textrm'><i><b>unique</b></i></span>  in a translation unit are replaced by
the same identifier, and this identifier differs from all other
identifiers in the entire program.<a class='footnotenum' href='#footnote-94'>94</a>
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace { int i; }            <span class='comment'>// <span class='textrm'><i><b>unique</b></i></span>  <span class='texttt'>::i</span>
</span>void f() { i++; }               <span class='comment'>// <span class='textrm'><i><b>unique</b></i></span>  <span class='texttt'>::i++</span>
</span>
namespace A {
  namespace {
    int i;                      <span class='comment'>// <span class='texttt'>A::</span> <span class='textrm'><i><b>unique</b></i></span>  <span class='texttt'>::i</span>
</span>    int j;                      <span class='comment'>// <span class='texttt'>A::</span> <span class='textrm'><i><b>unique</b></i></span>  <span class='texttt'>::j</span>
</span>  }
  void g() { i++; }             <span class='comment'>// <span class='texttt'>A::</span> <span class='textrm'><i><b>unique</b></i></span>  <span class='texttt'>::i++</span>
</span>}

using namespace A;
void h() {
  i++;                          <span class='comment'>// error: <span class='textrm'><i><b>unique</b></i></span>  <span class='texttt'>::i</span> or <span class='texttt'>A::</span> <span class='textrm'><i><b>unique</b></i></span>  <span class='texttt'>::i</span>
</span>  A::i++;                       <span class='comment'>// <span class='texttt'>A::</span> <span class='textrm'><i><b>unique</b></i></span>  <span class='texttt'>::i</span>
</span>  j++;                          <span class='comment'>// <span class='texttt'>A::</span> <span class='textrm'><i><b>unique</b></i></span>  <span class='texttt'>::j</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='footnote' id='footnote-94'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-94'>94)</a></div><p >Although entities in an unnamed
namespace might have external linkage,
they are effectively qualified by a name unique to their translation
unit and therefore can never be seen from any other translation unit.</p></div></div><div id='namespace.memdef'><h4 ><a class='secnum' href='#namespace.memdef' style='min-width:118pt'>7.3.1.2</a> Namespace member definitions <a class='abbr_ref' href='namespace.memdef'>[namespace.memdef]</a></h4><p ><span class='indexparent'><a class='index' id='namespace,member_definition'></a></span></p><div class='para' id='namespace.memdef-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace.memdef-1'>1</a></div><p >Members (including explicit specializations of
templates (<a href='temp.expl.spec'>[temp.expl.spec]</a>)) of a namespace can be defined within
that namespace.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace X {
  void f() { <span class='comment'>/* ... */</span> }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.memdef-2'><div class='marginalizedparent'><a class='marginalized' href='#namespace.memdef-2'>2</a></div><p >Members of a named namespace can also be
defined outside that namespace by explicit
qualification (<a href='namespace.qual'>[namespace.qual]</a>) of the name being defined, provided
that the entity being defined was already declared in the namespace and
the definition appears after the point of declaration in a namespace
that encloses the declaration's namespace.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace Q {
  namespace V {
    void f();
  }
  void V::f() { <span class='comment'>/* ... */</span> }     <span class='comment'>// OK
</span>  void V::g() { <span class='comment'>/* ... */</span> }     <span class='comment'>// error: <span class='texttt'>g()</span> is not yet a member of <span class='texttt'>V</span>
</span>  namespace V {
    void g();
  }
}

namespace R {
  void Q::V::g() { <span class='comment'>/* ... */</span> }  <span class='comment'>// error: <span class='texttt'>R</span> doesn't enclose <span class='texttt'>Q</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.memdef-3'><div class='marginalizedparent'><a class='marginalized' href='#namespace.memdef-3'>3</a></div><p >Every name first declared in a namespace is a member of that namespace.
If a <span class='texttt'>friend</span> declaration in a non-local class first declares a
class or function<a class='footnotenum' href='#footnote-95'>95</a>
the friend class or function is a member of the innermost enclosing
namespace. The name of the friend is not found by 
unqualified lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>) or by qualified
lookup (<a href='basic.lookup.qual'>[basic.lookup.qual]</a>)
until a matching declaration is provided in that namespace scope (either
before or after the class definition granting friendship). If a friend
function is called, its name may be found by the name lookup that
considers functions from namespaces and classes associated with the
types of the function arguments (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>). If the name
in a <span class='texttt'>friend</span> declaration is neither qualified nor a
<i ><a href='temp.names#nt:template-id'>template-id</a></i> and the declaration is a function or an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>, the lookup to determine whether
the entity has been previously declared shall not consider any scopes
outside the innermost enclosing namespace. [&nbsp;<i>Note:</i> The other forms of
<span class='texttt'>friend</span> declarations cannot declare a new member of the innermost
enclosing namespace and thus follow the usual lookup rules.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
<span class='comment'>// Assume <span class='texttt'>f</span> and <span class='texttt'>g</span> have not yet been defined.
</span>void h(int);
template &lt;class T&gt; void f2(T);
namespace A {
  class X {
    friend void f(X);           <span class='comment'>// <span class='texttt'>A::f(X)</span> is a friend
</span>    class Y {
      friend void g();          <span class='comment'>// <span class='texttt'>A::g</span> is a friend
</span>      friend void h(int);       <span class='comment'>// <span class='texttt'>A::h</span> is a friend
</span>                                <span class='comment'>// <span class='texttt'>::h</span> not considered
</span>      friend void f2&lt;&gt;(int);    <span class='comment'>// <span class='texttt'>::f2&lt;&gt;(int)</span> is a friend
</span>    };
  };

  <span class='comment'>// <span class='texttt'>A::f</span>, <span class='texttt'>A::g</span> and <span class='texttt'>A::h</span> are not visible here
</span>  X x;
  void g() { f(x); }            <span class='comment'>// definition of <span class='texttt'>A::g</span>
</span>  void f(X) <span class='texttt'>{ /* ... */}</span>       <span class='comment'>// definition of <span class='texttt'>A::f</span>
</span>  void h(int) <span class='texttt'>{ /* ... */ }</span>    <span class='comment'>// definition of <span class='texttt'>A::h</span>
</span>  <span class='comment'>// <span class='texttt'>A::f</span>, <span class='texttt'>A::g</span> and <span class='texttt'>A::h</span> are visible here and known to be friends
</span>}

using A::x;

void h() {
  A::f(x);
  A::X::f(x);                   <span class='comment'>// error: <span class='texttt'>f</span> is not a member of <span class='texttt'>A::X</span>
</span>  A::X::Y::g();                 <span class='comment'>// error: <span class='texttt'>g</span> is not a member of <span class='texttt'>A::X::Y</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='footnote' id='footnote-95'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-95'>95)</a></div><p >this implies that the name of the class or function is unqualified.</p></div></div></div><div id='namespace.alias'><h3 ><a class='secnum' href='#namespace.alias' style='min-width:103pt'>7.3.2</a> Namespace alias <a class='abbr_ref' href='namespace.alias'>[namespace.alias]</a></h3><p ><span class='indexparent'><a class='index' id='namespace,alias'></a></span><span class='indexparent'><a class='index' id='alias,namespace'></a></span><span class='indexparent'><a class='index' id='synonym'></a></span></p><div class='para' id='namespace.alias-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace.alias-1'>1</a></div><p >A <i ><a href='namespace.alias#nt:namespace-alias-definition'>namespace-alias-definition</a></i> declares an alternate name for a
namespace according to the following grammar:</p><pre class='bnf'><a id='nt:namespace-alias'>namespace-alias:</a>
        <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><pre class='bnf'><a id='nt:namespace-alias-definition'>namespace-alias-definition:</a>
        <span class='terminal'>namespace</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>=</span> <i ><a href='namespace.alias#nt:qualified-namespace-specifier'>qualified-namespace-specifier</a></i> <span class='terminal'>;</span></pre><pre class='bnf'><a id='nt:qualified-namespace-specifier'>qualified-namespace-specifier:</a>
    <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i></pre></div><div class='para' id='namespace.alias-2'><div class='marginalizedparent'><a class='marginalized' href='#namespace.alias-2'>2</a></div><p >The <i ><a href='lex.name#nt:identifier'>identifier</a></i> in a <i ><a href='namespace.alias#nt:namespace-alias-definition'>namespace-alias-definition</a></i> is
a synonym for the name of the namespace denoted by the
<i ><a href='namespace.alias#nt:qualified-namespace-specifier'>qualified-namespace-specifier</a></i> and becomes a
<i ><a href='namespace.alias#nt:namespace-alias'>namespace-alias</a></i>.
[&nbsp;<i>Note:</i>
When looking up a <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> in a
<i ><a href='namespace.alias#nt:namespace-alias-definition'>namespace-alias-definition</a></i>, only namespace names are
considered, see <a href='basic.lookup.udir'>[basic.lookup.udir]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='namespace.alias-3'><div class='marginalizedparent'><a class='marginalized' href='#namespace.alias-3'>3</a></div><p >In a declarative region, a <i ><a href='namespace.alias#nt:namespace-alias-definition'>namespace-alias-definition</a></i> can be
used to redefine a <i ><a href='namespace.alias#nt:namespace-alias'>namespace-alias</a></i> declared in that
declarative region to refer only to the namespace to which it already
refers.
[&nbsp;<i>Example:</i>
the following declarations are well-formed:</p><pre class='codeblock'>
namespace Company_with_very_long_name { <span class='comment'>/* ... */</span> }
namespace CWVLN = Company_with_very_long_name;
namespace CWVLN = Company_with_very_long_name;          <span class='comment'>// OK: duplicate
</span>namespace CWVLN = CWVLN;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.alias-4'><div class='marginalizedparent'><a class='marginalized' href='#namespace.alias-4'>4</a></div><p >A <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> or <i ><a href='namespace.alias#nt:namespace-alias'>namespace-alias</a></i> shall not be
declared as the name of any other entity in the same declarative region.
A <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> defined at global scope shall not be
declared as the name of any other entity in any global scope of the
program. No diagnostic is required for a violation of this rule by
declarations in different translation units.</p></div></div><div id='namespace.udecl'><h3 ><a class='secnum' href='#namespace.udecl' style='min-width:103pt'>7.3.3</a> The <span class='texttt'>using</span> declaration <a class='abbr_ref' href='namespace.udecl'>[namespace.udecl]</a></h3><p ><span class='indexparent'><a class='index' id='using-declaration'></a></span></p><div class='para' id='namespace.udecl-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-1'>1</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> introduces a name into the declarative
region in which the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> appears.</p><pre class='bnf'><a id='nt:using-declaration'>using-declaration:</a>
    <span class='terminal'>using typename<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i> <span class='terminal'>;</span>
    <span class='terminal'>using ::</span> <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i> <span class='terminal'>;</span></pre><p >The member name specified in a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> is declared
in the declarative region in which the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>
appears. [&nbsp;<i>Note:</i> Only the specified name is so declared; specifying
an enumeration name in a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> does not declare
its enumerators in the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>'s declarative
region.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> names a constructor (<a href='class.qual'>[class.qual]</a>), it
implicitly declares a set of constructors in the class in which the
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> appears (<a href='class.inhctor'>[class.inhctor]</a>); otherwise the
name specified in a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> is a synonym for the name of
some entity declared elsewhere.</p></div><div class='para' id='namespace.udecl-2'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-2'>2</a></div><p >Every <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> is a <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> and a
<i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i> and so can be used in a class definition.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct B {
  void f(char);
  void g(char);
  enum E { e };
  union { int x; };
};

struct D : B {
  using B::f;
  void f(int) { f('c'); }       <span class='comment'>// calls <span class='texttt'>B::f(char)</span>
</span>  void g(int) { g('c'); }       <span class='comment'>// recursively calls <span class='texttt'>D::g(int)</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-3'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-3'>3</a></div><p >In a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> used as a
<i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>, the <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i>
shall name a base class of the class being defined. If such a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> names a constructor, the
<i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> shall name a direct base class of the class
being defined; otherwise it introduces the set of declarations found by
member name lookup (<a href='class.member.lookup'>[class.member.lookup]</a>, <a href='class.qual'>[class.qual]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class C {
  int g();
};

class D2 : public B {
  using B::f;                   <span class='comment'>// OK: <span class='texttt'>B</span> is a base of <span class='texttt'>D2</span>
</span>  using B::e;                   <span class='comment'>// OK: <span class='texttt'>e</span> is an enumerator of base <span class='texttt'>B</span>
</span>  using B::x;                   <span class='comment'>// OK: <span class='texttt'>x</span> is a union member of base <span class='texttt'>B</span>
</span>  using C::g;                   <span class='comment'>// error: <span class='texttt'>C</span> isn't a base of <span class='texttt'>D2</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-4'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-4'>4</a></div><p >[&nbsp;<i>Note:</i>
Since destructors do not have names, a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> cannot refer to a
destructor for a base class. Since specializations of member templates
for conversion functions are not found by name lookup, they are not
considered when a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> specifies a conversion
function (<a href='temp.mem'>[temp.mem]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If an assignment operator brought from a base class into a derived class
scope has the signature of a copy/move assignment
operator for the derived
class (<a href='class.copy'>[class.copy]</a>), the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> does not by
itself suppress the implicit declaration of the derived class
assignment operator; the copy/move assignment
operator from the base
class is hidden or overridden by the implicitly-declared
copy/move assignment
operator of the derived class, as described below.</p></div><div class='para' id='namespace.udecl-5'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-5'>5</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> shall not name a <i ><a href='temp.names#nt:template-id'>template-id</a></i>.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct A {
  template &lt;class T&gt; void f(T);
  template &lt;class T&gt; struct X { };
};
struct B : A {
  using A::f&lt;double&gt;;           <span class='comment'>// ill-formed
</span>  using A::X&lt;int&gt;;              <span class='comment'>// ill-formed
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-6'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-6'>6</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> shall not name a namespace.</p></div><div class='para' id='namespace.udecl-7'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-7'>7</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> shall not name a scoped enumerator.</p></div><div class='para' id='namespace.udecl-8'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-8'>8</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> for a class member shall be a
<i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct X {
  int i;
  static int s;
};

void f() {
  using X::i;       <span class='comment'>// error: <span class='texttt'>X::i</span> is a class member
</span>                    <span class='comment'>// and this is not a member declaration.
</span>  using X::s;       <span class='comment'>// error: <span class='texttt'>X::s</span> is a class member
</span>                    <span class='comment'>// and this is not a member declaration.
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-9'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-9'>9</a></div><p >Members declared by a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> can be referred to by
explicit qualification just like other member
names (<a href='namespace.qual'>[namespace.qual]</a>). In a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>, a
prefix <span class='texttt'>::</span> refers to the global namespace.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
void f();

namespace A {
  void g();
}

namespace X {
  using ::f;        <span class='comment'>// global <span class='texttt'>f</span>
</span>  using A::g;       <span class='comment'>// <span class='texttt'>A</span>'s <span class='texttt'>g</span>
</span>}

void h(){
  X::f();           <span class='comment'>// calls <span class='texttt'>::f</span>
</span>  X::g();           <span class='comment'>// calls <span class='texttt'>A::g</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-10'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-10'>10</a></div><p >A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> is a <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> and can
therefore be used repeatedly where (and only where) multiple
declarations are allowed.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace A {
  int i;
}

namespace A1 {
  using A::i;
  using A::i;       <span class='comment'>// OK: double declaration
</span>}

void f() {
  using A::i;
  using A::i;       <span class='comment'>// error: double declaration
</span>}

struct B {
  int i;
};

struct X : B {
  using B::i;
  using B::i;       <span class='comment'>// error: double member declaration
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-11'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-11'>11</a></div><p >The entity declared by a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> shall be known in
the context using it according to its definition at the point of the
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>. Definitions added to the namespace after
the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> are not considered when a use of the
name is made.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace A {
  void f(int);
}

using A::f;         <span class='comment'>// <span class='texttt'>f</span> is a synonym for <span class='texttt'>A::f</span>;
</span>                    <span class='comment'>// that is, for <span class='texttt'>A::f(int)</span>.
</span>namespace A {
  void f(char);
}

void foo() {
  f('a');           <span class='comment'>// calls <span class='texttt'>f(int)</span>,
</span>}                   <span class='comment'>// even though <span class='texttt'>f(char)</span> exists.
</span>
void bar() {
  using A::f;       <span class='comment'>// <span class='texttt'>f</span> is a synonym for <span class='texttt'>A::f</span>;
</span>                    <span class='comment'>// that is, for <span class='texttt'>A::f(int)</span> and <span class='texttt'>A::f(char)</span>.
</span>  f('a');           <span class='comment'>// calls <span class='texttt'>f(char)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-12'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-12'>12</a></div><p >[&nbsp;<i>Note:</i>
Partial specializations of class templates are found by looking up the
primary class template and then considering all partial specializations
of that template. If a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> names a class
template, partial specializations introduced after the
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> are effectively visible because the primary
template is visible (<a href='temp.class.spec'>[temp.class.spec]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-13'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-13'>13</a></div><p >Since a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> is a declaration, the restrictions
on declarations of the same name in the same declarative
region (<a href='basic.scope'>[basic.scope]</a>) also apply to <i ><a href='namespace.udecl#nt:using-declaration'>using-declarations</a></i>.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace A {
  int x;
}

namespace B {
  int i;
  struct g { };
  struct x { };
  void f(int);
  void f(double);
  void g(char);     <span class='comment'>// OK: hides <span class='texttt'>struct g</span>
</span>}

void func() {
  int i;
  using B::i;       <span class='comment'>// error: <span class='texttt'>i</span> declared twice
</span>  void f(char);
  using B::f;       <span class='comment'>// OK: each <span class='texttt'>f</span> is a function
</span>  f(3.5);           <span class='comment'>// calls <span class='texttt'>B::f(double)</span>
</span>  using B::g;
  g('a');           <span class='comment'>// calls <span class='texttt'>B::g(char)</span>
</span>  struct g g1;      <span class='comment'>// <span class='texttt'>g1</span> has class type <span class='texttt'>B::g</span>
</span>  using B::x;
  using A::x;       <span class='comment'>// OK: hides <span class='texttt'>struct B::x</span>
</span>  x = 99;           <span class='comment'>// assigns to <span class='texttt'>A::x</span>
</span>  struct x x1;      <span class='comment'>// <span class='texttt'>x1</span> has class type <span class='texttt'>B::x</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-14'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-14'>14</a></div><p >If a function declaration in namespace scope or block scope has the same
name and the same parameter types as a function introduced by a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>, and the declarations do not declare the
same function, the program is ill-formed.
[&nbsp;<i>Note:</i>
Two <i ><a href='namespace.udecl#nt:using-declaration'>using-declarations</a></i> may introduce functions with the same
name and the same parameter types. If, for a call to an unqualified
function name, function overload resolution selects the functions
introduced by such <i ><a href='namespace.udecl#nt:using-declaration'>using-declarations</a></i>, the function call is
ill-formed.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace B {
  void f(int);
  void f(double);
}
namespace C {
  void f(int);
  void f(double);
  void f(char);
}

void h() {
  using B::f;       <span class='comment'>// <span class='texttt'>B::f(int)</span> and <span class='texttt'>B::f(double)</span>
</span>  using C::f;       <span class='comment'>// <span class='texttt'>C::f(int)</span>, <span class='texttt'>C::f(double)</span>, and <span class='texttt'>C::f(char)</span>
</span>  f('h');           <span class='comment'>// calls <span class='texttt'>C::f(char)</span>
</span>  f(1);             <span class='comment'>// error: ambiguous: <span class='texttt'>B::f(int)</span> or <span class='texttt'>C::f(int)</span>?
</span>  void f(int);      <span class='comment'>// error: <span class='texttt'>f(int)</span> conflicts with <span class='texttt'>C::f(int)</span> and <span class='texttt'>B::f(int)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-15'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-15'>15</a></div><p ><span class='indexparent'><a class='index' id='name_hiding,using-declaration_and'></a></span>When a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> brings names from a base class into
a derived class scope, member functions and member function templates in
the derived class override and/or hide member functions and member
function templates with the same name,
parameter-type-list (<a href='dcl.fct'>[dcl.fct]</a>), cv-qualification, and <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> (if any) in a base
class (rather than conflicting).
[&nbsp;<i>Note:</i> For <span class='grammarterm'>using-declarations</span> that name a constructor, see <a href='class.inhctor'>[class.inhctor]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct B {
  virtual void f(int);
  virtual void f(char);
  void g(int);
  void h(int);
};

struct D : B {
  using B::f;
  void f(int);      <span class='comment'>// OK: <span class='texttt'>D::f(int)</span> overrides <span class='texttt'>B::f(int)</span>;
</span>
  using B::g;
  void g(char);     <span class='comment'>// OK
</span>
  using B::h;
  void h(int);      <span class='comment'>// OK: <span class='texttt'>D::h(int)</span> hides <span class='texttt'>B::h(int)</span>
</span>};

void k(D* p){
  p-&gt;f(1);          <span class='comment'>// calls <span class='texttt'>D::f(int)</span>
</span>  p-&gt;f('a');        <span class='comment'>// calls <span class='texttt'>B::f(char)</span>
</span>  p-&gt;g(1);          <span class='comment'>// calls <span class='texttt'>B::g(int)</span>
</span>  p-&gt;g('a');        <span class='comment'>// calls <span class='texttt'>D::g(char)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-16'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-16'>16</a></div><p ><span class='indexparent'><a class='index' id='overloading,using-declaration_and'></a></span>For the purpose of overload resolution, the functions which are
introduced by a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> into a derived class will
be treated as though they were members of the derived class. In
particular, the implicit <span class='texttt'>this</span> parameter shall be treated as if
it were a pointer to the derived class rather than to the base class.
This has no effect on the type of the function, and in all other
respects the function remains a member of the base class.</p></div><div class='para' id='namespace.udecl-17'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-17'>17</a></div><p ><span class='indexparent'><a class='index' id='access_control,using-declaration_and'></a></span>The access rules for inheriting constructors are specified
in <a href='class.inhctor'>[class.inhctor]</a>; otherwise all instances of the name mentioned in a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>
shall be accessible. In particular, if a derived class uses a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> to access a member of a base class, the
member name shall be accessible. If the name is that of an overloaded
member function, then all functions named shall be accessible. The base
class members mentioned by a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> shall be
visible in the scope of at least one of the direct base classes of the
class where the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> is specified. [&nbsp;<i>Note:</i>
Because a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> designates a base class member
(and not a member subobject or a member function of a base class
subobject), a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> cannot be used to resolve
inherited member ambiguities. For example,</p><pre class='codeblock'>
struct A { int x(); };
struct B : A { };
struct C : A {
  using A::x;
  int x(int);
};

struct D : B, C {
  using C::x;
  int x(double);
};
int f(D* d) {
  return d-&gt;x();    <span class='comment'>// ambiguous: <span class='texttt'>B::x</span> or <span class='texttt'>C::x</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-18'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-18'>18</a></div><p >The alias created by the <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> has the usual
accessibility for a <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>.
[&nbsp;<i>Note:</i> A <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> that names a constructor does not
create aliases; see <a href='class.inhctor'>[class.inhctor]</a> for the pertinent accessibility rules.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class A {
private:
    void f(char);
public:
    void f(int);
protected:
    void g();
};

class B : public A {
  using A::f;       <span class='comment'>// error: <span class='texttt'>A::f(char)</span> is inaccessible
</span>public:
  using A::g;       <span class='comment'>// <span class='texttt'>B::g</span> is a public synonym for <span class='texttt'>A::g</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udecl-19'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udecl-19'>19</a></div><p >If a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> uses the keyword <span class='texttt'>typename</span> and
specifies a dependent name (<a href='temp.dep'>[temp.dep]</a>), the name introduced by the
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> is treated as a
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> (<a href='dcl.typedef'>[dcl.typedef]</a>).<span class='indexparent'><a class='index' id='using-declaration'></a></span></p></div></div><div id='namespace.udir'><h3 ><a class='secnum' href='#namespace.udir' style='min-width:103pt'>7.3.4</a> Using directive <a class='abbr_ref' href='namespace.udir'>[namespace.udir]</a></h3><p ><span class='indexparent'><a class='index' id='using-directive'></a></span></p><pre class='bnf'><a id='nt:using-directive'>using-directive:</a>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>using  namespace</span> <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> <span class='terminal'>;</span></pre><div class='para' id='namespace.udir-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udir-1'>1</a></div><p >A <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> shall not appear in class scope, but may
appear in namespace scope or in block scope.
[&nbsp;<i>Note:</i>
When looking up a <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> in a
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i>, only namespace names are considered,
see <a href='basic.lookup.udir'>[basic.lookup.udir]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> appertains to the <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i>.</p></div><div class='para' id='namespace.udir-2'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udir-2'>2</a></div><p >A <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> specifies that the names in the nominated
namespace can be used in the scope in which the
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> appears after the <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i>.
During unqualified name lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>), the names
appear as if they were declared in the nearest enclosing namespace which
contains both the <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> and the nominated
namespace.
[&nbsp;<i>Note:</i>
In this context, “contains” means “contains directly or indirectly”.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='namespace.udir-3'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udir-3'>3</a></div><p >A <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> does not add any members to the declarative
region in which it appears.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace A {
  int i;
  namespace B {
    namespace C {
      int i;
    }
    using namespace A::B::C;
    void f1() {
      i = 5;        <span class='comment'>// OK, <span class='texttt'>C::i</span> visible in <span class='texttt'>B</span> and hides <span class='texttt'>A::i</span>
</span>    }
  }
  namespace D {
    using namespace B;
    using namespace C;
    void f2() {
      i = 5;        <span class='comment'>// ambiguous, <span class='texttt'>B::C::i</span> or <span class='texttt'>A::i</span>?
</span>    }
  }
  void f3() {
    i = 5;          <span class='comment'>// uses <span class='texttt'>A::i</span>
</span>  }
}
void f4() {
  i = 5;            <span class='comment'>// ill-formed; neither <span class='texttt'>i</span> is visible
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udir-4'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udir-4'>4</a></div><p >For unqualified lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>), the
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> is transitive: if a scope contains a
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> that nominates a second namespace that itself
contains <i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i>, the effect is as if the
<i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> from the second namespace also appeared in
the first.
[&nbsp;<i>Note:</i> For qualified lookup, see <a href='namespace.qual'>[namespace.qual]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace M {
  int i;
}

namespace N {
  int i;
  using namespace M;
}

void f() {
  using namespace N;
  i = 7;            <span class='comment'>// error: both <span class='texttt'>M::i</span> and <span class='texttt'>N::i</span> are visible
</span>}
</pre><p >For another example,</p><pre class='codeblock'>
namespace A {
  int i;
}
namespace B {
  int i;
  int j;
  namespace C {
    namespace D {
      using namespace A;
      int j;
      int k;
      int a = i;    <span class='comment'>// <span class='texttt'>B::i</span> hides <span class='texttt'>A::i</span>
</span>    }
    using namespace D;
    int k = 89;     <span class='comment'>// no problem yet
</span>    int l = k;      <span class='comment'>// ambiguous: <span class='texttt'>C::k</span> or <span class='texttt'>D::k</span>
</span>    int m = i;      <span class='comment'>// <span class='texttt'>B::i</span> hides <span class='texttt'>A::i</span>
</span>    int n = j;      <span class='comment'>// <span class='texttt'>D::j</span> hides <span class='texttt'>B::j</span>
</span>  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.udir-5'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udir-5'>5</a></div><p >If a namespace is extended by an
<i ><a href='namespace.def#nt:extension-namespace-definition'>extension-namespace-definition</a></i> after a
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> for that namespace is given, the additional
members of the extended namespace and the members of namespaces
nominated by <i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> in the
<i ><a href='namespace.def#nt:extension-namespace-definition'>extension-namespace-definition</a></i> can be used after the
<i ><a href='namespace.def#nt:extension-namespace-definition'>extension-namespace-definition</a></i>.</p></div><div class='para' id='namespace.udir-6'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udir-6'>6</a></div><p >If name lookup finds a declaration for a name in two different
namespaces, and the declarations do not declare the same entity and do
not declare functions, the use of the name is ill-formed.
[&nbsp;<i>Note:</i>
In particular, the name of a variable, function or enumerator does not
hide the name of a class or enumeration declared in a different
namespace. For example,</p><pre class='codeblock'>
namespace A {
  class X { };
  extern "C"   int g();
  extern "C++" int h();
}
namespace B {
  void X(int);
  extern "C"   int g();
  extern "C++" int h(int);
}
using namespace A;
using namespace B;

void f() {
  X(1);             <span class='comment'>// error: name <span class='texttt'>X</span> found in two namespaces
</span>  g();              <span class='comment'>// okay: name <span class='texttt'>g</span> refers to the same entity
</span>  h();              <span class='comment'>// okay: overload resolution selects <span class='texttt'>A::h</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='namespace.udir-7'><div class='marginalizedparent'><a class='marginalized' href='#namespace.udir-7'>7</a></div><p ><span class='indexparent'><a class='index' id='overloading,using_directive_and'></a></span>During overload resolution, all functions from the transitive search are
considered for argument matching. The set of declarations found by the
transitive search is unordered.
[&nbsp;<i>Note:</i>
In particular, the order in which namespaces were considered and the
relationships among the namespaces implied by the
<i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> do not cause preference to be given to any
of the declarations found by the search.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
An ambiguity exists if the best match finds two functions with the same
signature, even if one is in a namespace reachable through
<i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> in the namespace of the other.<a class='footnotenum' href='#footnote-96'>96</a>
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace D {
  int d1;
  void f(char);
}
using namespace D;

int d1;             <span class='comment'>// OK: no conflict with <span class='texttt'>D::d1</span>
</span>
namespace E {
  int e;
  void f(int);
}

namespace D {       <span class='comment'>// namespace extension
</span>  int d2;
  using namespace E;
  void f(int);
}

void f() {
  d1++;             <span class='comment'>// error: ambiguous <span class='texttt'>::d1</span> or <span class='texttt'>D::d1</span>?
</span>  ::d1++;           <span class='comment'>// OK
</span>  D::d1++;          <span class='comment'>// OK
</span>  d2++;             <span class='comment'>// OK: <span class='texttt'>D::d2</span>
</span>  e++;              <span class='comment'>// OK: <span class='texttt'>E::e</span>
</span>  f(1);             <span class='comment'>// error: ambiguous: <span class='texttt'>D::f(int)</span> or <span class='texttt'>E::f(int)</span>?
</span>  f('a');           <span class='comment'>// OK: <span class='texttt'>D::f(char)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='using-directive'></a></span><span class='indexparent'><a class='index' id='namespaces'></a></span></p></div><div class='footnote' id='footnote-96'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-96'>96)</a></div><p >During
name lookup in a class hierarchy, some ambiguities may be
resolved by considering whether one member hides the other along some
paths (<a href='class.member.lookup'>[class.member.lookup]</a>). There is no such disambiguation when
considering the set of names found as a result of following
<i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i>.</p></div></div></div></div></body></html>