<!DOCTYPE html><html lang='en'><head><title>[atomics.types.operations]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>29</a> Atomic operations library <a class='abbr_ref' href='./#atomics'>[atomics]</a></h1><div id='atomics.types.operations'><h2 ><a class='secnum' style='min-width:88pt'>29.6</a> Operations on atomic types <a class='abbr_ref'>[atomics.types.operations]</a></h2><div id='general'><h3 ><a class='secnum' href='#general' style='min-width:103pt'>29.6.1</a> General operations on atomic types <a class='abbr_ref' href='atomics.types.operations.general'>[atomics.types.operations.general]</a></h3><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p >The implementation shall provide the functions and function templates identified as “general operations
on atomic types” in <a href='atomics.syn'>[atomics.syn]</a>.</p></div><div class='para' id='general-2'><div class='marginalizedparent'><a class='marginalized' href='#general-2'>2</a></div><p >In the declarations of these functions and function templates, the name
<i>atomic-type</i> refers to either <span class='texttt'>atomic&lt;T&gt;</span> or to a named base class for <span class='texttt'>T</span>
from Table <a href='atomics.types.generic#tab:atomics.integral'>[tab:atomics.integral]</a> or inferred from Table <a href='atomics.types.generic#tab:atomics.typedefs'>[tab:atomics.typedefs]</a>.</p></div></div><div id='templ'><h3 ><a class='secnum' href='#templ' style='min-width:103pt'>29.6.2</a> Templated operations on atomic types <a class='abbr_ref' href='atomics.types.operations.templ'>[atomics.types.operations.templ]</a></h3><div class='para' id='templ-1'><div class='marginalizedparent'><a class='marginalized' href='#templ-1'>1</a></div><p >The implementation shall declare but not define the
function templates identified as “templated operations on atomic types” in <a href='atomics.syn'>[atomics.syn]</a>.</p></div></div><div id='arith'><h3 ><a class='secnum' href='#arith' style='min-width:103pt'>29.6.3</a> Arithmetic operations on atomic types <a class='abbr_ref' href='atomics.types.operations.arith'>[atomics.types.operations.arith]</a></h3><div class='para' id='arith-1'><div class='marginalizedparent'><a class='marginalized' href='#arith-1'>1</a></div><p >The implementation shall provide the functions and function template specializations identified as “arithmetic operations
on atomic types” in <a href='atomics.syn'>[atomics.syn]</a>.</p></div><div class='para' id='arith-2'><div class='marginalizedparent'><a class='marginalized' href='#arith-2'>2</a></div><p >In the declarations of these functions and function template specializations, the name <i>integral</i> refers to an
integral type and the name <i>atomic-integral</i> refers to either
<span class='texttt'>atomic&lt;<i>integral</i>&gt;</span> or to a named base class for <span class='texttt'><i>integral</i></span> from
Table <a href='atomics.types.generic#tab:atomics.integral'>[tab:atomics.integral]</a> or inferred from Table <a href='atomics.types.generic#tab:atomics.typedefs'>[tab:atomics.typedefs]</a>.</p></div></div><div id='pointer'><h3 ><a class='secnum' href='#pointer' style='min-width:103pt'>29.6.4</a> Operations on atomic pointer types <a class='abbr_ref' href='atomics.types.operations.pointer'>[atomics.types.operations.pointer]</a></h3><div class='para' id='pointer-1'><div class='marginalizedparent'><a class='marginalized' href='#pointer-1'>1</a></div><p >The implementation shall provide the function template specializations
identified as “partial specializations for pointers” in <a href='atomics.syn'>[atomics.syn]</a>.</p></div></div><div id='req'><h3 ><a class='secnum' href='#req' style='min-width:103pt'>29.6.5</a> Requirements for operations on atomic types <a class='abbr_ref' href='atomics.types.operations.req'>[atomics.types.operations.req]</a></h3><div class='para' id='req-1'><div class='marginalizedparent'><a class='marginalized' href='#req-1'>1</a></div><p >There are only a few kinds of operations on atomic types, though there are many
instances on those kinds. This section specifies each general kind. The specific
instances are defined in 
<a href='atomics.types.generic'>[atomics.types.generic]</a>, <a href='atomics.types.operations.general'>[atomics.types.operations.general]</a>,
<a href='atomics.types.operations.arith'>[atomics.types.operations.arith]</a>, and <a href='atomics.types.operations.pointer'>[atomics.types.operations.pointer]</a>.</p></div><div class='para' id='req-2'><div class='marginalizedparent'><a class='marginalized' href='#req-2'>2</a></div><p >In the following operation definitions:</p><ul ><li ><p >an <i>A</i> refers to one of the atomic types.
</p></li><li ><p >a <i>C</i> refers to its corresponding non-atomic type. The
<span class='texttt'>atomic_address</span> atomic type corresponds to the <span class='texttt'>void*</span> non-atomic type.
</p></li><li ><p >an <i>M</i> refers to type of the other argument for arithmetic operations. For
integral atomic types, <i>M</i> is <i>C</i>. For atomic address types, <i>M</i> is
<span class='texttt'>std::ptrdiff_t</span>.
</p></li><li ><p >the free functions not ending in <span class='texttt'>_explicit</span> have the semantics of their
corresponding <span class='texttt'>_explicit</span> with <span class='texttt'>memory_order</span> arguments of
<span class='texttt'>memory_order_seq_cst</span>.
</p></li></ul></div><div class='para' id='req-3'><div class='marginalizedparent'><a class='marginalized' href='#req-3'>3</a></div><p >[&nbsp;<i>Note:</i> Many operations are volatile-qualified. The “volatile as device register”
semantics have not changed in the standard. This qualification means that volatility is
preserved when applying these operations to volatile objects. It does not mean that
operations on non-volatile objects become volatile. Thus, volatile qualified operations
on non-volatile objects may be merged under some conditions. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='atomic_type,constructor'></a></span><code class='itemdecl'>
<i>A</i>::<i>A</i>() noexcept = default;
</code></p></div><div class='itemdescr'></div><div class='para' id='req-4'><div class='marginalizedparent'><a class='marginalized' href='#req-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
leaves the atomic object in an uninitialized state.
[&nbsp;<i>Note:</i>
These semantics ensure compatibility with C.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_type,constructor'></a></span><code class='itemdecl'>
constexpr <i>A</i>::<i>A</i>(<i>C</i> desired) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='req-5'><div class='marginalizedparent'><a class='marginalized' href='#req-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the object with the value <span class='texttt'>desired</span>.
Initialization is not an atomic operation (<a href='intro.multithread'>[intro.multithread]</a>).
[&nbsp;<i>Note:</i> it is possible to have an access to an atomic object <span class='texttt'>A</span>
race with its construction, for example by communicating the address of the
just-constructed object <span class='texttt'>A</span> to another thread via
<span class='texttt'>memory_order_relaxed</span> operations on a suitable atomic pointer
variable, and then immediately accessing <span class='texttt'>A</span> in the receiving thread.
This results in undefined behavior. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><code class='itemdecl'>
#define ATOMIC_VAR_INIT(value) <i><span class='texttt'>see below</span></i>
</code></p><div class='itemdescr'></div><div class='para' id='req-6'><div class='marginalizedparent'><a class='marginalized' href='#req-6'>6</a></div><div class='itemdescr'><p >The macro expands to a token sequence suitable for
constant initialization of
an atomic variable of static storage duration of a type that is
initialization-compatible with <i>value</i>.
[&nbsp;<i>Note:</i> This operation may need to initialize locks. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
Concurrent access to the variable being initialized, even via an atomic operation,
constitutes a data race. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
atomic&lt;int&gt; v = ATOMIC_VAR_INIT(5);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_type,atomic_is_lock_free'></a></span><span class='indexparent'><a class='index' id='atomic_is_lock_free,atomic_type'></a></span><code class='itemdecl'>
bool atomic_is_lock_free(const volatile <i>A</i> *object) noexcept;
bool atomic_is_lock_free(const <i>A</i> *object) noexcept;
bool <i>A</i>::is_lock_free() const volatile noexcept;
bool <i>A</i>::is_lock_free() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='req-7'><div class='marginalizedparent'><a class='marginalized' href='#req-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> True if the object's operations are lock-free, false otherwise.
</p></div></div><p ><code class='itemdecl'>
void atomic_init(volatile <i>A</i> *object, <i>C</i> desired) noexcept;
void atomic_init(<i>A</i> *object, <i>C</i> desired) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='req-8'><div class='marginalizedparent'><a class='marginalized' href='#req-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Non-atomically
initializes <span class='texttt'>*object</span> with value <span class='texttt'>desired</span>. This function shall only be applied
to objects that have been default constructed, and then only once.
[&nbsp;<i>Note:</i>
These semantics ensure compatibility with C.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i> 
Concurrent access from another thread, even via an atomic operation, constitutes
a data race.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_type,atomic_store'></a></span><span class='indexparent'><a class='index' id='atomic_store,atomic_type'></a></span><span class='indexparent'><a class='index' id='atomic_type,atomic_store_explicit'></a></span><span class='indexparent'><a class='index' id='atomic_store_explicit,atomic_type'></a></span><span class='indexparent'><a class='index' id='atomic_type,store'></a></span><span class='indexparent'><a class='index' id='store,atomic_type'></a></span><code class='itemdecl'>
void atomic_store(volatile <i>A</i>* object, <i>C</i> desired) noexcept;
void atomic_store(<i>A</i>* object, <i>C</i> desired) noexcept;
void atomic_store_explicit(volatile <i>A</i> *object, <i>C</i> desired, memory_order order) noexcept;
void atomic_store_explicit(<i>A</i>* object, <i>C</i> desired, memory_order order) noexcept;
void <i>A</i>::store(<i>C</i> desired, memory_order order = memory_order_seq_cst) volatile noexcept;
void <i>A</i>::store(<i>C</i> desired, memory_order order = memory_order_seq_cst) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='req-9'><div class='marginalizedparent'><a class='marginalized' href='#req-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> The <span class='texttt'>order</span> argument shall not be <span class='texttt'>memory_order_consume</span>,
<span class='texttt'>memory_order_acquire</span>, nor <span class='texttt'>memory_order_acq_rel</span>.</p></div></div><div class='para' id='req-10'><div class='marginalizedparent'><a class='marginalized' href='#req-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Atomically replaces the value pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span>
with the value of <span class='texttt'>desired</span>. Memory is affected according to the value of
<span class='texttt'>order</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_type,operator='></a></span><span class='indexparent'><a class='index' id='operator=,atomic_type'></a></span><code class='itemdecl'>
<i>C</i> <i>A</i>::operator=(<i>C</i> desired) volatile noexcept;
<i>C</i> <i>A</i>::operator=(<i>C</i> desired) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='req-11'><div class='marginalizedparent'><a class='marginalized' href='#req-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>store(desired)</span></p></div></div><div class='para' id='req-12'><div class='marginalizedparent'><a class='marginalized' href='#req-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>desired</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_type,atomic_load'></a></span><span class='indexparent'><a class='index' id='atomic_load,atomic_type'></a></span><span class='indexparent'><a class='index' id='atomic_type,atomic_load_explicit'></a></span><span class='indexparent'><a class='index' id='atomic_load_explicit,atomic_type'></a></span><span class='indexparent'><a class='index' id='atomic_type,load'></a></span><span class='indexparent'><a class='index' id='load,atomic_type'></a></span><code class='itemdecl'>
<i>C</i> atomic_load(const volatile <i>A</i>* object) noexcept;
<i>C</i> atomic_load(const <i>A</i>* object) noexcept;
<i>C</i> atomic_load_explicit(const volatile <i>A</i>* object, memory_order) noexcept;
<i>C</i> atomic_load_explicit(const <i>A</i>* object, memory_order) noexcept;
<i>C</i> <i>A</i>::load(memory_order order = memory_order_seq_cst) const volatile noexcept;
<i>C</i> <i>A</i>::load(memory_order order = memory_order_seq_cst) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='req-13'><div class='marginalizedparent'><a class='marginalized' href='#req-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i> The <span class='texttt'>order</span> argument shall not be <span class='texttt'>memory_order_release</span> nor <span class='texttt'>memory_order_acq_rel</span>.</p></div></div><div class='para' id='req-14'><div class='marginalizedparent'><a class='marginalized' href='#req-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> Memory is affected according to the value of <span class='texttt'>order</span>.</p></div></div><div class='para' id='req-15'><div class='marginalizedparent'><a class='marginalized' href='#req-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i> Atomically returns the value pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_type,operator_C'></a></span><span class='indexparent'><a class='index' id='operator_C,atomic_type'></a></span><code class='itemdecl'>
<i>A</i>::operator <i>C</i>() const volatile noexcept;
<i>A</i>::operator <i>C</i>() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='req-16'><div class='marginalizedparent'><a class='marginalized' href='#req-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>load()</span></p></div></div><div class='para' id='req-17'><div class='marginalizedparent'><a class='marginalized' href='#req-17'>17</a></div><div class='itemdescr'><p ><i>Returns:</i> The result of <span class='texttt'>load()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_type,atomic_exchange'></a></span><span class='indexparent'><a class='index' id='atomic_exchange,atomic_type'></a></span><span class='indexparent'><a class='index' id='atomic_type,atomic_exchange_explicit'></a></span><span class='indexparent'><a class='index' id='atomic_exchange_explicit,atomic_type'></a></span><span class='indexparent'><a class='index' id='atomic_type,exchange'></a></span><span class='indexparent'><a class='index' id='exchange,atomic_type'></a></span><code class='itemdecl'>
<i>C</i> atomic_exchange(volatile <i>A</i>* object, <i>C</i> desired) noexcept;
<i>C</i> atomic_exchange(<i>A</i>* object, <i>C</i> desired) noexcept;
<i>C</i> atomic_exchange_explicit(volatile <i>A</i>* object, <i>C</i> desired, memory_order) noexcept;
<i>C</i> atomic_exchange_explicit(<i>A</i>* object, <i>C</i> desired, memory_order) noexcept;
<i>C</i> <i>A</i>::exchange(<i>C</i> desired, memory_order order = memory_order_seq_cst) volatile noexcept;
<i>C</i> <i>A</i>::exchange(<i>C</i> desired, memory_order order = memory_order_seq_cst) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='req-18'><div class='marginalizedparent'><a class='marginalized' href='#req-18'>18</a></div><div class='itemdescr'><p ><i>Effects:</i> Atomically replaces the value pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span>
with <span class='texttt'>desired</span>.
Memory is affected according to the value of <span class='texttt'>order</span>.
These operations are atomic read-modify-write operations (<a href='intro.multithread'>[intro.multithread]</a>).</p></div></div><div class='para' id='req-19'><div class='marginalizedparent'><a class='marginalized' href='#req-19'>19</a></div><div class='itemdescr'><p ><i>Returns:</i> Atomically returns the value pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span> immediately before the effects.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_type,atomic_compare_exchange_weak'></a></span><span class='indexparent'><a class='index' id='atomic_compare_exchange_weak,atomic_type'></a></span><span class='indexparent'><a class='index' id='atomic_type,atomic_compare_exchange_strong'></a></span><span class='indexparent'><a class='index' id='atomic_compare_exchange_strong,atomic_type'></a></span><span class='indexparent'><a class='index' id='atomic_type,atomic_compare_exchange_weak_explicit'></a></span><span class='indexparent'><a class='index' id='atomic_compare_exchange_weak_explicit,atomic_type'></a></span><span class='indexparent'><a class='index' id='atomic_type,atomic_compare_exchange_strong_explicit'></a></span><span class='indexparent'><a class='index' id='atomic_compare_exchange_strong_explicit,atomic_type'></a></span><span class='indexparent'><a class='index' id='atomic_type,compare_exchange_weak'></a></span><span class='indexparent'><a class='index' id='compare_exchange_weak,atomic_type'></a></span><span class='indexparent'><a class='index' id='atomic_type,compare_exchange_strong'></a></span><span class='indexparent'><a class='index' id='compare_exchange_strong,atomic_type'></a></span><span class='indexparent'><a class='index' id='atomic_type,compare_exchange_weak_explicit'></a></span><span class='indexparent'><a class='index' id='compare_exchange_weak_explicit,atomic_type'></a></span><span class='indexparent'><a class='index' id='atomic_type,compare_exchange_strong_explicit'></a></span><span class='indexparent'><a class='index' id='compare_exchange_strong_explicit,atomic_type'></a></span><code class='itemdecl'>
bool atomic_compare_exchange_weak(volatile <i>A</i>* object, <i>C</i>* expected, <i>C</i> desired) noexcept;
bool atomic_compare_exchange_weak(<i>A</i>* object, <i>C</i>* expected, <i>C</i> desired) noexcept;
bool atomic_compare_exchange_strong(volatile <i>A</i>* object, <i>C</i>* expected, <i>C</i> desired) noexcept;
bool atomic_compare_exchange_strong(<i>A</i>* object, <i>C</i>* expected, <i>C</i> desired) noexcept;
bool atomic_compare_exchange_weak_explicit(volatile <i>A</i>* object, <i>C</i>* expected, <i>C</i> desired,
    memory_order success, memory_order failure) noexcept;
bool atomic_compare_exchange_weak_explicit(<i>A</i>* object, <i>C</i>* expected, <i>C</i> desired,
    memory_order success, memory_order failure) noexcept;
bool atomic_compare_exchange_strong_explicit(volatile <i>A</i>* object, <i>C</i>* expected, <i>C</i> desired,
    memory_order success, memory_order failure) noexcept;
bool atomic_compare_exchange_strong_explicit(<i>A</i>* object, <i>C</i>* expected, <i>C</i> desired,
    memory_order success, memory_order failure) noexcept;
bool <i>A</i>::compare_exchange_weak(<i>C</i>&amp; expected, <i>C</i> desired,
    memory_order success, memory_order failure) volatile noexcept;
bool <i>A</i>::compare_exchange_weak(<i>C</i>&amp; expected, <i>C</i> desired,
    memory_order success, memory_order failure) noexcept;
bool <i>A</i>::compare_exchange_strong(<i>C</i>&amp; expected, <i>C</i> desired,
    memory_order success, memory_order failure) volatile noexcept;
bool <i>A</i>::compare_exchange_strong(<i>C</i>&amp; expected, <i>C</i> desired,
    memory_order success, memory_order failure) noexcept;
bool <i>A</i>::compare_exchange_weak(<i>C</i>&amp; expected, <i>C</i> desired,
    memory_order order = memory_order_seq_cst) volatile noexcept;
bool <i>A</i>::compare_exchange_weak(<i>C</i>&amp; expected, <i>C</i> desired,
    memory_order order = memory_order_seq_cst) noexcept;
bool <i>A</i>::compare_exchange_strong(<i>C</i>&amp; expected, <i>C</i> desired,
    memory_order order = memory_order_seq_cst) volatile noexcept;
bool <i>A</i>::compare_exchange_strong(<i>C</i>&amp; expected, <i>C</i> desired,
    memory_order order = memory_order_seq_cst) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='req-20'><div class='marginalizedparent'><a class='marginalized' href='#req-20'>20</a></div><div class='itemdescr'><p ><i>Requires:</i> The <span class='texttt'>failure</span> argument shall not be <span class='texttt'>memory_order_release</span> nor
<span class='texttt'>memory_order_acq_rel</span>. The <span class='texttt'>failure</span> argument shall be no stronger than the
<span class='texttt'>success</span> argument.</p></div></div><div class='para' id='req-21'><div class='marginalizedparent'><a class='marginalized' href='#req-21'>21</a></div><div class='itemdescr'><p ><i>Effects:</i> Atomically, compares the contents of the memory pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span>
for equality with that in <span class='texttt'>expected</span>, and if true, replaces the contents of the memory pointed to
by <span class='texttt'>object</span> or by <span class='texttt'>this</span> with that in <span class='texttt'>desired</span>, and if false, updates the
contents of the memory in <span class='texttt'>expected</span> with the contents of the memory pointed to by <span class='texttt'>object</span> or by
<span class='texttt'>this</span>. Further, if the comparison is true, memory is affected according to the
value of <span class='texttt'>success</span>, and if the comparison is false, memory is affected according
to the value of <span class='texttt'>failure</span>. When only one <span class='texttt'>memory_order</span> argument is
supplied, the value of <span class='texttt'>success</span> is <span class='texttt'>order</span>, and the value of
<span class='texttt'>failure</span> is <span class='texttt'>order</span> except that a value of <span class='texttt'>memory_order_acq_rel</span>
shall be replaced by the value <span class='texttt'>memory_order_acquire</span> and a value of
<span class='texttt'>memory_order_release</span> shall be replaced by the value
<span class='texttt'>memory_order_relaxed</span>. If the operation returns <span class='texttt'>true</span>, these
operations are atomic read-modify-write
operations (<a href='intro.multithread'>[intro.multithread]</a>). Otherwise, these operations are atomic load operations.</p></div></div><div class='para' id='req-22'><div class='marginalizedparent'><a class='marginalized' href='#req-22'>22</a></div><div class='itemdescr'><p ><i>Returns:</i> The result of the comparison.</p></div></div><div class='para' id='req-23'><div class='marginalizedparent'><a class='marginalized' href='#req-23'>23</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> For example, the effect of
<span class='texttt'>atomic_compare_exchange_strong</span> is
</p><pre class='codeblock'>
if (memcmp(object, expected, sizeof(*object)) == 0)
  memcpy(object, &amp;desired, sizeof(*object));
else
  memcpy(expected, object, sizeof(*object));
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i> the expected use of the compare-and-exchange operations is as follows. The
compare-and-exchange operations will update <span class='texttt'>expected</span> when another iteration of
the loop is needed.
</p><pre class='codeblock'>
expected = current.load();
do {
  desired = function(expected);
} while (!current.compare_exchange_weak(expected, desired));
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div class='para' id='req-24'><div class='marginalizedparent'><a class='marginalized' href='#req-24'>24</a></div><div class='itemdescr'><p >Implementations should ensure that weak compare-and-exchange operations do not
consistently return <span class='texttt'>false</span> unless either the atomic object has value
different from <span class='texttt'>expected</span> or there are concurrent modifications to the
atomic object.</p></div></div><div class='para' id='req-25'><div class='marginalizedparent'><a class='marginalized' href='#req-25'>25</a></div><div class='itemdescr'><p ><i>Remark:</i>
A weak compare-and-exchange operation may fail spuriously. That is, even when
the contents of memory referred to by <span class='texttt'>expected</span> and <span class='texttt'>object</span> are
equal, it may return false and store back to <span class='texttt'>expected</span> the same memory
contents that were originally there.
[&nbsp;<i>Note:</i> This
spurious failure enables implementation of compare-and-exchange on a broader class of
machines, e.g., load-locked store-conditional machines. A
consequence of spurious failure is that nearly all uses of weak compare-and-exchange
will be in a loop.</p><p >When a compare-and-exchange is in a loop, the weak version will yield better performance
on some platforms. When a weak compare-and-exchange would require a loop and a strong one
would not, the strong one is preferable.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='req-26'><div class='marginalizedparent'><a class='marginalized' href='#req-26'>26</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The <span class='texttt'>memcpy</span> and <span class='texttt'>memcmp</span> semantics of the compare-and-exchange
operations may result in failed comparisons for values that compare equal with
<span class='texttt'>operator==</span> if the underlying type has padding bits, trap bits, or alternate
representations of the same value. Thus, <span class='texttt'>compare_exchange_strong</span> should be used
with extreme care. On the other hand, <span class='texttt'>compare_exchange_weak</span> should converge
rapidly. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><div class='para' id='req-27'><div class='marginalizedparent'><a class='marginalized' href='#req-27'>27</a></div><p >The following operations perform arithmetic computations. The key, operator, and computation correspondence is:</p><div class='numberedTable' id='tab:atomic.arithmetic.computations'>Table <a href='#tab:atomic.arithmetic.computations'>147</a> — Atomic arithmetic computations<br><table ><tr class='rowsep'><td class='left'>



<span class='texttt'>Key</span>       </td><td class='left'>
  Op          </td><td class='left'>
  Computation     </td><td class='border left'>
<span class='texttt'>Key</span>       </td><td class='left'>
  Op          </td><td class='left'>
  Computation     </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>add</span>       </td><td class='left'>
  <span class='texttt'>+</span>       </td><td class='left'>
  addition        </td><td class='border left'>
<span class='texttt'>sub</span>       </td><td class='left'>
  <span class='texttt'>-</span>       </td><td class='left'>
  subtraction     </td></tr><tr ><td class='left'>
<span class='texttt'>or</span>        </td><td class='left'>
  <span class='texttt'>|</span>       </td><td class='left'>
  bitwise inclusive or  </td><td class='border left'>
<span class='texttt'>xor</span>       </td><td class='left'>
  <span class='texttt'>^</span>        </td><td class='left'>
  bitwise exclusive or  </td></tr><tr ><td class='left'>
<span class='texttt'>and</span>       </td><td class='left'>
  <span class='texttt'>&amp;</span>      </td><td class='left'>
  bitwise and     </td><td class='border left'></td><td class='left'></td><td class='left'></td></tr></table></div><p ><span class='indexparent'><a class='index' id='atomic_type,atomic_fetch_'></a></span><span class='indexparent'><a class='index' id='atomic_fetch_,atomic_type'></a></span><span class='indexparent'><a class='index' id='atomic_type,fetch_'></a></span><span class='indexparent'><a class='index' id='fetch_,atomic_type'></a></span><code class='itemdecl'>
<i>C</i> atomic_fetch_<i>key</i>(volatile <i>A</i> *object, <i>M</i> operand) noexcept;
<i>C</i> atomic_fetch_<i>key</i>(<i>A</i>* object, <i>M</i> operand) noexcept;
<i>C</i> atomic_fetch_<i>key</i>_explicit(volatile <i>A</i> *object, <i>M</i> operand, memory_order order) noexcept;
<i>C</i> atomic_fetch_<i>key</i>_explicit(<i>A</i>* object, <i>M</i> operand, memory_order order) noexcept;
<i>C</i> <i>A</i>::fetch_<i>key</i>(<i>M</i> operand, memory_order order = memory_order_seq_cst) volatile noexcept;
<i>C</i> <i>A</i>::fetch_<i>key</i>(<i>M</i> operand, memory_order order = memory_order_seq_cst) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='req-28'><div class='marginalizedparent'><a class='marginalized' href='#req-28'>28</a></div><div class='itemdescr'><p ><i>Effects:</i> Atomically replaces the value pointed to by <span class='texttt'>object</span> or by
<span class='texttt'>this</span> with the result of the <i>computation</i> applied to the
value pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span> and the given <span class='texttt'>operand</span>.
Memory is affected according to the value of <span class='texttt'>order</span>.
These operations are atomic read-modify-write operations (<a href='intro.multithread'>[intro.multithread]</a>).</p></div></div><div class='para' id='req-29'><div class='marginalizedparent'><a class='marginalized' href='#req-29'>29</a></div><div class='itemdescr'><p ><i>Returns:</i> Atomically, the value pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span> immediately before the effects.</p></div></div><div class='para' id='req-30'><div class='marginalizedparent'><a class='marginalized' href='#req-30'>30</a></div><div class='itemdescr'><p ><i>Remark:</i> For signed integer types, arithmetic is defined to use two's complement
representation. There are no undefined results. For address types, the result may be an
undefined address, but the operations otherwise have no undefined behavior.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_type,operator_@='></a></span><span class='indexparent'><a class='index' id='operator_@=,atomic_type'></a></span><code class='itemdecl'>
<i>C</i> <i>A</i>::operator <i>op</i>=(<i>M</i> operand) volatile noexcept;
<i>C</i> <i>A</i>::operator <i>op</i>=(<i>M</i> operand) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='req-31'><div class='marginalizedparent'><a class='marginalized' href='#req-31'>31</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>fetch_<i>key</i>(operand)</span></p></div></div><div class='para' id='req-32'><div class='marginalizedparent'><a class='marginalized' href='#req-32'>32</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>fetch_<i>key</i>(operand) op operand</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_type,operator++'></a></span><span class='indexparent'><a class='index' id='operator++,atomic_type'></a></span><code class='itemdecl'>
<i>C</i> <i>A</i>::operator++(int) volatile noexcept;
<i>C</i> <i>A</i>::operator++(int) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='req-33'><div class='marginalizedparent'><a class='marginalized' href='#req-33'>33</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>fetch_add(1)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_type,operator--'></a></span><span class='indexparent'><a class='index' id='operator--,atomic_type'></a></span><code class='itemdecl'>
<i>C</i> <i>A</i>::operator--(int) volatile noexcept;
<i>C</i> <i>A</i>::operator--(int) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='req-34'><div class='marginalizedparent'><a class='marginalized' href='#req-34'>34</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>fetch_sub(1)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_type,operator++'></a></span><span class='indexparent'><a class='index' id='operator++,atomic_type'></a></span><code class='itemdecl'>
<i>C</i> <i>A</i>::operator++() volatile noexcept;
<i>C</i> <i>A</i>::operator++() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='req-35'><div class='marginalizedparent'><a class='marginalized' href='#req-35'>35</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>fetch_add(1)</span></p></div></div><div class='para' id='req-36'><div class='marginalizedparent'><a class='marginalized' href='#req-36'>36</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>fetch_add(1) + 1</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_type,operator--'></a></span><span class='indexparent'><a class='index' id='operator--,atomic_type'></a></span><code class='itemdecl'>
<i>C</i> <i>A</i>::operator--() volatile noexcept;
<i>C</i> <i>A</i>::operator--() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='req-37'><div class='marginalizedparent'><a class='marginalized' href='#req-37'>37</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>fetch_sub(1)</span></p></div></div><div class='para' id='req-38'><div class='marginalizedparent'><a class='marginalized' href='#req-38'>38</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>fetch_sub(1) - 1</span>
</p></div></div></div></div></div></body></html>