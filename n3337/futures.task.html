<!DOCTYPE html><html lang='en'><head><title>[futures.task]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>30</a> Thread support library <a class='abbr_ref' href='./#thread'>[thread]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>30.6</a> Futures <a class='abbr_ref' href='futures#task'>[futures]</a></h2><div id='futures.task'><h3 ><a class='secnum' style='min-width:103pt'>30.6.9</a> Class template <span class='texttt'>packaged_task</span> <a class='abbr_ref'>[futures.task]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The class template <span class='texttt'>packaged_task</span> defines a type for wrapping a function or
callable object so that the return value of the function or callable object is stored in
a future when it is invoked.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >When the <span class='texttt'>packaged_task</span> object is invoked, its stored task is invoked and the
result (whether normal or exceptional) stored in the shared state. Any futures that
share the shared state will then be able to access the stored result.</p><pre class='codeblock'>
namespace std {
  template&lt;class&gt; class packaged_task; <span class='comment'>// undefined
</span>
  template&lt;class R, class... ArgTypes&gt;
  class packaged_task&lt;R(ArgTypes...)&gt; {
  public:
    <span class='comment'>// construction and destruction
</span>    packaged_task() noexcept;
    template &lt;class F&gt;
      explicit packaged_task(F&amp;&amp; f);
    template &lt;class F, class Allocator&gt;
      explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
    ~packaged_task();

    <span class='comment'>// no copy
</span>    packaged_task(packaged_task&amp;) = delete;
    packaged_task&amp; operator=(packaged_task&amp;) = delete;

    <span class='comment'>// move support
</span>    packaged_task(packaged_task&amp;&amp; rhs) noexcept;
    packaged_task&amp; operator=(packaged_task&amp;&amp; rhs) noexcept;
    void swap(packaged_task&amp; other) noexcept;

    bool valid() const noexcept;

    <span class='comment'>// result retrieval
</span>    future&lt;R&gt; get_future();        

    <span class='comment'>// execution
</span>    void operator()(ArgTypes... );
    void make_ready_at_thread_exit(ArgTypes...);

    void reset();
  };
  template &lt;class R, class... ArgTypes&gt;
    void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp; x, packaged_task&lt;R(ArgTypes...)&gt;&amp; y) noexcept;
  template &lt;class R, class Alloc&gt;
    struct uses_allocator&lt;packaged_task&lt;R&gt;, Alloc&gt;;
}
</pre></div><div id='members'><h4 ><a class='secnum' href='#members' style='min-width:118pt'>30.6.9.1</a> <span class='texttt'>packaged_task</span> member functions <a class='abbr_ref' href='futures.task.members'>[futures.task.members]</a></h4><p ><span class='indexparent'><a class='index' id='packaged_task,constructor'></a></span><code class='itemdecl'>
packaged_task() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='members-1'><div class='marginalizedparent'><a class='marginalized' href='#members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> constructs a <span class='texttt'>packaged_task</span> object with no shared state and no stored task.
</p></div></div><p ><span class='indexparent'><a class='index' id='packaged_task,constructor'></a></span><code class='itemdecl'>
template &lt;class F&gt;
  packaged_task(F&amp;&amp; f);
template &lt;class F, class Allocator&gt;
  explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
</code></p><div class='itemdescr'></div><div class='para' id='members-2'><div class='marginalizedparent'><a class='marginalized' href='#members-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN, R)</span>, where <span class='texttt'>t1, t2, ..., tN</span> are values
of the corresponding types in <span class='texttt'>ArgTypes...</span>, shall be a valid expression. Invoking
a copy of <span class='texttt'>f</span> shall behave the same as invoking <span class='texttt'>f</span>.</p></div></div><div class='para' id='members-3'><div class='marginalizedparent'><a class='marginalized' href='#members-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> constructs a new <span class='texttt'>packaged_task</span> object with a shared state and
initializes the object's stored task with <span class='texttt'>std::forward&lt;F&gt;(f)</span>. The constructors that
take an <span class='texttt'>Allocator</span> argument use it to allocate memory needed to store the
internal data structures.</p></div></div><div class='para' id='members-4'><div class='marginalizedparent'><a class='marginalized' href='#members-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i> any exceptions thrown by the copy or move constructor of <span class='texttt'>f</span>, or
<span class='texttt'>std::bad_alloc</span> if memory for the internal data structures could not be
allocated.
</p></div></div><p ><span class='indexparent'><a class='index' id='packaged_task,constructor'></a></span><code class='itemdecl'>
packaged_task(packaged_task&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='members-5'><div class='marginalizedparent'><a class='marginalized' href='#members-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> constructs a new <span class='texttt'>packaged_task</span> object and transfers ownership of
<span class='texttt'>rhs</span>'s shared state to <span class='texttt'>*this</span>, leaving <span class='texttt'>rhs</span> with no
shared state. Moves the stored task from <span class='texttt'>rhs</span> to <span class='texttt'>*this</span>.</p></div></div><div class='para' id='members-6'><div class='marginalizedparent'><a class='marginalized' href='#members-6'>6</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>rhs</span> has no shared state.
</p></div></div><p ><span class='indexparent'><a class='index' id='packaged_task,operator='></a></span><span class='indexparent'><a class='index' id='operator=,packaged_task'></a></span><code class='itemdecl'>
packaged_task&amp; operator=(packaged_task&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='members-7'><div class='marginalizedparent'><a class='marginalized' href='#members-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i></p><ul ><li id='members-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#members-7.1'>(7.1)</a></div><p >releases any shared state (<a href='futures.state'>[futures.state]</a>).</p></li><li id='members-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#members-7.2'>(7.2)</a></div><p ><span class='texttt'>packaged_task(std::move(rhs)).swap(*this)</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='packaged_task,destructor'></a></span><code class='itemdecl'>
~packaged_task();
</code></p><div class='itemdescr'></div><div class='para' id='members-8'><div class='marginalizedparent'><a class='marginalized' href='#members-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i>
Abandons any shared state. (<a href='futures.state'>[futures.state]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='packaged_task,swap'></a></span><span class='indexparent'><a class='index' id='swap,packaged_task'></a></span><code class='itemdecl'>
void swap(packaged_task&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='members-9'><div class='marginalizedparent'><a class='marginalized' href='#members-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> exchanges the shared states and stored tasks of <span class='texttt'>*this</span> and <span class='texttt'>other</span>.</p></div></div><div class='para' id='members-10'><div class='marginalizedparent'><a class='marginalized' href='#members-10'>10</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>*this</span> has the same shared state
and stored task (if any) as <span class='texttt'>other</span>
prior to the call to <span class='texttt'>swap</span>. <span class='texttt'>other</span> has the same shared state
and stored task (if any)
as <span class='texttt'>*this</span> prior to the call to <span class='texttt'>swap</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='packaged_task,valid'></a></span><span class='indexparent'><a class='index' id='valid,packaged_task'></a></span><code class='itemdecl'>
bool valid() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='members-11'><div class='marginalizedparent'><a class='marginalized' href='#members-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> only if <span class='texttt'>*this</span> has a shared state.
</p></div></div><p ><span class='indexparent'><a class='index' id='packaged_task,get_future'></a></span><span class='indexparent'><a class='index' id='get_future,packaged_task'></a></span><code class='itemdecl'>
future&lt;R&gt; get_future();
</code></p><div class='itemdescr'></div><div class='para' id='members-12'><div class='marginalizedparent'><a class='marginalized' href='#members-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>future</span> object that shares the same shared state as <span class='texttt'>*this</span>.</p></div></div><div class='para' id='members-13'><div class='marginalizedparent'><a class='marginalized' href='#members-13'>13</a></div><div class='itemdescr'><p ><i>Throws:</i> a <span class='texttt'>future_error</span> object if an error occurs.</p></div></div><div class='para' id='members-14'><div class='marginalizedparent'><a class='marginalized' href='#members-14'>14</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li id='members-14.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#members-14.1'>(14.1)</a></div><p ><span class='texttt'>future_already_retrieved</span> if <span class='texttt'>get_future</span> has already been called on
a <span class='texttt'>packaged_task</span> object with the same shared state as <span class='texttt'>*this</span>.
</p></li><li id='members-14.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#members-14.2'>(14.2)</a></div><p ><span class='texttt'>no_state</span> if <span class='texttt'>*this</span> has no shared state.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='packaged_task,operator()'></a></span><span class='indexparent'><a class='index' id='operator(),packaged_task'></a></span><code class='itemdecl'>
void operator()(ArgTypes... args);
</code></p><div class='itemdescr'></div><div class='para' id='members-15'><div class='marginalizedparent'><a class='marginalized' href='#members-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN, R)</span>, where <span class='texttt'>f</span> is the
stored task of <span class='texttt'>*this</span> and
<span class='texttt'>t1, t2, ..., tN</span> are the values in <span class='texttt'>args...</span>. If the task returns normally,
the return value is stored as the asynchronous result in the shared state of
<span class='texttt'>*this</span>, otherwise the exception thrown by the task is stored. The
shared state of <span class='texttt'>*this</span> is made ready, and any threads blocked in a
function waiting for
the shared state of <span class='texttt'>*this</span> to become ready are unblocked.</p></div></div><div class='para' id='members-16'><div class='marginalizedparent'><a class='marginalized' href='#members-16'>16</a></div><div class='itemdescr'><p ><i>Throws:</i> a <span class='texttt'>future_error</span> exception object if there is no shared
state or the stored task has already been invoked.</p></div></div><div class='para' id='members-17'><div class='marginalizedparent'><a class='marginalized' href='#members-17'>17</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li id='members-17.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#members-17.1'>(17.1)</a></div><p ><span class='texttt'>promise_already_satisfied</span> if
the stored task has already been invoked.
</p></li><li id='members-17.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#members-17.2'>(17.2)</a></div><p ><span class='texttt'>no_state</span> if <span class='texttt'>*this</span> has no shared state.
</p></li></ul></div></div><div class='para' id='members-18'><div class='marginalizedparent'><a class='marginalized' href='#members-18'>18</a></div><div class='itemdescr'><p ><i>Synchronization:</i> a successful call to <span class='texttt'>operator()</span> synchronizes
with (<a href='intro.multithread'>[intro.multithread]</a>) a call to any member function of a <span class='texttt'>future</span>
or
<span class='texttt'>shared_future</span> object that shares the shared state of <span class='texttt'>*this</span>. The
completion of the invocation
of the
stored task and the
storage of the result (whether normal or exceptional) into the shared state
synchronizes with (<a href='intro.multithread'>[intro.multithread]</a>) the successful return from any member
function that detects that the state is set to ready.
[&nbsp;<i>Note:</i>
<span class='texttt'>operator()</span> synchronizes and serializes with other functions through the
shared state. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='packaged_task,make_ready_at_thread_exit'></a></span><span class='indexparent'><a class='index' id='make_ready_at_thread_exit,packaged_task'></a></span><code class='itemdecl'>
void make_ready_at_thread_exit(ArgTypes... args);
</code></p><div class='itemdescr'></div><div class='para' id='members-19'><div class='marginalizedparent'><a class='marginalized' href='#members-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN, R)</span>, where <span class='texttt'>f</span> is the
stored task and
<span class='texttt'>t1, t2, ..., tN</span> are the values in <span class='texttt'>args...</span>. If the task returns normally,
the return value is stored as the asynchronous result in the shared state of
<span class='texttt'>*this</span>, otherwise the exception thrown by the task is stored. In either
case, this shall be done without making that state ready (<a href='futures.state'>[futures.state]</a>) immediately. Schedules
the shared state to be made ready when the current thread exits,
after all objects of thread storage duration associated with the current thread
have been destroyed.</p></div></div><div class='para' id='members-20'><div class='marginalizedparent'><a class='marginalized' href='#members-20'>20</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>future_error</span> if an error condition occurs.</p></div></div><div class='para' id='members-21'><div class='marginalizedparent'><a class='marginalized' href='#members-21'>21</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li id='members-21.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#members-21.1'>(21.1)</a></div><p ><span class='texttt'>promise_already_satisfied</span> if the
stored task has already been invoked.
</p></li><li id='members-21.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#members-21.2'>(21.2)</a></div><p ><span class='texttt'>no_state</span> if <span class='texttt'>*this</span> has no shared state.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='packaged_task,reset'></a></span><span class='indexparent'><a class='index' id='reset,packaged_task'></a></span><code class='itemdecl'>
void reset();
</code></p><div class='itemdescr'></div><div class='para' id='members-22'><div class='marginalizedparent'><a class='marginalized' href='#members-22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i> as if <span class='texttt'>*this = packaged_task(std::move(f))</span>, where
<span class='texttt'>f</span> is the task stored in
<span class='texttt'>*this</span>. [&nbsp;<i>Note:</i> This constructs a new shared state for <span class='texttt'>*this</span>. The
old state is abandoned (<a href='futures.state'>[futures.state]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='members-23'><div class='marginalizedparent'><a class='marginalized' href='#members-23'>23</a></div><div class='itemdescr'><p ><i>Throws:</i>
</p><ul ><li id='members-23.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#members-23.1'>(23.1)</a></div><p ><span class='texttt'>bad_alloc</span> if memory for the new shared state could not be allocated.
</p></li><li id='members-23.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#members-23.2'>(23.2)</a></div><p >any exception thrown by the move constructor of the task stored in the shared
state.
</p></li><li id='members-23.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#members-23.3'>(23.3)</a></div><p ><span class='texttt'>future_error</span> with an error condition of <span class='texttt'>no_state</span> if <span class='texttt'>*this</span>
has no shared state.
</p></li></ul></div></div></div><div id='nonmembers'><h4 ><a class='secnum' href='#nonmembers' style='min-width:118pt'>30.6.9.2</a> <span class='texttt'>packaged_task</span> globals <a class='abbr_ref' href='futures.task.nonmembers'>[futures.task.nonmembers]</a></h4><p ><span class='indexparent'><a class='index' id='packaged_task,swap'></a></span><span class='indexparent'><a class='index' id='swap,packaged_task'></a></span><code class='itemdecl'>
template &lt;class R, class... ArgTypes&gt;
  void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp; x, packaged_task&lt;R(ArgTypes...)&gt;&amp; y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='nonmembers-1'><div class='marginalizedparent'><a class='marginalized' href='#nonmembers-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>x.swap(y)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='uses_allocator'></a></span><code class='itemdecl'>
template &lt;class R, class Alloc&gt;
  struct uses_allocator&lt;packaged_task&lt;R&gt;, Alloc&gt;
    : true_type { };
</code></p><div class='itemdescr'></div><div class='para' id='nonmembers-2'><div class='marginalizedparent'><a class='marginalized' href='#nonmembers-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>Alloc</span> shall be an Allocator (<a href='allocator.requirements'>[allocator.requirements]</a>).
</p></div></div></div></div></div></body></html>