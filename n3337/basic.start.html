<!DOCTYPE html><html lang='en'><head><title>[basic.start]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><div id='basic.start'><h2 ><a class='secnum' style='min-width:88pt'>3.6</a> Start and termination <a class='abbr_ref'>[basic.start]</a></h2><div id='main'><h3 ><a class='secnum' href='#main' style='min-width:103pt'>3.6.1</a> Main function <a class='abbr_ref' href='basic.start.main'>[basic.start.main]</a></h3><div class='para' id='main-1'><div class='marginalizedparent'><a class='marginalized' href='#main-1'>1</a></div><p ><span class='indexparent'><a class='index' id='program,start'></a></span><span class='indexparent'><a class='index' id='main()'></a></span>A program shall contain a global function called <span class='texttt'>main</span>, which is the designated
start of the program. It is <span class='indexparent'><a class='index' id='defining_main_in_freestanding_environment'></a></span>implementation-defined
whether a program in a freestanding environment is required to define a <span class='texttt'>main</span>
function. [&nbsp;<i>Note:</i> In a freestanding environment, start-up and termination is
<span class='indexparent'><a class='index' id='start-up_and_termination_in_freestanding_environment'></a></span>implementation-defined; start-up contains the
execution of constructors for objects of namespace scope with static storage duration;
termination contains the execution of destructors for objects with static storage
duration. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='main-2'><div class='marginalizedparent'><a class='marginalized' href='#main-2'>2</a></div><p >An implementation shall not predefine the <span class='texttt'>main</span> function. This
function shall not be overloaded. It shall have a return type of type
<span class='texttt'>int</span>, but otherwise its type is <span class='indexparent'><a class='index' id='parameters_to_main'></a></span>implementation-defined.
<span class='indexparent'><a class='index' id='main(),implementation-defined_parameters_to'></a></span>All implementations shall allow both of the following definitions of
<span class='texttt'>main</span>:</p><pre class='codeblock'>
int main() <span class='texttt'>{ /* ... */ }</span>
</pre><p >and</p><p ><span class='indexparent'><a class='index' id='argc'></a></span><span class='indexparent'><a class='index' id='argv'></a></span></p><pre class='codeblock'>
int main(int argc, char* argv[]) <span class='texttt'>{ /* ... */ }</span>
</pre><p ><span class='indexparent'><a class='index' id='main(),parameters_to'></a></span><span class='indexparent'><a class='index' id='environment,program'></a></span>In the latter form <span class='texttt'>argc</span> shall be the number of arguments passed
to the program from the environment in which the program is run. If
<span class='texttt'>argc</span> is nonzero these arguments shall be supplied in
<span class='texttt'>argv[0]</span> through <span class='texttt'>argv[argc-1]</span> as pointers to the initial
characters of null-terminated multibyte strings (<span class='textsc'>ntmbs</span>
s) (<a href='multibyte.strings'>[multibyte.strings]</a>) and <span class='texttt'>argv[0]</span> shall be the pointer to
the initial character of a <span class='textsc'>ntmbs</span> that represents the name used to
invoke the program or <span class='texttt'>""</span>. The value of <span class='texttt'>argc</span> shall be
non-negative. The value of <span class='texttt'>argv[argc]</span> shall be 0. [&nbsp;<i>Note:</i> It
is recommended that any further (optional) parameters be added after
<span class='texttt'>argv</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='main-3'><div class='marginalizedparent'><a class='marginalized' href='#main-3'>3</a></div><p >The function <span class='texttt'>main</span> shall not be used within
a program.
<span class='indexparent'><a class='index' id='main(),implementation-defined_linkage_of'></a></span>The linkage (<a href='basic.link'>[basic.link]</a>) of <span class='texttt'>main</span> is
<span class='indexparent'><a class='index' id='linkage_of_main'></a></span>implementation-defined. A program that defines <span class='texttt'>main</span> as
deleted or that declares <span class='texttt'>main</span> to be
<span class='texttt'>inline,</span> <span class='texttt'>static</span>, or <span class='texttt'>constexpr</span> is ill-formed. The name <span class='texttt'>main</span> is
not otherwise reserved. [&nbsp;<i>Example:</i> member functions, classes, and
enumerations can be called <span class='texttt'>main</span>, as can entities in other
namespaces. <i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='main-4'><div class='marginalizedparent'><a class='marginalized' href='#main-4'>4</a></div><p ><span class='indexparent'><a class='index' id='exit'></a></span><span class='indexparent'><a class='index' id='exit'></a></span><span class='indexparent'><a class='index' id='termination,program'></a></span>Terminating the program
without leaving the current block (e.g., by calling the function
<span class='texttt'>std::exit(int)</span> (<a href='support.start.term'>[support.start.term]</a>)) does not destroy any
objects with automatic storage duration (<a href='class.dtor'>[class.dtor]</a>). If
<span class='texttt'>std::exit</span> is called to end a program during the destruction of
an object with static or thread storage duration, the program has undefined
behavior.</p></div><div class='para' id='main-5'><div class='marginalizedparent'><a class='marginalized' href='#main-5'>5</a></div><p ><span class='indexparent'><a class='index' id='termination,program'></a></span><span class='indexparent'><a class='index' id='main(),return_from'></a></span>A return statement in <span class='texttt'>main</span> has the effect of leaving the main
function (destroying any objects with automatic storage duration) and
calling <span class='texttt'>std::exit</span> with the return value as the argument. If
control reaches the end of <span class='texttt'>main</span> without encountering a
<span class='texttt'>return</span> statement, the effect is that of executing</p><pre class='codeblock'>
return 0;
</pre></div></div><div id='init'><h3 ><a class='secnum' href='#init' style='min-width:103pt'>3.6.2</a> Initialization of non-local variables <a class='abbr_ref' href='basic.start.init'>[basic.start.init]</a></h3><div class='para' id='init-1'><div class='marginalizedparent'><a class='marginalized' href='#init-1'>1</a></div><p ><span class='indexparent'><a class='index' id='initialization'></a></span><span class='indexparent'><a class='index' id='initialization,static_and_thread'></a></span>There are two broad classes of named non-local variables: those with static storage
duration (<a href='basic.stc.static'>[basic.stc.static]</a>) and those with thread storage
duration (<a href='basic.stc.thread'>[basic.stc.thread]</a>). Non-local variables with static storage duration
are initialized as a consequence of program initiation. Non-local variables with
thread storage duration are initialized as a consequence of thread execution.
Within each of these phases of initiation, initialization occurs as follows.</p></div><div class='para' id='init-2'><div class='marginalizedparent'><a class='marginalized' href='#init-2'>2</a></div><p ><span class='indexparent'><a class='index' id='initialization,static_object'></a></span><span class='indexparent'><a class='index' id='initialization,dynamic'></a></span><span class='indexparent'><a class='index' id='initialization,run-time'></a></span><span class='indexparent'><a class='index' id='start,program'></a></span><span class='indexparent'><a class='index' id='initialization,order_of'></a></span>Variables with static storage duration (<a href='basic.stc.static'>[basic.stc.static]</a>) or thread storage
duration (<a href='basic.stc.thread'>[basic.stc.thread]</a>) shall be zero-initialized (<a href='dcl.init'>[dcl.init]</a>) before
any other initialization takes place.</p><p ><span class='indexparent'><a class='index' id='initialization,constant'></a></span><a class='hidden_link' href='#def:Constant_initialization' id='def:Constant_initialization'><i>Constant initialization</i></a> is performed:</p><ul ><li id='init-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#init-2.1'>(2.1)</a></div><p >if each full-expression (including implicit conversions) that appears in
the initializer of a reference with static or thread storage duration is a
constant expression (<a href='expr.const'>[expr.const]</a>) and the reference is bound to an lvalue
designating an object with static storage duration or to a temporary (see <a href='class.temporary'>[class.temporary]</a>);</p></li><li id='init-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#init-2.2'>(2.2)</a></div><p >if an object with static or thread storage duration is initialized
by a constructor call, if the constructor is a <span class='texttt'>constexpr</span> constructor, if all constructor
arguments are constant expressions (including conversions), and if, after function
invocation substitution (<a href='dcl.constexpr'>[dcl.constexpr]</a>), every constructor call and full-expression in
the <i ><a href='class.base.init#nt:mem-initializer'>mem-initializers</a></i>
and in the <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializers</a></i> for non-static data members
is a constant expression;</p></li><li id='init-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#init-2.3'>(2.3)</a></div><p >if an object with static or thread storage duration is not initialized by a constructor call
and if every full-expression that appears in its initializer is a constant expression.</p></li></ul><p >Together, zero-initialization and constant initialization are called <a class='hidden_link' href='#def:static_initialization' id='def:static_initialization'><i>static
initialization</i></a>; all other initialization is <a class='hidden_link' href='#def:dynamic_initialization' id='def:dynamic_initialization'><i>dynamic initialization</i></a>. Static
initialization shall be performed before any dynamic initialization takes place. Dynamic
initialization of a non-local variable with static storage duration is either ordered or
unordered. Definitions of explicitly specialized class template static data members have
ordered initialization. Other class template static data members (i.e., implicitly or
explicitly instantiated specializations) have unordered initialization. Other non-local
variables with static storage duration have ordered initialization. Variables with ordered
initialization defined within a single translation unit shall be initialized in the order of
their definitions in the translation unit. If a program starts a thread (<a href='thread.threads'>[thread.threads]</a>),
the subsequent initialization of a variable is unsequenced with respect to the initialization
of a variable defined in a different translation unit. Otherwise, the initialization of a
variable is indeterminately sequenced with respect to the initialization of a variable defined
in a different translation unit. If a program starts a thread, the subsequent unordered
initialization of a variable is unsequenced with respect to every other dynamic initialization.
Otherwise, the unordered initialization of a variable is indeterminately sequenced with respect
to every other dynamic initialization. [&nbsp;<i>Note:</i> This definition permits initialization of a
sequence of ordered variables concurrently with another sequence. <i>&nbsp;—&nbsp;end note</i>&nbsp;] [&nbsp;<i>Note:</i> The
initialization of local static variables is described in <a href='stmt.dcl'>[stmt.dcl]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='init-3'><div class='marginalizedparent'><a class='marginalized' href='#init-3'>3</a></div><p >An implementation is permitted to perform the initialization of a
non-local variable with static storage duration as a static
initialization even if such initialization is not required to be done
statically, provided that</p><ul ><li id='init-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#init-3.1'>(3.1)</a></div><p >the dynamic version of the initialization does not change the
value of any other object of namespace scope prior to its initialization, and</p></li><li id='init-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#init-3.2'>(3.2)</a></div><p >the static version of the initialization produces the same value
in the initialized variable as would be produced by the dynamic
initialization if all variables not required to be initialized statically
were initialized dynamically.
</p></li></ul><p >[&nbsp;<i>Note:</i> As a consequence, if the initialization of an object <span class='texttt'>obj1</span> refers to an
object <span class='texttt'>obj2</span> of namespace scope potentially requiring dynamic initialization and defined
later in the same translation unit, it is unspecified whether the value of <span class='texttt'>obj2</span> used
will be the value of the fully initialized <span class='texttt'>obj2</span> (because <span class='texttt'>obj2</span> was statically
initialized) or will be the value of <span class='texttt'>obj2</span> merely zero-initialized. For example,</p><pre class='codeblock'>
inline double fd() { return 1.0; }
extern double d1;
double d2 = d1;     <span class='comment'>// unspecified:
</span>                    <span class='comment'>// may be statically initialized to <span class='texttt'>0.0</span> or
</span>                    <span class='comment'>// dynamically initialized to <span class='texttt'>0.0</span> if <span class='texttt'>d1</span> is
</span>                    <span class='comment'>// dynamically initialized, or <span class='texttt'>1.0</span> otherwise
</span>double d1 = fd();   <span class='comment'>// may be initialized statically or dynamically to <span class='texttt'>1.0</span>
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='init-4'><div class='marginalizedparent'><a class='marginalized' href='#init-4'>4</a></div><p ><span class='indexparent'><a class='index' id='evaluation,unspecified_order_of'></a></span>It is <span class='indexparent'><a class='index' id='dynamic_initialization_of_static_objects_before_main'></a></span>implementation-defined whether the
dynamic initialization of a non-local variable with static storage duration is
done before the first statement of <span class='texttt'>main</span>. If the initialization is deferred to
some point in time after the first statement of <span class='texttt'>main</span>, it shall occur before the
first odr-use (<a href='basic.def.odr'>[basic.def.odr]</a>) of any function or variable
defined in the same translation unit as the variable
to be initialized.<a class='footnotenum' href='#footnote-34'>34</a>
[&nbsp;<i>Example:</i> </p><pre class='codeblock'>
<span class='comment'>// - File 1 -
</span>#include "a.h"
#include "b.h"
B b;
A::A(){
  b.Use();
}

<span class='comment'>// - File 2 -
</span>#include "a.h"
A a;

<span class='comment'>// - File 3 -
</span>#include "a.h"
#include "b.h"
extern A a;
extern B b;

int main() {
  a.Use();
  b.Use();
}
</pre><p >It is implementation-defined whether either <span class='texttt'>a</span> or <span class='texttt'>b</span> is
initialized before <span class='texttt'>main</span> is entered or whether the
initializations are delayed until <span class='texttt'>a</span> is first odr-used in
<span class='texttt'>main</span>. In particular, if <span class='texttt'>a</span> is initialized before
<span class='texttt'>main</span> is entered, it is not guaranteed that <span class='texttt'>b</span> will be
initialized before it is odr-used by the initialization of <span class='texttt'>a</span>, that
is, before <span class='texttt'>A::A</span> is called. If, however, <span class='texttt'>a</span> is initialized
at some point after the first statement of <span class='texttt'>main</span>, <span class='texttt'>b</span> will
be initialized prior to its use in <span class='texttt'>A::A</span>. <i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='init-5'><div class='marginalizedparent'><a class='marginalized' href='#init-5'>5</a></div><p >It is <span class='indexparent'><a class='index' id='dynamic_initialization_of_thread-local_objects_before_entry'></a></span>implementation-defined whether the
dynamic initialization of a non-local variable with static or
thread storage duration
is done before the first statement of the initial function of the thread. If the
initialization is deferred to some point in time after the first statement of the
initial function of the thread, it shall occur before the first
odr-use (<a href='basic.def.odr'>[basic.def.odr]</a>) of any variable with
thread storage duration defined in the same translation unit as the variable to be
initialized.</p></div><div class='para' id='init-6'><div class='marginalizedparent'><a class='marginalized' href='#init-6'>6</a></div><p >If the initialization of a non-local variable with static or thread storage duration
exits via
an exception, <span class='texttt'>std::terminate</span> is called (<a href='except.terminate'>[except.terminate]</a>).<span class='indexparent'><a class='index' id='program,start'></a></span></p></div><div class='footnote' id='footnote-34'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-34'>34)</a></div><p >A non-local variable with static storage duration
having initialization
with side-effects must be initialized even if it is not
odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>, <a href='basic.stc.static'>[basic.stc.static]</a>).</p></div></div><div id='term'><h3 ><a class='secnum' href='#term' style='min-width:103pt'>3.6.3</a> Termination <a class='abbr_ref' href='basic.start.term'>[basic.start.term]</a></h3><div class='para' id='term-1'><div class='marginalizedparent'><a class='marginalized' href='#term-1'>1</a></div><p ><span class='indexparent'><a class='index' id='program,termination'></a></span><span class='indexparent'><a class='index' id='object,destructor_static'></a></span><span class='indexparent'><a class='index' id='main(),return_from'></a></span>Destructors (<a href='class.dtor'>[class.dtor]</a>) for initialized objects
(that is, objects whose lifetime (<a href='basic.life'>[basic.life]</a>) has begun)
with static storage duration
are called as a result of returning from <span class='texttt'>main</span> and as a result of calling
<span class='indexparent'><a class='index' id='exit'></a></span><span class='indexparent'><a class='index' id='exit'></a></span><span class='texttt'>std::exit</span> (<a href='support.start.term'>[support.start.term]</a>).
Destructors for initialized objects with thread storage duration within a given thread
are called as a result of returning from the initial function of that thread and as a
result of that thread calling <span class='texttt'>std::exit</span>.
The completions of the destructors for all initialized objects with thread storage
duration within that thread are sequenced before the initiation of the destructors of
any object with static storage duration.
If the completion of the constructor or dynamic initialization of an object with thread
storage duration is sequenced before that of another, the completion of the destructor
of the second is sequenced before the initiation of the destructor of the first.
If the completion of the constructor or dynamic initialization of an object with static
storage duration is sequenced before that of another, the completion of the destructor
of the second is sequenced before the initiation of the destructor of the first.
[&nbsp;<i>Note:</i> This definition permits concurrent destruction. <i>&nbsp;—&nbsp;end note</i>&nbsp;] If an object is
initialized statically, the object is destroyed in the same order as if
the object was dynamically initialized. For an object of array or class
type, all subobjects of that object are destroyed before any block-scope
object with static storage duration initialized during the construction
of the subobjects is destroyed.
If the destruction of an object with static or thread storage duration
exits via an exception,
<span class='texttt'>std::terminate</span> is called (<a href='except.terminate'>[except.terminate]</a>).</p></div><div class='para' id='term-2'><div class='marginalizedparent'><a class='marginalized' href='#term-2'>2</a></div><p >If a function contains a block-scope object of static or thread storage duration that has been
destroyed and the function is called during the destruction of an object with static or
thread storage duration, the program has undefined behavior if the flow of control
passes through the definition of the previously destroyed block-scope object. Likewise, the
behavior is undefined if the block-scope object is used indirectly (i.e., through a
pointer) after its destruction.</p></div><div class='para' id='term-3'><div class='marginalizedparent'><a class='marginalized' href='#term-3'>3</a></div><p ><span class='indexparent'><a class='index' id='atexit'></a></span><span class='indexparent'><a class='index' id='atexit'></a></span>If the completion of the initialization of an object with static storage
duration is sequenced before a call to <span class='texttt'>std::atexit</span> (see
<span class='texttt'>&lt;cstdlib&gt;</span>, <a href='support.start.term'>[support.start.term]</a>), the call to the function passed to
<span class='texttt'>std::atexit</span> is sequenced before the call to the destructor for the object. If a
call to <span class='texttt'>std::atexit</span> is sequenced before the completion of the initialization of
an object with static storage duration, the call to the destructor for the
object is sequenced before the call to the function passed to <span class='texttt'>std::atexit</span>. If a
call to <span class='texttt'>std::atexit</span> is sequenced before another call to <span class='texttt'>std::atexit</span>, the
call to the function passed to the second <span class='texttt'>std::atexit</span> call is sequenced before
the call to the function passed to the first <span class='texttt'>std::atexit</span> call.</p></div><div class='para' id='term-4'><div class='marginalizedparent'><a class='marginalized' href='#term-4'>4</a></div><p >If there is a use of a standard library object or function not permitted within signal
handlers (<a href='support.runtime'>[support.runtime]</a>) that does not happen before (<a href='intro.multithread'>[intro.multithread]</a>)
completion of destruction of objects with static storage duration and execution of
<span class='texttt'>std::atexit</span> registered functions (<a href='support.start.term'>[support.start.term]</a>), the program has
undefined behavior. [&nbsp;<i>Note:</i> If there is a use of an object with static storage
duration that does not happen before the object's destruction, the program has undefined
behavior. Terminating every thread before a call to <span class='texttt'>std::exit</span> or the exit from
<span class='texttt'>main</span> is sufficient, but not necessary, to satisfy these requirements. These
requirements permit thread managers as static-storage-duration objects. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='term-5'><div class='marginalizedparent'><a class='marginalized' href='#term-5'>5</a></div><p ><span class='indexparent'><a class='index' id='abort'></a></span><span class='indexparent'><a class='index' id='abort'></a></span><span class='indexparent'><a class='index' id='termination,program'></a></span>Calling the function <span class='texttt'>std::abort()</span> declared in
<span class='indexparent'><a class='index' id='cstdlib'></a></span><span class='texttt'>&lt;cstdlib&gt;</span> terminates the program without executing any destructors
and without calling
the functions passed to <span class='texttt'>std::atexit()</span> or <span class='texttt'>std::at_quick_exit()</span>.<span class='indexparent'><a class='index' id='program,termination'></a></span></p></div></div></div></div></body></html>