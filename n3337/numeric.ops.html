<!DOCTYPE html><html lang='en'><head><title>[numeric.ops]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>26</a> Numerics library <a class='abbr_ref' href='./#numerics'>[numerics]</a></h1><div id='numeric.ops'><h2 ><a class='secnum' style='min-width:88pt'>26.7</a> Generalized numeric operations <a class='abbr_ref'>[numeric.ops]</a></h2><div id='overview'><h3 ><a class='secnum' href='#overview' style='min-width:103pt'>26.7.1</a> Header <span class='texttt'>&lt;numeric&gt;</span> synopsis <a class='abbr_ref' href='numeric.ops.overview'>[numeric.ops.overview]</a></h3><p ><span class='indexparent'><a class='index' id='numeric'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class InputIterator, class T&gt;
    T accumulate(InputIterator first, InputIterator last, T init);
  template &lt;class InputIterator, class T, class BinaryOperation&gt;
    T accumulate(InputIterator first, InputIterator last, T init,
                 BinaryOperation binary_op);

  template &lt;class InputIterator1, class InputIterator2, class T&gt;
    T inner_product(InputIterator1 first1, InputIterator1 last1,
                    InputIterator2 first2, T init);
  template &lt;class InputIterator1, class InputIterator2, class T,
            class BinaryOperation1, class BinaryOperation2&gt;
    T inner_product(InputIterator1 first1, InputIterator1 last1,
                    InputIterator2 first2, T init,
                    BinaryOperation1 binary_op1,
                    BinaryOperation2 binary_op2);

  template &lt;class InputIterator, class OutputIterator&gt;
    OutputIterator partial_sum(InputIterator first,
                               InputIterator last,
                               OutputIterator result);
  template &lt;class InputIterator, class OutputIterator,
            class BinaryOperation&gt;
    OutputIterator partial_sum(InputIterator first,
                               InputIterator last,
                               OutputIterator result,
                               BinaryOperation binary_op);

  template &lt;class InputIterator, class OutputIterator&gt;
    OutputIterator adjacent_difference(InputIterator first,
                                       InputIterator last,
                                       OutputIterator result);
  template &lt;class InputIterator, class OutputIterator,
            class BinaryOperation&gt;
    OutputIterator adjacent_difference(InputIterator first,
                                       InputIterator last,
                                       OutputIterator result,
                                       BinaryOperation binary_op);

  template &lt;class ForwardIterator, class T&gt;
    void iota(ForwardIterator first, ForwardIterator last, T value);
}
</pre><div class='para' id='overview-1'><div class='marginalizedparent'><a class='marginalized' href='#overview-1'>1</a></div><p >The requirements on the types of algorithms' arguments that are
described in the introduction to Clause <a href='algorithms'>[algorithms]</a> also
apply to the following algorithms.</p></div></div><div id='accumulate'><h3 ><a class='secnum' href='#accumulate' style='min-width:103pt'>26.7.2</a> Accumulate <a class='abbr_ref' href='accumulate'>[accumulate]</a></h3><p ><span class='indexparent'><a class='index' id='accumulate'></a></span><code class='itemdecl'>
template &lt;class InputIterator, class T&gt;
  T accumulate(InputIterator first, InputIterator last, T init);
template &lt;class InputIterator, class T, class BinaryOperation&gt;
  T accumulate(InputIterator first, InputIterator last, T init,
               BinaryOperation binary_op);
</code></p><div class='itemdescr'></div><div class='para' id='accumulate-1'><div class='marginalizedparent'><a class='marginalized' href='#accumulate-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Computes its result by initializing the accumulator
<span class='texttt'>acc</span>
with the initial value
<span class='texttt'>init</span>
and then modifies it with
<span class='texttt'>acc = acc + *i</span>
or
<span class='texttt'>acc = binary_op(acc, *i)</span>
for every iterator
<span class='texttt'>i</span>
in the range <span class='texttt'>[first,last)</span>
in order.<a class='footnotenum' href='#footnote-289'>289</a></p></div></div><div class='para' id='accumulate-2'><div class='marginalizedparent'><a class='marginalized' href='#accumulate-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>T</span> shall meet the requirements of <span class='texttt'>CopyConstructible</span> (Table <a href='copyconstructible'>[copyconstructible]</a>)
and <span class='texttt'>CopyAssignable</span> (Table <a href='copyassignable'>[copyassignable]</a>) types.
In the range
<span class='texttt'>[first,last]</span>,
<span class='texttt'>binary_op</span>
shall neither modify elements nor invalidate iterators or subranges.<a class='footnotenum' href='#footnote-290'>290</a>
</p></div></div><div class='footnote' id='footnote-288'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-288'>288)</a></div><p ><span class='texttt'>accumulate</span>
is similar to the APL reduction operator and Common Lisp reduce function, but
it avoids the difficulty of defining the result of reduction on an empty
sequence by always requiring an initial value.</p></div><div class='footnote' id='footnote-289'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-289'>289)</a></div><p >The use of fully closed ranges is intentional
</p></div></div><div id='inner.product'><h3 ><a class='secnum' href='#inner.product' style='min-width:103pt'>26.7.3</a> Inner product <a class='abbr_ref' href='inner.product'>[inner.product]</a></h3><p ><span class='indexparent'><a class='index' id='inner_product'></a></span>
<span class='indexparent'><a class='index' id='inner_product'></a></span><code class='itemdecl'>
template &lt;class InputIterator1, class InputIterator2, class T&gt;
  T inner_product(InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2, T init);
template &lt;class InputIterator1, class InputIterator2, class T,
    class BinaryOperation1, class BinaryOperation2&gt;
  T inner_product(InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2, T init,
                  BinaryOperation1 binary_op1,
                  BinaryOperation2 binary_op2);
</code></p><div class='itemdescr'></div><div class='para' id='inner.product-1'><div class='marginalizedparent'><a class='marginalized' href='#inner.product-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Computes its result by initializing the accumulator
<span class='texttt'>acc</span>
with the initial value
<span class='texttt'>init</span>
and then modifying it with
<span class='texttt'>acc = acc + (*i1) * (*i2)</span>
or
<span class='texttt'>acc = binary_op1(acc, binary_op2(*i1, *i2))</span>
for every iterator
<span class='texttt'>i1</span>
in the range <span class='texttt'>[first1,last1)</span>
and iterator
<span class='texttt'>i2</span>
in the range
<span class='texttt'>[first2,first2 + (last1 - first1))</span>
in order.</p></div></div><div class='para' id='inner.product-2'><div class='marginalizedparent'><a class='marginalized' href='#inner.product-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>T</span> shall meet the requirements of <span class='texttt'>CopyConstructible</span> (Table <a href='copyconstructible'>[copyconstructible]</a>)
and <span class='texttt'>CopyAssignable</span> (Table <a href='copyassignable'>[copyassignable]</a>) types.
In the ranges
<span class='texttt'>[first1,last1]</span>
and
<span class='texttt'>[first2,first2 + (last1 - first1)]</span>
<span class='texttt'>binary_op1</span>
and
<span class='texttt'>binary_op2</span>
shall neither modify elements nor invalidate iterators or subranges.<a class='footnotenum' href='#footnote-291'>291</a>
</p></div></div><div class='footnote' id='footnote-290'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-290'>290)</a></div><p >The use of fully closed ranges is intentional
</p></div></div><div id='partial.sum'><h3 ><a class='secnum' href='#partial.sum' style='min-width:103pt'>26.7.4</a> Partial sum <a class='abbr_ref' href='partial.sum'>[partial.sum]</a></h3><p ><span class='indexparent'><a class='index' id='partial_sum'></a></span><code class='itemdecl'>
template &lt;class InputIterator, class OutputIterator&gt;
  OutputIterator partial_sum(
    InputIterator first, InputIterator last,
    OutputIterator result);
template
  &lt;class InputIterator, class OutputIterator, class BinaryOperation&gt;
    OutputIterator partial_sum(
      InputIterator first, InputIterator last,
      OutputIterator result, BinaryOperation binary_op);
</code></p><div class='itemdescr'></div><div class='para' id='partial.sum-1'><div class='marginalizedparent'><a class='marginalized' href='#partial.sum-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> For a non-empty range,
the function creates an accumulator <span class='texttt'>acc</span> whose type is <span class='texttt'>InputIterator</span>'s
value type, initializes it with <span class='texttt'>*first</span>,
and assigns the result to <span class='texttt'>*result</span>. For every iterator <span class='texttt'>i</span> in <span class='texttt'>[first + 1,last)</span>
in order, <span class='texttt'>acc</span> is then modified by <span class='texttt'>acc = acc + *i</span> or <span class='texttt'>acc = binary_op(acc, *i)</span>
and the result is assigned to <span class='texttt'>*(result + (i - first))</span>.</p></div></div><div class='para' id='partial.sum-2'><div class='marginalizedparent'><a class='marginalized' href='#partial.sum-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>result + (last - first)</span>.</p></div></div><div class='para' id='partial.sum-3'><div class='marginalizedparent'><a class='marginalized' href='#partial.sum-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>(last - first) - 1</span>
applications of
the binary operation.</p></div></div><div class='para' id='partial.sum-4'><div class='marginalizedparent'><a class='marginalized' href='#partial.sum-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>InputIterator</span>'s value type shall be constructible from the type of <span class='texttt'>*first</span>.
The result of the expression <span class='texttt'>acc + *i</span> or <span class='texttt'>binary_op(acc, *i)</span> shall be
implicitly convertible to <span class='texttt'>InputIterator</span>'s value type. <span class='texttt'>acc</span>
shall be writable to the <span class='texttt'>result</span> output iterator.
In the ranges
<span class='texttt'>[first,last]</span>
and
<span class='mbox'><span class='texttt'>[result,result + (last - first)]</span></span>
<span class='texttt'>binary_op</span>
shall neither modify elements nor invalidate iterators or subranges.<a class='footnotenum' href='#footnote-292'>292</a></p></div></div><div class='para' id='partial.sum-5'><div class='marginalizedparent'><a class='marginalized' href='#partial.sum-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i>
<span class='texttt'>result</span>
may be equal to
<span class='texttt'>first</span>.
</p></div></div><div class='footnote' id='footnote-291'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-291'>291)</a></div><p >The use of fully closed ranges is intentional.
</p></div></div><div id='adjacent.difference'><h3 ><a class='secnum' href='#adjacent.difference' style='min-width:103pt'>26.7.5</a> Adjacent difference <a class='abbr_ref' href='adjacent.difference'>[adjacent.difference]</a></h3><p ><span class='indexparent'><a class='index' id='adjacent_difference'></a></span><code class='itemdecl'>
template &lt;class InputIterator, class OutputIterator&gt;
  OutputIterator adjacent_difference(
    InputIterator first, InputIterator last,
    OutputIterator result);
template &lt;class InputIterator, class OutputIterator, class BinaryOperation&gt;
  OutputIterator adjacent_difference(
    InputIterator first, InputIterator last,
    OutputIterator result,
    BinaryOperation binary_op);
</code></p><div class='itemdescr'><p ><i>Effects:</i> For a non-empty range,
the function creates an accumulator <span class='texttt'>acc</span> whose type is <span class='texttt'>InputIterator</span>'s
value type, initializes it with <span class='texttt'>*first</span>,
and assigns the result to <span class='texttt'>*result</span>. For every iterator <span class='texttt'>i</span> in <span class='texttt'>[first + 1,last)</span>
in order, creates an object <span class='texttt'>val</span> whose type is <span class='texttt'>InputIterator</span>'s value type, initializes it
with *i, computes <span class='texttt'>val - acc</span> or <span class='texttt'>binary_op(val, acc)</span>, assigns the result
to <span class='texttt'>*(result + (i - first))</span>, and move assigns from <span class='texttt'>val</span> to <span class='texttt'>acc</span>.</p></div><div class='para' id='adjacent.difference-1'><div class='marginalizedparent'><a class='marginalized' href='#adjacent.difference-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>InputIterator</span>'s value type shall be <span class='texttt'>MoveAssignable</span> (Table <a href='moveassignable'>[moveassignable]</a>)
and shall be constructible from the type of <span class='texttt'>*first</span>. <span class='texttt'>acc</span> shall be
writable to the <span class='texttt'>result</span> output iterator. The result of the expression <span class='texttt'>val - acc</span>
or <span class='texttt'>binary_op(val, acc)</span> shall be writable to the <span class='texttt'>result</span> output iterator.
In the ranges
<span class='texttt'>[first,last]</span>
and
<span class='texttt'>[result,result + (last - first)]</span>,
<span class='texttt'>binary_op</span>
shall neither modify elements nor invalidate iterators or
subranges.<a class='footnotenum' href='#footnote-293'>293</a></p></div></div><div class='para' id='adjacent.difference-2'><div class='marginalizedparent'><a class='marginalized' href='#adjacent.difference-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i>
<span class='texttt'>result</span>
may be equal to
<span class='texttt'>first</span>.</p></div></div><div class='para' id='adjacent.difference-3'><div class='marginalizedparent'><a class='marginalized' href='#adjacent.difference-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>result + (last - first)</span>.</p></div></div><div class='para' id='adjacent.difference-4'><div class='marginalizedparent'><a class='marginalized' href='#adjacent.difference-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i>
Exactly
<span class='texttt'>(last - first) - 1</span>
applications of
the binary operation.
</p></div></div><div class='footnote' id='footnote-292'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-292'>292)</a></div><p >The use of fully closed ranges is intentional.</p></div></div><div id='numeric.iota'><h3 ><a class='secnum' href='#numeric.iota' style='min-width:103pt'>26.7.6</a> Iota <a class='abbr_ref' href='numeric.iota'>[numeric.iota]</a></h3><p ><span class='indexparent'><a class='index' id='iota'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator, class T&gt;
  void iota(ForwardIterator first, ForwardIterator last, T value);
</code></p><div class='itemdescr'></div><div class='para' id='numeric.iota-1'><div class='marginalizedparent'><a class='marginalized' href='#numeric.iota-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be convertible to <span class='texttt'>ForwardIterator</span>'s value
type. The expression <span class='texttt'>++val</span>, where <span class='texttt'>val</span> has type <span class='texttt'>T</span>, shall
be well formed.</p></div></div><div class='para' id='numeric.iota-2'><div class='marginalizedparent'><a class='marginalized' href='#numeric.iota-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> For each element referred to by the iterator <span class='texttt'>i</span> in the range
<span class='texttt'>[first,last)</span>, assigns <span class='texttt'>*i = value</span> and increments <span class='texttt'>value</span> as
if by <span class='texttt'>++value</span>.</p></div></div><div class='para' id='numeric.iota-3'><div class='marginalizedparent'><a class='marginalized' href='#numeric.iota-3'>3</a></div><div class='itemdescr'><p ><i>Complexity:</i> Exactly <span class='texttt'>last - first</span> increments and assignments.
</p></div></div></div></div></div></body></html>