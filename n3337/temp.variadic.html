<!DOCTYPE html><html lang='en'><head><title>[temp.variadic]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.5</a> Template declarations <a class='abbr_ref' href='temp.decls#temp.variadic'>[temp.decls]</a></h2><div id='temp.variadic'><h3 ><a class='secnum' style='min-width:103pt'>14.5.3</a> Variadic templates <a class='abbr_ref'>[temp.variadic]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A <a class='hidden_link' href='#def:template_parameter_pack' id='def:template_parameter_pack'><i>template parameter pack</i></a> is a template parameter
that accepts zero or more template arguments. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class ... Types&gt; struct Tuple { };

Tuple&lt;&gt; t0;                     <span class='comment'>// <span class='texttt'>Types</span> contains no arguments
</span>Tuple&lt;int&gt; t1;                  <span class='comment'>// <span class='texttt'>Types</span> contains one argument: <span class='texttt'>int</span>
</span>Tuple&lt;int, float&gt; t2;           <span class='comment'>// <span class='texttt'>Types</span> contains two arguments: <span class='texttt'>int</span> and <span class='texttt'>float</span>
</span>Tuple&lt;0&gt; error;                 <span class='comment'>// error: 0 is not a type
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A <a class='hidden_link' href='#def:function_parameter_pack' id='def:function_parameter_pack'><i>function parameter pack</i></a> is a function parameter
that accepts zero or more function arguments. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class ... Types&gt; void f(Types ... args);

f();                <span class='comment'>// OK: <span class='texttt'>args</span> contains no arguments
</span>f(1);               <span class='comment'>// OK: <span class='texttt'>args</span> contains one argument: <span class='texttt'>int</span>
</span>f(2, 1.0);          <span class='comment'>// OK: <span class='texttt'>args</span> contains two arguments: <span class='texttt'>int</span> and <span class='texttt'>double</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A <a class='hidden_link' href='#def:parameter_pack' id='def:parameter_pack'><i>parameter pack</i></a> is either a template parameter
pack or a function parameter pack.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >A <a class='hidden_link' href='#def:pack_expansion' id='def:pack_expansion'><i>pack expansion</i></a>
consists of a <a class='hidden_link' href='#def:pattern' id='def:pattern'><i>pattern</i></a> and an ellipsis, the instantiation of which
produces zero or more instantiations of the pattern in a list (described below).
The form of the pattern
depends on the context in which the expansion occurs. Pack
expansions can occur in the following contexts:</p><ul ><li ><p >In a function parameter pack (<a href='dcl.fct'>[dcl.fct]</a>); the pattern is the
<i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> without the ellipsis.</p></li><li ><p >In a template parameter pack that is a pack expansion (<a href='temp.param'>[temp.param]</a>):</p><ul ><li ><p >if the template parameter pack is a <i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i>;
the pattern is the <i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> without the ellipsis;</p></li><li ><p >if the template parameter pack is a <i ><a href='temp.param#nt:type-parameter'>type-parameter</a></i> with a
<i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i>; the pattern is the corresponding
<i ><a href='temp.param#nt:type-parameter'>type-parameter</a></i> without the ellipsis.
</p></li></ul></li><li ><p >In an <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> (<a href='dcl.init'>[dcl.init]</a>);
the pattern is an <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>.</p></li><li ><p >In a <i ><a href='class.derived#nt:base-specifier-list'>base-specifier-list</a></i> (Clause <a href='class.derived'>[class.derived]</a>);
the pattern is a <i ><a href='class.derived#nt:base-specifier'>base-specifier</a></i>.</p></li><li ><p >In a <i ><a href='class.base.init#nt:mem-initializer-list'>mem-initializer-list</a></i> (<a href='class.base.init'>[class.base.init]</a>);
the pattern is a <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>.</p></li><li ><p >In a <i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i> (<a href='temp.arg'>[temp.arg]</a>);
the pattern is a <i ><a href='temp.names#nt:template-argument'>template-argument</a></i>.</p></li><li ><p >In a <i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specification</a></i> (<a href='except.spec'>[except.spec]</a>);
the pattern is a <i ><a href='dcl.name#nt:type-id'>type-id</a></i>.</p></li><li ><p >In an <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i> (<a href='dcl.attr.grammar'>[dcl.attr.grammar]</a>); the pattern is
an <i ><a href='dcl.attr.grammar#nt:attribute'>attribute</a></i>.</p></li><li ><p >In an <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i> (<a href='dcl.align'>[dcl.align]</a>); the pattern is
the <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i> without the ellipsis.</p></li><li ><p >In a <i ><a href='expr.prim.lambda#nt:capture-list'>capture-list</a></i> (<a href='expr.prim.lambda'>[expr.prim.lambda]</a>); the pattern is
a <i ><a href='expr.prim.lambda#nt:capture'>capture</a></i>.</p></li><li ><p >In a <span class='texttt'>sizeof...</span> expression (<a href='expr.sizeof'>[expr.sizeof]</a>); the pattern is an
<i ><a href='lex.name#nt:identifier'>identifier</a></i>.
</p></li></ul><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class ... Types&gt; void f(Types ... rest);
template&lt;class ... Types&gt; void g(Types ... rest) {
  f(&amp;rest ...);     <span class='comment'>// “<span class='texttt'>&amp;rest ...</span>” is a pack expansion; “<span class='texttt'>&amp;rest</span>” is its pattern
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A parameter pack whose name appears within the pattern of a pack
expansion is expanded by that pack expansion. An appearance of the name of
a parameter pack is only expanded by the innermost enclosing pack expansion.
The pattern of a pack expansion shall name one or more parameter packs that
are not expanded by a nested pack expansion; such parameter packs are called
<a class='hidden_link' href='#def:unexpanded' id='def:unexpanded'><i>unexpanded</i></a> parameter packs in the pattern. All of the parameter packs expanded
by a pack expansion shall have the same number of arguments specified. An
appearance of a name of a parameter pack that is not expanded is
ill-formed. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;typename...&gt; struct Tuple {};
template&lt;typename T1, typename T2&gt; struct Pair {};

template&lt;class ... Args1&gt; struct zip {
  template&lt;class ... Args2&gt; struct with {
    typedef Tuple&lt;Pair&lt;Args1, Args2&gt; ... &gt; type;
  };
};

typedef zip&lt;short, int&gt;::with&lt;unsigned short, unsigned&gt;::type T1;
    <span class='comment'>// <span class='texttt'>T1</span> is <span class='texttt'>Tuple&lt;Pair&lt;short, unsigned short&gt;, Pair&lt;int, unsigned&gt;&gt;</span>
</span>typedef zip&lt;short&gt;::with&lt;unsigned short, unsigned&gt;::type T2;
    <span class='comment'>// error: different number of arguments specified for <span class='texttt'>Args1</span> and <span class='texttt'>Args2</span>
</span>
template&lt;class ... Args&gt;
  void g(Args ... args) {               <span class='comment'>// OK: <span class='texttt'>Args</span> is expanded by the function parameter pack <span class='texttt'>args</span>
</span>    f(const_cast&lt;const Args*&gt;(&amp;args)...); <span class='comment'>// OK: “<span class='texttt'>Args</span>” and “<span class='texttt'>args</span>” are expanded
</span>    f(5 ...);                             <span class='comment'>// error: pattern does not contain any parameter packs
</span>    f(args);                              <span class='comment'>// error: parameter pack “<span class='texttt'>args</span>” is not expanded
</span>    f(h(args ...) + args ...);            <span class='comment'>// OK: first “<span class='texttt'>args</span>” expanded within <span class='texttt'>h</span>, second
</span>                                          <span class='comment'>// “<span class='texttt'>args</span>” expanded within <span class='texttt'>f</span>
</span>  }
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >The instantiation of a pack expansion
that is not a <span class='texttt'>sizeof...</span> expression
produces a
list
<span class='math'><span class='mathtt'>E</span><sub >1</sub>, <span class='mathtt'>E</span><sub >2</sub>, ..., <span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span></sub></span>,
where
<span class='math'><span class='mathalpha'>N</span></span> is the number of elements in the pack expansion parameters. Each
<span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>i</span></sub></span> is generated by instantiating the pattern and
replacing each pack expansion parameter with its <span class='math'><span class='mathalpha'>i</span></span>th element.
All of the <span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>i</span></sub></span> become elements in the enclosing list.
[&nbsp;<i>Note:</i> The variety of list varies with the context:
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>,
<i ><a href='class.derived#nt:base-specifier-list'>base-specifier-list</a></i>,
<i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i>, etc.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
When <span class='math'><span class='mathalpha'>N</span></span> is zero, the instantiation of the expansion produces an empty list.
Such an instantiation does not alter the syntactic interpretation of the
enclosing construct, even in cases where omitting the list entirely would
otherwise be ill-formed or would result in an ambiguity in the grammar.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class... T&gt; struct X : T... { };
template&lt;class... T&gt; void f(T... values) {
  X&lt;T...&gt; x(values...);
}

template void f&lt;&gt;();  <span class='comment'>// OK: <span class='texttt'>X&lt;&gt;</span> has no base classes
</span>                      <span class='comment'>// <span class='texttt'>x</span> is a variable of type <span class='texttt'>X&lt;&gt;</span> that is value-initialized
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >The instantiation of a <span class='texttt'>sizeof...</span> expression (<a href='expr.sizeof'>[expr.sizeof]</a>) produces
an integral constant containing the number of elements in the parameter pack
it expands.</p></div></div></div></body></html>