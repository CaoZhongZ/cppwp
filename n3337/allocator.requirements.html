<!DOCTYPE html><html lang='en'><head><title>[allocator.requirements]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>17</a> Library introduction <a class='abbr_ref' href='./#library'>[library]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>17.6</a> Library-wide requirements <a class='abbr_ref' href='requirements#allocator.requirements'>[requirements]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>17.6.3</a> Requirements on types and expressions <a class='abbr_ref' href='utility.requirements#allocator.requirements'>[utility.requirements]</a></h3><div id='allocator.requirements'><h4 ><a class='secnum' style='min-width:118pt'>17.6.3.5</a> Allocator requirements <a class='abbr_ref'>[allocator.requirements]</a></h4><p ><span class='indexparent'><a class='index' id='requirements,Allocator'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The library describes a standard set of requirements for <i>allocators</i>,
which are class-type objects that encapsulate the information about an allocation model.
This information includes the knowledge of pointer types, the type of their
difference, the type of the size of objects in this allocation model, as well
as the memory allocation and deallocation primitives for it. All of the
string types (Clause <a href='strings'>[strings]</a>),
containers (Clause <a href='containers'>[containers]</a>) (except array),
string buffers and string streams (Clause <a href='input.output'>[input.output]</a>), and
<span class='texttt'>match_results</span> (Clause <a href='re'>[re]</a>) are parameterized in terms of
allocators.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The template struct <span class='texttt'>allocator_traits</span> (<a href='allocator.traits'>[allocator.traits]</a>) supplies
a uniform interface to all allocator types.
Table <a href='#tab:desc.var.def'>[tab:desc.var.def]</a> describes the types manipulated
through allocators. Table <a href='#tab:utilities.allocator.requirements'>[tab:utilities.allocator.requirements]</a>
describes the requirements on allocator types
and thus on types used to instantiate <span class='texttt'>allocator_traits</span>. A requirement
is optional if the last column of
Table <a href='#tab:utilities.allocator.requirements'>[tab:utilities.allocator.requirements]</a> specifies a default for a
given expression. Within the standard library <span class='texttt'>allocator_traits</span>
template, an optional requirement that is not supplied by an allocator is
replaced by the specified default expression. A user specialization of
<span class='texttt'>allocator_traits</span> may provide different defaults and may provide
defaults for different requirements than the primary template. Within
Tables <a href='#tab:desc.var.def'>[tab:desc.var.def]</a> and <a href='#tab:utilities.allocator.requirements'>[tab:utilities.allocator.requirements]</a>,
the use of <span class='texttt'>move</span> and <span class='texttt'>forward</span> always refers to <span class='texttt'>std::move</span>
and <span class='texttt'>std::forward</span>, respectively.</p><div class='numberedTable' id='tab:desc.var.def'>Table <a href='#tab:desc.var.def'>27</a> — Descriptive variable definitions<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Variable</b></td><td colspan='1' class='center'><b>Definition</b></td></tr><tr class='capsep'><td class='left'>  
<span class='endhead'></span>
<span class='texttt'>T, U, C</span>    </td><td class='left'>   any non-const object type (<a href='basic.types'>[basic.types]</a>)       </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>V</span>       </td><td class='left'>   a type convertible to <span class='texttt'>T</span>         </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>X</span>       </td><td class='left'>   an Allocator class for type <span class='texttt'>T</span>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>Y</span>       </td><td class='left'>   the corresponding Allocator class for type <span class='texttt'>U</span>    </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>XX</span>      </td><td class='left'>   the type <span class='texttt'>allocator_traits&lt;X&gt;</span>    </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>YY</span>      </td><td class='left'>   the type <span class='texttt'>allocator_traits&lt;Y&gt;</span>    </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>t</span>       </td><td class='left'>   a value of type <span class='texttt'>const T&amp;</span>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>a, a1, a2</span>   </td><td class='left'>   values of type <span class='texttt'>X&amp;</span>      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>a3</span>      </td><td class='left'>   an rvalue of type <span class='texttt'>X</span>      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>b</span>       </td><td class='left'>   a value of type <span class='texttt'>Y</span>           </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>c</span>       </td><td class='left'>   a dereferenceable pointer of type <span class='texttt'>C*</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>p</span>       </td><td class='left'>   a value of type <span class='texttt'>XX::pointer</span>, obtained
by calling <span class='texttt'>a1.allocate</span>, where <span class='texttt'>a1 == a</span>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>q</span>       </td><td class='left'>   a value of type <span class='texttt'>XX::const_pointer</span>
obtained by conversion from a value <span class='texttt'>p</span>.          </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>w</span>       </td><td class='left'>   a value of type <span class='texttt'>XX::void_pointer</span> obtained by
  conversion from a value <span class='texttt'>p</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>z</span>       </td><td class='left'>   a value of type <span class='texttt'>XX::const_void_pointer</span> obtained by
  conversion from a value <span class='texttt'>q</span> or a value <span class='texttt'>w</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>r</span>       </td><td class='left'>   a value of type <span class='texttt'>T&amp;</span>
obtained by the expression <span class='texttt'>*p</span>.                  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>s</span>       </td><td class='left'>   a value of type <span class='texttt'>const T&amp;</span>
obtained by the expression <span class='texttt'>*q</span> or by conversion from
a value <span class='texttt'>r</span>.                                      </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>u</span>       </td><td class='left'>   a value of type <span class='texttt'>YY::const_pointer</span>
obtained by calling <span class='texttt'>YY::allocate</span>, or else <span class='texttt'>nullptr</span>. </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>v</span>       </td><td class='left'>   a value of type <span class='texttt'>V</span>               </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>n</span>       </td><td class='left'>   a value of type <span class='texttt'>XX::size_type</span>.   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>Args</span>    </td><td class='left'>   a template parameter pack               </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>args</span>    </td><td class='left'>   a function parameter pack with the pattern <span class='texttt'>Args&amp;&amp;</span> </td></tr></table></div><div class='numberedTable' id='tab:utilities.allocator.requirements'>Table <a href='#tab:utilities.allocator.requirements'>28</a> — Allocator requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Assertion/note</b></td><td colspan='1' class='center'><b>Default</b></td></tr><tr ><td class='left'>
                    </td><td class='left'>                       </td><td colspan='1' class='center'><b>pre-/post-condition</b></td><td class='left'>   </td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span>
<span class='texttt'>X::pointer</span>          </td><td class='left'>          </td><td class='left'>   </td><td class='left'> <span class='texttt'>T*</span> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::const_pointer</span>    </td><td class='left'>
   </td><td class='left'>
  <span class='texttt'>X::pointer</span> is convertible to <span class='texttt'>X::const_pointer</span>   </td><td class='left'>
  <span class='texttt'>pointer_traits&lt;X::<span class='discretionary'></span>pointer&gt;::<span class='discretionary'></span>rebind&lt;const T&gt;</span>             </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::void_pointer</span><span class='hfill'></span><br/><span class='texttt'>Y::void_pointer</span> </td><td class='left'>
                                                  </td><td class='left'>
  <span class='texttt'>X::pointer</span> is convertible to <span class='texttt'>X::void_pointer</span>.
  <span class='texttt'>X::void_pointer</span> and <span class='texttt'>Y::void_pointer</span> are the same type.  </td><td class='left'>
  <span class='texttt'>pointer_traits&lt;X::<span class='discretionary'></span>pointer&gt;::<span class='discretionary'></span>rebind&lt;void&gt;</span> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::const_void_pointer</span><span class='hfill'></span><br/><span class='texttt'>Y::const_void_pointer</span> </td><td class='left'>
                                                  </td><td class='left'>
  <span class='texttt'>X::pointer</span>, <span class='texttt'>X::const_pointer</span>, and <span class='texttt'>X::void_pointer</span> are convertible to <span class='texttt'>X::const_void_pointer</span>.
  <span class='texttt'>X::const_void_pointer</span> and <span class='texttt'>Y::const_void_pointer</span> are the same type.  </td><td class='left'>
  <span class='texttt'>pointer_traits&lt;X::<span class='discretionary'></span>pointer&gt;::<span class='discretionary'></span>rebind&lt;const void&gt;</span> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::value_type</span>       </td><td class='left'>
  Identical to <span class='texttt'>T</span>    </td><td class='left'>   </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::size_type</span>        </td><td class='left'>
  unsigned integer type     </td><td class='left'>
  a type that can represent the size of the largest object in the allocation model. </td><td class='left'>
  <span class='texttt'>make_unsigned&lt;X::<span class='discretionary'></span>difference_type&gt;::type</span> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::difference_type</span>  </td><td class='left'>
  signed integer type       </td><td class='left'>
  a type that can represent the difference between any two pointers
    in the allocation model.</td><td class='left'>
  <span class='texttt'>pointer_traits&lt;X::<span class='discretionary'></span>pointer&gt;::<span class='discretionary'></span>difference_type</span> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>typename X::template rebind&lt;U&gt;::other</span>   </td><td class='left'>
  <span class='texttt'>Y</span>                 </td><td class='left'>
  For all <span class='texttt'>U</span> (including <span class='texttt'>T</span>), <span class='texttt'>Y::template rebind&lt;T&gt;::other</span>
    is <span class='texttt'>X</span>.           </td><td class='left'>
  See Note A, below.        </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>*p</span>                  </td><td class='left'>
  <span class='texttt'>T&amp;</span>               </td><td class='left'></td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>*q</span>                  </td><td class='left'>
  <span class='texttt'>const T&amp;</span>         </td><td class='left'>
  <span class='texttt'>*q</span> refers to the same object as <span class='texttt'>*p</span></td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>p-&gt;m</span>                </td><td class='left'>
  type of <span class='texttt'>T::m</span>      </td><td class='left'>
  <i>pre:</i> <span class='texttt'>(*p).m</span> is well-defined. equivalent to <span class='texttt'>(*p).m</span>  </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>q-&gt;m</span>                </td><td class='left'>
  type of <span class='texttt'>T::m</span>      </td><td class='left'>
  <i>pre:</i> <span class='texttt'>(*q).m</span> is well-defined. equivalent to <span class='texttt'>(*q).m</span>  </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>static_-</span> <span class='texttt'>cast&lt;X::pointer&gt;(w)</span>  </td><td class='left'>
  <span class='texttt'>X::pointer</span>                </td><td class='left'>
  <span class='texttt'>static_cast&lt;X::pointer&gt;(w)</span> <span class='texttt'>== p</span> </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>static_cast&lt;X</span> <span class='texttt'>::const_pointer&gt;(z)</span>  </td><td class='left'>
  <span class='texttt'>X::const_pointer</span>                </td><td class='left'>
  <span class='texttt'>static_cast&lt;X</span> <span class='texttt'>::const_pointer&gt;(z)</span> <span class='texttt'>== q</span> </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.allocate(n)</span>   </td><td class='left'>   <span class='texttt'>X::pointer</span>  </td><td class='left'>
Memory is allocated for <span class='texttt'>n</span> objects of type <span class='texttt'>T</span> but objects
are not constructed. <span class='texttt'>allocate</span> may raise an appropriate exception.<a class='footnotenum' href='#footnote-181'>181</a>
[&nbsp;<i>Note:</i>
If <span class='texttt'>n == 0</span>, the return value is unspecified.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]              </td><td class='left'>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.allocate(n, u)</span>    </td><td class='left'>
  <span class='texttt'>X::pointer</span>        </td><td class='left'>
  Same as <span class='texttt'>a.allocate(n)</span>. The use of <span class='texttt'>u</span> is unspecified, but
    it is intended as an aid to locality. </td><td class='left'>
  <span class='texttt'>a.allocate(n)</span>     </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.deallocate(p,n)</span>   </td><td class='left'>
  (not used)                </td><td class='left'>
  All <span class='texttt'>n T</span> objects in the area pointed to by <span class='texttt'>p</span> shall be
    destroyed prior to this call. <span class='texttt'>n</span> shall match the value passed to
    <span class='texttt'>allocate</span> to obtain this memory. Does not throw exceptions.
    [&nbsp;<i>Note:</i> <span class='texttt'>p</span> shall not be singular.<i>&nbsp;—&nbsp;end note</i>&nbsp;]   </td><td class='left'>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.max_size()</span>        </td><td class='left'>
  <span class='texttt'>X::size_type</span>      </td><td class='left'>
  the largest value that can meaningfully be passed to <span class='texttt'>X::allocate()</span>  </td><td class='left'>
  <span class='texttt'>numeric_limits&lt;size_type&gt;::max()</span>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a1 == a2</span>            </td><td class='left'>
  <span class='texttt'>bool</span>              </td><td class='left'>
  returns <span class='texttt'>true</span> only if storage allocated from each can
    be deallocated via the other. <span class='texttt'>operator==</span> shall be reflexive, symmetric,
    and transitive, and shall not exit via an exception. </td><td class='left'>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a1 != a2</span>            </td><td class='left'>
  <span class='texttt'>bool</span>              </td><td class='left'>
  same as <span class='texttt'>!(a1 == a2)</span>     </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a == b</span>              </td><td class='left'>
  <span class='texttt'>bool</span>              </td><td class='left'>
  same as <span class='texttt'>a ==</span> <span class='texttt'>Y::rebind&lt;T&gt;::other(b)</span> </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a != b</span>              </td><td class='left'>
  <span class='texttt'>bool</span>              </td><td class='left'>
  same as <span class='texttt'>!(a == b)</span> </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X a1(a)</span>;            </td><td class='left'>
                            </td><td class='left'>
  Shall not exit via an exception.<span class='hfill'></span><br/>
  post: <span class='texttt'>a1 == a</span>     </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X a(b);</span>             </td><td class='left'>
                            </td><td class='left'>
  Shall not exit via an exception.<span class='hfill'></span><br/>
  post: <span class='texttt'>Y(a) == b</span>, <span class='texttt'>a == X(b)</span> </td><td class='left'>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X a1(move(a));</span>      </td><td class='left'>
                            </td><td class='left'>
  Shall not exit via an exception.<span class='hfill'></span><br/>
  post: <span class='texttt'>a1</span> equals the prior value of <span class='texttt'>a</span>. </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X a(move(b));</span>       </td><td class='left'>
                            </td><td class='left'>
  Shall not exit via an exception.<span class='hfill'></span><br/>
  post: <span class='texttt'>a</span> equals the prior value of <span class='texttt'>X(b)</span>. </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.construct(c, args)</span></td><td class='left'>
  (not used)                </td><td class='left'>
  Effect: Constructs an object of type <span class='texttt'>C</span> at
    <span class='texttt'>c</span>               </td><td class='left'>
  <span class='texttt'>::new ((void*)c) C(forward&lt;<span class='discretionary'></span>Args&gt;<span class='discretionary'></span>(args)...)</span>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.destroy(c)</span>        </td><td class='left'>
  (not used)                </td><td class='left'>
  Effect: Destroys the object at <span class='texttt'>c</span>  </td><td class='left'>
  <span class='texttt'>c-&gt;~C()</span>           </td></tr><tr class='rowsep'><td class='left'>  <span class='texttt'>a.select_on_container_copy_construction()</span> </td><td class='left'>
  <span class='texttt'>X</span>                 </td><td class='left'>
  Typically returns either <span class='texttt'>a</span> or <span class='texttt'>X()</span> </td><td class='left'>
  <span class='texttt'>return a;</span>         </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::propagate_on_container_copy_assignment</span> </td><td class='left'>
  Identical to or derived from <span class='texttt'>true_type</span> or <span class='texttt'>false_type</span>  </td><td class='left'>
  <span class='texttt'>true_type</span> only if an allocator of type <span class='texttt'>X</span> should be copied
    when the client container is copy-assigned.   </td><td class='left'>
  <span class='texttt'>false_type</span>        </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::propagate_on_container_move_assignment</span> </td><td class='left'>
  Identical to or derived from <span class='texttt'>true_type</span> or <span class='texttt'>false_type</span>  </td><td class='left'>
  <span class='texttt'>true_type</span> only if an allocator of type <span class='texttt'>X</span> should be moved
    when the client container is move-assigned.   </td><td class='left'>
  <span class='texttt'>false_type</span>        </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::propagate_on_-</span> <span class='texttt'>container_swap</span> </td><td class='left'>
  Identical to or derived from <span class='texttt'>true_type</span> or <span class='texttt'>false_type</span>  </td><td class='left'>
  <span class='texttt'>true_type</span> only if an allocator of type <span class='texttt'>X</span> should be swapped
    when the client container is swapped.   </td><td class='left'>
  <span class='texttt'>false_type</span>        </td></tr></table></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >Note A: The member class template <span class='texttt'>rebind</span> in the table above is
effectively a typedef template. [&nbsp;<i>Note:</i> In general, if
the name <span class='texttt'>Allocator</span> is bound to <span class='texttt'>SomeAllocator&lt;T&gt;</span>, then
<span class='texttt'>Allocator::rebind&lt;U&gt;::other</span> is the same type as
<span class='texttt'>SomeAllocator&lt;U&gt;</span>, where
<span class='texttt'>SomeAllocator&lt;T&gt;::value_type</span> is <span class='texttt'>T</span> and
<span class='texttt'>SomeAllocator&lt;U&gt;::<span class='discretionary'></span>value_type</span> is <span class='texttt'>U</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] If
<span class='texttt'>Allocator</span> is a class template instantiation of the form
<span class='texttt'>SomeAllocator&lt;T, Args&gt;</span>, where <span class='texttt'>Args</span> is zero or more type
arguments, and <span class='texttt'>Allocator</span> does not supply a <span class='texttt'>rebind</span> member
template, the standard <span class='texttt'>allocator_traits</span> template uses
<span class='texttt'>SomeAllocator&lt;U, Args&gt;</span> in place of <span class='texttt'>Allocator::<span class='discretionary'></span>rebind&lt;U&gt;::other</span>
by default. For allocator types that are not template instantiations of the
above form, no default is provided.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The <span class='texttt'>X::pointer</span>, <span class='texttt'>X::const_pointer</span>, <span class='texttt'>X::void_pointer</span>, and
<span class='texttt'>X::const_void_pointer</span> types shall satisfy the requirements of
<span class='texttt'>NullablePointer</span> (<a href='nullablepointer.requirements'>[nullablepointer.requirements]</a>).
No constructor,
comparison operator, copy operation, move operation, or swap operation on
these types shall exit via an exception. <span class='texttt'>X::pointer</span> and <span class='texttt'>X::const_pointer</span> shall also
satisfy the requirements for a random access
iterator (<a href='iterator.requirements'>[iterator.requirements]</a>).</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >An allocator may constrain the types on which it can be instantiated and the
arguments for which its <span class='texttt'>construct</span> member may be called. If a type
cannot be used with a particular allocator, the allocator class or the call to
<span class='texttt'>construct</span> may fail to instantiate.</p><p >[&nbsp;<i>Example:</i> the following is an allocator class template supporting the minimal
interface that satisfies the requirements of
Table <a href='#tab:utilities.allocator.requirements'>[tab:utilities.allocator.requirements]</a>:</p><pre class='codeblock'>
template &lt;class Tp&gt;
struct SimpleAllocator {
  typedef Tp value_type;
  SimpleAllocator(<i>ctor args</i>);

  template &lt;class T&gt; SimpleAllocator(const SimpleAllocator&lt;T&gt;&amp; other);

  Tp *allocate(std::size_t n);
  void deallocate(Tp *p, std::size_t n);
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >If the alignment associated with a specific over-aligned type is not
supported by an allocator, instantiation of the allocator for that type may
fail. The allocator also may silently ignore the requested alignment.
[&nbsp;<i>Note:</i> Additionally, the member function <span class='texttt'>allocate</span>
for that type may fail by throwing an object of type
<span class='texttt'>std::bad_alloc</span>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-180'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-180'>180)</a></div><p >It is intended that <span class='texttt'>a.allocate</span> be an efficient means
of allocating a single object of type <span class='texttt'>T</span>, even when <span class='texttt'>sizeof(T)</span>
is small. That is, there is no need for a container to maintain its own
free list.</p></div></div></div></body></html>