<!DOCTYPE html><html lang='en'><head><title>[class.union]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>9</a> Classes <a class='abbr_ref' href='./#class'>[class]</a></h1><div id='class.union'><h2 ><a class='secnum' style='min-width:88pt'>9.5</a> Unions <a class='abbr_ref'>[class.union]</a></h2><p ><span class='indexparent'><a class='index' id='union'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >In a union, at most one of the non-static data members can be active at any
time, that is, the value of at most one of the non-static data members can be
stored in a union at any time. [&nbsp;<i>Note:</i> One special guarantee is made in order to
simplify the use of unions: If a standard-layout union contains several standard-layout
structs that share a common initial sequence (<a href='class.mem'>[class.mem]</a>), and if an object of this
standard-layout union type contains one of the standard-layout structs, it is permitted
to inspect the common initial sequence of any of standard-layout struct members;
see <a href='class.mem'>[class.mem]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] The size of a union is sufficient to contain the largest
of its non-static data members. Each non-static data member is allocated
as if it were the sole member of a struct.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='member_function,union'></a></span><span class='indexparent'><a class='index' id='constructor,union'></a></span><span class='indexparent'><a class='index' id='destructor,union'></a></span>A union can have member functions (including constructors and destructors),
<span class='indexparent'><a class='index' id='restriction,union'></a></span>but not virtual (<a href='class.virtual'>[class.virtual]</a>) functions. A union shall not have
base classes. A union shall not be used as a base class.
<span class='indexparent'><a class='index' id='restriction,union'></a></span>If a union contains a non-static data member of
reference type the program is ill-formed.
At most one non-static data member of a union may have a
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i>.
[&nbsp;<i>Note:</i> If any non-static data member of a union has a non-trivial
default constructor (<a href='class.ctor'>[class.ctor]</a>),
copy constructor (<a href='class.copy'>[class.copy]</a>),
move constructor (<a href='class.copy'>[class.copy]</a>),
copy assignment operator (<a href='class.copy'>[class.copy]</a>),
move assignment operator (<a href='class.copy'>[class.copy]</a>),
or destructor (<a href='class.dtor'>[class.dtor]</a>), the corresponding member function
of the union must be user-provided or it will
be implicitly deleted (<a href='dcl.fct.def.delete'>[dcl.fct.def.delete]</a>) for the union. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >[&nbsp;<i>Example:</i> Consider the following union:</p><pre class='codeblock'>
union U {
  int i;
  float f;
  std::string s;
};
</pre><p >Since <span class='texttt'>std::string</span> (<a href='string.classes'>[string.classes]</a>) declares non-trivial versions of all of the special
member functions, <span class='texttt'>U</span> will have an implicitly deleted default constructor,
copy/move constructor,
copy/move assignment operator, and destructor.
To use <span class='texttt'>U</span>, some or all of these member functions
must be user-provided.<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >[&nbsp;<i>Note:</i> In general, one must use explicit destructor calls and placement
new operators to change the active member of a union. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
Consider an object <span class='texttt'>u</span> of a <span class='texttt'>union</span> type <span class='texttt'>U</span> having non-static data members
<span class='texttt'>m</span> of type <span class='texttt'>M</span> and <span class='texttt'>n</span> of type <span class='texttt'>N</span>. If <span class='texttt'>M</span> has a non-trivial
destructor and <span class='texttt'>N</span> has a non-trivial constructor (for instance, if they declare or inherit
virtual functions), the active member of <span class='texttt'>u</span> can be safely switched from <span class='texttt'>m</span> to
<span class='texttt'>n</span> using the destructor and placement new operator as follows:</p><pre class='codeblock'>
u.m.~M();
new (&amp;u.n) N;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='union,anonymous'></a></span>A union of the form</p><pre class='bnf'><span class='terminal'>union</span> { <i ><a href='class.mem#nt:member-specification'>member-specification</a></i> } ;</pre><p >is called an anonymous union; it defines an unnamed object of unnamed
type. The <i ><a href='class.mem#nt:member-specification'>member-specification</a></i> of an anonymous union shall
only define non-static data members.
[&nbsp;<i>Note:</i>
Nested types and functions cannot be declared within an anonymous union.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The names of the members of an anonymous union shall be distinct from
the names of any other entity in the scope in which the anonymous union
is declared. For the purpose of name lookup, after the anonymous union
definition, the members of the anonymous union are considered to have
been defined in the scope in which the anonymous union is declared.
<span class='indexparent'><a class='index' id='initialization,union'></a></span>[&nbsp;<i>Example:</i></p><pre class='codeblock'>
void f() {
  union { int a; const char* p; };
  a = 1;
  p = "Jennifer";
}
</pre><p >Here <span class='texttt'>a</span> and <span class='texttt'>p</span> are used like ordinary (nonmember)
variables, but since they are union members they have the same address.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='union,global_anonymous'></a></span><span class='indexparent'><a class='index' id='scope,anonymous_union_at_namespace'></a></span>Anonymous unions declared in a named namespace or in the global
namespace shall be declared <span class='texttt'>static</span>. Anonymous unions declared at
block scope shall be declared with any storage class allowed for a
block-scope variable, or with no storage class. A storage class is not
allowed in a declaration of an anonymous union in a class scope.
<span class='indexparent'><a class='index' id='access_control,anonymous_union'></a></span><span class='indexparent'><a class='index' id='restriction,anonymous_union'></a></span>An anonymous union shall not have <span class='texttt'>private</span> or <span class='texttt'>protected</span>
members (Clause <a href='class.access'>[class.access]</a>). An anonymous union shall not have
function members.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >A union for which objects or pointers are declared is not an anonymous union.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
union { int aa; char* p; } obj, *ptr = &amp;obj;
aa = 1;                         <span class='comment'>// error
</span>ptr-&gt;aa = 1;                    <span class='comment'>// OK
</span></pre><p >The assignment to plain <span class='texttt'>aa</span> is ill-formed since the member name
is not visible outside the union, and even if it were visible, it is not
associated with any particular object.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
Initialization of unions with no user-declared constructors is described
in (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >A <span class='grammarterm'>union-like class</span> is a union or a class that has an anonymous union as a direct member. A union-like class <span class='texttt'>X</span> has a set of <a class='hidden_link' href='#def:variant_members' id='def:variant_members'><i>variant members</i></a>. If <span class='texttt'>X</span> is a union its variant members are the non-static data members; otherwise, its variant members are the non-static data members of all anonymous unions that are members of <span class='texttt'>X</span>.</p></div></div></div></body></html>