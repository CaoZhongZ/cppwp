<!DOCTYPE html><html lang='en'><head><title>[temp.dep]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.6</a> Name resolution <a class='abbr_ref' href='temp.res#temp.dep'>[temp.res]</a></h2><div id='temp.dep'><h3 ><a class='secnum' style='min-width:103pt'>14.6.2</a> Dependent names <a class='abbr_ref'>[temp.dep]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='name,dependent'></a></span>Inside a template, some constructs have semantics which may differ from one
instantiation to another.
Such a construct
<a class='hidden_link' href='#def:depends' id='def:depends'><i>depends</i></a>
on the template parameters.
In particular, types and expressions may depend on the type
and/or
value of
template parameters (as determined by the template arguments) and this determines
the context for name lookup for certain names.
Expressions may be
<span class='grammarterm'>type-dependent</span>
(on the type of a template parameter) or
<span class='grammarterm'>value-dependent</span>
(on the value of a non-type template parameter).
In an expression of the form:</p><pre class='bnf'><i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#nt:expression-list'>expression-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span></pre><p >where the
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>
is an
<i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i>,
the
<i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i>
denotes a
<span class='indexparent'><a class='index' id='name,dependent'></a></span><a class='hidden_link' href='#def:dependent_name' id='def:dependent_name'><i>dependent name</i></a>
if</p><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p >any of the expressions in the <i ><a href='expr.post#nt:expression-list'>expression-list</a></i> is a pack
expansion (<a href='temp.variadic'>[temp.variadic]</a>),</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p >any of the expressions in the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
is a type-dependent expression (<a href='temp.dep.expr'>[temp.dep.expr]</a>), or</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p >if the <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i> of the <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i>
is a <i ><a href='temp.names#nt:template-id'>template-id</a></i> in which any of the template arguments depends
on a template parameter.
</p></li></ul><p >If an operand of an operator is a type-dependent expression, the operator
also denotes a dependent name.
Such names are unbound and
are looked up at the point of the template instantiation (<a href='temp.point'>[temp.point]</a>) in
both the context of the template definition and the
context of the point of instantiation.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; struct X : B&lt;T&gt; {
  typename T::A* pa;
  void f(B&lt;T&gt;* pb) {
    static int i = B&lt;T&gt;::i;
    pb-&gt;j++;
  }
};
</pre><p >the base class name
<span class='texttt'>B&lt;T&gt;</span>,
the type name
<span class='texttt'>T::A</span>,
the names
<span class='texttt'>B&lt;T&gt;::i</span>
and
<span class='texttt'>pb-&gt;j</span>
explicitly depend on the
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >In the definition of a class or class template, if a base class
depends on a
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>,
the base class scope is not examined during unqualified
name lookup either at the point of definition of the
class template or member or during an instantiation of
the class template or member.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
typedef double A;
template&lt;class T&gt; class B {
  typedef int A;
};
template&lt;class T&gt; struct X : B&lt;T&gt; {
  A a;              <span class='comment'>// <span class='texttt'>a</span> has type <span class='texttt'>double</span>
</span>};
</pre><p >The type name
<span class='texttt'>A</span>
in the definition of
<span class='texttt'>X&lt;T&gt;</span>
binds to the typedef name defined in the global
namespace scope, not to the typedef name
defined in the base class
<span class='texttt'>B&lt;T&gt;</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct A {
  struct B { <span class='comment'>/* ... */</span> };
  int a;
  int Y;
};

int a;

template&lt;class T&gt; struct Y : T {
  struct B { <span class='comment'>/* ... */</span> };
  B b;                          <span class='comment'>// The <span class='texttt'>B</span> defined in <span class='texttt'>Y</span>
</span>  void f(int i) { a = i; }      <span class='comment'>// <span class='texttt'>::a</span>
</span>  Y* p;                         <span class='comment'>// <span class='texttt'>Y&lt;T&gt;</span>
</span>};

Y&lt;A&gt; ya;
</pre><p >The members
<span class='texttt'>A::B</span>,
<span class='texttt'>A::a</span>,
and
<span class='texttt'>A::Y</span>
of the template argument
<span class='texttt'>A</span>
do not affect the binding of names in
<span class='texttt'>Y&lt;A&gt;</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='type'><h4 ><a class='secnum' href='#type' style='min-width:118pt'>14.6.2.1</a> Dependent types <a class='abbr_ref' href='temp.dep.type'>[temp.dep.type]</a></h4><div class='para' id='type-1'><div class='marginalizedparent'><a class='marginalized' href='#type-1'>1</a></div><p >A name refers to the
<a class='hidden_link' href='#def:current_instantiation' id='def:current_instantiation'><i>current instantiation</i></a>
if it is</p><ul class='itemize'><li id='type-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-1.1'>(1.1)</a></div><p >in the definition of a class template, a nested class of a class template,
a member of a class template, or a member of a nested class of a class template,
the injected-class-name (Clause <a href='class'>[class]</a>) of the class template or nested class,
</p></li><li id='type-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-1.2'>(1.2)</a></div><p >in the definition of a primary class template
or a member of a primary class template, the name of the
class template followed by the template argument list of the
primary template (as described below) enclosed in
<span class='texttt'>&lt;&gt;</span> (or an equivalent template alias specialization),
</p></li><li id='type-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-1.3'>(1.3)</a></div><p >in the definition of a nested class of a class template,
the name of the nested class referenced as a member of the
current instantiation, or
</p></li><li id='type-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-1.4'>(1.4)</a></div><p >in the definition of a partial specialization
or a member of a partial specialization, the name of
the class template followed by the template argument list of
the partial specialization enclosed in
<span class='texttt'>&lt;&gt;</span> (or an equivalent template alias specialization).
If the <i>n</i>th template parameter is
a parameter pack, the <i>n</i>th template argument is a pack
expansion (<a href='temp.variadic'>[temp.variadic]</a>) whose pattern is the name of
the parameter pack.
</p></li></ul></div><div class='para' id='type-2'><div class='marginalizedparent'><a class='marginalized' href='#type-2'>2</a></div><p >The template argument list of a primary template is a
template argument list in which the
<i>n</i>th
template argument has the value of the
<i>n</i>th
template parameter of the class template.
If the <i>n</i>th template parameter is a template
parameter pack (<a href='temp.variadic'>[temp.variadic]</a>), the <i>n</i>th template argument is a pack
expansion (<a href='temp.variadic'>[temp.variadic]</a>) whose pattern is the name of
the template parameter pack.</p></div><div class='para' id='type-3'><div class='marginalizedparent'><a class='marginalized' href='#type-3'>3</a></div><p >A template argument that is equivalent to a template
parameter (i.e., has the same constant value or the same type
as the template parameter) can be used in place of that
template parameter in a reference to the current
instantiation. In the case of a non-type template argument,
the argument must have been given the value of the
template parameter and not an expression in which the
template parameter appears as a subexpression.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; class A {
  A* p1;                        <span class='comment'>// <span class='texttt'>A</span> is the current instantiation
</span>  A&lt;T&gt;* p2;                     <span class='comment'>// <span class='texttt'>A&lt;T&gt;</span> is the current instantiation
</span>  A&lt;T*&gt; p3;                     <span class='comment'>// <span class='texttt'>A&lt;T*&gt;</span> is not the current instantiation
</span>  ::A&lt;T&gt;* p4;                   <span class='comment'>// <span class='texttt'>::A&lt;T&gt;</span> is the current instantiation
</span>  class B {
    B* p1;                      <span class='comment'>// <span class='texttt'>B</span> is the current instantiation
</span>    A&lt;T&gt;::B* p2;                <span class='comment'>// <span class='texttt'>A&lt;T&gt;::B</span> is the current instantiation
</span>    typename A&lt;T*&gt;::B* p3;      <span class='comment'>// <span class='texttt'>A&lt;T*&gt;::B</span> is not the
</span>                                <span class='comment'>// current instantiation
</span>  };
};

template &lt;class T&gt; class A&lt;T*&gt; {
  A&lt;T*&gt;* p1;                    <span class='comment'>// <span class='texttt'>A&lt;T*&gt;</span> is the current instantiation
</span>  A&lt;T&gt;* p2;                     <span class='comment'>// <span class='texttt'>A&lt;T&gt;</span> is not the current instantiation
</span>};

template &lt;class T1, class T2, int I&gt; struct B {
  B&lt;T1, T2, I&gt;* b1;             <span class='comment'>// refers to the current instantiation
</span>  B&lt;T2, T1, I&gt;* b2;             <span class='comment'>// not the current instantiation
</span>  typedef T1 my_T1;
  static const int my_I = I;
  static const int my_I2 = I+0;
  static const int my_I3 = my_I;
  B&lt;my_T1, T2, my_I&gt;* b3;       <span class='comment'>// refers to the current instantiation
</span>  B&lt;my_T1, T2, my_I2&gt;* b4;      <span class='comment'>// not the current instantiation
</span>  B&lt;my_T1, T2, my_I3&gt;* b5;      <span class='comment'>// refers to the current instantiation
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='type-4'><div class='marginalizedparent'><a class='marginalized' href='#type-4'>4</a></div><p >A name is a
<a class='hidden_link' href='#def:member_of_the_current_instantiation' id='def:member_of_the_current_instantiation'><i>member of the current instantiation</i></a>
if it is</p><ul class='itemize'><li id='type-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-4.1'>(4.1)</a></div><p >An unqualified name that, when looked up, refers to
at least one
member of
the current instantiation or a non-dependent base class thereof.
[&nbsp;<i>Note:</i>
This can only occur when looking up a name in a scope enclosed by the
definition of a class template.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li><li id='type-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-4.2'>(4.2)</a></div><p >A
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>
in which the
<i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation
and that, when looked up, refers to at least one member of the current
instantiation or a non-dependent base class thereof. [&nbsp;<i>Note:</i> if no such
member is found, and the current instantiation has any dependent base classes,
then the <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> is a member of an unknown specialization;
see below. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li id='type-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-4.3'>(4.3)</a></div><p >An <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> denoting the member in a class member access
expression (<a href='expr.ref'>[expr.ref]</a>) for which the type of the object expression is the
current instantiation, and the <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i>, when looked
up (<a href='basic.lookup.classref'>[basic.lookup.classref]</a>), refers to at least one member of the current
instantiation or a non-dependent base class thereof. [&nbsp;<i>Note:</i> if no such
member is found, and the current instantiation has any dependent base classes,
then the <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> is a member of an unknown specialization;
see below. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; class A {
  static const int i = 5;
  int n1[i];        <span class='comment'>// <span class='texttt'>i</span> refers to a member of the current instantiation
</span>  int n2[A::i];     <span class='comment'>// <span class='texttt'>A::i</span> refers to a member of the current instantiation
</span>  int n3[A&lt;T&gt;::i];  <span class='comment'>// <span class='texttt'>A&lt;T&gt;::i</span> refers to a member of the current instantiation
</span>  int f();
};

template &lt;class T&gt; int A&lt;T&gt;::f() {
  return i;         <span class='comment'>// <span class='texttt'>i</span> refers to a member of the current instantiation
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='type-5'><div class='marginalizedparent'><a class='marginalized' href='#type-5'>5</a></div><p >A name is a
<a class='hidden_link' href='#def:member_of_an_unknown_specialization' id='def:member_of_an_unknown_specialization'><i>member of an unknown specialization</i></a>
if it is</p><ul class='itemize'><li id='type-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-5.1'>(5.1)</a></div><p >A
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>
in which the
<i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i>
names a dependent type that is not the current instantiation.</p></li><li id='type-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-5.2'>(5.2)</a></div><p >A <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> in which the <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation, the current instantiation has at least one
dependent base class, and name lookup of the <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> does not
find any member of the current instantiation or a non-dependent base class thereof.</p></li><li id='type-5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-5.3'>(5.3)</a></div><p >An <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> denoting the member in a class member access
expression (<a href='expr.ref'>[expr.ref]</a>) in which either
</p><ul class='itemize'><li id='type-5.3.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#type-5.3.1'>(5.3.1)</a></div><p >the type of the object expression is the current instantiation, the
current instantiation has at least one dependent base class, and name lookup
of the <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> does not find a member of the current
instantiation or a non-dependent base class thereof; or</p></li><li id='type-5.3.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#type-5.3.2'>(5.3.2)</a></div><p >the type of the object expression is dependent and is not the current
instantiation.
</p></li></ul></li></ul></div><div class='para' id='type-6'><div class='marginalizedparent'><a class='marginalized' href='#type-6'>6</a></div><p >If a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> in which the <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i>
refers to the current instantiation is not a member of the current instantiation
or a member of an unknown specialization, the program is ill-formed even if the
template containing the <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> is not instantiated; no
diagnostic required. Similarly, if the <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> in a class
member access expression for which the type of the object expression is the
current instantiation does not refer to a member of the current instantiation
or a member of an unknown specialization, the program is ill-formed even if the
template containing the member access expression is not instantiated; no diagnostic
required. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; class A {
  typedef int type;
  void f() {
    A&lt;T&gt;::type i;           <span class='comment'>// OK: refers to a member of the current instantiation
</span>    typename A&lt;T&gt;::other j; <span class='comment'>// error: neither a member of the current instantiation nor
</span>                            <span class='comment'>// a member of an unknown specialization
</span>  }
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='type-7'><div class='marginalizedparent'><a class='marginalized' href='#type-7'>7</a></div><p >If, for a given set of template arguments, a specialization of a template is
instantiated that refers to a member of the current instantiation with a
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> or class member access expression, the name in the
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> or class member access expression is looked up in the
template instantiation context. If the result of this lookup differs from the
result of name lookup in the template definition context, name lookup is
ambiguous. [&nbsp;<i>Note:</i> the result of name lookup differs only when the member of
the current instantiation was found in a non-dependent base class of the current
instantiation and a member with the same name is also introduced by the
substitution for a dependent base class of the current instantiation. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='type-8'><div class='marginalizedparent'><a class='marginalized' href='#type-8'>8</a></div><p >A type is dependent if it is
</p><ul class='itemize'><li id='type-8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-8.1'>(8.1)</a></div><p >a template parameter,
</p></li><li id='type-8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-8.2'>(8.2)</a></div><p >a member of an unknown specialization,
</p></li><li id='type-8.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-8.3'>(8.3)</a></div><p >a nested class or enumeration that is a member of the current instantiation,
</p></li><li id='type-8.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-8.4'>(8.4)</a></div><p >a cv-qualified type where the cv-unqualified type is dependent,
</p></li><li id='type-8.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-8.5'>(8.5)</a></div><p >a compound type constructed from any dependent type,
</p></li><li id='type-8.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-8.6'>(8.6)</a></div><p >an array type constructed from any dependent type or whose
size is specified by a constant expression that is value-dependent,
</p></li><li id='type-8.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-8.7'>(8.7)</a></div><p >a
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
in which either the template name is a template parameter or any of the
template arguments is a dependent type or an expression that is type-dependent
or value-dependent, or
</p></li><li id='type-8.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#type-8.8'>(8.8)</a></div><p >denoted by <span class='texttt'>decltype(</span><i ><a href='expr.comma#nt:expression'>expression</a></i><span class='texttt'>)</span>,
where <i ><a href='expr.comma#nt:expression'>expression</a></i> is type-dependent (<a href='temp.dep.expr'>[temp.dep.expr]</a>).
</p></li></ul></div><div class='para' id='type-9'><div class='marginalizedparent'><a class='marginalized' href='#type-9'>9</a></div><p >[&nbsp;<i>Note:</i>
Because typedefs do not introduce new types, but
instead simply refer to other types, a name that refers to a
typedef that is a member of the current instantiation is dependent
only if the type referred to is dependent.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='expr'><h4 ><a class='secnum' href='#expr' style='min-width:118pt'>14.6.2.2</a> Type-dependent expressions <a class='abbr_ref' href='temp.dep.expr'>[temp.dep.expr]</a></h4><div class='para' id='expr-1'><div class='marginalizedparent'><a class='marginalized' href='#expr-1'>1</a></div><p >Except as described below, an expression is type-dependent if any
subexpression is type-dependent.</p></div><div class='para' id='expr-2'><div class='marginalizedparent'><a class='marginalized' href='#expr-2'>2</a></div><p ><span class='texttt'>this</span>
is type-dependent if the class type of the enclosing member function is
dependent (<a href='temp.dep.type'>[temp.dep.type]</a>).</p></div><div class='para' id='expr-3'><div class='marginalizedparent'><a class='marginalized' href='#expr-3'>3</a></div><p >An
<i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i>
is type-dependent if it contains</p><ul class='itemize'><li id='expr-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#expr-3.1'>(3.1)</a></div><p >an
<i ><a href='lex.name#nt:identifier'>identifier</a></i>
associated by name lookup with one or more declarations
declared with a dependent type,</p></li><li id='expr-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#expr-3.2'>(3.2)</a></div><p >a
<i ><a href='temp.names#nt:template-id'>template-id</a></i>
that is dependent,</p></li><li id='expr-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#expr-3.3'>(3.3)</a></div><p >a
<i ><a href='class.conv.fct#nt:conversion-function-id'>conversion-function-id</a></i>
that specifies a dependent type, or</p></li><li id='expr-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#expr-3.4'>(3.4)</a></div><p >a
<i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i>
or a
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>
that names a member of an unknown specialization;
</p></li></ul><p >or if it names a static data member of the current instantiation that has type
“array of unknown bound of <span class='texttt'>T</span>” for some <span class='texttt'>T</span> (<a href='temp.static'>[temp.static]</a>).
Expressions of the following forms are type-dependent only if the type
specified by the
<i ><a href='dcl.name#nt:type-id'>type-id</a></i>,
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i>
or
<i ><a href='expr.new#nt:new-type-id'>new-type-id</a></i>
is dependent, even if any subexpression is type-dependent:</p><pre class='bnf'><i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#nt:expression-list'>expression-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> new</span> <i ><a href='expr.new#nt:new-placement'>new-placement</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='expr.new#nt:new-type-id'>new-type-id</a></i> <i ><a href='expr.new#nt:new-initializer'>new-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> new</span> <i ><a href='expr.new#nt:new-placement'>new-placement</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>(</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span> <i ><a href='expr.new#nt:new-initializer'>new-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='terminal'>dynamic_cast &lt;</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>static_cast &lt;</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>const_cast &lt;</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>reinterpret_cast &lt;</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>(</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i></pre></div><div class='para' id='expr-4'><div class='marginalizedparent'><a class='marginalized' href='#expr-4'>4</a></div><p >Expressions of the following forms are never type-dependent (because the type
of the expression cannot be dependent):</p><pre class='bnf'><i ><a href='lex.literal.kinds#nt:literal'>literal</a></i>
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>.</span> <i ><a href='expr.post#nt:pseudo-destructor-name'>pseudo-destructor-name</a></i>
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> <span class='terminal'>-&gt;</span> <i ><a href='expr.post#nt:pseudo-destructor-name'>pseudo-destructor-name</a></i>
<span class='terminal'>sizeof</span> <i ><a href='expr.unary#nt:unary-expression'>unary-expression</a></i>
<span class='terminal'>sizeof (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>sizeof</span> <span class='terminal'>...</span> <span class='terminal'>(</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>)</span>
<span class='terminal'>alignof (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>typeid (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>typeid (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> delete</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
<span class='terminal'>::<span class='math'><sub ><span class='mathit'>opt</span></sub></span> delete [ ]</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
<span class='terminal'>throw</span> <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='terminal'>noexcept</span> <span class='terminal'>(</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span></pre><p >[&nbsp;<i>Note:</i> For the standard library macro <span class='texttt'>offsetof</span>,
see <a href='support.types'>[support.types]</a>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='expr-5'><div class='marginalizedparent'><a class='marginalized' href='#expr-5'>5</a></div><p >A class member access expression (<a href='expr.ref'>[expr.ref]</a>) is
type-dependent if
the expression refers to a member of the current instantiation and
the type of the referenced member is dependent, or the class member access
expression refers to a member of an unknown specialization.
[&nbsp;<i>Note:</i>
In an expression of the form
<span class='texttt'>x.y</span>
or
<span class='texttt'>xp-&gt;y</span>
the type of the expression is usually the type of the member
<span class='texttt'>y</span>
of the class of
<span class='texttt'>x</span>
(or the class pointed to by
<span class='texttt'>xp</span>).
However, if
<span class='texttt'>x</span>
or
<span class='texttt'>xp</span>
refers to a dependent type that is not the current instantiation,
the type of
<span class='texttt'>y</span>
is always dependent. If
<span class='texttt'>x</span>
or <span class='texttt'>xp</span>
refers to a non-dependent type or refers to the current instantiation, the
type of
<span class='texttt'>y</span>
is the type of the class member access expression.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='constexpr'><h4 ><a class='secnum' href='#constexpr' style='min-width:118pt'>14.6.2.3</a> Value-dependent expressions <a class='abbr_ref' href='temp.dep.constexpr'>[temp.dep.constexpr]</a></h4><div class='para' id='constexpr-1'><div class='marginalizedparent'><a class='marginalized' href='#constexpr-1'>1</a></div><p >Except as described below, a constant expression is value-dependent if any
subexpression is value-dependent.</p></div><div class='para' id='constexpr-2'><div class='marginalizedparent'><a class='marginalized' href='#constexpr-2'>2</a></div><p >An
<i ><a href='lex.name#nt:identifier'>identifier</a></i>
is value-dependent if it is:</p><ul class='itemize'><li id='constexpr-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#constexpr-2.1'>(2.1)</a></div><p >a name declared with a dependent type,
</p></li><li id='constexpr-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#constexpr-2.2'>(2.2)</a></div><p >the name of a non-type template parameter,
</p></li><li id='constexpr-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#constexpr-2.3'>(2.3)</a></div><p >a constant with literal type and is initialized with an
expression that is value-dependent.
</p></li></ul><p >Expressions of the following form are value-dependent if the
<i ><a href='expr.unary#nt:unary-expression'>unary-expression</a></i> or <i ><a href='expr.comma#nt:expression'>expression</a></i>
is type-dependent or the
<i ><a href='dcl.name#nt:type-id'>type-id</a></i>
is dependent:</p><pre class='bnf'><span class='terminal'>sizeof</span> <i ><a href='expr.unary#nt:unary-expression'>unary-expression</a></i>
<span class='terminal'>sizeof (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>typeid (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>typeid (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>alignof (</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span>
<span class='terminal'>noexcept</span> <span class='terminal'>(</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span></pre><p >[&nbsp;<i>Note:</i> For the standard library macro <span class='texttt'>offsetof</span>,
see <a href='support.types'>[support.types]</a>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='constexpr-3'><div class='marginalizedparent'><a class='marginalized' href='#constexpr-3'>3</a></div><p >Expressions of the following form are value-dependent if either the
<i ><a href='dcl.name#nt:type-id'>type-id</a></i>
or
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i>
is dependent or the
<i ><a href='expr.comma#nt:expression'>expression</a></i>
or
<i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
is value-dependent:</p><pre class='bnf'><i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#nt:expression-list'>expression-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span>
<span class='terminal'>static_cast &lt;</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>const_cast &lt;</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>reinterpret_cast &lt;</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>&gt; (</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
<span class='terminal'>(</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i></pre></div><div class='para' id='constexpr-4'><div class='marginalizedparent'><a class='marginalized' href='#constexpr-4'>4</a></div><p >Expressions of the following form are value-dependent:</p><pre class='bnf'><span class='terminal'>sizeof</span> <span class='terminal'>...</span> <span class='terminal'>(</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>)</span></pre></div><div class='para' id='constexpr-5'><div class='marginalizedparent'><a class='marginalized' href='#constexpr-5'>5</a></div><p >An <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i> is value-dependent if it names a member of an
unknown specialization.</p></div></div><div id='temp'><h4 ><a class='secnum' href='#temp' style='min-width:118pt'>14.6.2.4</a> Dependent template arguments <a class='abbr_ref' href='temp.dep.temp'>[temp.dep.temp]</a></h4><div class='para' id='temp-1'><div class='marginalizedparent'><a class='marginalized' href='#temp-1'>1</a></div><p >A type
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
is dependent if the type it specifies is dependent.</p></div><div class='para' id='temp-2'><div class='marginalizedparent'><a class='marginalized' href='#temp-2'>2</a></div><p >A non-type
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
is dependent if its type is dependent or the constant
expression it specifies is value-dependent.</p></div><div class='para' id='temp-3'><div class='marginalizedparent'><a class='marginalized' href='#temp-3'>3</a></div><p >Furthermore, a non-type
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
is dependent if the corresponding non-type <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
is of reference or pointer type and the <i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
designates or points to a member of the current instantiation or a member of
a dependent type.</p></div><div class='para' id='temp-4'><div class='marginalizedparent'><a class='marginalized' href='#temp-4'>4</a></div><p >A template
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
is dependent if it names a
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>
or is a
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>
that refers to a member of an unknown specialization.</p></div></div></div></div></body></html>