<!DOCTYPE html><html lang='en'><head><title>[meta.unary]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>20.9</a> Metaprogramming and type traits <a class='abbr_ref' href='meta#unary'>[meta]</a></h2><div id='meta.unary'><h3 ><a class='secnum' style='min-width:103pt'>20.9.4</a> Unary type traits <a class='abbr_ref'>[meta.unary]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >This sub-clause contains templates that may be used to query the
properties of a type at compile time.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Each of these templates shall be a
UnaryTypeTrait (<a href='meta.rqmts'>[meta.rqmts]</a>)
with a BaseCharacteristic of
<span class='texttt'>true_type</span> if the corresponding condition is true, otherwise
<span class='texttt'>false_type</span>.</p></div><div id='cat'><h4 ><a class='secnum' href='#cat' style='min-width:118pt'>20.9.4.1</a> Primary type categories <a class='abbr_ref' href='meta.unary.cat'>[meta.unary.cat]</a></h4><div class='para' id='cat-1'><div class='marginalizedparent'><a class='marginalized' href='#cat-1'>1</a></div><p >The primary type categories correspond to the descriptions given in
section <a href='basic.types'>[basic.types]</a> of the C++ standard.</p></div><div class='para' id='cat-2'><div class='marginalizedparent'><a class='marginalized' href='#cat-2'>2</a></div><p >For any given type <span class='texttt'>T</span>, the result of applying one of these templates to
<span class='texttt'>T</span> and to <i>cv-qualified</i> <span class='texttt'>T</span> shall yield the same result.</p></div><div class='para' id='cat-3'><div class='marginalizedparent'><a class='marginalized' href='#cat-3'>3</a></div><p >[&nbsp;<i>Note:</i>
For any given type <span class='texttt'>T</span>, exactly one of the primary type categories
has a <span class='texttt'>value</span> member that evaluates to <span class='texttt'>true</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><div class='numberedTable' id='tab:type-traits.primary'>Table <a href='#tab:type-traits.primary'>47</a> — Primary type category predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span>
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_void;</span>                </td><td class='left'>
<span class='texttt'>T</span> is <span class='texttt'>void</span>       </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_integral;</span>        </td><td class='left'>
<span class='texttt'>T</span> is an integral type (<a href='basic.fundamental'>[basic.fundamental]</a>)                 </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_floating_point;</span>  </td><td class='left'>
<span class='texttt'>T</span> is a floating point type (<a href='basic.fundamental'>[basic.fundamental]</a>)            </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_array;</span>           </td><td class='left'>
<span class='texttt'>T</span> is an array type (<a href='basic.compound'>[basic.compound]</a>) of known or unknown extent    </td><td class='left'>
Class template <span class='texttt'>array</span> (<a href='array'>[array]</a>)
is not an array type.                   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_pointer;</span>         </td><td class='left'>
<span class='texttt'>T</span> is a pointer type (<a href='basic.compound'>[basic.compound]</a>)                      </td><td class='left'>
Includes pointers to functions
but not pointers to non-static members.                        </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_lvalue_reference;</span>    </td><td class='left'>
 <span class='texttt'>T</span> is an lvalue reference type (<a href='dcl.ref'>[dcl.ref]</a>)   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_rvalue_reference;</span>    </td><td class='left'>
 <span class='texttt'>T</span> is an rvalue reference type (<a href='dcl.ref'>[dcl.ref]</a>)   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_member_object_pointer;</span></td><td class='left'>
 <span class='texttt'>T</span> is a pointer to non-static data member                              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_member_function_pointer;</span></td><td class='left'>
<span class='texttt'>T</span> is a pointer to non-static member function                           </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_enum;</span>            </td><td class='left'>
<span class='texttt'>T</span> is an enumeration type (<a href='basic.compound'>[basic.compound]</a>)                 </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_union;</span>           </td><td class='left'>
<span class='texttt'>T</span> is a union type (<a href='basic.compound'>[basic.compound]</a>)                        </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_class;</span>           </td><td class='left'>
<span class='texttt'>T</span> is a class type but not a union type (<a href='basic.compound'>[basic.compound]</a>) </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_function;</span>        </td><td class='left'>
<span class='texttt'>T</span> is a function type (<a href='basic.compound'>[basic.compound]</a>)                     </td><td class='left'>   </td></tr></table></div></div></div><div id='comp'><h4 ><a class='secnum' href='#comp' style='min-width:118pt'>20.9.4.2</a> Composite type traits <a class='abbr_ref' href='meta.unary.comp'>[meta.unary.comp]</a></h4><div class='para' id='comp-1'><div class='marginalizedparent'><a class='marginalized' href='#comp-1'>1</a></div><p >These templates provide convenient compositions of the primary type
categories, corresponding to the descriptions given in section <a href='basic.types'>[basic.types]</a>.</p></div><div class='para' id='comp-2'><div class='marginalizedparent'><a class='marginalized' href='#comp-2'>2</a></div><p >For any given type <span class='texttt'>T</span>, the result of applying one of these templates to
<span class='texttt'>T</span>, and to <i>cv-qualified</i> <span class='texttt'>T</span> shall yield the same result.</p><div class='numberedTable' id='tab:type-traits.composite'>Table <a href='#tab:type-traits.composite'>48</a> — Composite type category predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span>
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_reference;</span>   </td><td class='left'>
 <span class='texttt'>T</span> is an lvalue reference or an rvalue reference </td><td class='left'>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_arithmetic;</span>          </td><td class='left'>
 <span class='texttt'>T</span> is an arithmetic type (<a href='basic.fundamental'>[basic.fundamental]</a>)              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_fundamental;</span>         </td><td class='left'>
 <span class='texttt'>T</span> is a fundamental type (<a href='basic.fundamental'>[basic.fundamental]</a>)              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_object;</span>              </td><td class='left'>
 <span class='texttt'>T</span> is an object type (<a href='basic.types'>[basic.types]</a>)                            </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_scalar;</span>              </td><td class='left'>
 <span class='texttt'>T</span> is a scalar type (<a href='basic.types'>[basic.types]</a>)                         </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_compound;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is a compound type (<a href='basic.compound'>[basic.compound]</a>)                        </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_member_pointer;</span>      </td><td class='left'>
 <span class='texttt'>T</span> is a pointer to non-static data member
 or non-static member function             </td><td class='left'>   </td></tr></table></div></div></div><div id='prop'><h4 ><a class='secnum' href='#prop' style='min-width:118pt'>20.9.4.3</a> Type properties <a class='abbr_ref' href='meta.unary.prop'>[meta.unary.prop]</a></h4><div class='para' id='prop-1'><div class='marginalizedparent'><a class='marginalized' href='#prop-1'>1</a></div><p >These templates provide access to some of the more important
properties of types.</p></div><div class='para' id='prop-2'><div class='marginalizedparent'><a class='marginalized' href='#prop-2'>2</a></div><p >It is unspecified whether the library defines any full or partial
specializations of any of these templates.</p></div><div class='para' id='prop-3'><div class='marginalizedparent'><a class='marginalized' href='#prop-3'>3</a></div><p >For all of the class templates <span class='texttt'>X</span> declared in this Clause,
instantiating that template with a template-argument that is a class
template specialization may result in the implicit instantiation of
the template argument if and only if the semantics of <span class='texttt'>X</span> require that
the argument must be a complete type.</p><div class='numberedTable' id='tab:type-traits.properties'>Table <a href='#tab:type-traits.properties'>49</a> — Type property predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Preconditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='endhead'></span><span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_const;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is const-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>)                  </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_volatile;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is volatile-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>)                   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivial;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a trivial type (<a href='basic.types'>[basic.types]</a>)     </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete
 type, (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_copyable;</span>      </td><td class='left'>
 <span class='texttt'>T</span> is a trivially copyable type (<a href='basic.types'>[basic.types]</a>) </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown bound.                               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_standard_layout;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a standard-layout type (<a href='basic.types'>[basic.types]</a>)   </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete
 type, (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_pod;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a POD type (<a href='basic.types'>[basic.types]</a>)                                </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete
 type, (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_literal_type;</span>        </td><td class='left'>
 <span class='texttt'>T</span> is a literal type (<a href='basic.types'>[basic.types]</a>)  </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown bound.                               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_empty;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is a class type, but not a union type, with no non-static data
 members other than bit-fields of length 0, no virtual member functions,
 no virtual base classes, and no base class <span class='texttt'>B</span> for
 which <span class='texttt'>is_empty&lt;B&gt;::value</span> is false. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) <span class='texttt'>void</span>, or an array of unknown bound.                               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_polymorphic;</span>         </td><td class='left'>
 <span class='texttt'>T</span> is a polymorphic class (<a href='class.virtual'>[class.virtual]</a>)                             </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 type, (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_abstract;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is an abstract class (<a href='class.abstract'>[class.abstract]</a>)                              </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 type, (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_signed;</span>              </td><td class='left'>
  <span class='texttt'>is_arithmetic&lt;T&gt;::value</span> <span class='texttt'>&amp;&amp;</span>
  <span class='texttt'>T(-1) &lt; T(0)</span>   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'>  <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_unsigned;</span>            </td><td class='left'>
  <span class='texttt'>is_arithmetic&lt;T&gt;::value</span> <span class='texttt'>&amp;&amp;</span>
  <span class='texttt'>T(0) &lt; T(-1)</span>   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'>  <span class='texttt'>template &lt;class T, class... Args&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_constructible;</span>   </td><td class='left'>
 <i><span class='texttt'>see below</span></i>                          </td><td class='left'>
 <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span>
 shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
 or arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_default_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_copy_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible&lt;T, const T&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_move_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible&lt;T, T&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class U&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_assignable;</span> </td><td class='left'>
  The expression <span class='texttt'>declval&lt;T&gt;() =</span> <span class='texttt'>declval&lt;U&gt;()</span> is well-formed
  when treated as an unevaluated
  operand (Clause <a href='expr'>[expr]</a>). Access checking is performed as if in a context
  unrelated to <span class='texttt'>T</span> and <span class='texttt'>U</span>. Only the validity of the immediate context
  of the assignment expression is considered. [&nbsp;<i>Note:</i> The compilation of the
  expression can result in side effects such as the instantiation of class template
  specializations and function template specializations, the generation of
  implicitly-defined functions, and so on. Such side effects are not in the “immediate
  context” and can result in the program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_copy_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable&lt;T&amp;, const T&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_move_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_destructible;</span> </td><td class='left'>
  For a complete type <span class='texttt'>T</span> and given<span class='hfill'></span><br/>
  <span class='texttt'>template &lt;class U&gt;</span>
  <span class='texttt'>struct test { U u; };</span>,<span class='hfill'></span><br/>
  <span class='texttt'>test&lt;T&gt;::~test()</span> is not deleted. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class... Args&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct</span><span class='hfill'></span><br/>
  <span class='texttt'>is_trivially_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible&lt;T,</span><span class='hfill'></span><br/>
  <span class='texttt'>Args...&gt;::value</span> is <span class='texttt'>true</span> and the variable
  definition for <span class='texttt'>is_constructible</span>, as defined below, is known to call
  no operation that is not trivial ( <a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span> shall be complete types,
  (possibly cv-qualified) <span class='texttt'>void</span>, or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_default_constructible;</span> </td><td class='left'>
 <span class='texttt'>is_trivially_constructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_copy_constructible;</span>      </td><td class='left'>
 <span class='texttt'>is_trivially_constructible&lt;T, const T&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_move_constructible;</span>      </td><td class='left'>
 <span class='texttt'>is_trivially_constructible&lt;T, T&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class U&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_trivially_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable&lt;T, U&gt;::value</span> is <span class='texttt'>true</span> and the assignment, as defined by
  <span class='texttt'>is_assignable</span>, is known to call no operation that is not trivial
  (<a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_copy_assignable;</span> </td><td class='left'>
 <span class='texttt'>is_trivially_assignable&lt;T&amp;, const T&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_move_assignable;</span> </td><td class='left'>
 <span class='texttt'>is_trivially_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_trivially_destructible;</span> </td><td class='left'>
 <span class='texttt'>is_destructible&lt;T&gt;::value</span> is <span class='texttt'>true</span> and the indicated destructor is known
 to be trivial. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class... Args&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_constructible;</span>   </td><td class='left'>
 <span class='texttt'>is_constructible&lt;T,</span> <span class='texttt'> Args...&gt;::value</span> is <span class='texttt'>true</span>
 and the
 variable definition for <span class='texttt'>is_constructible</span>, as defined below, is known not to
 throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>).
 </td><td class='left'>
 <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span>
 shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
 or arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_default_constructible;</span> </td><td class='left'>
 <span class='texttt'>is_nothrow_constructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>.  </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_copy_constructible;</span>      </td><td class='left'>
 <span class='texttt'>is_nothrow_constructible&lt;T, const T&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_move_constructible;</span>      </td><td class='left'>
 <span class='texttt'>is_nothrow_constructible&lt;T, T&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class U&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_nothrow_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable&lt;T, U&gt;::value</span> is <span class='texttt'>true</span> and the assignment is known not to
  throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct is_nothrow_copy_assignable;</span> </td><td class='left'>
 <span class='texttt'>is_nothrow_assignable&lt;T&amp;, const T&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_nothrow_move_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_nothrow_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
  <span class='texttt'>struct is_nothrow_destructible;</span> </td><td class='left'>
  <span class='texttt'>is_destructible&lt;T&gt;::value</span> is <span class='texttt'>true</span> and the indicated destructor is known
  not to throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  (possibly cv-qualified) void, or an array of unknown
  bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><span class='hfill'></span><br/>
 <span class='texttt'>struct has_virtual_destructor;</span> </td><td class='left'>
 <span class='texttt'>T</span> has a virtual destructor (<a href='class.dtor'>[class.dtor]</a>) </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr></table></div></div><div class='para' id='prop-4'><div class='marginalizedparent'><a class='marginalized' href='#prop-4'>4</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
is_const&lt;const volatile int&gt;::value     <span class='comment'>// true
</span>is_const&lt;const int*&gt;::value             <span class='comment'>// false
</span>is_const&lt;const int&amp;&gt;::value             <span class='comment'>// false
</span>is_const&lt;int[3]&gt;::value                 <span class='comment'>// false
</span>is_const&lt;const int[3]&gt;::value           <span class='comment'>// true
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='prop-5'><div class='marginalizedparent'><a class='marginalized' href='#prop-5'>5</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
remove_const&lt;const volatile int&gt;::type  <span class='comment'>// <span class='texttt'>volatile int</span>
</span>remove_const&lt;const int* const&gt;::type    <span class='comment'>// <span class='texttt'>const int*</span>
</span>remove_const&lt;const int&amp;&gt;::type          <span class='comment'>// <span class='texttt'>const int&amp;</span>
</span>remove_const&lt;const int[3]&gt;::type        <span class='comment'>// <span class='texttt'>int[3]</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='prop-6'><div class='marginalizedparent'><a class='marginalized' href='#prop-6'>6</a></div><p >Given the following function prototype:
</p><pre class='codeblock'>
template &lt;class T&gt;
  typename add_rvalue_reference&lt;T&gt;::type create();
</pre><p >the predicate condition for a template specialization
<span class='texttt'>is_constructible&lt;T, Args...&gt;</span> shall be satisfied if and only if the
following variable definition would be well-formed for some invented variable <span class='texttt'>t</span>:</p><pre class='codeblock'>
T t(create&lt;Args&gt;()...);
</pre><p >[&nbsp;<i>Note:</i> These tokens are never interpreted as a function declaration.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] Access checking is performed as if in a context unrelated to <span class='texttt'>T</span>
and any of the <span class='texttt'>Args</span>. Only the validity of the immediate context of the
variable initialization is considered. [&nbsp;<i>Note:</i> The evaluation of the
initialization can result in side effects such as the instantiation of class
template specializations and function template specializations, the generation
of implicitly-defined functions, and so on. Such side effects are not in the
“immediate context” and can result in the program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div></div></body></html>