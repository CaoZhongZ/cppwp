<!DOCTYPE html><html lang='en'><head><title>[forwardlist.ops]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>23</a> Containers library <a class='abbr_ref' href='./#containers'>[containers]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>23.3</a> Sequence containers <a class='abbr_ref' href='sequences#forwardlist.ops'>[sequences]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>23.3.4</a> Class template <span class='texttt'>forward_list</span> <a class='abbr_ref' href='forwardlist#ops'>[forwardlist]</a></h3><div id='forwardlist.ops'><h4 ><a class='secnum' style='min-width:118pt'>23.3.4.6</a> <span class='texttt'>forward_list</span> operations <a class='abbr_ref'>[forwardlist.ops]</a></h4><p ><span class='indexparent'><a class='index' id='splice_after,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,splice_after'></a></span><code class='itemdecl'>
void splice_after(const_iterator position, forward_list&amp; x);
void splice_after(const_iterator position, forward_list&amp;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>position</span> is <span class='texttt'>before_begin()</span> or is a dereferenceable
iterator in the range <span class='texttt'>[begin(),end())</span>.
<span class='texttt'>&amp;x != this</span>.</p></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Inserts the contents of <span class='texttt'>x</span> after
<span class='texttt'>position</span>, and <span class='texttt'>x</span> becomes empty. Pointers and references to the moved
elements of <span class='texttt'>x</span> now refer to those same elements but as members of <span class='texttt'>*this</span>.
Iterators referring to the moved elements will continue to refer to their elements, but
they now behave as iterators into <span class='texttt'>*this</span>, not into <span class='texttt'>x</span>.</p></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i> <span class='math'>Ο(<span class='math'><span class='mathalpha'>distance</span>(<span class='mathalpha'>x</span>.<span class='mathalpha'>begin</span>(), <span class='mathalpha'>x</span>.<span class='mathalpha'>end</span>())</span>)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='splice_after,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,splice_after'></a></span><code class='itemdecl'>
void splice_after(const_iterator position, forward_list&amp; x, const_iterator i);
void splice_after(const_iterator position, forward_list&amp;&amp; x, const_iterator i);
</code></p><div class='itemdescr'></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>position</span> is <span class='texttt'>before_begin()</span> or is a dereferenceable
iterator in the range <span class='texttt'>[begin(),end())</span>.
The iterator following <span class='texttt'>i</span> is a dereferenceable iterator in <span class='texttt'>x</span>.</p></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Inserts the element following <span class='texttt'>i</span> into <span class='texttt'>*this</span>, following
<span class='texttt'>position</span>, and removes it from <span class='texttt'>x</span>.
The result is unchanged if <span class='texttt'>position == i</span> or <span class='texttt'>position == ++i</span>. Pointers
and references to <span class='texttt'>*i</span> continue to refer to the same element but as a member of
<span class='texttt'>*this</span>. Iterators to <span class='texttt'>*i</span> (including <span class='texttt'>i</span> itself) continue to refer to
the same element, but now behave as iterators into <span class='texttt'>*this</span>, not into <span class='texttt'>x</span>.</p></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='itemdescr'><p ><i>Complexity:</i> <span class='math'>Ο(<span class='math'>1</span>)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='splice_after,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,splice_after'></a></span><code class='itemdecl'>
void splice_after(const_iterator position, forward_list&amp; x,
                  const_iterator first, const_iterator last);
void splice_after(const_iterator position, forward_list&amp;&amp; x,
                  const_iterator first, const_iterator last);
</code></p><div class='itemdescr'></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>position</span> is <span class='texttt'>before_begin()</span> or is a
dereferenceable iterator in the range <span class='texttt'>[begin(),end())</span>. <span class='texttt'>(first,last)</span> is a
valid range in <span class='texttt'>x</span>, and all iterators in the range <span class='texttt'>(first,last)</span> are
dereferenceable. <span class='texttt'>position</span> is not an iterator in the range <span class='texttt'>(first,last)</span>.</p></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Inserts elements in the range <span class='texttt'>(first,last)</span> after <span class='texttt'>position</span> and
removes the elements from <span class='texttt'>x</span>. Pointers and references to the moved elements of
<span class='texttt'>x</span> now refer to those same elements but as members of <span class='texttt'>*this</span>. Iterators
referring to the moved elements will continue to refer to their elements, but they now
behave as iterators into <span class='texttt'>*this</span>, not into <span class='texttt'>x</span>.</p></div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='itemdescr'><p ><i>Complexity:</i> <span class='math'>Ο(<span class='math'><span class='mathalpha'>distance</span>(<span class='mathalpha'>first</span>, <span class='mathalpha'>last</span>)</span>)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='remove,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,remove'></a></span><span class='indexparent'><a class='index' id='remove_if,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,remove_if'></a></span><code class='itemdecl'>
void remove(const T&amp; value);
template &lt;class Predicate&gt; void remove_if(Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Erases all the elements in the list referred by a list iterator <span class='texttt'>i</span> for
which the following conditions hold: <span class='texttt'>*i == value</span> (for <span class='texttt'>remove()</span>),
<span class='texttt'>pred(*i)</span> is true (for <span class='texttt'>remove_if()</span>). This operation shall be stable: the
relative order of the elements that are not removed is the same as their relative order
in the original list.
Invalidates only the iterators and references to the erased elements.</p></div></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing unless an exception is thrown by the equality comparison or the
predicate.</p></div></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='itemdescr'><p ><i>Complexity:</i> Exactly <span class='texttt'>distance(begin(), end())</span> applications of the corresponding
predicate.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,unique'></a></span><code class='itemdecl'>
void unique();
template &lt;class BinaryPredicate&gt; void unique(BinaryPredicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> Erases all but the first element from every consecutive
group of equal elements referred to by the iterator <span class='texttt'>i</span> in the range <span class='texttt'>[first +
1,last)</span> for which <span class='texttt'>*i == *(i-1)</span> (for the version with no arguments) or <span class='texttt'>pred(*i,
*(i - 1))</span> (for the version with a predicate argument) holds.
Invalidates only the iterators and references to the erased elements.</p></div></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing unless an exception is thrown by the equality comparison or the predicate.</p></div></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><div class='itemdescr'><p ><i>Complexity:</i> If the range <span class='texttt'>[first,last)</span> is not empty, exactly <span class='texttt'>(last - first) - 1</span> applications of the corresponding predicate, otherwise no applications of the predicate.
</p></div></div><p ><span class='indexparent'><a class='index' id='merge,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,merge'></a></span><code class='itemdecl'>
void merge(forward_list&amp; x);
void merge(forward_list&amp;&amp; x);
template &lt;class Compare&gt; void merge(forward_list&amp; x, Compare comp)
template &lt;class Compare&gt; void merge(forward_list&amp;&amp; x, Compare comp)
</code></p><div class='itemdescr'></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>comp</span> defines a strict weak ordering (<a href='alg.sorting'>[alg.sorting]</a>), and <span class='texttt'>*this</span>
and <span class='texttt'>x</span> are both sorted according to this ordering.</p></div></div><div class='para' id='19'><div class='marginalizedparent'><a class='marginalized' href='#19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> Merges <span class='texttt'>x</span> into <span class='texttt'>*this</span>. This operation shall be stable: for equivalent
elements in the two lists, the elements from <span class='texttt'>*this</span> shall always precede the elements
from <span class='texttt'>x</span>. <span class='texttt'>x</span> is empty after the merge. If an exception is thrown other than by a
comparison there are no effects.
Pointers and references to the moved elements of <span class='texttt'>x</span> now refer to those same elements
but as members of <span class='texttt'>*this</span>. Iterators referring to the moved elements will continue to
refer to their elements, but they now behave as iterators into <span class='texttt'>*this</span>, not into
<span class='texttt'>x</span>.</p></div></div><div class='para' id='20'><div class='marginalizedparent'><a class='marginalized' href='#20'>20</a></div><div class='itemdescr'><p ><i>Complexity:</i> At most distance(begin(),
end()) + distance(x.begin(), x.end()) - 1 comparisons.
</p></div></div><p ><span class='indexparent'><a class='index' id='sort,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,sort'></a></span><code class='itemdecl'>
void sort();
template &lt;class Compare&gt; void sort(Compare comp);
</code></p><div class='itemdescr'></div><div class='para' id='21'><div class='marginalizedparent'><a class='marginalized' href='#21'>21</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>operator&lt;</span> (for the version with no arguments) or <span class='texttt'>comp</span> (for the
version with a comparison argument) defines a strict weak ordering (<a href='alg.sorting'>[alg.sorting]</a>).</p></div></div><div class='para' id='22'><div class='marginalizedparent'><a class='marginalized' href='#22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i> Sorts the list according to the <span class='texttt'>operator&lt;</span> or the <span class='texttt'>comp</span> function object.
This operation shall be stable: the relative order of the equivalent elements is preserved. If
an exception is thrown the order of the elements in <span class='texttt'>*this</span> is unspecified.
Does not affect the validity of iterators and references.</p></div></div><div class='para' id='23'><div class='marginalizedparent'><a class='marginalized' href='#23'>23</a></div><div class='itemdescr'><p ><i>Complexity:</i> Approximately <span class='math'><span class='mathalpha'>N</span> <span class="mathrm">log</span> <span class='mathalpha'>N</span></span> comparisons, where <span class='math'><span class='mathalpha'>N</span></span> is <span class='texttt'>distance(begin(), end())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reverse,forward_list'></a></span><span class='indexparent'><a class='index' id='forward_list,reverse'></a></span><code class='itemdecl'>
void reverse() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='24'><div class='marginalizedparent'><a class='marginalized' href='#24'>24</a></div><div class='itemdescr'><p ><i>Effects:</i> Reverses the order of the elements in the list.
Does not affect the validity of iterators and references.</p></div></div><div class='para' id='25'><div class='marginalizedparent'><a class='marginalized' href='#25'>25</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear time.
</p></div></div></div></div></body></html>