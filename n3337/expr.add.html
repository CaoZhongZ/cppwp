<!DOCTYPE html><html lang='en'><head><title>[expr.add]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><div id='expr.add'><h2 ><a class='secnum' style='min-width:88pt'>5.7</a> Additive operators <a class='abbr_ref'>[expr.add]</a></h2><p ><span class='indexparent'><a class='index' id='expression,additive_operators'></a></span><span class='indexparent'><a class='index' id='operator,additive'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The additive operators <span class='texttt'>+</span> and <span class='texttt'>-</span> group left-to-right. The
usual arithmetic conversions are performed for operands of arithmetic or
enumeration type.</p><p ><span class='indexparent'><a class='index' id='addition_operator'></a></span><span class='indexparent'><a class='index' id='+'></a></span><span class='indexparent'><a class='index' id='subtraction_operator'></a></span><span class='indexparent'><a class='index' id='-'></a></span></p><pre class='bnf'><a id='nt:additive-expression'>additive-expression:</a>
    <i ><a href='expr.mul#nt:multiplicative-expression'>multiplicative-expression</a></i>
    <i ><a href='expr.add#nt:additive-expression'>additive-expression</a></i> <span class='terminal'>+</span> <i ><a href='expr.mul#nt:multiplicative-expression'>multiplicative-expression</a></i>
    <i ><a href='expr.add#nt:additive-expression'>additive-expression</a></i> <span class='terminal'>-</span> <i ><a href='expr.mul#nt:multiplicative-expression'>multiplicative-expression</a></i></pre><p ><span class='indexparent'><a class='index' id='incomplete'></a></span>For addition, either both operands shall have arithmetic or unscoped enumeration
type, or one operand shall be a pointer to a completely-defined object
type and the other shall have integral or unscoped enumeration type.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >For subtraction, one of the following shall hold:</p><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><p >both operands have arithmetic or unscoped enumeration type; or</p><p ><span class='indexparent'><a class='index' id='arithmetic,pointer'></a></span></p></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><p >both operands are pointers to cv-qualified or cv-unqualified
versions of the same completely-defined object type; or</p></li><li id='2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.3'>(2.3)</a></div><p >the left operand is a pointer to a completely-defined object type
and the right operand has integral or unscoped enumeration type.
</p></li></ul></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The result of the binary <span class='texttt'>+</span> operator is the sum of the operands.
The result of the binary <span class='texttt'>-</span> operator is the difference resulting
from the subtraction of the second operand from the first.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='arithmetic,pointer'></a></span>For the purposes of these operators, a pointer to a nonarray object
behaves the same as a pointer to the first element of an array of length
one with the type of the object as its element type.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >When an expression that has integral type is added to or subtracted from
a pointer, the result has the type of the pointer operand. If the
pointer operand points to an element of an array object, and the array
is large enough, the result points to an element offset from the
original element such that the difference of the subscripts of the
resulting and original array elements equals the integral expression. In
other words, if the expression <span class='texttt'>P</span> points to the <span class='math'><span class='mathalpha'>i</span></span>-th element of
an array object, the expressions <span class='texttt'>(P)+N</span> (equivalently,
<span class='texttt'>N+(P)</span>) and <span class='texttt'>(P)-N</span> (where <span class='texttt'>N</span> has the value <span class='math'><span class='mathalpha'>n</span></span>)
point to, respectively, the <span class='math'><span class='mathalpha'>i</span>+<span class='mathalpha'>n</span></span>-th and <span class='math'><span class='mathalpha'>i</span>-<span class='mathalpha'>n</span></span>-th elements of the array
object, provided they exist. Moreover, if the expression <span class='texttt'>P</span>
points to the last element of an array object, the expression
<span class='texttt'>(P)+1</span> points one past the last element of the array object, and
if the expression <span class='texttt'>Q</span> points one past the last element of an array
object, the expression <span class='texttt'>(Q)-1</span> points to the last element of the
array object. If both the pointer operand and the result point to
elements of the same array object, or one past the last element of the
array object, the evaluation shall not produce an overflow; otherwise,
the behavior is undefined.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='ptrdiff_t,implementation_defined_type_of'></a></span><span class='indexparent'><a class='index' id='subtraction,implementation_defined_pointer'></a></span><span class='indexparent'><a class='index' id='ptrdiff_t'></a></span><span class='indexparent'><a class='index' id='cstddef'></a></span><span class='indexparent'><a class='index' id='comparison,undefined_pointer'></a></span>When two pointers to elements of the same array object are subtracted,
the result is the difference of the subscripts of the two array
elements. The type of the result is an <span class='indexparent'><a class='index' id='type_of_ptrdiff_t'></a></span>implementation-defined signed
integral type; this type shall be the same type that is defined as
<span class='texttt'>std::ptrdiff_t</span> in the <span class='texttt'>&lt;cstddef&gt;</span>
header (<a href='support.types'>[support.types]</a>). As with any other arithmetic overflow, if
the result does not fit in the space provided, the behavior is
undefined. In other words, if the expressions <span class='texttt'>P</span> and <span class='texttt'>Q</span>
point to, respectively, the <span class='math'><span class='mathalpha'>i</span></span>-th and <span class='math'><span class='mathalpha'>j</span></span>-th elements of an array
object, the expression <span class='texttt'>(P)-(Q)</span> has the value <span class='math'><span class='mathalpha'>i</span>-<span class='mathalpha'>j</span></span> provided the
value fits in an object of type <span class='texttt'>std::ptrdiff_t</span>. Moreover, if the
expression <span class='texttt'>P</span> points either to an element of an array object or
one past the last element of an array object, and the expression
<span class='texttt'>Q</span> points to the last element of the same array object, the
expression <span class='texttt'>((Q)+1)-(P)</span> has the same value as <span class='texttt'>((Q)-(P))+1</span>
and as <span class='texttt'>-((P)-((Q)+1))</span>, and has the value zero if the expression
<span class='texttt'>P</span> points one past the last element of the array object, even
though the expression <span class='texttt'>(Q)+1</span> does not point to an element of the
array object. Unless both pointers point to elements of the same array
object, or one past the last element of the array object, the behavior
is undefined.<a class='footnotenum' href='#footnote-82'>82</a></p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >If the value 0 is added to or subtracted from a pointer value, the
result compares equal to the original pointer value. If two pointers
point to the same object or both point one past the end of the same
array or both are null, and the two pointers are subtracted, the result
compares equal to the value 0 converted to the type
<span class='texttt'>std::ptrdiff_t</span>.</p></div><div class='footnote' id='footnote-82'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-82'>82)</a></div><p >Another way to approach pointer arithmetic is first to convert the
pointer(s) to character pointer(s): In this scheme the integral value of
the expression added to or subtracted from the converted pointer is
first multiplied by the size of the object originally pointed to, and
the resulting pointer is converted back to the original type. For
pointer subtraction, the result of the difference between the character
pointers is similarly divided by the size of the object originally
pointed to.</p><p >When viewed in this way, an implementation need only provide one extra
byte (which might overlap another object in the program) just after the
end of the object in order to satisfy the “one past the last element”
requirements.</p></div></div></div></body></html>