<!DOCTYPE html><html lang='en'><head><title>[iterator.traits]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>24</a> Iterators library <a class='abbr_ref' href='./#iterators'>[iterators]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>24.4</a> Iterator primitives <a class='abbr_ref' href='iterator.primitives#iterator.traits'>[iterator.primitives]</a></h2><div id='iterator.traits'><h3 ><a class='secnum' style='min-width:103pt'>24.4.1</a> Iterator traits <a class='abbr_ref'>[iterator.traits]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >To implement algorithms only in terms of iterators, it is often necessary to
determine the value and
difference types that correspond to a particular iterator type.
Accordingly, it is required that if
<span class='texttt'>Iterator</span>
is the type of an iterator,
the types</p><pre class='codeblock'>
iterator_traits&lt;Iterator&gt;::difference_type
iterator_traits&lt;Iterator&gt;::value_type
iterator_traits&lt;Iterator&gt;::iterator_category
</pre><p >be defined as the iterator's difference type, value type and iterator category, respectively.
In addition, the types</p><pre class='codeblock'>
iterator_traits&lt;Iterator&gt;::reference
iterator_traits&lt;Iterator&gt;::pointer
</pre><p >shall be defined as the iterator's reference and pointer types, that is, for an
iterator object <span class='texttt'>a</span>, the same type as the type of <span class='texttt'>*a</span> and <span class='texttt'>a-&gt;</span>,
respectively. In the case of an output iterator, the types</p><pre class='codeblock'>
iterator_traits&lt;Iterator&gt;::difference_type
iterator_traits&lt;Iterator&gt;::value_type
iterator_traits&lt;Iterator&gt;::reference
iterator_traits&lt;Iterator&gt;::pointer
</pre><p >may be defined as <span class='texttt'>void</span>.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The template
<span class='texttt'>iterator_traits&lt;Iterator&gt;</span>
is defined as</p><pre class='codeblock'>
namespace std {
  template&lt;class Iterator&gt; struct iterator_traits {
    typedef typename Iterator::difference_type difference_type;
    typedef typename Iterator::value_type value_type;
    typedef typename Iterator::pointer pointer;
    typedef typename Iterator::reference reference;
    typedef typename Iterator::iterator_category iterator_category;
  };
}
</pre></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >It is specialized for pointers as</p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; struct iterator_traits&lt;T*&gt; {
    typedef ptrdiff_t difference_type;
    typedef T value_type;
    typedef T* pointer;
    typedef T&amp; reference;
    typedef random_access_iterator_tag iterator_category;
  };
}
</pre><p >and for pointers to const as</p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; struct iterator_traits&lt;const T*&gt; {
    typedef ptrdiff_t difference_type;
    typedef T value_type;
    typedef const T* pointer;
    typedef const T&amp; reference;
    typedef random_access_iterator_tag iterator_category;
  };
}
</pre></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >[&nbsp;<i>Note:</i>
If there is an additional pointer type
<span class='texttt'>&nbsp;__far</span>
such that the difference of two
<span class='texttt'>&nbsp;__far</span>
is of type
<span class='texttt'>long</span>,
an implementation may define</p><pre class='codeblock'>
  template&lt;class T&gt; struct iterator_traits&lt;T __far*&gt; {
    typedef long difference_type;
    typedef T value_type;
    typedef T __far* pointer;
    typedef T __far&amp; reference;
    typedef random_access_iterator_tag iterator_category;
  };
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >[&nbsp;<i>Example:</i>
To implement a generic
<span class='texttt'>reverse</span>
function, a C++ program can do the following:</p><pre class='codeblock'>
template &lt;class BidirectionalIterator&gt;
void reverse(BidirectionalIterator first, BidirectionalIterator last) {
  typename iterator_traits&lt;BidirectionalIterator&gt;::difference_type n =
    distance(first, last);
  --n;
  while(n &gt; 0) {
    typename iterator_traits&lt;BidirectionalIterator&gt;::value_type
     tmp = *first;
    *first++ = *--last;
    *last = tmp;
    n -= 2;
  }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></body></html>