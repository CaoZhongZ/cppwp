<!DOCTYPE html><html lang='en'><head><title>[basic.def]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><div id='basic.def'><h2 ><a class='secnum' style='min-width:88pt'>3.1</a> Declarations and definitions <a class='abbr_ref'>[basic.def]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='declaration!definition~versus'></a></span><span class='indexparent'><a class='index' id='declaration'></a></span><span class='indexparent'><a class='index' id='declaration!name'></a></span>A declaration (Clause <a href='dcl.dcl'>[dcl.dcl]</a>) may introduce
one or more names into a translation
unit or redeclare names introduced by previous declarations.
If so, the
declaration specifies the interpretation and attributes of these names.
A declaration may also have effects including:</p><ul ><li ><p >a static assertion (Clause <a href='dcl.dcl'>[dcl.dcl]</a>),
</p></li><li ><p >controlling template instantiation (<a href='temp.explicit'>[temp.explicit]</a>),
</p></li><li ><p >guiding template argument deduction for constructors (<a href='temp.deduct.guide'>[temp.deduct.guide]</a>),
</p></li><li ><p >use of attributes (Clause <a href='dcl.dcl'>[dcl.dcl]</a>), and
</p></li><li ><p >nothing (in the case of an <i ><a href='dcl.dcl#empty-declaration'>empty-declaration</a></i>).
</p></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='declaration!function'></a></span><span class='indexparent'><a class='index' id='definition'></a></span>A declaration is a <a id='definition'><i>definition</i></a> unless
</p><ul ><li ><p >it declares a function
without specifying the function's body (<a href='dcl.fct.def'>[dcl.fct.def]</a>),
</p></li><li ><p >it contains
the
<span class='indexparent'><a class='index' id='declaration!extern'></a></span><span class='texttt'>extern</span> specifier (<a href='dcl.stc'>[dcl.stc]</a>) or a
<i ><a href='dcl.link#linkage-specification'>linkage-specification</a></i><a class='footnotenum' href='#footnote-25'>25</a>
(<a href='dcl.link'>[dcl.link]</a>) and neither an <i ><a href='dcl.init#initializer'>initializer</a></i> nor a
<i ><a href='dcl.fct.def.general#function-body'>function-body</a></i>,
</p></li><li ><p ><span class='indexparent'><a class='index' id='declaration!static member'></a></span>it declares a non-inline static data member in a class
definition (<a href='class.mem'>[class.mem]</a>, <a href='class.static'>[class.static]</a>),
</p></li><li ><p >it declares a static data member outside a class definition
and the variable was defined within the class with the <span class='texttt'>constexpr</span>
specifier (this usage is deprecated; see <a href='depr.static_constexpr'>[depr.static_constexpr]</a>),
</p></li><li ><p ><span class='indexparent'><a class='index' id='declaration!class~name'></a></span>it is a class name declaration (<a href='class.name'>[class.name]</a>),
</p></li><li ><p >it is an
<span class='indexparent'><a class='index' id='declaration!opaque~enum'></a></span><i ><a href='dcl.enum#opaque-enum-declaration'>opaque-enum-declaration</a></i> (<a href='dcl.enum'>[dcl.enum]</a>),
</p></li><li ><p >it is a
<span class='indexparent'><a class='index' id='parameter!template'></a></span><span class='indexparent'><a class='index' id='template parameter'></a></span><i ><a href='temp.param#template-parameter'>template-parameter</a></i> (<a href='temp.param'>[temp.param]</a>),
</p></li><li ><p >it is a
<span class='indexparent'><a class='index' id='declaration!parameter'></a></span><span class='indexparent'><a class='index' id='parameter declaration'></a></span><i ><a href='dcl.fct#parameter-declaration'>parameter-declaration</a></i> (<a href='dcl.fct'>[dcl.fct]</a>) in a function
<span class='indexparent'><a class='index' id='declarator'></a></span>declarator that is not the <i ><a href='dcl.decl#declarator'>declarator</a></i> of a
<i ><a href='dcl.fct.def.general#function-definition'>function-definition</a></i>,
</p></li><li ><p >it is a
<span class='indexparent'><a class='index' id='declaration!typedef'></a></span><span class='texttt'>typedef</span> declaration (<a href='dcl.typedef'>[dcl.typedef]</a>),
</p></li><li ><p >it is
an <i ><a href='dcl.dcl#alias-declaration'>alias-declaration</a></i> (<a href='dcl.typedef'>[dcl.typedef]</a>),
</p></li><li ><p >it is
a
<i ><a href='namespace.udecl#using-declaration'>using-declaration</a></i> (<a href='namespace.udecl'>[namespace.udecl]</a>),
</p></li><li ><p >it is
a <i ><a href='temp.deduct.guide#deduction-guide'>deduction-guide</a></i> (<a href='temp.deduct.guide'>[temp.deduct.guide]</a>),
</p></li><li ><p >it is
a <i ><a href='dcl.dcl#static_assert-declaration'>static_assert-declaration</a></i> (Clause <a href='dcl.dcl'>[dcl.dcl]</a>),
</p></li><li ><p >it is an
<i ><a href='dcl.dcl#attribute-declaration'>attribute-declaration</a></i> (Clause <a href='dcl.dcl'>[dcl.dcl]</a>),
</p></li><li ><p >it is an
<i ><a href='dcl.dcl#empty-declaration'>empty-declaration</a></i> (Clause <a href='dcl.dcl'>[dcl.dcl]</a>),
</p></li><li ><p >it is
a <i ><a href='namespace.udir#using-directive'>using-directive</a></i> (<a href='namespace.udir'>[namespace.udir]</a>),
</p></li><li ><p >it is
an explicit instantiation declaration (<a href='temp.explicit'>[temp.explicit]</a>), or
</p></li><li ><p >it is
an explicit specialization (<a href='temp.expl.spec'>[temp.expl.spec]</a>) whose
<i ><a href='dcl.dcl#declaration'>declaration</a></i> is not a definition.
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span> all but one of the following are definitions:</p><p ><span class='indexparent'><a class='index' id='example!definition'></a></span></p><pre class='codeblock'>
int a;                          <span class='comment'>// defines <span class='texttt'>a</span>
</span>extern const int c = 1;         <span class='comment'>// defines <span class='texttt'>c</span>
</span>int f(int x) { return x+a; }    <span class='comment'>// defines <span class='texttt'>f</span> and defines <span class='texttt'>x</span>
</span>struct S { int a; int b; };     <span class='comment'>// defines <span class='texttt'>S</span>, <span class='texttt'>S::a</span>, and <span class='texttt'>S::b</span>
</span>struct X {                      <span class='comment'>// defines <span class='texttt'>X</span>
</span>  int x;                        <span class='comment'>// defines non-static data member <span class='texttt'>x</span>
</span>  static int y;                 <span class='comment'>// declares static data member <span class='texttt'>y</span>
</span>  X(): x(0) { }                 <span class='comment'>// defines a constructor of <span class='texttt'>X</span>
</span>};
int X::y = 1;                   <span class='comment'>// defines <span class='texttt'>X::y</span>
</span>enum { up, down };              <span class='comment'>// defines <span class='texttt'>up</span> and <span class='texttt'>down</span>
</span>namespace N { int d; }          <span class='comment'>// defines <span class='texttt'>N</span> and <span class='texttt'>N::d</span>
</span>namespace N1 = N;               <span class='comment'>// defines <span class='texttt'>N1</span>
</span>X anX;                          <span class='comment'>// defines <span class='texttt'>anX</span>
</span>
</pre><p >whereas these are just declarations:
<span class='indexparent'><a class='index' id='example!declaration'></a></span></p><pre class='codeblock'>
extern int a;                   <span class='comment'>// declares <span class='texttt'>a</span>
</span>extern const int c;             <span class='comment'>// declares <span class='texttt'>c</span>
</span>int f(int);                     <span class='comment'>// declares <span class='texttt'>f</span>
</span>struct S;                       <span class='comment'>// declares <span class='texttt'>S</span>
</span>typedef int Int;                <span class='comment'>// declares <span class='texttt'>Int</span>
</span>extern X anotherX;              <span class='comment'>// declares <span class='texttt'>anotherX</span>
</span>using N::d;                     <span class='comment'>// declares <span class='texttt'>d</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
<span class='indexparent'><a class='index' id='implementation-generated'></a></span>In some circumstances, C++ implementations implicitly define the
default constructor (<a href='class.ctor'>[class.ctor]</a>),
copy constructor (<a href='class.copy'>[class.copy]</a>),
move constructor (<a href='class.copy'>[class.copy]</a>),
copy assignment operator (<a href='class.copy'>[class.copy]</a>),
move assignment operator (<a href='class.copy'>[class.copy]</a>),
or destructor (<a href='class.dtor'>[class.dtor]</a>) member functions. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span> given</p><pre class='codeblock'>
#include &lt;string&gt;

struct C {
  std::string s;              <span class='comment'>// <span class='texttt'>std::string</span> is the standard library class (Clause <a href='strings'>[strings]</a>)
</span>};

int main() {
  C a;
  C b = a;
  b = a;
}
</pre><p >the implementation will implicitly define functions to make the
definition of <span class='texttt'>C</span> equivalent to</p><pre class='codeblock'>
struct C {
  std::string s;
  C() : s() { }
  C(const C&amp; x): s(x.s) { }
  C(C&amp;&amp; x): s(static_cast&lt;std::string&amp;&amp;&gt;(x.s)) { }
    <span class='comment'>// <span class='texttt'>: s(std::move(x.s)) { }</span>
</span>  C&amp; operator=(const C&amp; x) { s = x.s; return *this; }
  C&amp; operator=(C&amp;&amp; x) { s = static_cast&lt;std::string&amp;&amp;&gt;(x.s); return *this; }
    <span class='comment'>// <span class='texttt'>{ s = std::move(x.s); return *this; }</span>
</span>  ~C() { }
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> A class name can also be implicitly declared by an
<i ><a href='dcl.type.elab#elaborated-type-specifier'>elaborated-type-specifier</a></i> (<a href='dcl.type.elab'>[dcl.type.elab]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='type!incomplete'></a></span>A program is ill-formed if the definition of any object gives the object
an incomplete type (<a href='basic.types'>[basic.types]</a>).</p><p ><span class='indexparent'><a class='index' id='object!definition'></a></span><span class='indexparent'><a class='index' id='function!definition'></a></span><span class='indexparent'><a class='index' id='class!definition'></a></span><span class='indexparent'><a class='index' id='enumerator!definition'></a></span><span class='indexparent'><a class='index' id='one-definition~rule'></a></span></p></div><div class='footnote' id='footnote-25'><div class='marginalizedparent'><a class='marginalized' href='#footnote-25'>25)</a></div><p >Appearing inside the braced-enclosed
<span class='grammarterm'>declaration-seq</span> in a <span class='grammarterm'>linkage-specification</span> does
not affect whether a declaration is a definition.</p></div></div></div></body></html>