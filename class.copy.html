<!DOCTYPE html><html lang='en'><head><title>[class.copy]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>15</a> Special member functions <a class='abbr_ref' href='./#special'>[special]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>15.8</a> Copying and moving class objects <a class='abbr_ref'>[class.copy]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2396'>#</a></div><p >A class object can be copied or moved in two ways:
by initialization (<a href='class.ctor'>[class.ctor]</a>, <a href='dcl.init'>[dcl.init]</a>), including for function argument passing (<a href='expr.call'>[expr.call]</a>) and for <a href='stmt.return'>function value return</a>;
and by <a href='expr.ass'>assignment</a>.
Conceptually, these two operations are implemented by a
copy/move constructor (<a href='class.ctor'>[class.ctor]</a>)
and copy/move assignment operator (<a href='over.ass'>[over.ass]</a>).</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2404'>#</a></div><p ><span class='indexparent'><a class='index' id=':constructor,copy,inaccessible'></a></span><span class='indexparent'><a class='index' id=':constructor,move,inaccessible'></a></span><span class='indexparent'><a class='index' id=':assignment_operator,copy,inaccessible'></a></span><span class='indexparent'><a class='index' id=':assignment_operator,move,inaccessible'></a></span>A program is ill-formed if the copy/move constructor or the copy/move assignment
operator for an object is implicitly odr-used and the special member function
is not <a href='class.access'>accessible</a>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
Copying/moving one object into another using the copy/move constructor or
the copy/move assignment operator does not change the layout or size of either
object.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div id='ctor'><h3 ><a class='secnum' href='#ctor' style='min-width:103pt'>15.8.1</a> Copy/move constructors <a class='abbr_ref' href='class.copy.ctor'>[class.copy.ctor]</a></h3><div class='para' id='ctor-1'><div class='marginalizedparent'><a class='marginalized' href='#ctor-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2420'>#</a></div><p ><span class='indexparent'><a class='index' id=':constructor,copy'></a></span><span class='indexparent'><a class='index' id=':constructor,move'></a></span>A non-template constructor for class
<span class='texttt'>X</span>
is
a
<a class='hidden_link' href='#def:constructor,copy' id='def:constructor,copy'><i >copy constructor</i></a> if its first parameter is of type
<span class='texttt'>X&amp;</span>,
<span class='texttt'>const X&amp;</span>,
<span class='texttt'>volatile X&amp;</span>
or
<span class='texttt'>const volatile X&amp;</span>,
and either there are no other parameters
or else all other parameters have <a href='dcl.fct.default'>default arguments</a>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
<span class='texttt'>X&#x200b;::&#x200b;X(const X&amp;)</span>
and
<span class='texttt'>X&#x200b;::&#x200b;X(X&amp;,int=1)</span>
are copy constructors.</p><pre class='codeblock'>
struct X {
  X(int);
  X(const X&amp;, int = 1);
};
X a(1);             <span class='comment'>// calls <span class='tcode_in_codeblock'>X(int);</span>
</span>X b(a, 0);          <span class='comment'>// calls <span class='tcode_in_codeblock'>X(const X&amp;, int);</span>
</span>X c = b;            <span class='comment'>// calls <span class='tcode_in_codeblock'>X(const X&amp;, int);</span>
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='ctor-2'><div class='marginalizedparent'><a class='marginalized' href='#ctor-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2454'>#</a></div><p >A non-template constructor for class <span class='texttt'>X</span> is a <a class='hidden_link' href='#def:constructor,move' id='def:constructor,move'><i >move constructor</i></a> if its
first parameter is of type <span class='texttt'>X&amp;&amp;</span>, <span class='texttt'>const X&amp;&amp;</span>,
<span class='texttt'>volatile X&amp;&amp;</span>, or <span class='texttt'>const volatile X&amp;&amp;</span>, and either there are
no other parameters or else all other parameters have <a href='dcl.fct.default'>default
arguments</a>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>  <span class='texttt'>Y&#x200b;::&#x200b;Y(Y&amp;&amp;)</span> is a move constructor.
</p><pre class='codeblock'>
struct Y {
  Y(const Y&amp;);
  Y(Y&amp;&amp;);
};
extern Y f(int);
Y d(f(1));          <span class='comment'>// calls <span class='tcode_in_codeblock'>Y(Y&amp;&amp;)</span>
</span>Y e = d;            <span class='comment'>// calls <span class='tcode_in_codeblock'>Y(const Y&amp;)</span>
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='ctor-3'><div class='marginalizedparent'><a class='marginalized' href='#ctor-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2472'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
All forms of copy/move constructor may be declared for a class.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><pre class='codeblock'>
struct X {
  X(const X&amp;);
  X(X&amp;);            <span class='comment'>// OK
</span>  X(X&amp;&amp;);
  X(const X&amp;&amp;);     <span class='comment'>// OK, but possibly not sensible
</span>};</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] 
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='ctor-4'><div class='marginalizedparent'><a class='marginalized' href='#ctor-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2488'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
If a class
<span class='texttt'>X</span>
only has a copy constructor with a parameter of type
<span class='texttt'>X&amp;</span>,
an initializer of type
<span class='texttt'>const</span>
<span class='texttt'>X</span>
or
<span class='texttt'>volatile</span>
<span class='texttt'>X</span>
cannot initialize an object of type
(possibly
cv-qualified)
<span class='texttt'>X</span>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><pre class='codeblock'>
struct X {
  X();              <span class='comment'>// default constructor
</span>  X(X&amp;);            <span class='comment'>// copy constructor with a non-const parameter
</span>};
const X cx;
X x = cx;           <span class='comment'>// error: <span class='tcode_in_codeblock'>X&#x200b;::&#x200b;X(X&amp;)</span> cannot copy <span class='tcode_in_codeblock'>cx</span> into <span class='tcode_in_codeblock'>x</span>
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] 
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='ctor-5'><div class='marginalizedparent'><a class='marginalized' href='#ctor-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2517'>#</a></div><p >A declaration of a constructor for a class
<span class='texttt'>X</span>
is ill-formed if its first parameter is of type (optionally cv-qualified)
<span class='texttt'>X</span>
and either there are no other parameters or else all other parameters have
default arguments.
A member function template is never instantiated to
produce such a constructor signature.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
struct S {
  template&lt;typename T&gt; S(T);
  S();
};

S g;

void h() {
  S a(g);           <span class='comment'>// does not instantiate the member template to produce <span class='tcode_in_codeblock'>S&#x200b;::&#x200b;S&lt;S&gt;(S)</span>;
</span>                    <span class='comment'>// uses the implicitly declared copy constructor
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='ctor-6'><div class='marginalizedparent'><a class='marginalized' href='#ctor-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2542'>#</a></div><p >If the class definition does not explicitly declare a copy constructor,
a non-explicit one is declared <a class='hidden_link' href='#def:constructor,copy,implicitly_declared' id='def:constructor,copy,implicitly_declared'><i >implicitly</i></a>.
If the class definition declares a move
constructor or move assignment operator, the implicitly declared copy
constructor is defined as deleted; otherwise, it is defined as
<a href='dcl.fct.def'>defaulted</a>.
The latter case is deprecated if the class has a user-declared copy assignment
operator or a user-declared destructor.</p></div><div class='para' id='ctor-7'><div class='marginalizedparent'><a class='marginalized' href='#ctor-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2552'>#</a></div><p >The implicitly-declared copy constructor for a class
<span class='texttt'>X</span>
will have the form</p><pre class='codeblock'>
X::X(const X&amp;)</pre><p >if each potentially constructed subobject of a class type
<span class='texttt'>M</span>
(or array thereof)
has a copy constructor whose first parameter is of type
<span class='texttt'>const</span>
<span class='texttt'>M&amp;</span>
or
<span class='texttt'>const</span>
<span class='texttt'>volatile</span>
<span class='texttt'>M&amp;</span>.<a class='footnotenum' href='#footnote-119'>119</a>
Otherwise, the implicitly-declared copy constructor will have the form</p><pre class='codeblock'>
X::X(X&amp;)</pre></div><div class='para' id='ctor-8'><div class='marginalizedparent'><a class='marginalized' href='#ctor-8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2581'>#</a></div><p ><span class='indexparent'><a class='index' id=':constructor,move,implicitly_declared'></a></span>If the definition of a class <span class='texttt'>X</span> does not explicitly declare
a move constructor, a non-explicit one will be
implicitly declared as defaulted if and only if</p><ul class='itemize'><li id='ctor-8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ctor-8.1'>(8.1)</a></div><p ><span class='texttt'>X</span> does not have a user-declared copy constructor,</p></li><li id='ctor-8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ctor-8.2'>(8.2)</a></div><p ><span class='texttt'>X</span> does not have a user-declared copy assignment operator,</p></li><li id='ctor-8.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ctor-8.3'>(8.3)</a></div><p ><span class='texttt'>X</span> does not have a user-declared move assignment operator, and</p></li><li id='ctor-8.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ctor-8.4'>(8.4)</a></div><p ><span class='texttt'>X</span> does not have a user-declared destructor.
</p></li></ul><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  When the move constructor is not implicitly declared or explicitly supplied,
expressions that otherwise would have invoked the move constructor may instead invoke
a copy constructor. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='ctor-9'><div class='marginalizedparent'><a class='marginalized' href='#ctor-9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2605'>#</a></div><p >The implicitly-declared move constructor for class <span class='texttt'>X</span> will have the form
</p><pre class='codeblock'>
X::X(X&amp;&amp;)</pre></div><div class='para' id='ctor-10'><div class='marginalizedparent'><a class='marginalized' href='#ctor-10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2611'>#</a></div><p >An implicitly-declared copy/move constructor is an
<span class='texttt'>inline</span>
<span class='texttt'>public</span>
member of its class.
A defaulted copy/&#x200b;move constructor for a class
  <span class='texttt'>X</span> is defined as <a href='dcl.fct.def.delete'>deleted</a> if <span class='texttt'>X</span> has:
</p><ul class='itemize'><li id='ctor-10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ctor-10.1'>(10.1)</a></div><p >a variant member with a non-trivial corresponding constructor and
  <span class='texttt'>X</span> is a union-like class,</p></li><li id='ctor-10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ctor-10.2'>(10.2)</a></div><p >a potentially constructed subobject type
  <span class='texttt'>M</span> (or array thereof) that cannot be copied/moved because
  <a href='over.match'>overload resolution</a>, as applied to find
  <span class='texttt'>M</span>'s
  corresponding constructor, results in an ambiguity or
  a function that is deleted or inaccessible from the
  defaulted constructor,</p></li><li id='ctor-10.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ctor-10.3'>(10.3)</a></div><p >any potentially constructed subobject of a type
  with a destructor that is deleted or inaccessible from the defaulted
  constructor, or,</p></li><li id='ctor-10.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ctor-10.4'>(10.4)</a></div><p >for the copy constructor, a non-static data member of rvalue reference type.
</p></li></ul><p >A defaulted move constructor that is defined as deleted is ignored by overload
resolution (<a href='over.match'>[over.match]</a>, <a href='over.over'>[over.over]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
A deleted move constructor would otherwise interfere with initialization from
an rvalue which can use the copy constructor instead.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='ctor-11'><div class='marginalizedparent'><a class='marginalized' href='#ctor-11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2644'>#</a></div><p ><span class='indexparent'><a class='index' id=':constructor,copy,trivial'></a></span><span class='indexparent'><a class='index' id=':constructor,move,trivial'></a></span>A copy/move constructor for class
<span class='texttt'>X</span>
is
trivial
if it is not user-provided and if:</p><ul class='itemize'><li id='ctor-11.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ctor-11.1'>(11.1)</a></div><p >class
<span class='texttt'>X</span>
has no <a href='class.virtual'>virtual functions</a>
and no <a href='class.mi#def:base_class,virtual'>virtual base classes</a>, and</p></li><li id='ctor-11.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ctor-11.2'>(11.2)</a></div><p >the constructor selected to copy/move each direct base class subobject is trivial, and</p></li><li id='ctor-11.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ctor-11.3'>(11.3)</a></div><p >for each non-static data member of
<span class='texttt'>X</span>
that is of class type (or array thereof),
the constructor selected to copy/move that member is trivial;
</p></li></ul><p ><span class='indexparent'><a class='index' id=':constructor,move,non-trivial'></a></span>otherwise the copy/move constructor is
<a class='hidden_link' href='#def:constructor,copy,nontrivial' id='def:constructor,copy,nontrivial'><i >non-trivial</i></a>.</p></div><div class='para' id='ctor-12'><div class='marginalizedparent'><a class='marginalized' href='#ctor-12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2674'>#</a></div><p ><span class='indexparent'><a class='index' id=':constructor,copy,implicitly_defined'></a></span><span class='indexparent'><a class='index' id=':constructor,move,implicitly_defined'></a></span>A copy/move constructor
that is defaulted and not defined as deleted
is
<span class='textit'>implicitly defined</span>
if it is <a href='basic.def.odr'>odr-used</a>
or when it is explicitly defaulted after its first declaration.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
The copy/move constructor is implicitly defined even if the implementation elided
its <a href='basic.def.odr'>odr-use</a> (<a href='class.temporary'>[class.temporary]</a>).
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
If the implicitly-defined constructor would satisfy the requirements of a
<a href='dcl.constexpr#def:specifier,constexpr,constructor'>constexpr constructor</a>, the implicitly-defined
constructor is <span class='texttt'>constexpr</span>.</p></div><div class='para' id='ctor-13'><div class='marginalizedparent'><a class='marginalized' href='#ctor-13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2691'>#</a></div><p >Before the defaulted copy/move constructor for a class is
implicitly defined,
all non-user-provided copy/move constructors for its
potentially constructed subobjects
shall have been implicitly defined.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
An implicitly-declared copy/move constructor has an
implied <a href='except.spec'>exception specification</a>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='ctor-14'><div class='marginalizedparent'><a class='marginalized' href='#ctor-14'>14</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2702'>#</a></div><p >The implicitly-defined copy/move constructor for a non-union class
<span class='texttt'>X</span>
performs a memberwise copy/move of its bases and members.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  Default member initializers of non-static data members are ignored. See also the example in <a href='class.base.init'>[class.base.init]</a>. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
The order of initialization is the same as the order of initialization of bases
and members in a user-defined constructor (see <a href='class.base.init'>[class.base.init]</a>).
Let <span class='texttt'>x</span> be either the parameter of the constructor or, for the move constructor, an
xvalue referring to the parameter.
Each base or non-static data member
is copied/moved in the manner appropriate to its type:</p><ul class='itemize'><li id='ctor-14.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ctor-14.1'>(14.1)</a></div><p >if the member is an array, each element is
direct-initialized with the corresponding subobject of <span class='texttt'>x</span>;</p></li><li id='ctor-14.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ctor-14.2'>(14.2)</a></div><p >if a member <span class='texttt'>m</span> has rvalue reference type <span class='texttt'>T&amp;&amp;</span>, it is direct-initialized with
<span class='texttt'>static_&shy;cast&lt;T&amp;&amp;&gt;(x.m)</span>;</p></li><li id='ctor-14.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ctor-14.3'>(14.3)</a></div><p >otherwise, the base or member is direct-initialized with the corresponding base or member of <span class='texttt'>x</span>.
</p></li></ul><p ><span class='indexparent'><a class='index' id=':initialization,virtual_base_class'></a></span>Virtual base class subobjects shall be initialized only once by
the implicitly-defined copy/move constructor (see <a href='class.base.init'>[class.base.init]</a>).</p></div><div class='para' id='ctor-15'><div class='marginalizedparent'><a class='marginalized' href='#ctor-15'>15</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2731'>#</a></div><p >The implicitly-defined copy/move constructor for a union
<span class='texttt'>X</span> copies the <a href='basic.types#def:object_representation'>object representation</a> of <span class='texttt'>X</span>.</p></div><div class='footnote' id='footnote-119'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-119'>119)</a></div><p >This implies that the reference parameter of the
implicitly-declared copy constructor
cannot bind to a
<span class='texttt'>volatile</span>
lvalue; see <a href='diff.special'>[diff.special]</a>.</p></div></div><div id='assign'><h3 ><a class='secnum' href='#assign' style='min-width:103pt'>15.8.2</a> Copy/move assignment operator <a class='abbr_ref' href='class.copy.assign'>[class.copy.assign]</a></h3><div class='para' id='assign-1'><div class='marginalizedparent'><a class='marginalized' href='#assign-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2740'>#</a></div><p ><span class='indexparent'><a class='index' id=':assignment_operator,copy'></a></span><span class='indexparent'><a class='index' id=':assignment_operator,move'></a></span>
A user-declared <a class='hidden_link' href='#def:assignment_operator,copy' id='def:assignment_operator,copy'><i >copy</i></a> assignment operator <span class='texttt'>X&#x200b;::&#x200b;operator=</span> is a
non-static non-template member function of class <span class='texttt'>X</span> with exactly one
parameter of type <span class='texttt'>X</span>, <span class='texttt'>X&amp;</span>, <span class='texttt'>const</span> <span class='texttt'>X&amp;</span>,
<span class='texttt'>volatile</span> <span class='texttt'>X&amp;</span> or <span class='texttt'>const</span> <span class='texttt'>volatile</span>
<span class='texttt'>X&amp;</span>.<a class='footnotenum' href='#footnote-120'>120</a>
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
An overloaded assignment operator must be declared to have only one parameter;
see <a href='over.ass'>[over.ass]</a>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
More than one form of copy assignment operator may be declared for a class.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
If a class
<span class='texttt'>X</span>
only has a copy assignment operator with a parameter of type
<span class='texttt'>X&amp;</span>,
an expression of type const
<span class='texttt'>X</span>
cannot be assigned to an object of type
<span class='texttt'>X</span>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><pre class='codeblock'>
struct X {
  X();
  X&amp; operator=(X&amp;);
};
const X cx;
X x;
void f() {
  x = cx;           <span class='comment'>// error: <span class='tcode_in_codeblock'>X&#x200b;::&#x200b;operator=(X&amp;)</span> cannot assign <span class='tcode_in_codeblock'>cx</span> into <span class='tcode_in_codeblock'>x</span>
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] 
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='assign-2'><div class='marginalizedparent'><a class='marginalized' href='#assign-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2790'>#</a></div><p >If the class definition does not explicitly declare a copy assignment operator,
one is declared <a class='hidden_link' href='#def:assignment_operator,copy,implicitly_declared' id='def:assignment_operator,copy,implicitly_declared'><i >implicitly</i></a>.
If the class definition declares a move
constructor or move assignment operator, the implicitly declared copy
assignment operator is defined as deleted; otherwise, it is defined as
<a href='dcl.fct.def'>defaulted</a>.
The latter case is deprecated if the class has a user-declared copy constructor
or a user-declared destructor.
The implicitly-declared copy assignment operator for a class
<span class='texttt'>X</span>
will have the form</p><pre class='codeblock'>
X&amp; X::operator=(const X&amp;)</pre><p >if</p><ul class='itemize'><li id='assign-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-2.1'>(2.1)</a></div><p >each direct base class
<span class='texttt'>B</span>
of
<span class='texttt'>X</span>
has a copy assignment operator whose parameter is of type
<span class='texttt'>const</span>
<span class='texttt'>B&amp;</span>,
<span class='texttt'>const</span>
<span class='texttt'>volatile</span>
<span class='texttt'>B&amp;</span>
or
<span class='texttt'>B</span>,
and
</p></li><li id='assign-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-2.2'>(2.2)</a></div><p >for all the non-static data members of
<span class='texttt'>X</span>
that are of a class type
<span class='texttt'>M</span>
(or array thereof),
each such class type has a copy assignment operator whose parameter is of type
<span class='texttt'>const</span>
<span class='texttt'>M&amp;</span>,
<span class='texttt'>const</span>
<span class='texttt'>volatile</span>
<span class='texttt'>M&amp;</span>
or
<span class='texttt'>M</span>.<a class='footnotenum' href='#footnote-121'>121</a>
</p></li></ul><p >Otherwise, the implicitly-declared copy
assignment operator
will have the form</p><pre class='codeblock'>
X&amp; X::operator=(X&amp;)</pre></div><div class='para' id='assign-3'><div class='marginalizedparent'><a class='marginalized' href='#assign-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2851'>#</a></div><p >A user-declared <a class='hidden_link' href='#def:assignment_operator,move' id='def:assignment_operator,move'><i >move</i></a> assignment operator <span class='texttt'>X&#x200b;::&#x200b;operator=</span> is
a non-static non-template member function of class <span class='texttt'>X</span> with exactly
one parameter of type <span class='texttt'>X&amp;&amp;</span>, <span class='texttt'>const X&amp;&amp;</span>, <span class='texttt'>volatile X&amp;&amp;</span>, or
<span class='texttt'>const volatile X&amp;&amp;</span>. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  An overloaded assignment operator must be
declared to have only one parameter; see <a href='over.ass'>[over.ass]</a>. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  More
than one form of move assignment operator may be declared for a class. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='assign-4'><div class='marginalizedparent'><a class='marginalized' href='#assign-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2860'>#</a></div><p ><span class='indexparent'><a class='index' id=':assignment_operator,move,implicitly_declared'></a></span>If the definition of a class <span class='texttt'>X</span> does not explicitly declare a
move assignment operator, one
will be implicitly declared as defaulted if and only if</p><ul class='itemize'><li id='assign-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-4.1'>(4.1)</a></div><p ><span class='texttt'>X</span> does not have a user-declared copy constructor,</p></li><li id='assign-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-4.2'>(4.2)</a></div><p ><span class='texttt'>X</span> does not have a user-declared move constructor,</p></li><li id='assign-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-4.3'>(4.3)</a></div><p ><span class='texttt'>X</span> does not have a user-declared copy assignment operator, and</p></li><li id='assign-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-4.4'>(4.4)</a></div><p ><span class='texttt'>X</span> does not have a user-declared destructor.
</p></li></ul><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>  The class definition
</p><pre class='codeblock'>
struct S {
  int a;
  S&amp; operator=(const S&amp;) = default;
};</pre><p >will not have a default move assignment operator implicitly declared because the
copy assignment operator has been user-declared. The move assignment operator may
be explicitly defaulted.</p><pre class='codeblock'>
struct S {
  int a;
  S&amp; operator=(const S&amp;) = default;
  S&amp; operator=(S&amp;&amp;) = default;
};</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='assign-5'><div class='marginalizedparent'><a class='marginalized' href='#assign-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2901'>#</a></div><p >The implicitly-declared move assignment operator for a class <span class='texttt'>X</span> will have the form
</p><pre class='codeblock'>
X&amp; X::operator=(X&amp;&amp;);</pre></div><div class='para' id='assign-6'><div class='marginalizedparent'><a class='marginalized' href='#assign-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2907'>#</a></div><p >The implicitly-declared copy/move assignment operator for class
<span class='texttt'>X</span>
has the return type
<span class='texttt'>X&amp;</span>;
it returns the object for which the assignment operator is invoked, that is,
the object assigned to.
An implicitly-declared copy/move assignment operator is an
<span class='texttt'>inline</span>
<span class='texttt'>public</span>
member of its class.</p></div><div class='para' id='assign-7'><div class='marginalizedparent'><a class='marginalized' href='#assign-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2919'>#</a></div><p >A defaulted copy/move assignment operator for
class <span class='texttt'>X</span> is defined as deleted if <span class='texttt'>X</span> has:
</p><ul class='itemize'><li id='assign-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-7.1'>(7.1)</a></div><p >a variant member with a non-trivial corresponding assignment operator and
  <span class='texttt'>X</span> is a union-like class, or</p></li><li id='assign-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-7.2'>(7.2)</a></div><p >a non-static data member of <span class='texttt'>const</span> non-class
  type (or array thereof), or</p></li><li id='assign-7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-7.3'>(7.3)</a></div><p >a non-static data member of reference type, or</p></li><li id='assign-7.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-7.4'>(7.4)</a></div><p >a direct non-static data member of class type <span class='texttt'>M</span>
  (or array thereof) or a direct base class <span class='texttt'>M</span>
  that cannot be copied/moved because <a href='over.match'>overload resolution</a>,
  as applied to find <span class='texttt'>M</span>'s corresponding
  assignment operator, results in an ambiguity or
  a function that is deleted or inaccessible from the
  defaulted assignment operator.
</p></li></ul><p >A defaulted move assignment operator that is defined as deleted is ignored by
overload resolution (<a href='over.match'>[over.match]</a>, <a href='over.over'>[over.over]</a>).</p></div><div class='para' id='assign-8'><div class='marginalizedparent'><a class='marginalized' href='#assign-8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2943'>#</a></div><p ><span class='indexparent'><a class='index' id=':assignment_operator,copy,hidden'></a></span><span class='indexparent'><a class='index' id=':assignment_operator,move,hidden'></a></span>Because a copy/move assignment operator is implicitly declared for a class
if not declared by the user,
a base class copy/move assignment operator is always hidden
by the corresponding assignment operator of a derived class (<a href='over.ass'>[over.ass]</a>).
A
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> that brings in from a base class an assignment operator
with a parameter type that could be that of a
copy/move assignment operator for the
derived class is not considered an explicit declaration of such an
operator and does not suppress the implicit declaration of the derived class
operator;
the operator introduced by the
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>
is hidden by the implicitly-declared operator in the derived
class.</p></div><div class='para' id='assign-9'><div class='marginalizedparent'><a class='marginalized' href='#assign-9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2962'>#</a></div><p ><span class='indexparent'><a class='index' id=':assignment_operator,copy,trivial'></a></span><span class='indexparent'><a class='index' id=':assignment_operator,move,trivial'></a></span>A copy/move assignment operator for class
<span class='texttt'>X</span>
is
trivial
if it is not user-provided and if:</p><ul class='itemize'><li id='assign-9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-9.1'>(9.1)</a></div><p >class
<span class='texttt'>X</span>
has no <a href='class.virtual'>virtual functions</a>
and no <a href='class.mi'>virtual base classes</a>, and</p></li><li id='assign-9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-9.2'>(9.2)</a></div><p >the assignment operator selected to copy/move each direct
base class subobject is trivial, and</p></li><li id='assign-9.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-9.3'>(9.3)</a></div><p >for each non-static data member of
<span class='texttt'>X</span>
that is of class type (or array thereof),
the assignment operator selected to copy/move that member is trivial;
</p></li></ul><p ><span class='indexparent'><a class='index' id=':assignment_operator,move,non-trivial'></a></span>otherwise the copy/move assignment operator is
<a class='hidden_link' href='#def:assignment_operator,copy,non-trivial' id='def:assignment_operator,copy,non-trivial'><i >non-trivial</i></a>.</p></div><div class='para' id='assign-10'><div class='marginalizedparent'><a class='marginalized' href='#assign-10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L2992'>#</a></div><p ><span class='indexparent'><a class='index' id=':assignment_operator,copy,implicitly_defined'></a></span><span class='indexparent'><a class='index' id=':assignment_operator,move,implicitly_defined'></a></span>A copy/move assignment operator for a class <span class='texttt'>X</span>
that is defaulted and not defined as deleted
is
<span class='textit'>implicitly defined</span>
when
it is <a href='basic.def.odr'>odr-used</a> (e.g., when it is selected by overload resolution
to assign to an object of its class type)
or when it is explicitly defaulted after its first declaration.
The implicitly-defined copy/move assignment operator is <span class='texttt'>constexpr</span> if
</p><ul class='itemize'><li id='assign-10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-10.1'>(10.1)</a></div><p ><span class='texttt'>X</span> is a literal type, and</p></li><li id='assign-10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-10.2'>(10.2)</a></div><p >the assignment operator selected to copy/move each direct base class subobject
is a constexpr function, and</p></li><li id='assign-10.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-10.3'>(10.3)</a></div><p >for each non-static data member of <span class='texttt'>X</span> that is of class type (or array
thereof), the assignment operator selected to copy/move that member is a
constexpr function.
</p></li></ul></div><div class='para' id='assign-11'><div class='marginalizedparent'><a class='marginalized' href='#assign-11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L3018'>#</a></div><p >Before the defaulted copy/move assignment operator for a class is
implicitly defined,
all non-user-provided copy/move assignment operators for
its direct base classes and
its non-static data members shall have been implicitly defined.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
An implicitly-declared copy/move assignment operator has an
implied <a href='except.spec'>exception specification</a>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='assign-12'><div class='marginalizedparent'><a class='marginalized' href='#assign-12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L3029'>#</a></div><p >The implicitly-defined copy/move assignment operator for a
non-union class <span class='texttt'>X</span> performs memberwise copy/move assignment of its subobjects. The direct
base classes of <span class='texttt'>X</span> are assigned first, in the order of their declaration in the
<i ><a href='class.derived#nt:base-specifier-list'>base-specifier-list</a></i>, and then the immediate non-static data members of
<span class='texttt'>X</span> are assigned, in the order in which they were declared in the class
definition.
Let <span class='texttt'>x</span> be either the parameter of the function or, for the move operator, an
xvalue referring to the parameter.
Each subobject is assigned in the manner appropriate to its type:</p><ul class='itemize'><li id='assign-12.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-12.1'>(12.1)</a></div><p >if the subobject is of class type,
as if by a call to <span class='texttt'>operator=</span> with the subobject as the object expression
and the corresponding subobject of <span class='texttt'>x</span> as a single function argument
(as if by explicit qualification; that is,
ignoring any possible virtual overriding functions in more derived classes);
</p></li><li id='assign-12.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-12.2'>(12.2)</a></div><p >if the subobject is an array, each element is assigned,
in the manner appropriate to the element type;
</p></li><li id='assign-12.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-12.3'>(12.3)</a></div><p >if the subobject is of scalar type,
the built-in assignment operator is used.
</p></li></ul><p ><span class='indexparent'><a class='index' id=':assignment_operator,copy,virtual_bases_and'></a></span>It is unspecified whether subobjects representing virtual base classes
are assigned more than once by the implicitly-defined copy/move assignment
operator.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><pre class='codeblock'>
struct V { };
struct A : virtual V { };
struct B : virtual V { };
struct C : B, A { };</pre><p >It is unspecified whether the virtual base class subobject
<span class='texttt'>V</span>
is assigned twice by the implicitly-defined copy/move assignment operator for
<span class='texttt'>C</span>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='assign-13'><div class='marginalizedparent'><a class='marginalized' href='#assign-13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L3074'>#</a></div><p >The implicitly-defined copy assignment operator for a
union <span class='texttt'>X</span> copies the <a href='basic.types#def:object_representation'>object representation</a> of <span class='texttt'>X</span>.</p></div><div class='footnote' id='footnote-120'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-120'>120)</a></div><p >Because a template assignment operator or an assignment
operator taking an rvalue reference parameter is never a copy assignment
operator, the presence of such an assignment operator does not suppress the
implicit declaration of a copy assignment operator. Such assignment operators
participate in overload resolution with other assignment operators, including
copy assignment operators, and, if selected, will be used to assign an object.</p></div><div class='footnote' id='footnote-121'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-121'>121)</a></div><p >This implies that the reference parameter of the
implicitly-declared copy assignment operator cannot bind to a
<span class='texttt'>volatile</span>
lvalue; see <a href='diff.special'>[diff.special]</a>.</p></div></div><div id='elision'><h3 ><a class='secnum' href='#elision' style='min-width:103pt'>15.8.3</a> Copy/move elision <a class='abbr_ref' href='class.copy.elision'>[class.copy.elision]</a></h3><div class='para' id='elision-1'><div class='marginalizedparent'><a class='marginalized' href='#elision-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L3082'>#</a></div><p ><span class='indexparent'><a class='index' id=':temporary,elimination_of'></a></span><span class='indexparent'><a class='index' id=':constructor,copy,elision'></a></span><span class='indexparent'><a class='index' id=':constructor,move,elision'></a></span>When certain criteria are met, an implementation is
allowed to omit the copy/move construction of a class object,
even if the constructor selected for the copy/move operation and/or the
destructor for the object have
<span class='indexparent'><a class='index' id=':side_effects'></a></span>side effects.  In such cases, the
implementation treats the source and target of the
omitted copy/move operation as simply two different ways of
referring to the same object. If the first parameter of the
selected constructor is an rvalue reference to the object's type,
the destruction of that object occurs when the target would have been destroyed;
otherwise, the destruction occurs at the later of the times when the
two objects would have been destroyed without the
optimization.<a class='footnotenum' href='#footnote-122'>122</a>
This elision of copy/move operations, called
<span class='indexparent'><a class='index' id=':constructor,copy,elision_'></a></span><span class='indexparent'><a class='index' id=':constructor,move,elision_'></a></span><a class='hidden_link' href='#def:copy_elision' id='def:copy_elision'><i>copy elision</i></a>,
is permitted in the
following circumstances (which may be combined to
eliminate multiple copies):</p><ul class='itemize'><li id='elision-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#elision-1.1'>(1.1)</a></div><p >in a <span class='texttt'>return</span> statement in a function with a class return type,
when the <i ><a href='expr.comma#nt:expression'>expression</a></i> is the name of a non-volatile
automatic object (other than a function parameter or a variable
introduced by the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> of a
<i ><a href='except#nt:handler'>handler</a></i> (<a href='except.handle'>[except.handle]</a>))
with the same type (ignoring cv-qualification) as
the function return type, the copy/move operation can be
omitted by constructing the automatic object directly
into the function call's return object</p></li><li id='elision-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#elision-1.2'>(1.2)</a></div><p >in a <i ><a href='expr.throw#nt:throw-expression'>throw-expression</a></i>, when the operand
is the name of a non-volatile automatic object
(other than a function or catch-clause parameter)
whose scope does not extend beyond the end of the innermost enclosing
<i ><a href='except#nt:try-block'>try-block</a></i> (if there is one), the copy/move operation from the
operand to the <a href='except.throw#def:exception_handling,exception_object'>exception object</a> can be omitted by
constructing the automatic object directly into the exception object</p></li><li id='elision-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#elision-1.3'>(1.3)</a></div><p >when the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> of an
exception handler (Clause <a href='except'>[except]</a>) declares an object of the same
type (except for cv-qualification) as the
<a href='except.throw#def:exception_handling,exception_object'>exception object</a>,
the copy operation can be omitted by treating
the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> as an alias for the exception
object if the meaning of the program will be unchanged except for the execution
of constructors and destructors for the object declared by the
<i ><a href='except#nt:exception-declaration'>exception-declaration</a></i>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  There cannot be a move from the exception object because it is
always an lvalue.  <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
</p></li></ul><p >Copy elision is required
where an expression is evaluated in a context
requiring a <a href='expr.const'>constant expression</a>
and in <a href='basic.start.static#def:constant_initialization'>constant initialization</a>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
Copy elision might not be performed
if the same expression
is evaluated in another context.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='elision-2'><div class='marginalizedparent'><a class='marginalized' href='#elision-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L3153'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
class Thing {
public:
  Thing();
  ~Thing();
  Thing(const Thing&amp;);
};

Thing f() {
  Thing t;
  return t;
}

Thing t2 = f();

struct A {
  void *p;
  constexpr A(): p(this) {}
};

constexpr A g() {
  A a;
  return a;
}

constexpr A a;          <span class='comment'>// well-formed, <span class='tcode_in_codeblock'>a.p</span> points to <span class='tcode_in_codeblock'>a</span>
</span>constexpr A b = g();    <span class='comment'>// well-formed, <span class='tcode_in_codeblock'>b.p</span> points to <span class='tcode_in_codeblock'>b</span>
</span>
void g() {
  A c = g();            <span class='comment'>// well-formed, <span class='tcode_in_codeblock'>c.p</span> may point to <span class='tcode_in_codeblock'>c</span> or to an ephemeral temporary
</span>}</pre><p >Here the criteria for elision can
eliminate
the copying of the local automatic object
<span class='texttt'>t</span>
into the result object for the function call
<span class='texttt'>f()</span>,
which is the global object
<span class='texttt'>t2</span>.
Effectively, the construction of the local object
<span class='texttt'>t</span>
can be viewed as directly initializing the global
object
<span class='texttt'>t2</span>,
and that object's destruction will occur at program
exit.
Adding a move constructor to <span class='texttt'>Thing</span> has the same effect, but it is the
move construction from the local automatic object to <span class='texttt'>t2</span> that is elided.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='elision-3'><div class='marginalizedparent'><a class='marginalized' href='#elision-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L3206'>#</a></div><p >In the following copy-initialization contexts, a move operation might be used instead of a copy operation:
</p><ul class='itemize'><li id='elision-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#elision-3.1'>(3.1)</a></div><p >If the <i ><a href='expr.comma#nt:expression'>expression</a></i> in a <a href='stmt.return'><span class='texttt'>return</span> statement</a>
is a (possibly parenthesized) <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
that names an object with automatic storage duration declared in the body
or <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> of the innermost enclosing
function or <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>, or</p></li><li id='elision-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#elision-3.2'>(3.2)</a></div><p >if the operand of a <i ><a href='expr.throw#nt:throw-expression'>throw-expression</a></i>
is the name of a non-volatile automatic object
(other than a function or catch-clause parameter)
whose scope does not extend beyond the end of the innermost enclosing
<i ><a href='except#nt:try-block'>try-block</a></i> (if there is one),
</p></li></ul><p >overload resolution to select the constructor
for the copy is first performed as if the object were designated by an
rvalue.
If the first overload resolution fails or was not performed,
or if the type of the first parameter of the selected
constructor is not an rvalue reference to the object's type (possibly cv-qualified),
overload resolution is performed again, considering the object as an lvalue.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
This two-stage overload resolution must be performed regardless
of whether copy elision will occur. It determines the constructor to be called if
elision is not performed, and the selected constructor must be accessible even if
the call is elided.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='elision-4'><div class='marginalizedparent'><a class='marginalized' href='#elision-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/special.tex#L3235'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
class Thing {
public:
  Thing();
  ~Thing();
  Thing(Thing&amp;&amp;);
private:
  Thing(const Thing&amp;);
};

Thing f(bool b) {
  Thing t;
  if (b)
    throw t;            <span class='comment'>// OK: <span class='tcode_in_codeblock'>Thing(Thing&amp;&amp;)</span> used (or elided) to throw <span class='tcode_in_codeblock'>t</span>
</span>  return t;             <span class='comment'>// OK: <span class='tcode_in_codeblock'>Thing(Thing&amp;&amp;)</span> used (or elided) to return <span class='tcode_in_codeblock'>t</span>
</span>}

Thing t2 = f(false);    <span class='comment'>// OK: no extra copy/move performed, <span class='tcode_in_codeblock'>t2</span> constructed by call to <span class='tcode_in_codeblock'>f</span>
</span>
struct Weird {
  Weird();
  Weird(Weird&amp;);
};

Weird g() {
  Weird w;
  return w;             <span class='comment'>// OK: first overload resolution fails, second overload resolution selects <span class='tcode_in_codeblock'>Weird(Weird&amp;)</span>
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] 
</p></div><div class='footnote' id='footnote-122'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-122'>122)</a></div><p >Because only one object is destroyed instead of two,
and one copy/move constructor
is not executed, there is still one object destroyed for each one constructed.</p></div></div></div></body></html>