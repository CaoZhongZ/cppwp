<!DOCTYPE html><html lang='en'><head><title>[class.copy]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>12</a> Special member functions <a class='abbr_ref' href='./#special'>[special]</a></h1><div id='class.copy'><h2 ><a class='secnum' style='min-width:88pt'>12.8</a> Copying and moving class objects <a class='abbr_ref'>[class.copy]</a></h2><p ><span class='indexparent'><a class='index' id='copy!class~object'></a></span><span class='indexparent'><a class='index' id='move!class~object'></a></span><span class='indexparent'><a class='index' id='constructor!copy'></a></span><span class='indexparent'><a class='index' id='constructor!move'></a></span><span class='indexparent'><a class='index' id='operator!copy assignment'></a></span><span class='indexparent'><a class='index' id='operator!move assignment'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A class object can be copied or moved in two ways:
by initialization (<a href='class.ctor'>[class.ctor]</a>, <a href='dcl.init'>[dcl.init]</a>), including for function argument passing (<a href='expr.call'>[expr.call]</a>) and for function value return (<a href='stmt.return'>[stmt.return]</a>);
and by assignment (<a href='expr.ass'>[expr.ass]</a>).
Conceptually, these two operations are implemented by a
copy/move constructor (<a href='class.ctor'>[class.ctor]</a>)
and copy/move assignment operator (<a href='over.ass'>[over.ass]</a>).</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='constructor!copy'></a></span><span class='indexparent'><a class='index' id='constructor!move'></a></span>A non-template constructor for class
<span class='texttt'>X</span>
is
a
copy
constructor if its first parameter is of type
<span class='texttt'>X&amp;</span>,
<span class='texttt'>const X&amp;</span>,
<span class='texttt'>volatile X&amp;</span>
or
<span class='texttt'>const volatile X&amp;</span>,
and either there are no other parameters
or else all other parameters have default arguments (<a href='dcl.fct.default'>[dcl.fct.default]</a>).
[&nbsp;<i>Example:</i><span class='space'></span>
<span class='texttt'>X::X(const X&amp;)</span>
and
<span class='texttt'>X::X(X&amp;,int=1)</span>
are copy constructors.</p><pre class='codeblock'>
struct X {
  X(int);
  X(const X&amp;, int = 1);
};
X a(1);             <span class='comment'>// calls <span class='texttt'>X(int);</span>
</span>X b(a, 0);          <span class='comment'>// calls <span class='texttt'>X(const X&amp;, int);</span>
</span>X c = b;            <span class='comment'>// calls <span class='texttt'>X(const X&amp;, int);</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A non-template constructor for class <span class='texttt'>X</span> is a move constructor if its
first parameter is of type <span class='texttt'>X&amp;&amp;</span>, <span class='texttt'>const X&amp;&amp;</span>,
<span class='texttt'>volatile X&amp;&amp;</span>, or <span class='texttt'>const volatile X&amp;&amp;</span>, and either there are
no other parameters or else all other parameters have default 
arguments (<a href='dcl.fct.default'>[dcl.fct.default]</a>).
[&nbsp;<i>Example:</i><span class='space'></span> <span class='texttt'>Y::Y(Y&amp;&amp;)</span> is a move constructor.
</p><pre class='codeblock'>
struct Y {
  Y(const Y&amp;);
  Y(Y&amp;&amp;);
};
extern Y f(int);
Y d(f(1));          <span class='comment'>// calls <span class='texttt'>Y(Y&amp;&amp;)</span>
</span>Y e = d;            <span class='comment'>// calls <span class='texttt'>Y(const Y&amp;)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
All forms of copy/move constructor may be declared for a class.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct X {
  X(const X&amp;);
  X(X&amp;);            <span class='comment'>// OK
</span>  X(X&amp;&amp;);
  X(const X&amp;&amp;);     <span class='comment'>// OK, but possibly not sensible
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
If a class
<span class='texttt'>X</span>
only has a copy constructor with a parameter of type
<span class='texttt'>X&amp;</span>,
an initializer of type
<span class='texttt'>const</span>
<span class='texttt'>X</span>
or
<span class='texttt'>volatile</span>
<span class='texttt'>X</span>
cannot initialize an object of type
(possibly
cv-qualified)
<span class='texttt'>X</span>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct X {
  X();              <span class='comment'>// default constructor
</span>  X(X&amp;);            <span class='comment'>// copy constructor with a nonconst parameter
</span>};
const X cx;
X x = cx;           <span class='comment'>// error: <span class='texttt'>X::X(X&amp;)</span> cannot copy <span class='texttt'>cx</span> into <span class='texttt'>x</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >A declaration of a constructor for a class
<span class='texttt'>X</span>
is ill-formed if its first parameter is of type (optionally cv-qualified)
<span class='texttt'>X</span>
and either there are no other parameters or else all other parameters have
default arguments.
A member function template is never instantiated to
produce such a constructor signature.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct S {
  template&lt;typename T&gt; S(T);
  S();
};

S g;

void h() {
  S a(g);           <span class='comment'>// does not instantiate the member template to produce <span class='texttt'>S::S&lt;S&gt;(S)</span>;
</span>                    <span class='comment'>// uses the implicitly declared copy constructor
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p ><span class='indexparent'><a class='index' id='constructor!copy!implicitly declared'></a></span>If the class definition does not explicitly declare a copy constructor,
a non-explicit one is declared <i>implicitly</i>.
If the class definition declares a move
constructor or move assignment operator, the implicitly declared copy
constructor is defined as deleted; otherwise, it is defined as
defaulted (<a href='dcl.fct.def'>[dcl.fct.def]</a>).
The latter case is deprecated if the class has a user-declared copy assignment
operator or a user-declared destructor.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >The implicitly-declared copy constructor for a class
<span class='texttt'>X</span>
will have the form</p><pre class='codeblock'>
X::X(const X&amp;)
</pre><p >if each potentially constructed subobject of a class type
<span class='texttt'>M</span>
(or array thereof)
has a copy constructor whose first parameter is of type
<span class='texttt'>const</span>
<span class='texttt'>M&amp;</span>
or
<span class='texttt'>const</span>
<span class='texttt'>volatile</span>
<span class='texttt'>M&amp;</span>.<a class='footnotenum' href='#footnote-118'>118</a>
Otherwise, the implicitly-declared copy constructor will have the form</p><pre class='codeblock'>
X::X(X&amp;)
</pre></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p ><span class='indexparent'><a class='index' id='constructor!move!implicitly declared'></a></span>If the definition of a class <span class='texttt'>X</span> does not explicitly declare
a move constructor, a non-explicit one will be
implicitly declared as defaulted if and only if</p><ul ><li ><p ><span class='texttt'>X</span> does not have a user-declared copy constructor,</p></li><li ><p ><span class='texttt'>X</span> does not have a user-declared copy assignment operator,</p></li><li ><p ><span class='texttt'>X</span> does not have a user-declared move assignment operator, and</p></li><li ><p ><span class='texttt'>X</span> does not have a user-declared destructor.
</p></li></ul><p >[&nbsp;<i>Note:</i><span class='space'></span> When the move constructor is not implicitly declared or explicitly supplied,
expressions that otherwise would have invoked the move constructor may instead invoke
a copy constructor. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >The implicitly-declared move constructor for class <span class='texttt'>X</span> will have the form
</p><pre class='codeblock'>
X::X(X&amp;&amp;)
</pre></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >An implicitly-declared copy/move constructor is an
<span class='texttt'>inline</span>
<span class='texttt'>public</span>
member of its class.
A defaulted copy/<span class='discretionary'></span>move constructor for a class
  <span class='texttt'>X</span> is defined as deleted (<a href='dcl.fct.def.delete'>[dcl.fct.def.delete]</a>) if <span class='texttt'>X</span> has:
</p><ul ><li ><p >a variant member with a non-trivial corresponding constructor and
  <span class='texttt'>X</span> is a union-like class,</p></li><li ><p >a potentially constructed subobject type
  <span class='texttt'>M</span> (or array thereof) that cannot be copied/moved because
  overload resolution (<a href='over.match'>[over.match]</a>), as applied to
  <span class='texttt'>M</span>'s 
  corresponding constructor, results in an ambiguity or 
  a function that is deleted or inaccessible from the
  defaulted constructor,</p></li><li ><p >any potentially constructed subobject of a type
  with a destructor that is deleted or inaccessible from the defaulted
  constructor, or,</p></li><li ><p >for the copy constructor, a non-static data member of rvalue reference type.
</p></li></ul><p >A defaulted move constructor that is defined as deleted is ignored by overload
resolution (<a href='over.match'>[over.match]</a>, <a href='over.over'>[over.over]</a>).
[&nbsp;<i>Note:</i><span class='space'></span>
A deleted move constructor would otherwise interfere with initialization from
an rvalue which can use the copy constructor instead.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p ><span class='indexparent'><a class='index' id='constructor!copy!trivial'></a></span><span class='indexparent'><a class='index' id='constructor!move!trivial'></a></span>A copy/move constructor for class
<span class='texttt'>X</span>
is
trivial
if it is not user-provided and if:</p><ul ><li ><p >class
<span class='texttt'>X</span>
has no virtual functions (<a href='class.virtual'>[class.virtual]</a>)
and no virtual base classes (<a href='class.mi'>[class.mi]</a>), and</p></li><li ><p >class <span class='texttt'>X</span> has no non-static data members of volatile-qualified type, and</p></li><li ><p >the constructor selected to copy/move each direct base class subobject is trivial, and</p></li><li ><p >for each non-static data member of
<span class='texttt'>X</span>
that is of class type (or array thereof),
the constructor selected to copy/move that member is trivial;
</p></li></ul><p >otherwise the copy/move constructor is
<span class='grammarterm'>non-trivial</span>.</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p ><span class='indexparent'><a class='index' id='constructor!copy!implicitly defined'></a></span><span class='indexparent'><a class='index' id='constructor!move!implicitly defined'></a></span>A copy/move constructor
that is defaulted and not defined as deleted
is
<i>implicitly defined</i>
if it is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>)
or when it is explicitly defaulted after its first declaration.
[&nbsp;<i>Note:</i><span class='space'></span>
The copy/move constructor is implicitly defined even if the implementation elided
its odr-use (<a href='basic.def.odr'>[basic.def.odr]</a>, <a href='class.temporary'>[class.temporary]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If the implicitly-defined constructor would satisfy the requirements of a
<span class='texttt'>constexpr</span> constructor (<a href='dcl.constexpr'>[dcl.constexpr]</a>), the implicitly-defined
constructor is <span class='texttt'>constexpr</span>.</p></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><p >Before the defaulted copy/move constructor for a class is
implicitly defined,
all non-user-provided copy/move constructors for its
potentially constructed subobjects
shall have been implicitly defined.
[&nbsp;<i>Note:</i><span class='space'></span>
An implicitly-declared copy/move constructor has an
implied exception specification (<a href='except.spec'>[except.spec]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><p >The implicitly-defined copy/move constructor for a non-union class
<span class='texttt'>X</span>
performs a memberwise copy/move of its bases and members.
[&nbsp;<i>Note:</i><span class='space'></span> Default member initializers of non-static data members are ignored. See also the example in <a href='class.base.init'>[class.base.init]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
The order of initialization is the same as the order of initialization of bases
and members in a user-defined constructor (see <a href='class.base.init'>[class.base.init]</a>).
Let <span class='texttt'>x</span> be either the parameter of the constructor or, for the move constructor, an
xvalue referring to the parameter.
Each base or non-static data member
is copied/moved in the manner appropriate to its type:</p><ul ><li ><p >if the member is an array, each element is
direct-initialized with the corresponding subobject of <span class='texttt'>x</span>;</p></li><li ><p >if a member <span class='texttt'>m</span> has rvalue reference type <span class='texttt'>T&amp;&amp;</span>, it is direct-initialized with
<span class='texttt'>static_cast&lt;T&amp;&amp;&gt;(x.m)</span>;</p></li><li ><p >otherwise, the base or member is direct-initialized with the corresponding base or member of <span class='texttt'>x</span>.
</p></li></ul><p ><span class='indexparent'><a class='index' id='initialization!virtual~base~class'></a></span>Virtual base class subobjects shall be initialized only once by
the implicitly-defined copy/move constructor (see <a href='class.base.init'>[class.base.init]</a>).</p></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><p >The implicitly-defined copy/move constructor for a union
<span class='texttt'>X</span> copies the object representation (<a href='basic.types'>[basic.types]</a>) of <span class='texttt'>X</span>.<span class='indexparent'><a class='index' id='constructor!move'></a></span><span class='indexparent'><a class='index' id='constructor!copy'></a></span></p></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><p ><span class='indexparent'><a class='index' id='assignment operator!copy'></a></span><span class='indexparent'><a class='index' id='assignment operator!move'></a></span>A user-declared <i>copy</i> assignment operator <span class='texttt'>X::operator=</span> is a
non-static non-template member function of class <span class='texttt'>X</span> with exactly one
parameter of type <span class='texttt'>X</span>, <span class='texttt'>X&amp;</span>, <span class='texttt'>const</span> <span class='texttt'>X&amp;</span>,
<span class='texttt'>volatile</span> <span class='texttt'>X&amp;</span> or <span class='texttt'>const</span> <span class='texttt'>volatile</span>
<span class='texttt'>X&amp;</span>.<a class='footnotenum' href='#footnote-119'>119</a>
[&nbsp;<i>Note:</i><span class='space'></span>
An overloaded assignment operator must be declared to have only one parameter;
see <a href='over.ass'>[over.ass]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
More than one form of copy assignment operator may be declared for a class.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
If a class
<span class='texttt'>X</span>
only has a copy assignment operator with a parameter of type
<span class='texttt'>X&amp;</span>,
an expression of type const
<span class='texttt'>X</span>
cannot be assigned to an object of type
<span class='texttt'>X</span>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct X {
  X();
  X&amp; operator=(X&amp;);
};
const X cx;
X x;
void f() {
  x = cx;           <span class='comment'>// error: <span class='texttt'>X::operator=(X&amp;)</span> cannot assign <span class='texttt'>cx</span> into <span class='texttt'>x</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><p ><span class='indexparent'><a class='index' id='assignment operator!copy!implicitly declared'></a></span>If the class definition does not explicitly declare a copy assignment operator,
one is declared <i>implicitly</i>. If the class definition declares a move
constructor or move assignment operator, the implicitly declared copy
assignment operator is defined as deleted; otherwise, it is defined as
defaulted (<a href='dcl.fct.def'>[dcl.fct.def]</a>).
The latter case is deprecated if the class has a user-declared copy constructor
or a user-declared destructor.
The implicitly-declared copy assignment operator for a class
<span class='texttt'>X</span>
will have the form</p><pre class='codeblock'>
X&amp; X::operator=(const X&amp;)
</pre><p >if</p><ul ><li ><p >each direct base class
<span class='texttt'>B</span>
of
<span class='texttt'>X</span>
has a copy assignment operator whose parameter is of type
<span class='texttt'>const</span>
<span class='texttt'>B&amp;</span>,
<span class='texttt'>const</span>
<span class='texttt'>volatile</span>
<span class='texttt'>B&amp;</span>
or
<span class='texttt'>B</span>,
and
</p></li><li ><p >for all the non-static data members of
<span class='texttt'>X</span>
that are of a class type
<span class='texttt'>M</span>
(or array thereof),
each such class type has a copy assignment operator whose parameter is of type
<span class='texttt'>const</span>
<span class='texttt'>M&amp;</span>,
<span class='texttt'>const</span>
<span class='texttt'>volatile</span>
<span class='texttt'>M&amp;</span>
or
<span class='texttt'>M</span>.<a class='footnotenum' href='#footnote-120'>120</a>
</p></li></ul><p >Otherwise, the implicitly-declared copy
assignment operator
will have the form</p><pre class='codeblock'>
X&amp; X::operator=(X&amp;)
</pre></div><div class='para' id='19'><div class='marginalizedparent'><a class='marginalized' href='#19'>19</a></div><p >A user-declared move assignment operator <span class='texttt'>X::operator=</span> is
a non-static non-template member function of class <span class='texttt'>X</span> with exactly
one parameter of type <span class='texttt'>X&amp;&amp;</span>, <span class='texttt'>const X&amp;&amp;</span>, <span class='texttt'>volatile X&amp;&amp;</span>, or
<span class='texttt'>const volatile X&amp;&amp;</span>. [&nbsp;<i>Note:</i><span class='space'></span> An overloaded assignment operator must be
declared to have only one parameter; see <a href='over.ass'>[over.ass]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span> More
than one form of move assignment operator may be declared for a class. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='20'><div class='marginalizedparent'><a class='marginalized' href='#20'>20</a></div><p ><span class='indexparent'><a class='index' id='assignment operator!move!implicitly declared'></a></span>If the definition of a class <span class='texttt'>X</span> does not explicitly declare a
move assignment operator, one
will be implicitly declared as defaulted if and only if</p><ul ><li ><p ><span class='texttt'>X</span> does not have a user-declared copy constructor,</p></li><li ><p ><span class='texttt'>X</span> does not have a user-declared move constructor,</p></li><li ><p ><span class='texttt'>X</span> does not have a user-declared copy assignment operator, and</p></li><li ><p ><span class='texttt'>X</span> does not have a user-declared destructor.
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span> The class definition
</p><pre class='codeblock'>
struct S {
  int a;
  S&amp; operator=(const S&amp;) = default;
};
</pre><p >will not have a default move assignment operator implicitly declared because the
copy assignment operator has been user-declared. The move assignment operator may
be explicitly defaulted.</p><pre class='codeblock'>
struct S {
  int a;
  S&amp; operator=(const S&amp;) = default;
  S&amp; operator=(S&amp;&amp;) = default;
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='21'><div class='marginalizedparent'><a class='marginalized' href='#21'>21</a></div><p >The implicitly-declared move assignment operator for a class <span class='texttt'>X</span> will have the form
</p><pre class='codeblock'>
X&amp; X::operator=(X&amp;&amp;);
</pre></div><div class='para' id='22'><div class='marginalizedparent'><a class='marginalized' href='#22'>22</a></div><p >The implicitly-declared copy/move assignment operator for class
<span class='texttt'>X</span>
has the return type
<span class='texttt'>X&amp;</span>;
it returns the object for which the assignment operator is invoked, that is,
the object assigned to.
An implicitly-declared copy/move assignment operator is an
<span class='texttt'>inline</span>
<span class='texttt'>public</span>
member of its class.</p></div><div class='para' id='23'><div class='marginalizedparent'><a class='marginalized' href='#23'>23</a></div><p >A defaulted copy/move assignment operator for
class <span class='texttt'>X</span> is defined as deleted if <span class='texttt'>X</span> has:
</p><ul ><li ><p >a variant member with a non-trivial corresponding assignment operator and
  <span class='texttt'>X</span> is a union-like class, or</p></li><li ><p >a non-static data member of <span class='texttt'>const</span> non-class
  type (or array thereof), or</p></li><li ><p >a non-static data member of reference type, or</p></li><li ><p >a direct non-static data member of class type <span class='texttt'>M</span>
  (or array thereof) or a direct base class <span class='texttt'>M</span>
  that cannot be copied/moved because overload resolution
  (<a href='over.match'>[over.match]</a>), as applied to <span class='texttt'>M</span>'s corresponding
  assignment operator, results in an ambiguity or
  a function that is deleted or inaccessible from the
  defaulted assignment operator.
</p></li></ul><p >A defaulted move assignment operator that is defined as deleted is ignored by
overload resolution (<a href='over.match'>[over.match]</a>, <a href='over.over'>[over.over]</a>).</p></div><div class='para' id='24'><div class='marginalizedparent'><a class='marginalized' href='#24'>24</a></div><p ><span class='indexparent'><a class='index' id='assignment operator!copy!hidden'></a></span><span class='indexparent'><a class='index' id='assignment operator!move!hidden'></a></span>Because a copy/move assignment operator is implicitly declared for a class
if not declared by the user,
a base class copy/move assignment operator is always hidden
by the corresponding assignment operator of a derived class (<a href='over.ass'>[over.ass]</a>).
A
<i ><a href='namespace.udecl#using-declaration'>using-declaration</a></i> (<a href='namespace.udecl'>[namespace.udecl]</a>) that brings in from a base class an assignment operator
with a parameter type that could be that of a
copy/move assignment operator for the
derived class is not considered an explicit declaration of such an
operator and does not suppress the implicit declaration of the derived class
operator;
the operator introduced by the
<i ><a href='namespace.udecl#using-declaration'>using-declaration</a></i>
is hidden by the implicitly-declared operator in the derived
class.</p></div><div class='para' id='25'><div class='marginalizedparent'><a class='marginalized' href='#25'>25</a></div><p ><span class='indexparent'><a class='index' id='assignment operator!copy!trivial'></a></span><span class='indexparent'><a class='index' id='assignment operator!move!trivial'></a></span>A copy/move assignment operator for class
<span class='texttt'>X</span>
is
trivial
if it is not user-provided and if:</p><ul ><li ><p >class
<span class='texttt'>X</span>
has no virtual functions (<a href='class.virtual'>[class.virtual]</a>)
and no virtual base classes (<a href='class.mi'>[class.mi]</a>), and</p></li><li ><p >class <span class='texttt'>X</span> has no non-static data members of volatile-qualified
type, and</p></li><li ><p >the assignment operator selected to copy/move each direct
base class subobject is trivial, and</p></li><li ><p >for each non-static data member of
<span class='texttt'>X</span>
that is of class type (or array thereof),
the assignment operator selected to copy/move that member is trivial;
</p></li></ul><p >otherwise the copy/move assignment operator is
<span class='grammarterm'>non-trivial</span>.</p></div><div class='para' id='26'><div class='marginalizedparent'><a class='marginalized' href='#26'>26</a></div><p ><span class='indexparent'><a class='index' id='assignment operator!copy!implicitly defined'></a></span><span class='indexparent'><a class='index' id='assignment operator!move!implicitly defined'></a></span>A copy/move assignment operator for a class <span class='texttt'>X</span>
that is defaulted and not defined as deleted
is
<i>implicitly defined</i>
when
it is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>) (e.g., when it is selected by overload resolution
to assign to an object of its class type)
or when it is explicitly defaulted after its first declaration.
The implicitly-defined copy/move assignment operator is <span class='texttt'>constexpr</span> if
</p><ul ><li ><p ><span class='texttt'>X</span> is a literal type, and</p></li><li ><p >the assignment operator selected to copy/move each direct base class subobject
is a <span class='texttt'>constexpr</span> function, and</p></li><li ><p >for each non-static data member of <span class='texttt'>X</span> that is of class type (or array
thereof), the assignment operator selected to copy/move that member is a
<span class='texttt'>constexpr</span> function.
</p></li></ul></div><div class='para' id='27'><div class='marginalizedparent'><a class='marginalized' href='#27'>27</a></div><p >Before the defaulted copy/move assignment operator for a class is
implicitly defined,
all non-user-provided copy/move assignment operators for
its direct base classes and
its non-static data members shall have been implicitly defined.
[&nbsp;<i>Note:</i><span class='space'></span>
An implicitly-declared copy/move assignment operator has an
implied exception specification (<a href='except.spec'>[except.spec]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='28'><div class='marginalizedparent'><a class='marginalized' href='#28'>28</a></div><p >The implicitly-defined copy/move assignment operator for a
non-union class <span class='texttt'>X</span> performs memberwise copy/move assignment of its subobjects. The direct
base classes of <span class='texttt'>X</span> are assigned first, in the order of their declaration in the
<i ><a href='class.derived#base-specifier-list'>base-specifier-list</a></i>, and then the immediate non-static data members of
<span class='texttt'>X</span> are assigned, in the order in which they were declared in the class
definition.
Let <span class='texttt'>x</span> be either the parameter of the function or, for the move operator, an
xvalue referring to the parameter.
Each subobject is assigned in the manner appropriate to its type:</p><ul ><li ><p >if the subobject is of class type,
as if by a call to <span class='texttt'>operator=</span> with the subobject as the object expression
and the corresponding subobject of <span class='texttt'>x</span> as a single function argument
(as if by explicit qualification; that is,
ignoring any possible virtual overriding functions in more derived classes);
</p></li><li ><p >if the subobject is an array, each element is assigned,
in the manner appropriate to the element type;
</p></li><li ><p >if the subobject is of scalar type,
the built-in assignment operator is used.
</p></li></ul><p ><span class='indexparent'><a class='index' id='assignment operator!copy!virtual bases and'></a></span>It is unspecified whether subobjects representing virtual base classes
are assigned more than once by the implicitly-defined copy/move assignment
operator.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct V { };
struct A : virtual V { };
struct B : virtual V { };
struct C : B, A { };
</pre><p >It is unspecified whether the virtual base class subobject
<span class='texttt'>V</span>
is assigned twice by the implicitly-defined copy/move assignment operator for
<span class='texttt'>C</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='29'><div class='marginalizedparent'><a class='marginalized' href='#29'>29</a></div><p >The implicitly-defined copy assignment operator for a
union <span class='texttt'>X</span> copies the object representation (<a href='basic.types'>[basic.types]</a>) of <span class='texttt'>X</span>.<span class='indexparent'><a class='index' id='assignment operator!move'></a></span><span class='indexparent'><a class='index' id='assignment operator!copy'></a></span></p></div><div class='para' id='30'><div class='marginalizedparent'><a class='marginalized' href='#30'>30</a></div><p ><span class='indexparent'><a class='index' id='constructor!copy!inaccessible'></a></span><span class='indexparent'><a class='index' id='constructor!move!inaccessible'></a></span><span class='indexparent'><a class='index' id='assignment operator!copy!inaccessible'></a></span><span class='indexparent'><a class='index' id='assignment operator!move!inaccessible'></a></span>A program is ill-formed if the copy/move constructor or the copy/move assignment
operator for an object is implicitly odr-used and the special member function
is not accessible (Clause <a href='class.access'>[class.access]</a>).
[&nbsp;<i>Note:</i><span class='space'></span>
Copying/moving one object into another using the copy/move constructor or
the copy/move assignment operator does not change the layout or size of either
object.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='31'><div class='marginalizedparent'><a class='marginalized' href='#31'>31</a></div><p ><span class='indexparent'><a class='index' id='temporary!elimination~of'></a></span><span class='indexparent'><a class='index' id='elision!copy constructor'></a></span><span class='indexparent'><a class='index' id='elision!move constructor'></a></span><span class='indexparent'><a class='index' id='constructor!copy!elision'></a></span><span class='indexparent'><a class='index' id='constructor!move!elision'></a></span>When certain criteria are met, an implementation is
allowed to omit the copy/move construction of a class object,
even if the constructor selected for the copy/move operation and/or the
destructor for the object have
<span class='indexparent'><a class='index' id='side effects'></a></span>side effects.  In such cases, the
implementation treats the source and target of the
omitted copy/move operation as simply two different ways of
referring to the same object. If the first parameter of the
selected constructor is an rvalue reference to the object's type,
the destruction of that object occurs when the target would have been destroyed;
otherwise, the destruction occurs at the later of the times when the
two objects would have been destroyed without the
optimization.<a class='footnotenum' href='#footnote-121'>121</a>
This elision of copy/move operations, called
<span class='indexparent'><a class='index' id='copy elision'></a></span><span class='indexparent'><a class='index' id='elision!copy'></a></span><span class='indexparent'><a class='index' id='constructor!copy!elision'></a></span><span class='indexparent'><a class='index' id='constructor!move!elision'></a></span><i>copy elision</i>,
is permitted in the
following circumstances (which may be combined to
eliminate multiple copies):</p><ul ><li ><p >in a <span class='texttt'>return</span> statement in a function with a class return type,
when the <i ><a href='expr.comma#expression'>expression</a></i> is the name of a non-volatile
automatic object (other than a function parameter or a variable
introduced by the <i ><a href='except#exception-declaration'>exception-declaration</a></i> of a
<i ><a href='except#handler'>handler</a></i> (<a href='except.handle'>[except.handle]</a>))
with the same type (ignoring cv-qualification) as
the function return type, the copy/move operation can be
omitted by constructing the automatic object directly
into the function call's return object</p></li><li ><p >in a <span class='small'></span><span class='rmfamily'></span><i> throw-expression</i> (<a href='expr.throw'>[expr.throw]</a>), when the operand
is the name of a non-volatile automatic object
(other than a function or catch-clause parameter)
whose scope does not extend beyond the end of the innermost enclosing
<i ><a href='except#try-block'>try-block</a></i> (if there is one), the copy/move operation from the
operand to the exception object (<a href='except.throw'>[except.throw]</a>) can be omitted by
constructing the automatic object directly into the exception object</p></li><li ><p >when the <span class='small'></span><span class='rmfamily'></span><i> exception-declaration</i> of an
exception handler (Clause <a href='except'>[except]</a>) declares an object of the same
type (except for cv-qualification) as the exception
object (<a href='except.throw'>[except.throw]</a>), the copy operation can be omitted by treating
the <span class='small'></span><span class='rmfamily'></span><i> exception-declaration</i> as an alias for the exception
object if the meaning of the program will be unchanged except for the execution
of constructors and destructors for the object declared by the
<span class='small'></span><span class='rmfamily'></span><i> exception-declaration</i>.
[&nbsp;<i>Note:</i><span class='space'></span> There cannot be a move from the exception object because it is
always an lvalue.  <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >Copy elision is required
where an expression is evaluated in a context
requiring a constant expression (<a href='expr.const'>[expr.const]</a>)
and in constant initialization (<a href='basic.start.static'>[basic.start.static]</a>).
[&nbsp;<i>Note:</i><span class='space'></span>
Copy elision might not be performed
if the same expression
is evaluated in another context.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class Thing {
public:
  Thing();
  ~Thing();
  Thing(const Thing&amp;);
};

Thing f() {
  Thing t;
  return t;
}

Thing t2 = f();

struct A {
  void *p;
  constexpr A(): p(this) {}
};

constexpr A g() {
  A a;
  return a;
}

constexpr A a;        <span class='comment'>// well-formed, <span class='texttt'>a.p</span> points to <span class='texttt'>a</span>
</span>constexpr A b = g();  <span class='comment'>// well-formed, <span class='texttt'>b.p</span> points to <span class='texttt'>b</span>
</span>
void g() {
  A c = g();          <span class='comment'>// well-formed, <span class='texttt'>c.p</span> may point to <span class='texttt'>c</span> or to an ephemeral temporary
</span>}
</pre><p >Here the criteria for elision can
eliminate
the copying of the local automatic object
<span class='texttt'>t</span>
into the result object for the function call
<span class='texttt'>f()</span>,
which is the global object
<span class='texttt'>t2</span>.
Effectively, the construction of the local object
<span class='texttt'>t</span>
can be viewed as directly initializing the global
object
<span class='texttt'>t2</span>,
and that object's destruction will occur at program
exit.
Adding a move constructor to <span class='texttt'>Thing</span> has the same effect, but it is the
move construction from the local automatic object to <span class='texttt'>t2</span> that is elided.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='32'><div class='marginalizedparent'><a class='marginalized' href='#32'>32</a></div><p >When the criteria for elision of a copy/move operation are met,
but not for an <span class='small'></span><span class='rmfamily'></span><i> exception-declaration</i>,
and the object
to be copied is designated by an lvalue,
or when the <i ><a href='expr.comma#expression'>expression</a></i> in a <span class='texttt'>return</span> statement
is a (possibly parenthesized) <i ><a href='expr.prim.id#id-expression'>id-expression</a></i>
that names an object with automatic storage duration declared in the body
or <i ><a href='dcl.fct#parameter-declaration-clause'>parameter-declaration-clause</a></i> of the innermost enclosing
function or <i ><a href='expr.prim.lambda#lambda-expression'>lambda-expression</a></i>,
overload resolution to select the constructor
for the copy is first performed as if the object were designated by an rvalue.
If the first overload resolution fails or was not performed,
or if the type of the first parameter of the selected
constructor is not an rvalue reference to the object's type (possibly cv-qualified),
overload resolution is performed again, considering the object as an lvalue.
[&nbsp;<i>Note:</i><span class='space'></span> This two-stage overload resolution must be performed regardless
of whether copy elision will occur. It determines the constructor to be called if
elision is not performed, and the selected constructor must be accessible even if
the call is elided. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
class Thing {
public:
  Thing();
  ~Thing();
  Thing(Thing&amp;&amp;);
private:
  Thing(const Thing&amp;);
};

Thing f(bool b) {
  Thing t;
  if (b)
    throw t;                    <span class='comment'>// OK: <span class='texttt'>Thing(Thing&amp;&amp;)</span> used (or elided) to throw <span class='texttt'>t</span>
</span>  return t;                     <span class='comment'>// OK: <span class='texttt'>Thing(Thing&amp;&amp;)</span> used (or elided) to return <span class='texttt'>t</span>
</span>}

Thing t2 = f(false);            <span class='comment'>// OK: no extra copy/move performed, <span class='texttt'>t2</span> constructed by call to <span class='texttt'>f</span>
</span>
struct Weird {
  Weird();
  Weird(Weird&amp;);
};

Weird g() {
  Weird w;
  return w;                     <span class='comment'>// OK: first overload resolution fails,
</span>                                <span class='comment'>// second overload resolution selects <span class='texttt'>Weird(Weird&amp;)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div><div class='footnote' id='footnote-118'><div class='marginalizedparent'><a class='marginalized' href='#footnote-118'>118)</a></div><p >This implies that the reference parameter of the
implicitly-declared copy constructor
cannot bind to a
<span class='texttt'>volatile</span>
lvalue; see <a href='diff.special'>[diff.special]</a>.</p></div><div class='footnote' id='footnote-119'><div class='marginalizedparent'><a class='marginalized' href='#footnote-119'>119)</a></div><p >Because a template assignment operator or an assignment
operator taking an rvalue reference parameter is never a copy assignment
operator, the presence of such an assignment operator does not suppress the
implicit declaration of a copy assignment operator. Such assignment operators
participate in overload resolution with other assignment operators, including
copy assignment operators, and, if selected, will be used to assign an object.</p></div><div class='footnote' id='footnote-120'><div class='marginalizedparent'><a class='marginalized' href='#footnote-120'>120)</a></div><p >This implies that the reference parameter of the
implicitly-declared copy assignment operator cannot bind to a
<span class='texttt'>volatile</span>
lvalue; see <a href='diff.special'>[diff.special]</a>.</p></div><div class='footnote' id='footnote-121'><div class='marginalizedparent'><a class='marginalized' href='#footnote-121'>121)</a></div><p >Because only one object is destroyed instead of two,
and one copy/move constructor
is not executed, there is still one object destroyed for each one constructed.</p></div></div></div></body></html>