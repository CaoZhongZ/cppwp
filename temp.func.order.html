<!DOCTYPE html><html lang='en'><head><title>[temp.func.order]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.5</a> Template declarations <a class='abbr_ref' href='temp.decls#temp.func.order'>[temp.decls]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>14.5.6</a> Function templates <a class='abbr_ref' href='temp.fct#temp.func.order'>[temp.fct]</a></h3><div id='temp.func.order'><h4 ><a class='secnum' style='min-width:118pt'>14.5.6.2</a> Partial ordering of function templates <a class='abbr_ref'>[temp.func.order]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='overloading,resolution,template'></a></span><span class='indexparent'><a class='index' id='ordering,function_template_partial'></a></span>If a function template is overloaded,
the use of a function template specialization might be ambiguous because
template argument deduction (<a href='temp.deduct'>[temp.deduct]</a>) may associate the function
template specialization with more than one function template declaration.
<a class='hidden_link' href='#def:Partial_ordering' id='def:Partial_ordering'><i>Partial ordering</i></a>
of overloaded function template declarations is used in the following contexts
to select the function template to which a function template specialization
refers:</p><ul ><li ><p >during overload resolution for a call to a function template specialization (<a href='over.match.best'>[over.match.best]</a>);
</p></li><li ><p >when the address of a function template specialization is taken;
</p></li><li ><p >when a placement operator delete that is a
function template
specialization
is selected to match a placement operator new (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>, <a href='expr.new'>[expr.new]</a>);
</p></li><li ><p >when a friend function declaration (<a href='temp.friend'>[temp.friend]</a>), an
explicit instantiation (<a href='temp.explicit'>[temp.explicit]</a>) or an explicit specialization (<a href='temp.expl.spec'>[temp.expl.spec]</a>) refers to
a function template specialization.
</p></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Partial ordering selects which of two function templates is more
specialized than the other by transforming each template in turn
(see next paragraph) and performing template argument deduction
using the function type.
The deduction process determines whether
one of the templates is more specialized than the other. If so, the
more specialized template is the one chosen by the partial ordering
process.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >To produce the transformed template, for each type, non-type, or template
template parameter (including template parameter packs (<a href='temp.variadic'>[temp.variadic]</a>)
thereof) synthesize a unique type, value, or class template
respectively and substitute it for each occurrence of that parameter
in the function type of the template.
[&nbsp;<i>Note:</i><span class='space'></span>
The type replacing the placeholder
in the type of the value synthesized for a non-type template parameter
is also a unique synthesized type.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If only one of the function templates <i>M</i> is a non-static
member of some class <i>A</i>, <i>M</i> is considered to have
a new first parameter inserted in its function
parameter list. Given <i>cv</i> as the cv-qualifiers of <i>M</i>
(if any), the new parameter is of type “rvalue reference to
<i>cv</i> <i>A</i>” if the optional <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> of
<i>M</i> is <span class='texttt'>&amp;&amp;</span> or if <i>M</i> has no
<i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> and the first parameter of the other
template has rvalue reference type. Otherwise, the new parameter is
of type “lvalue reference to <i>cv</i> <i>A</i>”.
[&nbsp;<i>Note:</i><span class='space'></span> This allows a non-static
member to be ordered with respect to a nonmember function and for the results
to be equivalent to the ordering of two equivalent nonmembers. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A { };
template&lt;class T&gt; struct B {
  template&lt;class R&gt; int operator*(R&amp;);              <span class='comment'>// #1
</span>};

template&lt;class T, class R&gt; int operator*(T&amp;, R&amp;);   <span class='comment'>// #2
</span>
<span class='comment'>// The declaration of <span class='texttt'>B::operator*</span> is transformed into the equivalent of
</span><span class='comment'>// <span class='texttt'>template&lt;class R&gt; int operator*(B&lt;A&gt;&amp;, R&amp;);</span>&emsp;&ensp;&emsp;&ensp;&emsp;&ensp;// #1a
</span>
int main() {
  A a;
  B&lt;A&gt; b;
  b * a;                                            <span class='comment'>// calls #1a
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >Using the transformed function template's function type,
perform type deduction against the other template as described in <a href='temp.deduct.partial'>[temp.deduct.partial]</a>.</p><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A { A(); };

template&lt;class T&gt; void f(T);
template&lt;class T&gt; void f(T*);
template&lt;class T&gt; void f(const T*);

template&lt;class T&gt; void g(T);
template&lt;class T&gt; void g(T&amp;);

template&lt;class T&gt; void h(const T&amp;);
template&lt;class T&gt; void h(A&lt;T&gt;&amp;);

void m() {
  const int* p;
  f(p);             <span class='comment'>// <span class='texttt'>f(const T*)</span> is more specialized than <span class='texttt'>f(T)</span> or <span class='texttt'>f(T*)</span>
</span>  float x;
  g(x);             <span class='comment'>// Ambiguous: <span class='texttt'>g(T)</span> or <span class='texttt'>g(T&amp;)</span>
</span>  A&lt;int&gt; z;
  h(z);             <span class='comment'>// overload resolution selects <span class='texttt'>h(A&lt;T&gt;&amp;)</span>
</span>  const A&lt;int&gt; z2;
  h(z2);            <span class='comment'>// <span class='texttt'>h(const T&amp;)</span> is called because <span class='texttt'>h(A&lt;T&gt;&amp;)</span> is not callable
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Since partial ordering in a call context considers only parameters
for which there are explicit call arguments, some parameters are ignored (namely,
function parameter packs, parameters with default arguments, and ellipsis
parameters).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; void f(T);            <span class='comment'>// #1
</span>template&lt;class T&gt; void f(T*, int=1);    <span class='comment'>// #2
</span>template&lt;class T&gt; void g(T);            <span class='comment'>// #3
</span>template&lt;class T&gt; void g(T*, ...);      <span class='comment'>// #4
</span>
</pre><pre class='codeblock'>
int main() {
  int* ip;
  f(ip);            <span class='comment'>// calls #2
</span>  g(ip);            <span class='comment'>// calls #4
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;][&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T, class U&gt; struct A { };

template&lt;class T, class U&gt; void f(U, A&lt;U, T&gt;* p = 0); <span class='comment'>// #1
</span>template&lt;         class U&gt; void f(U, A&lt;U, U&gt;* p = 0); <span class='comment'>// #2
</span>template&lt;class T         &gt; void g(T, T = T());        <span class='comment'>// #3
</span>template&lt;class T, class... U&gt; void g(T, U ...);       <span class='comment'>// #4
</span>
void h() {
  f&lt;int&gt;(42, (A&lt;int, int&gt;*)0);                        <span class='comment'>// calls #2
</span>  f&lt;int&gt;(42);                                         <span class='comment'>// error: ambiguous
</span>  g(42);                                              <span class='comment'>// error: ambiguous
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;][&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T, class... U&gt; void f(T, U...);        <span class='comment'>// #1
</span>template&lt;class T            &gt; void f(T);              <span class='comment'>// #2
</span>template&lt;class T, class... U&gt; void g(T*, U...);       <span class='comment'>// #3
</span>template&lt;class T            &gt; void g(T);              <span class='comment'>// #4
</span>
void h(int i) {
  f(&amp;i);                                              <span class='comment'>// error: ambiguous
</span>  g(&amp;i);                                              <span class='comment'>// OK: calls #3
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div></body></html>