<!DOCTYPE html><html lang='en'><head><title>[basic.stc.dynamic.safety]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>3.7</a> Storage duration <a class='abbr_ref' href='basic.stc#dynamic.safety'>[basic.stc]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>3.7.4</a> Dynamic storage duration <a class='abbr_ref' href='basic.stc.dynamic#safety'>[basic.stc.dynamic]</a></h3><div id='basic.stc.dynamic.safety'><h4 ><a class='secnum' style='min-width:118pt'>3.7.4.3</a> Safely-derived pointers <a class='abbr_ref'>[basic.stc.dynamic.safety]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/basic.tex#L3109'>#</a></div><p ><span class='indexparent'><a class='index' id='pointer,safely-derived'></a></span><span class='indexparent'><a class='index' id='pointer,to_traceable_object'></a></span>A <a class='hidden_link' href='#def:traceable_pointer_object' id='def:traceable_pointer_object'><i>traceable pointer object</i></a> is
</p><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p >an object of an object pointer
type (<a href='basic.compound'>[basic.compound]</a>), or
</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p >an object of an integral type that is at least as large as <span class='texttt'>std::intptr_t</span>,
or
</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p >a sequence of elements in an array of narrow character
type (<a href='basic.fundamental'>[basic.fundamental]</a>), where the size and alignment of the sequence
match those of some object pointer type.
</p></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/basic.tex#L3123'>#</a></div><p ><span class='indexparent'><a class='index' id='safely-derived_pointer'></a></span>A pointer value is a <span class='grammarterm'>safely-derived pointer</span> to a dynamic object only if it
has an object pointer type and it is one of the following:
</p><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><p >the value returned by a call to the C++ standard library implementation of
<span class='texttt'>::operator new(std::size_t)</span> or
<span class='texttt'>::operator new(std::size_t, std::align_val_t)</span>;<a class='footnotenum' href='#footnote-40'>40</a></p></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><p >the result of taking the address of an object (or one of its
  subobjects) designated by an lvalue resulting from indirection
  through a safely-derived pointer value;</p></li><li id='2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.3'>(2.3)</a></div><p >the result of well-defined pointer arithmetic (<a href='expr.add'>[expr.add]</a>) using a safely-derived pointer
value;</p></li><li id='2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.4'>(2.4)</a></div><p >the result of a well-defined pointer
conversion (<a href='conv.ptr'>[conv.ptr]</a>, <a href='expr.cast'>[expr.cast]</a>) of a safely-derived pointer value;</p></li><li id='2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.5'>(2.5)</a></div><p >the result of a <span class='texttt'>reinterpret_cast</span> of a safely-derived pointer value;</p></li><li id='2.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.6'>(2.6)</a></div><p >the result of a <span class='texttt'>reinterpret_cast</span> of an integer representation of a
safely-derived pointer value;</p></li><li id='2.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.7'>(2.7)</a></div><p >the value of an object whose value was copied from a traceable pointer object,
where at the time of the copy the source object contained a copy of a safely-derived
pointer value.
</p></li></ul></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/basic.tex#L3157'>#</a></div><p ><span class='indexparent'><a class='index' id='integer_representation'></a></span><span class='indexparent'><a class='index' id='safely-derived_pointer,integer_representation'></a></span><span class='indexparent'><a class='index' id='pointer,_integer_representation_of_safely-derived'></a></span>An integer value is an <span class='grammarterm'>integer representation of a safely-derived pointer</span>
only if its type is at least as large as <span class='texttt'>std::intptr_t</span> and it is one of the
following:</p><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >the result of a <span class='texttt'>reinterpret_cast</span> of a safely-derived pointer value;</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p >the result of a valid conversion of an integer representation of a safely-derived
pointer value;</p></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><p >the value of an object whose value was copied from a traceable pointer object,
where at the time of the copy the source object contained an integer representation of a
safely-derived pointer value;</p></li><li id='3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.4'>(3.4)</a></div><p >the result of an additive or bitwise operation, one of whose operands is an
integer representation of a safely-derived pointer value <span class='texttt'>P</span>, if that result
converted by <span class='texttt'>reinterpret_cast&lt;void*&gt;</span> would compare equal to a safely-derived
pointer computable from <span class='texttt'>reinterpret_cast&lt;void*&gt;(P)</span>.
</p></li></ul></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/basic.tex#L3181'>#</a></div><p >An implementation may have <a class='hidden_link' href='#def:relaxed_pointer_safety' id='def:relaxed_pointer_safety'><i>relaxed pointer safety</i></a>, in which case the
validity of a pointer value does not depend on whether it is a safely-derived
pointer value. Alternatively, an implementation may have <a class='hidden_link' href='#def:strict_pointer_safety' id='def:strict_pointer_safety'><i>strict pointer
safety</i></a>, in which case a pointer value referring to an object with dynamic
storage duration that is not a safely-derived pointer
value is an invalid pointer value unless
the referenced complete object has previously been declared
reachable (<a href='util.dynamic.safety'>[util.dynamic.safety]</a>). [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
The effect of using an invalid pointer value (including passing it to a
deallocation function) is undefined, see <a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>.
This is true even if the unsafely-derived pointer value might compare equal to
some safely-derived pointer value. <i><span style='white-space:nowrap'>&thinsp;</span>â€”<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>] It is
<span class='indexparent'><a class='index' id='whether_an_implementation_has_relaxed_or_strict_pointer_safety'></a></span>implementation-defined whether an implementation has relaxed or strict pointer safety.<span class='indexparent'><a class='index' id='pointer,safely-derived'></a></span><span class='indexparent'><a class='index' id='storage_duration,dynamic'></a></span></p></div><div class='footnote' id='footnote-40'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-40'>40)</a></div><p >This section does not impose restrictions
on indirection through pointers to memory not allocated by <span class='texttt'>::operator new</span>. This
maintains the ability of many C++ implementations to use binary libraries and
components written in other languages. In particular, this applies to C binaries,
because indirection through pointers to memory allocated by <span class='texttt'>std::malloc</span> is not restricted.</p></div></div></div></body></html>