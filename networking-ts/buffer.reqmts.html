<!DOCTYPE html><html lang='en'><head><title>[buffer.reqmts]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>16</a> Buffers <a class='abbr_ref' href='./#buffer'>[buffer]</a></h1><div id='buffer.reqmts'><h2 ><a class='secnum' style='min-width:88pt'>16.2</a> Requirements <a class='abbr_ref'>[buffer.reqmts]</a></h2><div id='mutablebuffersequence'><h3 ><a class='secnum' href='#mutablebuffersequence' style='min-width:103pt'>16.2.1</a> Mutable buffer sequence requirements <a class='abbr_ref' href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a></h3><div class='para' id='mutablebuffersequence-1'><div class='marginalizedparent'><a class='marginalized' href='#mutablebuffersequence-1'>1</a></div><p >A <a class='hidden_link' href='#def:mutable_buffer_sequence' id='def:mutable_buffer_sequence'><i>mutable buffer sequence</i></a> represents a set of memory regions that may be used to receive the output of an operation, such as the <span class='texttt'>receive</span> operation of a socket.</p></div><div class='para' id='mutablebuffersequence-2'><div class='marginalizedparent'><a class='marginalized' href='#mutablebuffersequence-2'>2</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>MutableBufferSequence</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (<span class='CppXref'>destructible</span>) and <span class='texttt'>CopyConstructible</span> (<span class='CppXref'>copyconstructible</span>), as well as the additional requirements listed in Table <a href='#tab:buffer.reqmts.mutablebuffersequence.requirements'>[tab:buffer.reqmts.mutablebuffersequence.requirements]</a>.</p></div><div class='para' id='mutablebuffersequence-3'><div class='marginalizedparent'><a class='marginalized' href='#mutablebuffersequence-3'>3</a></div><p >In Table <a href='#tab:buffer.reqmts.mutablebuffersequence.requirements'>[tab:buffer.reqmts.mutablebuffersequence.requirements]</a>,
<span class='texttt'>x</span> denotes a (possibly const) value of type <span class='texttt'>X</span>,
and <span class='texttt'>u</span> denotes an identifier.</p><p ><span class='indexparent'><a class='index' id='requirements,MutableBufferSequence'></a></span>
 
 </p><div class='numberedTable' id='tab:buffer.reqmts.mutablebuffersequence.requirements'>Table <a href='#tab:buffer.reqmts.mutablebuffersequence.requirements'>12</a> — MutableBufferSequence requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note</b></td></tr><tr ><td colspan='1' class='center'><b></b></td><td colspan='1' class='center'><b></b></td><td colspan='1' class='center'><b>pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>net::buffer_sequence_begin(x)</span><br/>
<span class='texttt'>net::buffer_sequence_end(x)</span>  </td><td class='left'>
An iterator type whose <span class='texttt'>reference</span> type is convertible to <span class='texttt'>mutable_buffer</span>,
and which satisfies all the requirements for bidirectional iterators (<span class='CppXref'>bidirectional.iterators</span>)
except that:
<ul class='itemize'><li ><p >there is no requirement that <span class='texttt'>operator-&gt;</span> is provided, and
</p></li><li ><p >there is no requirement that <span class='texttt'>reference</span> be a reference type.
</p></li></ul> </td><td class='left'>
For a dereferenceable iterator, no increment, decrement, or dereference operation, or conversion of the reference type to <span class='texttt'>mutable_buffer</span>, shall exit via an exception.
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(x);</span>
  </td><td class='left'>
  </td><td class='left'>
post: <pre class='codeblock'>
equal(
  net::buffer_sequence_begin(x),
  net::buffer_sequence_end(x),
  net::buffer_sequence_begin(u),
  net::buffer_sequence_end(u),
  [](const typename X::value_type&amp; v1,
     const typename X::value_type&amp; v2)
   {
     mutable_buffer b1(v1);
     mutable_buffer b2(v2);
     return b1.data() == b2.data()
         &amp;&amp; b1.size() == b2.size();
   })
</pre>
  </td></tr></table></div></div></div><div id='constbuffersequence'><h3 ><a class='secnum' href='#constbuffersequence' style='min-width:103pt'>16.2.2</a> Constant buffer sequence requirements <a class='abbr_ref' href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a></h3><div class='para' id='constbuffersequence-1'><div class='marginalizedparent'><a class='marginalized' href='#constbuffersequence-1'>1</a></div><p >A <a class='hidden_link' href='#def:constant_buffer_sequence' id='def:constant_buffer_sequence'><i>constant buffer sequence</i></a> represents a set of memory regions that may be used as input to an operation, such as the <span class='texttt'>send</span> operation of a socket.</p></div><div class='para' id='constbuffersequence-2'><div class='marginalizedparent'><a class='marginalized' href='#constbuffersequence-2'>2</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>ConstBufferSequence</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (<span class='CppXref'>destructible</span>) and <span class='texttt'>CopyConstructible</span> (<span class='CppXref'>copyconstructible</span>), as well as the additional requirements listed in Table <a href='#tab:buffer.reqmts.constbuffersequence.requirements'>[tab:buffer.reqmts.constbuffersequence.requirements]</a>.</p></div><div class='para' id='constbuffersequence-3'><div class='marginalizedparent'><a class='marginalized' href='#constbuffersequence-3'>3</a></div><p >In Table <a href='#tab:buffer.reqmts.constbuffersequence.requirements'>[tab:buffer.reqmts.constbuffersequence.requirements]</a>,
<span class='texttt'>x</span> denotes a (possibly const) value of type <span class='texttt'>X</span>,
and <span class='texttt'>u</span> denotes an identifier.</p><p ><span class='indexparent'><a class='index' id='requirements,ConstBufferSequence'></a></span>
 
 </p><div class='numberedTable' id='tab:buffer.reqmts.constbuffersequence.requirements'>Table <a href='#tab:buffer.reqmts.constbuffersequence.requirements'>13</a> — ConstBufferSequence requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note</b></td></tr><tr ><td colspan='1' class='center'><b></b></td><td colspan='1' class='center'><b></b></td><td colspan='1' class='center'><b>pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>net::buffer_sequence_begin(x)</span><br/>
<span class='texttt'>net::buffer_sequence_end(x)</span>  </td><td class='left'>
An iterator type whose <span class='texttt'>reference</span> type is convertible to <span class='texttt'>const_buffer</span>,
and which satisfies all the requirements for bidirectional iterators (<span class='CppXref'>bidirectional.iterators</span>)
except that:
<ul class='itemize'><li ><p >there is no requirement that <span class='texttt'>operator-&gt;</span> is provided, and
</p></li><li ><p >there is no requirement that <span class='texttt'>reference</span> be a reference type.
</p></li></ul> </td><td class='left'>
For a dereferenceable iterator, no increment, decrement, or dereference operation, or conversion of the reference type to <span class='texttt'>const_buffer</span>, shall exit via an exception.
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(x);</span>
  </td><td class='left'>
  </td><td class='left'>
post:
<pre class='codeblock'>
equal(
  net::buffer_sequence_begin(x),
  net::buffer_sequence_end(x),
  net::buffer_sequence_begin(u),
  net::buffer_sequence_end(u),
  [](const typename X::value_type&amp; v1,
     const typename X::value_type&amp; v2)
   {
     const_buffer b1(v1);
     const_buffer b2(v2);
     return b1.data() == b2.data()
         &amp;&amp; b1.size() == b2.size();
   })
</pre>
  </td></tr></table></div></div></div><div id='size'><h3 ><a class='secnum' href='#size' style='min-width:103pt'>16.2.3</a> Buffer size <a class='abbr_ref' href='buffer.reqmts.size'>[buffer.reqmts.size]</a></h3><div class='para' id='size-1'><div class='marginalizedparent'><a class='marginalized' href='#size-1'>1</a></div><p >Several places in this document make unqualified calls to <span class='texttt'>buffer_size</span>.
The context in which these calls are evaluated shall ensure that
a unary non-member function named <span class='texttt'>buffer_size</span>
is selected via overload resolution (<span class='CppXref'>over.match</span>)
on a candidate set that includes:</p><ul class='itemize'><li id='size-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#size-1.1'>(1.1)</a></div><p >the <span class='texttt'>buffer_size</span> function template defined in <span class='texttt'>&lt;experimental/buffer&gt;</span> (<a href='buffer.synop'>[buffer.synop]</a>) and
</p></li><li id='size-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#size-1.2'>(1.2)</a></div><p >the lookup set produced by argument-dependent lookup (<span class='CppXref'>basic.lookup.argdep</span>).
</p></li></ul></div></div><div id='dynamicbuffer'><h3 ><a class='secnum' href='#dynamicbuffer' style='min-width:103pt'>16.2.4</a> Dynamic buffer requirements <a class='abbr_ref' href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a></h3><div class='para' id='dynamicbuffer-1'><div class='marginalizedparent'><a class='marginalized' href='#dynamicbuffer-1'>1</a></div><p >A <a class='hidden_link' href='#def:dynamic_buffer' id='def:dynamic_buffer'><i>dynamic buffer</i></a> encapsulates memory storage that may be automatically resized as required, where the memory is divided into two regions: readable bytes followed by writable bytes. These memory regions are internal to the dynamic buffer, but direct access to the elements is provided to permit them to be efficiently used with I/O operations. [&nbsp;<i>Note:</i> Such as the <span class='texttt'>send</span> or <span class='texttt'>receive</span> operations of a socket. The readable bytes would be used as the constant buffer sequence for <span class='texttt'>send</span>, and the writable bytes used as the mutable buffer sequence for <span class='texttt'>receive</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Data written to the writable bytes of a dynamic buffer object is appended to the readable bytes of the same object.</p></div><div class='para' id='dynamicbuffer-2'><div class='marginalizedparent'><a class='marginalized' href='#dynamicbuffer-2'>2</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>DynamicBuffer</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (<span class='CppXref'>destructible</span>) and <span class='texttt'>MoveConstructible</span> (<span class='CppXref'>moveconstructible</span>), as well as the additional requirements listed in Table <a href='#tab:buffer.reqmts.dynamicbuffer.requirements'>[tab:buffer.reqmts.dynamicbuffer.requirements]</a>.</p></div><div class='para' id='dynamicbuffer-3'><div class='marginalizedparent'><a class='marginalized' href='#dynamicbuffer-3'>3</a></div><p >In Table <a href='#tab:buffer.reqmts.dynamicbuffer.requirements'>[tab:buffer.reqmts.dynamicbuffer.requirements]</a>,
<span class='texttt'>x</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>x1</span> denotes a (possibly const) value of type <span class='texttt'>X</span>,
and <span class='texttt'>n</span> denotes a (possibly const) value of type <span class='texttt'>size_t</span>.</p><p ><span class='indexparent'><a class='index' id='requirements,DynamicBuffer'></a></span>
 
 
 </p><div class='numberedTable' id='tab:buffer.reqmts.dynamicbuffer.requirements'>Table <a href='#tab:buffer.reqmts.dynamicbuffer.requirements'>14</a> — DynamicBuffer requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::const_buffers_type</span>  </td><td class='left'>
type meeting ConstBufferSequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) requirements.  </td><td class='left'>
 This type represents the memory associated with the readable bytes.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::mutable_buffers_type</span>  </td><td class='left'>
type meeting MutableBufferSequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) requirements.  </td><td class='left'>
 This type represents the memory associated with the writable bytes.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.size()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
 Returns the number of readable bytes.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.max_size()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns the maximum number of bytes, both readable and writable, that can be held by <span class='texttt'>x1</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.capacity()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns the maximum number of bytes, both readable and writable, that can be held by <span class='texttt'>x1</span> without requiring reallocation.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.data()</span>  </td><td class='left'>
<span class='texttt'>X::const_buffers_type</span>  </td><td class='left'>
Returns a constant buffer sequence <span class='texttt'>u</span> that represents the readable bytes, and where <span class='texttt'>buffer_size(u) == size()</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.prepare(n)</span>  </td><td class='left'>
<span class='texttt'>X::mutable_buffers_type</span>  </td><td class='left'>
Returns a mutable buffer sequence <span class='texttt'>u</span> representing the writable bytes, and where <span class='texttt'>buffer_size(u) == n</span>. The dynamic buffer reallocates memory as required. All constant or mutable buffer sequences previously obtained using <span class='texttt'>data()</span> or <span class='texttt'>prepare()</span> are invalidated.<br/> <i>Throws:</i> <span class='texttt'>length_error</span> if <span class='texttt'>size() + n</span> exceeds <span class='texttt'>max_size()</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.commit(n)</span>  </td><td class='left'>
  </td><td class='left'>
Appends <span class='texttt'>n</span> bytes from the start of the writable bytes to the end of the readable bytes. The remainder of the writable bytes are discarded. If <span class='texttt'>n</span> is greater than the number of writable bytes, all writable bytes are appended to the readable bytes. All constant or mutable buffer sequences previously obtained using <span class='texttt'>data()</span> or <span class='texttt'>prepare()</span> are invalidated.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.consume(n)</span>  </td><td class='left'>
  </td><td class='left'>
Removes <span class='texttt'>n</span> bytes from beginning of the readable bytes. If <span class='texttt'>n</span> is greater than the number of readable bytes, all readable bytes are removed. All constant or mutable buffer sequences previously obtained using <span class='texttt'>data()</span> or <span class='texttt'>prepare()</span> are invalidated.  </td></tr></table></div></div></div><div id='read.write'><h3 ><a class='secnum' href='#read.write' style='min-width:103pt'>16.2.5</a> Requirements on read and write operations <a class='abbr_ref' href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a></h3><div class='para' id='read.write-1'><div class='marginalizedparent'><a class='marginalized' href='#read.write-1'>1</a></div><p >A <a class='hidden_link' href='#def:read_operation' id='def:read_operation'><i>read operation</i></a> is an operation that reads data into a mutable buffer sequence argument of a type meeting <span class='texttt'>MutableBufferSequence</span> (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) requirements. The mutable buffer sequence specifies memory where the data should be placed. A read operation shall always fill a buffer in the sequence completely before proceeding to the next.</p></div><div class='para' id='read.write-2'><div class='marginalizedparent'><a class='marginalized' href='#read.write-2'>2</a></div><p >A <a class='hidden_link' href='#def:write_operation' id='def:write_operation'><i>write operation</i></a> is an operation that writes data from a constant buffer sequence argument of a type meeting <span class='texttt'>ConstBufferSequence</span> (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) requirements. The constant buffer sequence specifies memory where the data to be written is located. A write operation shall always write a buffer in the sequence completely before proceeding to the next.</p><p ><span class='indexparent'><a class='index' id='asynchronous_operation'></a></span></p></div><div class='para' id='read.write-3'><div class='marginalizedparent'><a class='marginalized' href='#read.write-3'>3</a></div><p >If a read or write operation is also an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>), the operation shall maintain one or more copies of the buffer sequence until such time as the operation no longer requires access to the memory specified by the buffers in the sequence. The program shall ensure the memory remains valid until:</p><ul class='itemize'><li id='read.write-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#read.write-3.1'>(3.1)</a></div><p >the last copy of the buffer sequence is destroyed, or
</p></li><li id='read.write-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#read.write-3.2'>(3.2)</a></div><p >the completion handler for the asynchronous operation is invoked,
</p></li></ul><p >whichever comes first.</p><p ><span class='indexparent'><a class='index' id='error_codes,stream'></a></span></p></div></div></div></div></body></html>