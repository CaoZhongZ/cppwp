<!DOCTYPE html><html lang='en'><head><title>[buffer.read.until]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>17</a> Buffer-oriented streams <a class='abbr_ref' href='./#buffer.stream'>[buffer.stream]</a></h1><div id='buffer.read.until'><h2 ><a class='secnum' style='min-width:88pt'>17.9</a> Synchronous delimited read operations <a class='abbr_ref'>[buffer.read.until]</a></h2><p ><span class='indexparent'><a class='index' id='read_until'></a></span><code class='itemdecl'>
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b, char delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b,
                    char delim, error_code&amp; ec);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b, string_view delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b,
                    string_view delim, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Reads data from the buffer-oriented synchronous read stream (<a href='buffer.stream.reqmts.syncreadstream'>[buffer.stream.reqmts.syncreadstream]</a>) object <span class='texttt'>stream</span> by performing zero or more calls to the stream's <span class='texttt'>read_some</span> member function, until the input sequence of the dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>) object <span class='texttt'>b</span> contains the specified delimiter <span class='texttt'>delim</span>.</p></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><p >Data is placed into the dynamic buffer object <span class='texttt'>b</span>. A mutable buffer sequence (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) is obtained prior to each <span class='texttt'>read_some</span> call using <span class='texttt'>b.prepare(N)</span>, where <span class='texttt'>N</span> is an unspecified value such that <span class='texttt'>N &lt;= max_size() - size()</span>. [&nbsp;<i>Note:</i> Implementations can use <span class='texttt'>b.capacity()</span> when determining <span class='texttt'>N</span>, to minimize the number of <span class='texttt'>read_some</span> calls performed on the stream. <i>&nbsp;—&nbsp;end note</i>&nbsp;] After each <span class='texttt'>read_some</span> call, the implementation performs <span class='texttt'>b.commit(n)</span>, where <span class='texttt'>n</span> is the return value from <span class='texttt'>read_some</span>.</p></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><p >The synchronous read_until operation continues until:</p><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >the input sequence of <span class='texttt'>b</span> contains the delimiter <span class='texttt'>delim</span>; or
</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p ><span class='texttt'>b.size() == b.max_size()</span>; or
</p></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><p >an asynchronous read_some operation fails.
</p></li></ul></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><p >On exit, if the input sequence of <span class='texttt'>b</span> contains the delimiter, <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>. Otherwise, if <span class='texttt'>b.size() == b.max_size()</span>, <span class='texttt'>ec</span> is set such that <span class='texttt'>ec == stream_errc::not_found</span>. If <span class='texttt'>b.size() &lt; b.max_size()</span>, <span class='texttt'>ec</span> contains the <span class='texttt'>error_code</span> from the most recent <span class='texttt'>read_some</span> call.</p></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of bytes in the input sequence of <span class='texttt'>b</span> up to and including the delimiter, if present. [&nbsp;<i>Note:</i> On completion, the buffer can contain additional bytes following the delimiter. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Otherwise returns <span class='texttt'>0</span>.
</p></div></div></div></div></body></html>