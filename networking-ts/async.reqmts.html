<!DOCTYPE html><html lang='en'><head><title>[async.reqmts]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Asynchronous model <a class='abbr_ref' href='./#async'>[async]</a></h1><div id='async.reqmts'><h2 ><a class='secnum' style='min-width:88pt'>13.2</a> Requirements <a class='abbr_ref'>[async.reqmts]</a></h2><div id='proto.allocator'><h3 ><a class='secnum' href='#proto.allocator' style='min-width:103pt'>13.2.1</a> Proto-allocator requirements <a class='abbr_ref' href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a></h3><div class='para' id='proto.allocator-1'><div class='marginalizedparent'><a class='marginalized' href='#proto.allocator-1'>1</a></div><p >A type <span class='texttt'>A</span> meets the proto-allocator requirements if <span class='texttt'>A</span> is <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), and <span class='texttt'>allocator_traits&lt;A&gt;::rebind_alloc&lt;U&gt;</span> meets the allocator requirements (C++Std &sect;<a href='../n4140/allocator.requirements'>[allocator.requirements]</a>), where <span class='texttt'>U</span> is an object type. [&nbsp;<i>Note:</i> For example, <span class='texttt'>allocator&lt;void&gt;</span> meets the proto-allocator requirements but not the allocator requirements. <i>&nbsp;—&nbsp;end note</i>&nbsp;] No comparison operator, copy operation, move operation, or swap operation on these types shall exit via an exception.</p></div></div><div id='executor'><h3 ><a class='secnum' href='#executor' style='min-width:103pt'>13.2.2</a> Executor requirements <a class='abbr_ref' href='async.reqmts.executor'>[async.reqmts.executor]</a></h3><div class='para' id='executor-1'><div class='marginalizedparent'><a class='marginalized' href='#executor-1'>1</a></div><p >The library describes a standard set of requirements for executors. A type meeting the <span class='texttt'>Executor</span> requirements embodies a set of rules for determining how submitted function objects are to be executed.</p></div><div class='para' id='executor-2'><div class='marginalizedparent'><a class='marginalized' href='#executor-2'>2</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>Executor</span> requirements if it satisfies the requirements of <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>) and <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), as well as the additional requirements listed below.</p></div><div class='para' id='executor-3'><div class='marginalizedparent'><a class='marginalized' href='#executor-3'>3</a></div><p >No comparison operator, copy operation, move operation, swap operation, or member functions <span class='texttt'>context</span>, <span class='texttt'>on_work_started</span>, and <span class='texttt'>on_work_finished</span> on these types shall exit via an exception.</p></div><div class='para' id='executor-4'><div class='marginalizedparent'><a class='marginalized' href='#executor-4'>4</a></div><p >The executor copy constructor, comparison operators, and other member functions defined in these requirements shall not introduce data races as a result of concurrent calls to those functions from different threads.
The member function <span class='texttt'>dispatch</span> may be recursively reentered.</p></div><div class='para' id='executor-5'><div class='marginalizedparent'><a class='marginalized' href='#executor-5'>5</a></div><p >Let <span class='texttt'>ctx</span> be the execution context returned by the executor's <span class='texttt'>context()</span> member function. An executor becomes invalid when the first call to <span class='texttt'>ctx.shutdown()</span> returns. The effect of calling <span class='texttt'>on_work_started</span>, <span class='texttt'>on_work_finished</span>, <span class='texttt'>dispatch</span>, <span class='texttt'>post</span>, or <span class='texttt'>defer</span> on an invalid executor is undefined. [&nbsp;<i>Note:</i> The copy constructor, comparison operators, and <span class='texttt'>context()</span> member function continue to remain valid until <span class='texttt'>ctx</span> is destroyed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='executor-6'><div class='marginalizedparent'><a class='marginalized' href='#executor-6'>6</a></div><p >In Table <a href='#tab:async.reqmts.executor.requirements'>[tab:async.reqmts.executor.requirements]</a>,
<span class='texttt'>x1</span> and <span class='texttt'>x2</span> denote values of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>,
<span class='texttt'>mx1</span> denotes an xvalue of type <span class='texttt'>X</span>,
<span class='texttt'>f</span> denotes a function object of <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>) type <span class='texttt'>Func</span> such that <span class='texttt'>f()</span> is a valid expression,
<span class='texttt'>a</span> denotes a value of type <span class='texttt'>A</span> or <span class='texttt'>const A</span>
where <span class='texttt'>A</span> is a type meeting the <span class='texttt'>ProtoAllocator</span> requirements (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>),
and <span class='texttt'>u</span> denotes an identifier.</p><div class='numberedTable' id='tab:async.reqmts.executor.requirements'>Table <a href='#tab:async.reqmts.executor.requirements'>4</a> — Executor requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X u(x1);</span>  </td><td class='left'>
  </td><td class='left'>
Shall not exit via an exception.<br/><i>post:</i> <span class='texttt'>u == x1</span> and <span class='texttt'>std::addressof(u.context()) == std::addressof(x1.context()).</span>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(mx1);</span>  </td><td class='left'>
  </td><td class='left'>
Shall not exit via an exception.<br/><i>post:</i> <span class='texttt'>u</span> equals the prior value of <span class='texttt'>mx1</span> and <span class='texttt'>std::addressof(u.context())</span> equals the prior value of <span class='texttt'>std::addressof(mx1.context())</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1 == x2</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>true</span> only if <span class='texttt'>x1</span> and <span class='texttt'>x2</span> can be interchanged with identical effects in any of the expressions defined in these type requirements. [&nbsp;<i>Note:</i> Returning <span class='texttt'>false</span> does not necessarily imply that the effects are not identical. <i>&nbsp;—&nbsp;end note</i>&nbsp;]<br/><span class='texttt'>operator==</span> shall be reflexive, symmetric, and transitive, and shall not exit via an exception.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1 != x2</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
Same as <span class='texttt'>!(x1 == x2)</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.context()</span>  </td><td class='left'>
<span class='texttt'>execution_context&amp;</span>, or <span class='texttt'>E&amp;</span> where <span class='texttt'>E</span> is a type that satisfies the <span class='texttt'>ExecutionContext</span>  (<a href='async.reqmts.executioncontext'>[async.reqmts.executioncontext]</a>) requirements.  </td><td class='left'>
Shall not exit via an exception. The comparison operators and member functions defined in these requirements shall not alter the reference returned by this function.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.on_work_started()</span>  </td><td class='left'>
  </td><td class='left'>
 Shall not exit via an exception.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.on_work_finished()</span>  </td><td class='left'>
  </td><td class='left'>
Shall not exit via an exception. <br/><i>Precondition:</i> A preceding call <span class='texttt'>x2.on_work_started()</span> where <span class='texttt'>x1 == x2</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.dispatch(<br/><span class='mbox'>  </span>std::move(f), a)</span>  </td><td class='left'>
  </td><td class='left'>
<i>Effects:</i> Creates an object <span class='texttt'>f1</span> initialized with <span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;Func&gt;(f))</span> (C++Std &sect;<a href='../n4140/thread.decaycopy'>[thread.decaycopy]</a>) in the current thread of execution. Calls <span class='texttt'>f1()</span> at most once. The executor may block forward progress of the caller until <span class='texttt'>f1()</span> finishes execution. Executor implementations should use the supplied allocator to allocate any memory required to store the function object. Prior to invoking the function object, the executor shall deallocate any memory allocated. [&nbsp;<i>Note:</i> Executors defined in this Technical Specification always use the supplied allocator unless otherwise specified. <i>&nbsp;—&nbsp;end note</i>&nbsp;] <br/>
<i>Synchronization:</i> The invocation of <span class='texttt'>dispatch</span> synchronizes with (C++Std &sect;<a href='../n4140/intro.multithread'>[intro.multithread]</a>) the invocation of <span class='texttt'>f1</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.post(std::move(f), a)</span>  </td><td class='left'>
  </td><td class='left'>
<i>Effects:</i> Creates an object <span class='texttt'>f1</span> initialized with <span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;Func&gt;(f))</span> in the current thread of execution. Calls <span class='texttt'>f1()</span> at most once. The executor shall not block forward progress of the caller pending completion of <span class='texttt'>f1()</span>. The executor may begin <span class='texttt'>f1</span>'s progress before the call to <span class='texttt'>post</span> completes. Executor implementations should use the supplied allocator to allocate any memory required to store the function object. Prior to invoking the function object, the executor shall deallocate any memory allocated. [&nbsp;<i>Note:</i> Executors defined in this Technical Specification always use the supplied allocator unless otherwise specified. <i>&nbsp;—&nbsp;end note</i>&nbsp;]<br/>
<i>Synchronization:</i> The invocation of <span class='texttt'>post</span> synchronizes with (C++Std &sect;<a href='../n4140/intro.multithread'>[intro.multithread]</a>) the invocation of <span class='texttt'>f1</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.defer(std::move(f), a)</span>  </td><td class='left'>
  </td><td class='left'>
<i>Effects:</i> Creates an object <span class='texttt'>f1</span> initialized with <span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;Func&gt;(f))</span> in the current thread of execution. Calls <span class='texttt'>f1()</span> at most once. The executor shall not block forward progress of the caller pending completion of <span class='texttt'>f1()</span>. The executor should not begin <span class='texttt'>f1</span>'s progress before the call to <span class='texttt'>defer</span> completes. [&nbsp;<i>Note:</i> One use of <span class='texttt'>defer</span> is to convey the intention of the caller that <span class='texttt'>f1</span> is a continuation of the current call context. The executor may use this information to optimize or otherwise adjust the way in which <span class='texttt'>f1</span> is invoked. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  Executor implementations should use the supplied allocator to allocate any memory required to store the function object. Prior to invoking the function object, the executor shall deallocate any memory allocated. [&nbsp;<i>Note:</i> Executors defined in this Technical Specification always use the supplied allocator unless otherwise specified. <i>&nbsp;—&nbsp;end note</i>&nbsp;]<br/>
<i>Synchronization:</i> The invocation of <span class='texttt'>defer</span> synchronizes with (C++Std &sect;<a href='../n4140/intro.multithread'>[intro.multithread]</a>) the invocation of <span class='texttt'>f1</span>.  </td></tr></table></div></div></div><div id='executioncontext'><h3 ><a class='secnum' href='#executioncontext' style='min-width:103pt'>13.2.3</a> Execution context requirements <a class='abbr_ref' href='async.reqmts.executioncontext'>[async.reqmts.executioncontext]</a></h3><p ><span class='indexparent'><a class='index' id='execution_context'></a></span></p><div class='para' id='executioncontext-1'><div class='marginalizedparent'><a class='marginalized' href='#executioncontext-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>ExecutionContext</span> requirements if it is publicly and unambiguously derived from <span class='texttt'>execution_context</span>, and satisfies the additional requirements listed below.</p></div><div class='para' id='executioncontext-2'><div class='marginalizedparent'><a class='marginalized' href='#executioncontext-2'>2</a></div><p >In Table <a href='#tab:async.reqmts.executioncontext.requirements'>[tab:async.reqmts.executioncontext.requirements]</a>, <span class='texttt'>x</span> denotes a value of type <span class='texttt'>X</span>.</p><p ><span class='indexparent'><a class='index' id='requirements,ExecutionContext'></a></span><span class='indexparent'><a class='index' id='ExecutionContext'></a></span>
 
 
 </p><div class='numberedTable' id='tab:async.reqmts.executioncontext.requirements'>Table <a href='#tab:async.reqmts.executioncontext.requirements'>5</a> — ExecutionContext requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::executor_type</span>  </td><td class='left'>
type meeting <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) requirements  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.~X()</span>  </td><td class='left'>
  </td><td class='left'>
 Destroys all unexecuted function objects that were submitted via an executor object that is associated with the execution context.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.get_executor()</span>  </td><td class='left'>
<span class='texttt'>X::executor_type</span>  </td><td class='left'>
 Returns an executor object that is associated with the execution context.  </td></tr></table></div></div></div><div id='service'><h3 ><a class='secnum' href='#service' style='min-width:103pt'>13.2.4</a> Service requirements <a class='abbr_ref' href='async.reqmts.service'>[async.reqmts.service]</a></h3><p ><span class='indexparent'><a class='index' id='service'></a></span>
<span class='indexparent'><a class='index' id='execution_context::service'></a></span></p><div class='para' id='service-1'><div class='marginalizedparent'><a class='marginalized' href='#service-1'>1</a></div><p >A class is a service if it is publicly and unambiguously derived from <span class='texttt'>execution_context::service</span>, or if it is publicly and unambiguously derived from another service. For a service <span class='texttt'>S</span>, <span class='texttt'>S::key_type</span> shall be valid and denote a type (C++Std &sect;<a href='../n4140/temp.deduct'>[temp.deduct]</a>), <span class='texttt'>is_base_of_v&lt;typename S::key_type, S&gt;</span> shall be <span class='texttt'>true</span>, and <span class='texttt'>S</span> shall satisfy the <span class='texttt'>Destructible</span> requirements (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>).</p></div><div class='para' id='service-2'><div class='marginalizedparent'><a class='marginalized' href='#service-2'>2</a></div><p >The first parameter of all service constructors shall be an lvalue reference to <span class='texttt'>execution_context</span>. This parameter denotes the <span class='texttt'>execution_context</span> object that represents a set of services, of which the service object will be a member. [&nbsp;<i>Note:</i> These constructors may be called by the <span class='texttt'>make_service</span> function. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='service-3'><div class='marginalizedparent'><a class='marginalized' href='#service-3'>3</a></div><p >A service shall provide an explicit constructor with a single parameter of lvalue reference to <span class='texttt'>execution_context</span>. [&nbsp;<i>Note:</i> This constructor may be called by the <span class='texttt'>use_service</span> function. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='service-4'><div class='marginalizedparent'><a class='marginalized' href='#service-4'>4</a></div><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class my_service : public execution_context::service{
public:
  using key_type = my_service;
  explicit my_service(execution_context&amp; ctx);
  my_service(execution_context&amp; ctx, int some_value);
private:
  virtual void shutdown() noexcept override;
  ...
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='service-5'><div class='marginalizedparent'><a class='marginalized' href='#service-5'>5</a></div><p >A service's <span class='texttt'>shutdown</span> member function shall destroy all copies of function objects that are held by the service.</p></div></div><div id='signature'><h3 ><a class='secnum' href='#signature' style='min-width:103pt'>13.2.5</a> Signature requirements <a class='abbr_ref' href='async.reqmts.signature'>[async.reqmts.signature]</a></h3><p ><span class='indexparent'><a class='index' id='requirements,signature'></a></span><span class='indexparent'><a class='index' id='signature_requirements'></a></span></p><div class='para' id='signature-1'><div class='marginalizedparent'><a class='marginalized' href='#signature-1'>1</a></div><p >A type satisfies the signature requirements if it is a call signature (C++Std &sect;<a href='../n4140/func.def'>[func.def]</a>).</p></div></div><div id='associator'><h3 ><a class='secnum' href='#associator' style='min-width:103pt'>13.2.6</a> Associator requirements <a class='abbr_ref' href='async.reqmts.associator'>[async.reqmts.associator]</a></h3><p ><span class='indexparent'><a class='index' id='requirements,associator'></a></span><span class='indexparent'><a class='index' id='associator'></a></span></p><div class='para' id='associator-1'><div class='marginalizedparent'><a class='marginalized' href='#associator-1'>1</a></div><p >An associator defines a relationship between different types and objects where, given:</p><ul class='itemize'><li id='associator-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#associator-1.1'>(1.1)</a></div><p >a source object <span class='texttt'>s</span> of type <span class='texttt'>S</span>,</p></li><li id='associator-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#associator-1.2'>(1.2)</a></div><p >type requirements <span class='texttt'>R</span>, and</p></li><li id='associator-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#associator-1.3'>(1.3)</a></div><p >a candidate object <span class='texttt'>c</span> of type <span class='texttt'>C</span> meeting the type requirements <span class='texttt'>R</span>,
</p></li></ul><p >an associated type <span class='texttt'>A</span> meeting the type requirements <span class='texttt'>R</span> may be computed, and an associated object <span class='texttt'>a</span> of type <span class='texttt'>A</span> may be obtained.</p></div><div class='para' id='associator-2'><div class='marginalizedparent'><a class='marginalized' href='#associator-2'>2</a></div><p >An associator shall be a class template that takes two template type arguments. The first template argument is the source type <span class='texttt'>S</span>. The second template argument is the candidate type <span class='texttt'>C</span>. The second template argument shall be defaulted to some default candidate type <span class='texttt'>D</span> that satisfies the type requirements <span class='texttt'>R</span>.</p></div><div class='para' id='associator-3'><div class='marginalizedparent'><a class='marginalized' href='#associator-3'>3</a></div><p >An associator shall additionally satisfy the requirements in Table <a href='#tab:async.reqmts.associator.requirements'>[tab:async.reqmts.associator.requirements]</a>.
In this table, <span class='texttt'>X</span> is a class template that meets the associator requirements,
<span class='texttt'>S</span> is the source type,
<span class='texttt'>s</span> is a value of type <span class='texttt'>S</span> or <span class='texttt'>const S</span>,
<span class='texttt'>C</span> is the candidate type,
<span class='texttt'>c</span> is a value of type <span class='texttt'>C</span> or <span class='texttt'>const C</span>,
<span class='texttt'>D</span> is the default candidate type,
and <span class='texttt'>d</span> is a value of type <span class='texttt'>D</span> or <span class='texttt'>const D</span> that is the default candidate object.</p><div class='numberedTable' id='tab:async.reqmts.associator.requirements'>Table <a href='#tab:async.reqmts.associator.requirements'>6</a> — Associator requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X&lt;S&gt;::type</span>  </td><td class='left'>
<span class='texttt'>X&lt;S, D&gt;::type</span>  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X&lt;S, C&gt;::type</span>  </td><td class='left'>
  </td><td class='left'>
 The associated type.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X&lt;S&gt;::get(s)</span>  </td><td class='left'>
<span class='texttt'>X&lt;S&gt;::type</span>  </td><td class='left'>
Returns <span class='texttt'>X&lt;S&gt;::get(S, d)</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X&lt;S, C&gt;::get(s, c)</span>  </td><td class='left'>
<span class='texttt'>X&lt;S, C&gt;::type</span>  </td><td class='left'>
 Returns the associated object.  </td></tr></table></div></div><div class='para' id='associator-4'><div class='marginalizedparent'><a class='marginalized' href='#associator-4'>4</a></div><p >The associator's primary template shall be defined. A program may partially specialize the associator class template for some user-defined type <span class='texttt'>S</span>.</p></div><div class='para' id='associator-5'><div class='marginalizedparent'><a class='marginalized' href='#associator-5'>5</a></div><p >Finally, the associator shall provide the following type alias and function template in the enclosing namespace:</p><pre class='codeblock'>
template&lt;class S, class C = D&gt; using <i>X</i>_t = typename <i>X</i>&lt;S, C&gt;::type;

template&lt;class S, class C = D&gt;
typename <i>X</i>&lt;S, C&gt;::type get_<i>X</i>(const S&amp; s, const C&amp; c = d){
  return <i>X</i>&lt;S, C&gt;::get(s, c);
}
</pre><p >where <span class='texttt'><i>X</i></span> is replaced with the name of the associator class template.
[&nbsp;<i>Note:</i> This function template is provided as a convenience, to automatically deduce the source and candidate types. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='async'><h3 ><a class='secnum' href='#async' style='min-width:103pt'>13.2.7</a> Requirements on asynchronous operations <a class='abbr_ref' href='async.reqmts.async'>[async.reqmts.async]</a></h3><div class='para' id='async-1'><div class='marginalizedparent'><a class='marginalized' href='#async-1'>1</a></div><p >This section uses the names <span class='texttt'>Alloc1</span>, <span class='texttt'>Alloc2</span>, <span class='texttt'>alloc1</span>, <span class='texttt'>alloc2</span>, <span class='texttt'>Args</span>, <span class='texttt'>CompletionHandler</span>, <span class='texttt'>completion_handler</span>, <span class='texttt'>Executor1</span>, <span class='texttt'>Executor2</span>, <span class='texttt'>ex1</span>, <span class='texttt'>ex2</span>, <span class='texttt'>f</span>, <i>i</i>, <i>N</i>, <span class='texttt'>Signature</span>, <span class='texttt'>token</span>, <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>, <span class='texttt'>t</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>, <span class='texttt'>work1</span>, and <span class='texttt'>work2</span> as placeholders for specifying the requirements below.</p></div><div id='async.concepts'><h4 ><a class='secnum' href='#async.concepts' style='min-width:118pt'>13.2.7.1</a> General asynchronous operation concepts <a class='abbr_ref' href='async.reqmts.async.concepts'>[async.reqmts.async.concepts]</a></h4><div class='para' id='async.concepts-1'><div class='marginalizedparent'><a class='marginalized' href='#async.concepts-1'>1</a></div><p >An initiating function is a function which may be called to start an asynchronous operation. A completion handler is a function object that will be invoked, at most once, with the result of the asynchronous operation.</p></div><div class='para' id='async.concepts-2'><div class='marginalizedparent'><a class='marginalized' href='#async.concepts-2'>2</a></div><p >The life cycle of an asynchronous operation is comprised of the following events and phases:</p><ul class='itemize'><li id='async.concepts-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.concepts-2.1'>(2.1)</a></div><p >Event 1: The asynchronous operation is started by a call to the initiating function.</p></li><li id='async.concepts-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.concepts-2.2'>(2.2)</a></div><p >Phase 1: The asynchronous operation is now outstanding.</p></li><li id='async.concepts-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.concepts-2.3'>(2.3)</a></div><p >Event 2: The externally observable side effects of the asynchronous operation, if any, are fully established. The completion handler is submitted to an executor.</p></li><li id='async.concepts-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.concepts-2.4'>(2.4)</a></div><p >Phase 2: The asynchronous operation is now completed.</p></li><li id='async.concepts-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.concepts-2.5'>(2.5)</a></div><p >Event 3: The completion handler is called with the result of the asynchronous operation.
</p></li></ul></div><div class='para' id='async.concepts-3'><div class='marginalizedparent'><a class='marginalized' href='#async.concepts-3'>3</a></div><p >In this Technical Specification, all functions with the prefix <span class='texttt'>async_</span> are initiating functions.</p></div></div><div id='async.token'><h4 ><a class='secnum' href='#async.token' style='min-width:118pt'>13.2.7.2</a> Completion tokens and handlers <a class='abbr_ref' href='async.reqmts.async.token'>[async.reqmts.async.token]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function'></a></span></p><div class='para' id='async.token-1'><div class='marginalizedparent'><a class='marginalized' href='#async.token-1'>1</a></div><p >Initiating functions:</p><ul class='itemize'><li id='async.token-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.token-1.1'>(1.1)</a></div><p >are function templates with template parameter <span class='texttt'>CompletionToken</span>;</p><p ><span class='indexparent'><a class='index' id='completion_token'></a></span></p></li><li id='async.token-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.token-1.2'>(1.2)</a></div><p >accept, as the final parameter, a completion token object <span class='texttt'>token</span> of type <span class='texttt'>CompletionToken</span>;</p><p ><span class='indexparent'><a class='index' id='completion_signature'></a></span></p></li><li id='async.token-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.token-1.3'>(1.3)</a></div><p >specify a completion signature, which is a call signature (C++Std &sect;<a href='../n4140/func.def'>[func.def]</a>) <span class='texttt'>Signature</span> that determines the arguments to the completion handler.
</p></li></ul><p ><span class='indexparent'><a class='index' id='completion_handler'></a></span></p></div><div class='para' id='async.token-2'><div class='marginalizedparent'><a class='marginalized' href='#async.token-2'>2</a></div><p >An initiating function determines the type <span class='texttt'>CompletionHandler</span> of its
completion handler function object by performing
<span class='texttt'>typename async_result&lt;decay_t&lt;CompletionToken&gt;, Signature&gt;::completion_handler_type</span>.
The completion handler object <span class='texttt'>completion_handler</span> is initialized with
<span class='texttt'>std::forward&lt;CompletionToken&gt;(token)</span>.
[&nbsp;<i>Note:</i> No other requirements are placed on the type <span class='texttt'>CompletionToken</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='async.token-3'><div class='marginalizedparent'><a class='marginalized' href='#async.token-3'>3</a></div><p >The type <span class='texttt'>CompletionHandler</span> must satisfy the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) and <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), and be callable with the specified call signature.</p></div><div class='para' id='async.token-4'><div class='marginalizedparent'><a class='marginalized' href='#async.token-4'>4</a></div><p >In this Technical Specification, all initiating functions specify a
<i>Completion signature:</i> element that defines the call signature <span class='texttt'>Signature</span>.
The <i>Completion signature:</i> elements in this Technical Specification have named
parameters, and the results of an asynchronous operation are specified in
terms of these names.</p></div></div><div id='async.return.type'><h4 ><a class='secnum' href='#async.return.type' style='min-width:118pt'>13.2.7.3</a> Deduction of initiating function return type <a class='abbr_ref' href='async.reqmts.async.return.type'>[async.reqmts.async.return.type]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function,deduction_of_return_type'></a></span></p><div class='para' id='async.return.type-1'><div class='marginalizedparent'><a class='marginalized' href='#async.return.type-1'>1</a></div><p >The return type of an initiating function is <span class='texttt'>typename async_result&lt;decay_t&lt;CompletionToken&gt;, Signature&gt;::return_type</span>.</p></div><div class='para' id='async.return.type-2'><div class='marginalizedparent'><a class='marginalized' href='#async.return.type-2'>2</a></div><p >For the sake of exposition, this Technical Specification sometimes annotates functions with a return type <i><span class='texttt'>DEDUCED</span></i>. For every function declaration that returns <i><span class='texttt'>DEDUCED</span></i>, the meaning is equivalent to specifying the return type as <span class='texttt'>typename async_result&lt;decay_t&lt;CompletionToken&gt;, Signature&gt;::return_type</span>.</p></div></div><div id='async.return.value'><h4 ><a class='secnum' href='#async.return.value' style='min-width:118pt'>13.2.7.4</a> Production of initiating function return value <a class='abbr_ref' href='async.reqmts.async.return.value'>[async.reqmts.async.return.value]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function,production_of_return_value'></a></span></p><div class='para' id='async.return.value-1'><div class='marginalizedparent'><a class='marginalized' href='#async.return.value-1'>1</a></div><p >An initiating function produces its return type as follows:</p><ul class='itemize'><li id='async.return.value-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.return.value-1.1'>(1.1)</a></div><p >constructing an object <span class='texttt'>result</span> of type <span class='texttt'>async_result&lt;decay_t&lt;CompletionToken&gt;, Signature&gt;</span>, initialized as <span class='texttt'>result(completion_handler)</span>; and</p></li><li id='async.return.value-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.return.value-1.2'>(1.2)</a></div><p >using <span class='texttt'>result.get()</span> as the operand of the return statement.
</p></li></ul></div><div class='para' id='async.return.value-2'><div class='marginalizedparent'><a class='marginalized' href='#async.return.value-2'>2</a></div><p >[&nbsp;<i>Example:</i> Given an asynchronous operation with Completion signature <span class='texttt'>void(R1 r1, R2 r2)</span>, an initiating function meeting these requirements may be implemented as follows:</p><pre class='codeblock'>
template&lt;class CompletionToken&gt;
auto async_xyz(T1 t1, T2 t2, CompletionToken&amp;&amp; token){
  typename async_result&lt;decay_t&lt;CompletionToken&gt;, void(R1, R2)&gt;::completion_handler_type
    completion_handler(forward&lt;CompletionToken&gt;(token));

  async_result&lt;decay_t&lt;CompletionToken&gt;, void(R1, R2)&gt; result(completion_handler);

  <span class='comment'>// initiate the operation and cause completion_handler to be invoked with
</span>  <span class='comment'>// the result
</span>
  return result.get();
}
</pre></div><div class='para' id='async.return.value-3'><div class='marginalizedparent'><a class='marginalized' href='#async.return.value-3'>3</a></div><p >For convenience, initiating functions may be implemented using the <span class='texttt'>async_completion</span> template:</p><pre class='codeblock'>
template&lt;class CompletionToken&gt;
auto async_xyz(T1 t1, T2 t2, CompletionToken&amp;&amp; token){
  async_completion&lt;CompletionToken, void(R1, R2)&gt; init(token);

  <span class='comment'>// initiate the operation and cause init.completion_handler to be invoked
</span>  <span class='comment'>// with the result
</span>
  return init.result.get();
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='async.lifetime'><h4 ><a class='secnum' href='#async.lifetime' style='min-width:118pt'>13.2.7.5</a> Lifetime of initiating function arguments <a class='abbr_ref' href='async.reqmts.async.lifetime'>[async.reqmts.async.lifetime]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function,lifetime_of_arguments'></a></span></p><div class='para' id='async.lifetime-1'><div class='marginalizedparent'><a class='marginalized' href='#async.lifetime-1'>1</a></div><p >Unless otherwise specified, the lifetime of arguments to initiating functions shall be treated as follows:</p><ul class='itemize'><li id='async.lifetime-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.lifetime-1.1'>(1.1)</a></div><p >If the parameter has a pointer type or has a type of lvalue reference to non-const, the implementation may assume the validity of the pointee or referent, respectively, until the completion handler is invoked. [&nbsp;<i>Note:</i> In other words, the program must guarantee the validity of the argument until the completion handler is invoked. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li id='async.lifetime-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.lifetime-1.2'>(1.2)</a></div><p >Otherwise, the implementation must not assume the validity of the argument after the initiating function completes. [&nbsp;<i>Note:</i> In other words, the program is not required to guarantee the validity of the argument after the initiating function completes. <i>&nbsp;—&nbsp;end note</i>&nbsp;] The implementation may make copies of the argument, and all copies shall be destroyed no later than immediately after invocation of the completion handler.
</p></li></ul></div></div><div id='async.non.blocking'><h4 ><a class='secnum' href='#async.non.blocking' style='min-width:118pt'>13.2.7.6</a> Non-blocking requirements on initiating functions <a class='abbr_ref' href='async.reqmts.async.non.blocking'>[async.reqmts.async.non.blocking]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function,non-blocking_requirements'></a></span></p><div class='para' id='async.non.blocking-1'><div class='marginalizedparent'><a class='marginalized' href='#async.non.blocking-1'>1</a></div><p >An initiating function shall not block (C++Std &sect;<a href='../n4140/defns.block'>[defns.block]</a>) the calling thread pending completion of the outstanding operation.</p></div><div class='para' id='async.non.blocking-2'><div class='marginalizedparent'><a class='marginalized' href='#async.non.blocking-2'>2</a></div><p >[&nbsp;<i>Note:</i> Initiating functions may still block the calling thread for other reasons. For example, an initiating function may lock a mutex in order to synchronize access to shared data. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='async.assoc.exec'><h4 ><a class='secnum' href='#async.assoc.exec' style='min-width:118pt'>13.2.7.7</a> Associated executor <a class='abbr_ref' href='async.reqmts.async.assoc.exec'>[async.reqmts.async.assoc.exec]</a></h4><p ><span class='indexparent'><a class='index' id='associated_executor'></a></span></p><div class='para' id='async.assoc.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.exec-1'>1</a></div><p >Certain objects that participate in asynchronous operations have an associated executor. These are obtained as specified below.</p></div></div><div id='async.io.exec'><h4 ><a class='secnum' href='#async.io.exec' style='min-width:118pt'>13.2.7.8</a> I/O executor <a class='abbr_ref' href='async.reqmts.async.io.exec'>[async.reqmts.async.io.exec]</a></h4><p ><span class='indexparent'><a class='index' id='system_executor'></a></span></p><div class='para' id='async.io.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#async.io.exec-1'>1</a></div><p >An asynchronous operation has an associated executor satisfying the <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) requirements. If not otherwise specified by the asynchronous operation, this associated executor is an object of type <span class='texttt'>system_executor</span>.</p></div><div class='para' id='async.io.exec-2'><div class='marginalizedparent'><a class='marginalized' href='#async.io.exec-2'>2</a></div><p >All asynchronous operations in this Technical Specification have an associated executor object that is determined as follows:</p><ul class='itemize'><li id='async.io.exec-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.io.exec-2.1'>(2.1)</a></div><p >If the initiating function is a member function, the associated executor is that returned by the <span class='texttt'>get_executor</span> member function on the same object.</p></li><li id='async.io.exec-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.io.exec-2.2'>(2.2)</a></div><p >If the initiating function is not a member function, the associated executor is that returned by the <span class='texttt'>get_executor</span> member function of the first argument to the initiating function.
</p></li></ul></div><div class='para' id='async.io.exec-3'><div class='marginalizedparent'><a class='marginalized' href='#async.io.exec-3'>3</a></div><p >Let <span class='texttt'>Executor1</span> be the type of the associated executor. Let <span class='texttt'>ex1</span> be a value of type <span class='texttt'>Executor1</span>, representing the associated executor object obtained as described above.</p></div></div><div id='async.handler.exec'><h4 ><a class='secnum' href='#async.handler.exec' style='min-width:118pt'>13.2.7.9</a> Completion handler executor <a class='abbr_ref' href='async.reqmts.async.handler.exec'>[async.reqmts.async.handler.exec]</a></h4><div class='para' id='async.handler.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#async.handler.exec-1'>1</a></div><p >A completion handler object of type <span class='texttt'>CompletionHandler</span>
has an associated executor
satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).
The type of this associated executor is
<span class='texttt'>associated_executor_t&lt;CompletionHandler, Executor1&gt;</span>.
Let <span class='texttt'>Executor2</span> be the type
<span class='texttt'>associated_executor_t&lt;CompletionHandler, Executor1&gt;</span>.
Let <span class='texttt'>ex2</span> be a value of type <span class='texttt'>Executor2</span>
obtained by performing <span class='texttt'>get_associated_executor(completion_handler, ex1)</span>.</p></div></div><div id='async.work'><h4 ><a class='secnum' href='#async.work' style='min-width:118pt'>13.2.7.10</a> Outstanding work <a class='abbr_ref' href='async.reqmts.async.work'>[async.reqmts.async.work]</a></h4><p ><span class='indexparent'><a class='index' id='outstanding_work'></a></span></p><div class='para' id='async.work-1'><div class='marginalizedparent'><a class='marginalized' href='#async.work-1'>1</a></div><p >Until the asynchronous operation has completed, the asynchronous operation shall maintain:</p><ul class='itemize'><li id='async.work-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.work-1.1'>(1.1)</a></div><p >an object <span class='texttt'>work1</span> of type <span class='texttt'>executor_work_guard&lt;Executor1&gt;</span>, initialized as <span class='texttt'>work1(ex1)</span>, and where <span class='texttt'>work1.owns_work() == true</span>; and</p></li><li id='async.work-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.work-1.2'>(1.2)</a></div><p >an object <span class='texttt'>work2</span> of type <span class='texttt'>executor_work_guard&lt;Executor2&gt;</span>, initialized as <span class='texttt'>work2(ex2)</span>, and where <span class='texttt'>work2.owns_work() == true</span>.
</p></li></ul></div></div><div id='async.alloc'><h4 ><a class='secnum' href='#async.alloc' style='min-width:118pt'>13.2.7.11</a> Allocation of intermediate storage <a class='abbr_ref' href='async.reqmts.async.alloc'>[async.reqmts.async.alloc]</a></h4><div class='para' id='async.alloc-1'><div class='marginalizedparent'><a class='marginalized' href='#async.alloc-1'>1</a></div><p >Asynchronous operations may allocate memory. [&nbsp;<i>Note:</i> Such as a data structure to store copies of the <span class='texttt'>completion_handler</span> object and the initiating function's arguments. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='async.alloc-2'><div class='marginalizedparent'><a class='marginalized' href='#async.alloc-2'>2</a></div><p >Let <span class='texttt'>Alloc1</span> be a type, satisfying the <span class='texttt'>ProtoAllocator</span> (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>) requirements, that represents the asynchronous operation's default allocation strategy. [&nbsp;<i>Note:</i> Typically <span class='texttt'>allocator&lt;void&gt;</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Let <span class='texttt'>alloc1</span> be a value of type <span class='texttt'>Alloc1</span>.</p></div><div class='para' id='async.alloc-3'><div class='marginalizedparent'><a class='marginalized' href='#async.alloc-3'>3</a></div><p >A completion handler object of type <span class='texttt'>CompletionHandler</span> has an associated allocator object <span class='texttt'>alloc2</span> of type <span class='texttt'>Alloc2</span> satisfying the <span class='texttt'>ProtoAllocator</span> (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>) requirements. The type <span class='texttt'>Alloc2</span> is <span class='texttt'>associated_allocator_t&lt;CompletionHandler, Alloc1&gt;</span>. Let <span class='texttt'>alloc2</span> be a value of type <span class='texttt'>Alloc2</span> obtained by performing <span class='texttt'>get_associated_allocator(completion_handler, alloc1)</span>.</p></div><div class='para' id='async.alloc-4'><div class='marginalizedparent'><a class='marginalized' href='#async.alloc-4'>4</a></div><p >The asynchronous operations defined in this Technical Specification:</p><ul class='itemize'><li id='async.alloc-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.alloc-4.1'>(4.1)</a></div><p >If required, allocate memory using only the completion handler's associated allocator.</p></li><li id='async.alloc-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.alloc-4.2'>(4.2)</a></div><p >Prior to completion handler execution, deallocate any memory allocated using the completion handler's associated allocator.
</p></li></ul></div><div class='para' id='async.alloc-5'><div class='marginalizedparent'><a class='marginalized' href='#async.alloc-5'>5</a></div><p >[&nbsp;<i>Note:</i> The implementation may perform operating system or underlying API calls that perform memory allocations not using the associated allocator. Invocations of the allocator functions may not introduce data races (See C++Std &sect;<a href='../n4140/res.on.data.races'>[res.on.data.races]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='async.completion'><h4 ><a class='secnum' href='#async.completion' style='min-width:118pt'>13.2.7.12</a> Execution of completion handler on completion of asynchronous operation <a class='abbr_ref' href='async.reqmts.async.completion'>[async.reqmts.async.completion]</a></h4><div class='para' id='async.completion-1'><div class='marginalizedparent'><a class='marginalized' href='#async.completion-1'>1</a></div><p >Let <span class='texttt'>Args...</span> be the argument types of the completion signature <span class='texttt'>Signature</span> and let <i>N</i> be <span class='texttt'>sizeof...(Args)</span>. Let <i>i</i> be in the range <span class='texttt'>[0, <i>N</i>)</span>. Let <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> type in <span class='texttt'>Args...</span> and let <span class='texttt'>t</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> completion handler argument associated with <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>.</p></div><div class='para' id='async.completion-2'><div class='marginalizedparent'><a class='marginalized' href='#async.completion-2'>2</a></div><p >Let <span class='texttt'>f</span> be a function object, callable as <span class='texttt'>f()</span>, that invokes <span class='texttt'>completion_handler</span> as if by <span class='texttt'>completion_handler(forward&lt;T<span class='math'><sub >0</sub></span>&gt;(t<span class='math'><sub >0</sub></span>), ..., forward&lt;T<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(t<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span>.</p></div><div class='para' id='async.completion-3'><div class='marginalizedparent'><a class='marginalized' href='#async.completion-3'>3</a></div><p >If an asynchronous operation completes immediately (that is, within the thread of execution calling the initiating function, and before the initiating function returns), the completion handler shall be submitted for execution as if by performing <span class='texttt'>ex2.post(std::move(f), alloc2)</span>. Otherwise, the completion handler shall be submitted for execution as if by performing <span class='texttt'>ex2.dispatch(std::move(f), alloc2)</span>.</p></div></div><div id='async.exceptions'><h4 ><a class='secnum' href='#async.exceptions' style='min-width:118pt'>13.2.7.13</a> Completion handlers and exceptions <a class='abbr_ref' href='async.reqmts.async.exceptions'>[async.reqmts.async.exceptions]</a></h4><div class='para' id='async.exceptions-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exceptions-1'>1</a></div><p >Completion handlers are permitted to throw exceptions. The effect of any exception propagated from the execution of a completion handler is determined by the executor which is executing the completion handler.</p></div></div><div id='async.composed'><h4 ><a class='secnum' href='#async.composed' style='min-width:118pt'>13.2.7.14</a> Composed asynchronous operations <a class='abbr_ref' href='async.reqmts.async.composed'>[async.reqmts.async.composed]</a></h4><div class='para' id='async.composed-1'><div class='marginalizedparent'><a class='marginalized' href='#async.composed-1'>1</a></div><p >In this Technical Specification, a <a class='hidden_link' href='#def:composed_asynchronous_operation' id='def:composed_asynchronous_operation'><i>composed asynchronous operation</i></a> is an asynchronous operation that is implemented in terms of zero or more intermediate calls to other asynchronous operations. The intermediate asynchronous operations are performed sequentially. [&nbsp;<i>Note:</i> That is, the completion handler of an intermediate operation initiates the next operation in the sequence. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >An intermediate operation's completion handler shall have an associated executor that is either:</p><ul class='itemize'><li id='async.composed-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.composed-1.1'>(1.1)</a></div><p >the type <span class='texttt'>Executor2</span> and object <span class='texttt'>ex2</span> obtained from the completion handler type <span class='texttt'>CompletionHandler</span> and object <span class='texttt'>completion_handler</span>; or</p></li><li id='async.composed-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.composed-1.2'>(1.2)</a></div><p >an object of an unspecified type satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>), that delegates executor operations to the type <span class='texttt'>Executor2</span> and object <span class='texttt'>ex2</span>.
</p></li></ul><p >An intermediate operation's completion handler shall have an associated allocator that is either:</p><ul class='itemize'><li id='async.composed-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.composed-1.3'>(1.3)</a></div><p >the type <span class='texttt'>Alloc2</span> and object <span class='texttt'>alloc2</span> obtained from the completion handler type <span class='texttt'>CompletionHandler</span> and object <span class='texttt'>completion_handler</span>; or</p></li><li id='async.composed-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.composed-1.4'>(1.4)</a></div><p >an object of an unspecified type satisfying the ProtoAllocator requirements (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>), that delegates allocator operations to the type <span class='texttt'>Alloc2</span> and object <span class='texttt'>alloc2</span>.
</p></li></ul></div></div></div></div></div></body></html>