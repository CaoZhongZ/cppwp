<!DOCTYPE html><html lang='en'><head><title>Networking: Tables</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1>List of Tables <a href='./#tab' class='abbr_ref'>[tab]</a></h1><hr><h4 ><a class='secnum' style='min-width:73pt'>7</a> Feature test macros (Informative) <a class='abbr_ref' href='feature.test#tab:info.features'>[feature.test]</a></h4><div class='numberedTable' id='info.features'>Table <a href='#info.features'>1</a> — Feature-test macro(s)<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Macro name</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'>

<span class='texttt'>__cpp_lib_experimental_net</span>  </td><td class='left'> <span class='texttt'>201803</span>      </td></tr><tr ><td class='left'>
<span class='texttt'>__cpp_lib_experimental_net_extensible</span>  </td><td class='left'> <span class='texttt'>201803</span>      </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:73pt'>10</a> Library summary <a class='abbr_ref' href='summary#tab:summary'>[summary]</a></h4><div class='numberedTable' id='summary'>Table <a href='#summary'>2</a> — Networking library summary<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Clause</b></td><td colspan='1' class='center'><b>Header(s)</b></td></tr><tr class='capsep'><td class='left'> 
Convenience header (<a href='convenience.hdr'>[convenience.hdr]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/net&gt;</span>  </td></tr><tr class='rowsep'><td class='left'> Forward declarations (<a href='fwd.decl'>[fwd.decl]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/netfwd&gt;</span>  </td></tr><tr class='rowsep'><td class='left'> Asynchronous model (<a href='async'>[async]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/executor&gt;</span>  </td></tr><tr class='rowsep'><td class='left'> Basic I/O services (<a href='io_context'>[io_context]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/io_context&gt;</span>  </td></tr><tr class='rowsep'><td class='left'> Timers (<a href='timer'>[timer]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/timer&gt;</span>  </td></tr><tr class='rowsep'><td class='left'> Buffers (<a href='buffer'>[buffer]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/buffer&gt;</span>  </td></tr><tr ><td class='left'>
Buffer-oriented streams (<a href='buffer.stream'>[buffer.stream]</a>)  </td><td class='left'>
 </td></tr><tr class='rowsep'><td class='left'> Sockets (<a href='socket'>[socket]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/socket&gt;</span>  </td></tr><tr ><td class='left'>
Socket iostreams (<a href='socket.iostreams'>[socket.iostreams]</a>)  </td><td class='left'>
 </td></tr><tr ><td class='left'>
Socket algorithms (<a href='socket.algo'>[socket.algo]</a>)  </td><td class='left'>
 </td></tr><tr class='rowsep'><td class='left'> Internet protocol (<a href='internet'>[internet]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/internet&gt;</span>  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:73pt'>10</a> Library summary <a class='abbr_ref' href='summary#tab:summary.requirements'>[summary]</a></h4><div class='numberedTable' id='summary.requirements'>Table <a href='#summary.requirements'>3</a> — Template parameters and type requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>template parameter name</b></td><td colspan='1' class='center'><b>type requirements</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>AcceptableProtocol</span>  </td><td class='left'>
acceptable protocol (<a href='socket.reqmts.acceptableprotocol'>[socket.reqmts.acceptableprotocol]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>Allocator</span>  </td><td class='left'>
 <span class='CppXref'>allocator.requirements</span>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>AsyncReadStream</span>  </td><td class='left'>
buffer-oriented asynchronous read stream (<a href='buffer.stream.reqmts.asyncreadstream'>[buffer.stream.reqmts.asyncreadstream]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>AsyncWriteStream</span>  </td><td class='left'>
buffer-oriented asynchronous write stream (<a href='buffer.stream.reqmts.asyncwritestream'>[buffer.stream.reqmts.asyncwritestream]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>Clock</span>  </td><td class='left'>
 <span class='CppXref'>time.clock.req</span>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>CompletionCondition</span>  </td><td class='left'>
completion condition (<a href='buffer.stream.reqmts.completioncondition'>[buffer.stream.reqmts.completioncondition]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>CompletionToken</span>  </td><td class='left'>
completion token (<a href='async.reqmts.async.token'>[async.reqmts.async.token]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ConnectCondition</span>  </td><td class='left'>
connect condition (<a href='socket.reqmts.connectcondition'>[socket.reqmts.connectcondition]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ConstBufferSequence</span>  </td><td class='left'>
constant buffer sequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>DynamicBuffer</span>  </td><td class='left'>
dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>EndpointSequence</span>  </td><td class='left'>
endpoint sequence (<a href='socket.reqmts.endpointsequence'>[socket.reqmts.endpointsequence]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ExecutionContext</span>  </td><td class='left'>
execution context (<a href='async.reqmts.executioncontext'>[async.reqmts.executioncontext]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>Executor</span>  </td><td class='left'>
executor (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>GettableSocketOption</span>  </td><td class='left'>
gettable socket option (<a href='socket.reqmts.gettablesocketoption'>[socket.reqmts.gettablesocketoption]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>InternetProtocol</span>  </td><td class='left'>
Internet protocol (<a href='internet.reqmts.protocol'>[internet.reqmts.protocol]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>IoControlCommand</span>  </td><td class='left'>
I/O control command (<a href='socket.reqmts.iocontrolcommand'>[socket.reqmts.iocontrolcommand]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>MutableBufferSequence</span>  </td><td class='left'>
mutable buffer sequence (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ProtoAllocator</span>  </td><td class='left'>
proto-allocator (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>Protocol</span>  </td><td class='left'>
protocol (<a href='socket.reqmts.protocol'>[socket.reqmts.protocol]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>Service</span>  </td><td class='left'>
service (<a href='async.reqmts.service'>[async.reqmts.service]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>SettableSocketOption</span>  </td><td class='left'>
settable socket option (<a href='socket.reqmts.settablesocketoption'>[socket.reqmts.settablesocketoption]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>Signature</span>  </td><td class='left'>
signature (<a href='async.reqmts.signature'>[async.reqmts.signature]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>SyncReadStream</span>  </td><td class='left'>
buffer-oriented synchronous read stream (<a href='buffer.stream.reqmts.syncreadstream'>[buffer.stream.reqmts.syncreadstream]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>SyncWriteStream</span>  </td><td class='left'>
buffer-oriented synchronous write stream (<a href='buffer.stream.reqmts.syncwritestream'>[buffer.stream.reqmts.syncwritestream]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>WaitTraits</span>  </td><td class='left'>
wait traits (<a href='timer.reqmts.waittraits'>[timer.reqmts.waittraits]</a>)  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>13.2.2</a> Executor requirements <a class='abbr_ref' href='async.reqmts.executor#tab:async.reqmts.executor.requirements'>[async.reqmts.executor]</a></h4><div class='numberedTable' id='async.reqmts.executor.requirements'>Table <a href='#async.reqmts.executor.requirements'>4</a> — Executor requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X u(x1);</span>  </td><td class='left'>
  </td><td class='left'>
Shall not exit via an exception.<br/><i>post:</i> <span class='texttt'>u == x1</span> and <span class='texttt'>std::addressof(u.context()) == std::addressof(x1.context()).</span>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(mx1);</span>  </td><td class='left'>
  </td><td class='left'>
Shall not exit via an exception.<br/><i>post:</i> <span class='texttt'>u</span> equals the prior value of <span class='texttt'>mx1</span> and <span class='texttt'>std::addressof(u.context())</span> equals the prior value of <span class='texttt'>std::addressof(mx1.context())</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1 == x2</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>true</span> only if <span class='texttt'>x1</span> and <span class='texttt'>x2</span> can be interchanged with identical effects in any of the expressions defined in these type requirements. [&nbsp;<i>Note:</i> Returning <span class='texttt'>false</span> does not necessarily imply that the effects are not identical. <i>&nbsp;—&nbsp;end note</i>&nbsp;]<br/><span class='texttt'>operator==</span> shall be reflexive, symmetric, and transitive, and shall not exit via an exception.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1 != x2</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
Same as <span class='texttt'>!(x1 == x2)</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.context()</span>  </td><td class='left'>
<span class='texttt'>execution_context&amp;</span>, or <span class='texttt'>E&amp;</span> where <span class='texttt'>E</span> is a type that satisfies the <span class='texttt'>ExecutionContext</span>  (<a href='async.reqmts.executioncontext'>[async.reqmts.executioncontext]</a>) requirements.  </td><td class='left'>
Shall not exit via an exception. The comparison operators and member functions defined in these requirements shall not alter the reference returned by this function.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.on_work_started()</span>  </td><td class='left'>
  </td><td class='left'>
 Shall not exit via an exception.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.on_work_finished()</span>  </td><td class='left'>
  </td><td class='left'>
Shall not exit via an exception. <br/><i>Precondition:</i> A preceding call <span class='texttt'>x2.on_work_started()</span> where <span class='texttt'>x1 == x2</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.dispatch(<br/><span class='mbox'>  </span>std::move(f), a)</span>  </td><td class='left'>
  </td><td class='left'>
<i>Effects:</i> Creates an object <span class='texttt'>f1</span> initialized with <span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;Func&gt;(f))</span> (<span class='CppXref'>thread.decaycopy</span>) in the current thread of execution. Calls <span class='texttt'>f1()</span> at most once. The executor may block forward progress of the caller until <span class='texttt'>f1()</span> finishes execution. Executor implementations should use the supplied allocator to allocate any memory required to store the function object. Prior to invoking the function object, the executor shall deallocate any memory allocated. [&nbsp;<i>Note:</i> Executors defined in this document always use the supplied allocator unless otherwise specified. <i>&nbsp;—&nbsp;end note</i>&nbsp;] <br/>
<i>Synchronization:</i> The invocation of <span class='texttt'>dispatch</span> synchronizes with (<span class='CppXref'>intro.multithread</span>) the invocation of <span class='texttt'>f1</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.post(std::move(f), a)</span>  </td><td class='left'>
  </td><td class='left'>
<i>Effects:</i> Creates an object <span class='texttt'>f1</span> initialized with <span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;Func&gt;(f))</span> in the current thread of execution. Calls <span class='texttt'>f1()</span> at most once. The executor shall not block forward progress of the caller pending completion of <span class='texttt'>f1()</span>. The executor may begin <span class='texttt'>f1</span>'s progress before the call to <span class='texttt'>post</span> completes. Executor implementations should use the supplied allocator to allocate any memory required to store the function object. Prior to invoking the function object, the executor shall deallocate any memory allocated. [&nbsp;<i>Note:</i> Executors defined in this document always use the supplied allocator unless otherwise specified. <i>&nbsp;—&nbsp;end note</i>&nbsp;]<br/>
<i>Synchronization:</i> The invocation of <span class='texttt'>post</span> synchronizes with (<span class='CppXref'>intro.multithread</span>) the invocation of <span class='texttt'>f1</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.defer(std::move(f), a)</span>  </td><td class='left'>
  </td><td class='left'>
<i>Effects:</i> Creates an object <span class='texttt'>f1</span> initialized with <span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;Func&gt;(f))</span> in the current thread of execution. Calls <span class='texttt'>f1()</span> at most once. The executor shall not block forward progress of the caller pending completion of <span class='texttt'>f1()</span>. The executor should not begin <span class='texttt'>f1</span>'s progress before the call to <span class='texttt'>defer</span> completes. [&nbsp;<i>Note:</i> One use of <span class='texttt'>defer</span> is to convey the intention of the caller that <span class='texttt'>f1</span> is a continuation of the current call context. The executor can use this information to optimize or otherwise adjust the way in which <span class='texttt'>f1</span> is invoked. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  Executor implementations should use the supplied allocator to allocate any memory required to store the function object. Prior to invoking the function object, the executor shall deallocate any memory allocated. [&nbsp;<i>Note:</i> Executors defined in this document always use the supplied allocator unless otherwise specified. <i>&nbsp;—&nbsp;end note</i>&nbsp;]<br/>
<i>Synchronization:</i> The invocation of <span class='texttt'>defer</span> synchronizes with (<span class='CppXref'>intro.multithread</span>) the invocation of <span class='texttt'>f1</span>.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>13.2.3</a> Execution context requirements <a class='abbr_ref' href='async.reqmts.executioncontext#tab:async.reqmts.executioncontext.requirements'>[async.reqmts.executioncontext]</a></h4><div class='numberedTable' id='async.reqmts.executioncontext.requirements'>Table <a href='#async.reqmts.executioncontext.requirements'>5</a> — ExecutionContext requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::executor_type</span>  </td><td class='left'>
type meeting <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) requirements  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.~X()</span>  </td><td class='left'>
  </td><td class='left'>
 Destroys all unexecuted function objects that were submitted via an executor object that is associated with the execution context.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.get_executor()</span>  </td><td class='left'>
<span class='texttt'>X::executor_type</span>  </td><td class='left'>
 Returns an executor object that is associated with the execution context.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>13.2.6</a> Associator requirements <a class='abbr_ref' href='async.reqmts.associator#tab:async.reqmts.associator.requirements'>[async.reqmts.associator]</a></h4><div class='numberedTable' id='async.reqmts.associator.requirements'>Table <a href='#async.reqmts.associator.requirements'>6</a> — Associator requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X&lt;S&gt;::type</span>  </td><td class='left'>
<span class='texttt'>X&lt;S, D&gt;::type</span>  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X&lt;S, C&gt;::type</span>  </td><td class='left'>
  </td><td class='left'>
 The associated type.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X&lt;S&gt;::get(s)</span>  </td><td class='left'>
<span class='texttt'>X&lt;S&gt;::type</span>  </td><td class='left'>
Returns <span class='texttt'>X&lt;S&gt;::get(S, d)</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X&lt;S, C&gt;::get(s, c)</span>  </td><td class='left'>
<span class='texttt'>X&lt;S, C&gt;::type</span>  </td><td class='left'>
 Returns the associated object.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:88pt'>13.3</a> Class template <span class='texttt'>async_result</span> <a class='abbr_ref' href='async.async.result#tab:async.async.result.requirements'>[async.async.result]</a></h4><div class='numberedTable' id='async.async.result.requirements'>Table <a href='#async.async.result.requirements'>7</a> — <span class='texttt'>async_result</span> specialization requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Requirement</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>R::completion_handler_type</span>  </td><td class='left'>
  </td><td class='left'>
A type satisfying <span class='texttt'>MoveConstructible</span> requirements (<span class='CppXref'>moveconstructible</span>), An object of type <span class='texttt'>completion_handler_type</span> shall be a function object with call signature <span class='texttt'>Signature</span>, and <span class='texttt'>completion_handler_type</span> shall be constructible with an rvalue of type <span class='texttt'>CompletionToken</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>R::return_type</span>  </td><td class='left'>
  </td><td class='left'>
<span class='texttt'>void</span>; or a type satisfying <span class='texttt'>MoveConstructible</span> requirements (<span class='CppXref'>moveconstructible</span>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>R r(h);</span>  </td><td class='left'>
  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>r.get()</span>  </td><td class='left'>
<span class='texttt'>R::return_type</span>  </td><td class='left'>
[&nbsp;<i>Note:</i> An asynchronous operation's initiating function uses the <span class='texttt'>get()</span> member function as the sole operand of a return statement. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:88pt'>13.5</a> Class template <span class='texttt'>associated_allocator</span> <a class='abbr_ref' href='async.assoc.alloc#tab:async.assoc.alloc.requirements'>[async.assoc.alloc]</a></h4><div class='numberedTable' id='async.assoc.alloc.requirements'>Table <a href='#async.assoc.alloc.requirements'>8</a> — <span class='texttt'>associated_allocator</span> specialization requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Note</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>typename X::type</span>  </td><td class='left'>
A type meeting the proto-allocator (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>) requirements.  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::get(t)</span>  </td><td class='left'>
<span class='texttt'>X::type</span>  </td><td class='left'>
Shall not exit via an exception. Equivalent to <span class='texttt'>X::get(t, ProtoAllocator())</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::get(t, a)</span>  </td><td class='left'>
<span class='texttt'>X::type</span>  </td><td class='left'>
 Shall not exit via an exception.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:88pt'>13.12</a> Class template <span class='texttt'>associated_executor</span> <a class='abbr_ref' href='async.assoc.exec#tab:async.assoc.exec.requirements'>[async.assoc.exec]</a></h4><div class='numberedTable' id='async.assoc.exec.requirements'>Table <a href='#async.assoc.exec.requirements'>9</a> — <span class='texttt'>associated_executor</span> specialization requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Note</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>typename X::type</span>  </td><td class='left'>
A type meeting Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::get(t)</span>  </td><td class='left'>
<span class='texttt'>X::type</span>  </td><td class='left'>
Shall not exit via an exception. Equivalent to <span class='texttt'>X::get(t, Executor())</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::get(t, e)</span>  </td><td class='left'>
<span class='texttt'>X::type</span>  </td><td class='left'>
 Shall not exit via an exception.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>13.26.3</a> Partial class template specialization <span class='texttt'>async_result</span>
        for <span class='texttt'>use_future_t</span> <a class='abbr_ref' href='async.use.future.result#tab:async.use.future.result.requirements'>[async.use.future.result]</a></h4><div class='numberedTable' id='async.use.future.result.requirements'>Table <a href='#async.use.future.result.requirements'>10</a> — <span class='texttt'>async_result&lt;use_future_t&lt;ProtoAllocator&gt;, Result(Args...)&gt;</span> semantics<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>N</b></td><td colspan='1' class='center'><b>U<span class='math'><sub >0</sub></span></b></td><td colspan='1' class='center'><b><span class='texttt'>R::return_type</span></b></td><td colspan='1' class='center'><b><span class='texttt'>F::operator()</span> effects</b></td></tr><tr class='capsep'><td class='center'> 
 0  </td><td class='left'>
  </td><td class='left'>
<span class='texttt'>future&lt;void&gt;</span>  </td><td class='justify'>
 None.  </td></tr><tr class='rowsep'><td class='center'>  1  </td><td class='left'>
<span class='texttt'>error_code</span>  </td><td class='left'>
<span class='texttt'>future&lt;void&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> evaluates to <span class='texttt'>true</span>, atomically stores the exception pointer produced by <span class='texttt'>make_exception_ptr(system_error(a<span class='math'><sub >0</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  1  </td><td class='left'>
<span class='texttt'>exception_ptr</span>  </td><td class='left'>
<span class='texttt'>future&lt;void&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> is non-null, atomically stores the exception pointer a<span class='math'><sub >0</sub></span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  1  </td><td class='left'>
 all other types  </td><td class='left'>
<span class='texttt'>future&lt;U<span class='math'><sub >0</sub></span>&gt;</span>  </td><td class='justify'>
Atomically stores <span class='texttt'>forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>)</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  2  </td><td class='left'>
<span class='texttt'>error_code</span>  </td><td class='left'>
<span class='texttt'>future&lt;U<span class='math'><sub >1</sub></span>&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> evaluates to <span class='texttt'>true</span>, atomically stores the exception pointer produced by <span class='texttt'>make_exception_ptr(system_error(a<span class='math'><sub >0</sub></span>))</span> in the shared state; otherwise, atomically stores <span class='texttt'>forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>)</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  2  </td><td class='left'>
<span class='texttt'>exception_ptr</span>  </td><td class='left'>
<span class='texttt'>future&lt;U<span class='math'><sub >1</sub></span>&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> is non-null, atomically stores the exception pointer in the shared state; otherwise, atomically stores <span class='texttt'>forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>)</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  2  </td><td class='left'>
 all other types  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >0</sub></span>, U<span class='math'><sub >1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
Atomically stores <span class='texttt'>forward_as_tuple(<br/>forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>), forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  &gt;2  </td><td class='left'>
<span class='texttt'>error_code</span>  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >1</sub></span>, <span class='math'>&hellip;</span>, U<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> evaluates to <span class='texttt'>true</span>, atomically stores the exception pointer produced by <span class='texttt'>make_exception_ptr(system_error(a<span class='math'><sub >0</sub></span>))</span> in the shared state; otherwise, atomically stores <span class='texttt'>forward_as_tuple(forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>), <span class='math'>&hellip;</span>, forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  &gt;2  </td><td class='left'>
<span class='texttt'>exception_ptr</span>  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >1</sub></span>, <span class='math'>&hellip;</span>, U<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> is non-null, atomically stores the exception pointer in the shared state; otherwise, atomically stores <span class='texttt'>forward_as_tuple(forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>), <span class='math'>&hellip;</span>, forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  &gt;2  </td><td class='left'>
 all other types  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >0</sub></span>, <span class='math'>&hellip;</span>, U<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
Atomically stores <span class='texttt'>forward_as_tuple(<br/>forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>), <span class='math'>&hellip;</span>, forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> in the shared state.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>15.2.1</a> Wait traits requirements <a class='abbr_ref' href='timer.reqmts.waittraits#tab:timer.reqmts.waittraits.requirements'>[timer.reqmts.waittraits]</a></h4><div class='numberedTable' id='timer.reqmts.waittraits.requirements'>Table <a href='#timer.reqmts.waittraits.requirements'>11</a> — WaitTraits requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::to_wait_duration(d)</span>  </td><td class='left'>
<span class='texttt'>Clock::duration</span>  </td><td class='left'>
Returns a <span class='texttt'>Clock::duration</span> value to be used in a <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operation. [&nbsp;<i>Note:</i> The return value is typically representative of the duration <span class='texttt'>d</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::to_wait_duration(t)</span>  </td><td class='left'>
<span class='texttt'>Clock::duration</span>  </td><td class='left'>
Returns a <span class='texttt'>Clock::duration</span> value to be used in a <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operation. [&nbsp;<i>Note:</i> The return value is typically representative of the duration from <span class='texttt'>Clock::now()</span> until the time point <span class='texttt'>t</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>16.2.1</a> Mutable buffer sequence requirements <a class='abbr_ref' href='buffer.reqmts.mutablebuffersequence#tab:buffer.reqmts.mutablebuffersequence.requirements'>[buffer.reqmts.mutablebuffersequence]</a></h4><div class='numberedTable' id='buffer.reqmts.mutablebuffersequence.requirements'>Table <a href='#buffer.reqmts.mutablebuffersequence.requirements'>12</a> — MutableBufferSequence requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note</b></td></tr><tr ><td colspan='1' class='center'><b></b></td><td colspan='1' class='center'><b></b></td><td colspan='1' class='center'><b>pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>net::buffer_sequence_begin(x)</span><br/>
<span class='texttt'>net::buffer_sequence_end(x)</span>  </td><td class='left'>
An iterator type whose <span class='texttt'>reference</span> type is convertible to <span class='texttt'>mutable_buffer</span>,
and which satisfies all the requirements for bidirectional iterators (<span class='CppXref'>bidirectional.iterators</span>)
except that:
<ul class='itemize'><li ><p >there is no requirement that <span class='texttt'>operator-&gt;</span> is provided, and
</p></li><li ><p >there is no requirement that <span class='texttt'>reference</span> be a reference type.
</p></li></ul> </td><td class='left'>
For a dereferenceable iterator, no increment, decrement, or dereference operation, or conversion of the reference type to <span class='texttt'>mutable_buffer</span>, shall exit via an exception.
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(x);</span>
  </td><td class='left'>
  </td><td class='left'>
post: <pre class='codeblock'>
equal(
  net::buffer_sequence_begin(x),
  net::buffer_sequence_end(x),
  net::buffer_sequence_begin(u),
  net::buffer_sequence_end(u),
  [](const mutable_buffer&amp; b1,
     const mutable_buffer&amp; b2)
   {
     return b1.data() == b2.data()
         &amp;&amp; b1.size() == b2.size();
   })
</pre>
  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>16.2.2</a> Constant buffer sequence requirements <a class='abbr_ref' href='buffer.reqmts.constbuffersequence#tab:buffer.reqmts.constbuffersequence.requirements'>[buffer.reqmts.constbuffersequence]</a></h4><div class='numberedTable' id='buffer.reqmts.constbuffersequence.requirements'>Table <a href='#buffer.reqmts.constbuffersequence.requirements'>13</a> — ConstBufferSequence requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note</b></td></tr><tr ><td colspan='1' class='center'><b></b></td><td colspan='1' class='center'><b></b></td><td colspan='1' class='center'><b>pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>net::buffer_sequence_begin(x)</span><br/>
<span class='texttt'>net::buffer_sequence_end(x)</span>  </td><td class='left'>
An iterator type whose <span class='texttt'>reference</span> type is convertible to <span class='texttt'>const_buffer</span>,
and which satisfies all the requirements for bidirectional iterators (<span class='CppXref'>bidirectional.iterators</span>)
except that:
<ul class='itemize'><li ><p >there is no requirement that <span class='texttt'>operator-&gt;</span> is provided, and
</p></li><li ><p >there is no requirement that <span class='texttt'>reference</span> be a reference type.
</p></li></ul> </td><td class='left'>
For a dereferenceable iterator, no increment, decrement, or dereference operation, or conversion of the reference type to <span class='texttt'>const_buffer</span>, shall exit via an exception.
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(x);</span>
  </td><td class='left'>
  </td><td class='left'>
post:
<pre class='codeblock'>
equal(
  net::buffer_sequence_begin(x),
  net::buffer_sequence_end(x),
  net::buffer_sequence_begin(u),
  net::buffer_sequence_end(u),
  [](const const_buffer&amp; b1,
     const const_buffer&amp; b2)
   {
     return b1.data() == b2.data()
         &amp;&amp; b1.size() == b2.size();
   })
</pre>
  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>16.2.4</a> Dynamic buffer requirements <a class='abbr_ref' href='buffer.reqmts.dynamicbuffer#tab:buffer.reqmts.dynamicbuffer.requirements'>[buffer.reqmts.dynamicbuffer]</a></h4><div class='numberedTable' id='buffer.reqmts.dynamicbuffer.requirements'>Table <a href='#buffer.reqmts.dynamicbuffer.requirements'>14</a> — DynamicBuffer requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::const_buffers_type</span>  </td><td class='left'>
type meeting ConstBufferSequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) requirements.  </td><td class='left'>
 This type represents the memory associated with the readable bytes.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::mutable_buffers_type</span>  </td><td class='left'>
type meeting MutableBufferSequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) requirements.  </td><td class='left'>
 This type represents the memory associated with the writable bytes.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.size()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
 Returns the number of readable bytes.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.max_size()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns the maximum number of bytes, both readable and writable, that can be held by <span class='texttt'>x1</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.capacity()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns the maximum number of bytes, both readable and writable, that can be held by <span class='texttt'>x1</span> without requiring reallocation.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.data()</span>  </td><td class='left'>
<span class='texttt'>X::const_buffers_type</span>  </td><td class='left'>
Returns a constant buffer sequence <span class='texttt'>u</span> that represents the readable bytes, and where <span class='texttt'>buffer_size(u) == size()</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.prepare(n)</span>  </td><td class='left'>
<span class='texttt'>X::mutable_buffers_type</span>  </td><td class='left'>
Returns a mutable buffer sequence <span class='texttt'>u</span> representing the writable bytes, and where <span class='texttt'>buffer_size(u) == n</span>. The dynamic buffer reallocates memory as required. All constant or mutable buffer sequences previously obtained using <span class='texttt'>data()</span> or <span class='texttt'>prepare()</span> are invalidated.<br/> <i>Throws:</i> <span class='texttt'>length_error</span> if <span class='texttt'>size() + n</span> exceeds <span class='texttt'>max_size()</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.commit(n)</span>  </td><td class='left'>
  </td><td class='left'>
Appends <span class='texttt'>n</span> bytes from the start of the writable bytes to the end of the readable bytes. The remainder of the writable bytes are discarded. If <span class='texttt'>n</span> is greater than the number of writable bytes, all writable bytes are appended to the readable bytes. All constant or mutable buffer sequences previously obtained using <span class='texttt'>data()</span> or <span class='texttt'>prepare()</span> are invalidated.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.consume(n)</span>  </td><td class='left'>
  </td><td class='left'>
Removes <span class='texttt'>n</span> bytes from beginning of the readable bytes. If <span class='texttt'>n</span> is greater than the number of readable bytes, all readable bytes are removed. All constant or mutable buffer sequences previously obtained using <span class='texttt'>data()</span> or <span class='texttt'>prepare()</span> are invalidated.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:88pt'>16.6</a> Buffer type traits <a class='abbr_ref' href='buffer.traits#tab:buffer.traits.requirements'>[buffer.traits]</a></h4><div class='numberedTable' id='buffer.traits.requirements'>Table <a href='#buffer.traits.requirements'>15</a> — Buffer type traits<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Preconditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>template&lt;class T&gt;</span><br/>
<span class='texttt'>struct is_mutable_buffer_sequence</span>  </td><td class='left'>
<span class='texttt'>T</span> meets the syntactic requirements for mutable buffer sequence (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>).  </td><td class='left'>
<span class='texttt'>T</span> is a complete type.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template&lt;class T&gt;</span><br/>
<span class='texttt'>struct is_const_buffer_sequence</span>  </td><td class='left'>
<span class='texttt'>T</span> meets the syntactic requirements for constant buffer sequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>).  </td><td class='left'>
<span class='texttt'>T</span> is a complete type.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template&lt;class T&gt;</span><br/>
<span class='texttt'>struct is_dynamic_buffer</span>  </td><td class='left'>
<span class='texttt'>T</span> meets the syntactic requirements for dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>).  </td><td class='left'>
<span class='texttt'>T</span> is a complete type.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>17.1.1</a> Buffer-oriented synchronous read stream requirements <a class='abbr_ref' href='buffer.stream.reqmts.syncreadstream#tab:buffer.stream.reqmts.syncreadstream.requirements'>[buffer.stream.reqmts.syncreadstream]</a></h4><div class='numberedTable' id='buffer.stream.reqmts.syncreadstream.requirements'>Table <a href='#buffer.stream.reqmts.syncreadstream.requirements'>16</a> — SyncReadStream requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>operation</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>semantics, pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.read_some(mb)</span>
<span class='texttt'>a.read_some(mb,ec)</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Meets the requirements for a read operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).<br/>
If <span class='texttt'>buffer_size(mb) &gt; 0</span>, reads one or more bytes of data from the stream <span class='texttt'>a</span> into the buffer sequence <span class='texttt'>mb</span>. If successful, sets <span class='texttt'>ec</span> such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and returns the number of bytes read. If an error occurred, sets <span class='texttt'>ec</span> such that <span class='texttt'>!!ec</span> is <span class='texttt'>true</span>, and returns 0. If all data has been read from the stream, and the stream performed an orderly shutdown, sets <span class='texttt'>ec</span> to <span class='texttt'>stream_errc::eof</span> and returns 0. If <span class='texttt'>buffer_size(mb) == 0</span>, the operation shall not block. Sets <span class='texttt'>ec</span> such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and returns 0.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>17.1.2</a> Buffer-oriented asynchronous read stream requirements <a class='abbr_ref' href='buffer.stream.reqmts.asyncreadstream#tab:buffer.stream.reqmts.asyncreadstream.requirements'>[buffer.stream.reqmts.asyncreadstream]</a></h4><div class='numberedTable' id='buffer.stream.reqmts.asyncreadstream.requirements'>Table <a href='#buffer.stream.reqmts.asyncreadstream.requirements'>17</a> — AsyncReadStream requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>operation</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>semantics, pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.get_executor()</span>  </td><td class='left'>
A type satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).  </td><td class='left'>
 Returns the associated I/O executor.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.async_read_some(mb,t)</span>  </td><td class='left'>
The return type is determined according to the requirements for an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>).  </td><td class='left'>
Meets the requirements for a read operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>) and an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>) with completion signature <span class='texttt'>void(error_code ec, size_t n)</span>.<br/>
If <span class='texttt'>buffer_size(mb) &gt; 0</span>, initiates an asynchronous operation to read one or more bytes of data from the stream <span class='texttt'>a</span> into the buffer sequence <span class='texttt'>mb</span>. If successful, <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is the number of bytes read. If an error occurred, <span class='texttt'>ec</span> is set such that <span class='texttt'>!!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is 0. If all data has been read from the stream, and the stream performed an orderly shutdown, <span class='texttt'>ec</span> is <span class='texttt'>stream_errc::eof</span> and <span class='texttt'>n</span> is 0. If <span class='texttt'>buffer_size(mb) == 0</span>, the operation completes immediately. <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is 0.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>17.1.3</a> Buffer-oriented synchronous write stream requirements <a class='abbr_ref' href='buffer.stream.reqmts.syncwritestream#tab:buffer.stream.reqmts.syncwritestream.requirements'>[buffer.stream.reqmts.syncwritestream]</a></h4><div class='numberedTable' id='buffer.stream.reqmts.syncwritestream.requirements'>Table <a href='#buffer.stream.reqmts.syncwritestream.requirements'>18</a> — SyncWriteStream requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>operation</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>semantics, pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.write_some(cb)</span>
<span class='texttt'>a.write_some(cb,ec)</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Meets the requirements for a write operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).<br/>
If <span class='texttt'>buffer_size(cb) &gt; 0</span>, writes one or more bytes of data to the stream <span class='texttt'>a</span> from the buffer sequence <span class='texttt'>cb</span>. If successful, sets <span class='texttt'>ec</span> such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and returns the number of bytes written. If an error occurred, sets <span class='texttt'>ec</span> such that <span class='texttt'>!!ec</span> is <span class='texttt'>true</span>, and returns 0. If <span class='texttt'>buffer_size(cb) == 0</span>, the operation shall not block. Sets <span class='texttt'>ec</span> such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and returns 0.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>17.1.4</a> Buffer-oriented asynchronous write stream requirements <a class='abbr_ref' href='buffer.stream.reqmts.asyncwritestream#tab:buffer.stream.reqmts.asyncwritestream.requirements'>[buffer.stream.reqmts.asyncwritestream]</a></h4><div class='numberedTable' id='buffer.stream.reqmts.asyncwritestream.requirements'>Table <a href='#buffer.stream.reqmts.asyncwritestream.requirements'>19</a> — AsyncWriteStream requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>operation</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>semantics, pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.get_executor()</span>  </td><td class='left'>
A type satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).  </td><td class='left'>
 Returns the associated I/O executor.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.async_write_some(cb,t)</span>  </td><td class='left'>
The return type is determined according to the requirements for an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>).  </td><td class='left'>
Meets the requirements for a write operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>) and an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>) with completion signature <span class='texttt'>void(error_code ec, size_t n)</span>.<br/>
If <span class='texttt'>buffer_size(cb) &gt; 0</span>, initiates an asynchronous operation to write one or more bytes of data to the stream <span class='texttt'>a</span> from the buffer sequence <span class='texttt'>cb</span>. If successful, <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is the number of bytes written. If an error occurred, <span class='texttt'>ec</span> is set such that <span class='texttt'>!!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is 0. If <span class='texttt'>buffer_size(cb) == 0</span>, the operation completes immediately. <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is 0.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>17.1.5</a> Completion condition requirements <a class='abbr_ref' href='buffer.stream.reqmts.completioncondition#tab:buffer.stream.reqmts.completioncondition.requirements'>[buffer.stream.reqmts.completioncondition]</a></h4><div class='numberedTable' id='buffer.stream.reqmts.completioncondition.requirements'>Table <a href='#buffer.stream.reqmts.completioncondition.requirements'>20</a> — CompletionCondition requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>x(ec, n)</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Let <span class='texttt'>n</span> be the total number of bytes transferred by the read or write algorithm so far.<br/>
Returns the maximum number of bytes to be transferred on the next <span class='texttt'>read_some</span>, <span class='texttt'>async_read_some</span>, <span class='texttt'>write_some</span>, or <span class='texttt'>async_write_some</span> operation performed by the algorithm. Returns <span class='texttt'>0</span> to indicate that the algorithm is complete.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>18.2.4</a> Endpoint requirements <a class='abbr_ref' href='socket.reqmts.endpoint#tab:socket.reqmts.endpoint.requirements'>[socket.reqmts.endpoint]</a></h4><div class='numberedTable' id='socket.reqmts.endpoint.requirements'>Table <a href='#socket.reqmts.endpoint.requirements'>21</a> — Endpoint requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::protocol_type</span>  </td><td class='left'>
type meeting <span class='texttt'>Protocol</span> (<a href='socket.reqmts.protocol'>[socket.reqmts.protocol]</a>) requirements  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.protocol()</span>  </td><td class='left'>
<span class='texttt'>protocol_type</span>  </td><td class='left'>
  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>18.2.4</a> Endpoint requirements <a class='abbr_ref' href='socket.reqmts.endpoint#tab:socket.reqmts.endpoint.requirements.ext'>[socket.reqmts.endpoint]</a></h4><div class='numberedTable' id='socket.reqmts.endpoint.requirements.ext'>Table <a href='#socket.reqmts.endpoint.requirements.ext'>22</a> — Endpoint requirements for extensible implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.data()</span>  </td><td class='left'>
<span class='texttt'>const void*</span>  </td><td class='left'>
Returns a pointer suitable for passing as the <span class='texttt'>address</span> argument to functions such as POSIX <span class='texttt'>connect</span>, or as the <span class='texttt'>dest_addr</span> argument to functions such as POSIX <span class='texttt'>sendto</span>. The implementation shall perform a <span class='texttt'>static_cast</span> on the pointer to convert it to <span class='texttt'>const sockaddr*</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.data()</span>  </td><td class='left'>
<span class='texttt'>void*</span>  </td><td class='left'>
Returns a pointer suitable for passing as the <span class='texttt'>address</span> argument to functions such as POSIX <span class='texttt'>accept</span>, <span class='texttt'>getpeername</span>, <span class='texttt'>getsockname</span> and <span class='texttt'>recvfrom</span>. The implementation shall perform a <span class='texttt'>static_cast</span> on the pointer to convert it to <span class='texttt'>sockaddr*</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.size()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>address_len</span> argument to functions such as POSIX <span class='texttt'>connect</span>, or as the <span class='texttt'>dest_len</span> argument to functions such as POSIX <span class='texttt'>sendto</span>, after appropriate integer conversion has been performed.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.resize(s)</span>  </td><td class='left'>
  </td><td class='left'>
pre: <span class='texttt'>s &gt;= 0</span><br/>
post: <span class='texttt'>a.size() == s</span><br/>
Passed the value contained in the <span class='texttt'>address_len</span> argument to functions such as POSIX <span class='texttt'>accept</span>, <span class='texttt'>getpeername</span>, <span class='texttt'>getsockname</span>, and <span class='texttt'>recvfrom</span>, after successful completion of the function. Permitted to throw an exception if the protocol associated with the endpoint object <span class='texttt'>a</span> does not support the specified size.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.capacity()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>address_len</span> argument to functions such as POSIX <span class='texttt'>accept</span>, <span class='texttt'>getpeername</span>, <span class='texttt'>getsockname</span>, and <span class='texttt'>recvfrom</span>, after appropriate integer conversion has been performed.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>18.2.5</a> Endpoint sequence requirements <a class='abbr_ref' href='socket.reqmts.endpointsequence#tab:socket.reqmts.endpointsequence.requirements'>[socket.reqmts.endpointsequence]</a></h4><div class='numberedTable' id='socket.reqmts.endpointsequence.requirements'>Table <a href='#socket.reqmts.endpointsequence.requirements'>23</a> — EndpointSequence requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>x.begin()</span><br/><span class='texttt'>x.end()</span>  </td><td class='left'>
A type meeting the requirements for forward iterators (<span class='CppXref'>forward.iterators</span>) whose value type is convertible to a type satisfying the <span class='texttt'>Endpoint</span> (<a href='socket.reqmts.endpoint'>[socket.reqmts.endpoint]</a>) requirements.  </td><td class='left'>
<span class='texttt'>[x.begin(), x.end())</span> is a valid range.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>18.2.6</a> Protocol requirements <a class='abbr_ref' href='socket.reqmts.protocol#tab:socket.reqmts.protocol.requirements'>[socket.reqmts.protocol]</a></h4><div class='numberedTable' id='socket.reqmts.protocol.requirements'>Table <a href='#socket.reqmts.protocol.requirements'>24</a> — Protocol requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::endpoint</span>  </td><td class='left'>
type meeting endpoint (<a href='socket.reqmts.endpoint'>[socket.reqmts.endpoint]</a>) requirements  </td><td class='left'>
  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>18.2.6</a> Protocol requirements <a class='abbr_ref' href='socket.reqmts.protocol#tab:socket.reqmts.protocol.requirements.ext'>[socket.reqmts.protocol]</a></h4><div class='numberedTable' id='socket.reqmts.protocol.requirements.ext'>Table <a href='#socket.reqmts.protocol.requirements.ext'>25</a> — Protocol requirements for extensible implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.family()</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the domain argument to POSIX <span class='texttt'>socket</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.type()</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the type argument to POSIX <span class='texttt'>socket</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.protocol()</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the protocol argument to POSIX <span class='texttt'>socket</span> (or equivalent).  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>18.2.7</a> Acceptable protocol requirements <a class='abbr_ref' href='socket.reqmts.acceptableprotocol#tab:socket.reqmts.acceptableprotocol.requirements'>[socket.reqmts.acceptableprotocol]</a></h4><div class='numberedTable' id='socket.reqmts.acceptableprotocol.requirements'>Table <a href='#socket.reqmts.acceptableprotocol.requirements'>26</a> — AcceptableProtocol requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::socket</span>  </td><td class='left'>
A type that satisfies the requirements of <span class='texttt'>Destructible</span> (<span class='CppXref'>destructible</span>) and <span class='texttt'>MoveConstructible</span> (<span class='CppXref'>moveconstructible</span>), and that is publicly and unambiguously derived from <span class='texttt'>basic_socket&lt;X&gt;</span>.  </td><td class='left'>
  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>18.2.8</a> Gettable socket option requirements <a class='abbr_ref' href='socket.reqmts.gettablesocketoption#tab:socket.reqmts.gettablesocketoption.requirements'>[socket.reqmts.gettablesocketoption]</a></h4><div class='numberedTable' id='socket.reqmts.gettablesocketoption.requirements'>Table <a href='#socket.reqmts.gettablesocketoption.requirements'>27</a> — GettableSocketOption requirements for extensible implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.level(p)</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>level</span> argument to POSIX <span class='texttt'>getsockopt</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.name(p)</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>option_name</span> argument to POSIX <span class='texttt'>getsockopt</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.data(p)</span>  </td><td class='left'>
<span class='texttt'>void*</span>  </td><td class='left'>
Returns a pointer suitable for passing as the <span class='texttt'>option_value</span> argument to POSIX getsockopt (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.size(p)</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>option_len</span> argument to POSIX <span class='texttt'>getsockopt</span> (or equivalent), after appropriate integer conversion has been performed.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.resize(p,s)</span>  </td><td class='left'>
  </td><td class='left'>
post: <span class='texttt'>b.size(p) == s</span>. Passed the value contained in the <span class='texttt'>option_len</span> argument to POSIX <span class='texttt'>getsockopt</span> (or equivalent) after successful completion of the function. Permitted to throw an exception if the socket option object <span class='texttt'>b</span> does not support the specified size.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>18.2.9</a> Settable socket option requirements <a class='abbr_ref' href='socket.reqmts.settablesocketoption#tab:socket.reqmts.settablesocketoption.requirements'>[socket.reqmts.settablesocketoption]</a></h4><div class='numberedTable' id='socket.reqmts.settablesocketoption.requirements'>Table <a href='#socket.reqmts.settablesocketoption.requirements'>28</a> — SettableSocketOption requirements for extensible implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.level(p)</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>level</span> argument to POSIX <span class='texttt'>setsockopt</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.name(p)</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>option_name</span> argument to POSIX <span class='texttt'>setsockopt</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.data(p)</span>  </td><td class='left'>
<span class='texttt'>const void*</span>  </td><td class='left'>
Returns a pointer suitable for passing as the <span class='texttt'>option_value</span> argument to POSIX <span class='texttt'>setsockopt</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.size(p)</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>option_len</span> argument to POSIX <span class='texttt'>setsockopt</span> (or equivalent), after appropriate integer conversion has been performed.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>18.2.10</a> Boolean socket options <a class='abbr_ref' href='socket.reqmts.opt.bool#tab:socket.reqmts.opt.bool.requirements'>[socket.reqmts.opt.bool]</a></h4><div class='numberedTable' id='socket.reqmts.opt.bool.requirements'>Table <a href='#socket.reqmts.opt.bool.requirements'>29</a> — BooleanSocketOption requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X u;</span>  </td><td class='left'>
  </td><td class='left'>
post: <span class='texttt'>!u.value()</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(v);</span>  </td><td class='left'>
  </td><td class='left'>
post: <span class='texttt'>u.value() == v</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.value()</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
 Returns the current boolean value of the socket option object.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>static_cast&lt;bool&gt;(a)</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>a.value()</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>!a</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>!a.value()</span>.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>18.2.11</a> Integer socket options <a class='abbr_ref' href='socket.reqmts.opt.int#tab:socket.reqmts.opt.int.requirements'>[socket.reqmts.opt.int]</a></h4><div class='numberedTable' id='socket.reqmts.opt.int.requirements'>Table <a href='#socket.reqmts.opt.int.requirements'>30</a> — IntegerSocketOption requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X u;</span>  </td><td class='left'>
  </td><td class='left'>
post: <span class='texttt'>u.value() == 0</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(v);</span>  </td><td class='left'>
  </td><td class='left'>
post: <span class='texttt'>u.value() == v</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.value()</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
 Returns the current integer value of the socket option object.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>18.2.12</a> I/O control command requirements <a class='abbr_ref' href='socket.reqmts.iocontrolcommand#tab:socket.reqmts.iocontrolcommand.requirements'>[socket.reqmts.iocontrolcommand]</a></h4><div class='numberedTable' id='socket.reqmts.iocontrolcommand.requirements'>Table <a href='#socket.reqmts.iocontrolcommand.requirements'>31</a> — IoControlCommand requirements for extensible implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.name()</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the request argument to POSIX <span class='texttt'>ioctl</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.data()</span>  </td><td class='left'>
<span class='texttt'>void*</span>  </td><td class='left'>
  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>18.2.13</a> Connect condition requirements <a class='abbr_ref' href='socket.reqmts.connectcondition#tab:socket.reqmts.connectcondition.requirements'>[socket.reqmts.connectcondition]</a></h4><div class='numberedTable' id='socket.reqmts.connectcondition.requirements'>Table <a href='#socket.reqmts.connectcondition.requirements'>32</a> — ConnectCondition requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>x(ec, ep)</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>true</span> to indicate that the <span class='texttt'>connect</span> or <span class='texttt'>async_connect</span> algorithm should attempt a connection to the endpoint <span class='texttt'>ep</span>. Otherwise, returns <span class='texttt'>false</span> to indicate that the algorithm should not attempt connection to the endpoint <span class='texttt'>ep</span>, and should instead skip to the next endpoint in the sequence.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:88pt'>18.4</a> Class <span class='texttt'>socket_base</span> <a class='abbr_ref' href='socket.base#tab:socket.base.requirements'>[socket.base]</a></h4><div class='numberedTable' id='socket.base.requirements'>Table <a href='#socket.base.requirements'>33</a> — <span class='texttt'>socket_base</span> constants<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Constant Name</b></td><td colspan='1' class='center'><b>POSIX macro</b></td><td colspan='1' class='center'><b>Definition or notes</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>shutdown_receive</span>  </td><td class='left'>
<span class='texttt'>SHUT_RD</span>  </td><td class='left'>
 Disables further receive operations.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>shutdown_send</span>  </td><td class='left'>
<span class='texttt'>SHUT_WR</span>  </td><td class='left'>
 Disables further send operations.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>shutdown_both</span>  </td><td class='left'>
<span class='texttt'>SHUT_RDWR</span>  </td><td class='left'>
 Disables further send and receive operations.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>wait_read</span>  </td><td class='left'>
  </td><td class='left'>
Wait until the socket is ready-to-read. For a given socket, when a <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operation using <span class='texttt'>wait_read</span> completes successfully, a subsequent call to the socket's <span class='texttt'>receive</span> or <span class='texttt'>receive_from</span> functions may complete without blocking. Similarly, for a given acceptor, when a <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operation using <span class='texttt'>wait_read</span> completes successfully, a subsequent call to the acceptor's <span class='texttt'>accept</span> function may complete without blocking.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>wait_write</span>  </td><td class='left'>
  </td><td class='left'>
Wait until the socket is ready-to-write. For a given socket, when a <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operation using <span class='texttt'>wait_write</span> completes successfully, a subsequent call to the socket's <span class='texttt'>send</span> or <span class='texttt'>send_to</span> functions may complete without blocking.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>wait_error</span>  </td><td class='left'>
  </td><td class='left'>
Wait until the socket has a pending error condition. For a given socket, when a <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operation using <span class='texttt'>wait_error</span> completes successfully, a subsequent call to one of the socket's synchronous operations may complete without blocking. The nature of the pending error condition determines which.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>message_peek</span>  </td><td class='left'>
<span class='texttt'>MSG_PEEK</span>  </td><td class='left'>
 Leave received data in queue.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>message_out_of_band</span>  </td><td class='left'>
<span class='texttt'>MSG_OOB</span>  </td><td class='left'>
 Out-of-band data.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>message_do_not_route</span>  </td><td class='left'>
<span class='texttt'>MSG_DONTROUTE</span>  </td><td class='left'>
 Send without using routing tables.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>max_listen_connections</span>  </td><td class='left'>
<span class='texttt'>SOMAXCONN</span>  </td><td class='left'>
 The <span class='indexparent'><a class='index' id='maximum_length_of_the_queue_of_pending_incoming_connections'></a></span>implementation-defined limit on the length of the queue of pending incoming connections.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:88pt'>18.5</a> Socket options <a class='abbr_ref' href='socket.opt#tab:socket.opt.requirements'>[socket.opt]</a></h4><div class='numberedTable' id='socket.opt.requirements'>Table <a href='#socket.opt.requirements'>34</a> — Socket options<br><table ><tr class='rowsep'><td colspan='1' class='center'><b><i>C</i></b></td><td colspan='1' class='center'><b><i>L</i></b></td><td colspan='1' class='center'><b><i>N</i></b></td><td colspan='1' class='center'><b><i>T</i></b></td><td colspan='1' class='center'><b>Requirements, definition or notes</b></td></tr><tr class='capsep'><td class='justify'> 
<span class='texttt'>socket_base::</span>
<span class='texttt'>broadcast</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_BROADCAST</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether a socket permits sending of broadcast messages, if supported by the protocol.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>debug</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_DEBUG</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether debugging information is recorded by the underlying protocol.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>do_not_route</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_DONTROUTE</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether outgoing messages bypass standard routing facilities.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>keep_alive</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_KEEPALIVE</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether a socket permits sending of keep_alive messages, if supported by the protocol.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>linger</span> (<a href='socket.opt.linger'>[socket.opt.linger]</a>)  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_LINGER</span>  </td><td class='left'>
<span class='texttt'>linger</span>  </td><td class='justify'>
 Controls the behavior when a socket is closed and unsent data is present.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>out_of_band_inline</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_OOBINLINE</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether out-of-band data (also known as urgent data) is received inline.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>receive_buffer_size</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_RCVBUF</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the size of the receive buffer associated with a socket.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>receive_low_watermark</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_RCVLOWAT</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the minimum number of bytes to process for socket input operations.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>reuse_address</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_REUSEADDR</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether the validation of endpoints used for binding a socket should allow the reuse of local endpoints, if supported by the protocol.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>send_buffer_size</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_SNDBUF</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the size of the send buffer associated with a socket.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>send_low_watermark</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_SNDLOWAT</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the minimum number of bytes to process for socket output operations.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>21.2.1</a> Internet protocol requirements <a class='abbr_ref' href='internet.reqmts.protocol#tab:internet.reqmts.protocol.requirements'>[internet.reqmts.protocol]</a></h4><div class='numberedTable' id='internet.reqmts.protocol.requirements'>Table <a href='#internet.reqmts.protocol.requirements'>35</a> — InternetProtocol requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::resolver</span>  </td><td class='left'>
<span class='texttt'>ip::basic_resolver&lt;X&gt;</span>  </td><td class='left'>
 The type of a resolver for the protocol.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::v4()</span>  </td><td class='left'>
<span class='texttt'>X</span>  </td><td class='left'>
 Returns an object representing the IP version 4 protocol.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::v6()</span>  </td><td class='left'>
<span class='texttt'>X</span>  </td><td class='left'>
 Returns an object representing the IP version 6 protocol.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a == b</span>  </td><td class='left'>
convertible to <span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>true</span> if <span class='texttt'>a</span> and <span class='texttt'>b</span> represent the same IP protocol version, otherwise <span class='texttt'>false</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a != b</span>  </td><td class='left'>
convertible to <span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>!(a == b)</span>.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:103pt'>21.2.2</a> Multicast group socket options <a class='abbr_ref' href='internet.reqmts.opt.mcast#tab:internet.reqmts.opt.mcast.requirements'>[internet.reqmts.opt.mcast]</a></h4><div class='numberedTable' id='internet.reqmts.opt.mcast.requirements'>Table <a href='#internet.reqmts.opt.mcast.requirements'>36</a> — MulticastGroupSocketOption requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X u(a);</span>  </td><td class='left'>
  </td><td class='left'>
 Constructs a multicast group socket option to join the group with the specified version-independent address.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(b, c);</span>  </td><td class='left'>
  </td><td class='left'>
 Constructs a multicast group socket option to join the specified IPv4 address on a specified network interface.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(d, e);</span>  </td><td class='left'>
  </td><td class='left'>
 Constructs a multicast group socket option to join the specified IPv6 address on a specified network interface.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:88pt'>21.16</a> Class <span class='texttt'>ip::resolver_base</span> <a class='abbr_ref' href='internet.resolver.base#tab:internet.resolver.base.requirements'>[internet.resolver.base]</a></h4><div class='numberedTable' id='internet.resolver.base.requirements'>Table <a href='#internet.resolver.base.requirements'>37</a> — Resolver flags<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Constant name</b></td><td colspan='1' class='center'><b>POSIX macro</b></td><td colspan='1' class='center'><b>Definition or notes</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>passive</span>  </td><td class='left'>
<span class='texttt'>AI_PASSIVE</span>  </td><td class='left'>
 Returned endpoints are intended for use as locally bound socket endpoints.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>canonical_name</span>  </td><td class='left'>
<span class='texttt'>AI_CANONNAME</span>  </td><td class='left'>
 Determine the canonical name of the host specified in the query.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>numeric_host</span>  </td><td class='left'>
<span class='texttt'>AI_NUMERICHOST</span>  </td><td class='left'>
 Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no host name resolution should be attempted.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>numeric_service</span>  </td><td class='left'>
<span class='texttt'>AI_NUMERICSERV</span>  </td><td class='left'>
 Service name should be treated as a numeric string defining a port number and no service name resolution should be attempted.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>v4_mapped</span>  </td><td class='left'>
<span class='texttt'>AI_V4MAPPED</span>  </td><td class='left'>
 If the protocol is specified as an IPv6 protocol, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>all_matching</span>  </td><td class='left'>
<span class='texttt'>AI_ALL</span>  </td><td class='left'>
If used with <span class='texttt'>v4_mapped</span>, return all matching IPv6 and IPv4 addresses.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>address_configured</span>  </td><td class='left'>
<span class='texttt'>AI_ADDRCONFIG</span>  </td><td class='left'>
 Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system.  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:88pt'>21.19</a> Class <span class='texttt'>ip::tcp</span> <a class='abbr_ref' href='internet.tcp#tab:internet.tcp.requirements'>[internet.tcp]</a></h4><div class='numberedTable' id='internet.tcp.requirements'>Table <a href='#internet.tcp.requirements'>38</a> — Behavior of extensible <span class='texttt'>ip::tcp</span> implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>value</b></td><td colspan='1' class='center'><b>family()</b></td><td colspan='1' class='center'><b>type()</b></td><td colspan='1' class='center'><b>protocol()</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>tcp::v4()</span>  </td><td class='left'>
<span class='texttt'>AF_INET</span>  </td><td class='left'>
<span class='texttt'>SOCK_STREAM</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_TCP</span>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>tcp::v6()</span>  </td><td class='left'>
<span class='texttt'>AF_INET6</span>  </td><td class='left'>
<span class='texttt'>SOCK_STREAM</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_TCP</span>  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:88pt'>21.20</a> Class <span class='texttt'>ip::udp</span> <a class='abbr_ref' href='internet.udp#tab:internet.udp.requirements'>[internet.udp]</a></h4><div class='numberedTable' id='internet.udp.requirements'>Table <a href='#internet.udp.requirements'>39</a> — Behavior of extensible <span class='texttt'>ip::udp</span> implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>value</b></td><td colspan='1' class='center'><b>family()</b></td><td colspan='1' class='center'><b>type()</b></td><td colspan='1' class='center'><b>protocol()</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>udp::v4()</span>  </td><td class='left'>
<span class='texttt'>AF_INET</span>  </td><td class='left'>
<span class='texttt'>SOCK_DGRAM</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_UDP</span>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>udp::v6()</span>  </td><td class='left'>
<span class='texttt'>AF_INET6</span>  </td><td class='left'>
<span class='texttt'>SOCK_DGRAM</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_UDP</span>  </td></tr></table></div><hr><h4 ><a class='secnum' style='min-width:88pt'>21.21</a> Internet socket options <a class='abbr_ref' href='internet.socket.opt#tab:internet.socket.opt.requirements'>[internet.socket.opt]</a></h4><div class='numberedTable' id='internet.socket.opt.requirements'>Table <a href='#internet.socket.opt.requirements'>40</a> — Internet socket options<br><table ><tr class='rowsep'><td colspan='1' class='center'><b><i>C</i></b></td><td colspan='1' class='center'><b><i>L</i></b></td><td colspan='1' class='center'><b><i>N</i></b></td><td colspan='1' class='center'><b><i>T</i></b></td><td colspan='1' class='center'><b>Requirements,</b></td></tr><tr ><td class='left'>
  </td><td class='left'>
  </td><td class='left'>
  </td><td class='left'>
  </td><td colspan='1' class='center'><b>definition or notes</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>ip::tcp::</span><br/>
<span class='texttt'>no_delay</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_TCP</span>  </td><td class='left'>
<span class='texttt'>TCP_NODELAY</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether a TCP socket will avoid coalescing of small segments. [&nbsp;<i>Note:</i> That is, setting this option disables the Nagle algorithm. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::v6_only</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span>  </td><td class='left'>
<span class='texttt'>IPV6_V6ONLY</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether a socket created for an IPv6 protocol is restricted to IPv6 communications only. Implementations are not required to support setting the <span class='texttt'>v6_only</span> option to <span class='texttt'>false</span>, and the initial value of the <span class='texttt'>v6_only</span> option for a socket is <span class='indexparent'><a class='index' id='initial_value_of_the_v6_only_option_for_a_socket'></a></span>implementation-defined. [&nbsp;<i>Note:</i> As not all operating systems support dual stack IP networking. Some operating systems that do provide dual stack support offer a configuration option to disable it or to set the initial value of the <span class='texttt'>v6_only</span> socket option. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::unicast::</span>
<span class='texttt'>hops</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_UNICAST_HOPS</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_TTL</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the default number of hops (also known as time-to-live or TTL) on outbound datagrams. The constructor and assignment operator for the <span class='texttt'>ip::unicast::hops</span> class throw <span class='texttt'>out_of_range</span> if the <span class='texttt'>int</span> argument is not in the range <span class='texttt'>[0, 255]</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>join_group</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_JOIN_GROUP</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_ADD_MEMBERSHIP</span>  </td><td class='left'>
<span class='texttt'>ipv6_mreq</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>ip_mreq</span>  </td><td class='left'>
Satisfies the <span class='texttt'>MulticastGroupSocketOption</span> (<a href='internet.reqmts.opt.mcast'>[internet.reqmts.opt.mcast]</a>) type requirements. Requests that the socket join the specified multicast group.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>leave_group</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_LEAVE_GROUP</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_DROP_MEMBERSHIP</span>  </td><td class='left'>
<span class='texttt'>ipv6_mreq</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>ip_mreq</span>  </td><td class='left'>
Satisfies the <span class='texttt'>MulticastGroupSocketOption</span> (<a href='internet.reqmts.opt.mcast'>[internet.reqmts.opt.mcast]</a>) type requirements. Requests that the socket leave the specified multicast group.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>outbound_interface</span><br/> (<a href='internet.multicast.outbound'>[internet.multicast.outbound]</a>)  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_MULTICAST_IF</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_IF</span>  </td><td class='left'>
<span class='texttt'>unsigned int</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>in_addr</span>  </td><td class='left'>
 Specifies the network interface to use for outgoing multicast datagrams.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>hops</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_MULTICAST_HOPS</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_TTL</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the default number of hops (also known as time-to-live or TTL) on outbound datagrams. The constructor and assignment operator for the <span class='texttt'>ip::multicast::hops</span> class throw <span class='texttt'>out_of_range</span> if the <span class='texttt'>int</span> argument is not in the range <span class='texttt'>[0, 255]</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>enable_loopback</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_MULTICAST_LOOP</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_LOOP</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether multicast datagrams are delivered back to the local application.  </td></tr></table></div></div></body></html>