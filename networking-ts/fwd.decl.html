<!DOCTYPE html><html lang='en'><head><title>[fwd.decl]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='fwd.decl'><h1 ><a class='secnum' style='min-width:73pt'>12</a> Forward declarations <a class='abbr_ref' href='./#fwd.decl'>[fwd.decl]</a></h1><p ><span class='indexparent'><a class='index' id='experimental/netfwd'></a></span></p><div id='synop'><h2 ><a class='secnum' href='#synop' style='min-width:88pt'>12.1</a> Header <span class='texttt'>&lt;experimental/netfwd&gt;</span> synopsis <a class='abbr_ref' href='fwd.decl.synop'>[fwd.decl.synop]</a></h2><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class execution_context;
  template&lt;class T, class Executor&gt;
    class executor_binder;
  template&lt;class Executor&gt;
    class executor_work_guard;
  class system_executor;
  class executor;
  template&lt;class Executor&gt;
    class strand;

  class io_context;

  template&lt;class Clock&gt; struct wait_traits;
  template&lt;class Clock, class WaitTraits = wait_traits&lt;Clock&gt;&gt;
    class basic_waitable_timer;
  using system_timer = basic_waitable_timer&lt;chrono::system_clock&gt;;
  using steady_timer = basic_waitable_timer&lt;chrono::steady_clock&gt;;
  using high_resolution_timer = basic_waitable_timer&lt;chrono::high_resolution_clock&gt;;

  template&lt;class Protocol&gt;
    class basic_socket;
  template&lt;class Protocol&gt;
    class basic_datagram_socket;
  template&lt;class Protocol&gt;
    class basic_stream_socket;
  template&lt;class Protocol&gt;
    class basic_socket_acceptor;
  template&lt;class Protocol, class Clock = chrono::steady_clock,
    class WaitTraits = wait_traits&lt;Clock&gt;&gt;
      class basic_socket_streambuf;
  template&lt;class Protocol, class Clock = chrono::steady_clock,
    class WaitTraits = wait_traits&lt;Clock&gt;&gt;
      class basic_socket_iostream;

  namespace ip {

    class address;
    class address_v4;
    class address_v6;
    template&lt;class Address&gt;
      class basic_address_iterator;
    using address_v4_iterator = basic_address_iterator&lt;address_v4&gt;;
    using address_v6_iterator = basic_address_iterator&lt;address_v6&gt;;
    template&lt;class Address&gt;
      class basic_address_range;
    using address_v4_range = basic_address_range&lt;address_v4&gt;;
    using address_v6_range = basic_address_range&lt;address_v6&gt;;
    class network_v4;
    class network_v6;
    template&lt;class InternetProtocol&gt;
      class basic_endpoint;
    template&lt;class InternetProtocol&gt;
      class basic_resolver_entry;
    template&lt;class InternetProtocol&gt;
      class basic_resolver_results;
    template&lt;class InternetProtocol&gt;
      class basic_resolver;
    class tcp;
    class udp;

  } <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='synop-1'><div class='marginalizedparent'><a class='marginalized' href='#synop-1'>1</a></div><p >Default template arguments are described as appearing both in <span class='texttt'>&lt;netfwd&gt;</span>
and in the synopsis of other headers but it is well-formed to include both
<span class='texttt'>&lt;netfwd&gt;</span> and one or more of the other headers.
[&nbsp;<i>Note:</i> It is the implementation's responsibility to implement headers so
that including <span class='texttt'>&lt;netfwd&gt;</span> and other headers does not violate the rules
about multiple occurrences of default arguments. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div></div></div></body></html>