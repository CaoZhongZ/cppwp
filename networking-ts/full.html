<!DOCTYPE html><html lang='en'><head><title>Networking</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='scope'><h1 ><a class='secnum' href='#scope' style='min-width:73pt'>1</a> Scope <a class='abbr_ref' href='./#scope'>[scope]</a></h1><div class='para' id='scope-1'><div class='marginalizedparent'><a class='marginalized' href='#scope-1'>1</a></div><p >This Technical Specification describes extensions to the C++ Standard Library.
This Technical Specification specifies requirements for implementations of an
interface that computer programs written in the C++ programming language may
use to perform operations related to networking, such as operations involving
sockets, timers, buffer management, host name resolution and internet protocols.
This Technical Specification is applicable to information technology systems
that can perform network operations, such as those with operating systems that
conform to the POSIX interface. This Technical Specification is applicable only
to vendors who wish to provide the interface it describes.</p></div></div><div id='references'><h1 ><a class='secnum' href='#references' style='min-width:73pt'>2</a> Normative references <a class='abbr_ref' href='./#references'>[references]</a></h1><div class='para' id='references-1'><div class='marginalizedparent'><a class='marginalized' href='#references-1'>1</a></div><p >The following referenced documents are indispensable for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</p></div><div class='para' id='references-2'><div class='marginalizedparent'><a class='marginalized' href='#references-2'>2</a></div><p >[&nbsp;<i>Note:</i> The programming language and library described in ISO/IEC 14882 is herein called the C++ Standard. References to clauses within the C++ Standard are written as “C++Std &sect;<a href='../n4140/library'>[library]</a>”.  The operating system interface described in ISO/IEC 9945 is herein called POSIX. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='references-3'><div class='marginalizedparent'><a class='marginalized' href='#references-3'>3</a></div><p >This Technical Specification mentions commercially available operating systems for purposes of exposition.  POSIX&reg; is a registered trademark of The IEEE. Windows&reg; is a registered trademark of Microsoft Corporation. This information is given for the convenience of users of this document and does not constitute an endorsement by ISO or IEC of these products.</p></div><div class='para' id='references-4'><div class='marginalizedparent'><a class='marginalized' href='#references-4'>4</a></div><p >Unless otherwise specified, the whole of the C++ Standard's Library introduction (C++Std &sect;<a href='../n4140/library'>[library]</a>) is included into this Technical Specification by reference.</p></div></div><div id='defs'><h1 ><a class='secnum' href='#defs' style='min-width:73pt'>3</a> Terms and definitions <a class='abbr_ref' href='./#defs'>[defs]</a></h1><p ><span class='indexparent'><a class='index' id='host_byte_order'></a></span></p><div id='defs.host.byte.order'><h2 ><a class='secnum' href='#defs.host.byte.order' style='min-width:88pt'>3.1</a> host byte order <a class='abbr_ref' href='defs.host.byte.order'>[defs.host.byte.order]</a></h2><p >see section 3.194 of POSIX Base Definitions, Host Byte Order</p><p ><span class='indexparent'><a class='index' id='network_byte_order'></a></span></p></div><div id='defs.net.byte.order'><h2 ><a class='secnum' href='#defs.net.byte.order' style='min-width:88pt'>3.2</a> network byte order <a class='abbr_ref' href='defs.net.byte.order'>[defs.net.byte.order]</a></h2><p >see section 3.238 of POSIX Base Definitions, Network Byte Order</p><p ><span class='indexparent'><a class='index' id='synchronous_operation'></a></span></p></div><div id='defs.sync.op'><h2 ><a class='secnum' href='#defs.sync.op' style='min-width:88pt'>3.3</a> synchronous operation <a class='abbr_ref' href='defs.sync.op'>[defs.sync.op]</a></h2><p >an operation where control is not returned until the operation completes</p><p ><span class='indexparent'><a class='index' id='asynchronous_operation'></a></span></p></div><div id='defs.async.op'><h2 ><a class='secnum' href='#defs.async.op' style='min-width:88pt'>3.4</a> asynchronous operation <a class='abbr_ref' href='defs.async.op'>[defs.async.op]</a></h2><p >an operation where control is returned immediately without waiting for the operation to complete
[&nbsp;<i>Note:</i> Multiple asynchronous operations may be executed concurrently. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='orderly_shutdown'></a></span></p></div><div id='defs.orderly.shutdown'><h2 ><a class='secnum' href='#defs.orderly.shutdown' style='min-width:88pt'>3.5</a> orderly shutdown <a class='abbr_ref' href='defs.orderly.shutdown'>[defs.orderly.shutdown]</a></h2><p >the procedure for shutting down a stream after all work in progress has been completed, without loss of data</p></div></div><div id='general'><h1 ><a class='secnum' href='#general' style='min-width:73pt'>4</a> General Principles <a class='abbr_ref' href='./#general'>[general]</a></h1><div id='conformance'><h2 ><a class='secnum' href='#conformance' style='min-width:88pt'>4.1</a> Conformance <a class='abbr_ref' href='conformance'>[conformance]</a></h2><div class='para' id='conformance-1'><div class='marginalizedparent'><a class='marginalized' href='#conformance-1'>1</a></div><p >Conformance is specified in terms of behavior. Ideal behavior is not always implementable, so the conformance sub-clauses take that into account.</p></div><div id='conformance.9945'><h3 ><a class='secnum' href='#conformance.9945' style='min-width:103pt'>4.1.1</a> POSIX conformance <a class='abbr_ref' href='conformance.9945'>[conformance.9945]</a></h3><div class='para' id='conformance.9945-1'><div class='marginalizedparent'><a class='marginalized' href='#conformance.9945-1'>1</a></div><p >Some behavior is specified by reference to POSIX. How such behavior is actually implemented is unspecified.</p></div><div class='para' id='conformance.9945-2'><div class='marginalizedparent'><a class='marginalized' href='#conformance.9945-2'>2</a></div><p >[&nbsp;<i>Note:</i> This constitutes an “as if” rule allowing implementations to call native operating system or other APIs. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='conformance.9945-3'><div class='marginalizedparent'><a class='marginalized' href='#conformance.9945-3'>3</a></div><p >Implementations are encouraged to provide such behavior as it is defined by POSIX. Implementations shall document any behavior that differs from the behavior defined by POSIX. Implementations that do not support exact POSIX behavior are encouraged to provide behavior as close to POSIX behavior as is reasonable given the limitations of actual operating systems and file systems. If an implementation cannot provide any reasonable behavior, the implementation shall report an error as specified in Error Reporting (<a href='err.report'>[err.report]</a>).</p></div><div class='para' id='conformance.9945-4'><div class='marginalizedparent'><a class='marginalized' href='#conformance.9945-4'>4</a></div><p >[&nbsp;<i>Note:</i> This allows users to rely on an exception being thrown or an error code being set when an implementation cannot provide any reasonable behavior. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='conformance.9945-5'><div class='marginalizedparent'><a class='marginalized' href='#conformance.9945-5'>5</a></div><p >Implementations are not required to provide behavior that is not supported by a particular operating system.</p></div></div><div id='conformance.conditional'><h3 ><a class='secnum' href='#conformance.conditional' style='min-width:103pt'>4.1.2</a> Conditionally-supported features <a class='abbr_ref' href='conformance.conditional'>[conformance.conditional]</a></h3><div class='para' id='conformance.conditional-1'><div class='marginalizedparent'><a class='marginalized' href='#conformance.conditional-1'>1</a></div><p >This Technical Specification defines conditionally-supported features, in the form of additional member functions on types that satisfy <span class='texttt'>Protocol</span> (<a href='socket.reqmts.protocol'>[socket.reqmts.protocol]</a>), <span class='texttt'>Endpoint</span> (<a href='socket.reqmts.endpoint'>[socket.reqmts.endpoint]</a>), <span class='texttt'>SettableSocketOption</span> (<a href='socket.reqmts.settablesocketoption'>[socket.reqmts.settablesocketoption]</a>), <span class='texttt'>GettableSocketOption</span> (<a href='socket.reqmts.gettablesocketoption'>[socket.reqmts.gettablesocketoption]</a>) or <span class='texttt'>IoControlCommand</span> (<a href='socket.reqmts.iocontrolcommand'>[socket.reqmts.iocontrolcommand]</a>) requirements.</p></div><div class='para' id='conformance.conditional-2'><div class='marginalizedparent'><a class='marginalized' href='#conformance.conditional-2'>2</a></div><p >[&nbsp;<i>Note:</i> This is so that, when the additional member functions are available, C++ programs may extend the library to add support for other protocols and socket options. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='conformance.conditional-3'><div class='marginalizedparent'><a class='marginalized' href='#conformance.conditional-3'>3</a></div><p >For the purposes of this Technical Specification, implementations that provide all of the additional member functions are known as extensible implementations.</p></div><div class='para' id='conformance.conditional-4'><div class='marginalizedparent'><a class='marginalized' href='#conformance.conditional-4'>4</a></div><p >[&nbsp;<i>Note:</i> Implementations are encouraged to provide the additional member functions, where possible. It is intended that POSIX and Windows implementations will provide them. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='intro.ack'><h2 ><a class='secnum' href='#intro.ack' style='min-width:88pt'>4.2</a> Acknowledgments <a class='abbr_ref' href='intro.ack'>[intro.ack]</a></h2><div class='para' id='intro.ack-1'><div class='marginalizedparent'><a class='marginalized' href='#intro.ack-1'>1</a></div><p >The design of this specification is based, in part, on the Asio library
written by Christopher Kohlhoff.</p></div></div></div><div id='namespaces'><h1 ><a class='secnum' href='#namespaces' style='min-width:73pt'>5</a> Namespaces and headers <a class='abbr_ref' href='./#namespaces'>[namespaces]</a></h1><div class='para' id='namespaces-1'><div class='marginalizedparent'><a class='marginalized' href='#namespaces-1'>1</a></div><p >The components described in this Technical Specification are experimental and not part of the C++ standard library. All components described in this Technical Specification are declared in namespace <span class='texttt'>std::experimental::net::v1</span> or a sub-namespace thereof unless otherwise specified. The headers described in this technical specification shall import the contents of <span class='texttt'>std::experimental::net::v1</span> into <span class='texttt'>std::experimental::net</span> as if by:</p><pre class='codeblock'>
namespace std {
  namespace experimental {
    namespace net {
      inline namespace v1 {}
    }
  }
}
</pre></div><div class='para' id='namespaces-2'><div class='marginalizedparent'><a class='marginalized' href='#namespaces-2'>2</a></div><p >Unless otherwise specified, references to other entities described in this Technical Specification are assumed to be qualified with <span class='texttt'>std::experimental::net::v1::</span>, references to entities described in the C++ standard are assumed to be qualified with <span class='texttt'>std::</span>, and references to entities described in C++ Extensions for Library Fundamentals are assumed to be qualified with <span class='texttt'>std::experimental::fundamentals_v1::</span>.</p></div></div><div id='plans'><h1 ><a class='secnum' href='#plans' style='min-width:73pt'>6</a> Future plans (Informative) <a class='abbr_ref' href='./#plans'>[plans]</a></h1><div class='para' id='plans-1'><div class='marginalizedparent'><a class='marginalized' href='#plans-1'>1</a></div><p >This section describes tentative plans for future versions of this technical
specification and plans for moving content into future versions of the C++
Standard.</p></div><div class='para' id='plans-2'><div class='marginalizedparent'><a class='marginalized' href='#plans-2'>2</a></div><p >The C++ committee may release new versions of this technical specification,
containing networking library extensions we hope to add to a near-future
version of the C++ Standard. Future versions will define their contents
in <span class='texttt'>std::experimental::net::v2</span>, <span class='texttt'>std::experimental::net::v3</span>,
etc., with the most recent implemented version inlined into
<span class='texttt'>std::experimental::net</span>.</p></div><div class='para' id='plans-3'><div class='marginalizedparent'><a class='marginalized' href='#plans-3'>3</a></div><p >When an extension defined in this or a future version of this technical
specification represents enough existing practice, it will be moved into
the next version of the C++ Standard by replacing the
<span class='texttt'>experimental::net::v<i>N</i></span> segment of its namespace with <span class='texttt'>net</span>,
and by removing the <span class='texttt'>experimental/</span> prefix from its header's path.</p></div></div><div id='feature.test'><h1 ><a class='secnum' href='#feature.test' style='min-width:73pt'>7</a> Feature test macros (Informative) <a class='abbr_ref' href='./#feature.test'>[feature.test]</a></h1><div class='para' id='feature.test-1'><div class='marginalizedparent'><a class='marginalized' href='#feature.test-1'>1</a></div><p >These macros allow users to determine which version of this Technical Specification is supported by the headers defined by the specification. All headers in this Technical Specification shall define the <span class='texttt'>__cpp_lib_experimental_net</span> feature test macro in Table <a href='feature.test#tab:info.features'>[tab:info.features]</a>.</p></div><div class='para' id='feature.test-2'><div class='marginalizedparent'><a class='marginalized' href='#feature.test-2'>2</a></div><p >If an implementation supplies all of the conditionally-supported features specified in <a href='conformance.conditional'>[conformance.conditional]</a>, all headers in this Technical Specification shall additionally define the <span class='texttt'>__cpp_lib_experimental_net_extensible</span> feature test macro.</p><div class='numberedTable' id='tab:info.features'>Table <a href='#tab:info.features'>1</a> — Feature-test macro(s)<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Macro name</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'>

<span class='texttt'>__cpp_lib_experimental_net</span>  </td><td class='left'> <span class='texttt'>201703</span>      </td></tr><tr ><td class='left'>
<span class='texttt'>__cpp_lib_experimental_net_extensible</span>  </td><td class='left'> <span class='texttt'>201703</span>      </td></tr></table></div></div></div><div id='description'><h1 ><a class='secnum' href='#description' style='min-width:73pt'>8</a> Method of description (Informative) <a class='abbr_ref' href='./#description'>[description]</a></h1><div class='para' id='description-1'><div class='marginalizedparent'><a class='marginalized' href='#description-1'>1</a></div><p >This sub-clause describes the conventions used to specify this Technical Specification, in addition to those conventions specified in C++Std &sect;<a href='../n4140/description'>[description]</a>.</p></div><div id='structure'><h2 ><a class='secnum' href='#structure' style='min-width:88pt'>8.1</a> Structure of each clause <a class='abbr_ref' href='structure'>[structure]</a></h2><div id='structure.specifications'><h3 ><a class='secnum' href='#structure.specifications' style='min-width:103pt'>8.1.1</a> Detailed specifications <a class='abbr_ref' href='structure.specifications'>[structure.specifications]</a></h3><div class='para' id='structure.specifications-1'><div class='marginalizedparent'><a class='marginalized' href='#structure.specifications-1'>1</a></div><p >In addition to the elements defined in C++Std &sect;<a href='../n4140/structure.specifications'>[structure.specifications]</a>, descriptions of function semantics contain the following elements (as appropriate):</p><ul class='itemize'><li id='structure.specifications-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#structure.specifications-1.1'>(1.1)</a></div><p ><i>Completion signature:</i> if the function initiates an asynchronous operation, specifies the signature of a completion handler used to receive the result of the operation.
</p></li></ul></div></div></div><div id='conventions'><h2 ><a class='secnum' href='#conventions' style='min-width:88pt'>8.2</a> Other conventions <a class='abbr_ref' href='conventions'>[conventions]</a></h2><div id='nested.class'><h3 ><a class='secnum' href='#nested.class' style='min-width:103pt'>8.2.1</a> Nested classes <a class='abbr_ref' href='nested.class'>[nested.class]</a></h3><div class='para' id='nested.class-1'><div class='marginalizedparent'><a class='marginalized' href='#nested.class-1'>1</a></div><p >Several classes defined in this Technical Specification are nested classes.
For a specified nested class <span class='texttt'>A::B</span>, an implementation is permitted to
define <span class='texttt'>A::B</span> as a synonym for a class with equivalent functionality to
class <span class='texttt'>A::B</span>. [&nbsp;<i>Note:</i> When <span class='texttt'>A::B</span> is a synonym for another
type <span class='texttt'>A</span> shall provide a nested type <span class='texttt'>B</span>, to emulate the injected
class name. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div></div><div id='err.report'><h1 ><a class='secnum' href='#err.report' style='min-width:73pt'>9</a> Error reporting <a class='abbr_ref' href='./#err.report'>[err.report]</a></h1><div id='err.report.sync'><h2 ><a class='secnum' href='#err.report.sync' style='min-width:88pt'>9.1</a> Synchronous operations <a class='abbr_ref' href='err.report.sync'>[err.report.sync]</a></h2><div class='para' id='err.report.sync-1'><div class='marginalizedparent'><a class='marginalized' href='#err.report.sync-1'>1</a></div><p >Most synchronous network library functions provide two overloads, one that throws an exception to report system errors, and another that sets an <span class='texttt'>error_code</span> (C++Std &sect;<a href='../n4140/syserr'>[syserr]</a>).</p><p >[&nbsp;<i>Note:</i> This supports two common use cases:
</p><ul class='itemize'><li id='err.report.sync-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#err.report.sync-1.1'>(1.1)</a></div><p >Uses where system errors are truly exceptional and indicate a serious failure. Throwing an exception is the most appropriate response.
</p></li><li id='err.report.sync-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#err.report.sync-1.2'>(1.2)</a></div><p >Uses where system errors are routine and do not necessarily represent failure. Returning an error code is the most appropriate response. This allows application specific error handling, including simply ignoring the error.
</p></li></ul><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='err.report.sync-2'><div class='marginalizedparent'><a class='marginalized' href='#err.report.sync-2'>2</a></div><p >Functions not having an argument of type <span class='texttt'>error_code&amp;</span> report errors as follows, unless otherwise specified:</p><ul class='itemize'><li id='err.report.sync-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#err.report.sync-2.1'>(2.1)</a></div><p >When a call by the implementation to an operating system or other underlying API results in an error that prevents the function from meeting its specifications, the function exits via an exception of a type that would match a handler of type <span class='texttt'>system_error</span>.</p></li><li id='err.report.sync-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#err.report.sync-2.2'>(2.2)</a></div><p >Destructors throw nothing.
</p></li></ul></div><div class='para' id='err.report.sync-3'><div class='marginalizedparent'><a class='marginalized' href='#err.report.sync-3'>3</a></div><p >Functions having an argument of type <span class='texttt'>error_code&amp;</span> report errors as follows, unless otherwise specified:</p><ul class='itemize'><li id='err.report.sync-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#err.report.sync-3.1'>(3.1)</a></div><p >If a call by the implementation to an operating system or other underlying API results in an error that prevents the function from meeting its specifications, the <span class='texttt'>error_code&amp;</span> argument <span class='texttt'>ec</span> is set as appropriate for the specific error. Otherwise, the <span class='texttt'>ec</span> argument is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>.
</p></li></ul></div><div class='para' id='err.report.sync-4'><div class='marginalizedparent'><a class='marginalized' href='#err.report.sync-4'>4</a></div><p >Where a function is specified as two overloads, with and without an argument of type <span class='texttt'>error_code&amp;</span>:</p><pre class='codeblock'>
<i>R f</i>(<i>A1</i> a1, <i>A2</i> a2, ..., <i>AN</i> aN);
<i>R f</i>(<i>A1</i> a1, <i>A2</i> a2, ..., <i>AN</i> aN, error_code&amp; ec);
</pre></div><div class='para' id='err.report.sync-5'><div class='marginalizedparent'><a class='marginalized' href='#err.report.sync-5'>5</a></div><p >then, when R is non-<span class='texttt'>void</span>, the effects of the first overload are as if:</p><pre class='codeblock'>
error_code ec;
<i>R</i> r(<i>f</i>(a1, a2, ..., aN, ec));
if (ec) throw system_error(ec, S);
return r;
</pre></div><div class='para' id='err.report.sync-6'><div class='marginalizedparent'><a class='marginalized' href='#err.report.sync-6'>6</a></div><p >otherwise, when R is <span class='texttt'>void</span>, the effects of the first overload are as if:</p><pre class='codeblock'>
error_code ec;
<i>f</i>(a1, a2, ..., aN, ec);
if (ec) throw system_error(ec, S);
</pre></div><div class='para' id='err.report.sync-7'><div class='marginalizedparent'><a class='marginalized' href='#err.report.sync-7'>7</a></div><p >except that the type thrown may differ as specified above. <span class='texttt'>S</span> is an <span class='textsc'>ntbs</span> indicating where the exception was thrown. [&nbsp;<i>Note:</i> A possible value for <span class='texttt'>S</span> is <span class='texttt'>__func__</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='err.report.sync-8'><div class='marginalizedparent'><a class='marginalized' href='#err.report.sync-8'>8</a></div><p >For both overloads, failure to allocate storage is reported by throwing an exception as described in the C++ standard (C++Std &sect;<a href='../n4140/res.on.exception.handling'>[res.on.exception.handling]</a>).</p></div><div class='para' id='err.report.sync-9'><div class='marginalizedparent'><a class='marginalized' href='#err.report.sync-9'>9</a></div><p >In this Technical Specification, when a type requirement is specified using two function call expressions <i>f</i>, with and without an argument <span class='texttt'>ec</span> of type <span class='texttt'>error_code</span>:</p><pre class='codeblock'>
<i>f</i>(a1, a2, ..., aN)
<i>f</i>(a1, a2, ..., aN, ec)
</pre><p >then the effects of the first call expression of <i>f</i> shall be as described for the first overload above.</p></div></div><div id='err.report.async'><h2 ><a class='secnum' href='#err.report.async' style='min-width:88pt'>9.2</a> Asynchronous operations <a class='abbr_ref' href='err.report.async'>[err.report.async]</a></h2><div class='para' id='err.report.async-1'><div class='marginalizedparent'><a class='marginalized' href='#err.report.async-1'>1</a></div><p >Asynchronous network library functions in this Technical Specification are identified by having the prefix <span class='texttt'>async_</span> and take a completion handler <a href='async.reqmts.async.token'>[async.reqmts.async.token]</a>. These asynchronous operations report errors as follows:</p><ul class='itemize'><li id='err.report.async-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#err.report.async-1.1'>(1.1)</a></div><p >If a call by the implementation to an operating system or other underlying API results in an error that prevents the asynchronous operation from meeting its specifications, the completion handler is invoked with an <span class='texttt'>error_code</span> value <span class='texttt'>ec</span> that is set as appropriate for the specific error. Otherwise, the <span class='texttt'>error_code</span> value <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>.</p></li><li id='err.report.async-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#err.report.async-1.2'>(1.2)</a></div><p >Asynchronous operations shall not fail with an error condition that indicates interruption of an operating system or underlying API by a signal. [&nbsp;<i>Note:</i> Such as POSIX error number <span class='texttt'>EINTR</span> <i>&nbsp;—&nbsp;end note</i>&nbsp;] Asynchronous operations shall not fail with any error condition associated with non-blocking operations. [&nbsp;<i>Note:</i> Such as POSIX error numbers <span class='texttt'>EWOULDBLOCK</span>, <span class='texttt'>EAGAIN</span>, or <span class='texttt'>EINPROGRESS</span>; Windows error numbers <span class='texttt'>WSAEWOULDBLOCK</span> or <span class='texttt'>WSAEINPROGRESS</span> <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div><div class='para' id='err.report.async-2'><div class='marginalizedparent'><a class='marginalized' href='#err.report.async-2'>2</a></div><p >In this Technical Specification, when a type requirement is specified as a call to a function or member function having the prefix <span class='texttt'>async_</span>, then the function shall satisfy the error reporting requirements described above.</p></div></div><div id='err.report.conditions'><h2 ><a class='secnum' href='#err.report.conditions' style='min-width:88pt'>9.3</a> Error conditions <a class='abbr_ref' href='err.report.conditions'>[err.report.conditions]</a></h2><div class='para' id='err.report.conditions-1'><div class='marginalizedparent'><a class='marginalized' href='#err.report.conditions-1'>1</a></div><p >Unless otherwise specified, when the behavior of a synchronous or asynchronous operation is defined “as if” implemented by a POSIX function, the <span class='texttt'>error_code</span> produced by the function shall meet the following requirements:</p><ul class='itemize'><li id='err.report.conditions-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#err.report.conditions-1.1'>(1.1)</a></div><p >If the failure condition is one that is listed by POSIX for that function, the <span class='texttt'>error_code</span> shall compare equal to the error's corresponding <span class='texttt'>enum class errc</span> (C++Std &sect;<a href='../n4140/syserr'>[syserr]</a>) or <span class='texttt'>enum class resolver_errc</span> (<a href='internet.resolver.err'>[internet.resolver.err]</a>) constant.</p></li><li id='err.report.conditions-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#err.report.conditions-1.2'>(1.2)</a></div><p >Otherwise, the <span class='texttt'>error_code</span> shall be set to an implementation-defined value that reflects the underlying operating system error.
</p></li></ul></div><div class='para' id='err.report.conditions-2'><div class='marginalizedparent'><a class='marginalized' href='#err.report.conditions-2'>2</a></div><p >[&nbsp;<i>Example:</i> The POSIX specification for <span class='texttt'>shutdown</span> lists <span class='texttt'>EBADF</span> as one of its possible errors. If a function that is specified “as if” implemented by <span class='texttt'>shutdown</span> fails with <span class='texttt'>EBADF</span> then the following condition holds for the <span class='texttt'>error_code</span> value <span class='texttt'>ec</span>: <span class='texttt'>ec == errc::bad_file_descriptor</span> <i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='err.report.conditions-3'><div class='marginalizedparent'><a class='marginalized' href='#err.report.conditions-3'>3</a></div><p >When the description of a function contains the element Error conditions, this lists conditions where the operation may fail. The conditions are listed, together with a suitable explanation, as <span class='texttt'>enum class</span> constants. Unless otherwise specified, this list is a subset of the failure conditions associated with the function.</p></div></div><div id='err.report.signal'><h2 ><a class='secnum' href='#err.report.signal' style='min-width:88pt'>9.4</a> Suppression of signals <a class='abbr_ref' href='err.report.signal'>[err.report.signal]</a></h2><div class='para' id='err.report.signal-1'><div class='marginalizedparent'><a class='marginalized' href='#err.report.signal-1'>1</a></div><p >Some POSIX functions referred to in this Technical Specification may report errors by raising a <span class='texttt'>SIGPIPE</span> signal. Where a synchronous or asynchronous operation is specified in terms of these POSIX functions, the generation of <span class='texttt'>SIGPIPE</span> is suppressed and an error condition corresponding to POSIX <span class='texttt'>EPIPE</span> is produced instead.</p></div></div></div><div id='summary'><h1 ><a class='secnum' href='#summary' style='min-width:73pt'>10</a> Library summary <a class='abbr_ref' href='./#summary'>[summary]</a></h1><div class='numberedTable' id='tab:summary'>Table <a href='#tab:summary'>2</a> — Networking library summary<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Clause</b></td><td colspan='1' class='center'><b>Header(s)</b></td></tr><tr class='capsep'><td class='left'> 
Convenience header (<a href='convenience.hdr'>[convenience.hdr]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/net&gt;</span>  </td></tr><tr class='rowsep'><td class='left'> Forward declarations (<a href='fwd.decl'>[fwd.decl]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/netfwd&gt;</span>  </td></tr><tr class='rowsep'><td class='left'> Asynchronous model (<a href='async'>[async]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/executor&gt;</span>  </td></tr><tr class='rowsep'><td class='left'> Basic I/O services (<a href='io_context'>[io_context]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/io_context&gt;</span>  </td></tr><tr class='rowsep'><td class='left'> Timers (<a href='timer'>[timer]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/timer&gt;</span>  </td></tr><tr class='rowsep'><td class='left'> Buffers (<a href='buffer'>[buffer]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/buffer&gt;</span>  </td></tr><tr ><td class='left'>
Buffer-oriented streams (<a href='buffer.stream'>[buffer.stream]</a>)  </td><td class='left'>
 </td></tr><tr class='rowsep'><td class='left'> Sockets (<a href='socket'>[socket]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/socket&gt;</span>  </td></tr><tr ><td class='left'>
Socket iostreams (<a href='socket.iostreams'>[socket.iostreams]</a>)  </td><td class='left'>
 </td></tr><tr ><td class='left'>
Socket algorithms (<a href='socket.algo'>[socket.algo]</a>)  </td><td class='left'>
 </td></tr><tr class='rowsep'><td class='left'> Internet protocol (<a href='internet'>[internet]</a>)  </td><td class='left'>
<span class='texttt'>&lt;experimental/internet&gt;</span>  </td></tr></table></div><div class='para' id='summary-1'><div class='marginalizedparent'><a class='marginalized' href='#summary-1'>1</a></div><p >Throughout this Technical Specification, the names of the template parameters are used to express type requirements, as listed in Table <a href='summary#tab:summary.requirements'>[tab:summary.requirements]</a>.</p><div class='numberedTable' id='tab:summary.requirements'>Table <a href='#tab:summary.requirements'>3</a> — Template parameters and type requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>template parameter name</b></td><td colspan='1' class='center'><b>type requirements</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>AcceptableProtocol</span>  </td><td class='left'>
acceptable protocol (<a href='socket.reqmts.acceptableprotocol'>[socket.reqmts.acceptableprotocol]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>Allocator</span>  </td><td class='left'>
 C++Std &sect;<a href='../n4140/allocator.requirements'>[allocator.requirements]</a>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>AsyncReadStream</span>  </td><td class='left'>
buffer-oriented asynchronous read stream (<a href='buffer.stream.reqmts.asyncreadstream'>[buffer.stream.reqmts.asyncreadstream]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>AsyncWriteStream</span>  </td><td class='left'>
buffer-oriented asynchronous write stream (<a href='buffer.stream.reqmts.asyncwritestream'>[buffer.stream.reqmts.asyncwritestream]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>Clock</span>  </td><td class='left'>
 C++Std &sect;<a href='../n4140/time.clock.req'>[time.clock.req]</a>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>CompletionCondition</span>  </td><td class='left'>
completion condition (<a href='buffer.stream.reqmts.completioncondition'>[buffer.stream.reqmts.completioncondition]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>CompletionToken</span>  </td><td class='left'>
completion token (<a href='async.reqmts.async.token'>[async.reqmts.async.token]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ConnectCondition</span>  </td><td class='left'>
connect condition (<a href='socket.reqmts.connectcondition'>[socket.reqmts.connectcondition]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ConstBufferSequence</span>  </td><td class='left'>
constant buffer sequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>DynamicBuffer</span>  </td><td class='left'>
dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>EndpointSequence</span>  </td><td class='left'>
endpoint sequence (<a href='socket.reqmts.endpointsequence'>[socket.reqmts.endpointsequence]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ExecutionContext</span>  </td><td class='left'>
execution context (<a href='async.reqmts.executioncontext'>[async.reqmts.executioncontext]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>Executor</span>  </td><td class='left'>
executor (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>GettableSocketOption</span>  </td><td class='left'>
gettable socket option (<a href='socket.reqmts.gettablesocketoption'>[socket.reqmts.gettablesocketoption]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>InternetProtocol</span>  </td><td class='left'>
Internet protocol (<a href='internet.reqmts.protocol'>[internet.reqmts.protocol]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>IoControlCommand</span>  </td><td class='left'>
I/O control command (<a href='socket.reqmts.iocontrolcommand'>[socket.reqmts.iocontrolcommand]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>MutableBufferSequence</span>  </td><td class='left'>
mutable buffer sequence (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ProtoAllocator</span>  </td><td class='left'>
proto-allocator (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>Protocol</span>  </td><td class='left'>
protocol (<a href='socket.reqmts.protocol'>[socket.reqmts.protocol]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>Service</span>  </td><td class='left'>
service (<a href='async.reqmts.service'>[async.reqmts.service]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>SettableSocketOption</span>  </td><td class='left'>
settable socket option (<a href='socket.reqmts.settablesocketoption'>[socket.reqmts.settablesocketoption]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>Signature</span>  </td><td class='left'>
signature (<a href='async.reqmts.signature'>[async.reqmts.signature]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>SyncReadStream</span>  </td><td class='left'>
buffer-oriented synchronous read stream (<a href='buffer.stream.reqmts.syncreadstream'>[buffer.stream.reqmts.syncreadstream]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>SyncWriteStream</span>  </td><td class='left'>
buffer-oriented synchronous write stream (<a href='buffer.stream.reqmts.syncwritestream'>[buffer.stream.reqmts.syncwritestream]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>WaitTraits</span>  </td><td class='left'>
wait traits (<a href='timer.reqmts.waittraits'>[timer.reqmts.waittraits]</a>)  </td></tr></table></div></div></div><div id='convenience.hdr'><h1 ><a class='secnum' href='#convenience.hdr' style='min-width:73pt'>11</a> Convenience header <a class='abbr_ref' href='./#convenience.hdr'>[convenience.hdr]</a></h1><p ><span class='indexparent'><a class='index' id='experimental/net'></a></span></p><div id='convenience.hdr.synop'><h2 ><a class='secnum' href='#convenience.hdr.synop' style='min-width:88pt'>11.1</a> Header <span class='texttt'>&lt;experimental/net&gt;</span> synopsis <a class='abbr_ref' href='convenience.hdr.synop'>[convenience.hdr.synop]</a></h2><pre class='codeblock'>
#include &lt;experimental/executor&gt;
#include &lt;experimental/io_context&gt;
#include &lt;experimental/timer&gt;
#include &lt;experimental/buffer&gt;
#include &lt;experimental/socket&gt;
#include &lt;experimental/internet&gt;
</pre><div class='para' id='convenience.hdr.synop-1'><div class='marginalizedparent'><a class='marginalized' href='#convenience.hdr.synop-1'>1</a></div><p >[&nbsp;<i>Note:</i> This header is provided as a convenience for programs so that they may access all networking facilities via a single, self-contained <span class='texttt'>#include</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='fwd.decl'><h1 ><a class='secnum' href='#fwd.decl' style='min-width:73pt'>12</a> Forward declarations <a class='abbr_ref' href='./#fwd.decl'>[fwd.decl]</a></h1><p ><span class='indexparent'><a class='index' id='experimental/netfwd'></a></span></p><div id='fwd.decl.synop'><h2 ><a class='secnum' href='#fwd.decl.synop' style='min-width:88pt'>12.1</a> Header <span class='texttt'>&lt;experimental/netfwd&gt;</span> synopsis <a class='abbr_ref' href='fwd.decl.synop'>[fwd.decl.synop]</a></h2><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class execution_context;
  template&lt;class T, class Executor&gt;
    class executor_binder;
  template&lt;class Executor&gt;
    class executor_work_guard;
  class system_executor;
  class executor;
  template&lt;class Executor&gt;
    class strand;

  class io_context;

  template&lt;class Clock&gt; struct wait_traits;
  template&lt;class Clock, class WaitTraits = wait_traits&lt;Clock&gt;&gt;
    class basic_waitable_timer;
  using system_timer = basic_waitable_timer&lt;chrono::system_clock&gt;;
  using steady_timer = basic_waitable_timer&lt;chrono::steady_clock&gt;;
  using high_resolution_timer = basic_waitable_timer&lt;chrono::high_resolution_clock&gt;;

  template&lt;class Protocol&gt;
    class basic_socket;
  template&lt;class Protocol&gt;
    class basic_datagram_socket;
  template&lt;class Protocol&gt;
    class basic_stream_socket;
  template&lt;class Protocol&gt;
    class basic_socket_acceptor;
  template&lt;class Protocol, class Clock = chrono::steady_clock,
    class WaitTraits = wait_traits&lt;Clock&gt;&gt;
      class basic_socket_streambuf;
  template&lt;class Protocol, class Clock = chrono::steady_clock,
    class WaitTraits = wait_traits&lt;Clock&gt;&gt;
      class basic_socket_iostream;

  namespace ip {

    class address;
    class address_v4;
    class address_v6;
    template&lt;class Address&gt;
      class basic_address_iterator;
    using address_v4_iterator = basic_address_iterator&lt;address_v4&gt;;
    using address_v6_iterator = basic_address_iterator&lt;address_v6&gt;;
    template&lt;class Address&gt;
      class basic_address_range;
    using address_v4_range = basic_address_range&lt;address_v4&gt;;
    using address_v6_range = basic_address_range&lt;address_v6&gt;;
    class network_v4;
    class network_v6;
    template&lt;class InternetProtocol&gt;
      class basic_endpoint;
    template&lt;class InternetProtocol&gt;
      class basic_resolver_entry;
    template&lt;class InternetProtocol&gt;
      class basic_resolver_results;
    template&lt;class InternetProtocol&gt;
      class basic_resolver;
    class tcp;
    class udp;

  } <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='fwd.decl.synop-1'><div class='marginalizedparent'><a class='marginalized' href='#fwd.decl.synop-1'>1</a></div><p >Default template arguments are described as appearing both in <span class='texttt'>&lt;netfwd&gt;</span>
and in the synopsis of other headers but it is well-formed to include both
<span class='texttt'>&lt;netfwd&gt;</span> and one or more of the other headers.
[&nbsp;<i>Note:</i> It is the implementation's responsibility to implement headers so
that including <span class='texttt'>&lt;netfwd&gt;</span> and other headers does not violate the rules
about multiple occurrences of default arguments. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='async'><h1 ><a class='secnum' href='#async' style='min-width:73pt'>13</a> Asynchronous model <a class='abbr_ref' href='./#async'>[async]</a></h1><p ><span class='indexparent'><a class='index' id='experimental/executor'></a></span></p><div id='async.synop'><h2 ><a class='secnum' href='#async.synop' style='min-width:88pt'>13.1</a> Header <span class='texttt'>&lt;experimental/executor&gt;</span> synopsis <a class='abbr_ref' href='async.synop'>[async.synop]</a></h2><p ><span class='indexparent'><a class='index' id='is_executor_v'></a></span><span class='indexparent'><a class='index' id='uses_executor_v'></a></span><span class='indexparent'><a class='index' id='associated_allocator_t'></a></span><span class='indexparent'><a class='index' id='associated_executor_t'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class CompletionToken, class Signature&gt;
    class async_result;

  template&lt;class CompletionToken, class Signature&gt;
    struct async_completion;

  template&lt;class T, class ProtoAllocator = allocator&lt;void&gt;&gt;
    struct associated_allocator;

  template&lt;class T, class ProtoAllocator = allocator&lt;void&gt;&gt;
    using associated_allocator_t = typename associated_allocator&lt;T, ProtoAllocator&gt;::type;

  <span class='comment'>// get_associated_allocator:
</span>
  template&lt;class T&gt;
    associated_allocator_t&lt;T&gt; get_associated_allocator(const T&amp; t) noexcept;
  template&lt;class T, class ProtoAllocator&gt;
    associated_allocator_t&lt;T, ProtoAllocator&gt;
      get_associated_allocator(const T&amp; t, const ProtoAllocator&amp; a) noexcept;

  enum class fork_event {
    prepare,
    parent,
    child
  };

  class execution_context;

  class service_already_exists;

  template&lt;class Service&gt; Service&amp; use_service(execution_context&amp; ctx);
  template&lt;class Service, class... Args&gt; Service&amp;
    make_service(execution_context&amp; ctx, Args&amp;&amp;... args);
  template&lt;class Service&gt; bool has_service(execution_context&amp; ctx) noexcept;

  template&lt;class T&gt; struct is_executor;

  template&lt;class T&gt;
    constexpr bool is_executor_v = is_executor&lt;T&gt;::value;

  struct executor_arg_t { };
  constexpr executor_arg_t executor_arg = executor_arg_t();

  template&lt;class T, class Executor&gt; struct uses_executor;

  template&lt;class T, class Executor&gt;
    constexpr bool uses_executor_v = uses_executor&lt;T, Executor&gt;::value;

  template&lt;class T, class Executor = system_executor&gt;
    struct associated_executor;

  template&lt;class T, class Executor = system_executor&gt;
    using associated_executor_t = typename associated_executor&lt;T, Executor&gt;::type;

  <span class='comment'>// get_associated_executor:
</span>
  template&lt;class T&gt;
    associated_executor_t&lt;T&gt; get_associated_executor(const T&amp; t) noexcept;
  template&lt;class T, class Executor&gt;
    associated_executor_t&lt;T, Executor&gt;
      get_associated_executor(const T&amp; t, const Executor&amp; ex) noexcept;
  template&lt;class T, class ExecutionContext&gt;
    associated_executor_t&lt;T, typename ExecutionContext::executor_type&gt;
      get_associated_executor(const T&amp; t, ExecutionContext&amp; ctx) noexcept;

  template&lt;class T, class Executor&gt;
    class executor_binder;

  template&lt;class T, class Executor, class Signature&gt;
    class async_result&lt;executor_binder&lt;T, Executor&gt;, Signature&gt;;

  template&lt;class T, class Executor, class ProtoAllocator&gt;
    struct associated_allocator&lt;executor_binder&lt;T, Executor&gt;, ProtoAllocator&gt;;

  template&lt;class T, class Executor, class Executor1&gt;
    struct associated_executor&lt;executor_binder&lt;T, Executor&gt;, Executor1&gt;;

  <span class='comment'>// bind_executor:
</span>
  template&lt;class Executor, class T&gt;
    executor_binder&lt;decay_t&lt;T&gt;, Executor&gt;
      bind_executor(const Executor&amp; ex, T&amp;&amp; t);
  template&lt;class ExecutionContext, class T&gt;
    executor_binder&lt;decay_t&lt;T&gt;, typename ExecutionContext::executor_type&gt;
      bind_executor(ExecutionContext&amp; ctx, T&amp;&amp; t);

  template&lt;class Executor&gt;
    class executor_work_guard;

  <span class='comment'>// make_work_guard:
</span>
  template&lt;class Executor&gt;
    executor_work_guard&lt;Executor&gt;
      make_work_guard(const Executor&amp; ex);
  template&lt;class ExecutionContext&gt;
    executor_work_guard&lt;typename ExecutionContext::executor_type&gt;
      make_work_guard(ExecutionContext&amp; ctx);
  template&lt;class T&gt;
    executor_work_guard&lt;associated_executor_t&lt;T&gt;&gt;
      make_work_guard(const T&amp; t);
  template&lt;class T, class U&gt;
    auto make_work_guard(const T&amp; t, U&amp;&amp; u)
      -&gt; decltype(make_work_guard(get_associated_executor(t, forward&lt;U&gt;(u))));

  class system_executor;
  class system_context;

  bool operator==(const system_executor&amp;, const system_executor&amp;);
  bool operator!=(const system_executor&amp;, const system_executor&amp;);

  class bad_executor;

  class executor;

  bool operator==(const executor&amp; a, const executor&amp; b) noexcept;
  bool operator==(const executor&amp; e, nullptr_t) noexcept;
  bool operator==(nullptr_t, const executor&amp; e) noexcept;
  bool operator!=(const executor&amp; a, const executor&amp; b) noexcept;
  bool operator!=(const executor&amp; e, nullptr_t) noexcept;
  bool operator!=(nullptr_t, const executor&amp; e) noexcept;

  <span class='comment'>// dispatch:
</span>
  template&lt;class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> dispatch(CompletionToken&amp;&amp; token);
  template&lt;class Executor, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> dispatch(const Executor&amp; ex, CompletionToken&amp;&amp; token);
  template&lt;class ExecutionContext, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> dispatch(ExecutionContext&amp; ctx, CompletionToken&amp;&amp; token);

  <span class='comment'>// post:
</span>
  template&lt;class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> post(CompletionToken&amp;&amp; token);
  template&lt;class Executor, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> post(const Executor&amp; ex, CompletionToken&amp;&amp; token);
  template&lt;class ExecutionContext, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> post(ExecutionContext&amp; ctx, CompletionToken&amp;&amp; token);

  <span class='comment'>// defer:
</span>
  template&lt;class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> defer(CompletionToken&amp;&amp; token);
  template&lt;class Executor, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> defer(const Executor&amp; ex, CompletionToken&amp;&amp; token);
  template&lt;class ExecutionContext, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> defer(ExecutionContext&amp; ctx, CompletionToken&amp;&amp; token);

  template&lt;class Executor&gt;
    class strand;

  template&lt;class Executor&gt;
    bool operator==(const strand&lt;Executor&gt;&amp; a, const strand&lt;Executor&gt;&amp; b);
  template&lt;class Executor&gt;
    bool operator!=(const strand&lt;Executor&gt;&amp; a, const strand&lt;Executor&gt;&amp; b);

  template&lt;class ProtoAllocator = allocator&lt;void&gt;&gt;
    class use_future_t;

  constexpr use_future_t&lt;&gt; use_future = use_future_t&lt;&gt;();

  template&lt;class ProtoAllocator, class Result, class... Args&gt;
    class async_result&lt;use_future_t&lt;ProtoAllocator&gt;, Result(Args...)&gt;;

  template&lt;class R, class... Args, class Signature&gt;
    class async_result&lt;packaged_task&lt;Result(Args...)&gt;, Signature&gt;;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>
  template&lt;class Allocator&gt;
    struct uses_allocator&lt;experimental::net::v1::executor, Allocator&gt;
      : true_type {};

} <span class='comment'>// namespace std
</span></pre></div><div id='async.reqmts'><h2 ><a class='secnum' href='#async.reqmts' style='min-width:88pt'>13.2</a> Requirements <a class='abbr_ref' href='async.reqmts'>[async.reqmts]</a></h2><div id='async.reqmts.proto.allocator'><h3 ><a class='secnum' href='#async.reqmts.proto.allocator' style='min-width:103pt'>13.2.1</a> Proto-allocator requirements <a class='abbr_ref' href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a></h3><div class='para' id='async.reqmts.proto.allocator-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.proto.allocator-1'>1</a></div><p >A type <span class='texttt'>A</span> meets the proto-allocator requirements if <span class='texttt'>A</span> is <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), and <span class='texttt'>allocator_traits&lt;A&gt;::rebind_alloc&lt;U&gt;</span> meets the allocator requirements (C++Std &sect;<a href='../n4140/allocator.requirements'>[allocator.requirements]</a>), where <span class='texttt'>U</span> is an object type. [&nbsp;<i>Note:</i> For example, <span class='texttt'>std::allocator&lt;void&gt;</span> meets the proto-allocator requirements but not the allocator requirements. <i>&nbsp;—&nbsp;end note</i>&nbsp;] No constructor, comparison operator, copy operation, move operation, or swap operation on these types shall exit via an exception.</p></div></div><div id='async.reqmts.executor'><h3 ><a class='secnum' href='#async.reqmts.executor' style='min-width:103pt'>13.2.2</a> Executor requirements <a class='abbr_ref' href='async.reqmts.executor'>[async.reqmts.executor]</a></h3><div class='para' id='async.reqmts.executor-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.executor-1'>1</a></div><p >The library describes a standard set of requirements for executors. A type meeting the <span class='texttt'>Executor</span> requirements embodies a set of rules for determining how submitted function objects are to be executed.</p></div><div class='para' id='async.reqmts.executor-2'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.executor-2'>2</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>Executor</span> requirements if it satisfies the requirements of <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>) and <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), as well as the additional requirements listed below.</p></div><div class='para' id='async.reqmts.executor-3'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.executor-3'>3</a></div><p >No constructor, comparison operator, copy operation, move operation, swap operation, or member functions <span class='texttt'>context</span>, <span class='texttt'>on_work_started</span>, and <span class='texttt'>on_work_finished</span> on these types shall exit via an exception.</p></div><div class='para' id='async.reqmts.executor-4'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.executor-4'>4</a></div><p >The executor copy constructor, comparison operators, and other member functions defined in these requirements shall not introduce data races as a result of concurrent calls to those functions from different threads.</p></div><div class='para' id='async.reqmts.executor-5'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.executor-5'>5</a></div><p >Let <span class='texttt'>ctx</span> be the execution context returned by the executor's <span class='texttt'>context()</span> member function. An executor becomes invalid when the first call to <span class='texttt'>ctx.shutdown()</span> returns. The effect of calling <span class='texttt'>on_work_started</span>, <span class='texttt'>on_work_finished</span>, <span class='texttt'>dispatch</span>, <span class='texttt'>post</span>, or <span class='texttt'>defer</span> on an invalid executor is undefined. [&nbsp;<i>Note:</i> The copy constructor, comparison operators, and <span class='texttt'>context()</span> member function continue to remain valid until <span class='texttt'>ctx</span> is destroyed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='async.reqmts.executor-6'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.executor-6'>6</a></div><p >In Table <a href='async.reqmts.executor#tab:async.reqmts.executor.requirements'>[tab:async.reqmts.executor.requirements]</a>,
<span class='texttt'>x1</span> and <span class='texttt'>x2</span> denote values of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>,
<span class='texttt'>mx1</span> denotes an xvalue of type <span class='texttt'>X</span>,
<span class='texttt'>f</span> denotes a <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>) function object callable with zero arguments,
<span class='texttt'>a</span> denotes a value of type <span class='texttt'>A</span> or <span class='texttt'>const A</span>
where <span class='texttt'>A</span> is a type meeting the <span class='texttt'>Allocator</span> requirements (C++Std &sect;<a href='../n4140/allocator.requirements'>[allocator.requirements]</a>),
and <span class='texttt'>u</span> denotes an identifier.</p><div class='numberedTable' id='tab:async.reqmts.executor.requirements'>Table <a href='#tab:async.reqmts.executor.requirements'>4</a> — Executor requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X u(x1);</span>  </td><td class='left'>
  </td><td class='left'>
Shall not exit via an exception.<br/><i>post:</i> <span class='texttt'>u == x1</span> and <span class='texttt'>std::addressof(u.context()) == std::addressof(x1.context()).</span>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(mx1);</span>  </td><td class='left'>
  </td><td class='left'>
Shall not exit via an exception.<br/><i>post:</i> <span class='texttt'>u</span> equals the prior value of <span class='texttt'>mx1</span> and <span class='texttt'>std::addressof(u.context())</span> equals the prior value of <span class='texttt'>std::addressof(mx1.context())</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1 == x2</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>true</span> only if <span class='texttt'>x1</span> and <span class='texttt'>x2</span> can be interchanged with identical effects in any of the expressions defined in these type requirements. [&nbsp;<i>Note:</i> Returning <span class='texttt'>false</span> does not necessarily imply that the effects are not identical. <i>&nbsp;—&nbsp;end note</i>&nbsp;]<br/><span class='texttt'>operator==</span> shall be reflexive, symmetric, and transitive, and shall not exit via an exception.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1 != x2</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
Same as <span class='texttt'>!(x1 == x2)</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.context()</span>  </td><td class='left'>
<span class='texttt'>execution_context&amp;</span>, or <span class='texttt'>E&amp;</span> where <span class='texttt'>E</span> is a type that satisfies the <span class='texttt'>ExecutionContext</span>  (<a href='async.reqmts.executioncontext'>[async.reqmts.executioncontext]</a>) requirements.  </td><td class='left'>
Shall not exit via an exception. The comparison operators and member functions defined in these requirements shall not alter the reference returned by this function.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.on_work_started()</span>  </td><td class='left'>
  </td><td class='left'>
 Shall not exit via an exception.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.on_work_finished()</span>  </td><td class='left'>
  </td><td class='left'>
Shall not exit via an exception. <br/><i>Precondition:</i> A preceding call <span class='texttt'>x2.on_work_started()</span> where <span class='texttt'>x1 == x2</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.dispatch(<br/><span class='mbox'>  </span>std::move(f), a)</span>  </td><td class='left'>
  </td><td class='left'>
<i>Effects:</i> Creates an object <span class='texttt'>f1</span> initialized with <span class='texttt'><i>DECAY_COPY</i>(forward&lt;Func&gt;(f))</span> (C++Std &sect;<a href='../n4140/thread.decaycopy'>[thread.decaycopy]</a>) in the current thread of execution. Calls <span class='texttt'>f1()</span> at most once. The executor may block forward progress of the caller until <span class='texttt'>f1()</span> finishes execution. Executor implementations should use the supplied allocator to allocate any memory required to store the function object. Prior to invoking the function object, the executor shall deallocate any memory allocated. [&nbsp;<i>Note:</i> Executors defined in this Technical Specification always use the supplied allocator unless otherwise specified. <i>&nbsp;—&nbsp;end note</i>&nbsp;] <br/>
<i>Synchronization:</i> The invocation of <span class='texttt'>dispatch</span> synchronizes with (C++Std &sect;<a href='../n4140/intro.multithread'>[intro.multithread]</a>) the invocation of <span class='texttt'>f1</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.post(std::move(f), a)</span><br/>
<span class='texttt'>x1.defer(std::move(f), a)</span>  </td><td class='left'>
  </td><td class='left'>
<i>Effects:</i> Creates an object <span class='texttt'>f1</span> initialized with <span class='texttt'><i>DECAY_COPY</i>(forward&lt;Func&gt;(f))</span> in the current thread of execution. Calls <span class='texttt'>f1()</span> at most once. The executor shall not block forward progress of the caller pending completion of <span class='texttt'>f1()</span>. Executor implementations should use the supplied allocator to allocate any memory required to store the function object. Prior to invoking the function object, the executor shall deallocate any memory allocated. [&nbsp;<i>Note:</i> Executors defined in this Technical Specification always use the supplied allocator unless otherwise specified. <i>&nbsp;—&nbsp;end note</i>&nbsp;]<br/>
<i>Synchronization:</i> The invocation of <span class='texttt'>post</span> or <span class='texttt'>defer</span> synchronizes with (C++Std &sect;<a href='../n4140/intro.multithread'>[intro.multithread]</a>) the invocation of <span class='texttt'>f1</span>. [&nbsp;<i>Note:</i> Although the requirements placed on <span class='texttt'>defer</span> are identical to <span class='texttt'>post</span>, the use of <span class='texttt'>post</span> conveys a preference that the caller does not block the first step of <span class='texttt'>f1</span>'s progress, whereas <span class='texttt'>defer</span> conveys a preference that the caller does block the first step of <span class='texttt'>f1</span>. One use of <span class='texttt'>defer</span> is to convey the intention of the caller that <span class='texttt'>f1</span> is a continuation of the current call context. The executor may use this information to optimize or otherwise adjust the way in which <span class='texttt'>f1</span> is invoked. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr></table></div></div></div><div id='async.reqmts.executioncontext'><h3 ><a class='secnum' href='#async.reqmts.executioncontext' style='min-width:103pt'>13.2.3</a> Execution context requirements <a class='abbr_ref' href='async.reqmts.executioncontext'>[async.reqmts.executioncontext]</a></h3><p ><span class='indexparent'><a class='index' id='execution_context'></a></span></p><div class='para' id='async.reqmts.executioncontext-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.executioncontext-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>ExecutionContext</span> requirements if it is publicly and unambiguously derived from <span class='texttt'>execution_context</span>, and satisfies the additional requirements listed below.</p></div><div class='para' id='async.reqmts.executioncontext-2'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.executioncontext-2'>2</a></div><p >In Table <a href='async.reqmts.executioncontext#tab:async.reqmts.executioncontext.requirements'>[tab:async.reqmts.executioncontext.requirements]</a>, <span class='texttt'>x</span> denotes a value of type <span class='texttt'>X</span>.</p><p ><span class='indexparent'><a class='index' id='requirements,ExecutionContext'></a></span><span class='indexparent'><a class='index' id='ExecutionContext'></a></span>
 
 
 </p><div class='numberedTable' id='tab:async.reqmts.executioncontext.requirements'>Table <a href='#tab:async.reqmts.executioncontext.requirements'>5</a> — ExecutionContext requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::executor_type</span>  </td><td class='left'>
type meeting <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) requirements  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.~X()</span>  </td><td class='left'>
  </td><td class='left'>
 Destroys all unexecuted function objects that were submitted via an executor object that is associated with the execution context.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.get_executor()</span>  </td><td class='left'>
<span class='texttt'>X::executor_type</span>  </td><td class='left'>
 Returns an executor object that is associated with the execution context.  </td></tr></table></div></div></div><div id='async.reqmts.service'><h3 ><a class='secnum' href='#async.reqmts.service' style='min-width:103pt'>13.2.4</a> Service requirements <a class='abbr_ref' href='async.reqmts.service'>[async.reqmts.service]</a></h3><p ><span class='indexparent'><a class='index' id='service'></a></span>
<span class='indexparent'><a class='index' id='execution_context::service'></a></span></p><div class='para' id='async.reqmts.service-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.service-1'>1</a></div><p >A class is a service if it is publicly and unambiguously derived from <span class='texttt'>execution_context::service</span>, or if it is publicly and unambiguously derived from another service. For a service <span class='texttt'>S</span>, <span class='texttt'>S::key_type</span> shall be valid and denote a type (C++Std &sect;<a href='../n4140/temp.deduct'>[temp.deduct]</a>), <span class='texttt'>is_base_of_v&lt;typename S::key_type, S&gt;</span> shall be <span class='texttt'>true</span>, and <span class='texttt'>S</span> shall satisfy the <span class='texttt'>Destructible</span> requirements (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>).</p></div><div class='para' id='async.reqmts.service-2'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.service-2'>2</a></div><p >The first parameter of all service constructors shall be an lvalue reference to <span class='texttt'>execution_context</span>. This parameter denotes the <span class='texttt'>execution_context</span> object that represents a set of services, of which the service object will be a member. [&nbsp;<i>Note:</i> These constructors may be called by the <span class='texttt'>make_service</span> function. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='async.reqmts.service-3'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.service-3'>3</a></div><p >A service shall provide an explicit constructor with a single parameter of lvalue reference to <span class='texttt'>execution_context</span>. [&nbsp;<i>Note:</i> This constructor may be called by the <span class='texttt'>use_service</span> function. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='async.reqmts.service-4'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.service-4'>4</a></div><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class my_service : public execution_context::service{
public:
  using key_type = my_service;
  explicit my_service(execution_context&amp; ctx);
  my_service(execution_context&amp; ctx, int some_value);
private:
  virtual void shutdown() noexcept override;
  ...
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='async.reqmts.service-5'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.service-5'>5</a></div><p >A service's <span class='texttt'>shutdown</span> member function shall destroy all copies of user-defined function objects that are held by the service.</p></div></div><div id='async.reqmts.signature'><h3 ><a class='secnum' href='#async.reqmts.signature' style='min-width:103pt'>13.2.5</a> Signature requirements <a class='abbr_ref' href='async.reqmts.signature'>[async.reqmts.signature]</a></h3><p ><span class='indexparent'><a class='index' id='requirements,signature'></a></span><span class='indexparent'><a class='index' id='signature_requirements'></a></span></p><div class='para' id='async.reqmts.signature-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.signature-1'>1</a></div><p >A type satisfies the signature requirements if it is a call signature (C++Std &sect;<a href='../n4140/func.def'>[func.def]</a>).</p></div></div><div id='async.reqmts.associator'><h3 ><a class='secnum' href='#async.reqmts.associator' style='min-width:103pt'>13.2.6</a> Associator requirements <a class='abbr_ref' href='async.reqmts.associator'>[async.reqmts.associator]</a></h3><p ><span class='indexparent'><a class='index' id='requirements,associator'></a></span><span class='indexparent'><a class='index' id='associator'></a></span></p><div class='para' id='async.reqmts.associator-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.associator-1'>1</a></div><p >An associator defines a relationship between different types and objects where, given:</p><ul class='itemize'><li id='async.reqmts.associator-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.associator-1.1'>(1.1)</a></div><p >a source object <span class='texttt'>s</span> of type <span class='texttt'>S</span>,</p></li><li id='async.reqmts.associator-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.associator-1.2'>(1.2)</a></div><p >type requirements <span class='texttt'>R</span>, and</p></li><li id='async.reqmts.associator-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.associator-1.3'>(1.3)</a></div><p >a candidate object <span class='texttt'>c</span> of type <span class='texttt'>C</span> meeting the type requirements <span class='texttt'>R</span>,
</p></li></ul><p >an associated type <span class='texttt'>A</span> meeting the type requirements <span class='texttt'>R</span> may be computed, and an associated object <span class='texttt'>a</span> of type <span class='texttt'>A</span> may be obtained.</p></div><div class='para' id='async.reqmts.associator-2'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.associator-2'>2</a></div><p >An associator shall be a class template that takes two template type arguments. The first template argument is the source type <span class='texttt'>S</span>. The second template argument is the candidate type <span class='texttt'>C</span>. The second template argument shall be defaulted to some default candidate type <span class='texttt'>D</span> that satisfies the type requirements <span class='texttt'>R</span>.</p></div><div class='para' id='async.reqmts.associator-3'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.associator-3'>3</a></div><p >An associator shall additionally satisfy the requirements in Table <a href='async.reqmts.associator#tab:async.reqmts.associator.requirements'>[tab:async.reqmts.associator.requirements]</a>.
In this table, <span class='texttt'>X</span> is a class template that meets the associator requirements,
<span class='texttt'>S</span> is the source type,
<span class='texttt'>s</span> is a value of type <span class='texttt'>S</span> or <span class='texttt'>const S</span>,
<span class='texttt'>C</span> is the candidate type,
<span class='texttt'>c</span> is a value of type <span class='texttt'>C</span> or <span class='texttt'>const C</span>,
<span class='texttt'>D</span> is the default candidate type,
and <span class='texttt'>d</span> is a value of type <span class='texttt'>D</span> or <span class='texttt'>const D</span> that is the default candidate object.</p><div class='numberedTable' id='tab:async.reqmts.associator.requirements'>Table <a href='#tab:async.reqmts.associator.requirements'>6</a> — Associator requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X&lt;S&gt;::type</span>  </td><td class='left'>
<span class='texttt'>X&lt;S, D&gt;::type</span>  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X&lt;S, C&gt;::type</span>  </td><td class='left'>
  </td><td class='left'>
 The associated type.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X&lt;S&gt;::get(s)</span>  </td><td class='left'>
<span class='texttt'>X&lt;S&gt;::type</span>  </td><td class='left'>
Returns <span class='texttt'>X&lt;S&gt;::get(S, d)</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X&lt;S, C&gt;::get(s, c)</span>  </td><td class='left'>
<span class='texttt'>X&lt;S, C&gt;::type</span>  </td><td class='left'>
 Returns the associated object.  </td></tr></table></div></div><div class='para' id='async.reqmts.associator-4'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.associator-4'>4</a></div><p >The associator's primary template shall be defined. A program may partially specialize the associator class template for some user-defined type <span class='texttt'>S</span>.</p></div><div class='para' id='async.reqmts.associator-5'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.associator-5'>5</a></div><p >Finally, the associator shall provide the following type alias and function template in the enclosing namespace:</p><pre class='codeblock'>
template&lt;class S, class C = D&gt; using <i>X</i>_t = typename <i>X</i>&lt;S, C&gt;::type;

template&lt;class S, class C = D&gt;
typename <i>X</i>&lt;S, C&gt;::type get_<i>X</i>(const S&amp; s, const C&amp; c = d){
  return <i>X</i>&lt;S, C&gt;::get(s, c);
}
</pre><p >where <span class='texttt'><i>X</i></span> is replaced with the name of the associator class template.
[&nbsp;<i>Note:</i> This function template is provided as a convenience, to automatically deduce the source and candidate types. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='async.reqmts.async'><h3 ><a class='secnum' href='#async.reqmts.async' style='min-width:103pt'>13.2.7</a> Requirements on asynchronous operations <a class='abbr_ref' href='async.reqmts.async'>[async.reqmts.async]</a></h3><div class='para' id='async.reqmts.async-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async-1'>1</a></div><p >This section uses the names <span class='texttt'>Alloc1</span>, <span class='texttt'>Alloc2</span>, <span class='texttt'>alloc1</span>, <span class='texttt'>alloc2</span>, <span class='texttt'>Args</span>, <span class='texttt'>CompletionHandler</span>, <span class='texttt'>completion_handler</span>, <span class='texttt'>Executor1</span>, <span class='texttt'>Executor2</span>, <span class='texttt'>ex1</span>, <span class='texttt'>ex2</span>, <span class='texttt'>f</span>, <i>i</i>, <i>N</i>, <span class='texttt'>Signature</span>, <span class='texttt'>token</span>, <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>, <span class='texttt'>t</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>, <span class='texttt'>work1</span>, and <span class='texttt'>work2</span> as placeholders for specifying the requirements below.</p></div><div id='async.reqmts.async.concepts'><h4 ><a class='secnum' href='#async.reqmts.async.concepts' style='min-width:118pt'>13.2.7.1</a> General asynchronous operation concepts <a class='abbr_ref' href='async.reqmts.async.concepts'>[async.reqmts.async.concepts]</a></h4><div class='para' id='async.reqmts.async.concepts-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.concepts-1'>1</a></div><p >An initiating function is a function which may be called to start an asynchronous operation. A completion handler is a function object that will be invoked, at most once, with the result of the asynchronous operation.</p></div><div class='para' id='async.reqmts.async.concepts-2'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.concepts-2'>2</a></div><p >The life cycle of an asynchronous operation is comprised of the following events and phases:</p><ul class='itemize'><li id='async.reqmts.async.concepts-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.concepts-2.1'>(2.1)</a></div><p >Event 1: The asynchronous operation is started by a call to the initiating function.</p></li><li id='async.reqmts.async.concepts-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.concepts-2.2'>(2.2)</a></div><p >Phase 1: The asynchronous operation is now outstanding.</p></li><li id='async.reqmts.async.concepts-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.concepts-2.3'>(2.3)</a></div><p >Event 2: The externally observable side effects of the asynchronous operation, if any, are fully established. The completion handler is submitted to an executor.</p></li><li id='async.reqmts.async.concepts-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.concepts-2.4'>(2.4)</a></div><p >Phase 2: The asynchronous operation is now completed.</p></li><li id='async.reqmts.async.concepts-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.concepts-2.5'>(2.5)</a></div><p >Event 3: The completion handler is called with the result of the asynchronous operation.
</p></li></ul></div><div class='para' id='async.reqmts.async.concepts-3'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.concepts-3'>3</a></div><p >In this Technical Specification, all functions with the prefix <span class='texttt'>async_</span> are initiating functions.</p></div></div><div id='async.reqmts.async.token'><h4 ><a class='secnum' href='#async.reqmts.async.token' style='min-width:118pt'>13.2.7.2</a> Completion tokens and handlers <a class='abbr_ref' href='async.reqmts.async.token'>[async.reqmts.async.token]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function'></a></span></p><div class='para' id='async.reqmts.async.token-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.token-1'>1</a></div><p >Initiating functions:</p><ul class='itemize'><li id='async.reqmts.async.token-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.token-1.1'>(1.1)</a></div><p >are function templates with template parameter <span class='texttt'>CompletionToken</span>;</p><p ><span class='indexparent'><a class='index' id='completion_token'></a></span></p></li><li id='async.reqmts.async.token-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.token-1.2'>(1.2)</a></div><p >accept, as the final parameter, a completion token object <span class='texttt'>token</span> of type <span class='texttt'>CompletionToken</span>;</p><p ><span class='indexparent'><a class='index' id='completion_signature'></a></span></p></li><li id='async.reqmts.async.token-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.token-1.3'>(1.3)</a></div><p >specify a completion signature, which is a call signature (C++Std &sect;<a href='../n4140/func.def'>[func.def]</a>) <span class='texttt'>Signature</span> that determines the arguments to the completion handler.
</p></li></ul><p ><span class='indexparent'><a class='index' id='completion_handler'></a></span></p></div><div class='para' id='async.reqmts.async.token-2'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.token-2'>2</a></div><p >An initiating function determines the type <span class='texttt'>CompletionHandler</span> of its
completion handler function object by performing
<span class='texttt'>typename async_result&lt;decay_t&lt;CompletionToken&gt;, Signature&gt;::completion_handler_type</span>.
The completion handler object <span class='texttt'>completion_handler</span> is initialized with
<span class='texttt'>std::forward&lt;CompletionToken&gt;(token)</span>.
[&nbsp;<i>Note:</i> No other requirements are placed on the type <span class='texttt'>CompletionToken</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='async.reqmts.async.token-3'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.token-3'>3</a></div><p >The type <span class='texttt'>CompletionHandler</span> must satisfy the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) and <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), and be callable with the specified call signature.</p></div><div class='para' id='async.reqmts.async.token-4'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.token-4'>4</a></div><p >In this Technical Specification, all initiating functions specify a
<i>Completion signature:</i> element that defines the call signature <span class='texttt'>Signature</span>.
The <i>Completion signature:</i> elements in this Technical Specification have named
parameters, and the results of an asynchronous operation are specified in
terms of these names.</p></div></div><div id='async.reqmts.async.return.type'><h4 ><a class='secnum' href='#async.reqmts.async.return.type' style='min-width:118pt'>13.2.7.3</a> Deduction of initiating function return type <a class='abbr_ref' href='async.reqmts.async.return.type'>[async.reqmts.async.return.type]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function,deduction_of_return_type'></a></span></p><div class='para' id='async.reqmts.async.return.type-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.return.type-1'>1</a></div><p >The return type of an initiating function is <span class='texttt'>typename async_result&lt;decay_t&lt;CompletionToken&gt;, Signature&gt;::return_type</span>.</p></div><div class='para' id='async.reqmts.async.return.type-2'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.return.type-2'>2</a></div><p >For the sake of exposition, this Technical Specification sometimes annotates functions with a return type <i><span class='texttt'>DEDUCED</span></i>. For every function declaration that returns <i><span class='texttt'>DEDUCED</span></i>, the meaning is equivalent to specifying the return type as <span class='texttt'>typename async_result&lt;decay_t&lt;CompletionToken&gt;, Signature&gt;::return_type</span>.</p></div></div><div id='async.reqmts.async.return.value'><h4 ><a class='secnum' href='#async.reqmts.async.return.value' style='min-width:118pt'>13.2.7.4</a> Production of initiating function return value <a class='abbr_ref' href='async.reqmts.async.return.value'>[async.reqmts.async.return.value]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function,production_of_return_value'></a></span></p><div class='para' id='async.reqmts.async.return.value-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.return.value-1'>1</a></div><p >An initiating function produces its return type as follows:</p><ul class='itemize'><li id='async.reqmts.async.return.value-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.return.value-1.1'>(1.1)</a></div><p >constructing an object <span class='texttt'>result</span> of type <span class='texttt'>async_result&lt;decay_t&lt;CompletionToken&gt;, Signature&gt;</span>, initialized as <span class='texttt'>result(completion_handler)</span>; and</p></li><li id='async.reqmts.async.return.value-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.return.value-1.2'>(1.2)</a></div><p >using <span class='texttt'>result.get()</span> as the operand of the return statement.
</p></li></ul></div><div class='para' id='async.reqmts.async.return.value-2'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.return.value-2'>2</a></div><p >[&nbsp;<i>Example:</i> Given an asynchronous operation with Completion signature <span class='texttt'>void(R1 r1, R2 r2)</span>, an initiating function meeting these requirements may be implemented as follows:</p><pre class='codeblock'>
template&lt;class CompletionToken&gt;
auto async_xyz(T1 t1, T2 t2, CompletionToken&amp;&amp; token){
  typename async_result&lt;decay_t&lt;CompletionToken&gt;, void(R1, R2)&gt;::completion_handler_type
    completion_handler(forward&lt;CompletionToken&gt;(token));

  async_result&lt;decay_t&lt;CompletionToken&gt;, void(R1, R2)&gt; result(completion_handler);

  <span class='comment'>// initiate the operation and cause completion_handler to be invoked with
</span>  <span class='comment'>// the result
</span>
  return result.get();
}
</pre></div><div class='para' id='async.reqmts.async.return.value-3'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.return.value-3'>3</a></div><p >For convenience, initiating functions may be implemented using the <span class='texttt'>async_completion</span> template:</p><pre class='codeblock'>
template&lt;class CompletionToken&gt;
auto async_xyz(T1 t1, T2 t2, CompletionToken&amp;&amp; token){
  async_completion&lt;CompletionToken, void(R1, R2)&gt; init(token);

  <span class='comment'>// initiate the operation and cause init.completion_handler to be invoked
</span>  <span class='comment'>// with the result
</span>
  return init.result.get();
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='async.reqmts.async.lifetime'><h4 ><a class='secnum' href='#async.reqmts.async.lifetime' style='min-width:118pt'>13.2.7.5</a> Lifetime of initiating function arguments <a class='abbr_ref' href='async.reqmts.async.lifetime'>[async.reqmts.async.lifetime]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function,lifetime_of_arguments'></a></span></p><div class='para' id='async.reqmts.async.lifetime-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.lifetime-1'>1</a></div><p >Unless otherwise specified, the lifetime of arguments to initiating functions shall be treated as follows:</p><ul class='itemize'><li id='async.reqmts.async.lifetime-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.lifetime-1.1'>(1.1)</a></div><p >If the parameter has a pointer type or has a type of lvalue reference to non-const, the implementation may assume the validity of the pointee or referent, respectively, until the completion handler is invoked. [&nbsp;<i>Note:</i> In other words, the program must guarantee the validity of the argument until the completion handler is invoked. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li id='async.reqmts.async.lifetime-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.lifetime-1.2'>(1.2)</a></div><p >Otherwise, the implementation must not assume the validity of the argument after the initiating function completes. [&nbsp;<i>Note:</i> In other words, the program is not required to guarantee the validity of the argument after the initiating function completes. <i>&nbsp;—&nbsp;end note</i>&nbsp;] The implementation may make copies of the argument, and all copies shall be destroyed no later than immediately after invocation of the completion handler.
</p></li></ul></div></div><div id='async.reqmts.async.non.blocking'><h4 ><a class='secnum' href='#async.reqmts.async.non.blocking' style='min-width:118pt'>13.2.7.6</a> Non-blocking requirements on initiating functions <a class='abbr_ref' href='async.reqmts.async.non.blocking'>[async.reqmts.async.non.blocking]</a></h4><p ><span class='indexparent'><a class='index' id='initiating_function,non-blocking_requirements'></a></span></p><div class='para' id='async.reqmts.async.non.blocking-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.non.blocking-1'>1</a></div><p >An initiating function shall not block (C++Std &sect;<a href='../n4140/defns.block'>[defns.block]</a>) the calling thread pending completion of the outstanding operation.</p></div><div class='para' id='async.reqmts.async.non.blocking-2'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.non.blocking-2'>2</a></div><p >[&nbsp;<i>Note:</i> Initiating functions may still block the calling thread for other reasons. For example, an initiating function may lock a mutex in order to synchronize access to shared data. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='async.reqmts.async.assoc.exec'><h4 ><a class='secnum' href='#async.reqmts.async.assoc.exec' style='min-width:118pt'>13.2.7.7</a> Associated executor <a class='abbr_ref' href='async.reqmts.async.assoc.exec'>[async.reqmts.async.assoc.exec]</a></h4><p ><span class='indexparent'><a class='index' id='associated_executor'></a></span></p><div class='para' id='async.reqmts.async.assoc.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.assoc.exec-1'>1</a></div><p >Certain objects that participate in asynchronous operations have an associated executor. These are obtained as specified below.</p></div></div><div id='async.reqmts.async.io.exec'><h4 ><a class='secnum' href='#async.reqmts.async.io.exec' style='min-width:118pt'>13.2.7.8</a> I/O executor <a class='abbr_ref' href='async.reqmts.async.io.exec'>[async.reqmts.async.io.exec]</a></h4><p ><span class='indexparent'><a class='index' id='system_executor'></a></span></p><div class='para' id='async.reqmts.async.io.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.io.exec-1'>1</a></div><p >An asynchronous operation has an associated executor satisfying the <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) requirements. If not otherwise specified by the asynchronous operation, this associated executor is an object of type <span class='texttt'>system_executor</span>.</p></div><div class='para' id='async.reqmts.async.io.exec-2'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.io.exec-2'>2</a></div><p >All asynchronous operations in this Technical Specification have an associated executor object that is determined as follows:</p><ul class='itemize'><li id='async.reqmts.async.io.exec-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.io.exec-2.1'>(2.1)</a></div><p >If the initiating function is a member function, the associated executor is that returned by the <span class='texttt'>get_executor</span> member function on the same object.</p></li><li id='async.reqmts.async.io.exec-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.io.exec-2.2'>(2.2)</a></div><p >If the initiating function is not a member function, the associated executor is that returned by the <span class='texttt'>get_executor</span> member function of the first argument to the initiating function.
</p></li></ul></div><div class='para' id='async.reqmts.async.io.exec-3'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.io.exec-3'>3</a></div><p >Let <span class='texttt'>Executor1</span> be the type of the associated executor. Let <span class='texttt'>ex1</span> be a value of type <span class='texttt'>Executor1</span>, representing the associated executor object obtained as described above.</p></div></div><div id='async.reqmts.async.handler.exec'><h4 ><a class='secnum' href='#async.reqmts.async.handler.exec' style='min-width:118pt'>13.2.7.9</a> Completion handler executor <a class='abbr_ref' href='async.reqmts.async.handler.exec'>[async.reqmts.async.handler.exec]</a></h4><div class='para' id='async.reqmts.async.handler.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.handler.exec-1'>1</a></div><p >A completion handler object of type <span class='texttt'>CompletionHandler</span>
has an associated executor
satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).
The type of this associated executor is
<span class='texttt'>associated_executor_t&lt;CompletionHandler, Executor1&gt;</span>.
Let <span class='texttt'>Executor2</span> be the type
<span class='texttt'>associated_executor_t&lt;CompletionHandler, Executor1&gt;</span>.
Let <span class='texttt'>ex2</span> be a value of type <span class='texttt'>Executor2</span>
obtained by performing <span class='texttt'>get_associated_executor(completion_handler, ex1)</span>.</p></div></div><div id='async.reqmts.async.work'><h4 ><a class='secnum' href='#async.reqmts.async.work' style='min-width:118pt'>13.2.7.10</a> Outstanding work <a class='abbr_ref' href='async.reqmts.async.work'>[async.reqmts.async.work]</a></h4><p ><span class='indexparent'><a class='index' id='outstanding_work'></a></span></p><div class='para' id='async.reqmts.async.work-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.work-1'>1</a></div><p >Until the asynchronous operation has completed, the asynchronous operation shall maintain:</p><ul class='itemize'><li id='async.reqmts.async.work-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.work-1.1'>(1.1)</a></div><p >an object <span class='texttt'>work1</span> of type <span class='texttt'>executor_work_guard&lt;Executor1&gt;</span>, initialized as <span class='texttt'>work1(ex1)</span>, and where <span class='texttt'>work1.owns_work() == true</span>; and</p></li><li id='async.reqmts.async.work-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.work-1.2'>(1.2)</a></div><p >an object <span class='texttt'>work2</span> of type <span class='texttt'>executor_work_guard&lt;Executor2&gt;</span>, initialized as <span class='texttt'>work2(ex2)</span>, and where <span class='texttt'>work2.owns_work() == true</span>.
</p></li></ul></div></div><div id='async.reqmts.async.alloc'><h4 ><a class='secnum' href='#async.reqmts.async.alloc' style='min-width:118pt'>13.2.7.11</a> Allocation of intermediate storage <a class='abbr_ref' href='async.reqmts.async.alloc'>[async.reqmts.async.alloc]</a></h4><div class='para' id='async.reqmts.async.alloc-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.alloc-1'>1</a></div><p >Asynchronous operations may allocate memory. [&nbsp;<i>Note:</i> Such as a data structure to store copies of the <span class='texttt'>completion_handler</span> object and the initiating function's arguments. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='async.reqmts.async.alloc-2'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.alloc-2'>2</a></div><p >Let <span class='texttt'>Alloc1</span> be a type, satisfying the <span class='texttt'>ProtoAllocator</span> (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>) requirements, that represents the asynchronous operation's default allocation strategy. [&nbsp;<i>Note:</i> Typically <span class='texttt'>std::allocator&lt;void&gt;</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Let <span class='texttt'>alloc1</span> be a value of type <span class='texttt'>Alloc1</span>.</p></div><div class='para' id='async.reqmts.async.alloc-3'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.alloc-3'>3</a></div><p >A completion handler object of type <span class='texttt'>CompletionHandler</span> has an associated allocator object <span class='texttt'>alloc2</span> of type <span class='texttt'>Alloc2</span> satisfying the <span class='texttt'>ProtoAllocator</span> (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>) requirements. The type <span class='texttt'>Alloc2</span> is <span class='texttt'>associated_allocator_t&lt;CompletionHandler, Alloc1&gt;</span>. Let <span class='texttt'>alloc2</span> be a value of type <span class='texttt'>Alloc2</span> obtained by performing <span class='texttt'>get_associated_allocator(completion_handler, alloc1)</span>.</p></div><div class='para' id='async.reqmts.async.alloc-4'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.alloc-4'>4</a></div><p >The asynchronous operations defined in this Technical Specification:</p><ul class='itemize'><li id='async.reqmts.async.alloc-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.alloc-4.1'>(4.1)</a></div><p >If required, allocate memory using only the completion handler's associated allocator.</p></li><li id='async.reqmts.async.alloc-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.alloc-4.2'>(4.2)</a></div><p >Prior to completion handler execution, deallocate any memory allocated using the completion handler's associated allocator.
</p></li></ul></div><div class='para' id='async.reqmts.async.alloc-5'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.alloc-5'>5</a></div><p >[&nbsp;<i>Note:</i> The implementation may perform operating system or underlying API calls that perform memory allocations not using the associated allocator. Invocations of the allocator functions may not introduce data races (See C++Std &sect;<a href='../n4140/res.on.data.races'>[res.on.data.races]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='async.reqmts.async.completion'><h4 ><a class='secnum' href='#async.reqmts.async.completion' style='min-width:118pt'>13.2.7.12</a> Execution of completion handler on completion of asynchronous operation <a class='abbr_ref' href='async.reqmts.async.completion'>[async.reqmts.async.completion]</a></h4><div class='para' id='async.reqmts.async.completion-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.completion-1'>1</a></div><p >Let <span class='texttt'>Args...</span> be the argument types of the completion signature <span class='texttt'>Signature</span> and let <i>N</i> be <span class='texttt'>sizeof...(Args)</span>. Let <i>i</i> be in the range <span class='texttt'>[0, <i>N</i>)</span>. Let <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> type in <span class='texttt'>Args...</span> and let <span class='texttt'>t</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> completion handler argument associated with <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>.</p></div><div class='para' id='async.reqmts.async.completion-2'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.completion-2'>2</a></div><p >Let <span class='texttt'>f</span> be a function object, callable as <span class='texttt'>f()</span>, that invokes <span class='texttt'>completion_handler</span> as if by <span class='texttt'>completion_handler(forward&lt;T<span class='math'><sub >0</sub></span>&gt;(t<span class='math'><sub >0</sub></span>), ..., forward&lt;T<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(t<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span>.</p></div><div class='para' id='async.reqmts.async.completion-3'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.completion-3'>3</a></div><p >If an asynchronous operation completes immediately (that is, within the thread of execution calling the initiating function, and before the initiating function returns), the completion handler shall be submitted for execution as if by performing <span class='texttt'>ex2.post(std::move(f), alloc2)</span>. Otherwise, the completion handler shall be submitted for execution as if by performing <span class='texttt'>ex2.dispatch(std::move(f), alloc2)</span>.</p></div></div><div id='async.reqmts.async.exceptions'><h4 ><a class='secnum' href='#async.reqmts.async.exceptions' style='min-width:118pt'>13.2.7.13</a> Completion handlers and exceptions <a class='abbr_ref' href='async.reqmts.async.exceptions'>[async.reqmts.async.exceptions]</a></h4><div class='para' id='async.reqmts.async.exceptions-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.exceptions-1'>1</a></div><p >Completion handlers are permitted to throw exceptions. The effect of any exception propagated from the execution of a completion handler is determined by the executor which is executing the completion handler.</p></div></div><div id='async.reqmts.async.composed'><h4 ><a class='secnum' href='#async.reqmts.async.composed' style='min-width:118pt'>13.2.7.14</a> Composed asynchronous operations <a class='abbr_ref' href='async.reqmts.async.composed'>[async.reqmts.async.composed]</a></h4><div class='para' id='async.reqmts.async.composed-1'><div class='marginalizedparent'><a class='marginalized' href='#async.reqmts.async.composed-1'>1</a></div><p >In this Technical Specification, a <a class='hidden_link' href='#def:composed_asynchronous_operation' id='def:composed_asynchronous_operation'><i>composed asynchronous operation</i></a> is an asynchronous operation that is implemented in terms of zero or more intermediate calls to other asynchronous operations. The intermediate asynchronous operations are performed sequentially. [&nbsp;<i>Note:</i> That is, the completion handler of an intermediate operation initiates the next operation in the sequence. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >An intermediate operation's completion handler shall have an associated executor that is either:</p><ul class='itemize'><li id='async.reqmts.async.composed-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.composed-1.1'>(1.1)</a></div><p >the type <span class='texttt'>Executor2</span> and object <span class='texttt'>ex2</span> obtained from the completion handler type <span class='texttt'>CompletionHandler</span> and object <span class='texttt'>completion_handler</span>; or</p></li><li id='async.reqmts.async.composed-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.composed-1.2'>(1.2)</a></div><p >an object of an unspecified type satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>), that delegates executor operations to the type <span class='texttt'>Executor2</span> and object <span class='texttt'>ex2</span>.
</p></li></ul><p >An intermediate operation's completion handler shall have an associated allocator that is either:</p><ul class='itemize'><li id='async.reqmts.async.composed-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.composed-1.3'>(1.3)</a></div><p >the type <span class='texttt'>Alloc2</span> and object <span class='texttt'>alloc2</span> obtained from the completion handler type <span class='texttt'>CompletionHandler</span> and object <span class='texttt'>completion_handler</span>; or</p></li><li id='async.reqmts.async.composed-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.reqmts.async.composed-1.4'>(1.4)</a></div><p >an object of an unspecified type satisfying the ProtoAllocator requirements (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>), that delegates allocator operations to the type <span class='texttt'>Alloc2</span> and object <span class='texttt'>alloc2</span>.
</p></li></ul></div></div></div></div><div id='async.async.result'><h2 ><a class='secnum' href='#async.async.result' style='min-width:88pt'>13.3</a> Class template <span class='texttt'>async_result</span> <a class='abbr_ref' href='async.async.result'>[async.async.result]</a></h2><p ><span class='indexparent'><a class='index' id='async_result'></a></span></p><div class='para' id='async.async.result-1'><div class='marginalizedparent'><a class='marginalized' href='#async.async.result-1'>1</a></div><p >The <span class='texttt'>async_result</span> class template is a customization point for asynchronous operations. Template parameter <span class='texttt'>CompletionToken</span> specifies the model used to obtain the result of the asynchronous operation. Template parameter <span class='texttt'>Signature</span> is the call signature (C++Std &sect;<a href='../n4140/func.def'>[func.def]</a>) for the completion handler type invoked on completion of the asynchronous operation. The <span class='texttt'>async_result</span> template:</p><ul class='itemize'><li id='async.async.result-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.async.result-1.1'>(1.1)</a></div><p >transforms a <span class='texttt'>CompletionToken</span> into a completion handler type that is based on a <span class='texttt'>Signature</span>; and</p></li><li id='async.async.result-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.async.result-1.2'>(1.2)</a></div><p >determines the return type and return value of an asynchronous operation's initiating function.
</p></li></ul><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class CompletionToken, class Signature&gt;
  class async_result
  {
  public:
    using completion_handler_type = CompletionToken;
    using return_type = void;

    explicit async_result(completion_handler_type&amp;) {}
    async_result(const async_result&amp;) = delete;
    async_result&amp; operator=(const async_result&amp;) = delete;

    return_type get() {}
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='async.async.result-2'><div class='marginalizedparent'><a class='marginalized' href='#async.async.result-2'>2</a></div><p >The template parameter <span class='texttt'>CompletionToken</span> shall be an object type. The template parameter <span class='texttt'>Signature</span> shall be a call signature (C++Std &sect;<a href='../n4140/func.def'>[func.def]</a>).</p></div><div class='para' id='async.async.result-3'><div class='marginalizedparent'><a class='marginalized' href='#async.async.result-3'>3</a></div><p >Specializations of <span class='texttt'>async_result</span> shall satisfy the <span class='texttt'>Destructible</span> requirements (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) in addition to the requirements in Table <a href='async.async.result#tab:async.async.result.requirements'>[tab:async.async.result.requirements]</a>. In this table, <span class='texttt'>R</span> is a specialization of <span class='texttt'>async_result</span>; <span class='texttt'>r</span> is a modifiable lvalue of type <span class='texttt'>R</span>; and <span class='texttt'>h</span> is a modifiable lvalue of type <span class='texttt'>R::completion_handler_type</span>.</p><p ><span class='indexparent'><a class='index' id='requirements,async_result'></a></span>
 
 
 </p><div class='numberedTable' id='tab:async.async.result.requirements'>Table <a href='#tab:async.async.result.requirements'>7</a> — <span class='texttt'>async_result</span> specialization requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Requirement</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>R::completion_handler_type</span>  </td><td class='left'>
  </td><td class='left'>
A type satisfying <span class='texttt'>MoveConstructible</span> requirements (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), An object of type <span class='texttt'>completion_handler_type</span> shall be a function object with call signature <span class='texttt'>Signature</span>, and <span class='texttt'>completion_handler_type</span> shall be constructible with an rvalue of type <span class='texttt'>CompletionToken</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>R::return_type</span>  </td><td class='left'>
  </td><td class='left'>
<span class='texttt'>void</span>; or a type satisfying <span class='texttt'>MoveConstructible</span> requirements (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>)  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>R r(h);</span>  </td><td class='left'>
  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>r.get()</span>  </td><td class='left'>
<span class='texttt'>R::return_type</span>  </td><td class='left'>
[&nbsp;<i>Note:</i> An asynchronous operation's initiating function uses the <span class='texttt'>get()</span> member function as the sole operand of a return statement. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr></table></div></div></div><div id='async.async.completion'><h2 ><a class='secnum' href='#async.async.completion' style='min-width:88pt'>13.4</a> Class template <span class='texttt'>async_completion</span> <a class='abbr_ref' href='async.async.completion'>[async.async.completion]</a></h2><p ><span class='indexparent'><a class='index' id='async_completion'></a></span></p><div class='para' id='async.async.completion-1'><div class='marginalizedparent'><a class='marginalized' href='#async.async.completion-1'>1</a></div><p >Class template <span class='texttt'>async_completion</span> is provided as a convenience, to simplify the implementation of asynchronous operations that use <span class='texttt'>async_result</span>.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class CompletionToken, class Signature&gt;
  struct async_completion
  {
    using completion_handler_type = async_result&lt;decay_t&lt;CompletionToken&gt;,
      Signature&gt;::completion_handler_type;

    explicit async_completion(CompletionToken&amp; t);
    async_completion(const async_completion&amp;) = delete;
    async_completion&amp; operator=(const async_completion&amp;) = delete;

    <i><span class='texttt'>see below</span></i> completion_handler;
    async_result&lt;decay_t&lt;CompletionToken&gt;, Signature&gt; result;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='async.async.completion-2'><div class='marginalizedparent'><a class='marginalized' href='#async.async.completion-2'>2</a></div><p >The template parameter <span class='texttt'>Signature</span> shall be a call signature (C++Std &sect;<a href='../n4140/func.def'>[func.def]</a>).</p><p ><code class='itemdecl'>
explicit async_completion(CompletionToken&amp; t);
</code></p></div><div class='itemdescr'></div><div class='para' id='async.async.completion-3'><div class='marginalizedparent'><a class='marginalized' href='#async.async.completion-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>CompletionToken</span> and <span class='texttt'>completion_handler_type</span> are the same type,
binds <span class='texttt'>completion_handler</span> to <span class='texttt'>t</span>;
otherwise, initializes <span class='texttt'>completion_handler</span> with <span class='texttt'>forward&lt;CompletionToken&gt;(t)</span>.
Initializes <span class='texttt'>result</span> with <span class='texttt'>completion_handler</span>.
</p></div></div><p ><code class='itemdecl'>
<i><span class='texttt'>see below</span></i> completion_handler;
</code></p><div class='itemdescr'></div><div class='para' id='async.async.completion-4'><div class='marginalizedparent'><a class='marginalized' href='#async.async.completion-4'>4</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>completion_handler_type&amp;</span> if <span class='texttt'>CompletionToken</span> and <span class='texttt'>completion_handler_type</span> are the same type; otherwise, <span class='texttt'>completion_handler_type</span>.
</p></div></div></div><div id='async.assoc.alloc'><h2 ><a class='secnum' href='#async.assoc.alloc' style='min-width:88pt'>13.5</a> Class template <span class='texttt'>associated_allocator</span> <a class='abbr_ref' href='async.assoc.alloc'>[async.assoc.alloc]</a></h2><p ><span class='indexparent'><a class='index' id='associated_allocator'></a></span></p><div class='para' id='async.assoc.alloc-1'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.alloc-1'>1</a></div><p >Class template <span class='texttt'>associated_allocator</span> is an associator (<a href='async.reqmts.associator'>[async.reqmts.associator]</a>) for the <span class='texttt'>ProtoAllocator</span> (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>) type requirements, with default candidate type <span class='texttt'>allocator&lt;void&gt;</span> and default candidate object <span class='texttt'>allocator&lt;void&gt;()</span>.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class ProtoAllocator = allocator&lt;void&gt;&gt;
  struct associated_allocator
  {
    using type = <i><span class='texttt'>see below</span></i>;

    static type get(const T&amp; t, const ProtoAllocator&amp; a = ProtoAllocator()) noexcept;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><span class='indexparent'><a class='index' id='requirements,associated_allocator'></a></span></p></div><div class='para' id='async.assoc.alloc-2'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.alloc-2'>2</a></div><p >Specializations of <span class='texttt'>associated_allocator</span> shall satisfy the requirements in Table <a href='async.assoc.alloc#tab:async.assoc.alloc.requirements'>[tab:async.assoc.alloc.requirements]</a>.
In this table, <span class='texttt'>X</span> is a specialization of <span class='texttt'>associated_allocator</span>
for the template parameters <span class='texttt'>T</span> and <span class='texttt'>ProtoAllocator</span>;
<span class='texttt'>t</span> is a value of type <span class='texttt'>T</span> or <span class='texttt'>const T</span>;
and <span class='texttt'>a</span> is an object of type <span class='texttt'>ProtoAllocator</span>.</p><div class='numberedTable' id='tab:async.assoc.alloc.requirements'>Table <a href='#tab:async.assoc.alloc.requirements'>8</a> — <span class='texttt'>associated_allocator</span> specialization requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Note</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>typename X::type</span>  </td><td class='left'>
A type meeting the proto-allocator (<a href='async.reqmts.proto.allocator'>[async.reqmts.proto.allocator]</a>) requirements.  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::get(t)</span>  </td><td class='left'>
<span class='texttt'>X::type</span>  </td><td class='left'>
Shall not exit via an exception. Equivalent to <span class='texttt'>X::get(t, ProtoAllocator())</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::get(t, a)</span>  </td><td class='left'>
<span class='texttt'>X::type</span>  </td><td class='left'>
 Shall not exit via an exception.  </td></tr></table></div></div><div id='async.assoc.alloc.members'><h3 ><a class='secnum' href='#async.assoc.alloc.members' style='min-width:103pt'>13.5.1</a> <span class='texttt'>associated_allocator</span> members <a class='abbr_ref' href='async.assoc.alloc.members'>[async.assoc.alloc.members]</a></h3><p ><code class='itemdecl'>
using type = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='async.assoc.alloc.members-1'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.alloc.members-1'>1</a></div><div class='itemdescr'><p ><i>Type:</i> If the <span class='grammarterm'>qualified-id</span> <span class='texttt'>T::allocator_type</span>
is valid and denotes a type (C++Std &sect;<a href='../n4140/temp.deduct'>[temp.deduct]</a>), <span class='texttt'>T::allocator_type</span>.
Otherwise <span class='texttt'>ProtoAllocator</span>.
</p></div></div><p ><code class='itemdecl'>
type get(const T&amp; t, const ProtoAllocator&amp; a = ProtoAllocator()) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.assoc.alloc.members-2'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.alloc.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> If the <span class='grammarterm'>qualified-id</span> <span class='texttt'>T::allocator_type</span>
is valid and denotes a type (C++Std &sect;<a href='../n4140/temp.deduct'>[temp.deduct]</a>), <span class='texttt'>t.get_allocator()</span>.
Otherwise <span class='texttt'>a</span>.
</p></div></div></div></div><div id='async.assoc.alloc.get'><h2 ><a class='secnum' href='#async.assoc.alloc.get' style='min-width:88pt'>13.6</a> Function <span class='texttt'>get_associated_allocator</span> <a class='abbr_ref' href='async.assoc.alloc.get'>[async.assoc.alloc.get]</a></h2><p ><span class='indexparent'><a class='index' id='get_associated_allocator'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  associated_allocator_t&lt;T&gt; get_associated_allocator(const T&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.assoc.alloc.get-1'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.alloc.get-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>associated_allocator&lt;T&gt;::get(t)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class T, class ProtoAllocator&gt;
  associated_allocator_t&lt;T, ProtoAllocator&gt;
    get_associated_allocator(const T&amp; t, const ProtoAllocator&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.assoc.alloc.get-2'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.alloc.get-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>associated_allocator&lt;T, ProtoAllocator&gt;::get(t, a)</span>.
</p></div></div></div><div id='async.exec.ctx'><h2 ><a class='secnum' href='#async.exec.ctx' style='min-width:88pt'>13.7</a> Class <span class='texttt'>execution_context</span> <a class='abbr_ref' href='async.exec.ctx'>[async.exec.ctx]</a></h2><p ><span class='indexparent'><a class='index' id='execution_context'></a></span></p><div class='para' id='async.exec.ctx-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx-1'>1</a></div><p >Class <span class='texttt'>execution_context</span> implements an extensible, type-safe, polymorphic set of services, indexed by service type.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class execution_context
  {
  public:
    class service;

    <span class='comment'>// construct / copy / destroy:
</span>
    execution_context();
    execution_context(const execution_context&amp;) = delete;
    execution_context&amp; operator=(const execution_context&amp;) = delete;
    virtual ~execution_context();

    <span class='comment'>// execution context operations:
</span>
    void notify_fork(fork_event e);

  protected:

    <span class='comment'>// execution context protected operations:
</span>
    void shutdown() noexcept;
    void destroy() noexcept;
  };

  <span class='comment'>// service access:
</span>  template&lt;class Service&gt; typename Service::key_type&amp;
    use_service(execution_context&amp; ctx);
  template&lt;class Service, class... Args&gt; Service&amp;
    make_service(execution_context&amp; ctx, Args&amp;&amp;... args);
  template&lt;class Service&gt; bool has_service(const execution_context&amp; ctx) noexcept;
  class service_already_exists : public logic_error { };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='async.exec.ctx-2'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx-2'>2</a></div><p >Access to the services of an <span class='texttt'>execution_context</span> is via three function templates, <span class='texttt'>use_service&lt;&gt;</span>, <span class='texttt'>make_service&lt;&gt;</span> and <span class='texttt'>has_service&lt;&gt;</span>.</p></div><div class='para' id='async.exec.ctx-3'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx-3'>3</a></div><p >In a call to <span class='texttt'>use_service&lt;Service&gt;()</span>, the type argument chooses a service. If the service is not present in an <span class='texttt'>execution_context</span>, an object of type <span class='texttt'>Service</span> is created and added to the <span class='texttt'>execution_context</span>. A program can check if an <span class='texttt'>execution_context</span> implements a particular service with the function template <span class='texttt'>has_service&lt;Service&gt;()</span>.</p></div><div class='para' id='async.exec.ctx-4'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx-4'>4</a></div><p >Service objects may be explicitly added to an <span class='texttt'>execution_context</span> using the function template <span class='texttt'>make_service&lt;Service&gt;()</span>. If the service is already present, <span class='texttt'>make_service</span> exits via an exception of type <span class='texttt'>service_already_exists</span>.</p></div><div class='para' id='async.exec.ctx-5'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx-5'>5</a></div><p >Once a service reference is obtained from an <span class='texttt'>execution_context</span> object by calling <span class='texttt'>use_service&lt;&gt;</span>, that reference remains usable until a call to <span class='texttt'>destroy()</span>.</p></div><div id='async.exec.ctx.cons'><h3 ><a class='secnum' href='#async.exec.ctx.cons' style='min-width:103pt'>13.7.1</a> <span class='texttt'>execution_context</span> constructor <a class='abbr_ref' href='async.exec.ctx.cons'>[async.exec.ctx.cons]</a></h3><p ><span class='indexparent'><a class='index' id='execution_context,constructor'></a></span><code class='itemdecl'>
execution_context();
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.ctx.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Creates an object of class <span class='texttt'>execution_context</span> which contains no services. [&nbsp;<i>Note:</i> An implementation might preload services of internal service types for its own use. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='async.exec.ctx.dtor'><h3 ><a class='secnum' href='#async.exec.ctx.dtor' style='min-width:103pt'>13.7.2</a> <span class='texttt'>execution_context</span> destructor <a class='abbr_ref' href='async.exec.ctx.dtor'>[async.exec.ctx.dtor]</a></h3><p ><span class='indexparent'><a class='index' id='execution_context,destructor'></a></span><code class='itemdecl'>
~execution_context();
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.ctx.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys an object of class <span class='texttt'>execution_context</span>. Performs <span class='texttt'>shutdown()</span> followed by <span class='texttt'>destroy()</span>.
</p></div></div></div><div id='async.exec.ctx.ops'><h3 ><a class='secnum' href='#async.exec.ctx.ops' style='min-width:103pt'>13.7.3</a> <span class='texttt'>execution_context</span> operations <a class='abbr_ref' href='async.exec.ctx.ops'>[async.exec.ctx.ops]</a></h3><p ><span class='indexparent'><a class='index' id='notify_fork,execution_context'></a></span><span class='indexparent'><a class='index' id='execution_context,notify_fork'></a></span><code class='itemdecl'>
void notify_fork(fork_event e);
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.ctx.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.ops-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> For each service object <span class='texttt'>svc</span> in the set:
</p><ul class='itemize'><li id='async.exec.ctx.ops-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.exec.ctx.ops-1.1'>(1.1)</a></div><p >If <span class='texttt'>e == fork_event::prepare</span>, performs <span class='texttt'>svc-&gt;notify_fork(e)</span> in reverse order of addition to the set.
</p></li><li id='async.exec.ctx.ops-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.exec.ctx.ops-1.2'>(1.2)</a></div><p >Otherwise, performs <span class='texttt'>svc-&gt;notify_fork(e)</span> in order of addition to the set.
</p></li></ul></div></div></div><div id='async.exec.ctx.protected'><h3 ><a class='secnum' href='#async.exec.ctx.protected' style='min-width:103pt'>13.7.4</a> <span class='texttt'>execution_context</span> protected operations <a class='abbr_ref' href='async.exec.ctx.protected'>[async.exec.ctx.protected]</a></h3><p ><span class='indexparent'><a class='index' id='shutdown,execution_context'></a></span><span class='indexparent'><a class='index' id='execution_context,shutdown'></a></span><code class='itemdecl'>
void shutdown() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.ctx.protected-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.protected-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> For each service object <span class='texttt'>svc</span> in the <span class='texttt'>execution_context</span> set, in reverse order of addition to the set, performs <span class='texttt'>svc-&gt;shutdown()</span>. For each service in the set, <span class='texttt'>svc-&gt;shutdown()</span> is called only once irrespective of the number of calls to <span class='texttt'>shutdown</span> on the <span class='texttt'>execution_context</span>.
</p></div></div><p ><code class='itemdecl'>
void destroy() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.ctx.protected-2'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.protected-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys each service object in the <span class='texttt'>execution_context</span> set, and removes it from the set, in reverse order of addition to the set.
</p></div></div></div><div id='async.exec.ctx.globals'><h3 ><a class='secnum' href='#async.exec.ctx.globals' style='min-width:103pt'>13.7.5</a> <span class='texttt'>execution_context</span> globals <a class='abbr_ref' href='async.exec.ctx.globals'>[async.exec.ctx.globals]</a></h3><div class='para' id='async.exec.ctx.globals-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.globals-1'>1</a></div><p >The functions <span class='texttt'>use_service</span>, <span class='texttt'>make_service</span>, and <span class='texttt'>has_service</span> do not introduce data races as a result of concurrent calls to those functions from different threads.</p><p ><span class='indexparent'><a class='index' id='use_service'></a></span><code class='itemdecl'>
template&lt;class Service&gt; typename Service::key_type&amp;
  use_service(execution_context&amp; ctx);
</code></p></div><div class='itemdescr'></div><div class='para' id='async.exec.ctx.globals-2'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.globals-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> If an object of type <span class='texttt'>Service::key_type</span> does not already exist in the <span class='texttt'>execution_context</span> set identified by <span class='texttt'>ctx</span>, creates an object of type <span class='texttt'>Service</span>, initialized as <span class='texttt'>Service(ctx)</span>, and adds it to the set.</p></div></div><div class='para' id='async.exec.ctx.globals-3'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.globals-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to the corresponding service of <span class='texttt'>ctx</span>.</p></div></div><div class='para' id='async.exec.ctx.globals-4'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.globals-4'>4</a></div><div class='itemdescr'><p >Notes: The reference returned remains valid until a call to <span class='texttt'>destroy</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_service'></a></span><code class='itemdecl'>
template&lt;class Service, class... Args&gt; Service&amp;
  make_service(execution_context&amp; ctx, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.ctx.globals-5'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.globals-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> A service object of type <span class='texttt'>Service::key_type</span> does not already exist in the <span class='texttt'>execution_context</span> set identified by <span class='texttt'>ctx</span>.</p></div></div><div class='para' id='async.exec.ctx.globals-6'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.globals-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Creates an object of type <span class='texttt'>Service</span>, initialized as <span class='texttt'>Service(ctx, forward&lt;Args&gt;(args)...)</span>, and adds it to the <span class='texttt'>execution_context</span> set identified by <span class='texttt'>ctx</span>.</p></div></div><div class='para' id='async.exec.ctx.globals-7'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.globals-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>service_already_exists</span> if a corresponding service object of type <span class='texttt'>Key</span> is already present in the set.</p></div></div><div class='para' id='async.exec.ctx.globals-8'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.globals-8'>8</a></div><div class='itemdescr'><p >Notes: The reference returned remains valid until a call to <span class='texttt'>destroy</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='has_service'></a></span><code class='itemdecl'>
template&lt;class Service&gt; bool has_service(const execution_context&amp; ctx) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.ctx.globals-9'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.globals-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if an object of type <span class='texttt'>Service::key_type</span> is present in <span class='texttt'>ctx</span>, otherwise <span class='texttt'>false</span>.
</p></div></div></div></div><div id='async.exec.ctx.svc'><h2 ><a class='secnum' href='#async.exec.ctx.svc' style='min-width:88pt'>13.8</a> Class <span class='texttt'>execution_context::service</span> <a class='abbr_ref' href='async.exec.ctx.svc'>[async.exec.ctx.svc]</a></h2><p ><span class='indexparent'><a class='index' id='execution_context::service'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class execution_context::service
  {
  protected:
    <span class='comment'>// construct / copy / destroy:
</span>
    explicit service(execution_context&amp; owner);
    service(const service&amp;) = delete;
    service&amp; operator=(const service&amp;) = delete;
    virtual ~service();

    <span class='comment'>// service observers:
</span>
    execution_context&amp; context() noexcept;

  private:
    <span class='comment'>// service operations:
</span>
    virtual void shutdown() noexcept = 0;
    virtual void notify_fork(fork_event e) {}

    execution_context&amp; context_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><span class='indexparent'><a class='index' id='execution_context::service,constructor'></a></span><code class='itemdecl'>
explicit service(execution_context&amp; owner);
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.ctx.svc-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.svc-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>std::addressof(context_) == std::addressof(owner)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='context,execution_context::service'></a></span><span class='indexparent'><a class='index' id='execution_context::service,context'></a></span><code class='itemdecl'>
execution_context&amp; context() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.ctx.svc-2'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.ctx.svc-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>context_</span>.
</p></div></div></div><div id='async.is.exec'><h2 ><a class='secnum' href='#async.is.exec' style='min-width:88pt'>13.9</a> Class template <span class='texttt'>is_executor</span> <a class='abbr_ref' href='async.is.exec'>[async.is.exec]</a></h2><p ><span class='indexparent'><a class='index' id='is_executor'></a></span></p><div class='para' id='async.is.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#async.is.exec-1'>1</a></div><p >The class template <span class='texttt'>is_executor</span> can be used to detect executor types satisfying the <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) type requirements.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T&gt; struct is_executor;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='async.is.exec-2'><div class='marginalizedparent'><a class='marginalized' href='#async.is.exec-2'>2</a></div><p ><span class='texttt'>T</span> shall be a complete type.</p></div><div class='para' id='async.is.exec-3'><div class='marginalizedparent'><a class='marginalized' href='#async.is.exec-3'>3</a></div><p >Class template <span class='texttt'>is_executor</span> is a UnaryTypeTrait (C++Std &sect;<a href='../n4140/meta.rqmts'>[meta.rqmts]</a>) with a BaseCharacteristic of <span class='texttt'>true_type</span> if the type <span class='texttt'>T</span> meets the syntactic requirements for <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>), otherwise <span class='texttt'>false_type</span>.</p></div></div><div id='async.executor.arg'><h2 ><a class='secnum' href='#async.executor.arg' style='min-width:88pt'>13.10</a> Executor argument tag <a class='abbr_ref' href='async.executor.arg'>[async.executor.arg]</a></h2><p ><span class='indexparent'><a class='index' id='executor_arg_t'></a></span><span class='indexparent'><a class='index' id='executor_arg'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  struct executor_arg_t { };
  constexpr executor_arg_t executor_arg = executor_arg_t();

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='async.executor.arg-1'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.arg-1'>1</a></div><p >The <span class='texttt'>executor_arg_t</span> struct is an empty structure type used as a unique type to disambiguate constructor and function overloading. Specifically, types may have constructors with <span class='texttt'>executor_arg_t</span> as the first argument, immediately followed by an argument of a type that satisfies the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).</p></div></div><div id='async.uses.executor'><h2 ><a class='secnum' href='#async.uses.executor' style='min-width:88pt'>13.11</a> <span class='texttt'>uses_executor</span> <a class='abbr_ref' href='async.uses.executor'>[async.uses.executor]</a></h2><div id='async.uses.executor.trait'><h3 ><a class='secnum' href='#async.uses.executor.trait' style='min-width:103pt'>13.11.1</a> <span class='texttt'>uses_executor</span> trait <a class='abbr_ref' href='async.uses.executor.trait'>[async.uses.executor.trait]</a></h3><p ><span class='indexparent'><a class='index' id='uses_executor'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class Executor&gt; struct uses_executor;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='async.uses.executor.trait-1'><div class='marginalizedparent'><a class='marginalized' href='#async.uses.executor.trait-1'>1</a></div><p >Remark: Detects whether <span class='texttt'>T</span> has a nested <span class='texttt'>executor_type</span> that is convertible from <span class='texttt'>Executor</span>. Meets the <span class='texttt'>BinaryTypeTrait</span> requirements (C++Std &sect;<a href='../n4140/meta.rqmts'>[meta.rqmts]</a>). The implementation provides a definition that is derived from <span class='texttt'>true_type</span> if a type <span class='texttt'>T::executor_type</span> exists and <span class='texttt'>is_convertible&lt;Executor, T::executor_type&gt;::value != false</span>, otherwise it is derived from <span class='texttt'>false_type</span>. A program may specialize this template to derive from <span class='texttt'>true_type</span> for a user-defined type <span class='texttt'>T</span> that does not have a nested <span class='texttt'>executor_type</span> but nonetheless can be constructed with an executor if the first argument of a constructor has type <span class='texttt'>executor_arg_t</span> and the second argument has type <span class='texttt'>Executor</span>.</p></div></div><div id='async.uses.executor.cons'><h3 ><a class='secnum' href='#async.uses.executor.cons' style='min-width:103pt'>13.11.2</a> uses-executor construction <a class='abbr_ref' href='async.uses.executor.cons'>[async.uses.executor.cons]</a></h3><p ><span class='indexparent'><a class='index' id='uses-executor_construction'></a></span></p><div class='para' id='async.uses.executor.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#async.uses.executor.cons-1'>1</a></div><p >Uses-executor construction with executor <span class='texttt'>Executor</span> refers to the construction of an object <span class='texttt'>obj</span> of type <span class='texttt'>T</span>, using constructor arguments <span class='texttt'>v1, v2, ..., vN</span> of types <span class='texttt'>V1, V2, ..., VN</span>, respectively, and an executor <span class='texttt'>ex</span> of type <span class='texttt'>Executor</span>, according to the following rules:</p><ul class='itemize'><li id='async.uses.executor.cons-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.uses.executor.cons-1.1'>(1.1)</a></div><p >if <span class='texttt'>uses_executor_v&lt;T, Executor&gt;</span> is <span class='texttt'>true</span>
and <span class='texttt'>is_constructible&lt;T, executor_arg_t, Executor, V1, V2, ..., VN&gt;::value</span> is <span class='texttt'>true</span>,
then <span class='texttt'>obj</span> is initialized as <span class='texttt'>obj(executor_arg, ex, v1, v2, ..., vN)</span>;</p></li><li id='async.uses.executor.cons-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.uses.executor.cons-1.2'>(1.2)</a></div><p >otherwise, <span class='texttt'>obj</span> is initialized as <span class='texttt'>obj(v1, v2, ..., vN)</span>.
</p></li></ul></div></div></div><div id='async.assoc.exec'><h2 ><a class='secnum' href='#async.assoc.exec' style='min-width:88pt'>13.12</a> Class template <span class='texttt'>associated_executor</span> <a class='abbr_ref' href='async.assoc.exec'>[async.assoc.exec]</a></h2><p ><span class='indexparent'><a class='index' id='associated_executor'></a></span></p><div class='para' id='async.assoc.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.exec-1'>1</a></div><p >Class template <span class='texttt'>associated_executor</span> is an associator (<a href='async.reqmts.associator'>[async.reqmts.associator]</a>) for the <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) type requirements, with default candidate type <span class='texttt'>system_executor</span> and default candidate object <span class='texttt'>system_executor()</span>.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class Executor = system_executor&gt;
  struct associated_executor
  {
    using type = <i><span class='texttt'>see below</span></i>;

    static type get(const T&amp; t, const Executor&amp; e = Executor()) noexcept;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><span class='indexparent'><a class='index' id='requirements,associated_executor'></a></span></p></div><div class='para' id='async.assoc.exec-2'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.exec-2'>2</a></div><p >Specializations of <span class='texttt'>associated_executor</span> shall satisfy the requirements in Table <a href='async.assoc.exec#tab:async.assoc.exec.requirements'>[tab:async.assoc.exec.requirements]</a>.
In this table, <span class='texttt'>X</span> is a specialization of <span class='texttt'>associated_executor</span>
for the template parameters <span class='texttt'>T</span> and <span class='texttt'>Executor</span>;
<span class='texttt'>t</span> is a value of <span class='texttt'>T</span> or <span class='texttt'>const T</span>;
and <span class='texttt'>e</span> is an object of type <span class='texttt'>Executor</span>.</p><div class='numberedTable' id='tab:async.assoc.exec.requirements'>Table <a href='#tab:async.assoc.exec.requirements'>9</a> — <span class='texttt'>associated_executor</span> specialization requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Expression</b></td><td colspan='1' class='center'><b>Return type</b></td><td colspan='1' class='center'><b>Note</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>typename X::type</span>  </td><td class='left'>
A type meeting Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::get(t)</span>  </td><td class='left'>
<span class='texttt'>X::type</span>  </td><td class='left'>
Shall not exit via an exception. Equivalent to <span class='texttt'>X::get(t, Executor())</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::get(t, e)</span>  </td><td class='left'>
<span class='texttt'>X::type</span>  </td><td class='left'>
 Shall not exit via an exception.  </td></tr></table></div></div><div id='async.assoc.exec.members'><h3 ><a class='secnum' href='#async.assoc.exec.members' style='min-width:103pt'>13.12.1</a> <span class='texttt'>associated_executor</span> members <a class='abbr_ref' href='async.assoc.exec.members'>[async.assoc.exec.members]</a></h3><p ><code class='itemdecl'>
using type = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='async.assoc.exec.members-1'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.exec.members-1'>1</a></div><div class='itemdescr'><p ><i>Type:</i> If the <span class='grammarterm'>qualified-id</span> <span class='texttt'>T::executor_type</span>
is valid and denotes a type (C++Std &sect;<a href='../n4140/temp.deduct'>[temp.deduct]</a>), <span class='texttt'>T::executor_type</span>.
Otherwise <span class='texttt'>Executor</span>.
</p></div></div><p ><code class='itemdecl'>
type get(const T&amp; t, const Executor&amp; e = Executor()) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.assoc.exec.members-2'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.exec.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> If the <span class='grammarterm'>qualified-id</span> <span class='texttt'>T::executor_type</span>
is valid and denotes a type (C++Std &sect;<a href='../n4140/temp.deduct'>[temp.deduct]</a>), <span class='texttt'>t.get_executor()</span>.
Otherwise <span class='texttt'>e</span>.
</p></div></div></div></div><div id='async.assoc.exec.get'><h2 ><a class='secnum' href='#async.assoc.exec.get' style='min-width:88pt'>13.13</a> Function <span class='texttt'>get_associated_executor</span> <a class='abbr_ref' href='async.assoc.exec.get'>[async.assoc.exec.get]</a></h2><p ><span class='indexparent'><a class='index' id='get_associated_executor'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  associated_executor_t&lt;T&gt; get_associated_executor(const T&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.assoc.exec.get-1'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.exec.get-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>associated_executor&lt;T&gt;::get(t)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class T, class Executor&gt;
  associated_executor_t&lt;T, Executor&gt;
    get_associated_executor(const T&amp; t, const Executor&amp; ex) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.assoc.exec.get-2'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.exec.get-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>associated_executor&lt;T, Executor&gt;::get(t, ex)</span>.</p></div></div><div class='para' id='async.assoc.exec.get-3'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.exec.get-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_executor_v&lt;Executor&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class T, class ExecutionContext&gt;
  associated_executor_t&lt;T, typename ExecutionContext::executor_type&gt;
    get_associated_executor(const T&amp; t, ExecutionContext&amp; ctx) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.assoc.exec.get-4'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.exec.get-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get_associated_executor(t, ctx.get_executor())</span>.</p></div></div><div class='para' id='async.assoc.exec.get-5'><div class='marginalizedparent'><a class='marginalized' href='#async.assoc.exec.get-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_convertible&lt;ExecutionContext&amp;, execution_context&amp;&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='async.exec.binder'><h2 ><a class='secnum' href='#async.exec.binder' style='min-width:88pt'>13.14</a> Class template <span class='texttt'>executor_binder</span> <a class='abbr_ref' href='async.exec.binder'>[async.exec.binder]</a></h2><p ><span class='indexparent'><a class='index' id='executor_binder'></a></span></p><div class='para' id='async.exec.binder-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder-1'>1</a></div><p >The class template <span class='texttt'>executor_binder</span> binds executors to objects.
A specialization <span class='texttt'>executor_binder&lt;T, Executor&gt;</span> binds
an executor of type <span class='texttt'>Executor</span> satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>)
to an object or function of type <span class='texttt'>T</span>.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class Executor&gt;
  class executor_binder
  {
  public:
    <span class='comment'>// types:
</span>
    using target_type = T;
    using executor_type = Executor;

    <span class='comment'>// construct / copy / destroy:
</span>
    executor_binder(T t, const Executor&amp; ex);
    executor_binder(const executor_binder&amp; other) = default;
    executor_binder(executor_binder&amp;&amp; other) = default;
    template&lt;class U, class OtherExecutor&gt;
      executor_binder(const executor_binder&lt;U, OtherExecutor&gt;&amp; other);
    template&lt;class U, class OtherExecutor&gt;
      executor_binder(executor_binder&lt;U, OtherExecutor&gt;&amp;&amp; other);
    template&lt;class U, class OtherExecutor&gt;
      executor_binder(executor_arg_t, const Executor&amp; ex,
        const executor_binder&lt;U, OtherExecutor&gt;&amp; other);
    template&lt;class U, class OtherExecutor&gt;
      executor_binder(executor_arg_t, const Executor&amp; ex,
        executor_binder&lt;U, OtherExecutor&gt;&amp;&amp; other);

    ~executor_binder();

    <span class='comment'>// executor binder access:
</span>
    T&amp; get() noexcept;
    const T&amp; get() const noexcept;
    executor_type get_executor() const noexcept;

    <span class='comment'>// executor binder invocation:
</span>
    template&lt;class... Args&gt;
      result_of_t&lt;T&amp;(Args&amp;&amp;...)&gt; operator()(Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      result_of_t&lt;const T&amp;(Args&amp;&amp;...)&gt; operator()(Args&amp;&amp;... args) const;

  private:
    Executor ex_; <span class='comment'>// <i>exposition only</i>
</span>    T target_; <span class='comment'>// <i>exposition only</i>
</span>  };

  template&lt;class T, class Executor, class Signature&gt;
    class async_result&lt;executor_binder&lt;T, Executor&gt;, Signature&gt;;

  template&lt;class T, class Executor, class ProtoAllocator&gt;
    struct associated_allocator&lt;executor_binder&lt;T, Executor&gt;, ProtoAllocator&gt;;

  template&lt;class T, class Executor, class Executor1&gt;
    struct associated_executor&lt;executor_binder&lt;T, Executor&gt;, Executor1&gt;;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div id='async.exec.binder.cons'><h3 ><a class='secnum' href='#async.exec.binder.cons' style='min-width:103pt'>13.14.1</a> <span class='texttt'>executor_binder</span> constructors <a class='abbr_ref' href='async.exec.binder.cons'>[async.exec.binder.cons]</a></h3><p ><span class='indexparent'><a class='index' id='executor_binder,constructor'></a></span><code class='itemdecl'>
executor_binder(T t, const Executor&amp; ex);
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.binder.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>ex</span>. Initializes <span class='texttt'>target_</span> by performing uses-executor construction, using the constructor argument <span class='texttt'>std::move(t)</span> and the executor <span class='texttt'>ex_</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class U, class OtherExecutor&gt;
  executor_binder(const executor_binder&lt;U, OtherExecutor&gt;&amp; other);
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.binder.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.cons-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>U</span> is not convertible to <span class='texttt'>T</span>, or if <span class='texttt'>OtherExecutor</span> is not convertible to <span class='texttt'>Executor</span>, the program is ill-formed.</p></div></div><div class='para' id='async.exec.binder.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>other.get_executor()</span>. Initializes <span class='texttt'>target_</span> by performing uses-executor construction, using the constructor argument <span class='texttt'>other.get()</span> and the executor <span class='texttt'>ex_</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class U, class OtherExecutor&gt;
  executor_binder(executor_binder&lt;U, OtherExecutor&gt;&amp;&amp; other);
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.binder.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.cons-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>U</span> is not convertible to <span class='texttt'>T</span>, or if <span class='texttt'>OtherExecutor</span> is not convertible to <span class='texttt'>Executor</span>, the program is ill-formed.</p></div></div><div class='para' id='async.exec.binder.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>other.get_executor()</span>. Initializes <span class='texttt'>target_</span> by performing uses-executor construction, using the constructor argument <span class='texttt'>std::move(other.get())</span> and the executor <span class='texttt'>ex_</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class U, class OtherExecutor&gt;
  executor_binder(executor_arg_t, const Executor&amp; ex,
    const executor_binder&lt;U, OtherExecutor&gt;&amp; other);
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.binder.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.cons-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>U</span> is not convertible to <span class='texttt'>T</span> the program is ill-formed.</p></div></div><div class='para' id='async.exec.binder.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.cons-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>ex</span>. Initializes <span class='texttt'>target_</span> by performing uses-executor construction, using the constructor argument <span class='texttt'>other.get()</span> and the executor <span class='texttt'>ex_</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class U, class OtherExecutor&gt;
  executor_binder(executor_arg_t, const Executor&amp; ex,
    executor_binder&lt;U, OtherExecutor&gt;&amp;&amp; other);
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.binder.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.cons-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>U</span> is <span class='texttt'>T</span> or convertible to <span class='texttt'>T</span>.</p></div></div><div class='para' id='async.exec.binder.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.cons-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>ex</span>. Initializes <span class='texttt'>target_</span> by performing uses-executor construction, using the constructor argument <span class='texttt'>std::move(other.get())</span> and the executor <span class='texttt'>ex_</span>.
</p></div></div></div><div id='async.exec.binder.access'><h3 ><a class='secnum' href='#async.exec.binder.access' style='min-width:103pt'>13.14.2</a> <span class='texttt'>executor_binder</span> access <a class='abbr_ref' href='async.exec.binder.access'>[async.exec.binder.access]</a></h3><p ><span class='indexparent'><a class='index' id='get,executor_binder'></a></span><span class='indexparent'><a class='index' id='executor_binder,get'></a></span><code class='itemdecl'>
T&amp; get() noexcept;
const T&amp; get() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.binder.access-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.access-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>target_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_executor,executor_binder'></a></span><span class='indexparent'><a class='index' id='executor_binder,get_executor'></a></span><code class='itemdecl'>
executor_type get_executor() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.binder.access-2'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.access-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>executor_</span>.
</p></div></div></div><div id='async.exec.binder.invocation'><h3 ><a class='secnum' href='#async.exec.binder.invocation' style='min-width:103pt'>13.14.3</a> <span class='texttt'>executor_binder</span> invocation <a class='abbr_ref' href='async.exec.binder.invocation'>[async.exec.binder.invocation]</a></h3><p ><span class='indexparent'><a class='index' id='operator(),executor_binder'></a></span><span class='indexparent'><a class='index' id='executor_binder,operator()'></a></span><code class='itemdecl'>
template&lt;class... Args&gt;
  result_of_t&lt;T&amp;(Args&amp;&amp;...)&gt; operator()(Args&amp;&amp;... args);
template&lt;class... Args&gt;
  result_of_t&lt;const T&amp;(Args&amp;&amp;...)&gt; operator()(Args&amp;&amp;... args) const;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.binder.invocation-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.invocation-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'><i>INVOKE</i>(get(), forward&lt;Args&gt;(args)...)</span> (C++Std &sect;<a href='../n4140/func.require'>[func.require]</a>).
</p></div></div></div><div id='async.exec.binder.async.result'><h3 ><a class='secnum' href='#async.exec.binder.async.result' style='min-width:103pt'>13.14.4</a> Class template partial specialization <span class='texttt'>async_result</span> <a class='abbr_ref' href='async.exec.binder.async.result'>[async.exec.binder.async.result]</a></h3><p ><span class='indexparent'><a class='index' id='async_result,specialization_for_executor_binder'></a></span><span class='indexparent'><a class='index' id='async_result'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class Executor, class Signature&gt;
  class async_result&lt;executor_binder&lt;T, Executor&gt;, Signature&gt;
  {
  public:
    using completion_handler_type = executor_binder&lt;
      typename async_result&lt;T, Signature&gt;::completion_handler_type,
        Executor&gt;;
    using return_type = typename async_result&lt;T, Signature&gt;::return_type;

    explicit async_result(completion_handler_type&amp; h);
    async_result(const async_result&amp;) = delete;
    async_result&amp; operator=(const async_result&amp;) = delete;

    return_type get();

  private:
    async_result&lt;T, Signature&gt; target_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><code class='itemdecl'>
explicit async_result(completion_handler_type&amp; h);
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.binder.async.result-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.async.result-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>target_</span> as <span class='texttt'>target_(h.get())</span>.
</p></div></div><p ><code class='itemdecl'>
return_type get();
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.binder.async.result-2'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.async.result-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>target_.get()</span>.
</p></div></div></div><div id='async.exec.binder.assoc.alloc'><h3 ><a class='secnum' href='#async.exec.binder.assoc.alloc' style='min-width:103pt'>13.14.5</a> Class template partial specialization <span class='texttt'>associated_allocator</span> <a class='abbr_ref' href='async.exec.binder.assoc.alloc'>[async.exec.binder.assoc.alloc]</a></h3><p ><span class='indexparent'><a class='index' id='associated_allocator,specialization_for_executor_binder'></a></span><span class='indexparent'><a class='index' id='associated_allocator'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class Executor, class ProtoAllocator&gt;
    struct associated_allocator&lt;executor_binder&lt;T, Executor&gt;, ProtoAllocator&gt;
  {
    using type = associated_allocator_t&lt;T, ProtoAllocator&gt;;

    static type get(const executor_binder&lt;T, Executor&gt;&amp; b,
                    const ProtoAllocator&amp; a = ProtoAllocator()) noexcept;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><code class='itemdecl'>
static type get(const executor_binder&lt;T, Executor&gt;&amp; b,
                const ProtoAllocator&amp; a = ProtoAllocator()) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.binder.assoc.alloc-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.assoc.alloc-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>associated_allocator&lt;T, ProtoAllocator&gt;::get(b.get(), a)</span>.
</p></div></div></div><div id='async.exec.binder.assoc.exec'><h3 ><a class='secnum' href='#async.exec.binder.assoc.exec' style='min-width:103pt'>13.14.6</a> Class template partial specialization <span class='texttt'>associated_executor</span> <a class='abbr_ref' href='async.exec.binder.assoc.exec'>[async.exec.binder.assoc.exec]</a></h3><p ><span class='indexparent'><a class='index' id='associated_executor,specialization_for_executor_binder'></a></span><span class='indexparent'><a class='index' id='associated_executor'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class Executor, class Executor1&gt;
    struct associated_executor&lt;executor_binder&lt;T, Executor&gt;, Executor1&gt;
  {
    using type = Executor;

    static type get(const executor_binder&lt;T, Executor&gt;&amp; b,
                    const Executor1&amp; e = Executor1()) noexcept;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><code class='itemdecl'>
static type get(const executor_binder&lt;T, Executor&gt;&amp; b,
                const Executor1&amp; e = Executor1()) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.binder.assoc.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.binder.assoc.exec-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>b.get_executor()</span>.
</p></div></div></div></div><div id='async.bind.executor'><h2 ><a class='secnum' href='#async.bind.executor' style='min-width:88pt'>13.15</a> Function <span class='texttt'>bind_executor</span> <a class='abbr_ref' href='async.bind.executor'>[async.bind.executor]</a></h2><p ><span class='indexparent'><a class='index' id='bind_executor'></a></span><code class='itemdecl'>
template&lt;class Executor, class T&gt;
  executor_binder&lt;decay_t&lt;T&gt;, Executor&gt;
    bind_executor(const Executor&amp; ex, T&amp;&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='async.bind.executor-1'><div class='marginalizedparent'><a class='marginalized' href='#async.bind.executor-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>executor_binder&lt;decay_t&lt;T&gt;, Executor&gt;(forward&lt;T&gt;(t), ex)</span>.</p></div></div><div class='para' id='async.bind.executor-2'><div class='marginalizedparent'><a class='marginalized' href='#async.bind.executor-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_executor_v&lt;Executor&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bind_executor'></a></span><code class='itemdecl'>
template&lt;class ExecutionContext, class CompletionToken&gt;
  executor_binder&lt;decay_t&lt;T&gt;, typename ExecutionContext::executor_type&gt;
    bind_executor(ExecutionContext&amp; ctx, T&amp;&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='async.bind.executor-3'><div class='marginalizedparent'><a class='marginalized' href='#async.bind.executor-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>bind_executor(ctx.get_executor(), forward&lt;T&gt;(t))</span>.</p></div></div><div class='para' id='async.bind.executor-4'><div class='marginalizedparent'><a class='marginalized' href='#async.bind.executor-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_convertible&lt;ExecutionContext&amp;, execution_context&amp;&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='async.exec.work.guard'><h2 ><a class='secnum' href='#async.exec.work.guard' style='min-width:88pt'>13.16</a> Class template <span class='texttt'>executor_work_guard</span> <a class='abbr_ref' href='async.exec.work.guard'>[async.exec.work.guard]</a></h2><p ><span class='indexparent'><a class='index' id='executor_work_guard'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Executor&gt;
  class executor_work_guard
  {
  public:
    <span class='comment'>// types:
</span>
    using executor_type = Executor;

    <span class='comment'>// construct / copy / destroy:
</span>
    explicit executor_work_guard(const executor_type&amp; ex) noexcept;
    executor_work_guard(const executor_work_guard&amp; other) noexcept;
    executor_work_guard(executor_work_guard&amp;&amp; other) noexcept;

    executor_work_guard&amp; operator=(const executor_work_guard&amp;) = delete;

    ~executor_work_guard();

    <span class='comment'>// executor work guard observers:
</span>
    executor_type get_executor() const noexcept;
    bool owns_work() const noexcept;

    <span class='comment'>// executor work guard modifiers:
</span>
    void reset() noexcept;

  private:
    Executor ex_; <span class='comment'>// <i>exposition only</i>
</span>    bool owns_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div id='async.exec.work.guard.members'><h3 ><a class='secnum' href='#async.exec.work.guard.members' style='min-width:103pt'>13.16.1</a> <span class='texttt'>executor_work_guard</span> members <a class='abbr_ref' href='async.exec.work.guard.members'>[async.exec.work.guard.members]</a></h3><p ><span class='indexparent'><a class='index' id='executor_work_guard,constructor'></a></span><code class='itemdecl'>
explicit executor_work_guard(const executor_type&amp; ex) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.work.guard.members-1'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.work.guard.members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>ex</span>, and then performs <span class='texttt'>ex_.on_work_started()</span>.</p></div></div><div class='para' id='async.exec.work.guard.members-2'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.work.guard.members-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>ex_ == ex</span> and <span class='texttt'>owns_ == true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor_work_guard,constructor'></a></span><code class='itemdecl'>
executor_work_guard(const executor_work_guard&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.work.guard.members-3'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.work.guard.members-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>other.ex_</span>. If <span class='texttt'>other.owns_ == true</span>, performs <span class='texttt'>ex_.on_work_started()</span>.</p></div></div><div class='para' id='async.exec.work.guard.members-4'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.work.guard.members-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>ex_ == other.ex_</span> and <span class='texttt'>owns_ == other.owns_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor_work_guard,constructor'></a></span><code class='itemdecl'>
executor_work_guard(executor_work_guard&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.work.guard.members-5'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.work.guard.members-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>ex_</span> with <span class='texttt'>std::move(other.ex_)</span>
and initializes <span class='texttt'>owns_</span> with <span class='texttt'>other.owns_</span>,
and sets <span class='texttt'>other.owns_</span> to <span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor_work_guard,destructor'></a></span><code class='itemdecl'>
~executor_work_guard();
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.work.guard.members-6'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.work.guard.members-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>owns_</span> is <span class='texttt'>true</span>, performs <span class='texttt'>ex_.on_work_finished()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_executor,executor_work_guard'></a></span><span class='indexparent'><a class='index' id='executor_work_guard,get_executor'></a></span><code class='itemdecl'>
executor_type get_executor() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.work.guard.members-7'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.work.guard.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>ex_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='owns_work,executor_work_guard'></a></span><span class='indexparent'><a class='index' id='executor_work_guard,owns_work'></a></span><code class='itemdecl'>
bool owns_work() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.work.guard.members-8'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.work.guard.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>owns_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reset,executor_work_guard'></a></span><span class='indexparent'><a class='index' id='executor_work_guard,reset'></a></span><code class='itemdecl'>
void reset() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.exec.work.guard.members-9'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.work.guard.members-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>owns_</span> is <span class='texttt'>true</span>, performs <span class='texttt'>ex_.on_work_finished()</span>.</p></div></div><div class='para' id='async.exec.work.guard.members-10'><div class='marginalizedparent'><a class='marginalized' href='#async.exec.work.guard.members-10'>10</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>owns_ == false</span>.
</p></div></div></div></div><div id='async.make.work.guard'><h2 ><a class='secnum' href='#async.make.work.guard' style='min-width:88pt'>13.17</a> Function <span class='texttt'>make_work_guard</span> <a class='abbr_ref' href='async.make.work.guard'>[async.make.work.guard]</a></h2><p ><span class='indexparent'><a class='index' id='make_work_guard'></a></span><code class='itemdecl'>
template&lt;class Executor&gt;
  executor_work_guard&lt;Executor&gt;
    make_work_guard(const Executor&amp; ex);
</code></p><div class='itemdescr'></div><div class='para' id='async.make.work.guard-1'><div class='marginalizedparent'><a class='marginalized' href='#async.make.work.guard-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>executor_work_guard&lt;Executor&gt;(ex)</span>.</p></div></div><div class='para' id='async.make.work.guard-2'><div class='marginalizedparent'><a class='marginalized' href='#async.make.work.guard-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_executor_v&lt;Executor&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_work_guard'></a></span><code class='itemdecl'>
template&lt;class ExecutionContext&gt;
  executor_work_guard&lt;typename ExecutionContext::executor_type&gt;
    make_work_guard(ExecutionContext&amp; ctx);
</code></p><div class='itemdescr'></div><div class='para' id='async.make.work.guard-3'><div class='marginalizedparent'><a class='marginalized' href='#async.make.work.guard-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>make_work_guard(ctx.get_executor())</span>.</p></div></div><div class='para' id='async.make.work.guard-4'><div class='marginalizedparent'><a class='marginalized' href='#async.make.work.guard-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution
unless <span class='texttt'>is_convertible&lt;ExecutionContext&amp;, execution_context&amp;&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_work_guard'></a></span><code class='itemdecl'>
template&lt;class T&gt;
  executor_work_guard&lt;associated_executor_t&lt;T&gt;&gt;
    make_work_guard(const T&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='async.make.work.guard-5'><div class='marginalizedparent'><a class='marginalized' href='#async.make.work.guard-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>make_work_guard(get_associated_executor(t))</span>.</p></div></div><div class='para' id='async.make.work.guard-6'><div class='marginalizedparent'><a class='marginalized' href='#async.make.work.guard-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_executor_v&lt;T&gt;</span> is <span class='texttt'>false</span>
and <span class='texttt'>is_convertible&lt;T&amp;, execution_context&amp;&gt;::value</span> is <span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_work_guard'></a></span><code class='itemdecl'>
template&lt;class T, class U&gt;
  auto make_work_guard(const T&amp; t, U&amp;&amp; u)
    -&gt; decltype(make_work_guard(get_associated_executor(t, forward&lt;U&gt;(u))));
</code></p><div class='itemdescr'></div><div class='para' id='async.make.work.guard-7'><div class='marginalizedparent'><a class='marginalized' href='#async.make.work.guard-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>make_work_guard(get_associated_executor(t, forward&lt;U&gt;(u)))</span>.
</p></div></div></div><div id='async.system.exec'><h2 ><a class='secnum' href='#async.system.exec' style='min-width:88pt'>13.18</a> Class <span class='texttt'>system_executor</span> <a class='abbr_ref' href='async.system.exec'>[async.system.exec]</a></h2><p ><span class='indexparent'><a class='index' id='system_executor'></a></span></p><div class='para' id='async.system.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#async.system.exec-1'>1</a></div><p >Class <span class='texttt'>system_executor</span> represents a set of rules where function objects are permitted to execute on any thread.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class system_executor
  {
  public:
    <span class='comment'>// constructors:
</span>
    system_executor() {}

    <span class='comment'>// executor operations:
</span>
    system_context&amp; context() const noexcept;

    void on_work_started() const noexcept {}
    void on_work_finished() const noexcept {}

    template&lt;class Func, class ProtoAllocator&gt;
      void dispatch(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
    template&lt;class Func, class ProtoAllocator&gt;
      void post(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
    template&lt;class Func, class ProtoAllocator&gt;
      void defer(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
  };

  bool operator==(const system_executor&amp;, const system_executor&amp;) noexcept;
  bool operator!=(const system_executor&amp;, const system_executor&amp;) noexcept;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='async.system.exec-2'><div class='marginalizedparent'><a class='marginalized' href='#async.system.exec-2'>2</a></div><p >Class <span class='texttt'>system_executor</span> satisfies the <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>DefaultConstructible</span> (C++Std &sect;<a href='../n4140/defaultconstructible'>[defaultconstructible]</a>), and <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) type requirements.</p></div><div class='para' id='async.system.exec-3'><div class='marginalizedparent'><a class='marginalized' href='#async.system.exec-3'>3</a></div><p >To satisfy the <span class='texttt'>Executor</span> requirements for the <span class='texttt'>post</span> and <span class='texttt'>defer</span> member functions, the system executor may create <span class='texttt'>thread</span> objects to run the submitted function objects. These <span class='texttt'>thread</span> objects are collectively referred to as system threads.</p></div><div id='async.system.exec.ops'><h3 ><a class='secnum' href='#async.system.exec.ops' style='min-width:103pt'>13.18.1</a> <span class='texttt'>system_executor</span> operations <a class='abbr_ref' href='async.system.exec.ops'>[async.system.exec.ops]</a></h3><p ><span class='indexparent'><a class='index' id='context,system_executor'></a></span><span class='indexparent'><a class='index' id='system_executor,context'></a></span><code class='itemdecl'>
system_context&amp; context() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.system.exec.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#async.system.exec.ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to an object with static storage duration. All calls to this function return references to the same object.
</p></div></div><p ><span class='indexparent'><a class='index' id='dispatch,system_executor'></a></span><span class='indexparent'><a class='index' id='system_executor,dispatch'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void dispatch(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='async.system.exec.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#async.system.exec.ops-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'><i>DECAY_COPY</i>(forward&lt;Func&gt;(f))()</span> (C++Std &sect;<a href='../n4140/thread.decaycopy'>[thread.decaycopy]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='post,system_executor'></a></span><span class='indexparent'><a class='index' id='system_executor,post'></a></span><span class='indexparent'><a class='index' id='defer,system_executor'></a></span><span class='indexparent'><a class='index' id='system_executor,defer'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void post(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
template&lt;class Func, class ProtoAllocator&gt;
  void defer(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='async.system.exec.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#async.system.exec.ops-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>context().stopped() == false</span>, creates an object <span class='texttt'>f1</span> initialized with <span class='texttt'><i>DECAY_COPY</i>(forward&lt;Func&gt;(f))</span>, and calls <span class='texttt'>f1</span> as if in a thread of execution represented by a <span class='texttt'>thread</span> object. Any exception propagated from the execution of <span class='texttt'><i>DECAY_COPY</i>(forward&lt;Func&gt;(f))()</span> results in a call to <span class='texttt'>std::terminate</span>.
</p></div></div></div><div id='async.system.exec.comparisons'><h3 ><a class='secnum' href='#async.system.exec.comparisons' style='min-width:103pt'>13.18.2</a> <span class='texttt'>system_executor</span> comparisons <a class='abbr_ref' href='async.system.exec.comparisons'>[async.system.exec.comparisons]</a></h3><p ><span class='indexparent'><a class='index' id='operator==,system_executor'></a></span><span class='indexparent'><a class='index' id='system_executor,operator=='></a></span><code class='itemdecl'>
bool operator==(const system_executor&amp;, const system_executor&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.system.exec.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#async.system.exec.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,system_executor'></a></span><span class='indexparent'><a class='index' id='system_executor,operator!='></a></span><code class='itemdecl'>
bool operator!=(const system_executor&amp;, const system_executor&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.system.exec.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#async.system.exec.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>false</span>.
</p></div></div></div></div><div id='async.system.context'><h2 ><a class='secnum' href='#async.system.context' style='min-width:88pt'>13.19</a> Class <span class='texttt'>system_context</span> <a class='abbr_ref' href='async.system.context'>[async.system.context]</a></h2><p ><span class='indexparent'><a class='index' id='system_context'></a></span></p><div class='para' id='async.system.context-1'><div class='marginalizedparent'><a class='marginalized' href='#async.system.context-1'>1</a></div><p >Class <span class='texttt'>system_context</span> implements the execution context associated with <span class='texttt'>system_executor</span> objects.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class system_context : public execution_context
  {
  public:
    <span class='comment'>// types:
</span>
    using executor_type = system_executor;

    <span class='comment'>// construct / copy / destroy:
</span>
    system_context() = delete;
    system_context(const system_context&amp;) = delete;
    system_context&amp; operator=(const system_context&amp;) = delete;
    ~system_context();

    <span class='comment'>// system_context operations:
</span>
    executor_type get_executor() noexcept;

    void stop();
    bool stopped() const noexcept;
    void join();
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='async.system.context-2'><div class='marginalizedparent'><a class='marginalized' href='#async.system.context-2'>2</a></div><p >The class <span class='texttt'>system_context</span> satisfies the <span class='texttt'>ExecutionContext</span> (<a href='async.reqmts.executioncontext'>[async.reqmts.executioncontext]</a>) type requirements.</p></div><div class='para' id='async.system.context-3'><div class='marginalizedparent'><a class='marginalized' href='#async.system.context-3'>3</a></div><p >The <span class='texttt'>system_context</span> member functions <span class='texttt'>get_executor</span>, <span class='texttt'>stop</span>, and <span class='texttt'>stopped</span>, and the <span class='texttt'>system_executor</span> copy constructors, member functions and comparison operators, do not introduce data races as a result of concurrent calls to those functions from different threads of execution.</p><p ><span class='indexparent'><a class='index' id='system_context,destructor'></a></span><code class='itemdecl'>
~system_context();
</code></p></div><div class='itemdescr'></div><div class='para' id='async.system.context-4'><div class='marginalizedparent'><a class='marginalized' href='#async.system.context-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Performs <span class='texttt'>stop()</span> followed by <span class='texttt'>join()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_executor,system_context'></a></span><span class='indexparent'><a class='index' id='system_context,get_executor'></a></span><code class='itemdecl'>
executor_type get_executor() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.system.context-5'><div class='marginalizedparent'><a class='marginalized' href='#async.system.context-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>system_executor()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='stop,system_context'></a></span><span class='indexparent'><a class='index' id='system_context,stop'></a></span><code class='itemdecl'>
void stop();
</code></p><div class='itemdescr'></div><div class='para' id='async.system.context-6'><div class='marginalizedparent'><a class='marginalized' href='#async.system.context-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Signals all system threads to exit as soon as possible. If a system thread is currently executing a function object, the thread will exit only after completion of that function object. Returns without waiting for the system threads to complete.</p></div></div><div class='para' id='async.system.context-7'><div class='marginalizedparent'><a class='marginalized' href='#async.system.context-7'>7</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>stopped() == true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='stopped,system_context'></a></span><span class='indexparent'><a class='index' id='system_context,stopped'></a></span><code class='itemdecl'>
bool stopped() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.system.context-8'><div class='marginalizedparent'><a class='marginalized' href='#async.system.context-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the <span class='texttt'>system_context</span> has been stopped by a prior call to <span class='texttt'>stop</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='join,system_context'></a></span><span class='indexparent'><a class='index' id='system_context,join'></a></span><code class='itemdecl'>
void join();
</code></p><div class='itemdescr'></div><div class='para' id='async.system.context-9'><div class='marginalizedparent'><a class='marginalized' href='#async.system.context-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Blocks the calling thread (C++Std &sect;<a href='../n4140/defns.block'>[defns.block]</a>) until all system threads have completed.</p></div></div><div class='para' id='async.system.context-10'><div class='marginalizedparent'><a class='marginalized' href='#async.system.context-10'>10</a></div><div class='itemdescr'><p ><i>Synchronization:</i> The completion of each system thread synchronizes with (C++Std &sect;<a href='../n4140/intro.multithread'>[intro.multithread]</a>) the corresponding successful <span class='texttt'>join()</span> return.
</p></div></div></div><div id='async.bad.exec'><h2 ><a class='secnum' href='#async.bad.exec' style='min-width:88pt'>13.20</a> Class <span class='texttt'>bad_executor</span> <a class='abbr_ref' href='async.bad.exec'>[async.bad.exec]</a></h2><p ><span class='indexparent'><a class='index' id='bad_executor'></a></span></p><div class='para' id='async.bad.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#async.bad.exec-1'>1</a></div><p >An exception of type <span class='texttt'>bad_executor</span> is thrown by <span class='texttt'>executor</span> member functions <span class='texttt'>dispatch</span>, <span class='texttt'>post</span>, and <span class='texttt'>defer</span> when the executor object has no target.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class bad_executor : public exception
  {
  public:
    <span class='comment'>// constructor:
</span>    bad_executor() noexcept;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><code class='itemdecl'>
bad_executor() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='async.bad.exec-2'><div class='marginalizedparent'><a class='marginalized' href='#async.bad.exec-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> constructs a <span class='texttt'>bad_executor</span> object.</p></div></div><div class='para' id='async.bad.exec-3'><div class='marginalizedparent'><a class='marginalized' href='#async.bad.exec-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>what()</span> returns an <span class='indexparent'><a class='index' id='result_of_bad_executor::what'></a></span>implementation-defined <span class='textsc'>ntbs</span>.
</p></div></div></div><div id='async.executor'><h2 ><a class='secnum' href='#async.executor' style='min-width:88pt'>13.21</a> Class <span class='texttt'>executor</span> <a class='abbr_ref' href='async.executor'>[async.executor]</a></h2><p ><span class='indexparent'><a class='index' id='executor'></a></span></p><div class='para' id='async.executor-1'><div class='marginalizedparent'><a class='marginalized' href='#async.executor-1'>1</a></div><p >The <span class='texttt'>executor</span> class provides a polymorphic wrapper for types that satisfy the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class executor
  {
  public:
    <span class='comment'>// construct / copy / destroy:
</span>
    executor() noexcept;
    executor(nullptr_t) noexcept;
    executor(const executor&amp; e) noexcept;
    executor(executor&amp;&amp; e) noexcept;
    template&lt;class Executor&gt; executor(Executor e);
    template&lt;class Executor, class ProtoAllocator&gt;
      executor(allocator_arg_t, const ProtoAllocator&amp; a, Executor e);

    executor&amp; operator=(const executor&amp; e) noexcept;
    executor&amp; operator=(executor&amp;&amp; e) noexcept;
    executor&amp; operator=(nullptr_t) noexcept;
    template&lt;class Executor&gt; executor&amp; operator=(Executor e);

    ~executor();

    <span class='comment'>// executor modifiers:
</span>
    void swap(executor&amp; other) noexcept;
    template&lt;class Executor, class ProtoAllocator&gt;
      void assign(Executor e, const ProtoAllocator&amp; a);

    <span class='comment'>// executor operations:
</span>
    execution_context&amp; context() const noexcept;

    void on_work_started() const noexcept;
    void on_work_finished() const noexcept;

    template&lt;class Func, class ProtoAllocator&gt;
      void dispatch(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
    template&lt;class Func, class ProtoAllocator&gt;
      void post(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
    template&lt;class Func, class ProtoAllocator&gt;
      void defer(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;

    <span class='comment'>// executor capacity:
</span>
    explicit operator bool() const noexcept;

    <span class='comment'>// executor target access:
</span>
    const type_info&amp; target_type() const noexcept;
    template&lt;class Executor&gt; Executor* target() noexcept;
    template&lt;class Executor&gt; const Executor* target() const noexcept;
  };

  <span class='comment'>// executor comparisons:
</span>
  bool operator==(const executor&amp; a, const executor&amp; b) noexcept;
  bool operator==(const executor&amp; e, nullptr_t) noexcept;
  bool operator==(nullptr_t, const executor&amp; e) noexcept;
  bool operator!=(const executor&amp; a, const executor&amp; b) noexcept;
  bool operator!=(const executor&amp; e, nullptr_t) noexcept;
  bool operator!=(nullptr_t, const executor&amp; e) noexcept;

  <span class='comment'>// executor specialized algorithms:
</span>
  void swap(executor&amp; a, executor&amp; b) noexcept;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>
  template&lt;class Allocator&gt;
    struct uses_allocator&lt;experimental::net::v1::executor, Allocator&gt;
      : true_type {};

} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='async.executor-2'><div class='marginalizedparent'><a class='marginalized' href='#async.executor-2'>2</a></div><p >Class <span class='texttt'>executor</span> meets the requirements of <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>), <span class='texttt'>DefaultConstructible</span> (C++Std &sect;<a href='../n4140/defaultconstructible'>[defaultconstructible]</a>), and <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>).</p></div><div class='para' id='async.executor-3'><div class='marginalizedparent'><a class='marginalized' href='#async.executor-3'>3</a></div><p >[&nbsp;<i>Note:</i> To meet the <span class='texttt'>noexcept</span> requirements for executor copy constructors and move constructors, implementations may share a target between two or more <span class='texttt'>executor</span> objects. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='async.executor-4'><div class='marginalizedparent'><a class='marginalized' href='#async.executor-4'>4</a></div><p >The <a class='hidden_link' href='#def:target,executor' id='def:target,executor'><i>target</i></a> is the executor object that is held by the wrapper.</p></div><div id='async.executor.cons'><h3 ><a class='secnum' href='#async.executor.cons' style='min-width:103pt'>13.21.1</a> <span class='texttt'>executor</span> constructors <a class='abbr_ref' href='async.executor.cons'>[async.executor.cons]</a></h3><p ><span class='indexparent'><a class='index' id='executor,constructor'></a></span><code class='itemdecl'>
executor() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor,constructor'></a></span><code class='itemdecl'>
executor(nullptr_t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor,constructor'></a></span><code class='itemdecl'>
executor(const executor&amp; e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!*this</span> if <span class='texttt'>!e</span>; otherwise, <span class='texttt'>*this</span> targets <span class='texttt'>e.target()</span> or a copy of <span class='texttt'>e.target()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor,constructor'></a></span><code class='itemdecl'>
executor(executor&amp;&amp; e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>!e</span>, <span class='texttt'>*this</span> has no target; otherwise, moves <span class='texttt'>e.target()</span> or move-constructs the target of <span class='texttt'>e</span> into the target of <span class='texttt'>*this</span>, leaving <span class='texttt'>e</span> in a valid state with an unspecified value.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor,constructor'></a></span><code class='itemdecl'>
template&lt;class Executor&gt; executor(Executor e);
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>*this</span> targets a copy of <span class='texttt'>e</span> initialized with <span class='texttt'>std::move(e)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='executor,constructor'></a></span><code class='itemdecl'>
template&lt;class Executor, class ProtoAllocator&gt;
  executor(allocator_arg_t, const ProtoAllocator&amp; a, Executor e);
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.cons-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>*this</span> targets a copy of <span class='texttt'>e</span> initialized with <span class='texttt'>std::move(e)</span>.</p></div></div><div class='para' id='async.executor.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.cons-7'>7</a></div><div class='itemdescr'><p >A copy of the allocator argument is used to allocate memory, if necessary, for the internal data structures of the constructed <span class='texttt'>executor</span> object.
</p></div></div></div><div id='async.executor.assign'><h3 ><a class='secnum' href='#async.executor.assign' style='min-width:103pt'>13.21.2</a> <span class='texttt'>executor</span> assignment <a class='abbr_ref' href='async.executor.assign'>[async.executor.assign]</a></h3><p ><span class='indexparent'><a class='index' id='operator=,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator='></a></span><code class='itemdecl'>
executor&amp; operator=(const executor&amp; e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>executor(e).swap(*this)</span>.</p></div></div><div class='para' id='async.executor.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator='></a></span><code class='itemdecl'>
executor&amp; operator=(executor&amp;&amp; e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.assign-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Replaces the target of <span class='texttt'>*this</span> with the target of <span class='texttt'>e</span>, leaving <span class='texttt'>e</span> in a valid state with an unspecified value.</p></div></div><div class='para' id='async.executor.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.assign-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator='></a></span><code class='itemdecl'>
executor&amp; operator=(nullptr_t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.assign-5'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.assign-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>executor(nullptr).swap(*this)</span>.</p></div></div><div class='para' id='async.executor.assign-6'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.assign-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator='></a></span><code class='itemdecl'>
template&lt;class Executor&gt; executor&amp; operator=(Executor e);
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.assign-7'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.assign-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>executor(std::move(e)).swap(*this)</span>.</p></div></div><div class='para' id='async.executor.assign-8'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.assign-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='async.executor.dtor'><h3 ><a class='secnum' href='#async.executor.dtor' style='min-width:103pt'>13.21.3</a> <span class='texttt'>executor</span> destructor <a class='abbr_ref' href='async.executor.dtor'>[async.executor.dtor]</a></h3><p ><span class='indexparent'><a class='index' id='executor,destructor'></a></span><code class='itemdecl'>
~executor();
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>*this != nullptr</span>, releases shared ownership of, or destroys, the target of <span class='texttt'>*this</span>.
</p></div></div></div><div id='async.executor.modifiers'><h3 ><a class='secnum' href='#async.executor.modifiers' style='min-width:103pt'>13.21.4</a> <span class='texttt'>executor</span> modifiers <a class='abbr_ref' href='async.executor.modifiers'>[async.executor.modifiers]</a></h3><p ><span class='indexparent'><a class='index' id='swap,executor'></a></span><span class='indexparent'><a class='index' id='executor,swap'></a></span><code class='itemdecl'>
void swap(executor&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.modifiers-1'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.modifiers-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Interchanges the targets of <span class='texttt'>*this</span> and <span class='texttt'>other</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='assign,executor'></a></span><span class='indexparent'><a class='index' id='executor,assign'></a></span><code class='itemdecl'>
template&lt;class Executor, class ProtoAllocator&gt;
  void assign(Executor e, const ProtoAllocator&amp; a);
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.modifiers-2'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.modifiers-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>executor(allocator_arg, a, std::move(e)).swap(*this)</span>.
</p></div></div></div><div id='async.executor.ops'><h3 ><a class='secnum' href='#async.executor.ops' style='min-width:103pt'>13.21.5</a> <span class='texttt'>executor</span> operations <a class='abbr_ref' href='async.executor.ops'>[async.executor.ops]</a></h3><p ><span class='indexparent'><a class='index' id='context,executor'></a></span><span class='indexparent'><a class='index' id='executor,context'></a></span><code class='itemdecl'>
execution_context&amp; context() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.ops-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>*this != nullptr</span>.</p></div></div><div class='para' id='async.executor.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.ops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>e.context()</span>, where <span class='texttt'>e</span> is the target object of <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='on_work_started,executor'></a></span><span class='indexparent'><a class='index' id='executor,on_work_started'></a></span><code class='itemdecl'>
void on_work_started() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.ops-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>*this != nullptr</span>.</p></div></div><div class='para' id='async.executor.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.ops-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>e.on_work_started()</span>, where <span class='texttt'>e</span> is the target object of <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='on_work_finished,executor'></a></span><span class='indexparent'><a class='index' id='executor,on_work_finished'></a></span><code class='itemdecl'>
void on_work_finished() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.ops-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>*this != nullptr</span>.</p></div></div><div class='para' id='async.executor.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.ops-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>e.on_work_finished()</span>, where <span class='texttt'>e</span> is the target object of <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='dispatch,executor'></a></span><span class='indexparent'><a class='index' id='executor,dispatch'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void dispatch(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.ops-7'>7</a></div><div class='itemdescr'><p >Let <span class='texttt'>e</span> be the target object of <span class='texttt'>*this</span>. Let <span class='texttt'>a1</span> be the allocator that was specified when the target was set. Let <span class='texttt'>fd</span> be the result of <span class='texttt'><i>DECAY_COPY</i>(f)</span> (C++Std &sect;<a href='../n4140/thread.decaycopy'>[thread.decaycopy]</a>).</p></div></div><div class='para' id='async.executor.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.ops-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>e.dispatch(g, a1)</span>, where <span class='texttt'>g</span> is a function object of unspecified type that, when called as <span class='texttt'>g()</span>, performs <span class='texttt'>fd()</span>. The allocator <span class='texttt'>a</span> is used to allocate any memory required to implement <span class='texttt'>g</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='post,executor'></a></span><span class='indexparent'><a class='index' id='executor,post'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void post(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.ops-9'>9</a></div><div class='itemdescr'><p >Let <span class='texttt'>e</span> be the target object of <span class='texttt'>*this</span>. Let <span class='texttt'>a1</span> be the allocator that was specified when the target was set. Let <span class='texttt'>fd</span> be the result of <span class='texttt'><i>DECAY_COPY</i>(f)</span>.</p></div></div><div class='para' id='async.executor.ops-10'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.ops-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>e.post(g, a1)</span>, where <span class='texttt'>g</span> is a function object of unspecified type that, when called as <span class='texttt'>g()</span>, performs <span class='texttt'>fd()</span>. The allocator <span class='texttt'>a</span> is used to allocate any memory required to implement <span class='texttt'>g</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='defer,executor'></a></span><span class='indexparent'><a class='index' id='executor,defer'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void defer(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.ops-11'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.ops-11'>11</a></div><div class='itemdescr'><p >Let <span class='texttt'>e</span> be the target object of <span class='texttt'>*this</span>. Let <span class='texttt'>a1</span> be the allocator that was specified when the target was set. Let <span class='texttt'>fd</span> be the result of <span class='texttt'><i>DECAY_COPY</i>(f)</span>.</p></div></div><div class='para' id='async.executor.ops-12'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.ops-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>e.defer(g, a1)</span>, where <span class='texttt'>g</span> is a function object of unspecified type that, when called as <span class='texttt'>g()</span>, performs <span class='texttt'>fd()</span>. The allocator <span class='texttt'>a</span> is used to allocate any memory required to implement <span class='texttt'>g</span>.
</p></div></div></div><div id='async.executor.capacity'><h3 ><a class='secnum' href='#async.executor.capacity' style='min-width:103pt'>13.21.6</a> <span class='texttt'>executor</span> capacity <a class='abbr_ref' href='async.executor.capacity'>[async.executor.capacity]</a></h3><p ><span class='indexparent'><a class='index' id='operator_bool,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator_bool'></a></span><code class='itemdecl'>
explicit operator bool() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.capacity-1'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.capacity-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>*this</span> has a target, otherwise <span class='texttt'>false</span>.
</p></div></div></div><div id='async.executor.target'><h3 ><a class='secnum' href='#async.executor.target' style='min-width:103pt'>13.21.7</a> <span class='texttt'>executor</span> target access <a class='abbr_ref' href='async.executor.target'>[async.executor.target]</a></h3><p ><span class='indexparent'><a class='index' id='target_type,executor'></a></span><span class='indexparent'><a class='index' id='executor,target_type'></a></span><code class='itemdecl'>
const type_info&amp; target_type() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.target-1'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.target-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>*this</span> has a target of type <span class='texttt'>T</span>, <span class='texttt'>typeid(T)</span>; otherwise, <span class='texttt'>typeid(void)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='target,executor'></a></span><span class='indexparent'><a class='index' id='executor,target'></a></span><code class='itemdecl'>
template&lt;class Executor&gt; Executor* target() noexcept;
template&lt;class Executor&gt; const Executor* target() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.target-2'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.target-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>target_type() == typeid(Executor)</span> a pointer to the stored executor target; otherwise a null pointer value.
</p></div></div></div><div id='async.executor.comparisons'><h3 ><a class='secnum' href='#async.executor.comparisons' style='min-width:103pt'>13.21.8</a> <span class='texttt'>executor</span> comparisons <a class='abbr_ref' href='async.executor.comparisons'>[async.executor.comparisons]</a></h3><p ><span class='indexparent'><a class='index' id='operator==,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator=='></a></span><code class='itemdecl'>
bool operator==(const executor&amp; a, const executor&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><ul class='itemize'><li id='async.executor.comparisons-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.executor.comparisons-1.1'>(1.1)</a></div><p ><span class='texttt'>true</span> if <span class='texttt'>!a</span> and <span class='texttt'>!b</span>;
</p></li><li id='async.executor.comparisons-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.executor.comparisons-1.2'>(1.2)</a></div><p ><span class='texttt'>true</span> if <span class='texttt'>a</span> and <span class='texttt'>b</span> share a target;
</p></li><li id='async.executor.comparisons-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.executor.comparisons-1.3'>(1.3)</a></div><p ><span class='texttt'>true</span> if <span class='texttt'>e</span> and <span class='texttt'>f</span> are the same type and <span class='texttt'>e == f</span>, where <span class='texttt'>e</span> is the target of <span class='texttt'>a</span> and <span class='texttt'>f</span> is the target of <span class='texttt'>b</span>;
</p></li><li id='async.executor.comparisons-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.executor.comparisons-1.4'>(1.4)</a></div><p >otherwise <span class='texttt'>false</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='operator==,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator=='></a></span><code class='itemdecl'>
bool operator==(const executor&amp; e, nullptr_t) noexcept;
bool operator==(nullptr_t, const executor&amp; e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!e</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator!='></a></span><code class='itemdecl'>
bool operator!=(const executor&amp; a, const executor&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.comparisons-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,executor'></a></span><span class='indexparent'><a class='index' id='executor,operator!='></a></span><code class='itemdecl'>
bool operator!=(const executor&amp; e, nullptr_t) noexcept;
bool operator!=(nullptr_t, const executor&amp; e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.comparisons-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>(bool) e</span>.
</p></div></div></div><div id='async.executor.algo'><h3 ><a class='secnum' href='#async.executor.algo' style='min-width:103pt'>13.21.9</a> <span class='texttt'>executor</span> specialized algorithms <a class='abbr_ref' href='async.executor.algo'>[async.executor.algo]</a></h3><p ><span class='indexparent'><a class='index' id='swap,executor'></a></span><span class='indexparent'><a class='index' id='executor,swap'></a></span><code class='itemdecl'>
void swap(executor&amp; a, executor&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.executor.algo-1'><div class='marginalizedparent'><a class='marginalized' href='#async.executor.algo-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>a.swap(b)</span>.
</p></div></div></div></div><div id='async.dispatch'><h2 ><a class='secnum' href='#async.dispatch' style='min-width:88pt'>13.22</a> Function <span class='texttt'>dispatch</span> <a class='abbr_ref' href='async.dispatch'>[async.dispatch]</a></h2><p ><span class='indexparent'><a class='index' id='dispatch'></a></span></p><div class='para' id='async.dispatch-1'><div class='marginalizedparent'><a class='marginalized' href='#async.dispatch-1'>1</a></div><p >[&nbsp;<i>Note:</i> The function <span class='texttt'>dispatch</span> satisfies the requirements for an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>), except for the requirement that the operation uses <span class='texttt'>post</span> if it completes immediately. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> dispatch(CompletionToken&amp;&amp; token);
</code></p></div><div class='itemdescr'></div><div class='para' id='async.dispatch-2'><div class='marginalizedparent'><a class='marginalized' href='#async.dispatch-2'>2</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='async.dispatch-3'><div class='marginalizedparent'><a class='marginalized' href='#async.dispatch-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='async.dispatch-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.dispatch-3.1'>(3.1)</a></div><p >Constructs an object <span class='texttt'>completion</span> of type <span class='texttt'>async_completion&lt;CompletionToken, void()&gt;</span>, initialized with <span class='texttt'>token</span>.
</p></li><li id='async.dispatch-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.dispatch-3.2'>(3.2)</a></div><p >Performs <span class='texttt'>ex.dispatch(std::move(completion.completion_handler), alloc)</span>, where <span class='texttt'>ex</span> is the result of <span class='texttt'>get_associated_executor(completion.completion_handler)</span>, and <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(completion.completion_handler)</span>.
</p></li></ul></div></div><div class='para' id='async.dispatch-4'><div class='marginalizedparent'><a class='marginalized' href='#async.dispatch-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>completion.result.get()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Executor, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> dispatch(const Executor&amp; ex, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='async.dispatch-5'><div class='marginalizedparent'><a class='marginalized' href='#async.dispatch-5'>5</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='async.dispatch-6'><div class='marginalizedparent'><a class='marginalized' href='#async.dispatch-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='async.dispatch-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.dispatch-6.1'>(6.1)</a></div><p >Constructs an object <span class='texttt'>completion</span> of type <span class='texttt'>async_completion&lt;CompletionToken, void()&gt;</span>, initialized with <span class='texttt'>token</span>.
</p></li><li id='async.dispatch-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.dispatch-6.2'>(6.2)</a></div><p >Constructs a function object <span class='texttt'>f</span> containing as members:
</p><ul class='itemize'><li id='async.dispatch-6.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#async.dispatch-6.2.1'>(6.2.1)</a></div><p >a copy of the completion handler <span class='texttt'>h</span>, initialized with <span class='texttt'>std::move(completion.completion_handler)</span>,
</p></li><li id='async.dispatch-6.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#async.dispatch-6.2.2'>(6.2.2)</a></div><p >an <span class='texttt'>executor_work_guard</span> object <span class='texttt'>w</span> for the completion handler's associated executor, initialized with <span class='texttt'>make_work_guard(h)</span>,
</p></li></ul><p >and where the effect of <span class='texttt'>f()</span> is:
</p><ul class='itemize'><li id='async.dispatch-6.2.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#async.dispatch-6.2.3'>(6.2.3)</a></div><p ><span class='texttt'>w.get_executor().dispatch(std::move(h), alloc)</span>, where <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(h)</span>, followed by
</p></li><li id='async.dispatch-6.2.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#async.dispatch-6.2.4'>(6.2.4)</a></div><p ><span class='texttt'>w.reset()</span>.
</p></li></ul></li><li id='async.dispatch-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.dispatch-6.3'>(6.3)</a></div><p >Performs <span class='texttt'>ex.dispatch(std::move(f), alloc)</span>, where <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(completion.completion_handler)</span> prior to the construction of <span class='texttt'>f</span>.
</p></li></ul></div></div><div class='para' id='async.dispatch-7'><div class='marginalizedparent'><a class='marginalized' href='#async.dispatch-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>completion.result.get()</span>.</p></div></div><div class='para' id='async.dispatch-8'><div class='marginalizedparent'><a class='marginalized' href='#async.dispatch-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_executor_v&lt;Executor&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ExecutionContext, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> dispatch(ExecutionContext&amp; ctx, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='async.dispatch-9'><div class='marginalizedparent'><a class='marginalized' href='#async.dispatch-9'>9</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='async.dispatch-10'><div class='marginalizedparent'><a class='marginalized' href='#async.dispatch-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>net::dispatch(ctx.get_executor(), forward&lt;CompletionToken&gt;(token))</span>.</p></div></div><div class='para' id='async.dispatch-11'><div class='marginalizedparent'><a class='marginalized' href='#async.dispatch-11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution
unless <span class='texttt'>is_convertible&lt;ExecutionContext&amp;, execution_context&amp;&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='async.post'><h2 ><a class='secnum' href='#async.post' style='min-width:88pt'>13.23</a> Function <span class='texttt'>post</span> <a class='abbr_ref' href='async.post'>[async.post]</a></h2><p ><span class='indexparent'><a class='index' id='post'></a></span></p><div class='para' id='async.post-1'><div class='marginalizedparent'><a class='marginalized' href='#async.post-1'>1</a></div><p >[&nbsp;<i>Note:</i> The function <span class='texttt'>post</span> satisfies the requirements for an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> post(CompletionToken&amp;&amp; token);
</code></p></div><div class='itemdescr'></div><div class='para' id='async.post-2'><div class='marginalizedparent'><a class='marginalized' href='#async.post-2'>2</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='async.post-3'><div class='marginalizedparent'><a class='marginalized' href='#async.post-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='async.post-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.post-3.1'>(3.1)</a></div><p >Constructs an object <span class='texttt'>completion</span> of type <span class='texttt'>async_completion&lt;CompletionToken, void()&gt;</span>, initialized with <span class='texttt'>token</span>.
</p></li><li id='async.post-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.post-3.2'>(3.2)</a></div><p >Performs <span class='texttt'>ex.post(std::move(completion.completion_handler), alloc)</span>, where <span class='texttt'>ex</span> is the result of <span class='texttt'>get_associated_executor(completion.completion_handler)</span>, and <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(completion.completion_handler)</span>.
</p></li></ul></div></div><div class='para' id='async.post-4'><div class='marginalizedparent'><a class='marginalized' href='#async.post-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>completion.result.get()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Executor, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> post(const Executor&amp; ex, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='async.post-5'><div class='marginalizedparent'><a class='marginalized' href='#async.post-5'>5</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='async.post-6'><div class='marginalizedparent'><a class='marginalized' href='#async.post-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='async.post-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.post-6.1'>(6.1)</a></div><p >Constructs an object <span class='texttt'>completion</span> of type <span class='texttt'>async_completion&lt;CompletionToken, void()&gt;</span>, initialized with <span class='texttt'>token</span>.
</p></li><li id='async.post-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.post-6.2'>(6.2)</a></div><p >Constructs a function object <span class='texttt'>f</span> containing as members:
</p><ul class='itemize'><li id='async.post-6.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#async.post-6.2.1'>(6.2.1)</a></div><p >a copy of the completion handler <span class='texttt'>h</span>, initialized with <span class='texttt'>std::move(completion.completion_handler)</span>,
</p></li><li id='async.post-6.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#async.post-6.2.2'>(6.2.2)</a></div><p >an <span class='texttt'>executor_work_guard</span> object <span class='texttt'>w</span> for the completion handler's associated executor, initialized with <span class='texttt'>make_work_guard(h)</span>,
</p></li></ul><p >and where the effect of <span class='texttt'>f()</span> is:
</p><ul class='itemize'><li id='async.post-6.2.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#async.post-6.2.3'>(6.2.3)</a></div><p ><span class='texttt'>w.get_executor().dispatch(std::move(h), alloc)</span>, where <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(h)</span>, followed by
</p></li><li id='async.post-6.2.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#async.post-6.2.4'>(6.2.4)</a></div><p ><span class='texttt'>w.reset()</span>.
</p></li></ul></li><li id='async.post-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.post-6.3'>(6.3)</a></div><p >Performs <span class='texttt'>ex.post(std::move(f), alloc)</span>, where <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(completion.completion_handler)</span> prior to the construction of <span class='texttt'>f</span>.
</p></li></ul></div></div><div class='para' id='async.post-7'><div class='marginalizedparent'><a class='marginalized' href='#async.post-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>completion.result.get()</span>.</p></div></div><div class='para' id='async.post-8'><div class='marginalizedparent'><a class='marginalized' href='#async.post-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_executor_v&lt;Executor&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ExecutionContext, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> post(ExecutionContext&amp; ctx, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='async.post-9'><div class='marginalizedparent'><a class='marginalized' href='#async.post-9'>9</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='async.post-10'><div class='marginalizedparent'><a class='marginalized' href='#async.post-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>net::post(ctx.get_executor(), forward&lt;CompletionToken&gt;(token))</span>.</p></div></div><div class='para' id='async.post-11'><div class='marginalizedparent'><a class='marginalized' href='#async.post-11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution
unless <span class='texttt'>is_convertible&lt;ExecutionContext&amp;, execution_context&amp;&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='async.defer'><h2 ><a class='secnum' href='#async.defer' style='min-width:88pt'>13.24</a> Function <span class='texttt'>defer</span> <a class='abbr_ref' href='async.defer'>[async.defer]</a></h2><p ><span class='indexparent'><a class='index' id='defer'></a></span></p><div class='para' id='async.defer-1'><div class='marginalizedparent'><a class='marginalized' href='#async.defer-1'>1</a></div><p >[&nbsp;<i>Note:</i> The function <span class='texttt'>defer</span> satisfies the requirements for an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>), except for the requirement that the operation uses <span class='texttt'>post</span> if it completes immediately. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> defer(CompletionToken&amp;&amp; token);
</code></p></div><div class='itemdescr'></div><div class='para' id='async.defer-2'><div class='marginalizedparent'><a class='marginalized' href='#async.defer-2'>2</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='async.defer-3'><div class='marginalizedparent'><a class='marginalized' href='#async.defer-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='async.defer-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.defer-3.1'>(3.1)</a></div><p >Constructs an object <span class='texttt'>completion</span> of type <span class='texttt'>async_completion&lt;CompletionToken, void()&gt;</span>, initialized with <span class='texttt'>token</span>.
</p></li><li id='async.defer-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.defer-3.2'>(3.2)</a></div><p >Performs <span class='texttt'>ex.defer(std::move(completion.completion_handler), alloc)</span>, where <span class='texttt'>ex</span> is the result of <span class='texttt'>get_associated_executor(completion.completion_handler)</span>, and <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(completion.completion_handler)</span>.
</p></li></ul></div></div><div class='para' id='async.defer-4'><div class='marginalizedparent'><a class='marginalized' href='#async.defer-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>completion.result.get()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Executor, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> defer(const Executor&amp; ex, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='async.defer-5'><div class='marginalizedparent'><a class='marginalized' href='#async.defer-5'>5</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='async.defer-6'><div class='marginalizedparent'><a class='marginalized' href='#async.defer-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='async.defer-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.defer-6.1'>(6.1)</a></div><p >Constructs an object <span class='texttt'>completion</span> of type <span class='texttt'>async_completion&lt;CompletionToken, void()&gt;</span>, initialized with <span class='texttt'>token</span>.
</p></li><li id='async.defer-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.defer-6.2'>(6.2)</a></div><p >Constructs a function object <span class='texttt'>f</span> containing as members:
</p><ul class='itemize'><li id='async.defer-6.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#async.defer-6.2.1'>(6.2.1)</a></div><p >a copy of the completion handler <span class='texttt'>h</span>, initialized with <span class='texttt'>std::move(completion.completion_handler)</span>,
</p></li><li id='async.defer-6.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#async.defer-6.2.2'>(6.2.2)</a></div><p >an <span class='texttt'>executor_work_guard</span> object <span class='texttt'>w</span> for the completion handler's associated executor, initialized with <span class='texttt'>make_work_guard(h)</span>,
</p></li></ul><p >and where the effect of <span class='texttt'>f()</span> is:
</p><ul class='itemize'><li id='async.defer-6.2.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#async.defer-6.2.3'>(6.2.3)</a></div><p ><span class='texttt'>w.get_executor().dispatch(std::move(h), alloc)</span>, where <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(h)</span>, followed by
</p></li><li id='async.defer-6.2.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#async.defer-6.2.4'>(6.2.4)</a></div><p ><span class='texttt'>w.reset()</span>.
</p></li></ul></li><li id='async.defer-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.defer-6.3'>(6.3)</a></div><p >Performs <span class='texttt'>ex.defer(std::move(f), alloc)</span>, where <span class='texttt'>alloc</span> is the result of <span class='texttt'>get_associated_allocator(completion.completion_handler)</span> prior to the construction of <span class='texttt'>f</span>.
</p></li></ul></div></div><div class='para' id='async.defer-7'><div class='marginalizedparent'><a class='marginalized' href='#async.defer-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>completion.result.get()</span>.</p></div></div><div class='para' id='async.defer-8'><div class='marginalizedparent'><a class='marginalized' href='#async.defer-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_executor_v&lt;Executor&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ExecutionContext, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> defer(ExecutionContext&amp; ctx, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='async.defer-9'><div class='marginalizedparent'><a class='marginalized' href='#async.defer-9'>9</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void()</span>.</p></div></div><div class='para' id='async.defer-10'><div class='marginalizedparent'><a class='marginalized' href='#async.defer-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>net::defer(ctx.get_executor(), forward&lt;CompletionToken&gt;(token))</span>.</p></div></div><div class='para' id='async.defer-11'><div class='marginalizedparent'><a class='marginalized' href='#async.defer-11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution
unless <span class='texttt'>is_convertible&lt;ExecutionContext&amp;, execution_context&amp;&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='async.strand'><h2 ><a class='secnum' href='#async.strand' style='min-width:88pt'>13.25</a> Class template <span class='texttt'>strand</span> <a class='abbr_ref' href='async.strand'>[async.strand]</a></h2><p ><span class='indexparent'><a class='index' id='strand'></a></span></p><div class='para' id='async.strand-1'><div class='marginalizedparent'><a class='marginalized' href='#async.strand-1'>1</a></div><p >The class template <span class='texttt'>strand</span> is a wrapper around an object of type <span class='texttt'>Executor</span> satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Executor&gt;
  class strand
  {
  public:
    <span class='comment'>// types:
</span>
    using inner_executor_type = Executor;

    <span class='comment'>// construct / copy / destroy:
</span>
    strand();
    explicit strand(Executor ex);
    template&lt;class ProtoAllocator&gt;
      strand(allocator_arg_t, const ProtoAllocator&amp; alloc, Executor ex);
    strand(const strand&amp; other) noexcept;
    strand(strand&amp;&amp; other) noexcept;
    template&lt;class OtherExecutor&gt; strand(const strand&lt;OtherExecutor&gt;&amp; other) noexcept;
    template&lt;class OtherExecutor&gt; strand(strand&lt;OtherExecutor&gt;&amp;&amp; other) noexcept;

    strand&amp; operator=(const strand&amp; other) noexcept;
    strand&amp; operator=(strand&amp;&amp; other) noexcept;
    template&lt;class OtherExecutor&gt; strand&amp; operator=(const strand&lt;OtherExecutor&gt;&amp; other) noexcept;
    template&lt;class OtherExecutor&gt; strand&amp; operator=(strand&lt;OtherExecutor&gt;&amp;&amp; other) noexcept;

    ~strand();

    <span class='comment'>// strand operations:
</span>
    inner_executor_type get_inner_executor() const noexcept;

    bool running_in_this_thread() const noexcept;

    execution_context&amp; context() const noexcept;

    void on_work_started() const noexcept;
    void on_work_finished() const noexcept;

    template&lt;class Func, class ProtoAllocator&gt;
      void dispatch(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
    template&lt;class Func, class ProtoAllocator&gt;
      void post(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
    template&lt;class Func, class ProtoAllocator&gt;
      void defer(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;

  private:
    Executor inner_ex_; <span class='comment'>// <i>exposition only</i>
</span>  };

  bool operator==(const strand&lt;Executor&gt;&amp; a, const strand&lt;Executor&gt;&amp; b);
  bool operator!=(const strand&lt;Executor&gt;&amp; a, const strand&lt;Executor&gt;&amp; b);

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='async.strand-2'><div class='marginalizedparent'><a class='marginalized' href='#async.strand-2'>2</a></div><p ><span class='texttt'>strand&lt;Executor&gt;</span> satisfies the <span class='texttt'>Executor</span> (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>) requirements.</p></div><div class='para' id='async.strand-3'><div class='marginalizedparent'><a class='marginalized' href='#async.strand-3'>3</a></div><p >A strand provides guarantees of ordering and non-concurrency. Given:</p><ul class='itemize'><li id='async.strand-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.strand-3.1'>(3.1)</a></div><p >strand objects <span class='texttt'>s1</span> and <span class='texttt'>s2</span> such that <span class='texttt'>s1 == s2</span></p></li><li id='async.strand-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.strand-3.2'>(3.2)</a></div><p >a function object <span class='texttt'>f1</span> added to the strand <span class='texttt'>s1</span> using <span class='texttt'>post</span> or <span class='texttt'>defer</span>, or using <span class='texttt'>dispatch</span> when <span class='texttt'>s1.running_in_this_thread() == false</span></p></li><li id='async.strand-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.strand-3.3'>(3.3)</a></div><p >a function object <span class='texttt'>f2</span> added to the strand <span class='texttt'>s2</span> using <span class='texttt'>post</span> or <span class='texttt'>defer</span>, or using <span class='texttt'>dispatch</span> when <span class='texttt'>s2.running_in_this_thread() == false</span>
</p></li></ul></div><div class='para' id='async.strand-4'><div class='marginalizedparent'><a class='marginalized' href='#async.strand-4'>4</a></div><p >then the implementation invokes <span class='texttt'>f1</span> and <span class='texttt'>f2</span> such that:</p><ul class='itemize'><li id='async.strand-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.strand-4.1'>(4.1)</a></div><p >the invocation of <span class='texttt'>f1</span> is not concurrent with the invocation of <span class='texttt'>f2</span></p></li><li id='async.strand-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.strand-4.2'>(4.2)</a></div><p >the invocation of <span class='texttt'>f1</span> synchronizes with the invocation of <span class='texttt'>f2</span>.
</p></li></ul></div><div class='para' id='async.strand-5'><div class='marginalizedparent'><a class='marginalized' href='#async.strand-5'>5</a></div><p >Furthermore, if the addition of <span class='texttt'>f1</span> happens before the addition of <span class='texttt'>f2</span>, then the invocation of <span class='texttt'>f1</span> happens before the invocation of <span class='texttt'>f2</span>.</p></div><div class='para' id='async.strand-6'><div class='marginalizedparent'><a class='marginalized' href='#async.strand-6'>6</a></div><p >All member functions, except for the assignment operators and the destructor, do not introduce data races on <span class='texttt'>*this</span>, including its ordered, non-concurrent state. Additionally, constructors and assignment operators do not introduce data races on lvalue arguments.</p></div><div class='para' id='async.strand-7'><div class='marginalizedparent'><a class='marginalized' href='#async.strand-7'>7</a></div><p >If any function <span class='texttt'>f</span> executed by the strand throws an exception, the subsequent strand state is as if <span class='texttt'>f</span> had exited without throwing an exception.</p></div><div id='async.strand.cons'><h3 ><a class='secnum' href='#async.strand.cons' style='min-width:103pt'>13.25.1</a> <span class='texttt'>strand</span> constructors <a class='abbr_ref' href='async.strand.cons'>[async.strand.cons]</a></h3><p ><span class='indexparent'><a class='index' id='strand,constructor'></a></span><code class='itemdecl'>
strand();
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of class <span class='texttt'>strand&lt;Executor&gt;</span> that represents a unique ordered, non-concurrent state. Initializes <span class='texttt'>inner_ex_</span> as <span class='texttt'>inner_ex_()</span>.</p></div></div><div class='para' id='async.strand.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.cons-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> This overload shall not participate in overload resolution unless <span class='texttt'>Executor</span> satisfies the <span class='texttt'>DefaultConstructible</span> requirements (C++Std &sect;<a href='../n4140/defaultconstructible'>[defaultconstructible]</a>).
</p></div></div><p ><code class='itemdecl'>
explicit strand(Executor ex);
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of class <span class='texttt'>strand&lt;Executor&gt;</span> that represents a unique ordered, non-concurrent state. Initializes <span class='texttt'>inner_ex_</span> as <span class='texttt'>inner_ex_(ex)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ProtoAllocator&gt;
  strand(allocator_arg_t, const ProtoAllocator&amp; a, Executor ex);
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of class <span class='texttt'>strand&lt;Executor&gt;</span> that represents a unique ordered, non-concurrent state. Initializes <span class='texttt'>inner_ex_</span> as <span class='texttt'>inner_ex_(ex)</span>. A copy of the allocator argument <span class='texttt'>a</span> is used to allocate memory, if necessary, for the internal data structures of the constructed strand object.
</p></div></div><p ><code class='itemdecl'>
strand(const strand&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>inner_ex_</span> as <span class='texttt'>inner_ex_(other.inner_ex_)</span>.</p></div></div><div class='para' id='async.strand.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.cons-6'>6</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='async.strand.cons-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.strand.cons-6.1'>(6.1)</a></div><p ><span class='texttt'>*this == other</span>
</p></li><li id='async.strand.cons-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.strand.cons-6.2'>(6.2)</a></div><p ><span class='texttt'>get_inner_executor() == other.get_inner_executor()</span>
</p></li></ul></div></div><p ><code class='itemdecl'>
strand(strand&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.cons-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>inner_ex_</span> as <span class='texttt'>inner_ex_(std::move(other.inner_ex_))</span>.</p></div></div><div class='para' id='async.strand.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.cons-8'>8</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='async.strand.cons-8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.strand.cons-8.1'>(8.1)</a></div><p ><span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>other</span>
</p></li><li id='async.strand.cons-8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.strand.cons-8.2'>(8.2)</a></div><p ><span class='texttt'>get_inner_executor() == other.get_inner_executor()</span>
</p></li></ul></div></div><p ><code class='itemdecl'>
template&lt;class OtherExecutor&gt; strand(const strand&lt;OtherExecutor&gt;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.cons-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherExecutor</span> is convertible to <span class='texttt'>Executor</span>.</p></div></div><div class='para' id='async.strand.cons-10'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.cons-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>inner_ex_</span> as <span class='texttt'>inner_ex_(other.inner_ex_)</span>.</p></div></div><div class='para' id='async.strand.cons-11'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.cons-11'>11</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this == other</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class OtherExecutor&gt; strand(strand&lt;OtherExecutor&gt;&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.cons-12'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.cons-12'>12</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherExecutor</span> is convertible to <span class='texttt'>Executor</span>.</p></div></div><div class='para' id='async.strand.cons-13'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.cons-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>inner_ex_</span> as <span class='texttt'>inner_ex_(std::move(other.inner_ex_))</span>.</p></div></div><div class='para' id='async.strand.cons-14'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.cons-14'>14</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>other</span>.
</p></div></div></div><div id='async.strand.assign'><h3 ><a class='secnum' href='#async.strand.assign' style='min-width:103pt'>13.25.2</a> <span class='texttt'>strand</span> assignment <a class='abbr_ref' href='async.strand.assign'>[async.strand.assign]</a></h3><p ><span class='indexparent'><a class='index' id='operator=,strand'></a></span><span class='indexparent'><a class='index' id='strand,operator='></a></span><code class='itemdecl'>
strand&amp; operator=(const strand&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.assign-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>Executor</span> is <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>).</p></div></div><div class='para' id='async.strand.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.assign-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='async.strand.assign-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.strand.assign-2.1'>(2.1)</a></div><p ><span class='texttt'>*this == other</span>
</p></li><li id='async.strand.assign-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.strand.assign-2.2'>(2.2)</a></div><p ><span class='texttt'>get_inner_executor() == other.get_inner_executor()</span>
</p></li></ul></div></div><div class='para' id='async.strand.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.assign-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
strand&amp; operator=(strand&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.assign-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>Executor</span> is <span class='texttt'>MoveAssignable</span> (C++Std &sect;<a href='../n4140/moveassignable'>[moveassignable]</a>).</p></div></div><div class='para' id='async.strand.assign-5'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.assign-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='async.strand.assign-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.strand.assign-5.1'>(5.1)</a></div><p ><span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>other</span>
</p></li><li id='async.strand.assign-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.strand.assign-5.2'>(5.2)</a></div><p ><span class='texttt'>get_inner_executor() == other.get_inner_executor()</span>
</p></li></ul></div></div><div class='para' id='async.strand.assign-6'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.assign-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class OtherExecutor&gt; strand&amp; operator=(const strand&lt;OtherExecutor&gt;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.assign-7'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.assign-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherExecutor</span> is convertible to <span class='texttt'>Executor</span>. <span class='texttt'>Executor</span> is <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>).</p></div></div><div class='para' id='async.strand.assign-8'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.assign-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns <span class='texttt'>other.inner_ex_</span> to <span class='texttt'>inner_ex_</span>.</p></div></div><div class='para' id='async.strand.assign-9'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.assign-9'>9</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this == other</span>.</p></div></div><div class='para' id='async.strand.assign-10'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.assign-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class OtherExecutor&gt; strand&amp; operator=(strand&lt;OtherExecutor&gt;&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.assign-11'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.assign-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherExecutor</span> is convertible to <span class='texttt'>Executor</span>. <span class='texttt'>Executor</span> is <span class='texttt'>MoveAssignable</span> (C++Std &sect;<a href='../n4140/moveassignable'>[moveassignable]</a>).</p></div></div><div class='para' id='async.strand.assign-12'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.assign-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns <span class='texttt'>std::move(other.inner_ex_)</span> to <span class='texttt'>inner_ex_</span>.</p></div></div><div class='para' id='async.strand.assign-13'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.assign-13'>13</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>other</span>.</p></div></div><div class='para' id='async.strand.assign-14'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.assign-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='async.strand.dtor'><h3 ><a class='secnum' href='#async.strand.dtor' style='min-width:103pt'>13.25.3</a> <span class='texttt'>strand</span> destructor <a class='abbr_ref' href='async.strand.dtor'>[async.strand.dtor]</a></h3><p ><span class='indexparent'><a class='index' id='strand,destructor'></a></span><code class='itemdecl'>
~strand();
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys an object of class <span class='texttt'>strand&lt;Executor&gt;</span>. After this destructor completes, objects that were added to the strand but have not yet been executed will be executed in a way that meets the guarantees of ordering and non-concurrency.
</p></div></div></div><div id='async.strand.ops'><h3 ><a class='secnum' href='#async.strand.ops' style='min-width:103pt'>13.25.4</a> <span class='texttt'>strand</span> operations <a class='abbr_ref' href='async.strand.ops'>[async.strand.ops]</a></h3><p ><span class='indexparent'><a class='index' id='get_inner_executor,strand'></a></span><span class='indexparent'><a class='index' id='strand,get_inner_executor'></a></span><code class='itemdecl'>
inner_executor_type get_inner_executor() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>inner_ex_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='running_in_this_thread,strand'></a></span><span class='indexparent'><a class='index' id='strand,running_in_this_thread'></a></span><code class='itemdecl'>
bool running_in_this_thread() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.ops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the current thread of execution is running a function that was submitted to the strand, or to any other strand object <span class='texttt'>s</span> such that <span class='texttt'>s == *this</span>, using <span class='texttt'>dispatch</span>, <span class='texttt'>post</span> or <span class='texttt'>defer</span>; otherwise <span class='texttt'>false</span>. [&nbsp;<i>Note:</i> That is, the current thread of execution's call chain includes a function that was submitted to the strand. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='context,strand'></a></span><span class='indexparent'><a class='index' id='strand,context'></a></span><code class='itemdecl'>
execution_context&amp; context() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.ops-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>inner_ex_.context()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='on_work_started,strand'></a></span><span class='indexparent'><a class='index' id='strand,on_work_started'></a></span><code class='itemdecl'>
void on_work_started() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.ops-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Calls <span class='texttt'>inner_ex_.on_work_started()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='on_work_finished,strand'></a></span><span class='indexparent'><a class='index' id='strand,on_work_finished'></a></span><code class='itemdecl'>
void on_work_finished() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.ops-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Calls <span class='texttt'>inner_ex_.on_work_finished()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='dispatch,strand'></a></span><span class='indexparent'><a class='index' id='strand,dispatch'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void dispatch(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.ops-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>running_in_this_thread() == true</span>, calls <span class='texttt'><i>DECAY_COPY</i>(forward&lt;Func&gt;(f))()</span> (C++Std &sect;<a href='../n4140/thread.decaycopy'>[thread.decaycopy]</a>). [&nbsp;<i>Note:</i> If <span class='texttt'>f</span> exits via an exception, the exception propagates to the caller of <span class='texttt'>dispatch()</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Otherwise, requests invocation of <span class='texttt'>f</span>, as if by forwarding the function object <span class='texttt'>f</span> and allocator <span class='texttt'>a</span> to the executor <span class='texttt'>inner_ex_</span>, such that the guarantees of ordering and non-concurrency are met.
</p></div></div><p ><span class='indexparent'><a class='index' id='post,strand'></a></span><span class='indexparent'><a class='index' id='strand,post'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void post(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.ops-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Requests invocation of <span class='texttt'>f</span>, as if by forwarding the function object <span class='texttt'>f</span> and allocator <span class='texttt'>a</span> to the executor <span class='texttt'>inner_ex_</span>, such that the guarantees of ordering and non-concurrency are met.
</p></div></div><p ><span class='indexparent'><a class='index' id='defer,strand'></a></span><span class='indexparent'><a class='index' id='strand,defer'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void defer(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.ops-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Requests invocation of <span class='texttt'>f</span>, as if by forwarding the function object <span class='texttt'>f</span> and allocator <span class='texttt'>a</span> to the executor <span class='texttt'>inner_ex_</span>, such that the guarantees of ordering and non-concurrency are met.
</p></div></div></div><div id='async.strand.comparisons'><h3 ><a class='secnum' href='#async.strand.comparisons' style='min-width:103pt'>13.25.5</a> <span class='texttt'>strand</span> comparisons <a class='abbr_ref' href='async.strand.comparisons'>[async.strand.comparisons]</a></h3><p ><span class='indexparent'><a class='index' id='operator==,strand'></a></span><span class='indexparent'><a class='index' id='strand,operator=='></a></span><code class='itemdecl'>
bool operator==(const strand&lt;Executor&gt;&amp; a, const strand&lt;Executor&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span>, if the strand objects share the same ordered, non-concurrent state; otherwise <span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,strand'></a></span><span class='indexparent'><a class='index' id='strand,operator!='></a></span><code class='itemdecl'>
bool operator!=(const strand&lt;Executor&gt;&amp; a, const strand&lt;Executor&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='async.strand.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#async.strand.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div></div></div><div id='async.use.future'><h2 ><a class='secnum' href='#async.use.future' style='min-width:88pt'>13.26</a> Class template <span class='texttt'>use_future_t</span> <a class='abbr_ref' href='async.use.future'>[async.use.future]</a></h2><p ><span class='indexparent'><a class='index' id='use_future_t'></a></span></p><div class='para' id='async.use.future-1'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future-1'>1</a></div><p >The class template <span class='texttt'>use_future_t</span> defines a set of types that, when passed as a completion token (<a href='async.reqmts.async.token'>[async.reqmts.async.token]</a>) to an asynchronous operation's initiating function, cause the result of the asynchronous operation to be delivered via a future (C++Std &sect;<a href='../n4140/futures.uniquefuture'>[futures.uniquefuture]</a>).</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class ProtoAllocator = allocator&lt;void&gt;&gt;
  class use_future_t
  {
  public:
    <span class='comment'>// use_future_t types:
</span>    using allocator_type = ProtoAllocator;

    <span class='comment'>// use_future_t members:
</span>    constexpr use_future_t() noexcept(noexcept(allocator_type()));
    explicit use_future_t(const allocator_type&amp; a) noexcept;
    template&lt;class OtherProtoAllocator&gt; use_future_t&lt;OtherProtoAllocator&gt;
      rebind(const OtherProtoAllocator&amp; a) const noexcept;
    allocator_type get_allocator() const noexcept;
    template &lt;class F&gt; <i><span class='texttt'>unspecified</span></i> operator()(F&amp;&amp; f) const;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div id='async.use.future.cons'><h3 ><a class='secnum' href='#async.use.future.cons' style='min-width:103pt'>13.26.1</a> <span class='texttt'>use_future_t</span> constructors <a class='abbr_ref' href='async.use.future.cons'>[async.use.future.cons]</a></h3><p ><span class='indexparent'><a class='index' id='use_future_t,constructor'></a></span><code class='itemdecl'>
constexpr use_future_t() noexcept(noexcept(allocator_type()));
</code></p><div class='itemdescr'></div><div class='para' id='async.use.future.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>use_future_t</span> with a default-constructed allocator.
</p></div></div><p ><code class='itemdecl'>
explicit use_future_t(const allocator_type&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.use.future.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_allocator() == a</span>.
</p></div></div></div><div id='async.use.future.members'><h3 ><a class='secnum' href='#async.use.future.members' style='min-width:103pt'>13.26.2</a> <span class='texttt'>use_future_t</span> members <a class='abbr_ref' href='async.use.future.members'>[async.use.future.members]</a></h3><p ><span class='indexparent'><a class='index' id='rebind,use_future_t'></a></span><span class='indexparent'><a class='index' id='use_future_t,rebind'></a></span><code class='itemdecl'>
template&lt;class OtherProtoAllocator&gt; use_future_t&lt;OtherProtoAllocator&gt;
  rebind(const OtherProtoAllocator&amp; a) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.use.future.members-1'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>use_future_t</span> object where <span class='texttt'>get_allocator() == a</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_allocator,use_future_t'></a></span><span class='indexparent'><a class='index' id='use_future_t,get_allocator'></a></span><code class='itemdecl'>
allocator_type get_allocator() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='async.use.future.members-2'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The associated allocator object.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator(),use_future_t'></a></span><span class='indexparent'><a class='index' id='use_future_t,operator()'></a></span><code class='itemdecl'>
template &lt;class F&gt; <i><span class='texttt'>unspecified</span></i> operator()(F&amp;&amp; f) const;
</code></p><div class='itemdescr'></div><div class='para' id='async.use.future.members-3'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.members-3'>3</a></div><div class='itemdescr'><p >Let <span class='texttt'>T</span> be a completion token type. Let <span class='texttt'>H</span> be a completion handler type and let <span class='texttt'>h</span> be an object of type <span class='texttt'>H</span>. Let <span class='texttt'>FD</span> be the type <span class='texttt'>decay_t&lt;F&gt;</span> and let <span class='texttt'>fd</span> be an lvalue of type <span class='texttt'>FD</span> constructed with <span class='texttt'>forward&lt;F&gt;(f)</span>. Let <span class='texttt'>R(Args...)</span> be the completion signature of an asynchronous operation using <span class='texttt'>H</span> and let <i>N</i> be <span class='texttt'>sizeof...(Args)</span>. Let <i>i</i> be in the range <span class='texttt'>[0, <i>N</i>)</span> and let <span class='texttt'>A<span class='math'><sub ><span class='mathalpha'>i</span></sub></span></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> type in <span class='texttt'>Args</span>. Let <span class='texttt'>a<span class='math'><sub ><span class='mathalpha'>i</span></sub></span></span> be the argument associated with <span class='texttt'>A<span class='math'><sub ><span class='mathalpha'>i</span></sub></span></span>.</p></div></div><div class='para' id='async.use.future.members-4'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> A completion token <span class='texttt'>t</span> of type <span class='texttt'>T</span>.</p></div></div><div class='para' id='async.use.future.members-5'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.members-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> The return type <span class='texttt'>T</span> satisfies the <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) and <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>) requirements.</p></div></div><div class='para' id='async.use.future.members-6'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.members-6'>6</a></div><div class='itemdescr'><p >The object <span class='texttt'>h</span> of type <span class='texttt'>H</span> is an asynchronous provider with an associated shared state (C++Std &sect;<a href='../n4140/futures.state'>[futures.state]</a>). The effect of <span class='texttt'>h(a<span class='math'><sub >0</sub></span>, ..., a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>)</span> is to atomically store the result of <span class='texttt'><i>INVOKE</i>(fd, forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>), ..., forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> (C++Std &sect;<a href='../n4140/func.require'>[func.require]</a>) in the shared state and make the shared state ready. If <span class='texttt'>fd</span> exits via an exception then that exception is atomically stored in the shared state and the shared state is made ready.</p></div></div><div class='para' id='async.use.future.members-7'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.members-7'>7</a></div><div class='itemdescr'><p >The implementation provides a partial specialization <span class='texttt'>template &lt;class Result, class... Args&gt; async_result&lt;T, Result(Args...)&gt;</span> such that:
</p><ul class='itemize'><li id='async.use.future.members-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.use.future.members-7.1'>(7.1)</a></div><p >the nested type <span class='texttt'>completion_handler_type</span> is a type <span class='texttt'>H</span>;
</p></li><li id='async.use.future.members-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.use.future.members-7.2'>(7.2)</a></div><p >the nested type <span class='texttt'>return_type</span> is <span class='texttt'>future&lt;result_of_t&lt;FD(decay_t&lt;Args&gt;...)&gt;&gt;</span>; and
</p></li><li id='async.use.future.members-7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#async.use.future.members-7.3'>(7.3)</a></div><p >when an object <span class='texttt'>r1</span> of type <span class='texttt'>async_result&lt;T, Result(Args...)&gt;</span> is constructed from <span class='texttt'>h</span>, the expression <span class='texttt'>r1.get()</span> returns a future with the same shared state as <span class='texttt'>h</span>.
</p></li></ul></div></div><div class='para' id='async.use.future.members-8'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.members-8'>8</a></div><div class='itemdescr'><p >For any executor type <span class='texttt'>E</span>, the associated object for the associator <span class='texttt'>associated_executor&lt;H, E&gt;</span> is an executor where, for function objects executed using the executor's <span class='texttt'>dispatch()</span>, <span class='texttt'>post()</span> or <span class='texttt'>defer()</span> functions, any exception thrown is caught by a function object and stored in the associated shared state.
</p></div></div></div><div id='async.use.future.result'><h3 ><a class='secnum' href='#async.use.future.result' style='min-width:103pt'>13.26.3</a> Partial class template specialization <span class='texttt'>async_result</span>
        for <span class='texttt'>use_future_t</span> <a class='abbr_ref' href='async.use.future.result'>[async.use.future.result]</a></h3><p ><span class='indexparent'><a class='index' id='async_result'></a></span><span class='indexparent'><a class='index' id='async_result,specialization_for_use_future_t'></a></span></p><pre class='codeblock'>
template&lt;class ProtoAllocator, class Result, class... Args&gt;
class async_result&lt;use_future_t&lt;ProtoAllocator&gt;, Result(Args...)&gt;{
  using completion_handler_type = <i><span class='texttt'>see below</span></i>;
  using return_type =  <i><span class='texttt'>see below</span></i>;

  explicit async_result(completion_handler_type&amp; h);
  async_result(const async_result&amp;) = delete;
  async_result&amp; operator=(const async_result&amp;) = delete;

  return_type get();
};
</pre><div class='para' id='async.use.future.result-1'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.result-1'>1</a></div><p >Let <span class='texttt'>R</span> be the type <span class='texttt'>async_result&lt;use_future_t&lt;ProtoAllocator&gt;, Result(Args...)&gt;</span>. Let <span class='texttt'>F</span> be the nested function object type <span class='texttt'>R::completion_handler_type</span>.</p></div><div class='para' id='async.use.future.result-2'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.result-2'>2</a></div><p >An object <span class='texttt'>t1</span> of type <span class='texttt'>F</span> is an asynchronous provider with an associated shared state (C++Std &sect;<a href='../n4140/futures.state'>[futures.state]</a>). The type <span class='texttt'>F</span> provides <span class='texttt'>F::operator()</span> such that the expression <span class='texttt'>t1(declval&lt;Args&gt;()...)</span> is well formed.</p></div><div class='para' id='async.use.future.result-3'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.result-3'>3</a></div><p >The implementation specializes <span class='texttt'>associated_executor</span> for <span class='texttt'>F</span>. For function objects executed using the associated executor's <span class='texttt'>dispatch()</span>, <span class='texttt'>post()</span> or <span class='texttt'>defer()</span> functions, any exception thrown is caught by the executor and stored in the associated shared state.</p></div><div class='para' id='async.use.future.result-4'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.result-4'>4</a></div><p >For any executor type <span class='texttt'>E</span>, the associated object for the associator <span class='texttt'>associated_executor&lt;F, E&gt;</span> is an executor where, for function objects executed using the executor's <span class='texttt'>dispatch()</span>, <span class='texttt'>post()</span> or <span class='texttt'>defer()</span> functions, any exception thrown by a function object is caught by the executor and stored in the associated shared state.</p></div><div class='para' id='async.use.future.result-5'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.result-5'>5</a></div><p >When an object <span class='texttt'>r1</span> of type <span class='texttt'>R</span> is constructed from <span class='texttt'>t1</span>, the expression <span class='texttt'>r1.get()</span> returns a future with the same shared state as <span class='texttt'>t1</span>.</p></div><div class='para' id='async.use.future.result-6'><div class='marginalizedparent'><a class='marginalized' href='#async.use.future.result-6'>6</a></div><p >The type of <span class='texttt'>R::return_type</span> and the effects of <span class='texttt'>F::operator()</span> are defined in Table <a href='async.use.future.result#tab:async.use.future.result.requirements'>[tab:async.use.future.result.requirements]</a>. After establishing these effects, <span class='texttt'>F::operator()</span> makes the shared state ready. In this table, <i>N</i> is the value of <span class='texttt'>sizeof...(Args)</span>; let <i>i</i> be in the range <span class='texttt'>[0, <i>N</i>)</span> and let <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> type in <span class='texttt'>Args</span>; let <span class='texttt'>U</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be <span class='texttt'>decay_t&lt;T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span><span class='texttt'>&gt;</span> for each type <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> in <span class='texttt'>Args</span>; let <span class='texttt'>A</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the deduced type of the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> argument to <span class='texttt'>F::operator()</span>; and let <span class='texttt'>a</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> argument to <span class='texttt'>F::operator()</span>.</p><div class='numberedTable' id='tab:async.use.future.result.requirements'>Table <a href='#tab:async.use.future.result.requirements'>10</a> — <span class='texttt'>async_result&lt;use_future_t&lt;ProtoAllocator&gt;, Result(Args...)&gt;</span> semantics<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>N</b></td><td colspan='1' class='center'><b>U<span class='math'><sub >0</sub></span></b></td><td colspan='1' class='center'><b><span class='texttt'>R::return_type</span></b></td><td colspan='1' class='center'><b><span class='texttt'>F::operator()</span> effects</b></td></tr><tr class='capsep'><td class='center'> 
 0  </td><td class='left'>
  </td><td class='left'>
<span class='texttt'>future&lt;void&gt;</span>  </td><td class='justify'>
 None.  </td></tr><tr class='rowsep'><td class='center'>  1  </td><td class='left'>
<span class='texttt'>error_code</span>  </td><td class='left'>
<span class='texttt'>future&lt;void&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> evaluates to <span class='texttt'>true</span>, atomically stores the exception pointer produced by <span class='texttt'>make_exception_ptr(system_error(a<span class='math'><sub >0</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  1  </td><td class='left'>
<span class='texttt'>exception_ptr</span>  </td><td class='left'>
<span class='texttt'>future&lt;void&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> is non-null, atomically stores the exception pointer a<span class='math'><sub >0</sub></span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  1  </td><td class='left'>
 all other types  </td><td class='left'>
<span class='texttt'>future&lt;U<span class='math'><sub >0</sub></span>&gt;</span>  </td><td class='justify'>
Atomically stores <span class='texttt'>forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>)</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  2  </td><td class='left'>
<span class='texttt'>error_code</span>  </td><td class='left'>
<span class='texttt'>future&lt;U<span class='math'><sub >1</sub></span>&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> evaluates to <span class='texttt'>true</span>, atomically stores the exception pointer produced by <span class='texttt'>make_exception_ptr(system_error(a<span class='math'><sub >0</sub></span>))</span> in the shared state; otherwise, atomically stores <span class='texttt'>forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>)</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  2  </td><td class='left'>
<span class='texttt'>exception_ptr</span>  </td><td class='left'>
<span class='texttt'>future&lt;U<span class='math'><sub >1</sub></span>&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> is non-null, atomically stores the exception pointer in the shared state; otherwise, atomically stores <span class='texttt'>forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>)</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  2  </td><td class='left'>
 all other types  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >0</sub></span>, U<span class='math'><sub >1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
Atomically stores <span class='texttt'>forward_as_tuple(forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>), forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  &gt;2  </td><td class='left'>
<span class='texttt'>error_code</span>  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >1</sub></span>, ..., U<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> evaluates to <span class='texttt'>true</span>, atomically stores the exception pointer produced by <span class='texttt'>make_exception_ptr(system_error(a<span class='math'><sub >0</sub></span>))</span> in the shared state; otherwise, atomically stores <span class='texttt'>forward_as_tuple(forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>), ..., forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  &gt;2  </td><td class='left'>
<span class='texttt'>exception_ptr</span>  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >1</sub></span>, ..., U<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
If <span class='texttt'>a<span class='math'><sub >0</sub></span></span> is non-null, atomically stores the exception pointer in the shared state; otherwise, atomically stores <span class='texttt'>forward_as_tuple(forward&lt;A<span class='math'><sub >1</sub></span>&gt;(a<span class='math'><sub >1</sub></span>), ..., forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> in the shared state.  </td></tr><tr class='rowsep'><td class='center'>  &gt;2  </td><td class='left'>
 all other types  </td><td class='left'>
<span class='texttt'>future&lt;tuple&lt;U<span class='math'><sub >0</sub></span>, ..., U<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;&gt;</span>  </td><td class='justify'>
Atomically stores <span class='texttt'>forward_as_tuple(forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>), ..., forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> in the shared state.  </td></tr></table></div></div></div></div><div id='async.packaged.task.spec'><h2 ><a class='secnum' href='#async.packaged.task.spec' style='min-width:88pt'>13.27</a> Partial specialization of <span class='texttt'>async_result</span> for <span class='texttt'>packaged_task</span> <a class='abbr_ref' href='async.packaged.task.spec'>[async.packaged.task.spec]</a></h2><p ><span class='indexparent'><a class='index' id='async_result'></a></span><span class='indexparent'><a class='index' id='async_result,specialization_for_packaged_task'></a></span><code class='itemdecl'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Result, class... Args, class Signature&gt;
  class async_result&lt;packaged_task&lt;Result(Args...)&gt;, Signature&gt;
  {
  public:
    using completion_handler_type = packaged_task&lt;Result(Args...)&gt;;
    using return_type = future&lt;Result&gt;;

    explicit async_result(completion_handler_type&amp; h);
    async_result(const async_result&amp;) = delete;
    async_result&amp; operator=(const async_result&amp;) = delete;

    return_type get();

  private:
    return_type future_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span>
explicit async_result(completion_handler_type&amp; h);
</code></p><div class='itemdescr'></div><div class='para' id='async.packaged.task.spec-1'><div class='marginalizedparent'><a class='marginalized' href='#async.packaged.task.spec-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>future_</span> with <span class='texttt'>h.get_future()</span>.
</p></div></div><p ><code class='itemdecl'>
return_type get();
</code></p><div class='itemdescr'></div><div class='para' id='async.packaged.task.spec-2'><div class='marginalizedparent'><a class='marginalized' href='#async.packaged.task.spec-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>std::move(future_)</span>.
</p></div></div></div></div><div id='io_context'><h1 ><a class='secnum' href='#io_context' style='min-width:73pt'>14</a> Basic I/O services <a class='abbr_ref' href='./#io_context'>[io_context]</a></h1><p ><span class='indexparent'><a class='index' id='experimental/io_context'></a></span></p><div id='io_context.synop'><h2 ><a class='secnum' href='#io_context.synop' style='min-width:88pt'>14.1</a> Header <span class='texttt'>&lt;experimental/io_context&gt;</span> synopsis <a class='abbr_ref' href='io_context.synop'>[io_context.synop]</a></h2><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class io_context;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div id='io_context.io_context'><h2 ><a class='secnum' href='#io_context.io_context' style='min-width:88pt'>14.2</a> Class <span class='texttt'>io_context</span> <a class='abbr_ref' href='io_context.io_context'>[io_context.io_context]</a></h2><p ><span class='indexparent'><a class='index' id='io_context'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class io_context : public execution_context
  {
  public:
    <span class='comment'>// types:
</span>
    class executor_type;
    using count_type = <i>implementation-defined</i>;

    <span class='comment'>// construct / copy / destroy:
</span>
    io_context();
    explicit io_context(int concurrency_hint);
    io_context(const io_context&amp;) = delete;
    io_context&amp; operator=(const io_context&amp;) = delete;

    <span class='comment'>// io_context operations:
</span>
    executor_type get_executor() noexcept;

    count_type run();
    template&lt;class Rep, class Period&gt;
      count_type run_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template&lt;class Clock, class Duration&gt;
      count_type run_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);

    count_type run_one();
    template&lt;class Rep, class Period&gt;
      count_type run_one_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template&lt;class Clock, class Duration&gt;
      count_type run_one_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);

    count_type poll();

    count_type poll_one();

    void stop();

    bool stopped() const noexcept;

    void restart();
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='io_context.io_context-1'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context-1'>1</a></div><p >The class <span class='texttt'>io_context</span> satisfies the ExecutionContext type requirements (<a href='async.reqmts.executioncontext'>[async.reqmts.executioncontext]</a>).</p><p ><span class='indexparent'><a class='index' id='count_type,io_context'></a></span><span class='indexparent'><a class='index' id='io_context,count_type'></a></span></p></div><div class='para' id='io_context.io_context-2'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context-2'>2</a></div><p ><span class='texttt'>count_type</span> is an <span class='indexparent'><a class='index' id='type_of_io_context::count_type'></a></span>implementation-defined
unsigned integral type of at least 32 bits.</p></div><div class='para' id='io_context.io_context-3'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context-3'>3</a></div><p >The <span class='texttt'>io_context</span> member functions <span class='texttt'>run</span>, <span class='texttt'>run_for</span>, <span class='texttt'>run_until</span>, <span class='texttt'>run_one</span>, <span class='texttt'>run_one_for</span>, <span class='texttt'>run_one_until</span>, <span class='texttt'>poll</span>, and <span class='texttt'>poll_one</span> are collectively referred to as the <a class='hidden_link' href='#def:run_functions' id='def:run_functions'><i>run functions</i></a>. The run functions must be called for the <span class='texttt'>io_context</span> to perform asynchronous operations (<a href='defs.async.op'>[defs.async.op]</a>) on behalf of a C++ program. Notification that an asynchronous operation has completed is delivered by execution of the associated completion handler function object, as determined by the requirements for asynchronous operations (<a href='async.reqmts.async'>[async.reqmts.async]</a>).</p></div><div class='para' id='io_context.io_context-4'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context-4'>4</a></div><p >For an object of type <span class='texttt'>io_context</span>, <a class='hidden_link' href='#def:outstanding_work' id='def:outstanding_work'><i>outstanding work</i></a> is defined as the sum of:</p><ul class='itemize'><li id='io_context.io_context-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#io_context.io_context-4.1'>(4.1)</a></div><p >the total number of calls to the <span class='texttt'>on_work_started</span> function, less the total number of calls to the <span class='texttt'>on_work_finished</span> function, to any executor of the <span class='texttt'>io_context</span>.
</p></li><li id='io_context.io_context-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#io_context.io_context-4.2'>(4.2)</a></div><p >the number of function objects that have been added to the <span class='texttt'>io_context</span> via any executor of the <span class='texttt'>io_context</span>, but not yet executed; and
</p></li><li id='io_context.io_context-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#io_context.io_context-4.3'>(4.3)</a></div><p >the number of function objects that are currently being executed by the <span class='texttt'>io_context</span>.
</p></li></ul></div><div class='para' id='io_context.io_context-5'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context-5'>5</a></div><p >If at any time the outstanding work falls to <span class='texttt'>0</span>, the <span class='texttt'>io_context</span> is stopped as if by <span class='texttt'>stop()</span>.</p></div><div class='para' id='io_context.io_context-6'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context-6'>6</a></div><p >The <span class='texttt'>io_context</span> member functions <span class='texttt'>get_executor</span>, <span class='texttt'>stop</span>, and <span class='texttt'>stopped</span>, the run functions, and the <span class='texttt'>io_context::executor_type</span> copy constructors, member functions and comparison operators, do not introduce data races as a result of concurrent calls to those functions from different threads of execution. [&nbsp;<i>Note:</i> The <span class='texttt'>restart</span> member function is excluded from these thread safety requirements. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='io_context.io_context.members'><h3 ><a class='secnum' href='#io_context.io_context.members' style='min-width:103pt'>14.2.1</a> <span class='texttt'>io_context</span> members <a class='abbr_ref' href='io_context.io_context.members'>[io_context.io_context.members]</a></h3><p ><span class='indexparent'><a class='index' id='io_context,constructor'></a></span><code class='itemdecl'>
io_context();
explicit io_context(int concurrency_hint);
</code></p><div class='itemdescr'></div><div class='para' id='io_context.io_context.members-1'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Creates an object of class <span class='texttt'>io_context</span>.</p></div></div><div class='para' id='io_context.io_context.members-2'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> The <span class='texttt'>concurrency_hint</span> parameter is a suggestion to the implementation on the number of threads that should process asynchronous operations and execute function objects.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_executor,io_context'></a></span><span class='indexparent'><a class='index' id='io_context,get_executor'></a></span><code class='itemdecl'>
executor_type get_executor() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.io_context.members-3'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> An executor that may be used for submitting function objects to the <span class='texttt'>io_context</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='run,io_context'></a></span><span class='indexparent'><a class='index' id='io_context,run'></a></span><code class='itemdecl'>
count_type run();
</code></p><div class='itemdescr'></div><div class='para' id='io_context.io_context.members-4'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> Must not be called from a thread that is currently calling a run function.</p></div></div><div class='para' id='io_context.io_context.members-5'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
count_type n = 0;
while (run_one())
  if (n != numeric_limits&lt;count_type&gt;::max())
    ++n;
</pre></div></div><div class='para' id='io_context.io_context.members-6'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='run_for,io_context'></a></span><span class='indexparent'><a class='index' id='io_context,run_for'></a></span><code class='itemdecl'>
template&lt;class Rep, class Period&gt;
  count_type run_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></p><div class='itemdescr'></div><div class='para' id='io_context.io_context.members-7'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
return run_until(chrono::steady_clock::now() + rel_time);
</pre></div></div><p ><span class='indexparent'><a class='index' id='run_until,io_context'></a></span><span class='indexparent'><a class='index' id='io_context,run_until'></a></span><code class='itemdecl'>
template&lt;class Clock, class Duration&gt;
  count_type run_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</code></p><div class='itemdescr'></div><div class='para' id='io_context.io_context.members-8'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
count_type n = 0;
while (run_one_until(abs_time))
  if (n != numeric_limits&lt;count_type&gt;::max())
    ++n;
</pre></div></div><div class='para' id='io_context.io_context.members-9'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='run_one,io_context'></a></span><span class='indexparent'><a class='index' id='io_context,run_one'></a></span><code class='itemdecl'>
count_type run_one();
</code></p><div class='itemdescr'></div><div class='para' id='io_context.io_context.members-10'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-10'>10</a></div><div class='itemdescr'><p ><i>Requires:</i> Must not be called from a thread that is currently calling a run function.</p></div></div><div class='para' id='io_context.io_context.members-11'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> If the <span class='texttt'>io_context</span> object has no outstanding work, performs <span class='texttt'>stop()</span>. Otherwise, blocks while the io_context has outstanding work, or until the <span class='texttt'>io_context</span> is stopped, or until one function object has been executed.</p></div></div><div class='para' id='io_context.io_context.members-12'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-12'>12</a></div><div class='itemdescr'><p >If an executed function object throws an exception, the exception propagates to the caller of <span class='texttt'>run_one()</span>. The <span class='texttt'>io_context</span> state is as if the function object had returned normally.</p></div></div><div class='para' id='io_context.io_context.members-13'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>1</span> if a function object was executed, otherwise <span class='texttt'>0</span>.</p></div></div><div class='para' id='io_context.io_context.members-14'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-14'>14</a></div><div class='itemdescr'><p >Notes: This function may invoke additional function objects through nested calls to the <span class='texttt'>io_context</span> executor's <span class='texttt'>dispatch</span> member function. These do not count towards the return value.
</p></div></div><p ><span class='indexparent'><a class='index' id='run_one_for,io_context'></a></span><span class='indexparent'><a class='index' id='io_context,run_one_for'></a></span><code class='itemdecl'>
template&lt;class Rep, class Period&gt;
  count_type run_one_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></p><div class='itemdescr'></div><div class='para' id='io_context.io_context.members-15'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
return run_one_until(chrono::steady_clock::now() + rel_time);
</pre></div></div><p ><span class='indexparent'><a class='index' id='run_one_until,io_context'></a></span><span class='indexparent'><a class='index' id='io_context,run_one_until'></a></span><code class='itemdecl'>
template&lt;class Clock, class Duration&gt;
  count_type run_one_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</code></p><div class='itemdescr'></div><div class='para' id='io_context.io_context.members-16'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> If the <span class='texttt'>io_context</span> object has no outstanding work, performs <span class='texttt'>stop()</span>. Otherwise, blocks while the io_context has outstanding work, or until the expiration of the absolute timeout (C++Std &sect;<a href='../n4140/thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span>, or until the <span class='texttt'>io_context</span> is stopped, or until one function object has been executed.</p></div></div><div class='para' id='io_context.io_context.members-17'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-17'>17</a></div><div class='itemdescr'><p >If an executed function object throws an exception, the exception propagates to the caller of <span class='texttt'>run_one()</span>. The <span class='texttt'>io_context</span> state is as if the function object had returned normally.</p></div></div><div class='para' id='io_context.io_context.members-18'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-18'>18</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>1</span> if a function object was executed, otherwise <span class='texttt'>0</span>.</p></div></div><div class='para' id='io_context.io_context.members-19'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-19'>19</a></div><div class='itemdescr'><p >Notes: This function may invoke additional function objects through nested calls to the <span class='texttt'>io_context</span> executor's <span class='texttt'>dispatch</span> member function. These do not count towards the return value.
</p></div></div><p ><span class='indexparent'><a class='index' id='poll,io_context'></a></span><span class='indexparent'><a class='index' id='io_context,poll'></a></span><code class='itemdecl'>
count_type poll();
</code></p><div class='itemdescr'></div><div class='para' id='io_context.io_context.members-20'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
count_type n = 0;
while (poll_one())
  if (n != numeric_limits&lt;count_type&gt;::max())
    ++n;
</pre></div></div><div class='para' id='io_context.io_context.members-21'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-21'>21</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='poll_one,io_context'></a></span><span class='indexparent'><a class='index' id='io_context,poll_one'></a></span><code class='itemdecl'>
count_type poll_one();
</code></p><div class='itemdescr'></div><div class='para' id='io_context.io_context.members-22'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i> If the <span class='texttt'>io_context</span> object has no outstanding work, performs <span class='texttt'>stop()</span>. Otherwise, if there is a function object ready for immediate execution, executes it.</p></div></div><div class='para' id='io_context.io_context.members-23'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-23'>23</a></div><div class='itemdescr'><p >If an executed function object throws an exception, the exception propagates to the caller of <span class='texttt'>poll_one()</span>. The <span class='texttt'>io_context</span> state is as if the function object had returned normally.</p></div></div><div class='para' id='io_context.io_context.members-24'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-24'>24</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>1</span> if a function object was invoked, otherwise <span class='texttt'>0</span>.</p></div></div><div class='para' id='io_context.io_context.members-25'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-25'>25</a></div><div class='itemdescr'><p >Notes: This function may invoke additional function objects through nested calls to the <span class='texttt'>io_context</span> executor's <span class='texttt'>dispatch</span> member function. These do not count towards the return value.
</p></div></div><p ><span class='indexparent'><a class='index' id='stop,io_context'></a></span><span class='indexparent'><a class='index' id='io_context,stop'></a></span><code class='itemdecl'>
void stop();
</code></p><div class='itemdescr'></div><div class='para' id='io_context.io_context.members-26'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-26'>26</a></div><div class='itemdescr'><p ><i>Effects:</i> Stops the <span class='texttt'>io_context</span>. Concurrent calls to any run function will end as soon as possible. If a call to a run function is currently executing a function object, the call will end only after completion of that function object. The call to <span class='texttt'>stop()</span> returns without waiting for concurrent calls to run functions to complete.</p></div></div><div class='para' id='io_context.io_context.members-27'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-27'>27</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>stopped() == true</span>.</p></div></div><div class='para' id='io_context.io_context.members-28'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-28'>28</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> When <span class='texttt'>stopped() == true</span>, subsequent calls to a run function will exit immediately with a return value of <span class='texttt'>0</span>, without executing any function objects. An <span class='texttt'>io_context</span> remains in the stopped state until a call to <span class='texttt'>restart()</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='stopped,io_context'></a></span><span class='indexparent'><a class='index' id='io_context,stopped'></a></span><code class='itemdecl'>
bool stopped() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.io_context.members-29'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-29'>29</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the <span class='texttt'>io_context</span> is stopped.
</p></div></div><p ><span class='indexparent'><a class='index' id='restart,io_context'></a></span><span class='indexparent'><a class='index' id='io_context,restart'></a></span><code class='itemdecl'>
void restart();
</code></p><div class='itemdescr'></div><div class='para' id='io_context.io_context.members-30'><div class='marginalizedparent'><a class='marginalized' href='#io_context.io_context.members-30'>30</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>stopped() == false</span>.
</p></div></div></div></div><div id='io_context.exec'><h2 ><a class='secnum' href='#io_context.exec' style='min-width:88pt'>14.3</a> Class <span class='texttt'>io_context::executor_type</span> <a class='abbr_ref' href='io_context.exec'>[io_context.exec]</a></h2><p ><span class='indexparent'><a class='index' id='io_context::executor_type'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class io_context::executor_type
  {
  public:
    <span class='comment'>// construct / copy / destroy:
</span>
    executor_type(const executor_type&amp; other) noexcept;
    executor_type(executor_type&amp;&amp; other) noexcept;

    executor_type&amp; operator=(const executor_type&amp; other) noexcept;
    executor_type&amp; operator=(executor_type&amp;&amp; other) noexcept;

    <span class='comment'>// executor operations:
</span>
    bool running_in_this_thread() const noexcept;

    io_context&amp; context() const noexcept;

    void on_work_started() const noexcept;
    void on_work_finished() const noexcept;

    template&lt;class Func, class ProtoAllocator&gt;
      void dispatch(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
    template&lt;class Func, class ProtoAllocator&gt;
      void post(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
    template&lt;class Func, class ProtoAllocator&gt;
      void defer(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
  };

  bool operator==(const io_context::executor_type&amp; a,
                  const io_context::executor_type&amp; b) noexcept;
  bool operator!=(const io_context::executor_type&amp; a,
                  const io_context::executor_type&amp; b) noexcept;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='io_context.exec-1'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec-1'>1</a></div><p ><span class='texttt'>io_context::executor_type</span> is a type satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>). Objects of type <span class='texttt'>io_context::executor_type</span> are associated with an <span class='texttt'>io_context</span>, and function objects submitted using the <span class='texttt'>dispatch</span>, <span class='texttt'>post</span>, or <span class='texttt'>defer</span> member functions will be executed by the <span class='texttt'>io_context</span> from within a run function.]</p></div><div id='io_context.exec.cons'><h3 ><a class='secnum' href='#io_context.exec.cons' style='min-width:103pt'>14.3.1</a> <span class='texttt'>io_context::executor_type</span> constructors <a class='abbr_ref' href='io_context.exec.cons'>[io_context.exec.cons]</a></h3><p ><span class='indexparent'><a class='index' id='io_context::executor_type,constructor'></a></span><code class='itemdecl'>
executor_type(const executor_type&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.exec.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this == other</span>.
</p></div></div><p ><code class='itemdecl'>
executor_type(executor_type&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.exec.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>other</span>.
</p></div></div></div><div id='io_context.exec.assign'><h3 ><a class='secnum' href='#io_context.exec.assign' style='min-width:103pt'>14.3.2</a> <span class='texttt'>io_context::executor_type</span> assignment <a class='abbr_ref' href='io_context.exec.assign'>[io_context.exec.assign]</a></h3><p ><span class='indexparent'><a class='index' id='operator=,io_context::executor_type'></a></span><span class='indexparent'><a class='index' id='io_context::executor_type,operator='></a></span><code class='itemdecl'>
executor_type&amp; operator=(const executor_type&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.exec.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.assign-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this == other</span>.</p></div></div><div class='para' id='io_context.exec.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
executor_type&amp; operator=(executor_type&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.exec.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.assign-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>other</span>.</p></div></div><div class='para' id='io_context.exec.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.assign-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='io_context.exec.ops'><h3 ><a class='secnum' href='#io_context.exec.ops' style='min-width:103pt'>14.3.3</a> <span class='texttt'>io_context::executor_type</span> operations <a class='abbr_ref' href='io_context.exec.ops'>[io_context.exec.ops]</a></h3><p ><span class='indexparent'><a class='index' id='running_in_this_thread,io_context::executor_type'></a></span><span class='indexparent'><a class='index' id='io_context::executor_type,running_in_this_thread'></a></span><code class='itemdecl'>
bool running_in_this_thread() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.exec.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the current thread of execution is calling a run function of the associated <span class='texttt'>io_context</span> object. [&nbsp;<i>Note:</i> That is, the current thread of execution's call chain includes a run function. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='context,io_context::executor_type'></a></span><span class='indexparent'><a class='index' id='io_context::executor_type,context'></a></span><code class='itemdecl'>
io_context&amp; context() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.exec.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.ops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to the associated <span class='texttt'>io_context</span> object.
</p></div></div><p ><span class='indexparent'><a class='index' id='on_work_started,io_context::executor_type'></a></span><span class='indexparent'><a class='index' id='io_context::executor_type,on_work_started'></a></span><code class='itemdecl'>
void on_work_started() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.exec.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.ops-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Increments the count of outstanding work associated with the <span class='texttt'>io_context</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='on_work_finished,io_context::executor_type'></a></span><span class='indexparent'><a class='index' id='io_context::executor_type,on_work_finished'></a></span><code class='itemdecl'>
void on_work_finished() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.exec.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.ops-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Decrements the count of outstanding work associated with the <span class='texttt'>io_context</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='dispatch,io_context::executor_type'></a></span><span class='indexparent'><a class='index' id='io_context::executor_type,dispatch'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void dispatch(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.exec.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.ops-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>running_in_this_thread()</span> is <span class='texttt'>true</span>, calls <span class='texttt'><i>DECAY_COPY</i>(forward&lt;Func&gt;(f))()</span> (C++Std &sect;<a href='../n4140/thread.decaycopy'>[thread.decaycopy]</a>). [&nbsp;<i>Note:</i> If <span class='texttt'>f</span> exits via an exception, the exception propagates to the caller of <span class='texttt'>dispatch()</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Otherwise, calls <span class='texttt'>post(forward&lt;Func&gt;(f), a)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='post,io_context::executor_type'></a></span><span class='indexparent'><a class='index' id='io_context::executor_type,post'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void post(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.exec.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.ops-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Adds <span class='texttt'>f</span> to the <span class='texttt'>io_context</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='defer,io_context::executor_type'></a></span><span class='indexparent'><a class='index' id='io_context::executor_type,defer'></a></span><code class='itemdecl'>
template&lt;class Func, class ProtoAllocator&gt;
  void defer(Func&amp;&amp; f, const ProtoAllocator&amp; a) const;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.exec.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.ops-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Adds <span class='texttt'>f</span> to the <span class='texttt'>io_context</span>.
</p></div></div></div><div id='io_context.exec.comparisons'><h3 ><a class='secnum' href='#io_context.exec.comparisons' style='min-width:103pt'>14.3.4</a> <span class='texttt'>io_context::executor_type</span> comparisons <a class='abbr_ref' href='io_context.exec.comparisons'>[io_context.exec.comparisons]</a></h3><p ><span class='indexparent'><a class='index' id='operator==,io_context::executor_type'></a></span><span class='indexparent'><a class='index' id='io_context::executor_type,operator=='></a></span><code class='itemdecl'>
bool operator==(const io_context::executor_type&amp; a,
                const io_context::executor_type&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.exec.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>addressof(a.context()) == addressof(b.context())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,io_context::executor_type'></a></span><span class='indexparent'><a class='index' id='io_context::executor_type,operator!='></a></span><code class='itemdecl'>
bool operator!=(const io_context::executor_type&amp; a,
                const io_context::executor_type&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='io_context.exec.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#io_context.exec.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div></div></div></div><div id='timer'><h1 ><a class='secnum' href='#timer' style='min-width:73pt'>15</a> Timers <a class='abbr_ref' href='./#timer'>[timer]</a></h1><div class='para' id='timer-1'><div class='marginalizedparent'><a class='marginalized' href='#timer-1'>1</a></div><p >This clause defines components for performing timer operations.</p></div><div class='para' id='timer-2'><div class='marginalizedparent'><a class='marginalized' href='#timer-2'>2</a></div><p >[&nbsp;<i>Example:</i> Performing a synchronous wait operation on a timer:
</p><pre class='codeblock'>
io_context c;
steady_timer t(c);
t.expires_after(seconds(5));
t.wait();
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='timer-3'><div class='marginalizedparent'><a class='marginalized' href='#timer-3'>3</a></div><p >[&nbsp;<i>Example:</i> Performing an asynchronous wait operation on a timer:
</p><pre class='codeblock'>
void handler(error_code ec) { ... }
...
io_context c;
steady_timer t(c);
t.expires_after(seconds(5));
t.async_wait(handler);
c.run();
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='experimental/timer'></a></span></p></div><div id='timer.synop'><h2 ><a class='secnum' href='#timer.synop' style='min-width:88pt'>15.1</a> Header <span class='texttt'>&lt;experimental/timer&gt;</span> synopsis <a class='abbr_ref' href='timer.synop'>[timer.synop]</a></h2><pre class='codeblock'>
#include &lt;chrono&gt;

namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Clock&gt; struct wait_traits;

  template&lt;class Clock, class WaitTraits = wait_traits&lt;Clock&gt;&gt;
    class basic_waitable_timer;

  using system_timer = basic_waitable_timer&lt;chrono::system_clock&gt;;
  using steady_timer = basic_waitable_timer&lt;chrono::steady_clock&gt;;
  using high_resolution_timer = basic_waitable_timer&lt;chrono::high_resolution_clock&gt;;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div id='timer.reqmts'><h2 ><a class='secnum' href='#timer.reqmts' style='min-width:88pt'>15.2</a> Requirements <a class='abbr_ref' href='timer.reqmts'>[timer.reqmts]</a></h2><div id='timer.reqmts.waittraits'><h3 ><a class='secnum' href='#timer.reqmts.waittraits' style='min-width:103pt'>15.2.1</a> Wait traits requirements <a class='abbr_ref' href='timer.reqmts.waittraits'>[timer.reqmts.waittraits]</a></h3><div class='para' id='timer.reqmts.waittraits-1'><div class='marginalizedparent'><a class='marginalized' href='#timer.reqmts.waittraits-1'>1</a></div><p >The <span class='texttt'>basic_waitable_timer</span> template uses wait traits to allow programs to customize <span class='texttt'>wait</span> and <span class='texttt'>async_wait</span> behavior.
[&nbsp;<i>Note:</i> Possible uses of wait traits include:
</p><ul class='itemize'><li id='timer.reqmts.waittraits-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#timer.reqmts.waittraits-1.1'>(1.1)</a></div><p >To enable timers based on non-realtime clocks.
</p></li><li id='timer.reqmts.waittraits-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#timer.reqmts.waittraits-1.2'>(1.2)</a></div><p >Determining how quickly wallclock-based timers respond to system time changes.
</p></li><li id='timer.reqmts.waittraits-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#timer.reqmts.waittraits-1.3'>(1.3)</a></div><p >Correcting for errors or rounding timeouts to boundaries.
</p></li><li id='timer.reqmts.waittraits-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#timer.reqmts.waittraits-1.4'>(1.4)</a></div><p >Preventing duration overflow. That is, a program may set a timer's expiry <span class='texttt'>e</span> to be <span class='texttt'>Clock::max()</span> (meaning never reached) or <span class='texttt'>Clock::min()</span> (meaning always in the past). As a result, computing the duration until timer expiry as <span class='texttt'>e - Clock::now()</span> may cause overflow. </p></li></ul><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='timer.reqmts.waittraits-2'><div class='marginalizedparent'><a class='marginalized' href='#timer.reqmts.waittraits-2'>2</a></div><p >For a type <span class='texttt'>Clock</span> meeting the <span class='texttt'>Clock</span> requirements (C++Std &sect;<a href='../n4140/time.clock.req'>[time.clock.req]</a>), a type <span class='texttt'>X</span> meets the <span class='texttt'>WaitTraits</span> requirements if it satisfies the requirements listed below.</p></div><div class='para' id='timer.reqmts.waittraits-3'><div class='marginalizedparent'><a class='marginalized' href='#timer.reqmts.waittraits-3'>3</a></div><p >In Table <a href='timer.reqmts.waittraits#tab:timer.reqmts.waittraits.requirements'>[tab:timer.reqmts.waittraits.requirements]</a>,
<span class='texttt'>t</span> denotes a value of type <span class='texttt'>Clock::time_point</span> or <span class='texttt'>const Clock::time_point</span>;
and <span class='texttt'>d</span> denotes a value of type <span class='texttt'>Clock::duration</span> or <span class='texttt'>const Clock::duration</span>.</p><p ><span class='indexparent'><a class='index' id='requirements,WaitTraits'></a></span>
 
 
 </p><div class='numberedTable' id='tab:timer.reqmts.waittraits.requirements'>Table <a href='#tab:timer.reqmts.waittraits.requirements'>11</a> — WaitTraits requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::to_wait_duration(d)</span>  </td><td class='left'>
<span class='texttt'>Clock::duration</span>  </td><td class='left'>
Returns a <span class='texttt'>Clock::duration</span> value to be used in a <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operation. [&nbsp;<i>Note:</i> The return value is typically representative of the duration <span class='texttt'>d</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::to_wait_duration(t)</span>  </td><td class='left'>
<span class='texttt'>Clock::duration</span>  </td><td class='left'>
Returns a <span class='texttt'>Clock::duration</span> value to be used in a <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operation. [&nbsp;<i>Note:</i> The return value is typically representative of the duration from <span class='texttt'>Clock::now()</span> until the time point <span class='texttt'>t</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr></table></div></div></div></div><div id='timer.waittraits'><h2 ><a class='secnum' href='#timer.waittraits' style='min-width:88pt'>15.3</a> Class template <span class='texttt'>wait_traits</span> <a class='abbr_ref' href='timer.waittraits'>[timer.waittraits]</a></h2><p ><span class='indexparent'><a class='index' id='wait_traits'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Clock&gt;
  struct wait_traits
  {
    static typename Clock::duration to_wait_duration(
      const typename Clock::duration&amp; d);

    static typename Clock::duration to_wait_duration(
      const typename Clock::time_point&amp; t);
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='timer.waittraits-1'><div class='marginalizedparent'><a class='marginalized' href='#timer.waittraits-1'>1</a></div><p >Class template <span class='texttt'>wait_traits</span> satisfies the <span class='texttt'>WaitTraits</span> (<a href='timer.reqmts.waittraits'>[timer.reqmts.waittraits]</a>) type requirements. Template argument <span class='texttt'>Clock</span> is a type meeting the <span class='texttt'>Clock</span> requirements (C++Std &sect;<a href='../n4140/time.clock.req'>[time.clock.req]</a>).</p><p ><span class='indexparent'><a class='index' id='to_wait_duration,wait_traits'></a></span><span class='indexparent'><a class='index' id='wait_traits,to_wait_duration'></a></span><code class='itemdecl'>
static typename Clock::duration to_wait_duration(
  const typename Clock::duration&amp; d);
</code></p></div><div class='itemdescr'></div><div class='para' id='timer.waittraits-2'><div class='marginalizedparent'><a class='marginalized' href='#timer.waittraits-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>d</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_wait_duration,wait_traits'></a></span><span class='indexparent'><a class='index' id='wait_traits,to_wait_duration'></a></span><code class='itemdecl'>
static typename Clock::duration to_wait_duration(
  const typename Clock::time_point&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='timer.waittraits-3'><div class='marginalizedparent'><a class='marginalized' href='#timer.waittraits-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> Let <span class='texttt'>now</span> be <span class='texttt'>Clock::now()</span>. If <span class='texttt'>now + Clock::duration::max()</span> is before <span class='texttt'>t</span>, <span class='texttt'>Clock::duration::max()</span>; if <span class='texttt'>now + Clock::duration::min()</span> is after <span class='texttt'>t</span>, <span class='texttt'>Clock::duration::min()</span>; otherwise, <span class='texttt'>t - now</span>.
</p></div></div></div><div id='timer.waitable'><h2 ><a class='secnum' href='#timer.waitable' style='min-width:88pt'>15.4</a> Class template <span class='texttt'>basic_waitable_timer</span> <a class='abbr_ref' href='timer.waitable'>[timer.waitable]</a></h2><p ><span class='indexparent'><a class='index' id='basic_waitable_timer'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Clock, class WaitTraits = wait_traits&lt;Clock&gt;&gt;
  class basic_waitable_timer
  {
  public:
    <span class='comment'>// types:
</span>
    using executor_type = io_context::executor_type;
    using clock_type = Clock;
    using duration = typename clock_type::duration;
    using time_point = typename clock_type::time_point;
    using traits_type = WaitTraits;

    <span class='comment'>// construct / copy / destroy:
</span>
    explicit basic_waitable_timer(io_context&amp; ctx);
    basic_waitable_timer(io_context&amp; ctx, const time_point&amp; t);
    basic_waitable_timer(io_context&amp; ctx, const duration&amp; d);
    basic_waitable_timer(const basic_waitable_timer&amp;) = delete;
    basic_waitable_timer(basic_waitable_timer&amp;&amp; rhs);

    ~basic_waitable_timer();

    basic_waitable_timer&amp; operator=(const basic_waitable_timer&amp;) = delete;
    basic_waitable_timer&amp; operator=(basic_waitable_timer&amp;&amp; rhs);

    <span class='comment'>// basic_waitable_timer operations:
</span>
    executor_type get_executor() noexcept;

    size_t cancel();
    size_t cancel_one();

    time_point expiry() const;
    size_t expires_at(const time_point&amp; t);
    size_t expires_after(const duration&amp; d);

    void wait();
    void wait(error_code&amp; ec);

    template&lt;class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_wait(CompletionToken&amp;&amp; token);
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='timer.waitable-1'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable-1'>1</a></div><p >Instances of class template <span class='texttt'>basic_waitable_timer</span> meet the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), and <span class='texttt'>MoveAssignable</span> (C++Std &sect;<a href='../n4140/moveassignable'>[moveassignable]</a>).</p></div><div id='timer.waitable.cons'><h3 ><a class='secnum' href='#timer.waitable.cons' style='min-width:103pt'>15.4.1</a> <span class='texttt'>basic_waitable_timer</span> constructors <a class='abbr_ref' href='timer.waitable.cons'>[timer.waitable.cons]</a></h3><p ><span class='indexparent'><a class='index' id='basic_waitable_timer,constructor'></a></span><code class='itemdecl'>
explicit basic_waitable_timer(io_context&amp; ctx);
</code></p><div class='itemdescr'></div><div class='para' id='timer.waitable.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>basic_waitable_timer(ctx, time_point())</span>.
</p></div></div><p ><code class='itemdecl'>
basic_waitable_timer(io_context&amp; ctx, const time_point&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='timer.waitable.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='timer.waitable.cons-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#timer.waitable.cons-2.1'>(2.1)</a></div><p ><span class='texttt'>get_executor() == ctx.get_executor()</span>.
</p></li><li id='timer.waitable.cons-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#timer.waitable.cons-2.2'>(2.2)</a></div><p ><span class='texttt'>expiry() == t</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
basic_waitable_timer(io_context&amp; ctx, const duration&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='timer.waitable.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets the expiry time as if by calling <span class='texttt'>expires_after(d)</span>.</p></div></div><div class='para' id='timer.waitable.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.cons-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_executor() == ctx.get_executor()</span>.
</p></div></div><p ><code class='itemdecl'>
basic_waitable_timer(basic_waitable_timer&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='timer.waitable.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs an object of class <span class='texttt'>basic_waitable_timer&lt;Clock, WaitTraits&gt;</span> that refers to the state originally represented by <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='timer.waitable.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.cons-6'>6</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='timer.waitable.cons-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#timer.waitable.cons-6.1'>(6.1)</a></div><p ><span class='texttt'>get_executor() == rhs.get_executor()</span>.
</p></li><li id='timer.waitable.cons-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#timer.waitable.cons-6.2'>(6.2)</a></div><p ><span class='texttt'>expiry()</span> returns the same value as <span class='texttt'>rhs.expiry()</span> prior to the constructor invocation.
</p></li><li id='timer.waitable.cons-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#timer.waitable.cons-6.3'>(6.3)</a></div><p ><span class='texttt'>rhs.expiry() == time_point()</span>.
</p></li></ul></div></div></div><div id='timer.waitable.dtor'><h3 ><a class='secnum' href='#timer.waitable.dtor' style='min-width:103pt'>15.4.2</a> <span class='texttt'>basic_waitable_timer</span> destructor <a class='abbr_ref' href='timer.waitable.dtor'>[timer.waitable.dtor]</a></h3><p ><span class='indexparent'><a class='index' id='basic_waitable_timer,destructor'></a></span><code class='itemdecl'>
~basic_waitable_timer();
</code></p><div class='itemdescr'></div><div class='para' id='timer.waitable.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys the timer, canceling any asynchronous wait operations associated with the timer as if by calling <span class='texttt'>cancel()</span>.
</p></div></div></div><div id='timer.waitable.assign'><h3 ><a class='secnum' href='#timer.waitable.assign' style='min-width:103pt'>15.4.3</a> <span class='texttt'>basic_waitable_timer</span> assignment <a class='abbr_ref' href='timer.waitable.assign'>[timer.waitable.assign]</a></h3><p ><span class='indexparent'><a class='index' id='operator=,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,operator='></a></span><code class='itemdecl'>
basic_waitable_timer&amp; operator=(basic_waitable_timer&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='timer.waitable.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Cancels any outstanding asynchronous operations associated with <span class='texttt'>*this</span> as if by calling <span class='texttt'>cancel()</span>, then moves into <span class='texttt'>*this</span> the state originally represented by <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='timer.waitable.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.assign-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='timer.waitable.assign-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#timer.waitable.assign-2.1'>(2.1)</a></div><p ><span class='texttt'>get_executor() == rhs.get_executor()</span>.
</p></li><li id='timer.waitable.assign-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#timer.waitable.assign-2.2'>(2.2)</a></div><p ><span class='texttt'>expiry()</span> returns the same value as <span class='texttt'>rhs.expiry()</span> prior to the assignment.
</p></li><li id='timer.waitable.assign-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#timer.waitable.assign-2.3'>(2.3)</a></div><p ><span class='texttt'>rhs.expiry() == time_point()</span>.
</p></li></ul></div></div><div class='para' id='timer.waitable.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.assign-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='timer.waitable.ops'><h3 ><a class='secnum' href='#timer.waitable.ops' style='min-width:103pt'>15.4.4</a> <span class='texttt'>basic_waitable_timer</span> operations <a class='abbr_ref' href='timer.waitable.ops'>[timer.waitable.ops]</a></h3><p ><span class='indexparent'><a class='index' id='get_executor,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,get_executor'></a></span><code class='itemdecl'>
executor_type get_executor() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='timer.waitable.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The associated executor.
</p></div></div><p ><span class='indexparent'><a class='index' id='cancel,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,cancel'></a></span><code class='itemdecl'>
size_t cancel();
</code></p><div class='itemdescr'></div><div class='para' id='timer.waitable.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Causes any outstanding asynchronous wait operations to complete. Completion handlers for canceled operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='timer.waitable.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of operations that were canceled.</p></div></div><div class='para' id='timer.waitable.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> Does not block (C++Std &sect;<a href='../n4140/defns.block'>[defns.block]</a>) the calling thread pending completion of the canceled operations.
</p></div></div><p ><span class='indexparent'><a class='index' id='cancel_one,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,cancel_one'></a></span><code class='itemdecl'>
size_t cancel_one();
</code></p><div class='itemdescr'></div><div class='para' id='timer.waitable.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Causes the outstanding asynchronous wait operation that was initiated first, if any, to complete as soon as possible. The completion handler for the canceled operation is passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='timer.waitable.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>1</span> if an operation was canceled, otherwise <span class='texttt'>0</span>.</p></div></div><div class='para' id='timer.waitable.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i> Does not block (C++Std &sect;<a href='../n4140/defns.block'>[defns.block]</a>) the calling thread pending completion of the canceled operation.
</p></div></div><p ><span class='indexparent'><a class='index' id='expiry,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,expiry'></a></span><code class='itemdecl'>
time_point expiry() const;
</code></p><div class='itemdescr'></div><div class='para' id='timer.waitable.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> The expiry time associated with the timer, as previously set using <span class='texttt'>expires_at()</span> or <span class='texttt'>expires_after()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='expires_at,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,expires_at'></a></span><code class='itemdecl'>
size_t expires_at(const time_point&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='timer.waitable.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Cancels outstanding asynchronous wait operations, as if by calling <span class='texttt'>cancel()</span>. Sets the expiry time associated with the timer.</p></div></div><div class='para' id='timer.waitable.ops-10'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of operations that were canceled.</p></div></div><div class='para' id='timer.waitable.ops-11'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-11'>11</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>expiry() == t</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='expires_after,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,expires_after'></a></span><code class='itemdecl'>
size_t expires_after(const duration&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='timer.waitable.ops-12'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>expires_at(clock_type::now() + d)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='wait,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,wait'></a></span><code class='itemdecl'>
void wait();
void wait(error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='timer.waitable.ops-13'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Establishes the postcondition as if by repeatedly blocking the calling thread (C++Std &sect;<a href='../n4140/defns.block'>[defns.block]</a>) for the relative time produced by <span class='texttt'>WaitTraits::to_wait_duration(expiry())</span>.</p></div></div><div class='para' id='timer.waitable.ops-14'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-14'>14</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>ec || expiry() &lt;= clock_type::now()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='asynchronous_wait_operation'></a></span><span class='indexparent'><a class='index' id='async_wait,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,async_wait'></a></span><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_wait(CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='timer.waitable.ops-15'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-15'>15</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec)</span>.</p></div></div><div class='para' id='timer.waitable.ops-16'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous wait operation to repeatedly wait for the relative time produced by <span class='texttt'>WaitTraits::to_wait_duration(e)</span>, where <span class='texttt'>e</span> is a value of type <span class='texttt'>time_point</span> such that <span class='texttt'>e &lt;= expiry()</span>. The completion handler is submitted for execution only when the condition <span class='texttt'>ec || expiry() &lt;= clock_type::now()</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='timer.waitable.ops-17'><div class='marginalizedparent'><a class='marginalized' href='#timer.waitable.ops-17'>17</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> To implement <span class='texttt'>async_wait</span>, an <span class='texttt'>io_context</span> object <span class='texttt'>ctx</span> may maintain a priority queue for each specialization of <span class='texttt'>basic_waitable_timer&lt;Clock, WaitTraits&gt;</span> for which a timer object was initialized with <span class='texttt'>ctx</span>. Only the time point <span class='texttt'>e</span> of the earliest outstanding expiry need be passed to <span class='texttt'>WaitTraits::to_wait_duration(e)</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div></div></div><div id='buffer'><h1 ><a class='secnum' href='#buffer' style='min-width:73pt'>16</a> Buffers <a class='abbr_ref' href='./#buffer'>[buffer]</a></h1><p ><span class='indexparent'><a class='index' id='experimental/buffer'></a></span></p><div id='buffer.synop'><h2 ><a class='secnum' href='#buffer.synop' style='min-width:88pt'>16.1</a> Header <span class='texttt'>&lt;experimental/buffer&gt;</span> synopsis <a class='abbr_ref' href='buffer.synop'>[buffer.synop]</a></h2><p ><span class='indexparent'><a class='index' id='is_mutable_buffer_sequence_v'></a></span><span class='indexparent'><a class='index' id='is_const_buffer_sequence_v'></a></span><span class='indexparent'><a class='index' id='is_dynamic_buffer_v'></a></span><span class='indexparent'><a class='index' id='stream_errc'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  enum class stream_errc {
    eof = <i>an implementation defined non-zero value</i>,
    not_found = <i>an implementation defined non-zero value</i>
  };

  const error_category&amp; stream_category() noexcept;

  error_code make_error_code(stream_errc e) noexcept;
  error_condition make_error_condition(stream_errc e) noexcept;

  class mutable_buffer;
  class const_buffer;

  <span class='comment'>// buffer type traits:
</span>
  template&lt;class T&gt; struct is_mutable_buffer_sequence;
  template&lt;class T&gt; struct is_const_buffer_sequence;
  template&lt;class T&gt; struct is_dynamic_buffer;

  template&lt;class T&gt;
      constexpr bool is_mutable_buffer_sequence_v = is_mutable_buffer_sequence&lt;T&gt;::value;
    template&lt;class T&gt;
      constexpr bool is_const_buffer_sequence_v = is_const_buffer_sequence&lt;T&gt;::value;
    template&lt;class T&gt;
      constexpr bool is_dynamic_buffer_v = is_dynamic_buffer&lt;T&gt;::value;

  <span class='comment'>// buffer sequence access:
</span>
  const mutable_buffer* buffer_sequence_begin(const mutable_buffer&amp; b);
  const const_buffer* buffer_sequence_begin(const const_buffer&amp; b);
  const mutable_buffer* buffer_sequence_end(const mutable_buffer&amp; b);
  const const_buffer* buffer_sequence_end(const const_buffer&amp; b);
  template&lt;class C&gt; auto buffer_sequence_begin(C&amp; c) -&gt; decltype(c.begin());
  template&lt;class C&gt; auto buffer_sequence_begin(const C&amp; c) -&gt; decltype(c.begin());
  template&lt;class C&gt; auto buffer_sequence_end(C&amp; c) -&gt; decltype(c.end());
  template&lt;class C&gt; auto buffer_sequence_end(const C&amp; c) -&gt; decltype(c.end());

  <span class='comment'>// buffer size:
</span>
  template&lt;class ConstBufferSequence&gt;
    size_t buffer_size(const ConstBufferSequence&amp; buffers) noexcept;

  <span class='comment'>// buffer copy:
</span>
  template&lt;class MutableBufferSequence, class ConstBufferSequence&gt;
    size_t buffer_copy(const MutableBufferSequence&amp; dest,
                       const ConstBufferSequence&amp; source) noexcept;
  template&lt;class MutableBufferSequence, class ConstBufferSequence&gt;
    size_t buffer_copy(const MutableBufferSequence&amp; dest,
                       const ConstBufferSequence&amp; source,
                       size_t max_size) noexcept;

  <span class='comment'>// buffer arithmetic:
</span>
  mutable_buffer operator+(const mutable_buffer&amp; b, size_t n) noexcept;
  mutable_buffer operator+(size_t n, const mutable_buffer&amp; b) noexcept;
  const_buffer operator+(const const_buffer&amp;, size_t n) noexcept;
  const_buffer operator+(size_t, const const_buffer&amp;) noexcept;

  <span class='comment'>// buffer creation:
</span>
  mutable_buffer buffer(void* p, size_t n) noexcept;
  const_buffer buffer(const void* p, size_t n) noexcept;

  mutable_buffer buffer(const mutable_buffer&amp; b) noexcept;
  mutable_buffer buffer(const mutable_buffer&amp; b, size_t n) noexcept;
  const_buffer buffer(const const_buffer&amp; b) noexcept;
  const_buffer buffer(const const_buffer&amp; b, size_t n) noexcept;

  template&lt;class T, size_t N&gt;
    mutable_buffer buffer(T (&amp;data)[N]) noexcept;
  template&lt;class T, size_t N&gt;
    const_buffer buffer(const T (&amp;data)[N]) noexcept;
  template&lt;class T, size_t N&gt;
    mutable_buffer buffer(array&lt;T, N&gt;&amp; data) noexcept;
  template&lt;class T, size_t N&gt;
    const_buffer buffer(array&lt;const T, N&gt;&amp; data) noexcept;
  template&lt;class T, size_t N&gt;
    const_buffer buffer(const array&lt;T, N&gt;&amp; data) noexcept;
  template&lt;class T, class Allocator&gt;
    mutable_buffer buffer(vector&lt;T, Allocator&gt;&amp; data) noexcept;
  template&lt;class T, class Allocator&gt;
    const_buffer buffer(const vector&lt;T, Allocator&gt;&amp; data) noexcept;
  template&lt;class CharT, class Traits, class Allocator&gt;
    mutable_buffer buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; data) noexcept;
  template&lt;class CharT, class Traits, class Allocator&gt;
    const_buffer buffer(const basic_string&lt;CharT, Traits, Allocator&gt;&amp; data) noexcept;
  template&lt;class CharT, class Traits&gt;
    const_buffer buffer(basic_string_view&lt;CharT, Traits&gt; data) noexcept;

  template&lt;class T, size_t N&gt;
    mutable_buffer buffer(T (&amp;data)[N], size_t n) noexcept;
  template&lt;class T, size_t N&gt;
    const_buffer buffer(const T (&amp;data)[N], size_t n) noexcept;
  template&lt;class T, size_t N&gt;
    mutable_buffer buffer(array&lt;T, N&gt;&amp; data, size_t n) noexcept;
  template&lt;class T, size_t N&gt;
    const_buffer buffer(array&lt;const T, N&gt;&amp; data, size_t n) noexcept;
  template&lt;class T, size_t N&gt;
    const_buffer buffer(const array&lt;T, N&gt;&amp; data, size_t n) noexcept;
  template&lt;class T, class Allocator&gt;
    mutable_buffer buffer(vector&lt;T, Allocator&gt;&amp; data, size_t n) noexcept;
  template&lt;class T, class Allocator&gt;
    const_buffer buffer(const vector&lt;T, Allocator&gt;&amp; data, size_t n) noexcept;
  template&lt;class CharT, class Traits, class Allocator&gt;
    mutable_buffer buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; data,
                          size_t n) noexcept;
  template&lt;class CharT, class Traits, class Allocator&gt;
    const_buffer buffer(const basic_string&lt;CharT, Traits, Allocator&gt;&amp; data,
                        size_t n) noexcept;
  template&lt;class CharT, class Traits&gt;
    const_buffer buffer(basic_string_view&lt;CharT, Traits&gt; data,
                        size_t n) noexcept;

  template&lt;class T, class Allocator&gt;
    class dynamic_vector_buffer;

  template&lt;class CharT, class Traits, class Allocator&gt;
    class dynamic_string_buffer;

  <span class='comment'>// dynamic buffer creation:
</span>
  template&lt;class T, class Allocator&gt;
    dynamic_vector_buffer&lt;T, Allocator&gt;
    dynamic_buffer(vector&lt;T, Allocator&gt;&amp; vec) noexcept;
  template&lt;class T, class Allocator&gt;
    dynamic_vector_buffer&lt;T, Allocator&gt;
    dynamic_buffer(vector&lt;T, Allocator&gt;&amp; vec, size_t n) noexcept;

  template&lt;class CharT, class Traits, class Allocator&gt;
    dynamic_string_buffer&lt;CharT, Traits, Allocator&gt;
    dynamic_buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; str) noexcept;
  template&lt;class CharT, class Traits, class Allocator&gt;
    dynamic_string_buffer&lt;CharT, Traits, Allocator&gt;
    dynamic_buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; str, size_t n) noexcept;

  class transfer_all;
  class transfer_at_least;
  class transfer_exactly;

  <span class='comment'>// synchronous read operations:
</span>
  template&lt;class SyncReadStream, class MutableBufferSequence&gt;
    size_t read(SyncReadStream&amp; stream,
                const MutableBufferSequence&amp; buffers);
  template&lt;class SyncReadStream, class MutableBufferSequence&gt;
    size_t read(SyncReadStream&amp; stream,
                const MutableBufferSequence&amp; buffers, error_code&amp; ec);
  template&lt;class SyncReadStream, class MutableBufferSequence,
    class CompletionCondition&gt;
      size_t read(SyncReadStream&amp; stream,
                  const MutableBufferSequence&amp; buffers,
                  CompletionCondition completion_condition);
  template&lt;class SyncReadStream, class MutableBufferSequence,
    class CompletionCondition&gt;
      size_t read(SyncReadStream&amp; stream,
                  const MutableBufferSequence&amp; buffers,
                  CompletionCondition completion_condition,
                  error_code&amp; ec);

  template&lt;class SyncReadStream, class DynamicBuffer&gt;
    size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;&amp; b);
  template&lt;class SyncReadStream, class DynamicBuffer&gt;
    size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;&amp; b, error_code&amp; ec);
  template&lt;class SyncReadStream, class DynamicBuffer, class CompletionCondition&gt;
    size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;&amp; b,
                CompletionCondition completion_condition);
  template&lt;class SyncReadStream, class DynamicBuffer, class CompletionCondition&gt;
    size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;&amp; b,
                CompletionCondition completion_condition, error_code&amp; ec);

  <span class='comment'>// asynchronous read operations:
</span>
  template&lt;class AsyncReadStream, class MutableBufferSequence,
    class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_read(AsyncReadStream&amp; stream,
                         const MutableBufferSequence&amp; buffers,
                         CompletionToken&amp;&amp; token);
  template&lt;class AsyncReadStream, class MutableBufferSequence,
    class CompletionCondition, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_read(AsyncReadStream&amp; stream,
                         const MutableBufferSequence&amp; buffers,
                         CompletionCondition completion_condition,
                         CompletionToken&amp;&amp; token);

  template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_read(AsyncReadStream&amp; stream,
                       DynamicBuffer&amp;&amp; b, CompletionToken&amp;&amp; token);
  template&lt;class AsyncReadStream, class DynamicBuffer,
    class CompletionCondition, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_read(AsyncReadStream&amp; stream,
                         DynamicBuffer&amp;&amp; b,
                         CompletionCondition completion_condition,
                         CompletionToken&amp;&amp; token);

  <span class='comment'>// synchronous write operations:
</span>
  template&lt;class SyncWriteStream, class ConstBufferSequence&gt;
    size_t write(SyncWriteStream&amp; stream,
                 const ConstBufferSequence&amp; buffers);
  template&lt;class SyncWriteStream, class ConstBufferSequence&gt;
    size_t write(SyncWriteStream&amp; stream,
                 const ConstBufferSequence&amp; buffers, error_code&amp; ec);
  template&lt;class SyncWriteStream, class ConstBufferSequence,
    class CompletionCondition&gt;
      size_t write(SyncWriteStream&amp; stream,
                   const ConstBufferSequence&amp; buffers,
                   CompletionCondition completion_condition);
  template&lt;class SyncWriteStream, class ConstBufferSequence,
    class CompletionCondition&gt;
      size_t write(SyncWriteStream&amp; stream,
                   const ConstBufferSequence&amp; buffers,
                   CompletionCondition completion_condition,
                   error_code&amp; ec);

  template&lt;class SyncWriteStream, class DynamicBuffer&gt;
    size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;&amp; b);
  template&lt;class SyncWriteStream, class DynamicBuffer&gt;
    size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;&amp; b, error_code&amp; ec);
  template&lt;class SyncWriteStream, class DynamicBuffer, class CompletionCondition&gt;
    size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;&amp; b,
                 CompletionCondition completion_condition);
  template&lt;class SyncWriteStream, class DynamicBuffer, class CompletionCondition&gt;
    size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;&amp; b,
                 CompletionCondition completion_condition, error_code&amp; ec);

  <span class='comment'>// asynchronous write operations:
</span>
  template&lt;class AsyncWriteStream, class ConstBufferSequence,
    class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_write(AsyncWriteStream&amp; stream,
                          const ConstBufferSequence&amp; buffers,
                          CompletionToken&amp;&amp; token);
  template&lt;class AsyncWriteStream, class ConstBufferSequence,
    class CompletionCondition, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_write(AsyncWriteStream&amp; stream,
                          const ConstBufferSequence&amp; buffers,
                          CompletionCondition completion_condition,
                          CompletionToken&amp;&amp; token);

  template&lt;class AsyncWriteStream, class DynamicBuffer, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_write(AsyncWriteStream&amp; stream,
                     DynamicBuffer&amp;&amp; b, CompletionToken&amp;&amp; token);
  template&lt;class AsyncWriteStream, class DynamicBuffer,
    class CompletionCondition, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_write(AsyncWriteStream&amp; stream,
                          DynamicBuffer&amp;&amp; b,
                          CompletionCondition completion_condition,
                          CompletionToken&amp;&amp; token);

  <span class='comment'>// synchronous delimited read operations:
</span>
  template&lt;class SyncReadStream, class DynamicBuffer&gt;
    size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b, char delim);
  template&lt;class SyncReadStream, class DynamicBuffer&gt;
    size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b,
                      char delim, error_code&amp; ec);
  template&lt;class SyncReadStream, class DynamicBuffer&gt;
    size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b, string_view delim);
  template&lt;class SyncReadStream, class DynamicBuffer&gt;
    size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b,
                      string_view delim, error_code&amp; ec);

  <span class='comment'>// asynchronous delimited read operations:
</span>
  template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_read_until(AsyncReadStream&amp; s,
                             DynamicBuffer&amp;&amp; b, char delim,
                             CompletionToken&amp;&amp; token);
  template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_read_until(AsyncReadStream&amp; s,
                             DynamicBuffer&amp;&amp; b, string_view delim,
                             CompletionToken&amp;&amp; token);

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>
  template&lt;&gt; struct is_error_code_enum&lt;
    experimental::net::v1::stream_errc&gt;
      : public true_type {};

} <span class='comment'>// namespace std
</span></pre></div><div id='buffer.reqmts'><h2 ><a class='secnum' href='#buffer.reqmts' style='min-width:88pt'>16.2</a> Requirements <a class='abbr_ref' href='buffer.reqmts'>[buffer.reqmts]</a></h2><div id='buffer.reqmts.mutablebuffersequence'><h3 ><a class='secnum' href='#buffer.reqmts.mutablebuffersequence' style='min-width:103pt'>16.2.1</a> Mutable buffer sequence requirements <a class='abbr_ref' href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a></h3><div class='para' id='buffer.reqmts.mutablebuffersequence-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.reqmts.mutablebuffersequence-1'>1</a></div><p >A <a class='hidden_link' href='#def:mutable_buffer_sequence' id='def:mutable_buffer_sequence'><i>mutable buffer sequence</i></a> represents a set of memory regions that may be used to receive the output of an operation, such as the <span class='texttt'>receive</span> operation of a socket.</p></div><div class='para' id='buffer.reqmts.mutablebuffersequence-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.reqmts.mutablebuffersequence-2'>2</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>MutableBufferSequence</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) and <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), as well as the additional requirements listed in Table <a href='buffer.reqmts.mutablebuffersequence#tab:buffer.reqmts.mutablebuffersequence.requirements'>[tab:buffer.reqmts.mutablebuffersequence.requirements]</a>.</p></div><div class='para' id='buffer.reqmts.mutablebuffersequence-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.reqmts.mutablebuffersequence-3'>3</a></div><p >In Table <a href='buffer.reqmts.mutablebuffersequence#tab:buffer.reqmts.mutablebuffersequence.requirements'>[tab:buffer.reqmts.mutablebuffersequence.requirements]</a>,
<span class='texttt'>x</span> denotes a value of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>,
and <span class='texttt'>u</span> denotes an identifier.</p><p ><span class='indexparent'><a class='index' id='requirements,MutableBufferSequence'></a></span>
 
 </p><div class='numberedTable' id='tab:buffer.reqmts.mutablebuffersequence.requirements'>Table <a href='#tab:buffer.reqmts.mutablebuffersequence.requirements'>12</a> — MutableBufferSequence requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note</b></td></tr><tr ><td colspan='1' class='center'><b></b></td><td colspan='1' class='center'><b></b></td><td colspan='1' class='center'><b>pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>net::buffer_sequence_begin(x)</span><br/>
<span class='texttt'>net::buffer_sequence_end(x)</span>  </td><td class='left'>
An iterator type meeting the requirements for bidirectional iterators (C++Std &sect;<a href='../n4140/bidirectional.iterators'>[bidirectional.iterators]</a>) whose value type is convertible to <span class='texttt'>mutable_buffer</span>.  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(x);</span>
  </td><td class='left'>
  </td><td class='left'>
post: <pre class='codeblock'>
equal(
  net::buffer_sequence_begin(x),
  net::buffer_sequence_end(x),
  net::buffer_sequence_begin(u),
  net::buffer_sequence_end(u),
  [](const typename X::value_type&amp; v1,
     const typename X::value_type&amp; v2)
   {
     mutable_buffer b1(v1);
     mutable_buffer b2(v2);
     return b1.data() == b2.data()
         &amp;&amp; b1.size() == b2.size();
   })
</pre>
  </td></tr></table></div></div></div><div id='buffer.reqmts.constbuffersequence'><h3 ><a class='secnum' href='#buffer.reqmts.constbuffersequence' style='min-width:103pt'>16.2.2</a> Constant buffer sequence requirements <a class='abbr_ref' href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a></h3><div class='para' id='buffer.reqmts.constbuffersequence-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.reqmts.constbuffersequence-1'>1</a></div><p >A <a class='hidden_link' href='#def:constant_buffer_sequence' id='def:constant_buffer_sequence'><i>constant buffer sequence</i></a> represents a set of memory regions that may be used as input to an operation, such as the <span class='texttt'>send</span> operation of a socket.</p></div><div class='para' id='buffer.reqmts.constbuffersequence-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.reqmts.constbuffersequence-2'>2</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>ConstBufferSequence</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) and <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), as well as the additional requirements listed in Table <a href='buffer.reqmts.constbuffersequence#tab:buffer.reqmts.constbuffersequence.requirements'>[tab:buffer.reqmts.constbuffersequence.requirements]</a>.</p></div><div class='para' id='buffer.reqmts.constbuffersequence-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.reqmts.constbuffersequence-3'>3</a></div><p >In Table <a href='buffer.reqmts.constbuffersequence#tab:buffer.reqmts.constbuffersequence.requirements'>[tab:buffer.reqmts.constbuffersequence.requirements]</a>,
<span class='texttt'>x</span> denotes a value of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>,
and <span class='texttt'>u</span> denotes an identifier.</p><p ><span class='indexparent'><a class='index' id='requirements,ConstBufferSequence'></a></span>
 
 </p><div class='numberedTable' id='tab:buffer.reqmts.constbuffersequence.requirements'>Table <a href='#tab:buffer.reqmts.constbuffersequence.requirements'>13</a> — ConstBufferSequence requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note</b></td></tr><tr ><td colspan='1' class='center'><b></b></td><td colspan='1' class='center'><b></b></td><td colspan='1' class='center'><b>pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>net::buffer_sequence_begin(x)</span><br/>
<span class='texttt'>net::buffer_sequence_end(x)</span>  </td><td class='left'>
An iterator type meeting the requirements for bidirectional iterators (C++Std &sect;<a href='../n4140/bidirectional.iterators'>[bidirectional.iterators]</a>) whose value type is convertible to <span class='texttt'>const_buffer</span>.  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(x);</span>
  </td><td class='left'>
  </td><td class='left'>
post:
<pre class='codeblock'>
equal(
  net::buffer_sequence_begin(x),
  net::buffer_sequence_end(x),
  net::buffer_sequence_begin(u),
  net::buffer_sequence_end(u),
  [](const typename X::value_type&amp; v1,
     const typename X::value_type&amp; v2)
   {
     const_buffer b1(v1);
     const_buffer b2(v2);
     return b1.data() == b2.data()
         &amp;&amp; b1.size() == b2.size();
   })
</pre>
  </td></tr></table></div></div></div><div id='buffer.reqmts.dynamicbuffer'><h3 ><a class='secnum' href='#buffer.reqmts.dynamicbuffer' style='min-width:103pt'>16.2.3</a> Dynamic buffer requirements <a class='abbr_ref' href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a></h3><div class='para' id='buffer.reqmts.dynamicbuffer-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.reqmts.dynamicbuffer-1'>1</a></div><p >A <a class='hidden_link' href='#def:dynamic_buffer' id='def:dynamic_buffer'><i>dynamic buffer</i></a> encapsulates memory storage that may be automatically resized as required, where the memory is divided into two regions: readable bytes followed by writable bytes. These memory regions are internal to the dynamic buffer, but direct access to the elements is provided to permit them to be efficiently used with I/O operations. [&nbsp;<i>Note:</i> Such as the <span class='texttt'>send</span> or <span class='texttt'>receive</span> operations of a socket. The readable bytes would be used as the constant buffer sequence for <span class='texttt'>send</span>, and the writable bytes used as the mutable buffer sequence for <span class='texttt'>receive</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Data written to the writable bytes of a dynamic buffer object is appended to the readable bytes of the same object.</p></div><div class='para' id='buffer.reqmts.dynamicbuffer-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.reqmts.dynamicbuffer-2'>2</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>DynamicBuffer</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) and <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), as well as the additional requirements listed in Table <a href='buffer.reqmts.dynamicbuffer#tab:buffer.reqmts.dynamicbuffer.requirements'>[tab:buffer.reqmts.dynamicbuffer.requirements]</a>.</p></div><div class='para' id='buffer.reqmts.dynamicbuffer-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.reqmts.dynamicbuffer-3'>3</a></div><p >In Table <a href='buffer.reqmts.dynamicbuffer#tab:buffer.reqmts.dynamicbuffer.requirements'>[tab:buffer.reqmts.dynamicbuffer.requirements]</a>,
<span class='texttt'>x</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>x1</span> denotes a value of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>,
and <span class='texttt'>n</span> denotes a value of type <span class='texttt'>size_t</span> or <span class='texttt'>const size_t</span>.</p><p ><span class='indexparent'><a class='index' id='requirements,DynamicBuffer'></a></span>
 
 
 </p><div class='numberedTable' id='tab:buffer.reqmts.dynamicbuffer.requirements'>Table <a href='#tab:buffer.reqmts.dynamicbuffer.requirements'>14</a> — DynamicBuffer requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::const_buffers_type</span>  </td><td class='left'>
type meeting ConstBufferSequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) requirements.  </td><td class='left'>
 This type represents the memory associated with the readable bytes.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::mutable_buffers_type</span>  </td><td class='left'>
type meeting MutableBufferSequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) requirements.  </td><td class='left'>
 This type represents the memory associated with the writable bytes.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.size()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
 Returns the number of readable bytes.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.max_size()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns the maximum number of bytes, both readable and writable, that can be held by <span class='texttt'>x1</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.capacity()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns the maximum number of bytes, both readable and writable, that can be held by <span class='texttt'>x1</span> without requiring reallocation.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.data()</span>  </td><td class='left'>
<span class='texttt'>X::const_buffers_type</span>  </td><td class='left'>
Returns a constant buffer sequence <span class='texttt'>u</span> that represents the readable bytes, and where <span class='texttt'>buffer_size(u) == size()</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.prepare(n)</span>  </td><td class='left'>
<span class='texttt'>X::mutable_buffers_type</span>  </td><td class='left'>
Returns a mutable buffer sequence <span class='texttt'>u</span> representing the writable bytes, and where <span class='texttt'>buffer_size(u) == n</span>. The dynamic buffer reallocates memory as required. All constant or mutable buffer sequences previously obtained using <span class='texttt'>data()</span> or <span class='texttt'>prepare()</span> are invalidated.<br/> <i>Throws:</i> <span class='texttt'>length_error</span> if <span class='texttt'>size() + n</span> exceeds <span class='texttt'>max_size()</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.commit(n)</span>  </td><td class='left'>
  </td><td class='left'>
Appends <span class='texttt'>n</span> bytes from the start of the writable bytes to the end of the readable bytes. The remainder of the writable bytes are discarded. If <span class='texttt'>n</span> is greater than the number of writable bytes, all writable bytes are appended to the readable bytes. All constant or mutable buffer sequences previously obtained using <span class='texttt'>data()</span> or <span class='texttt'>prepare()</span> are invalidated.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.consume(n)</span>  </td><td class='left'>
  </td><td class='left'>
Removes <span class='texttt'>n</span> bytes from beginning of the readable bytes. If <span class='texttt'>n</span> is greater than the number of readable bytes, all readable bytes are removed. All constant or mutable buffer sequences previously obtained using <span class='texttt'>data()</span> or <span class='texttt'>prepare()</span> are invalidated.  </td></tr></table></div></div></div><div id='buffer.reqmts.read.write'><h3 ><a class='secnum' href='#buffer.reqmts.read.write' style='min-width:103pt'>16.2.4</a> Requirements on read and write operations <a class='abbr_ref' href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a></h3><div class='para' id='buffer.reqmts.read.write-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.reqmts.read.write-1'>1</a></div><p >A <a class='hidden_link' href='#def:read_operation' id='def:read_operation'><i>read operation</i></a> is an operation that reads data into a mutable buffer sequence argument of a type meeting <span class='texttt'>MutableBufferSequence</span> (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) requirements. The mutable buffer sequence specifies memory where the data should be placed. A read operation shall always fill a buffer in the sequence completely before proceeding to the next.</p></div><div class='para' id='buffer.reqmts.read.write-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.reqmts.read.write-2'>2</a></div><p >A <a class='hidden_link' href='#def:write_operation' id='def:write_operation'><i>write operation</i></a> is an operation that writes data from a constant buffer sequence argument of a type meeting <span class='texttt'>ConstBufferSequence</span> (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) requirements. The constant buffer sequence specifies memory where the data to be written is located. A write operation shall always write a buffer in the sequence completely before proceeding to the next.</p><p ><span class='indexparent'><a class='index' id='asynchronous_operation'></a></span></p></div><div class='para' id='buffer.reqmts.read.write-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.reqmts.read.write-3'>3</a></div><p >If a read or write operation is also an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>), the operation shall maintain one or more copies of the buffer sequence until such time as the operation no longer requires access to the memory specified by the buffers in the sequence. The program shall ensure the memory remains valid until:</p><ul class='itemize'><li id='buffer.reqmts.read.write-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.reqmts.read.write-3.1'>(3.1)</a></div><p >the last copy of the buffer sequence is destroyed, or
</p></li><li id='buffer.reqmts.read.write-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.reqmts.read.write-3.2'>(3.2)</a></div><p >the completion handler for the asynchronous operation is invoked,
</p></li></ul><p >whichever comes first.</p><p ><span class='indexparent'><a class='index' id='error_codes,stream'></a></span></p></div></div></div><div id='buffer.err'><h2 ><a class='secnum' href='#buffer.err' style='min-width:88pt'>16.3</a> Error codes <a class='abbr_ref' href='buffer.err'>[buffer.err]</a></h2><p ><span class='indexparent'><a class='index' id='stream_category'></a></span><code class='itemdecl'>
const error_category&amp; stream_category() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.err-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.err-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to an object of a type derived from class <span class='texttt'>error_category</span>. All calls to this function return references to the same object.</p></div></div><div class='para' id='buffer.err-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.err-2'>2</a></div><div class='itemdescr'><p >The object's <span class='texttt'>default_error_condition</span> and <span class='texttt'>equivalent</span> virtual functions behave as specified for the class <span class='texttt'>error_category</span>. The object's <span class='texttt'>name</span> virtual function returns a pointer to the string <span class='texttt'>"stream"</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_error_code,stream_errc'></a></span><span class='indexparent'><a class='index' id='stream_errc,make_error_code'></a></span><code class='itemdecl'>
error_code make_error_code(stream_errc e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.err-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.err-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>error_code(static_cast&lt;int&gt;(e), stream_category())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_error_condition,stream_errc'></a></span><span class='indexparent'><a class='index' id='stream_errc,make_error_condition'></a></span><code class='itemdecl'>
error_condition make_error_condition(stream_errc e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.err-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.err-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>error_condition(static_cast&lt;int&gt;(e), stream_category())</span>.
</p></div></div></div><div id='buffer.mutable'><h2 ><a class='secnum' href='#buffer.mutable' style='min-width:88pt'>16.4</a> Class <span class='texttt'>mutable_buffer</span> <a class='abbr_ref' href='buffer.mutable'>[buffer.mutable]</a></h2><p ><span class='indexparent'><a class='index' id='mutable_buffer'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class mutable_buffer
  {
  public:
    <span class='comment'>// constructors:
</span>    mutable_buffer() noexcept;
    mutable_buffer(void* p, size_t n) noexcept;

    <span class='comment'>// members:
</span>    void* data() const noexcept;
    size_t size() const noexcept;
    mutable_buffer&amp; operator+=(size_t n) noexcept;

  private:
    void* data_; <span class='comment'>// <i>exposition only</i>
</span>    size_t size_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='buffer.mutable-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.mutable-1'>1</a></div><p >The <span class='texttt'>mutable_buffer</span> class satisfies requirements of <span class='texttt'>MutableBufferSequence</span> (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>), <span class='texttt'>DefaultConstructible</span> (C++Std &sect;<a href='../n4140/defaultconstructible'>[defaultconstructible]</a>), and <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>).</p><p ><span class='indexparent'><a class='index' id='mutable_buffer,constructor'></a></span><code class='itemdecl'>
mutable_buffer() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='buffer.mutable-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.mutable-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>data_ == nullptr</span> and <span class='texttt'>size_ == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='mutable_buffer,constructor'></a></span><code class='itemdecl'>
mutable_buffer(void* p, size_t n) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.mutable-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.mutable-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>data_ == p</span> and <span class='texttt'>size_ == n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='data,mutable_buffer'></a></span><span class='indexparent'><a class='index' id='mutable_buffer,data'></a></span><code class='itemdecl'>
void* data() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.mutable-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.mutable-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>data_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='size,mutable_buffer'></a></span><span class='indexparent'><a class='index' id='mutable_buffer,size'></a></span><code class='itemdecl'>
size_t size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.mutable-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.mutable-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>size_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator+=,mutable_buffer'></a></span><span class='indexparent'><a class='index' id='mutable_buffer,operator+='></a></span><code class='itemdecl'>
mutable_buffer&amp; operator+=(size_t n) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.mutable-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.mutable-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets <span class='texttt'>data_</span> to <span class='texttt'>static_cast&lt;char*&gt;(data_) + min(n, size_)</span>, and then <span class='texttt'>size_</span> to <span class='texttt'>size_ - min(n, size_)</span>.</p></div></div><div class='para' id='buffer.mutable-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.mutable-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='buffer.const'><h2 ><a class='secnum' href='#buffer.const' style='min-width:88pt'>16.5</a> Class <span class='texttt'>const_buffer</span> <a class='abbr_ref' href='buffer.const'>[buffer.const]</a></h2><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class const_buffer
  {
  public:
    <span class='comment'>// constructors:
</span>    const_buffer() noexcept;
    const_buffer(const void* p, size_t n) noexcept;
    const_buffer(const mutable_buffer&amp; b) noexcept;

    <span class='comment'>// members:
</span>    const void* data() const noexcept;
    size_t size() const noexcept;
    const_buffer&amp; operator+=(size_t n) noexcept;

  private:
    const void* data_; <span class='comment'>// <i>exposition only</i>
</span>    size_t size_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='buffer.const-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.const-1'>1</a></div><p >The <span class='texttt'>const_buffer</span> class satisfies requirements of <span class='texttt'>ConstBufferSequence</span> (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>), <span class='texttt'>DefaultConstructible</span> (C++Std &sect;<a href='../n4140/defaultconstructible'>[defaultconstructible]</a>), and <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>).</p><p ><span class='indexparent'><a class='index' id='const_buffer,constructor'></a></span><code class='itemdecl'>
const_buffer() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='buffer.const-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.const-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>data_ == nullptr</span> and <span class='texttt'>size_ == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='const_buffer,constructor'></a></span><code class='itemdecl'>
const_buffer(const void* p, size_t n) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.const-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.const-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>data_ == p</span> and <span class='texttt'>size_ == n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='const_buffer,constructor'></a></span><code class='itemdecl'>
const_buffer(const mutable_buffer&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.const-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.const-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>data_ == b.data()</span> and <span class='texttt'>size_ == b.size()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='data,const_buffer'></a></span><span class='indexparent'><a class='index' id='const_buffer,data'></a></span><code class='itemdecl'>
const void* data() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.const-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.const-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>data_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='size,const_buffer'></a></span><span class='indexparent'><a class='index' id='const_buffer,size'></a></span><code class='itemdecl'>
size_t size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.const-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.const-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>size_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator+=,const_buffer'></a></span><span class='indexparent'><a class='index' id='const_buffer,operator+='></a></span><code class='itemdecl'>
const_buffer&amp; operator+=(size_t n) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.const-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.const-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets <span class='texttt'>data_</span> to <span class='texttt'>static_cast&lt;const char*&gt;(data_) + min(n, size_)</span>, and then <span class='texttt'>size_</span> to <span class='texttt'>size_ - min(n, size_)</span>.</p></div></div><div class='para' id='buffer.const-8'><div class='marginalizedparent'><a class='marginalized' href='#buffer.const-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='buffer.traits'><h2 ><a class='secnum' href='#buffer.traits' style='min-width:88pt'>16.6</a> Buffer type traits <a class='abbr_ref' href='buffer.traits'>[buffer.traits]</a></h2><p ><span class='indexparent'><a class='index' id='is_mutable_buffer_sequence'></a></span><span class='indexparent'><a class='index' id='is_const_buffer_sequence'></a></span><span class='indexparent'><a class='index' id='is_dynamic_buffer'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T&gt; struct is_mutable_buffer_sequence;
  template&lt;class T&gt; struct is_const_buffer_sequence;
  template&lt;class T&gt; struct is_dynamic_buffer;

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='buffer.traits-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.traits-1'>1</a></div><p >This sub-clause contains templates that may be used to query the properties of a type at compile time. Each of these templates is a UnaryTypeTrait (C++Std &sect;<a href='../n4140/meta.rqmts'>[meta.rqmts]</a>) with a BaseCharacteristic of <span class='texttt'>true_type</span> if the corresponding condition is true, otherwise <span class='texttt'>false_type</span>.</p><div class='numberedTable' id='tab:buffer.traits.requirements'>Table <a href='#tab:buffer.traits.requirements'>15</a> — Buffer type traits<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Preconditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>template&lt;class T&gt;</span><br/>
<span class='texttt'>struct is_mutable_buffer_sequence</span>  </td><td class='left'>
<span class='texttt'>T</span> meets the syntactic requirements for mutable buffer sequence (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>).  </td><td class='left'>
<span class='texttt'>T</span> is a complete type.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template&lt;class T&gt;</span><br/>
<span class='texttt'>struct is_const_buffer_sequence</span>  </td><td class='left'>
<span class='texttt'>T</span> meets the syntactic requirements for constant buffer sequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>).  </td><td class='left'>
<span class='texttt'>T</span> is a complete type.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template&lt;class T&gt;</span><br/>
<span class='texttt'>struct is_dynamic_buffer</span>  </td><td class='left'>
<span class='texttt'>T</span> meets the syntactic requirements for dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>).  </td><td class='left'>
<span class='texttt'>T</span> is a complete type.  </td></tr></table></div></div></div><div id='buffer.seq.access'><h2 ><a class='secnum' href='#buffer.seq.access' style='min-width:88pt'>16.7</a> Buffer sequence access <a class='abbr_ref' href='buffer.seq.access'>[buffer.seq.access]</a></h2><p ><span class='indexparent'><a class='index' id='buffer_sequence_begin'></a></span><code class='itemdecl'>
const mutable_buffer* buffer_sequence_begin(const mutable_buffer&amp; b);
const const_buffer* buffer_sequence_begin(const const_buffer&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.seq.access-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.seq.access-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>std::addressof(b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='buffer_sequence_end'></a></span><code class='itemdecl'>
const mutable_buffer* buffer_sequence_end(const mutable_buffer&amp; b);
const const_buffer* buffer_sequence_end(const const_buffer&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.seq.access-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.seq.access-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>std::addressof(b) + 1</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='buffer_sequence_begin'></a></span><code class='itemdecl'>
template&lt;class C&gt; auto buffer_sequence_begin(C&amp; c) -&gt; decltype(c.begin());
template&lt;class C&gt; auto buffer_sequence_begin(const C&amp; c) -&gt; decltype(c.begin());
</code></p><div class='itemdescr'></div><div class='para' id='buffer.seq.access-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.seq.access-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>c.begin()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='buffer_sequence_end'></a></span><code class='itemdecl'>
template&lt;class C&gt; auto buffer_sequence_end(C&amp; c) -&gt; decltype(c.end());
template&lt;class C&gt; auto buffer_sequence_end(const C&amp; c) -&gt; decltype(c.end());
</code></p><div class='itemdescr'></div><div class='para' id='buffer.seq.access-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.seq.access-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>c.end()</span>.
</p></div></div></div><div id='buffer.size'><h2 ><a class='secnum' href='#buffer.size' style='min-width:88pt'>16.8</a> Function <span class='texttt'>buffer_size</span> <a class='abbr_ref' href='buffer.size'>[buffer.size]</a></h2><p ><span class='indexparent'><a class='index' id='buffer_sequence_size'></a></span><code class='itemdecl'>
template&lt;class ConstBufferSequence&gt;
  size_t buffer_size(const ConstBufferSequence&amp; buffers) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.size-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.size-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The total size of all buffers in the sequence, as if computed as follows:
</p><pre class='codeblock'>
size_t total_size = 0;
auto i = std::experimental::net::buffer_sequence_begin(buffers);
auto end = std::experimental::net::buffer_sequence_end(buffers);
for (; i != end; ++i){
  const_buffer b(*i);
  total_size += b.size();
}
return total_size;
</pre></div></div></div><div id='buffer.copy'><h2 ><a class='secnum' href='#buffer.copy' style='min-width:88pt'>16.9</a> Function <span class='texttt'>buffer_copy</span> <a class='abbr_ref' href='buffer.copy'>[buffer.copy]</a></h2><p ><span class='indexparent'><a class='index' id='buffer_copy'></a></span><code class='itemdecl'>
template&lt;class MutableBufferSequence, class ConstBufferSequence&gt;
  size_t buffer_copy(const MutableBufferSequence&amp; dest,
                     const ConstBufferSequence&amp; source) noexcept;
template&lt;class MutableBufferSequence, class ConstBufferSequence&gt;
  size_t buffer_copy(const MutableBufferSequence&amp; dest,
                     const ConstBufferSequence&amp; source,
                     size_t max_size) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.copy-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.copy-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Copies bytes from the buffer sequence <span class='texttt'>source</span> to the buffer sequence <span class='texttt'>dest</span>, as if by calls to <span class='texttt'>memcpy</span>.</p></div></div><div class='para' id='buffer.copy-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.copy-2'>2</a></div><div class='itemdescr'><p >The number of bytes copied is the lesser of:
</p><ul class='itemize'><li id='buffer.copy-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.copy-2.1'>(2.1)</a></div><p ><span class='texttt'>buffer_size(dest)</span>;
</p></li><li id='buffer.copy-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.copy-2.2'>(2.2)</a></div><p ><span class='texttt'>buffer_size(source)</span>; and
</p></li><li id='buffer.copy-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.copy-2.3'>(2.3)</a></div><p ><span class='texttt'>max_size</span>, if specified.
</p></li></ul></div></div><div class='para' id='buffer.copy-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.copy-3'>3</a></div><div class='itemdescr'><p >The mutable buffer sequence <span class='texttt'>dest</span> specifies memory where the data should be placed. The operation always fills a buffer in the sequence completely before proceeding to the next.</p></div></div><div class='para' id='buffer.copy-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.copy-4'>4</a></div><div class='itemdescr'><p >The constant buffer sequence <span class='texttt'>source</span> specifies memory where the data to be written is located. The operation always copies a buffer in the sequence completely before proceeding to the next.</p></div></div><div class='para' id='buffer.copy-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.copy-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of bytes copied from <span class='texttt'>source</span> to <span class='texttt'>dest</span>.
</p></div></div></div><div id='buffer.arithmetic'><h2 ><a class='secnum' href='#buffer.arithmetic' style='min-width:88pt'>16.10</a> Buffer arithmetic <a class='abbr_ref' href='buffer.arithmetic'>[buffer.arithmetic]</a></h2><p ><code class='itemdecl'>
mutable_buffer operator+(const mutable_buffer&amp; b, size_t n) noexcept;
mutable_buffer operator+(size_t n, const mutable_buffer&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.arithmetic-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.arithmetic-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>mutable_buffer</span> equivalent to
</p><pre class='codeblock'>
mutable_buffer(
  static_cast&lt;char*&gt;(b.data()) + min(n, b.size()),
  b.size() - min(n, b.size()));
</pre></div></div><p ><code class='itemdecl'>
const_buffer operator+(const const_buffer&amp; b, size_t n) noexcept;
const_buffer operator+(size_t n, const const_buffer&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.arithmetic-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.arithmetic-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>const_buffer</span> equivalent to
</p><pre class='codeblock'>
const_buffer(
  static_cast&lt;const char*&gt;(b.data()) + min(n, b.size()),
  b.size() - min(n, b.size()));
</pre></div></div></div><div id='buffer.creation'><h2 ><a class='secnum' href='#buffer.creation' style='min-width:88pt'>16.11</a> Buffer creation functions <a class='abbr_ref' href='buffer.creation'>[buffer.creation]</a></h2><div class='para' id='buffer.creation-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.creation-1'>1</a></div><p >In the functions below, <span class='texttt'>T</span> must be a trivially copyable or standard-layout type (C++Std &sect;<a href='../n4140/basic.types'>[basic.types]</a>).</p></div><div class='para' id='buffer.creation-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.creation-2'>2</a></div><p >For the function overloads below that accept an argument of type <span class='texttt'>vector&lt;&gt;</span>, the buffer objects returned are invalidated by any vector operation that also invalidates all references, pointers and iterators referring to the elements in the sequence (C++Std &sect;<a href='../n4140/vector'>[vector]</a>).</p></div><div class='para' id='buffer.creation-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.creation-3'>3</a></div><p >For the function overloads below that accept an argument of type <span class='texttt'>basic_string&lt;&gt;</span>, the buffer objects returned are invalidated according to the rules defined for invalidation of references, pointers and iterators referring to elements of the sequence (C++Std &sect;<a href='../n4140/string.require'>[string.require]</a>).</p><p ><span class='indexparent'><a class='index' id='buffer'></a></span><code class='itemdecl'>
mutable_buffer buffer(void* p, size_t n) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='buffer.creation-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.creation-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>mutable_buffer(p, n)</span>.
</p></div></div><p ><code class='itemdecl'>
const_buffer buffer(const void* p, size_t n) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.creation-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.creation-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>const_buffer(p, n)</span>.
</p></div></div><p ><code class='itemdecl'>
mutable_buffer buffer(const mutable_buffer&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.creation-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.creation-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>b</span>.
</p></div></div><p ><code class='itemdecl'>
mutable_buffer buffer(const mutable_buffer&amp; b, size_t n) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.creation-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.creation-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>mutable_buffer(b.data(), min(b.size(), n))</span>.
</p></div></div><p ><code class='itemdecl'>
const_buffer buffer(const const_buffer&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.creation-8'><div class='marginalizedparent'><a class='marginalized' href='#buffer.creation-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>b</span>.
</p></div></div><p ><code class='itemdecl'>
const_buffer buffer(const const_buffer&amp; b, size_t n) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.creation-9'><div class='marginalizedparent'><a class='marginalized' href='#buffer.creation-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>const_buffer(b.data(), min(b.size(), n))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class T, size_t N&gt;
  mutable_buffer buffer(T (&amp;data)[N]) noexcept;
template&lt;class T, size_t N&gt;
  const_buffer buffer(const T (&amp;data)[N]) noexcept;
template&lt;class T, size_t N&gt;
  mutable_buffer buffer(array&lt;T, N&gt;&amp; data) noexcept;
template&lt;class T, size_t N&gt;
  const_buffer buffer(array&lt;const T, N&gt;&amp; data) noexcept;
template&lt;class T, size_t N&gt;
  const_buffer buffer(const array&lt;T, N&gt;&amp; data) noexcept;
template&lt;class T, class Allocator&gt;
  mutable_buffer buffer(vector&lt;T, Allocator&gt;&amp; data) noexcept;
template&lt;class T, class Allocator&gt;
  const_buffer buffer(const vector&lt;T, Allocator&gt;&amp; data) noexcept;
template&lt;class CharT, class Traits, class Allocator&gt;
  mutable_buffer buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; data) noexcept;
template&lt;class CharT, class Traits, class Allocator&gt;
  const_buffer buffer(const basic_string&lt;CharT, Traits, Allocator&gt;&amp; data) noexcept;
template&lt;class CharT, class Traits&gt;
  const_buffer buffer(basic_string_view&lt;CharT, Traits&gt; data) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.creation-10'><div class='marginalizedparent'><a class='marginalized' href='#buffer.creation-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><pre class='codeblock'>
buffer(
  begin(data) != end(data) ? std::addressof(*begin(data)) : nullptr,
  (end(data) - begin(data)) * sizeof(*begin(data)));
</pre></div></div><p ><code class='itemdecl'>
template&lt;class T, size_t N&gt;
  mutable_buffer buffer(T (&amp;data)[N], size_t n) noexcept;
template&lt;class T, size_t N&gt;
  const_buffer buffer(const T (&amp;data)[N], size_t n) noexcept;
template&lt;class T, size_t N&gt;
  mutable_buffer buffer(array&lt;T, N&gt;&amp; data, size_t n) noexcept;
template&lt;class T, size_t N&gt;
  const_buffer buffer(array&lt;const T, N&gt;&amp; data, size_t n) noexcept;
template&lt;class T, size_t N&gt;
  const_buffer buffer(const array&lt;T, N&gt;&amp; data, size_t n) noexcept;
template&lt;class T, class Allocator&gt;
  mutable_buffer buffer(vector&lt;T, Allocator&gt;&amp; data, size_t n) noexcept;
template&lt;class T, class Allocator&gt;
  const_buffer buffer(const vector&lt;T, Allocator&gt;&amp; data, size_t n) noexcept;
template&lt;class CharT, class Traits, class Allocator&gt;
  mutable_buffer buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; data,
                        size_t n) noexcept;
template&lt;class CharT, class Traits, class Allocator&gt;
  const_buffer buffer(const basic_string&lt;CharT, Traits, Allocator&gt;&amp; data,
                      size_t n) noexcept;
template&lt;class CharT, class Traits&gt;
  const_buffer buffer(basic_string_view&lt;CharT, Traits&gt; data,
                      size_t n) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.creation-11'><div class='marginalizedparent'><a class='marginalized' href='#buffer.creation-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>buffer(buffer(data), n)</span>.
</p></div></div></div><div id='buffer.dynamic.vector'><h2 ><a class='secnum' href='#buffer.dynamic.vector' style='min-width:88pt'>16.12</a> Class template <span class='texttt'>dynamic_vector_buffer</span> <a class='abbr_ref' href='buffer.dynamic.vector'>[buffer.dynamic.vector]</a></h2><p ><span class='indexparent'><a class='index' id='dynamic_vector_buffer'></a></span></p><div class='para' id='buffer.dynamic.vector-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-1'>1</a></div><p >Class template <span class='texttt'>dynamic_vector_buffer</span> is an adaptor used to automatically grow or shrink a <span class='texttt'>vector</span> object, to reflect the data successfully transferred in an I/O operation.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class T, class Allocator&gt;
  class dynamic_vector_buffer
  {
  public:
    <span class='comment'>// types:
</span>    using const_buffers_type = const_buffer;
    using mutable_buffers_type = mutable_buffer;

    <span class='comment'>// constructors:
</span>    explicit dynamic_vector_buffer(vector&lt;T, Allocator&gt;&amp; vec) noexcept;
    dynamic_vector_buffer(vector&lt;T, Allocator&gt;&amp; vec,
                          size_t maximum_size) noexcept;
    dynamic_vector_buffer(dynamic_vector_buffer&amp;&amp;) = default;

    <span class='comment'>// members:
</span>    size_t size() const noexcept;
    size_t max_size() const noexcept;
    size_t capacity() const noexcept;
    const_buffers_type data() const noexcept;
    mutable_buffers_type prepare(size_t n);
    void commit(size_t n);
    void consume(size_t n);

  private:
    vector&lt;T, Allocator&gt;&amp; vec_; <span class='comment'>// <i>exposition only</i>
</span>    size_t size_; <span class='comment'>// <i>exposition only</i>
</span>    const size_t max_size_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='buffer.dynamic.vector-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-2'>2</a></div><p >The <span class='texttt'>dynamic_vector_buffer</span> class template meets the requirements of <span class='texttt'>DynamicBuffer</span> (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>).</p></div><div class='para' id='buffer.dynamic.vector-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-3'>3</a></div><p >The <span class='texttt'>dynamic_vector_buffer</span> class template requires that <span class='texttt'>T</span> is a trivially copyable or standard-layout type (C++Std &sect;<a href='../n4140/basic.types'>[basic.types]</a>) and that <span class='texttt'>sizeof(T) == 1</span>.</p><p ><span class='indexparent'><a class='index' id='dynamic_vector_buffer,constructor'></a></span><code class='itemdecl'>
explicit dynamic_vector_buffer(vector&lt;T, Allocator&gt;&amp; vec) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='buffer.dynamic.vector-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>vec_</span> with <span class='texttt'>vec</span>, <span class='texttt'>size_</span> with <span class='texttt'>vec.size()</span>, and <span class='texttt'>max_size_</span> with <span class='texttt'>vec.max_size()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='dynamic_vector_buffer,constructor'></a></span><code class='itemdecl'>
dynamic_vector_buffer(vector&lt;T, Allocator&gt;&amp; vec,
                      size_t maximum_size) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.vector-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>vec.size() &lt;= maximum_size</span>.</p></div></div><div class='para' id='buffer.dynamic.vector-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>vec_</span> with <span class='texttt'>vec</span>, <span class='texttt'>size_</span> with <span class='texttt'>vec.size()</span>, and <span class='texttt'>max_size_</span> with <span class='texttt'>maximum_size</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='size,dynamic_vector_buffer'></a></span><span class='indexparent'><a class='index' id='dynamic_vector_buffer,size'></a></span><code class='itemdecl'>
size_t size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.vector-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>size_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='max_size,dynamic_vector_buffer'></a></span><span class='indexparent'><a class='index' id='dynamic_vector_buffer,max_size'></a></span><code class='itemdecl'>
size_t max_size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.vector-8'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>max_size_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='capacity,dynamic_vector_buffer'></a></span><span class='indexparent'><a class='index' id='dynamic_vector_buffer,capacity'></a></span><code class='itemdecl'>
size_t capacity() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.vector-9'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>vec_.capacity()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='data,dynamic_vector_buffer'></a></span><span class='indexparent'><a class='index' id='dynamic_vector_buffer,data'></a></span><code class='itemdecl'>
const_buffers_type data() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.vector-10'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>buffer(vec_, size_)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='prepare,dynamic_vector_buffer'></a></span><span class='indexparent'><a class='index' id='dynamic_vector_buffer,prepare'></a></span><code class='itemdecl'>
mutable_buffers_type prepare(size_t n);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.vector-11'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> Performs <span class='texttt'>vec_.resize(size_ + n)</span>.</p></div></div><div class='para' id='buffer.dynamic.vector-12'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>buffer(buffer(vec_) + size_, n)</span>.</p></div></div><div class='para' id='buffer.dynamic.vector-13'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-13'>13</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>length_error</span> if <span class='texttt'>size() + n</span> exceeds <span class='texttt'>max_size()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='commit,dynamic_vector_buffer'></a></span><span class='indexparent'><a class='index' id='dynamic_vector_buffer,commit'></a></span><code class='itemdecl'>
void commit(size_t n);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.vector-14'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> Performs:
</p><pre class='codeblock'>
size_ += min(n, vec_.size() - size_);
vec_.resize(size_);
</pre></div></div><p ><span class='indexparent'><a class='index' id='consume,dynamic_vector_buffer'></a></span><span class='indexparent'><a class='index' id='dynamic_vector_buffer,consume'></a></span><code class='itemdecl'>
void consume(size_t n);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.vector-15'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.vector-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> Performs:
</p><pre class='codeblock'>
size_t m = min(n, size_);
vec_.erase(vec_.begin(), vec_.begin() + m);
size_ -= m;
</pre></div></div></div><div id='buffer.dynamic.string'><h2 ><a class='secnum' href='#buffer.dynamic.string' style='min-width:88pt'>16.13</a> Class template <span class='texttt'>dynamic_string_buffer</span> <a class='abbr_ref' href='buffer.dynamic.string'>[buffer.dynamic.string]</a></h2><p ><span class='indexparent'><a class='index' id='dynamic_string_buffer'></a></span></p><div class='para' id='buffer.dynamic.string-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-1'>1</a></div><p >Class template <span class='texttt'>dynamic_string_buffer</span> is an adaptor used to automatically grow or shrink a <span class='texttt'>basic_string</span> object, to reflect the data successfully transferred in an I/O operation.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class CharT, class Traits, class Allocator&gt;
  class dynamic_string_buffer
  {
  public:
    <span class='comment'>// types:
</span>    using const_buffers_type = const_buffer;
    using mutable_buffers_type = mutable_buffer;

    <span class='comment'>// constructors:
</span>    explicit dynamic_string_buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; str) noexcept;
    dynamic_string_buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; str,
                          size_t maximum_size) noexcept;
    dynamic_string_buffer(dynamic_string_buffer&amp;&amp;) = default;

    <span class='comment'>// members:
</span>    size_t size() const noexcept;
    size_t max_size() const noexcept;
    size_t capacity() const noexcept;
    const_buffers_type data() const noexcept;
    mutable_buffers_type prepare(size_t n);
    void commit(size_t n) noexcept;
    void consume(size_t n);

  private:
    basic_string&lt;CharT, Traits, Allocator&gt;&amp; str_; <span class='comment'>// <i>exposition only</i>
</span>    size_t size_; <span class='comment'>// <i>exposition only</i>
</span>    const size_t max_size_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='buffer.dynamic.string-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-2'>2</a></div><p >The <span class='texttt'>dynamic_string_buffer</span> class template meets the requirements of <span class='texttt'>DynamicBuffer</span> (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>).</p></div><div class='para' id='buffer.dynamic.string-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-3'>3</a></div><p >The <span class='texttt'>dynamic_string_buffer</span> class template requires that <span class='texttt'>sizeof(CharT) == 1</span>.</p><p ><span class='indexparent'><a class='index' id='dynamic_string_buffer,constructor'></a></span><code class='itemdecl'>
explicit dynamic_string_buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; str) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='buffer.dynamic.string-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>str_</span> with <span class='texttt'>str</span>, <span class='texttt'>size_</span> with <span class='texttt'>str.size()</span>, and <span class='texttt'>max_size_</span> with <span class='texttt'>str.max_size()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='dynamic_string_buffer,constructor'></a></span><code class='itemdecl'>
dynamic_string_buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; str,
                      size_t maximum_size) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.string-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>str.size() &lt;= maximum_size</span>.</p></div></div><div class='para' id='buffer.dynamic.string-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>str_</span> with <span class='texttt'>str</span>, <span class='texttt'>size_</span> with <span class='texttt'>str.size()</span>, and <span class='texttt'>max_size_</span> with <span class='texttt'>maximum_size</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='size,dynamic_string_buffer'></a></span><span class='indexparent'><a class='index' id='dynamic_string_buffer,size'></a></span><code class='itemdecl'>
size_t size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.string-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>size_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='max_size,dynamic_string_buffer'></a></span><span class='indexparent'><a class='index' id='dynamic_string_buffer,max_size'></a></span><code class='itemdecl'>
size_t max_size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.string-8'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>max_size_</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='capacity,dynamic_string_buffer'></a></span><span class='indexparent'><a class='index' id='dynamic_string_buffer,capacity'></a></span><code class='itemdecl'>
size_t capacity() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.string-9'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>str_.capacity()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='data,dynamic_string_buffer'></a></span><span class='indexparent'><a class='index' id='dynamic_string_buffer,data'></a></span><code class='itemdecl'>
const_buffers_type data() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.string-10'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>buffer(str_, size_)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='prepare,dynamic_string_buffer'></a></span><span class='indexparent'><a class='index' id='dynamic_string_buffer,prepare'></a></span><code class='itemdecl'>
mutable_buffers_type prepare(size_t n);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.string-11'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> Performs <span class='texttt'>str_.resize(size_ + n)</span>.</p></div></div><div class='para' id='buffer.dynamic.string-12'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>buffer(buffer(str_) + size_, n)</span>.</p></div></div><div class='para' id='buffer.dynamic.string-13'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-13'>13</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>length_error</span> if <span class='texttt'>size() + n</span> exceeds <span class='texttt'>max_size()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='commit,dynamic_string_buffer'></a></span><span class='indexparent'><a class='index' id='dynamic_string_buffer,commit'></a></span><code class='itemdecl'>
void commit(size_t n) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.string-14'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> Performs:
</p><pre class='codeblock'>
size_ += min(n, str_.size() - size_);
str_.resize(size_);
</pre></div></div><p ><span class='indexparent'><a class='index' id='consume,dynamic_string_buffer'></a></span><span class='indexparent'><a class='index' id='dynamic_string_buffer,consume'></a></span><code class='itemdecl'>
void consume(size_t n);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.string-15'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.string-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> Performs:
</p><pre class='codeblock'>
size_t m = min(n, size_);
str_.erase(0, m);
size_ -= m;
</pre></div></div></div><div id='buffer.dynamic.creation'><h2 ><a class='secnum' href='#buffer.dynamic.creation' style='min-width:88pt'>16.14</a> Dynamic buffer creation functions <a class='abbr_ref' href='buffer.dynamic.creation'>[buffer.dynamic.creation]</a></h2><p ><span class='indexparent'><a class='index' id='dynamic_buffer'></a></span><code class='itemdecl'>
template&lt;class T, class Allocator&gt;
  dynamic_vector_buffer&lt;T, Allocator&gt;
  dynamic_buffer(vector&lt;T, Allocator&gt;&amp; vec) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.creation-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.creation-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>dynamic_vector_buffer&lt;T, Allocator&gt;(vec)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class T, class Allocator&gt;
  dynamic_vector_buffer&lt;T, Allocator&gt;
  dynamic_buffer(vector&lt;T, Allocator&gt;&amp; vec, size_t n) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.creation-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.creation-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>dynamic_vector_buffer&lt;T, Allocator&gt;(vec, n)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CharT, class Traits, class Allocator&gt;
  dynamic_string_buffer&lt;CharT, Traits, Allocator&gt;
  dynamic_buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; str) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.creation-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.creation-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>dynamic_string_buffer&lt;CharT, Traits, Allocator&gt;(str)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CharT, class Traits, class Allocator&gt;
  dynamic_string_buffer&lt;CharT, Traits, Allocator&gt;
  dynamic_buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; str, size_t n) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.dynamic.creation-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.dynamic.creation-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>dynamic_string_buffer&lt;CharT, Traits, Allocator&gt;(str, n)</span>.
</p></div></div></div></div><div id='buffer.stream'><h1 ><a class='secnum' href='#buffer.stream' style='min-width:73pt'>17</a> Buffer-oriented streams <a class='abbr_ref' href='./#buffer.stream'>[buffer.stream]</a></h1><div id='buffer.stream.reqmts'><h2 ><a class='secnum' href='#buffer.stream.reqmts' style='min-width:88pt'>17.1</a> Requirements <a class='abbr_ref' href='buffer.stream.reqmts'>[buffer.stream.reqmts]</a></h2><div id='buffer.stream.reqmts.syncreadstream'><h3 ><a class='secnum' href='#buffer.stream.reqmts.syncreadstream' style='min-width:103pt'>17.1.1</a> Buffer-oriented synchronous read stream requirements <a class='abbr_ref' href='buffer.stream.reqmts.syncreadstream'>[buffer.stream.reqmts.syncreadstream]</a></h3><p ><span class='indexparent'><a class='index' id='SyncReadStream'></a></span><span class='indexparent'><a class='index' id='requirements,SyncReadStream'></a></span></p><div class='para' id='buffer.stream.reqmts.syncreadstream-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.reqmts.syncreadstream-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>SyncReadStream</span> requirements if it satisfies the requirements listed in Table <a href='buffer.stream.reqmts.syncreadstream#tab:buffer.stream.reqmts.syncreadstream.requirements'>[tab:buffer.stream.reqmts.syncreadstream.requirements]</a>.</p></div><div class='para' id='buffer.stream.reqmts.syncreadstream-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.reqmts.syncreadstream-2'>2</a></div><p >In Table <a href='buffer.stream.reqmts.syncreadstream#tab:buffer.stream.reqmts.syncreadstream.requirements'>[tab:buffer.stream.reqmts.syncreadstream.requirements]</a>,
<span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>mb</span> denotes a value of a (possibly const) type satisfying the <span class='texttt'>MutableBufferSequence</span> (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) requirements,
and <span class='texttt'>ec</span> denotes an object of type <span class='texttt'>error_code</span>.</p><p ><span class='indexparent'><a class='index' id='read_some'></a></span>
 
 
 </p><div class='numberedTable' id='tab:buffer.stream.reqmts.syncreadstream.requirements'>Table <a href='#tab:buffer.stream.reqmts.syncreadstream.requirements'>16</a> — SyncReadStream requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>operation</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>semantics, pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.read_some(mb)</span>
<span class='texttt'>a.read_some(mb,ec)</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Meets the requirements for a read operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).<br/>
If <span class='texttt'>buffer_size(mb) &gt; 0</span>, reads one or more bytes of data from the stream <span class='texttt'>a</span> into the buffer sequence <span class='texttt'>mb</span>. If successful, sets <span class='texttt'>ec</span> such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and returns the number of bytes read. If an error occurred, sets <span class='texttt'>ec</span> such that <span class='texttt'>!!ec</span> is <span class='texttt'>true</span>, and returns 0. If all data has been read from the stream, and the stream performed an orderly shutdown, sets <span class='texttt'>ec</span> to <span class='texttt'>stream_errc::eof</span> and returns 0. If <span class='texttt'>buffer_size(mb) == 0</span>, the operation shall not block. Sets <span class='texttt'>ec</span> such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and returns 0.  </td></tr></table></div></div></div><div id='buffer.stream.reqmts.asyncreadstream'><h3 ><a class='secnum' href='#buffer.stream.reqmts.asyncreadstream' style='min-width:103pt'>17.1.2</a> Buffer-oriented asynchronous read stream requirements <a class='abbr_ref' href='buffer.stream.reqmts.asyncreadstream'>[buffer.stream.reqmts.asyncreadstream]</a></h3><p ><span class='indexparent'><a class='index' id='AsyncReadStream'></a></span><span class='indexparent'><a class='index' id='requirements,AsyncReadStream'></a></span></p><div class='para' id='buffer.stream.reqmts.asyncreadstream-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.reqmts.asyncreadstream-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>AsyncReadStream</span> requirements if it satisfies the requirements listed below.</p></div><div class='para' id='buffer.stream.reqmts.asyncreadstream-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.reqmts.asyncreadstream-2'>2</a></div><p >In the table below, <span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>mb</span> denotes a value of a (possibly const) type satisfying the <span class='texttt'>MutableBufferSequence</span> (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) requirements,
and <span class='texttt'>t</span> is a completion token.</p><p ><span class='indexparent'><a class='index' id='get_executor'></a></span><span class='indexparent'><a class='index' id='async_read_some'></a></span>
 
 
 </p><div class='numberedTable' id='tab:buffer.stream.reqmts.asyncreadstream.requirements'>Table <a href='#tab:buffer.stream.reqmts.asyncreadstream.requirements'>17</a> — AsyncReadStream requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>operation</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>semantics, pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.get_executor()</span>  </td><td class='left'>
A type satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).  </td><td class='left'>
 Returns the associated I/O executor.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.async_read_some(mb,t)</span>  </td><td class='left'>
The return type is determined according to the requirements for an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>).  </td><td class='left'>
Meets the requirements for a read operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>) and an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>) with completion signature <span class='texttt'>void(error_code ec, size_t n)</span>.<br/>
If <span class='texttt'>buffer_size(mb) &gt; 0</span>, initiates an asynchronous operation to read one or more bytes of data from the stream <span class='texttt'>a</span> into the buffer sequence <span class='texttt'>mb</span>. If successful, <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is the number of bytes read. If an error occurred, <span class='texttt'>ec</span> is set such that <span class='texttt'>!!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is 0. If all data has been read from the stream, and the stream performed an orderly shutdown, <span class='texttt'>ec</span> is <span class='texttt'>stream_errc::eof</span> and <span class='texttt'>n</span> is 0. If <span class='texttt'>buffer_size(mb) == 0</span>, the operation completes immediately. <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is 0.  </td></tr></table></div></div></div><div id='buffer.stream.reqmts.syncwritestream'><h3 ><a class='secnum' href='#buffer.stream.reqmts.syncwritestream' style='min-width:103pt'>17.1.3</a> Buffer-oriented synchronous write stream requirements <a class='abbr_ref' href='buffer.stream.reqmts.syncwritestream'>[buffer.stream.reqmts.syncwritestream]</a></h3><p ><span class='indexparent'><a class='index' id='SyncWriteStream'></a></span><span class='indexparent'><a class='index' id='requirements,SyncWriteStream'></a></span></p><div class='para' id='buffer.stream.reqmts.syncwritestream-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.reqmts.syncwritestream-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>SyncWriteStream</span> requirements if it satisfies the requirements listed below.</p></div><div class='para' id='buffer.stream.reqmts.syncwritestream-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.reqmts.syncwritestream-2'>2</a></div><p >In the table below,
<span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>cb</span> denotes a value of a (possibly const) type satisfying the <span class='texttt'>ConstBufferSequence</span> (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) requirements,
and <span class='texttt'>ec</span> denotes an object of type <span class='texttt'>error_code</span>.</p><p ><span class='indexparent'><a class='index' id='write_some'></a></span>
 
 
 </p><div class='numberedTable' id='tab:buffer.stream.reqmts.syncwritestream.requirements'>Table <a href='#tab:buffer.stream.reqmts.syncwritestream.requirements'>18</a> — SyncWriteStream requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>operation</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>semantics, pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.write_some(cb)</span>
<span class='texttt'>a.write_some(cb,ec)</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Meets the requirements for a write operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).<br/>
If <span class='texttt'>buffer_size(cb) &gt; 0</span>, writes one or more bytes of data to the stream <span class='texttt'>a</span> from the buffer sequence <span class='texttt'>cb</span>. If successful, sets <span class='texttt'>ec</span> such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and returns the number of bytes written. If an error occurred, sets <span class='texttt'>ec</span> such that <span class='texttt'>!!ec</span> is <span class='texttt'>true</span>, and returns 0. If <span class='texttt'>buffer_size(cb) == 0</span>, the operation shall not block. Sets <span class='texttt'>ec</span> such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and returns 0.  </td></tr></table></div></div></div><div id='buffer.stream.reqmts.asyncwritestream'><h3 ><a class='secnum' href='#buffer.stream.reqmts.asyncwritestream' style='min-width:103pt'>17.1.4</a> Buffer-oriented asynchronous write stream requirements <a class='abbr_ref' href='buffer.stream.reqmts.asyncwritestream'>[buffer.stream.reqmts.asyncwritestream]</a></h3><p ><span class='indexparent'><a class='index' id='AsyncWriteStream'></a></span><span class='indexparent'><a class='index' id='requirements,AsyncWriteStream'></a></span></p><div class='para' id='buffer.stream.reqmts.asyncwritestream-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.reqmts.asyncwritestream-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>AsyncWriteStream</span> requirements if it satisfies the requirements listed below.</p></div><div class='para' id='buffer.stream.reqmts.asyncwritestream-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.reqmts.asyncwritestream-2'>2</a></div><p >In the table below,
<span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>cb</span> denotes a value of a (possibly const) type satisfying the <span class='texttt'>ConstBufferSequence</span> (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) requirements,
and <span class='texttt'>t</span> is a completion token.</p><p ><span class='indexparent'><a class='index' id='get_executor'></a></span><span class='indexparent'><a class='index' id='async_write_some'></a></span>
 
 
 </p><div class='numberedTable' id='tab:buffer.stream.reqmts.asyncwritestream.requirements'>Table <a href='#tab:buffer.stream.reqmts.asyncwritestream.requirements'>19</a> — AsyncWriteStream requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>operation</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>semantics, pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.get_executor()</span>  </td><td class='left'>
A type satisfying the Executor requirements (<a href='async.reqmts.executor'>[async.reqmts.executor]</a>).  </td><td class='left'>
 Returns the associated I/O executor.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.async_write_some(cb,t)</span>  </td><td class='left'>
The return type is determined according to the requirements for an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>).  </td><td class='left'>
Meets the requirements for a write operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>) and an asynchronous operation (<a href='async.reqmts.async'>[async.reqmts.async]</a>) with completion signature <span class='texttt'>void(error_code ec, size_t n)</span>.<br/>
If <span class='texttt'>buffer_size(cb) &gt; 0</span>, initiates an asynchronous operation to write one or more bytes of data to the stream <span class='texttt'>a</span> from the buffer sequence <span class='texttt'>cb</span>. If successful, <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is the number of bytes written. If an error occurred, <span class='texttt'>ec</span> is set such that <span class='texttt'>!!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is 0. If <span class='texttt'>buffer_size(cb) == 0</span>, the operation completes immediately. <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>, and <span class='texttt'>n</span> is 0.  </td></tr></table></div></div></div><div id='buffer.stream.reqmts.completioncondition'><h3 ><a class='secnum' href='#buffer.stream.reqmts.completioncondition' style='min-width:103pt'>17.1.5</a> Completion condition requirements <a class='abbr_ref' href='buffer.stream.reqmts.completioncondition'>[buffer.stream.reqmts.completioncondition]</a></h3><p ><span class='indexparent'><a class='index' id='CompletionCondition'></a></span><span class='indexparent'><a class='index' id='requirements,CompletionCondition'></a></span></p><div class='para' id='buffer.stream.reqmts.completioncondition-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.reqmts.completioncondition-1'>1</a></div><p >A completion condition is a function object that is used with the algorithms <span class='texttt'>read</span> (<a href='buffer.read'>[buffer.read]</a>), <span class='texttt'>async_read</span> (<a href='buffer.async.read'>[buffer.async.read]</a>), <span class='texttt'>write</span> (<a href='buffer.write'>[buffer.write]</a>), and <span class='texttt'>async_write</span> (<a href='buffer.async.write'>[buffer.async.write]</a>) to determine when the algorithm has completed transferring data.</p></div><div class='para' id='buffer.stream.reqmts.completioncondition-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.reqmts.completioncondition-2'>2</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>CompletionCondition</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) and <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), as well as the additional requirements listed below.</p></div><div class='para' id='buffer.stream.reqmts.completioncondition-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.reqmts.completioncondition-3'>3</a></div><p >In the table below, <span class='texttt'>x</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>ec</span> denotes a value of type <span class='texttt'>error_code</span> or <span class='texttt'>const error_code</span>,
and <span class='texttt'>n</span> denotes a value of type <span class='texttt'>size_t</span> or <span class='texttt'>const size_t</span>.</p><div class='numberedTable' id='tab:buffer.stream.reqmts.completioncondition.requirements'>Table <a href='#tab:buffer.stream.reqmts.completioncondition.requirements'>20</a> — CompletionCondition requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>x(ec, n)</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Let <span class='texttt'>n</span> be the total number of bytes transferred by the read or write algorithm so far.<br/>
Returns the maximum number of bytes to be transferred on the next <span class='texttt'>read_some</span>, <span class='texttt'>async_read_some</span>, <span class='texttt'>write_some</span>, or <span class='texttt'>async_write_some</span> operation performed by the algorithm. Returns <span class='texttt'>0</span> to indicate that the algorithm is complete.  </td></tr></table></div></div></div></div><div id='buffer.stream.transfer.all'><h2 ><a class='secnum' href='#buffer.stream.transfer.all' style='min-width:88pt'>17.2</a> Class <span class='texttt'>transfer_all</span> <a class='abbr_ref' href='buffer.stream.transfer.all'>[buffer.stream.transfer.all]</a></h2><p ><span class='indexparent'><a class='index' id='transfer_all'></a></span></p><div class='para' id='buffer.stream.transfer.all-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.transfer.all-1'>1</a></div><p >The class <span class='texttt'>transfer_all</span> is a completion condition that is used to specify that a read or write operation should continue until all of the data has been transferred, or until an error occurs.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class transfer_all
  {
  public:
    size_t operator()(const error_code&amp; ec, size_t) const;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='buffer.stream.transfer.all-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.transfer.all-2'>2</a></div><p >The class <span class='texttt'>transfer_all</span> satisfies the <span class='texttt'>CompletionCondition</span> (<a href='buffer.stream.reqmts.completioncondition'>[buffer.stream.reqmts.completioncondition]</a>) requirements.</p><p ><code class='itemdecl'>
size_t operator()(const error_code&amp; ec, size_t) const;
</code></p></div><div class='itemdescr'></div><div class='para' id='buffer.stream.transfer.all-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.transfer.all-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>!ec</span>, an unspecified non-zero value. Otherwise <span class='texttt'>0</span>.
</p></div></div></div><div id='buffer.stream.transfer.at.least'><h2 ><a class='secnum' href='#buffer.stream.transfer.at.least' style='min-width:88pt'>17.3</a> Class <span class='texttt'>transfer_at_least</span> <a class='abbr_ref' href='buffer.stream.transfer.at.least'>[buffer.stream.transfer.at.least]</a></h2><p ><span class='indexparent'><a class='index' id='transfer_at_least'></a></span></p><div class='para' id='buffer.stream.transfer.at.least-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.transfer.at.least-1'>1</a></div><p >The class <span class='texttt'>transfer_at_least</span> is a completion condition that is used to specify that a read or write operation should continue until a minimum number of bytes has been transferred, or until an error occurs.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class transfer_at_least
  {
  public:
    explicit transfer_at_least(size_t m);
    size_t operator()(const error_code&amp; ec, size_t n) const;
  private:
    size_t minimum_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='buffer.stream.transfer.at.least-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.transfer.at.least-2'>2</a></div><p >The class <span class='texttt'>transfer_at_least</span> satisfies the <span class='texttt'>CompletionCondition</span> (<a href='buffer.stream.reqmts.completioncondition'>[buffer.stream.reqmts.completioncondition]</a>) requirements.</p><p ><code class='itemdecl'>
explicit transfer_at_least(size_t m);
</code></p></div><div class='itemdescr'></div><div class='para' id='buffer.stream.transfer.at.least-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.transfer.at.least-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>minimum_ == m</span>.
</p></div></div><p ><code class='itemdecl'>
size_t operator()(const error_code&amp; ec, size_t n) const;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.stream.transfer.at.least-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.transfer.at.least-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>!ec &amp;&amp; n &lt; minimum_</span>, an unspecified non-zero value. Otherwise <span class='texttt'>0</span>.
</p></div></div></div><div id='buffer.stream.transfer.exactly'><h2 ><a class='secnum' href='#buffer.stream.transfer.exactly' style='min-width:88pt'>17.4</a> Class <span class='texttt'>transfer_exactly</span> <a class='abbr_ref' href='buffer.stream.transfer.exactly'>[buffer.stream.transfer.exactly]</a></h2><p ><span class='indexparent'><a class='index' id='transfer_exactly'></a></span></p><div class='para' id='buffer.stream.transfer.exactly-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.transfer.exactly-1'>1</a></div><p >The class <span class='texttt'>transfer_exactly</span> is a completion condition that is used to specify that a read or write operation should continue until an exact number of bytes has been transferred, or until an error occurs.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class transfer_exactly
  {
  public:
    explicit transfer_exactly(size_t e);
    size_t operator()(const error_code&amp; ec, size_t n) const;
  private:
    size_t exact_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='buffer.stream.transfer.exactly-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.transfer.exactly-2'>2</a></div><p >The class <span class='texttt'>transfer_exactly</span> satisfies the <span class='texttt'>CompletionCondition</span> (<a href='buffer.stream.reqmts.completioncondition'>[buffer.stream.reqmts.completioncondition]</a>) requirements.</p><p ><code class='itemdecl'>
explicit transfer_exactly(size_t e);
</code></p></div><div class='itemdescr'></div><div class='para' id='buffer.stream.transfer.exactly-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.transfer.exactly-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>exact_ == e</span>.
</p></div></div><p ><code class='itemdecl'>
size_t operator()(const error_code&amp; ec, size_t n) const;
</code></p><div class='itemdescr'></div><div class='para' id='buffer.stream.transfer.exactly-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.stream.transfer.exactly-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>!ec &amp;&amp; n &lt; exact_</span>, the result of <span class='texttt'>min(exact_ - n, N)</span>, where <span class='texttt'>N</span> is an unspecified non-zero value. Otherwise <span class='texttt'>0</span>.
</p></div></div></div><div id='buffer.read'><h2 ><a class='secnum' href='#buffer.read' style='min-width:88pt'>17.5</a> Synchronous read operations <a class='abbr_ref' href='buffer.read'>[buffer.read]</a></h2><p ><span class='indexparent'><a class='index' id='read'></a></span><code class='itemdecl'>
template&lt;class SyncReadStream, class MutableBufferSequence&gt;
  size_t read(SyncReadStream&amp; stream,
              const MutableBufferSequence&amp; buffers);
template&lt;class SyncReadStream, class MutableBufferSequence&gt;
  size_t read(SyncReadStream&amp; stream,
              const MutableBufferSequence&amp; buffers, error_code&amp; ec);
template&lt;class SyncReadStream, class MutableBufferSequence,
  class CompletionCondition&gt;
    size_t read(SyncReadStream&amp; stream,
                const MutableBufferSequence&amp; buffers,
                CompletionCondition completion_condition);
template&lt;class SyncReadStream, class MutableBufferSequence,
  class CompletionCondition&gt;
    size_t read(SyncReadStream&amp; stream,
                const MutableBufferSequence&amp; buffers,
                CompletionCondition completion_condition,
                error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.read-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-1'>1</a></div><div class='itemdescr'><p >A read operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='buffer.read-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Clears <span class='texttt'>ec</span>, then reads data from the buffer-oriented synchronous read stream (<a href='buffer.stream.reqmts.syncreadstream'>[buffer.stream.reqmts.syncreadstream]</a>) object <span class='texttt'>stream</span> by performing zero or more calls to the stream's <span class='texttt'>read_some</span> member function.</p></div></div><div class='para' id='buffer.read-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-3'>3</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called prior to each call to the stream's <span class='texttt'>read_some</span> member function. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>read_some</span> call, and the total number of bytes transferred in the synchronous read operation so far. The completion condition return value specifies the maximum number of bytes to be read on the subsequent <span class='texttt'>read_some</span> call. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.read-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-4'>4</a></div><div class='itemdescr'><p >The synchronous read operation continues until:</p><ul class='itemize'><li id='buffer.read-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.read-4.1'>(4.1)</a></div><p >the total number of bytes transferred is equal to <span class='texttt'>buffer_size(buffers)</span>; or
</p></li><li id='buffer.read-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.read-4.2'>(4.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.read-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-5'>5</a></div><div class='itemdescr'><p >On return, <span class='texttt'>ec</span> contains the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>read_some</span> call.</p></div></div><div class='para' id='buffer.read-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> The total number of bytes transferred in the synchronous read operation.</p></div></div><div class='para' id='buffer.read-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>is_mutable_buffer_sequence_v&lt;MutableBufferSequence&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='read'></a></span><code class='itemdecl'>
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;&amp; b);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;&amp; b, error_code&amp; ec);
template&lt;class SyncReadStream, class DynamicBuffer,
  class CompletionCondition&gt;
    size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;&amp; b,
                CompletionCondition completion_condition);
template&lt;class SyncReadStream, class DynamicBuffer,
  class CompletionCondition&gt;
    size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;&amp; b,
                CompletionCondition completion_condition,
                error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.read-8'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Clears <span class='texttt'>ec</span>, then reads data from the synchronous read stream (<a href='buffer.stream.reqmts.syncreadstream'>[buffer.stream.reqmts.syncreadstream]</a>) object <span class='texttt'>stream</span> by performing zero or more calls to the stream's <span class='texttt'>read_some</span> member function.</p></div></div><div class='para' id='buffer.read-9'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-9'>9</a></div><div class='itemdescr'><p >Data is placed into the dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>) object <span class='texttt'>b</span>. A mutable buffer sequence (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) is obtained prior to each <span class='texttt'>read_some</span> call using <span class='texttt'>b.prepare(N)</span>, where <span class='texttt'>N</span> is an unspecified value less than or equal to <span class='texttt'>b.max_size() - b.size()</span>. [&nbsp;<i>Note:</i> Implementations are encouraged to use <span class='texttt'>b.capacity()</span> when determining <span class='texttt'>N</span>, to minimize the number of <span class='texttt'>read_some</span> calls performed on the stream. <i>&nbsp;—&nbsp;end note</i>&nbsp;] After each <span class='texttt'>read_some</span> call, the implementation performs <span class='texttt'>b.commit(n)</span>, where <span class='texttt'>n</span> is the return value from <span class='texttt'>read_some</span>.</p></div></div><div class='para' id='buffer.read-10'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-10'>10</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called prior to each call to the stream's <span class='texttt'>read_some</span> member function. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>read_some</span> call, and the total number of bytes transferred in the synchronous read operation so far. The completion condition return value specifies the maximum number of bytes to be read on the subsequent <span class='texttt'>read_some</span> call. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.read-11'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-11'>11</a></div><div class='itemdescr'><p >The synchronous read operation continues until:</p><ul class='itemize'><li id='buffer.read-11.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.read-11.1'>(11.1)</a></div><p ><span class='texttt'>b.size() == b.max_size()</span>; or
</p></li><li id='buffer.read-11.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.read-11.2'>(11.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.read-12'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-12'>12</a></div><div class='itemdescr'><p >On return, <span class='texttt'>ec</span> contains the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>read_some</span> call.</p></div></div><div class='para' id='buffer.read-13'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> The total number of bytes transferred in the synchronous read operation.</p></div></div><div class='para' id='buffer.read-14'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read-14'>14</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>is_dynamic_buffer_v&lt;DynamicBuffer&gt;</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='buffer.async.read'><h2 ><a class='secnum' href='#buffer.async.read' style='min-width:88pt'>17.6</a> Asynchronous read operations <a class='abbr_ref' href='buffer.async.read'>[buffer.async.read]</a></h2><p ><span class='indexparent'><a class='index' id='async_read'></a></span><code class='itemdecl'>
template&lt;class AsyncReadStream, class MutableBufferSequence, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_read(AsyncReadStream&amp; stream,
                       const MutableBufferSequence&amp; buffers,
                       CompletionToken&amp;&amp; token);
template&lt;class AsyncReadStream, class MutableBufferSequence, class CompletionCondition,
         class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_read(AsyncReadStream&amp; stream,
                       const MutableBufferSequence&amp; buffers,
                       CompletionCondition completion_condition,
                       CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.async.read-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-1'>1</a></div><div class='itemdescr'><p >A composed asynchronous read operation (<a href='async.reqmts.async.composed'>[async.reqmts.async.composed]</a>, <a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='buffer.async.read-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-2'>2</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='buffer.async.read-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Reads data from the buffer-oriented asynchronous read stream (<a href='buffer.stream.reqmts.asyncreadstream'>[buffer.stream.reqmts.asyncreadstream]</a>) object <span class='texttt'>stream</span> by invoking the stream's <span class='texttt'>async_read_some</span> member function (henceforth referred to as asynchronous read_some operations) zero or more times.</p></div></div><div class='para' id='buffer.async.read-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-4'>4</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called prior to each asynchronous read_some operation. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent asynchronous read_some operation, and the total number of bytes transferred in the asynchronous read operation so far. The completion condition return value specifies the maximum number of bytes to be read on the subsequent asynchronous read_some operation. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.async.read-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-5'>5</a></div><div class='itemdescr'><p >This asynchronous read operation is outstanding until:</p><ul class='itemize'><li id='buffer.async.read-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.read-5.1'>(5.1)</a></div><p >the total number of bytes transferred is equal to <span class='texttt'>buffer_size(buffers)</span>; or
</p></li><li id='buffer.async.read-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.read-5.2'>(5.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.async.read-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-6'>6</a></div><div class='itemdescr'><p >The program shall ensure the <span class='texttt'>AsyncReadStream</span> object <span class='texttt'>stream</span> is valid until the completion handler for the asynchronous operation is invoked.</p></div></div><div class='para' id='buffer.async.read-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-7'>7</a></div><div class='itemdescr'><p >On completion of the asynchronous operation, <span class='texttt'>ec</span> is the <span class='texttt'>error_code</span> value from the most recent asynchronous read_some operation, and <span class='texttt'>n</span> is the total number of bytes transferred.</p></div></div><div class='para' id='buffer.async.read-8'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>is_mutable_buffer_sequence_v&lt;MutableBufferSequence&gt;</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='async_read'></a></span><code class='itemdecl'>
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_read(AsyncReadStream&amp; stream,
                       DynamicBuffer&amp;&amp; b, CompletionToken&amp;&amp; token);
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionCondition,
         class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_read(AsyncReadStream&amp; stream,
                       DynamicBuffer&amp;&amp; b,
                       CompletionCondition completion_condition,
                       CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.async.read-9'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-9'>9</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='buffer.async.read-10'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to read data from the buffer-oriented asynchronous read stream (<a href='buffer.stream.reqmts.asyncreadstream'>[buffer.stream.reqmts.asyncreadstream]</a>) object <span class='texttt'>stream</span> by performing one or more asynchronous read_some operations on the stream.</p></div></div><div class='para' id='buffer.async.read-11'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-11'>11</a></div><div class='itemdescr'><p >Data is placed into the dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>) object <span class='texttt'>b</span>. A mutable buffer sequence (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) is obtained prior to each <span class='texttt'>async_read_some</span> call using <span class='texttt'>b.prepare(N)</span>, where <span class='texttt'>N</span> is an unspecified value such that <span class='texttt'>N</span> is less than or equal to <span class='texttt'>b.max_size() - b.size()</span>. [&nbsp;<i>Note:</i> Implementations are encouraged to use <span class='texttt'>b.capacity()</span> when determining <span class='texttt'>N</span>, to minimize the number of asynchronous read_some operations performed on the stream. <i>&nbsp;—&nbsp;end note</i>&nbsp;] After the completion of each asynchronous read_some operation, the implementation performs <span class='texttt'>b.commit(n)</span>, where <span class='texttt'>n</span> is the value passed to the asynchronous read_some operation's completion handler.</p></div></div><div class='para' id='buffer.async.read-12'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-12'>12</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called prior to each asynchronous read_some operation. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent asynchronous read_some operation, and the total number of bytes transferred in the asynchronous read operation so far. The completion condition return value specifies the maximum number of bytes to be read on the subsequent asynchronous read_some operation. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.async.read-13'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-13'>13</a></div><div class='itemdescr'><p >The asynchronous read operation is outstanding until:</p><ul class='itemize'><li id='buffer.async.read-13.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.read-13.1'>(13.1)</a></div><p ><span class='texttt'>b.size() == b.max_size()</span>; or
</p></li><li id='buffer.async.read-13.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.read-13.2'>(13.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.async.read-14'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-14'>14</a></div><div class='itemdescr'><p >The program shall ensure the <span class='texttt'>AsyncReadStream</span> object <span class='texttt'>stream</span> is valid until the completion handler for the asynchronous operation is invoked.</p></div></div><div class='para' id='buffer.async.read-15'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-15'>15</a></div><div class='itemdescr'><p >On completion of the asynchronous operation, <span class='texttt'>ec</span> is the <span class='texttt'>error_code</span> value from the most recent asynchronous read_some operation, and <span class='texttt'>n</span> is the total number of bytes transferred.</p></div></div><div class='para' id='buffer.async.read-16'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read-16'>16</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless
<span class='texttt'>is_dynamic_buffer_v&lt;DynamicBuffer&gt;</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='buffer.write'><h2 ><a class='secnum' href='#buffer.write' style='min-width:88pt'>17.7</a> Synchronous write operations <a class='abbr_ref' href='buffer.write'>[buffer.write]</a></h2><p ><span class='indexparent'><a class='index' id='write'></a></span><code class='itemdecl'>
template&lt;class SyncWriteStream, class ConstBufferSequence&gt;
  size_t write(SyncWriteStream&amp; stream,
               const ConstBufferSequence&amp; buffers);
template&lt;class SyncWriteStream, class ConstBufferSequence&gt;
  size_t write(SyncWriteStream&amp; stream,
               const ConstBufferSequence&amp; buffers, error_code&amp; ec);
template&lt;class SyncWriteStream, class ConstBufferSequence,
  class CompletionCondition&gt;
    size_t write(SyncWriteStream&amp; stream,
                 const ConstBufferSequence&amp; buffers,
                 CompletionCondition completion_condition);
template&lt;class SyncWriteStream, class ConstBufferSequence,
  class CompletionCondition&gt;
    size_t write(SyncWriteStream&amp; stream,
                 const ConstBufferSequence&amp; buffers,
                 CompletionCondition completion_condition,
                 error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.write-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-1'>1</a></div><div class='itemdescr'><p >A write operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='buffer.write-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Writes data to the buffer-oriented synchronous write stream (<a href='buffer.stream.reqmts.syncwritestream'>[buffer.stream.reqmts.syncwritestream]</a>) object <span class='texttt'>stream</span> by performing zero or more calls to the stream's <span class='texttt'>write_some</span> member function.</p></div></div><div class='para' id='buffer.write-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-3'>3</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called prior to each call to the stream's <span class='texttt'>write_some</span> member function. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>write_some</span> call, and the total number of bytes transferred in the synchronous write operation so far. The completion condition return value specifies the maximum number of bytes to be written on the subsequent <span class='texttt'>write_some</span> call. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.write-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-4'>4</a></div><div class='itemdescr'><p >The synchronous write operation continues until:</p><ul class='itemize'><li id='buffer.write-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.write-4.1'>(4.1)</a></div><p >the total number of bytes transferred is equal to <span class='texttt'>buffer_size(buffers)</span>; or
</p></li><li id='buffer.write-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.write-4.2'>(4.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.write-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-5'>5</a></div><div class='itemdescr'><p >On return, <span class='texttt'>ec</span> contains the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>write_some</span> call.</p></div></div><div class='para' id='buffer.write-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> The total number of bytes transferred in the synchronous write operation.</p></div></div><div class='para' id='buffer.write-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>is_const_buffer_sequence&lt;ConstBufferSequence&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='write'></a></span><code class='itemdecl'>
template&lt;class SyncWriteStream, class DynamicBuffer&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;&amp; b);
template&lt;class SyncWriteStream, class DynamicBuffer&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;&amp; b, error_code&amp; ec);
template&lt;class SyncWriteStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;&amp; b,
               CompletionCondition completion_condition);
template&lt;class SyncWriteStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;&amp; b,
               CompletionCondition completion_condition,
               error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.write-8'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Writes data to the synchronous write stream (<a href='buffer.stream.reqmts.syncwritestream'>[buffer.stream.reqmts.syncwritestream]</a>) object <span class='texttt'>stream</span> by performing zero or more calls to the stream's <span class='texttt'>write_some</span> member function.</p></div></div><div class='para' id='buffer.write-9'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-9'>9</a></div><div class='itemdescr'><p >Data is written from the dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>) object <span class='texttt'>b</span>. A constant buffer sequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) is obtained using <span class='texttt'>b.data()</span>. After the data has been written to the stream, the implementation performs <span class='texttt'>b.consume(n)</span>, where <span class='texttt'>n</span> is the number of bytes successfully written.</p></div></div><div class='para' id='buffer.write-10'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-10'>10</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called after each call to the stream's <span class='texttt'>write_some</span> member function. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>write_some</span> call, and the total number of bytes transferred in the synchronous write operation so far. The completion condition return value specifies the maximum number of bytes to be written on the subsequent <span class='texttt'>write_some</span> call. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.write-11'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-11'>11</a></div><div class='itemdescr'><p >The synchronous write operation continues until:</p><ul class='itemize'><li id='buffer.write-11.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.write-11.1'>(11.1)</a></div><p ><span class='texttt'>b.size() == 0</span>; or
</p></li><li id='buffer.write-11.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.write-11.2'>(11.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.write-12'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-12'>12</a></div><div class='itemdescr'><p >On return, <span class='texttt'>ec</span> contains the <span class='texttt'>error_code</span> value from the most recent <span class='texttt'>write_some</span> call.</p></div></div><div class='para' id='buffer.write-13'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> The total number of bytes transferred in the synchronous write operation.</p></div></div><div class='para' id='buffer.write-14'><div class='marginalizedparent'><a class='marginalized' href='#buffer.write-14'>14</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>is_dynamic_buffer_v&lt;DynamicBuffer&gt;</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='buffer.async.write'><h2 ><a class='secnum' href='#buffer.async.write' style='min-width:88pt'>17.8</a> Asynchronous write operations <a class='abbr_ref' href='buffer.async.write'>[buffer.async.write]</a></h2><p ><span class='indexparent'><a class='index' id='async_write'></a></span><code class='itemdecl'>
template&lt;class AsyncWriteStream, class ConstBufferSequence, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_write(AsyncWriteStream&amp; stream,
                        const ConstBufferSequence&amp; buffers,
                        CompletionToken&amp;&amp; token);
template&lt;class AsyncWriteStream, class ConstBufferSequence, class CompletionCondition,
         class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_write(AsyncWriteStream&amp; stream,
                        const ConstBufferSequence&amp; buffers,
                        CompletionCondition completion_condition,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.async.write-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-1'>1</a></div><div class='itemdescr'><p >A composed asynchronous write operation (<a href='async.reqmts.async.composed'>[async.reqmts.async.composed]</a>, <a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='buffer.async.write-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-2'>2</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='buffer.async.write-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to write data to the buffer-oriented asynchronous write stream (<a href='buffer.stream.reqmts.asyncwritestream'>[buffer.stream.reqmts.asyncwritestream]</a>) object <span class='texttt'>stream</span> by performing zero or more asynchronous operations on the stream using the stream's <span class='texttt'>async_write_some</span> member function (henceforth referred to as asynchronous write_some operations).</p></div></div><div class='para' id='buffer.async.write-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-4'>4</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called prior to each asynchronous write_some operation. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent asynchronous write_some operation, and the total number of bytes transferred in the asynchronous write operation so far. The completion condition return value specifies the maximum number of bytes to be written on the subsequent asynchronous write_some operation. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.async.write-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-5'>5</a></div><div class='itemdescr'><p >The asynchronous write operation continues until:</p><ul class='itemize'><li id='buffer.async.write-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.write-5.1'>(5.1)</a></div><p >the total number of bytes transferred is equal to <span class='texttt'>buffer_size(buffers)</span>; or
</p></li><li id='buffer.async.write-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.write-5.2'>(5.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.async.write-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-6'>6</a></div><div class='itemdescr'><p >The program must ensure the <span class='texttt'>AsyncWriteStream</span> object <span class='texttt'>stream</span> is valid until the completion handler for the asynchronous operation is invoked.</p></div></div><div class='para' id='buffer.async.write-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-7'>7</a></div><div class='itemdescr'><p >On completion of the asynchronous operation, <span class='texttt'>ec</span> is the <span class='texttt'>error_code</span> value from the most recent asynchronous write_some operation, and <span class='texttt'>n</span> is the total number of bytes transferred.</p></div></div><div class='para' id='buffer.async.write-8'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>is_const_buffer_sequence&lt;ConstBufferSequence&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='async_write'></a></span><code class='itemdecl'>
template&lt;class AsyncWriteStream, class DynamicBuffer, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_write(AsyncWriteStream&amp; stream,
                      DynamicBuffer&amp;&amp; b, CompletionToken&amp;&amp; token);
template&lt;class AsyncWriteStream, class DynamicBuffer, class CompletionCondition,
         class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_write(AsyncWriteStream&amp; stream,
                        DynamicBuffer&amp;&amp; b,
                        CompletionCondition completion_condition,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.async.write-9'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-9'>9</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='buffer.async.write-10'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to write data to the buffer-oriented asynchronous write stream (<a href='buffer.stream.reqmts.asyncwritestream'>[buffer.stream.reqmts.asyncwritestream]</a>) object <span class='texttt'>stream</span> by performing zero or more asynchronous write_some operations on the stream.</p></div></div><div class='para' id='buffer.async.write-11'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-11'>11</a></div><div class='itemdescr'><p >Data is written from the dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>) object <span class='texttt'>b</span>. A constant buffer sequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) is obtained using <span class='texttt'>b.data()</span>. After the data has been written to the stream, the implementation performs <span class='texttt'>b.consume(n)</span>, where <span class='texttt'>n</span> is the number of bytes successfully written.</p></div></div><div class='para' id='buffer.async.write-12'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-12'>12</a></div><div class='itemdescr'><p >The <span class='texttt'>completion_condition</span> parameter specifies a completion condition to be called prior to each asynchronous write_some operation. The completion condition is passed the <span class='texttt'>error_code</span> value from the most recent asynchronous write_some operation, and the total number of bytes transferred in the asynchronous write operation so far. The completion condition return value specifies the maximum number of bytes to be written on the subsequent asynchronous write_some operation. Overloads where a completion condition is not specified behave as if called with an object of class <span class='texttt'>transfer_all</span>.</p></div></div><div class='para' id='buffer.async.write-13'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-13'>13</a></div><div class='itemdescr'><p >The asynchronous write operation continues until:</p><ul class='itemize'><li id='buffer.async.write-13.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.write-13.1'>(13.1)</a></div><p ><span class='texttt'>b.size() == 0</span>; or
</p></li><li id='buffer.async.write-13.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.write-13.2'>(13.2)</a></div><p >the completion condition returns <span class='texttt'>0</span>.
</p></li></ul></div></div><div class='para' id='buffer.async.write-14'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-14'>14</a></div><div class='itemdescr'><p >The program must ensure both the <span class='texttt'>AsyncWriteStream</span> object <span class='texttt'>stream</span> and the memory associated with the dynamic buffer <span class='texttt'>b</span> are valid until the completion handler for the asynchronous operation is invoked.</p></div></div><div class='para' id='buffer.async.write-15'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-15'>15</a></div><div class='itemdescr'><p >On completion of the asynchronous operation, <span class='texttt'>ec</span> is the <span class='texttt'>error_code</span> value from the most recent asynchronous write_some operation, and <span class='texttt'>n</span> is the total number of bytes transferred.</p></div></div><div class='para' id='buffer.async.write-16'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.write-16'>16</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>is_dynamic_buffer_v&lt;DynamicBuffer&gt;</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='buffer.read.until'><h2 ><a class='secnum' href='#buffer.read.until' style='min-width:88pt'>17.9</a> Synchronous delimited read operations <a class='abbr_ref' href='buffer.read.until'>[buffer.read.until]</a></h2><p ><span class='indexparent'><a class='index' id='read_until'></a></span><code class='itemdecl'>
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b, char delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b,
                    char delim, error_code&amp; ec);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b, string_view delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b,
                    string_view delim, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.read.until-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read.until-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Reads data from the buffer-oriented synchronous read stream (<a href='buffer.stream.reqmts.syncreadstream'>[buffer.stream.reqmts.syncreadstream]</a>) object <span class='texttt'>stream</span> by performing zero or more calls to the stream's <span class='texttt'>read_some</span> member function, until the input sequence of the dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>) object <span class='texttt'>b</span> contains the specified delimiter <span class='texttt'>delim</span>.</p></div></div><div class='para' id='buffer.read.until-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read.until-2'>2</a></div><div class='itemdescr'><p >Data is placed into the dynamic buffer object <span class='texttt'>b</span>. A mutable buffer sequence (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) is obtained prior to each <span class='texttt'>read_some</span> call using <span class='texttt'>b.prepare(N)</span>, where <span class='texttt'>N</span> is an unspecified value such that <span class='texttt'>N &lt;= max_size() - size()</span>. [&nbsp;<i>Note:</i> Implementations are encouraged to use <span class='texttt'>b.capacity()</span> when determining <span class='texttt'>N</span>, to minimize the number of <span class='texttt'>read_some</span> calls performed on the stream. <i>&nbsp;—&nbsp;end note</i>&nbsp;] After each <span class='texttt'>read_some</span> call, the implementation performs <span class='texttt'>b.commit(n)</span>, where <span class='texttt'>n</span> is the return value from <span class='texttt'>read_some</span>.</p></div></div><div class='para' id='buffer.read.until-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read.until-3'>3</a></div><div class='itemdescr'><p >The synchronous read_until operation continues until:</p><ul class='itemize'><li id='buffer.read.until-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.read.until-3.1'>(3.1)</a></div><p >the input sequence of <span class='texttt'>b</span> contains the delimiter <span class='texttt'>delim</span>; or
</p></li><li id='buffer.read.until-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.read.until-3.2'>(3.2)</a></div><p ><span class='texttt'>b.size() == b.max_size()</span>; or
</p></li><li id='buffer.read.until-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.read.until-3.3'>(3.3)</a></div><p >an asynchronous read_some operation fails.
</p></li></ul></div></div><div class='para' id='buffer.read.until-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read.until-4'>4</a></div><div class='itemdescr'><p >On exit, if the input sequence of <span class='texttt'>b</span> contains the delimiter, <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>. Otherwise, if <span class='texttt'>b.size() == b.max_size()</span>, <span class='texttt'>ec</span> is set such that <span class='texttt'>ec == stream_errc::not_found</span>. If <span class='texttt'>b.size() &lt; b.max_size()</span>, <span class='texttt'>ec</span> contains the <span class='texttt'>error_code</span> from the most recent <span class='texttt'>read_some</span> call.</p></div></div><div class='para' id='buffer.read.until-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.read.until-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of bytes in the input sequence of <span class='texttt'>b</span> up to and including the delimiter, if present. [&nbsp;<i>Note:</i> On completion, the buffer may contain additional bytes following the delimiter. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Otherwise returns <span class='texttt'>0</span>.
</p></div></div></div><div id='buffer.async.read.until'><h2 ><a class='secnum' href='#buffer.async.read.until' style='min-width:88pt'>17.10</a> Asynchronous delimited read operations <a class='abbr_ref' href='buffer.async.read.until'>[buffer.async.read.until]</a></h2><p ><span class='indexparent'><a class='index' id='async_read_until'></a></span><code class='itemdecl'>
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_read_until(AsyncReadStream&amp; s,
                           DynamicBuffer&amp;&amp; b, char delim,
                           CompletionToken&amp;&amp; token);
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_read_until(AsyncReadStream&amp; s,
                           DynamicBuffer&amp;&amp; b, string_view delim,
                           CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='buffer.async.read.until-1'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-1'>1</a></div><div class='itemdescr'><p >A composed asynchronous operation (<a href='async.reqmts.async.composed'>[async.reqmts.async.composed]</a>).</p></div></div><div class='para' id='buffer.async.read.until-2'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-2'>2</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='buffer.async.read.until-3'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to read data from the buffer-oriented asynchronous read stream (<a href='buffer.stream.reqmts.asyncreadstream'>[buffer.stream.reqmts.asyncreadstream]</a>) object <span class='texttt'>stream</span> by performing zero or more asynchronous read_some operations on the stream, until the readable bytes of the dynamic buffer (<a href='buffer.reqmts.dynamicbuffer'>[buffer.reqmts.dynamicbuffer]</a>) object <span class='texttt'>b</span> contain the specified delimiter <span class='texttt'>delim</span>.</p></div></div><div class='para' id='buffer.async.read.until-4'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-4'>4</a></div><div class='itemdescr'><p >Data is placed into the dynamic buffer object <span class='texttt'>b</span>. A mutable buffer sequence (<a href='buffer.reqmts.mutablebuffersequence'>[buffer.reqmts.mutablebuffersequence]</a>) is obtained prior to each <span class='texttt'>async_read_some</span> call using <span class='texttt'>b.prepare(N)</span>, where <span class='texttt'>N</span> is an unspecified value such that <span class='texttt'>N &lt;= max_size() - size()</span>. [&nbsp;<i>Note:</i> Implementations are encouraged to use <span class='texttt'>b.capacity()</span> when determining <span class='texttt'>N</span>, to minimize the number of asynchronous read_some operations performed on the stream. <i>&nbsp;—&nbsp;end note</i>&nbsp;] After the completion of each asynchronous read_some operation, the implementation performs <span class='texttt'>b.commit(n)</span>, where <span class='texttt'>n</span> is the value passed to the asynchronous read_some operation's completion handler.</p></div></div><div class='para' id='buffer.async.read.until-5'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-5'>5</a></div><div class='itemdescr'><p >The asynchronous read_until operation continues until:</p><ul class='itemize'><li id='buffer.async.read.until-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.read.until-5.1'>(5.1)</a></div><p >the readable bytes of <span class='texttt'>b</span> contain the delimiter <span class='texttt'>delim</span>; or
</p></li><li id='buffer.async.read.until-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.read.until-5.2'>(5.2)</a></div><p ><span class='texttt'>b.size() == b.max_size()</span>; or
</p></li><li id='buffer.async.read.until-5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#buffer.async.read.until-5.3'>(5.3)</a></div><p >an asynchronous read_some operation fails.
</p></li></ul></div></div><div class='para' id='buffer.async.read.until-6'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-6'>6</a></div><div class='itemdescr'><p >The program shall ensure the <span class='texttt'>AsyncReadStream</span> object <span class='texttt'>stream</span> is valid until the completion handler for the asynchronous operation is invoked.</p></div></div><div class='para' id='buffer.async.read.until-7'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-7'>7</a></div><div class='itemdescr'><p >If <span class='texttt'>delim</span> is of type <span class='texttt'>string_view</span>, the implementation copies the underlying sequence of characters prior to initiating an asynchronous read_some operation on the stream. [&nbsp;<i>Note:</i> This means that the caller is not required to guarantee the validity of the delimiter string after the call to <span class='texttt'>async_read_until</span> returns. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='buffer.async.read.until-8'><div class='marginalizedparent'><a class='marginalized' href='#buffer.async.read.until-8'>8</a></div><div class='itemdescr'><p >On completion of the asynchronous operation, if the readable bytes of <span class='texttt'>b</span> contain the delimiter, <span class='texttt'>ec</span> is set such that <span class='texttt'>!ec</span> is <span class='texttt'>true</span>. Otherwise, if <span class='texttt'>b.size() == b.max_size()</span>, <span class='texttt'>ec</span> is set such that <span class='texttt'>ec == stream_errc::not_found</span>. If <span class='texttt'>b.size() &lt; b.max_size()</span>, <span class='texttt'>ec</span> is the <span class='texttt'>error_code</span> from the most recent asynchronous read_some operation. <span class='texttt'>n</span> is the number of readable bytes in <span class='texttt'>b</span> up to and including the delimiter, if present, otherwise <span class='texttt'>0</span>.
</p></div></div></div></div><div id='socket'><h1 ><a class='secnum' href='#socket' style='min-width:73pt'>18</a> Sockets <a class='abbr_ref' href='./#socket'>[socket]</a></h1><p ><span class='indexparent'><a class='index' id='experimental/socket'></a></span></p><div id='socket.synop'><h2 ><a class='secnum' href='#socket.synop' style='min-width:88pt'>18.1</a> Header <span class='texttt'>&lt;experimental/socket&gt;</span> synopsis <a class='abbr_ref' href='socket.synop'>[socket.synop]</a></h2><p ><span class='indexparent'><a class='index' id='socket_errc'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  enum class socket_errc {
    already_open = <i>an implementation defined non-zero value</i>,
    not_found = <i>an implementation defined non-zero value</i>
  };

  const error_category&amp; socket_category() noexcept;

  error_code make_error_code(socket_errc e) noexcept;
  error_condition make_error_condition(socket_errc e) noexcept;

  <span class='comment'>// Sockets:
</span>
  class socket_base;

  template&lt;class Protocol&gt;
    class basic_socket;

  template&lt;class Protocol&gt;
    class basic_datagram_socket;

  template&lt;class Protocol&gt;
    class basic_stream_socket;

  template&lt;class Protocol&gt;
    class basic_socket_acceptor;

  <span class='comment'>// Socket streams:
</span>
  template&lt;class Protocol, class Clock = chrono::steady_clock,
    class WaitTraits = wait_traits&lt;Clock&gt;&gt;
      class basic_socket_streambuf;

  template&lt;class Protocol, class Clock = chrono::steady_clock,
    class WaitTraits = wait_traits&lt;Clock&gt;&gt;
      class basic_socket_iostream;

  <span class='comment'>// synchronous connect operations:
</span>
  template&lt;class Protocol, class EndpointSequence&gt;
    typename Protocol::endpoint connect(basic_socket&lt;Protocol&gt;&amp; s,
                                        const EndpointSequence&amp; endpoints);
  template&lt;class Protocol, class EndpointSequence&gt;
    typename Protocol::endpoint connect(basic_socket&lt;Protocol&gt;&amp; s,
                                        const EndpointSequence&amp; endpoints,
                                        error_code&amp; ec);
  template&lt;class Protocol, class EndpointSequence, class ConnectCondition&gt;
    typename Protocol::endpoint connect(basic_socket&lt;Protocol&gt;&amp; s,
                                        const EndpointSequence&amp; endpoints,
                                        ConnectCondition c);
  template&lt;class Protocol, class EndpointSequence, class ConnectCondition&gt;
    typename Protocol::endpoint connect(basic_socket&lt;Protocol&gt;&amp; s,
                                        const EndpointSequence&amp; endpoints,
                                        ConnectCondition c,
                                        error_code&amp; ec);

  template&lt;class Protocol, class InputIterator&gt;
    InputIterator connect(basic_socket&lt;Protocol&gt;&amp; s,
                          InputIterator first, InputIterator last);
  template&lt;class Protocol, class InputIterator&gt;
    InputIterator connect(basic_socket&lt;Protocol&gt;&amp; s,
                          InputIterator first, InputIterator last,
                          error_code&amp; ec);
  template&lt;class Protocol, class InputIterator, class ConnectCondition&gt;
    InputIterator connect(basic_socket&lt;Protocol&gt;&amp; s,
                          InputIterator first, InputIterator last,
                          ConnectCondition c);
  template&lt;class Protocol, class InputIterator, class ConnectCondition&gt;
    InputIterator connect(basic_socket&lt;Protocol&gt;&amp; s,
                          InputIterator first, InputIterator last,
                          ConnectCondition c,
                          error_code&amp; ec);

  <span class='comment'>// asynchronous connect operations:
</span>
  template&lt;class Protocol, class EndpointSequence, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_connect(basic_socket&lt;Protocol&gt;&amp; s,
                          const EndpointSequence&amp; endpoints,
                          CompletionToken&amp;&amp; token);
  template&lt;class Protocol, class EndpointSequence, class ConnectCondition,
           class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_connect(basic_socket&lt;Protocol&gt;&amp; s,
                          const EndpointSequence&amp; endpoints,
                          ConnectCondition c,
                          CompletionToken&amp;&amp; token);

  template&lt;class Protocol, class InputIterator, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_connect(basic_socket&lt;Protocol&gt;&amp; s,
                          InputIterator first, InputIterator last,
                          CompletionToken&amp;&amp; token);
  template&lt;class Protocol, class InputIterator, class ConnectCondition,
           class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_connect(basic_socket&lt;Protocol&gt;&amp; s,
                          InputIterator first, InputIterator last,
                          ConnectCondition c,
                          CompletionToken&amp;&amp; token);

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>
  template&lt;&gt; struct is_error_code_enum&lt;
    experimental::net::v1::socket_errc&gt;
      : public true_type {};

} <span class='comment'>// namespace std
</span></pre><div class='para' id='socket.synop-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.synop-1'>1</a></div><p >The figure below illustrates relationships between various types described in this Technical Specification. A solid line from <b>A</b> to <b>B</b> that is terminated by an open arrow indicates that <b>A</b> is derived from <b>B</b>. A solid line from <b>A</b> to <b>B</b> that starts with a diamond and is terminated by a solid arrow indicates that <b>A</b> contains an object of type <b>B</b>. A dotted line from <b>A</b> to <b>B</b> indicates that <b>A</b> is a synonym for the class template <b>B</b> with the specified template argument.</p><div class='figure' id='fig:sockets'><svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   viewBox="0 0 1175 988.75"
   height="988.75"
   width="1175"
   xml:space="preserve"
   version="1.1"
   id="svg2"><metadata
     id="metadata8"><rdf:RDF><cc:Work
         rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" /></cc:Work></rdf:RDF></metadata><defs
     id="defs6"><clipPath
       id="clipPath20"
       clipPathUnits="userSpaceOnUse"><path
         id="path22"
         d="M 0,0 940,0 940,791 0,791 0,0 Z" /></clipPath></defs><g
     transform="matrix(1.25,0,0,-1.25,0,988.75)"
     id="g10"><g
       id="g12"><g
         id="g14"><g
           id="g16"><g
             clip-path="url(#clipPath20)"
             id="g18"><g
               id="g24"><g
                 transform="scale(940,791)"
                 id="g26"><image
                   id="image28"
                   xlink:href="data:image/png;base64,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REREREREZJdYsBIREREREZFdYsFKREREREREdokFKxEREREREdklFqxERERERERkl1iwkirfffcdXn31Va3DIKI6Gj16NNavX691GERUR9u2bcOzzz6rdRhEVo4ePYrY2Fitw6AmhAUrqXL8+HF88cUXWodBRHWUkJCAjIwMrcMgojo6f/48tm3bpnUYRFbeeustvPvuu1qHQU2Io9YB2LOysjLExsZCRLQORXPJyckoLCzEwYMHtQ7FLnTs2BGtW7fWOow7mojg2LFjMBqNWofSqHh5eSE3N5e5bKO77roLISEhWodxxzt9+jRyc3O1DsMuJCQkoLy8nLkMoGXLlujWrVuD9J2Tk4MzZ840SN9NVU5ODvfNWurRowc8PDy0DsPu6ITVWJU++ugjTJs2TeswyA498sgj+Pbbb7UO44524MAB/OEPf9A6DLpDBAYGIjk5Wesw7mj5+fnw8PDgPyKTFb1ej8LCQri4uNR737NmzcKaNWvqvV+iysybNw/vvPOO1mHYHX7DeV7u1AAAIABJREFUWo2ysjJ4enri3LlzWodCdmTOnDnIycnROow7XllZGQDg3Llz8PT01Dgaaso2btyIDz74QOsw7nhGoxEigoiICISGhmodDtmJvXv3YuLEiSgvL2+Q/svKyjB48GBERkY2SP9EFR577DGUlpZqHYZdYsFaA71eDz8/P63DIDvSrFkzFqx2xNfXF15eXlqHQU2Yu7u71iHQLby8vHheJsXtOP4bDAbuc9TgnJyctA7BbnHSJSIiIiIiIrJLLFiJiIiIiIjILrFgJSIiIiIiIrvEgpWIiIiIiIjsEgtWIiIiIiIiskssWBsRs9msdQg2GT58OMLDw+vcz/bt2xEaGopWrVqhZcuW6N69O28cT41aY8rlmJgYBAUF4fDhw3Xq58aNG5g1axY6deoENzc3BAUF4a233qqnKIm0wVxmLtsz7p/cP5sKFqyNxOOPP45HH31U6zBskpqairS0tDr1ceDAAYwaNQqZmZmYM2cOVq5ciUceeQSOjrwjEzU+e/fuRWBgII4dO6Z1KKoVFRUhOTkZJSUldeonPDwc69evR+/evbFmzRrMnDkTISEh9RQl0e3FXGYu2zPun9w/mxp+6m8kTp48iY4dO2odxm334YcfQkSwfft2BAcHax0OUZ2kpKTg6tWrWodx2/3666/YvXs3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WbTr2bMnHB0d8cknn6iKSY1jx45h2bJleP3119GtWzfs27cP//nPf/Dmm2/irrvuqrf1EFXFllz28fEBABw8eLDaPmuby2azGZ999hm6du2q/ERfbd5VfOg4dOiQsiwhIQGLFi2yaqv22GCLp556Co6OjsqHhhkzZuCuu+6q9nIAovqi0+nw73//G4mJiXj99dfh4uKCzZs348CBA3jnnXes2qvN5RkzZsBoNGLjxo349ttvMXHiRFU/4awsl205JwM15zLPyY0H98/6wf2z8XJYxk8DVTpx4gT27NlT6Qe2+hAaGoqCggKEhobCzc0Nw4YNg16vx+DBg60OGImJidi9ezcuXLgAZ2dnXL16FbGxsejevbtFOxcXF2zatAknTpzAyJEjra55MxqNWL58OQCgdevWuHHjBr788kvMmTMHgwcPxptvvqm07dGjB9atW4edO3fi8uXLcHV1RU5ODmJjY3HmzBl07doVwM0D6WeffYbk5GS4urpi6dKl2LZtG4KCguDq6qp8M+Th4YFr164hKioK+/btQ3FxMQwGA3799Vfs2rULd911F1q0aGER74cffggnJydMnz690jEUEXh4eGDRokXQ6XQoKChA8+bNlccN4bvvvkN+fj4mTZrUIP2TOpcuXcLmzZuxaNEi5adJWlGbyx4eHli3bh1OnjwJk8kEk8mEY8eOwdHR0eoa8Jpy+fvvv8fhw4fRqlUr6HQ6nD59GrNmzcLRo0cRERGBdu3aKetUk3dBQUH45JNPsGvXLgQHB2P//v2YPn067rnnHiQmJmLq1KnK/ZDVHhsqnDt3TrmuqGPHjlbjJzcnAMSUKVNw9913o7y8HLm5uZg+fTo6depUH29RnRw7dgz79+/H/PnztQ7ljlZcXIy33noLU6ZMQfv27eu9fx8fH/j4+KBz587o0qUL/P390aZNG/Tu3RuBgYEWbdXmclBQELZu3YrvvvsOxcXFWL9+vdVPIdXmstq8U5vLtTknq8nl231O/u233/Dpp59iyZIltb6eszrR0dHIzs7GlClT6r1vW3D/bJz7py0++ugj+Pn58T6yldFqtqfGoKFva2OLgoICmTJlijg5OSn3qqrs/qSlpaXSqlWrKmdSrJgl+NZ7X/n5+cnChQulqKjIqv3Jkyfl/vvvt1ivwWCQF154QWljNptlzpw54uzsLHq9Xu677z65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"
                   transform="matrix(1,0,0,-1,0,1)"
                   preserveAspectRatio="none"
                   height="1"
                   width="1" /></g></g></g></g></g></g></g></svg><br>Figure <a href='#fig:sockets'>1</a> — Socket and socket stream types [non-normative]</div></div></div><div id='socket.reqmts'><h2 ><a class='secnum' href='#socket.reqmts' style='min-width:88pt'>18.2</a> Requirements <a class='abbr_ref' href='socket.reqmts'>[socket.reqmts]</a></h2><div id='socket.reqmts.sync'><h3 ><a class='secnum' href='#socket.reqmts.sync' style='min-width:103pt'>18.2.1</a> Requirements on synchronous socket operations <a class='abbr_ref' href='socket.reqmts.sync'>[socket.reqmts.sync]</a></h3><div class='para' id='socket.reqmts.sync-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.sync-1'>1</a></div><p >In this section, <span class='indexparent'><a class='index' id='socket_operations,synchronous'></a></span><a class='hidden_link' href='#def:synchronous_socket_operations' id='def:synchronous_socket_operations'><i>synchronous socket operations</i></a> are those member functions specified as two overloads, with and without an argument of type <span class='texttt'>error_code&amp;</span>:</p><pre class='codeblock'>
<i>R f</i>(<i>A1</i> a1, <i>A2</i> a2, ..., <i>AN</i> aN);
<i>R f</i>(<i>A1</i> a1, <i>A2</i> a2, ..., <i>AN</i> aN, error_code&amp; ec);
</pre></div><div class='para' id='socket.reqmts.sync-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.sync-2'>2</a></div><p >For an object <span class='texttt'>s</span>, the conditions under which its synchronous socket operations may block the calling thread (C++Std &sect;<a href='../n4140/defns.block'>[defns.block]</a>) are determined as follows.</p></div><div class='para' id='socket.reqmts.sync-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.sync-3'>3</a></div><p >If:</p><ul class='itemize'><li id='socket.reqmts.sync-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.reqmts.sync-3.1'>(3.1)</a></div><p ><span class='texttt'>s.non_blocking() == true</span>,
</p></li><li id='socket.reqmts.sync-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.reqmts.sync-3.2'>(3.2)</a></div><p >the synchronous socket operation is specified in terms of a POSIX function other than <span class='texttt'>poll</span>,
</p></li><li id='socket.reqmts.sync-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.reqmts.sync-3.3'>(3.3)</a></div><p >that POSIX function lists <span class='texttt'>EWOULDBLOCK</span> or <span class='texttt'>EAGAIN</span> in its failure conditions, and
</p></li><li id='socket.reqmts.sync-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.reqmts.sync-3.4'>(3.4)</a></div><p >the effects of the operation cannot be established immediately
</p></li></ul><p >then the synchronous socket operation shall not block the calling thread. [&nbsp;<i>Note:</i> And the effects of the operation are not established. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='socket.reqmts.sync-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.sync-4'>4</a></div><p >Otherwise, the synchronous socket operation shall block the calling thread until the effects are established.</p></div></div><div id='socket.reqmts.async'><h3 ><a class='secnum' href='#socket.reqmts.async' style='min-width:103pt'>18.2.2</a> Requirements on asynchronous socket operations <a class='abbr_ref' href='socket.reqmts.async'>[socket.reqmts.async]</a></h3><div class='para' id='socket.reqmts.async-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.async-1'>1</a></div><p >In this section, <span class='indexparent'><a class='index' id='socket_operations,asynchronous'></a></span><a class='hidden_link' href='#def:asynchronous_socket_operations' id='def:asynchronous_socket_operations'><i>asynchronous socket operations</i></a> are those member functions having prefix <span class='texttt'>async_</span>.</p></div><div class='para' id='socket.reqmts.async-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.async-2'>2</a></div><p >For an object <span class='texttt'>s</span>, a program may initiate asynchronous socket operations such that there are multiple simultaneously outstanding asynchronous operations.</p></div><div class='para' id='socket.reqmts.async-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.async-3'>3</a></div><p >When there are multiple outstanding asynchronous read operations (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>) on <span class='texttt'>s</span>:</p><ul class='itemize'><li id='socket.reqmts.async-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.reqmts.async-3.1'>(3.1)</a></div><p >having no argument <span class='texttt'>flags</span> of type <span class='texttt'>socket_base::message_flags</span>, or
</p></li><li id='socket.reqmts.async-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.reqmts.async-3.2'>(3.2)</a></div><p >having an argument <span class='texttt'>flags</span> of type <span class='texttt'>socket_base::message_flags</span> but where <span class='texttt'>(flags &amp; socket_base::message_out_of_band) == 0</span>
</p></li></ul><p >then the <span class='texttt'>buffers</span> are filled in the order in which these operations were issued. The order of invocation of the completion handlers for these operations is unspecified.</p></div><div class='para' id='socket.reqmts.async-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.async-4'>4</a></div><p >When there are multiple outstanding asynchronous read operations (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>) on <span class='texttt'>s</span> having an argument <span class='texttt'>flags</span> of type <span class='texttt'>socket_base::message_flags</span> where <span class='texttt'>(flags &amp; socket_base::message_out_of_band) != 0</span> then the <span class='texttt'>buffers</span> are filled in the order in which these operations were issued.</p></div><div class='para' id='socket.reqmts.async-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.async-5'>5</a></div><p >When there are multiple outstanding asynchronous write operations (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>) on <span class='texttt'>s</span>, the <span class='texttt'>buffers</span> are transmitted in the order in which these operations were issued. The order of invocation of the completion handlers for these operations is unspecified.</p><p ><span class='indexparent'><a class='index' id='native_handles'></a></span></p></div></div><div id='socket.reqmts.native'><h3 ><a class='secnum' href='#socket.reqmts.native' style='min-width:103pt'>18.2.3</a> Native handles <a class='abbr_ref' href='socket.reqmts.native'>[socket.reqmts.native]</a></h3><div class='para' id='socket.reqmts.native-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.native-1'>1</a></div><p >Several classes described in this Technical Specification have a member type <span class='texttt'>native_handle_type</span>, a member function <span class='texttt'>native_handle</span>, and member functions that accept arguments of type <span class='texttt'>native_handle_type</span>. The presence of these members and their semantics is
<span class='indexparent'><a class='index' id='presence_and_meaning_of_native_handle_type_and_native_handle'></a></span>implementation-defined.</p></div><div class='para' id='socket.reqmts.native-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.native-2'>2</a></div><p >[&nbsp;<i>Note:</i> These members allow implementations to provide access to their implementation details. Their names are specified to facilitate portable compile-time detection. Actual use of these members is inherently non-portable. For operating systems that are based on POSIX, implementations are encouraged to define the <span class='texttt'>native_handle_type</span> for sockets as <span class='texttt'>int</span>, representing the native file descriptor associated with the socket. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='Endpoint'></a></span></p></div></div><div id='socket.reqmts.endpoint'><h3 ><a class='secnum' href='#socket.reqmts.endpoint' style='min-width:103pt'>18.2.4</a> Endpoint requirements <a class='abbr_ref' href='socket.reqmts.endpoint'>[socket.reqmts.endpoint]</a></h3><div class='para' id='socket.reqmts.endpoint-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.endpoint-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>Endpoint</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>DefaultConstructible</span> (C++Std &sect;<a href='../n4140/defaultconstructible'>[defaultconstructible]</a>), <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), and <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>), as well as the additional requirements listed below.</p></div><div class='para' id='socket.reqmts.endpoint-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.endpoint-2'>2</a></div><p >In the table below, <span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>,
and <span class='texttt'>u</span> denotes an identifier.</p><div class='numberedTable' id='tab:socket.reqmts.endpoint.requirements'>Table <a href='#tab:socket.reqmts.endpoint.requirements'>21</a> — Endpoint requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::protocol_type</span>  </td><td class='left'>
type meeting <span class='texttt'>Protocol</span> (<a href='socket.reqmts.protocol'>[socket.reqmts.protocol]</a>) requirements  </td><td class='left'>
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.protocol()</span>  </td><td class='left'>
<span class='texttt'>protocol_type</span>  </td><td class='left'>
  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='extensible_implementation,Endpoint'></a></span><span class='indexparent'><a class='index' id='Endpoint,extensible_implementation'></a></span></p></div><div class='para' id='socket.reqmts.endpoint-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.endpoint-3'>3</a></div><p >In the table below, <span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>,
<span class='texttt'>b</span> denotes a value of type <span class='texttt'>X</span>,
and <span class='texttt'>s</span> denotes a value of a (possibly const) type
that is convertible to <span class='texttt'>size_t</span> and denotes a size in bytes.</p><div class='numberedTable' id='tab:socket.reqmts.endpoint.requirements.ext'>Table <a href='#tab:socket.reqmts.endpoint.requirements.ext'>22</a> — Endpoint requirements for extensible implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.data()</span>  </td><td class='left'>
<span class='texttt'>const void*</span>  </td><td class='left'>
Returns a pointer suitable for passing as the <span class='texttt'>address</span> argument to functions such as POSIX <span class='texttt'>connect</span>, or as the <span class='texttt'>dest_addr</span> argument to functions such as POSIX <span class='texttt'>sendto</span>. The implementation shall perform a <span class='texttt'>static_cast</span> on the pointer to convert it to <span class='texttt'>const sockaddr*</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.data()</span>  </td><td class='left'>
<span class='texttt'>void*</span>  </td><td class='left'>
Returns a pointer suitable for passing as the <span class='texttt'>address</span> argument to functions such as POSIX <span class='texttt'>accept</span>, <span class='texttt'>getpeername</span>, <span class='texttt'>getsockname</span> and <span class='texttt'>recvfrom</span>. The implementation shall perform a <span class='texttt'>static_cast</span> on the pointer to convert it to <span class='texttt'>sockaddr*</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.size()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>address_len</span> argument to functions such as POSIX <span class='texttt'>connect</span>, or as the <span class='texttt'>dest_len</span> argument to functions such as POSIX <span class='texttt'>sendto</span>, after appropriate integer conversion has been performed.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.resize(s)</span>  </td><td class='left'>
  </td><td class='left'>
pre: <span class='texttt'>s &gt;= 0</span><br/>
post: <span class='texttt'>a.size() == s</span><br/>
Passed the value contained in the <span class='texttt'>address_len</span> argument to functions such as POSIX <span class='texttt'>accept</span>, <span class='texttt'>getpeername</span>, <span class='texttt'>getsockname</span>, and <span class='texttt'>recvfrom</span>, after successful completion of the function. Permitted to throw an exception if the protocol associated with the endpoint object <span class='texttt'>a</span> does not support the specified size.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.capacity()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>address_len</span> argument to functions such as POSIX <span class='texttt'>accept</span>, <span class='texttt'>getpeername</span>, <span class='texttt'>getsockname</span>, and <span class='texttt'>recvfrom</span>, after appropriate integer conversion has been performed.  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='EndpointSequence'></a></span></p></div></div><div id='socket.reqmts.endpointsequence'><h3 ><a class='secnum' href='#socket.reqmts.endpointsequence' style='min-width:103pt'>18.2.5</a> Endpoint sequence requirements <a class='abbr_ref' href='socket.reqmts.endpointsequence'>[socket.reqmts.endpointsequence]</a></h3><div class='para' id='socket.reqmts.endpointsequence-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.endpointsequence-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>EndpointSequence</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) and <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), as well as the additional requirements listed below.</p></div><div class='para' id='socket.reqmts.endpointsequence-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.endpointsequence-2'>2</a></div><p >In the table below, <span class='texttt'>x</span> denotes a value of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>.</p><div class='numberedTable' id='tab:socket.reqmts.endpointsequence.requirements'>Table <a href='#tab:socket.reqmts.endpointsequence.requirements'>23</a> — EndpointSequence requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>x.begin()</span><br/><span class='texttt'>x.end()</span>  </td><td class='left'>
A type meeting the requirements for forward iterators (C++Std &sect;<a href='../n4140/forward.iterators'>[forward.iterators]</a>) whose value type is convertible to a type satisfying the <span class='texttt'>Endpoint</span> (<a href='socket.reqmts.endpoint'>[socket.reqmts.endpoint]</a>) requirements.  </td><td class='left'>
<span class='texttt'>[x.begin(), x.end())</span> is a valid range.  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='Protocol'></a></span></p></div></div><div id='socket.reqmts.protocol'><h3 ><a class='secnum' href='#socket.reqmts.protocol' style='min-width:103pt'>18.2.6</a> Protocol requirements <a class='abbr_ref' href='socket.reqmts.protocol'>[socket.reqmts.protocol]</a></h3><div class='para' id='socket.reqmts.protocol-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.protocol-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>Protocol</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), and <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>), as well as the additional requirements listed below.</p><div class='numberedTable' id='tab:socket.reqmts.protocol.requirements'>Table <a href='#tab:socket.reqmts.protocol.requirements'>24</a> — Protocol requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::endpoint</span>  </td><td class='left'>
type meeting endpoint (<a href='socket.reqmts.endpoint'>[socket.reqmts.endpoint]</a>) requirements  </td><td class='left'>
  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='extensible_implementation,Protocol'></a></span><span class='indexparent'><a class='index' id='Protocol,extensible_implementation'></a></span></p></div><div class='para' id='socket.reqmts.protocol-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.protocol-2'>2</a></div><p >In the table below, <span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>.</p><div class='numberedTable' id='tab:socket.reqmts.protocol.requirements.ext'>Table <a href='#tab:socket.reqmts.protocol.requirements.ext'>25</a> — Protocol requirements for extensible implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.family()</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the domain argument to POSIX <span class='texttt'>socket</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.type()</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the type argument to POSIX <span class='texttt'>socket</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.protocol()</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the protocol argument to POSIX <span class='texttt'>socket</span> (or equivalent).  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='Acceptable'></a></span></p></div></div><div id='socket.reqmts.acceptableprotocol'><h3 ><a class='secnum' href='#socket.reqmts.acceptableprotocol' style='min-width:103pt'>18.2.7</a> Acceptable protocol requirements <a class='abbr_ref' href='socket.reqmts.acceptableprotocol'>[socket.reqmts.acceptableprotocol]</a></h3><div class='para' id='socket.reqmts.acceptableprotocol-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.acceptableprotocol-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>AcceptableProtocol</span> requirements if it satisfies the requirements of <span class='texttt'>Protocol</span> (<a href='socket.reqmts.protocol'>[socket.reqmts.protocol]</a>) as well as the additional requirements listed below.</p><div class='numberedTable' id='tab:socket.reqmts.acceptableprotocol.requirements'>Table <a href='#tab:socket.reqmts.acceptableprotocol.requirements'>26</a> — AcceptableProtocol requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::socket</span>  </td><td class='left'>
A type that satisfies the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) and <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), and that is publicly and unambiguously derived from <span class='texttt'>basic_socket&lt;X&gt;</span>.  </td><td class='left'>
  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='GettableSocketOption'></a></span></p></div></div><div id='socket.reqmts.gettablesocketoption'><h3 ><a class='secnum' href='#socket.reqmts.gettablesocketoption' style='min-width:103pt'>18.2.8</a> Gettable socket option requirements <a class='abbr_ref' href='socket.reqmts.gettablesocketoption'>[socket.reqmts.gettablesocketoption]</a></h3><div class='para' id='socket.reqmts.gettablesocketoption-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.gettablesocketoption-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>GettableSocketOption</span> requirements if it satisfies the requirements listed below.</p></div><div class='para' id='socket.reqmts.gettablesocketoption-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.gettablesocketoption-2'>2</a></div><p >In the table below, <span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>,
<span class='texttt'>b</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>p</span> denotes a value of a (possibly const) type
that meets the <span class='texttt'>Protocol</span> (<a href='socket.reqmts.protocol'>[socket.reqmts.protocol]</a>) requirements,
and <span class='texttt'>s</span> denotes a value of a (possibly const) type
that is convertible to <span class='texttt'>size_t</span> and denotes a size in bytes.</p><div class='numberedTable' id='tab:socket.reqmts.gettablesocketoption.requirements'>Table <a href='#tab:socket.reqmts.gettablesocketoption.requirements'>27</a> — GettableSocketOption requirements for extensible implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.level(p)</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>level</span> argument to POSIX <span class='texttt'>getsockopt</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.name(p)</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>option_name</span> argument to POSIX <span class='texttt'>getsockopt</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.data(p)</span>  </td><td class='left'>
<span class='texttt'>void*</span>  </td><td class='left'>
Returns a pointer suitable for passing as the <span class='texttt'>option_value</span> argument to POSIX getsockopt (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.size(p)</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>option_len</span> argument to POSIX <span class='texttt'>getsockopt</span> (or equivalent), after appropriate integer conversion has been performed.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.resize(p,s)</span>  </td><td class='left'>
  </td><td class='left'>
post: <span class='texttt'>b.size(p) == s</span>. Passed the value contained in the <span class='texttt'>option_len</span> argument to POSIX <span class='texttt'>getsockopt</span> (or equivalent) after successful completion of the function. Permitted to throw an exception if the socket option object <span class='texttt'>b</span> does not support the specified size.  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='SettableSocketOption'></a></span></p></div></div><div id='socket.reqmts.settablesocketoption'><h3 ><a class='secnum' href='#socket.reqmts.settablesocketoption' style='min-width:103pt'>18.2.9</a> Settable socket option requirements <a class='abbr_ref' href='socket.reqmts.settablesocketoption'>[socket.reqmts.settablesocketoption]</a></h3><div class='para' id='socket.reqmts.settablesocketoption-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.settablesocketoption-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>SettableSocketOption</span> requirements if it satisfies the requirements listed below.</p></div><div class='para' id='socket.reqmts.settablesocketoption-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.settablesocketoption-2'>2</a></div><p >In the table below, <span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>,
<span class='texttt'>p</span> denotes a value or a (possibly const) type
that meets the <span class='texttt'>Protocol</span> (<a href='socket.reqmts.protocol'>[socket.reqmts.protocol]</a>) requirements,
and <span class='texttt'>u</span> denotes an identifier.</p><div class='numberedTable' id='tab:socket.reqmts.settablesocketoption.requirements'>Table <a href='#tab:socket.reqmts.settablesocketoption.requirements'>28</a> — SettableSocketOption requirements for extensible implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.level(p)</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>level</span> argument to POSIX <span class='texttt'>setsockopt</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.name(p)</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>option_name</span> argument to POSIX <span class='texttt'>setsockopt</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.data(p)</span>  </td><td class='left'>
<span class='texttt'>const void*</span>  </td><td class='left'>
Returns a pointer suitable for passing as the <span class='texttt'>option_value</span> argument to POSIX <span class='texttt'>setsockopt</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.size(p)</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns a value suitable for passing as the <span class='texttt'>option_len</span> argument to POSIX <span class='texttt'>setsockopt</span> (or equivalent), after appropriate integer conversion has been performed.  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='BooleanSocketOption'></a></span></p></div></div><div id='socket.reqmts.opt.bool'><h3 ><a class='secnum' href='#socket.reqmts.opt.bool' style='min-width:103pt'>18.2.10</a> Boolean socket options <a class='abbr_ref' href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a></h3><div class='para' id='socket.reqmts.opt.bool-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>BooleanSocketOption</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>DefaultConstructible</span> (C++Std &sect;<a href='../n4140/defaultconstructible'>[defaultconstructible]</a>), <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>), <span class='texttt'>GettableSocketOption</span> (<a href='socket.reqmts.gettablesocketoption'>[socket.reqmts.gettablesocketoption]</a>), and <span class='texttt'>SettableSocketOption</span> (<a href='socket.reqmts.settablesocketoption'>[socket.reqmts.settablesocketoption]</a>), <span class='texttt'>X</span> is contextually convertible to bool, and <span class='texttt'>X</span> satisfies the additional requirements listed below.</p></div><div class='para' id='socket.reqmts.opt.bool-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-2'>2</a></div><p >In the table below, <span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>,
<span class='texttt'>v</span> denotes a value of type <span class='texttt'>bool</span> or <span class='texttt'>const bool</span>,
and <span class='texttt'>u</span> denotes an identifier.</p><div class='numberedTable' id='tab:socket.reqmts.opt.bool.requirements'>Table <a href='#tab:socket.reqmts.opt.bool.requirements'>29</a> — BooleanSocketOption requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X u;</span>  </td><td class='left'>
  </td><td class='left'>
post: <span class='texttt'>!u.value()</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(v);</span>  </td><td class='left'>
  </td><td class='left'>
post: <span class='texttt'>u.value() == v</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.value()</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
 Returns the current boolean value of the socket option object.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>static_cast&lt;bool&gt;(a)</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>a.value()</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>!a</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>!a.value()</span>.  </td></tr></table></div></div><div class='para' id='socket.reqmts.opt.bool-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-3'>3</a></div><p >In this Technical Specification, types that satisfy the <span class='texttt'>BooleanSocketOption</span> requirements are defined as follows.</p><pre class='codeblock'>
class <i>C</i>{
public:
  <span class='comment'>// constructors:
</span>  <i>C</i>() noexcept;
  explicit <i>C</i>(bool v) noexcept;

  <span class='comment'>// members:
</span>  <i>C</i>&amp; operator=(bool v) noexcept;

  bool value() const noexcept;

  explicit operator bool() const noexcept;
  bool operator!() const noexcept;
};
</pre><p ><span class='indexparent'><a class='index' id='extensible_implementation,BooleanSocketOption'></a></span><span class='indexparent'><a class='index' id='BooleanSocketOption,extensible_implementation'></a></span></p></div><div class='para' id='socket.reqmts.opt.bool-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-4'>4</a></div><p >Extensible implementations provide the following member functions:</p><pre class='codeblock'>
class <i>C</i>{
public:
  template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
  template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
  template&lt;class Protocol&gt; void* data(const Protocol&amp; p) noexcept;
  template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
  template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
  template&lt;class Protocol&gt; void resize(const Protocol&amp; p, size_t s);
  <span class='comment'>// <i>remainder unchanged</i>
</span>private:
  int value_; <span class='comment'>// <i>exposition only</i>
</span>};
</pre></div><div class='para' id='socket.reqmts.opt.bool-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-5'>5</a></div><p >Let <i>L</i> and <i>N</i> identify the POSIX macros to be passed as the <span class='texttt'>level</span> and <span class='texttt'>option_name</span> arguments, respectively, to POSIX <span class='texttt'>setsockopt</span> and <span class='texttt'>getsockopt</span>.</p><p ><code class='itemdecl'>
<i>C</i>() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.bool-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-6'>6</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!value()</span>.
</p></div></div><p ><code class='itemdecl'>
explicit <i>C</i>(bool v) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.bool-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-7'>7</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>value() == v</span>.
</p></div></div><p ><code class='itemdecl'>
<i>C</i>&amp; operator=(bool v) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.bool-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.</p></div></div><div class='para' id='socket.reqmts.opt.bool-9'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-9'>9</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>value() == v</span>.
</p></div></div><p ><code class='itemdecl'>
bool value() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.bool-10'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> The stored socket option value. For extensible implementations, returns <span class='texttt'>value_ != 0</span>.
</p></div></div><p ><code class='itemdecl'>
explicit operator bool() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.bool-11'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>value()</span>.
</p></div></div><p ><code class='itemdecl'>
bool operator!() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.bool-12'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!value()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.bool-13'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> <i>L</i>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.bool-14'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> <i>N</i>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; void* data(const Protocol&amp; p) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.bool-15'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>std::addressof(value_)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.bool-16'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>std::addressof(value_)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.bool-17'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-17'>17</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>sizeof(value_)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; void resize(const Protocol&amp; p, size_t s);
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.bool-18'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.bool-18'>18</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>length_error</span> if <span class='texttt'>s</span> is not a valid data size for the protocol specified by <span class='texttt'>p</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='IntegerSocketOption'></a></span></p></div><div id='socket.reqmts.opt.int'><h3 ><a class='secnum' href='#socket.reqmts.opt.int' style='min-width:103pt'>18.2.11</a> Integer socket options <a class='abbr_ref' href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a></h3><div class='para' id='socket.reqmts.opt.int-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>IntegerSocketOption</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>DefaultConstructible</span> (C++Std &sect;<a href='../n4140/defaultconstructible'>[defaultconstructible]</a>), <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>), <span class='texttt'>GettableSocketOption</span> (<a href='socket.reqmts.gettablesocketoption'>[socket.reqmts.gettablesocketoption]</a>), and <span class='texttt'>SettableSocketOption</span> (<a href='socket.reqmts.settablesocketoption'>[socket.reqmts.settablesocketoption]</a>), as well as the additional requirements listed below.</p></div><div class='para' id='socket.reqmts.opt.int-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-2'>2</a></div><p >In the table below, <span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>,
<span class='texttt'>v</span> denotes a value of type <span class='texttt'>int</span> or <span class='texttt'>const int</span>,
and <span class='texttt'>u</span> denotes an identifier.</p><div class='numberedTable' id='tab:socket.reqmts.opt.int.requirements'>Table <a href='#tab:socket.reqmts.opt.int.requirements'>30</a> — IntegerSocketOption requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X u;</span>  </td><td class='left'>
  </td><td class='left'>
post: <span class='texttt'>u.value() == 0</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(v);</span>  </td><td class='left'>
  </td><td class='left'>
post: <span class='texttt'>u.value() == v</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a.value()</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
 Returns the current integer value of the socket option object.  </td></tr></table></div></div><div class='para' id='socket.reqmts.opt.int-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-3'>3</a></div><p >In this Technical Specification, types that satisfy the <span class='texttt'>IntegerSocketOption</span> requirements are defined as follows.</p><pre class='codeblock'>
class <i>C</i>{
public:
  <span class='comment'>// constructors:
</span>  <i>C</i>() noexcept;
  explicit <i>C</i>(int v) noexcept;

  <span class='comment'>// members:
</span>  <i>C</i>&amp; operator=(int v) noexcept;

  int value() const noexcept;
};
</pre><p ><span class='indexparent'><a class='index' id='extensible_implementation,BooleanSocketOption'></a></span><span class='indexparent'><a class='index' id='BooleanSocketOption,extensible_implementation'></a></span></p></div><div class='para' id='socket.reqmts.opt.int-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-4'>4</a></div><p >Extensible implementations provide the following member functions:</p><pre class='codeblock'>
class <i>C</i>{
public:
  template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
  template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
  template&lt;class Protocol&gt; void* data(const Protocol&amp; p) noexcept;
  template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
  template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
  template&lt;class Protocol&gt; void resize(const Protocol&amp; p, size_t s);
  <span class='comment'>// <i>remainder unchanged</i>
</span>private:
  int value_; <span class='comment'>// <i>exposition only</i>
</span>};
</pre></div><div class='para' id='socket.reqmts.opt.int-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-5'>5</a></div><p >Let <i>L</i> and <i>N</i> identify the POSIX macros to be passed as the <span class='texttt'>level</span> and <span class='texttt'>option_name</span> arguments, respectively, to POSIX <span class='texttt'>setsockopt</span> and <span class='texttt'>getsockopt</span>.</p><p ><code class='itemdecl'>
<i>C</i>() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.int-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-6'>6</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!value()</span>.
</p></div></div><p ><code class='itemdecl'>
explicit <i>C</i>(int v) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.int-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-7'>7</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>value() == v</span>.
</p></div></div><p ><code class='itemdecl'>
<i>C</i>&amp; operator=(int v) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.int-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.</p></div></div><div class='para' id='socket.reqmts.opt.int-9'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-9'>9</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>value() == v</span>.
</p></div></div><p ><code class='itemdecl'>
int value() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.int-10'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> The stored socket option value. For extensible implementations, returns <span class='texttt'>value_</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.int-11'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <i>L</i>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.int-12'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <i>N</i>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; void* data(const Protocol&amp; p) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.int-13'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>std::addressof(value_)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.int-14'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>std::addressof(value_)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.int-15'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>sizeof(value_)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; void resize(const Protocol&amp; p, size_t s);
</code></p><div class='itemdescr'></div><div class='para' id='socket.reqmts.opt.int-16'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.opt.int-16'>16</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>length_error</span> if <span class='texttt'>s</span> is not a valid data size for the protocol specified by <span class='texttt'>p</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='requirements,IoControlCommand'></a></span><span class='indexparent'><a class='index' id='IoControlCommand'></a></span></p></div><div id='socket.reqmts.iocontrolcommand'><h3 ><a class='secnum' href='#socket.reqmts.iocontrolcommand' style='min-width:103pt'>18.2.12</a> I/O control command requirements <a class='abbr_ref' href='socket.reqmts.iocontrolcommand'>[socket.reqmts.iocontrolcommand]</a></h3><div class='para' id='socket.reqmts.iocontrolcommand-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.iocontrolcommand-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>IoControlCommand</span> requirements if it satisfies the requirements listed below.</p></div><div class='para' id='socket.reqmts.iocontrolcommand-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.iocontrolcommand-2'>2</a></div><p >In the table below, <span class='texttt'>a</span> denotes a value of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>,
and <span class='texttt'>b</span> denotes a value of type <span class='texttt'>X</span>.</p><div class='numberedTable' id='tab:socket.reqmts.iocontrolcommand.requirements'>Table <a href='#tab:socket.reqmts.iocontrolcommand.requirements'>31</a> — IoControlCommand requirements for extensible implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>a.name()</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Returns a value suitable for passing as the request argument to POSIX <span class='texttt'>ioctl</span> (or equivalent).  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>b.data()</span>  </td><td class='left'>
<span class='texttt'>void*</span>  </td><td class='left'>
  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='requirements,ConnectCondition'></a></span><span class='indexparent'><a class='index' id='ConnectCondition'></a></span></p></div></div><div id='socket.reqmts.connectcondition'><h3 ><a class='secnum' href='#socket.reqmts.connectcondition' style='min-width:103pt'>18.2.13</a> Connect condition requirements <a class='abbr_ref' href='socket.reqmts.connectcondition'>[socket.reqmts.connectcondition]</a></h3><div class='para' id='socket.reqmts.connectcondition-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.connectcondition-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>ConnectCondition</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) and <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), as well as the additional requirements listed below.</p></div><div class='para' id='socket.reqmts.connectcondition-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.reqmts.connectcondition-2'>2</a></div><p >In the table below, <span class='texttt'>x</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>ec</span> denotes a value of type <span class='texttt'>error_code</span> or <span class='texttt'>const error_code</span>,
and <span class='texttt'>ep</span> denotes a value of a type satisfying the endpoint (<a href='socket.reqmts.endpoint'>[socket.reqmts.endpoint]</a>) requirements.</p><div class='numberedTable' id='tab:socket.reqmts.connectcondition.requirements'>Table <a href='#tab:socket.reqmts.connectcondition.requirements'>32</a> — ConnectCondition requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-condition</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>x(ec, ep)</span>  </td><td class='left'>
<span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>true</span> to indicate that the <span class='texttt'>connect</span> or <span class='texttt'>async_connect</span> algorithm should attempt a connection to the endpoint <span class='texttt'>ep</span>. Otherwise, returns <span class='texttt'>false</span> to indicate that the algorithm should not attempt connection to the endpoint <span class='texttt'>ep</span>, and should instead skip to the next endpoint in the sequence.  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='error_codes,socket'></a></span></p></div></div></div><div id='socket.err'><h2 ><a class='secnum' href='#socket.err' style='min-width:88pt'>18.3</a> Error codes <a class='abbr_ref' href='socket.err'>[socket.err]</a></h2><p ><span class='indexparent'><a class='index' id='socket_category'></a></span><code class='itemdecl'>
const error_category&amp; socket_category() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.err-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.err-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to an object of a type derived from class <span class='texttt'>error_category</span>. All calls to this function return references to the same object.</p></div></div><div class='para' id='socket.err-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.err-2'>2</a></div><div class='itemdescr'><p >The object's <span class='texttt'>default_error_condition</span> and <span class='texttt'>equivalent</span> virtual functions behave as specified for the class <span class='texttt'>error_category</span>. The object's <span class='texttt'>name</span> virtual function returns a pointer to the string <span class='texttt'>"socket"</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_error_code'></a></span><span class='indexparent'><a class='index' id='socket_errc,make_error_code'></a></span><code class='itemdecl'>
error_code make_error_code(socket_errc e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.err-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.err-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>error_code(static_cast&lt;int&gt;(e), socket_category())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_error_condition'></a></span><span class='indexparent'><a class='index' id='socket_errc,make_error_condition'></a></span><code class='itemdecl'>
error_condition make_error_condition(socket_errc e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.err-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.err-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>error_condition(static_cast&lt;int&gt;(e), socket_category())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='socket_base'></a></span></p></div><div id='socket.base'><h2 ><a class='secnum' href='#socket.base' style='min-width:88pt'>18.4</a> Class <span class='texttt'>socket_base</span> <a class='abbr_ref' href='socket.base'>[socket.base]</a></h2><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class socket_base
  {
  public:
    class broadcast;
    class debug;
    class do_not_route;
    class keep_alive;
    class linger;
    class out_of_band_inline;
    class receive_buffer_size;
    class receive_low_watermark;
    class reuse_address;
    class send_buffer_size;
    class send_low_watermark;

    using shutdown_type = <i>T1</i>;
    static constexpr shutdown_type shutdown_receive;
    static constexpr shutdown_type shutdown_send;
    static constexpr shutdown_type shutdown_both;

    using wait_type = <i>T2</i>;
    static constexpr wait_type wait_read;
    static constexpr wait_type wait_write;
    static constexpr wait_type wait_error;

    using message_flags = <i>T3</i>;
    static constexpr message_flags message_peek;
    static constexpr message_flags message_out_of_band;
    static constexpr message_flags message_do_not_route;

    static const int max_listen_connections;

  protected:
    socket_base();
    ~socket_base();
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='socket.base-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.base-1'>1</a></div><p ><span class='texttt'>socket_base</span> defines several member types:</p><ul class='itemize'><li id='socket.base-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.base-1.1'>(1.1)</a></div><p >socket option classes <span class='texttt'>broadcast</span>, <span class='texttt'>debug</span>, <span class='texttt'>do_not_route</span>, <span class='texttt'>keep_alive</span>, <span class='texttt'>linger</span>, <span class='texttt'>out_of_band_inline</span>, <span class='texttt'>receive_buffer_size</span>, <span class='texttt'>receive_low_watermark</span>, <span class='texttt'>reuse_address</span>, <span class='texttt'>send_buffer_size</span>, and <span class='texttt'>send_low_watermark</span>;
</p></li><li id='socket.base-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.base-1.2'>(1.2)</a></div><p >an enumerated type, <span class='texttt'>shutdown_type</span>, for use with the <span class='texttt'>basic_socket&lt;Protocol&gt;</span> class's <span class='texttt'>shutdown</span> member function.
</p></li><li id='socket.base-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.base-1.3'>(1.3)</a></div><p >an enumerated type, <span class='texttt'>wait_type</span>, for use with the <span class='texttt'>basic_socket&lt;Protocol&gt;</span> and <span class='texttt'>basic_socket_acceptor&lt;Protocol&gt;</span> classes' <span class='texttt'>wait</span> and <span class='texttt'>async_wait</span> member functions,
</p></li><li id='socket.base-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.base-1.4'>(1.4)</a></div><p >a bitmask type, <span class='texttt'>message_flags</span>, for use with the <span class='texttt'>basic_stream_socket&lt;Protocol&gt;</span> class's <span class='texttt'>send</span>, <span class='texttt'>async_send</span>, <span class='texttt'>receive</span>, and <span class='texttt'>async_receive</span> member functions, and the <span class='texttt'>basic_datagram_socket&lt;Protocol&gt;</span> class's <span class='texttt'>send</span>, <span class='texttt'>async_send</span>, <span class='texttt'>send_to</span>, <span class='texttt'>async_send_to</span>, <span class='texttt'>receive</span>, <span class='texttt'>async_receive</span>, <span class='texttt'>receive_from</span>, and <span class='texttt'>async_receive_from</span> member functions.
</p></li><li id='socket.base-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.base-1.5'>(1.5)</a></div><p >a constant, <span class='texttt'>max_listen_connections</span>, for use with the <span class='texttt'>basic_socket_acceptor&lt;Protocol&gt;</span> class's <span class='texttt'>listen</span> member function.
</p></li></ul><div class='numberedTable' id='tab:socket.base.requirements'>Table <a href='#tab:socket.base.requirements'>33</a> — <span class='texttt'>socket_base</span> constants<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Constant Name</b></td><td colspan='1' class='center'><b>POSIX macro</b></td><td colspan='1' class='center'><b>Definition or notes</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>shutdown_receive</span>  </td><td class='left'>
<span class='texttt'>SHUT_RD</span>  </td><td class='left'>
 Disables further receive operations.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>shutdown_send</span>  </td><td class='left'>
<span class='texttt'>SHUT_WR</span>  </td><td class='left'>
 Disables further send operations.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>shutdown_both</span>  </td><td class='left'>
<span class='texttt'>SHUT_RDWR</span>  </td><td class='left'>
 Disables further send and receive operations.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>wait_read</span>  </td><td class='left'>
  </td><td class='left'>
Wait until the socket is ready-to-read. For a given socket, when a <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operation using <span class='texttt'>wait_read</span> completes successfully, a subsequent call to the socket's <span class='texttt'>receive</span> or <span class='texttt'>receive_from</span> functions may complete without blocking. Similarly, for a given acceptor, when a <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operation using <span class='texttt'>wait_read</span> completes successfully, a subsequent call to the acceptor's <span class='texttt'>accept</span> function may complete without blocking.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>wait_write</span>  </td><td class='left'>
  </td><td class='left'>
Wait until the socket is ready-to-write. For a given socket, when a <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operation using <span class='texttt'>wait_write</span> completes successfully, a subsequent call to the socket's <span class='texttt'>send</span> or <span class='texttt'>send_to</span> functions may complete without blocking.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>wait_error</span>  </td><td class='left'>
  </td><td class='left'>
Wait until the socket has a pending error condition. For a given socket, when a <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operation using <span class='texttt'>wait_error</span> completes successfully, a subsequent call to one of the socket's synchronous operations may complete without blocking. The nature of the pending error condition determines which.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>message_peek</span>  </td><td class='left'>
<span class='texttt'>MSG_PEEK</span>  </td><td class='left'>
 Leave received data in queue.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>message_out_of_band</span>  </td><td class='left'>
<span class='texttt'>MSG_OOB</span>  </td><td class='left'>
 Out-of-band data.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>message_do_not_route</span>  </td><td class='left'>
<span class='texttt'>MSG_DONTROUTE</span>  </td><td class='left'>
 Send without using routing tables.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>max_listen_connections</span>  </td><td class='left'>
<span class='texttt'>SOMAXCONN</span>  </td><td class='left'>
 The <span class='indexparent'><a class='index' id='maximum_length_of_the_queue_of_pending_incoming_connections'></a></span>implementation-defined limit on the length of the queue of pending incoming connections.  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='socket_options'></a></span></p></div></div><div id='socket.opt'><h2 ><a class='secnum' href='#socket.opt' style='min-width:88pt'>18.5</a> Socket options <a class='abbr_ref' href='socket.opt'>[socket.opt]</a></h2><div class='para' id='socket.opt-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt-1'>1</a></div><p >In the table below, let <i>C</i> denote a socket option class; let <i>L</i> identify the POSIX macro to be passed as the <span class='texttt'>level</span> argument to POSIX <span class='texttt'>setsockopt</span> and <span class='texttt'>getsockopt</span>; let <i>N</i> identify the POSIX macro to be passed as the <span class='texttt'>option_name</span> argument to POSIX <span class='texttt'>setsockopt</span> and <span class='texttt'>getsockopt</span>; and let <i>T</i> identify the type of the value whose address will be passed as the <span class='texttt'>option_value</span> argument to POSIX <span class='texttt'>setsockopt</span> and <span class='texttt'>getsockopt</span>.</p><div class='numberedTable' id='tab:socket.opt.requirements'>Table <a href='#tab:socket.opt.requirements'>34</a> — Socket options<br><table ><tr class='rowsep'><td colspan='1' class='center'><b><i>C</i></b></td><td colspan='1' class='center'><b><i>L</i></b></td><td colspan='1' class='center'><b><i>N</i></b></td><td colspan='1' class='center'><b><i>T</i></b></td><td colspan='1' class='center'><b>Requirements, definition or notes</b></td></tr><tr class='capsep'><td class='justify'> 
<span class='texttt'>socket_base::</span>
<span class='texttt'>broadcast</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_BROADCAST</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether a socket permits sending of broadcast messages, if supported by the protocol.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>debug</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_DEBUG</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether debugging information is recorded by the underlying protocol.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>do_not_route</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_DONTROUTE</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether outgoing messages bypass standard routing facilities.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>keep_alive</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_KEEPALIVE</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether a socket permits sending of keep_alive messages, if supported by the protocol.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>linger</span> (<a href='socket.opt.linger'>[socket.opt.linger]</a>)  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_LINGER</span>  </td><td class='left'>
<span class='texttt'>linger</span>  </td><td class='justify'>
 Controls the behavior when a socket is closed and unsent data is present.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>out_of_band_inline</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_OOBINLINE</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether out-of-band data (also known as urgent data) is received inline.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>receive_buffer_size</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_RCVBUF</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the size of the receive buffer associated with a socket.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>receive_low_watermark</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_RCVLOWAT</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the minimum number of bytes to process for socket input operations.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>reuse_address</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_REUSEADDR</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether the validation of endpoints used for binding a socket should allow the reuse of local endpoints, if supported by the protocol.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>send_buffer_size</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_SNDBUF</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the size of the send buffer associated with a socket.  </td></tr><tr class='rowsep'><td class='justify'> <span class='texttt'>socket_base::</span>
<span class='texttt'>send_low_watermark</span>  </td><td class='left'>
<span class='texttt'>SOL_SOCKET</span>  </td><td class='left'>
<span class='texttt'>SO_SNDLOWAT</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='justify'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the minimum number of bytes to process for socket output operations.  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='linger'></a></span></p></div><div id='socket.opt.linger'><h3 ><a class='secnum' href='#socket.opt.linger' style='min-width:103pt'>18.5.1</a> Class <span class='texttt'>socket_base::linger</span> <a class='abbr_ref' href='socket.opt.linger'>[socket.opt.linger]</a></h3><div class='para' id='socket.opt.linger-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-1'>1</a></div><p >The <span class='texttt'>linger</span> class represents a socket option for controlling the behavior when a socket is closed and unsent data is present.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class socket_base::linger
  {
  public:
    <span class='comment'>// constructors:
</span>    linger() noexcept;
    linger(bool e, chrono::seconds t) noexcept;

    <span class='comment'>// members:
</span>    bool enabled() const noexcept;
    void enabled(bool e) noexcept;

    chrono::seconds timeout() const noexcept;
    void timeout(chrono::seconds t) noexcept;
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='socket.opt.linger-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-2'>2</a></div><p ><span class='texttt'>linger</span> satisfies the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>DefaultConstructible</span> (C++Std &sect;<a href='../n4140/defaultconstructible'>[defaultconstructible]</a>), <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>), <span class='texttt'>GettableSocketOption</span> (<a href='socket.reqmts.gettablesocketoption'>[socket.reqmts.gettablesocketoption]</a>), and <span class='texttt'>SettableSocketOption</span> (<a href='socket.reqmts.settablesocketoption'>[socket.reqmts.settablesocketoption]</a>).</p><p ><span class='indexparent'><a class='index' id='extensible_implementation,linger'></a></span><span class='indexparent'><a class='index' id='linger,extensible_implementation'></a></span></p></div><div class='para' id='socket.opt.linger-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-3'>3</a></div><p >Extensible implementations provide the following member functions:</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  class socket_base::linger
  {
  public:
    template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
    template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
    template&lt;class Protocol&gt; void data(const Protocol&amp; p) noexcept;
    template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
    template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
    template&lt;class Protocol&gt; void resize(const Protocol&amp; p, size_t s);
    <span class='comment'>// <i>remainder unchanged</i>
</span>  private:
    ::linger value_;  <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><code class='itemdecl'>
linger() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='socket.opt.linger-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!enabled() &amp;&amp; timeout() == chrono::seconds(0)</span>.
</p></div></div><p ><code class='itemdecl'>
linger(bool e, chrono::seconds t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.opt.linger-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>enabled() == e &amp;&amp; timeout() == t</span>.
</p></div></div><p ><code class='itemdecl'>
bool enabled() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.opt.linger-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>value_.l_onoff != 0</span>.
</p></div></div><p ><code class='itemdecl'>
void enabled(bool e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.opt.linger-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-7'>7</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>enabled() == e</span>.
</p></div></div><p ><code class='itemdecl'>
chrono::seconds timeout() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.opt.linger-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>chrono::seconds(value_.l_linger)</span>.
</p></div></div><p ><code class='itemdecl'>
void timeout(chrono::seconds t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.opt.linger-9'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-9'>9</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>timeout() == t</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.opt.linger-10'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>SOL_SOCKET</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.opt.linger-11'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>SO_LINGER</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; void* data(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.opt.linger-12'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>std::addressof(value_)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.opt.linger-13'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>std::addressof(value_)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.opt.linger-14'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>sizeof(value_)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; void resize(const Protocol&amp; p, size_t s);
</code></p><div class='itemdescr'></div><div class='para' id='socket.opt.linger-15'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt.linger-15'>15</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>length_error</span> if <span class='texttt'>s != sizeof(value_)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_socket'></a></span></p></div></div><div id='socket.basic'><h2 ><a class='secnum' href='#socket.basic' style='min-width:88pt'>18.6</a> Class template <span class='texttt'>basic_socket</span> <a class='abbr_ref' href='socket.basic'>[socket.basic]</a></h2><div class='para' id='socket.basic-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic-1'>1</a></div><p >Class template <span class='texttt'>basic_socket&lt;Protocol&gt;</span> is used as the base class for the <span class='texttt'>basic_datagram_socket&lt;Protocol&gt;</span> and <span class='texttt'>basic_stream_socket&lt;Protocol&gt;</span> class templates. It provides functionality that is common to both types of socket.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Protocol&gt;
  class basic_socket : public socket_base
  {
  public:
    <span class='comment'>// types:
</span>
    using executor_type = io_context::executor_type;
    using native_handle_type = <i>implementation defined</i>; <span class='comment'>// see <a href='socket.reqmts.native'>[socket.reqmts.native]</a>
</span>    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;

    <span class='comment'>// basic_socket operations:
</span>
    executor_type get_executor() noexcept;

    native_handle_type native_handle(); <span class='comment'>// see <a href='socket.reqmts.native'>[socket.reqmts.native]</a>
</span>
    void open(const protocol_type&amp; protocol = protocol_type());
    void open(const protocol_type&amp; protocol, error_code&amp; ec);

    void assign(const protocol_type&amp; protocol,
                const native_handle_type&amp; native_socket); <span class='comment'>// see <a href='socket.reqmts.native'>[socket.reqmts.native]</a>
</span>    void assign(const protocol_type&amp; protocol,
                const native_handle_type&amp; native_socket,
                error_code&amp; ec); <span class='comment'>// see <a href='socket.reqmts.native'>[socket.reqmts.native]</a>
</span>
    bool is_open() const noexcept;

    void close();
    void close(error_code&amp; ec);

    void cancel();
    void cancel(error_code&amp; ec);

    template&lt;class SettableSocketOption&gt;
      void set_option(const SettableSocketOption&amp; option);
    template&lt;class SettableSocketOption&gt;
      void set_option(const SettableSocketOption&amp; option, error_code&amp; ec);

    template&lt;class GettableSocketOption&gt;
      void get_option(GettableSocketOption&amp; option) const;
    template&lt;class GettableSocketOption&gt;
      void get_option(GettableSocketOption&amp; option, error_code&amp; ec) const;

    template&lt;class IoControlCommand&gt;
      void io_control(IoControlCommand&amp; command);
    template&lt;class IoControlCommand&gt;
      void io_control(IoControlCommand&amp; command, error_code&amp; ec);

    void non_blocking(bool mode);
    void non_blocking(bool mode, error_code&amp; ec);
    bool non_blocking() const;

    void native_non_blocking(bool mode);
    void native_non_blocking(bool mode, error_code&amp; ec);
    bool native_non_blocking() const;

    bool at_mark() const;
    bool at_mark(error_code&amp; ec) const;

    size_t available() const;
    size_t available(error_code&amp; ec) const;

    void bind(const endpoint_type&amp; endpoint);
    void bind(const endpoint_type&amp; endpoint, error_code&amp; ec);

    void shutdown(shutdown_type what);
    void shutdown(shutdown_type what, error_code&amp; ec);

    endpoint_type local_endpoint() const;
    endpoint_type local_endpoint(error_code&amp; ec) const;

    endpoint_type remote_endpoint() const;
    endpoint_type remote_endpoint(error_code&amp; ec) const;

    void connect(const endpoint_type&amp; endpoint);
    void connect(const endpoint_type&amp; endpoint, error_code&amp; ec);

    template&lt;class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_connect(const endpoint_type&amp; endpoint,
                            CompletionToken&amp;&amp; token);

    void wait(wait_type w);
    void wait(wait_type w, error_code&amp; ec);

    template&lt;class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_wait(wait_type w, CompletionToken&amp;&amp; token);

  protected:
    <span class='comment'>// construct / copy / destroy:
</span>
    explicit basic_socket(io_context&amp; ctx);
    basic_socket(io_context&amp; ctx, const protocol_type&amp; protocol);
    basic_socket(io_context&amp; ctx, const endpoint_type&amp; endpoint);
    basic_socket(io_context&amp; ctx, const protocol_type&amp; protocol,
                 const native_handle_type&amp; native_socket); <span class='comment'>// see <a href='socket.reqmts.native'>[socket.reqmts.native]</a>
</span>    basic_socket(const basic_socket&amp;) = delete;
    basic_socket(basic_socket&amp;&amp; rhs);
    template&lt;class OtherProtocol&gt;
      basic_socket(basic_socket&lt;OtherProtocol&gt;&amp;&amp; rhs);

    ~basic_socket();

    basic_socket&amp; operator=(const basic_socket&amp;) = delete;
    basic_socket&amp; operator=(basic_socket&amp;&amp; rhs);
    template&lt;class OtherProtocol&gt;
      basic_socket&amp; operator=(basic_socket&lt;OtherProtocol&gt;&amp;&amp; rhs);

  private:
    protocol_type protocol_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='socket.basic-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic-2'>2</a></div><p >Instances of class template <span class='texttt'>basic_socket</span> meet the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), and <span class='texttt'>MoveAssignable</span> (C++Std &sect;<a href='../n4140/moveassignable'>[moveassignable]</a>).</p></div><div class='para' id='socket.basic-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic-3'>3</a></div><p >When an operation has its effects specified as if by passing the result of <span class='texttt'>native_handle()</span> to a POSIX function, then the operation fails with error condition <span class='texttt'>errc::bad_file_descriptor</span> if <span class='texttt'>is_open() == false</span> at the point in the effects when the POSIX function is called.</p></div><div id='socket.basic.cons'><h3 ><a class='secnum' href='#socket.basic.cons' style='min-width:103pt'>18.6.1</a> <span class='texttt'>basic_socket</span> constructors <a class='abbr_ref' href='socket.basic.cons'>[socket.basic.cons]</a></h3><p ><code class='itemdecl'>
explicit basic_socket(io_context&amp; ctx);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.basic.cons-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-1.1'>(1.1)</a></div><p ><span class='texttt'>get_executor() == ctx.get_executor()</span>.
</p></li><li id='socket.basic.cons-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-1.2'>(1.2)</a></div><p ><span class='texttt'>is_open() == false</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
basic_socket(io_context&amp; ctx, const protocol_type&amp; protocol);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Opens this socket as if by calling <span class='texttt'>open(protocol)</span>.</p></div></div><div class='para' id='socket.basic.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.basic.cons-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-3.1'>(3.1)</a></div><p ><span class='texttt'>get_executor() == ctx.get_executor()</span>.
</p></li><li id='socket.basic.cons-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-3.2'>(3.2)</a></div><p ><span class='texttt'>is_open() == true</span>.
</p></li><li id='socket.basic.cons-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-3.3'>(3.3)</a></div><p ><span class='texttt'>non_blocking() == false</span>.
</p></li><li id='socket.basic.cons-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-3.4'>(3.4)</a></div><p ><span class='texttt'>protocol_ == protocol</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
basic_socket(io_context&amp; ctx, const endpoint_type&amp; endpoint);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Opens and binds this socket as if by calling:
</p><pre class='codeblock'>
open(endpoint.protocol());
bind(endpoint);
</pre></div></div><div class='para' id='socket.basic.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.cons-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.basic.cons-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-5.1'>(5.1)</a></div><p ><span class='texttt'>get_executor() == ctx.get_executor()</span>.
</p></li><li id='socket.basic.cons-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-5.2'>(5.2)</a></div><p ><span class='texttt'>is_open() == true</span>.
</p></li><li id='socket.basic.cons-5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-5.3'>(5.3)</a></div><p ><span class='texttt'>non_blocking() == false</span>.
</p></li><li id='socket.basic.cons-5.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-5.4'>(5.4)</a></div><p ><span class='texttt'>protocol_ == endpoint.protocol()</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
basic_socket(io_context&amp; ctx, const protocol_type&amp; protocol,
             const native_handle_type&amp; native_socket);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.cons-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>native_socket</span> is a native handle to an open socket.</p></div></div><div class='para' id='socket.basic.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.cons-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns the existing native socket into this socket as if by calling <span class='texttt'>assign(protocol, native_socket)</span>.</p></div></div><div class='para' id='socket.basic.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.cons-8'>8</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.basic.cons-8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-8.1'>(8.1)</a></div><p ><span class='texttt'>get_executor() == ctx.get_executor()</span>.
</p></li><li id='socket.basic.cons-8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-8.2'>(8.2)</a></div><p ><span class='texttt'>is_open() == true</span>.
</p></li><li id='socket.basic.cons-8.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-8.3'>(8.3)</a></div><p ><span class='texttt'>non_blocking() == false</span>.
</p></li><li id='socket.basic.cons-8.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-8.4'>(8.4)</a></div><p ><span class='texttt'>protocol_ == protocol</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
basic_socket(basic_socket&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.cons-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs an object of class <span class='texttt'>basic_socket&lt;Protocol&gt;</span> that refers to the state originally represented by <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='socket.basic.cons-10'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.cons-10'>10</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.basic.cons-10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-10.1'>(10.1)</a></div><p ><span class='texttt'>get_executor() == rhs.get_executor()</span>.
</p></li><li id='socket.basic.cons-10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-10.2'>(10.2)</a></div><p ><span class='texttt'>is_open()</span> returns the same value as <span class='texttt'>rhs.is_open()</span> prior to the constructor invocation.
</p></li><li id='socket.basic.cons-10.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-10.3'>(10.3)</a></div><p ><span class='texttt'>non_blocking()</span> returns the same value as <span class='texttt'>rhs.non_blocking()</span> prior to the constructor invocation.
</p></li><li id='socket.basic.cons-10.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-10.4'>(10.4)</a></div><p ><span class='texttt'>native_handle()</span> returns the prior value of <span class='texttt'>rhs.native_handle()</span>.
</p></li><li id='socket.basic.cons-10.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-10.5'>(10.5)</a></div><p ><span class='texttt'>protocol_</span> is the prior value of <span class='texttt'>rhs.protocol_</span>.
</p></li><li id='socket.basic.cons-10.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-10.6'>(10.6)</a></div><p ><span class='texttt'>rhs.is_open() == false</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
template&lt;class OtherProtocol&gt;
  basic_socket(basic_socket&lt;OtherProtocol&gt;&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.cons-11'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.cons-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.</p></div></div><div class='para' id='socket.basic.cons-12'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.cons-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs an object of class <span class='texttt'>basic_socket&lt;Protocol&gt;</span> that refers to the state originally represented by <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='socket.basic.cons-13'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.cons-13'>13</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.basic.cons-13.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-13.1'>(13.1)</a></div><p ><span class='texttt'>get_executor() == rhs.get_executor()</span>.
</p></li><li id='socket.basic.cons-13.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-13.2'>(13.2)</a></div><p ><span class='texttt'>is_open()</span> returns the same value as <span class='texttt'>rhs.is_open()</span> prior to the constructor invocation.
</p></li><li id='socket.basic.cons-13.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-13.3'>(13.3)</a></div><p ><span class='texttt'>non_blocking()</span> returns the same value as <span class='texttt'>rhs.non_blocking()</span> prior to the constructor invocation.
</p></li><li id='socket.basic.cons-13.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-13.4'>(13.4)</a></div><p ><span class='texttt'>native_handle()</span> returns the prior value of <span class='texttt'>rhs.native_handle()</span>.
</p></li><li id='socket.basic.cons-13.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-13.5'>(13.5)</a></div><p ><span class='texttt'>protocol_</span> is the result of converting the prior value of <span class='texttt'>rhs.protocol_</span>.
</p></li><li id='socket.basic.cons-13.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.cons-13.6'>(13.6)</a></div><p ><span class='texttt'>rhs.is_open() == false</span>.
</p></li></ul></div></div><div class='para' id='socket.basic.cons-14'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.cons-14'>14</a></div><div class='itemdescr'><p ><i>Remarks:</i> This constructor shall not participate in overload resolution unless <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.
</p></div></div></div><div id='socket.basic.dtor'><h3 ><a class='secnum' href='#socket.basic.dtor' style='min-width:103pt'>18.6.2</a> <span class='texttt'>basic_socket</span> destructor <a class='abbr_ref' href='socket.basic.dtor'>[socket.basic.dtor]</a></h3><p ><code class='itemdecl'>
~basic_socket();
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>is_open()</span> is <span class='texttt'>true</span>, cancels all outstanding asynchronous operations associated with this socket, disables the linger socket option to prevent the destructor from blocking, and releases socket resources as if by POSIX <span class='texttt'>close(native_handle())</span>. Completion handlers for canceled operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.
</p></div></div></div><div id='socket.basic.assign'><h3 ><a class='secnum' href='#socket.basic.assign' style='min-width:103pt'>18.6.3</a> <span class='texttt'>basic_socket</span> assignment <a class='abbr_ref' href='socket.basic.assign'>[socket.basic.assign]</a></h3><p ><code class='itemdecl'>
basic_socket&amp; operator=(basic_socket&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>is_open()</span> is <span class='texttt'>true</span>, cancels all outstanding asynchronous operations associated with this socket. Completion handlers for canceled operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>. Disables the linger socket option to prevent the assignment from blocking, and releases socket resources as if by POSIX <span class='texttt'>close(native_handle())</span>. Moves into <span class='texttt'>*this</span> the state originally represented by <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='socket.basic.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.assign-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.basic.assign-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.assign-2.1'>(2.1)</a></div><p ><span class='texttt'>get_executor() == rhs.get_executor()</span>.
</p></li><li id='socket.basic.assign-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.assign-2.2'>(2.2)</a></div><p ><span class='texttt'>is_open()</span> returns the same value as <span class='texttt'>rhs.is_open()</span> prior to the assignment.
</p></li><li id='socket.basic.assign-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.assign-2.3'>(2.3)</a></div><p ><span class='texttt'>non_blocking()</span> returns the same value as <span class='texttt'>rhs.non_blocking()</span> prior to the assignment.
</p></li><li id='socket.basic.assign-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.assign-2.4'>(2.4)</a></div><p ><span class='texttt'>protocol_</span> is the prior value of <span class='texttt'>rhs.protocol_</span>.
</p></li><li id='socket.basic.assign-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.assign-2.5'>(2.5)</a></div><p ><span class='texttt'>rhs.is_open() == false</span>.
</p></li></ul></div></div><div class='para' id='socket.basic.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.assign-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class OtherProtocol&gt;
  basic_socket&amp; operator=(basic_socket&lt;OtherProtocol&gt;&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.assign-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.</p></div></div><div class='para' id='socket.basic.assign-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.assign-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>is_open()</span> is <span class='texttt'>true</span>, cancels all outstanding asynchronous operations associated with this socket. Completion handlers for canceled operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>. Disables the linger socket option to prevent the assignment from blocking, and releases socket resources as if by POSIX <span class='texttt'>close(native_handle())</span>. Moves into <span class='texttt'>*this</span> the state originally represented by <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='socket.basic.assign-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.assign-6'>6</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.basic.assign-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.assign-6.1'>(6.1)</a></div><p ><span class='texttt'>get_executor() == rhs.get_executor()</span>.
</p></li><li id='socket.basic.assign-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.assign-6.2'>(6.2)</a></div><p ><span class='texttt'>is_open()</span> returns the same value as <span class='texttt'>rhs.is_open()</span> prior to the assignment.
</p></li><li id='socket.basic.assign-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.assign-6.3'>(6.3)</a></div><p ><span class='texttt'>non_blocking()</span> returns the same value as <span class='texttt'>rhs.non_blocking()</span> prior to the assignment.
</p></li><li id='socket.basic.assign-6.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.assign-6.4'>(6.4)</a></div><p ><span class='texttt'>protocol_</span> is the result of converting the prior value of <span class='texttt'>rhs.protocol_</span>.
</p></li><li id='socket.basic.assign-6.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.assign-6.5'>(6.5)</a></div><p ><span class='texttt'>rhs.is_open() == false</span>.
</p></li></ul></div></div><div class='para' id='socket.basic.assign-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.assign-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.</p></div></div><div class='para' id='socket.basic.assign-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.assign-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This assignment operator shall not participate in overload resolution unless <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.
</p></div></div></div><div id='socket.basic.ops'><h3 ><a class='secnum' href='#socket.basic.ops' style='min-width:103pt'>18.6.4</a> <span class='texttt'>basic_socket</span> operations <a class='abbr_ref' href='socket.basic.ops'>[socket.basic.ops]</a></h3><p ><code class='itemdecl'>
executor_type get_executor() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The associated executor.
</p></div></div><p ><code class='itemdecl'>
native_handle_type native_handle();
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The native representation of this socket.
</p></div></div><p ><code class='itemdecl'>
void open(const protocol_type&amp; protocol);
void open(const protocol_type&amp; protocol, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Establishes the postcondition, as if by POSIX <span class='texttt'>socket(protocol.family(), protocol.type(), protocol.protocol())</span>.</p></div></div><div class='para' id='socket.basic.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.basic.ops-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-4.1'>(4.1)</a></div><p ><span class='texttt'>is_open() == true</span>.
</p></li><li id='socket.basic.ops-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-4.2'>(4.2)</a></div><p ><span class='texttt'>non_blocking() == false</span>.
</p></li><li id='socket.basic.ops-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-4.3'>(4.3)</a></div><p ><span class='texttt'>protocol_ == protocol</span>.
</p></li></ul></div></div><div class='para' id='socket.basic.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-5'>5</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.basic.ops-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-5.1'>(5.1)</a></div><p ><span class='texttt'>socket_errc::already_open</span> — if <span class='texttt'>is_open() == true</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
void assign(const protocol_type&amp; protocol,
            const native_handle_type&amp; native_socket);
void assign(const protocol_type&amp; protocol,
            const native_handle_type&amp; native_socket, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>native_socket</span> is a native handle to an open socket.</p></div></div><div class='para' id='socket.basic.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns the native socket handle to this socket object.</p></div></div><div class='para' id='socket.basic.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-8'>8</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.basic.ops-8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-8.1'>(8.1)</a></div><p ><span class='texttt'>is_open() == true</span>.
</p></li><li id='socket.basic.ops-8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-8.2'>(8.2)</a></div><p ><span class='texttt'>non_blocking() == false</span>.
</p></li><li id='socket.basic.ops-8.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-8.3'>(8.3)</a></div><p ><span class='texttt'>protocol_ == protocol</span>.
</p></li></ul></div></div><div class='para' id='socket.basic.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-9'>9</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.basic.ops-9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-9.1'>(9.1)</a></div><p ><span class='texttt'>socket_errc::already_open</span> — if <span class='texttt'>is_open() == true</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
bool is_open() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-10'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>bool</span> indicating whether this socket was opened by a previous call to <span class='texttt'>open</span> or <span class='texttt'>assign</span>.
</p></div></div><p ><code class='itemdecl'>
void close();
void close(error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-11'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>is_open()</span> is <span class='texttt'>true</span>, cancels all outstanding asynchronous operations associated with this socket, and establishes the postcondition as if by POSIX <span class='texttt'>close(native_handle())</span>. Completion handlers for canceled asynchronous operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='socket.basic.ops-12'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-12'>12</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_open() == false</span>.
</p></div></div><p ><code class='itemdecl'>
void cancel();
void cancel(error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-13'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Cancels all outstanding asynchronous operations associated with this socket. Completion handlers for canceled asynchronous operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='socket.basic.ops-14'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-14'>14</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.basic.ops-14.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-14.1'>(14.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li></ul></div></div><div class='para' id='socket.basic.ops-15'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-15'>15</a></div><div class='itemdescr'><p ><i>Remarks:</i> Does not block (C++Std &sect;<a href='../n4140/defns.block'>[defns.block]</a>) the calling thread pending completion of the canceled operations.
</p></div></div><p ><code class='itemdecl'>
template&lt;class SettableSocketOption&gt;
  void set_option(const SettableSocketOption&amp; option);
template&lt;class SettableSocketOption&gt;
  void set_option(const SettableSocketOption&amp; option, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-16'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets an option on this socket, as if by POSIX <span class='texttt'>setsockopt(native_handle(), option.level(protocol_), option.name(protocol_), option.data(protocol_), option.size(protocol_))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class GettableSocketOption&gt;
  void get_option(GettableSocketOption&amp; option);
template&lt;class GettableSocketOption&gt;
  void get_option(GettableSocketOption&amp; option, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-17'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-17'>17</a></div><div class='itemdescr'><p ><i>Effects:</i> Gets an option from this socket, as if by POSIX:
</p><pre class='codeblock'>
socklen_t option_len = option.size(protocol_);
int result = getsockopt(native_handle(), option.level(protocol_),
                        option.name(protocol_), option.data(protocol_),
                        &amp;option_len);
if (result == 0)
  option.resize(option_len);
</pre></div></div><p ><code class='itemdecl'>
template&lt;class IoControlCommand&gt;
  void io_control(IoControlCommand&amp; command);
template&lt;class IoControlCommand&gt;
  void io_control(IoControlCommand&amp; command, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-18'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-18'>18</a></div><div class='itemdescr'><p ><i>Effects:</i> Executes an I/O control command on this socket, as if by POSIX <span class='texttt'>ioctl(native_handle(), command.name(), command.data())</span>.
</p></div></div><p ><code class='itemdecl'>
void non_blocking(bool mode);
void non_blocking(bool mode, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-19'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets the non-blocking mode of this socket. The non-blocking mode determines whether subsequent synchronous socket operations (<a href='socket.reqmts.sync'>[socket.reqmts.sync]</a>) on <span class='texttt'>*this</span> block the calling thread.</p></div></div><div class='para' id='socket.basic.ops-20'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-20'>20</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.basic.ops-20.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-20.1'>(20.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li></ul></div></div><div class='para' id='socket.basic.ops-21'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-21'>21</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>non_blocking() == mode</span>.</p></div></div><div class='para' id='socket.basic.ops-22'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-22'>22</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The non-blocking mode has no effect on the behavior of asynchronous operations. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><code class='itemdecl'>
bool non_blocking() const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-23'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-23'>23</a></div><div class='itemdescr'><p ><i>Returns:</i> The non-blocking mode of this socket.
</p></div></div><p ><code class='itemdecl'>
void native_non_blocking(bool mode);
void native_non_blocking(bool mode, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-24'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-24'>24</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets the non-blocking mode of the underlying native socket, as if by POSIX:
</p><pre class='codeblock'>
int flags = fcntl(native_handle(), F_GETFL, 0);
if (flags &gt;= 0){
  if (mode)
    flags |= O_NONBLOCK;
  else
    flags &amp;= ~O_NONBLOCK;
  fcntl(native_handle(), F_SETFL, flags);
}
</pre></div></div><div class='para' id='socket.basic.ops-25'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-25'>25</a></div><div class='itemdescr'><p >The native non-blocking mode has no effect on the behavior of the synchronous or asynchronous operations specified in this clause.</p></div></div><div class='para' id='socket.basic.ops-26'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-26'>26</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.basic.ops-26.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-26.1'>(26.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li><li id='socket.basic.ops-26.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-26.2'>(26.2)</a></div><p ><span class='texttt'>errc::invalid_argument</span> — if <span class='texttt'>mode == false</span> and <span class='texttt'>non_blocking() == true</span>. [&nbsp;<i>Note:</i> As the combination does not make sense. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div></div><p ><code class='itemdecl'>
bool native_non_blocking() const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-27'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-27'>27</a></div><div class='itemdescr'><p ><i>Returns:</i> The non-blocking mode of the underlying native socket.</p></div></div><div class='para' id='socket.basic.ops-28'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-28'>28</a></div><div class='itemdescr'><p ><i>Remarks:</i> Implementations are permitted and encouraged to cache the native non-blocking mode that was applied through a prior call to <span class='texttt'>native_non_blocking</span>. Implementations may return an incorrect value if a program sets the non-blocking mode directly on the socket, by calling an operating system-specific function on the result of <span class='texttt'>native_handle()</span>.
</p></div></div><p ><code class='itemdecl'>
bool at_mark() const;
bool at_mark(error_code&amp; ec) const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-29'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-29'>29</a></div><div class='itemdescr'><p ><i>Effects:</i> Determines if this socket is at the out-of-band data mark, as if by POSIX <span class='texttt'>sockatmark(native_handle())</span>. [&nbsp;<i>Note:</i> The <span class='texttt'>at_mark()</span> function must be used in conjunction with the <span class='texttt'>socket_base::out_of_band_inline</span> socket option. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='socket.basic.ops-30'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-30'>30</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>bool</span> indicating whether this socket is at the out-of-band data mark. <span class='texttt'>false</span> if an error occurs.
</p></div></div><p ><code class='itemdecl'>
size_t available() const;
size_t available(error_code&amp; ec) const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-31'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-31'>31</a></div><div class='itemdescr'><p ><i>Returns:</i> An indication of the number of bytes that may be read without blocking, or <span class='texttt'>0</span> if an error occurs.</p></div></div><div class='para' id='socket.basic.ops-32'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-32'>32</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.basic.ops-32.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-32.1'>(32.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
void bind(const endpoint_type&amp; endpoint);
void bind(const endpoint_type&amp; endpoint, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-33'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-33'>33</a></div><div class='itemdescr'><p ><i>Effects:</i> Binds this socket to the specified local endpoint, as if by POSIX <span class='texttt'>bind(native_handle(), endpoint.data(), endpoint.size())</span>.
</p></div></div><p ><code class='itemdecl'>
void shutdown(shutdown_type what);
void shutdown(shutdown_type what, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-34'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-34'>34</a></div><div class='itemdescr'><p ><i>Effects:</i> Shuts down all or part of a full-duplex connection for the socket, as if by POSIX <span class='texttt'>shutdown(native_handle(), static_cast&lt;int&gt;(what))</span>.
</p></div></div><p ><code class='itemdecl'>
endpoint_type local_endpoint() const;
endpoint_type local_endpoint(error_code&amp; ec) const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-35'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-35'>35</a></div><div class='itemdescr'><p ><i>Effects:</i> Determines the locally-bound endpoint associated with the socket, as if by POSIX:
</p><pre class='codeblock'>
endpoint_type endpoint;
socklen_t endpoint_len = endpoint.capacity();
int result = getsockname(native_handle(), endpoint.data(), &amp;endpoint_len);
if (result == 0)
  endpoint.resize(endpoint_len);
</pre></div></div><div class='para' id='socket.basic.ops-36'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-36'>36</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, <span class='texttt'>endpoint</span>. Otherwise <span class='texttt'>endpoint_type()</span>.
</p></div></div><p ><code class='itemdecl'>
endpoint_type remote_endpoint() const;
endpoint_type remote_endpoint(error_code&amp; ec) const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-37'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-37'>37</a></div><div class='itemdescr'><p ><i>Effects:</i> Determines the remote endpoint associated with this socket, as if by POSIX:
</p><pre class='codeblock'>
endpoint_type endpoint;
socklen_t endpoint_len = endpoint.capacity();
int result = getpeername(native_handle(), endpoint.data(), &amp;endpoint_len);
if (result == 0)
  endpoint.resize(endpoint_len);
</pre></div></div><div class='para' id='socket.basic.ops-38'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-38'>38</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, <span class='texttt'>endpoint</span>. Otherwise <span class='texttt'>endpoint_type()</span>.
</p></div></div><p ><code class='itemdecl'>
void connect(const endpoint_type&amp; endpoint);
void connect(const endpoint_type&amp; endpoint, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-39'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-39'>39</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>, opens this socket by performing <span class='texttt'>open(endpoint.protocol(), ec)</span>. If <span class='texttt'>ec</span>, returns with no further action. Connects this socket to the specified remote endpoint, as if by POSIX <span class='texttt'>connect(native_handle(), endpoint.data(), endpoint.size())</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_connect(const endpoint_type&amp; endpoint, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-40'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-40'>40</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec)</span>.</p></div></div><div class='para' id='socket.basic.ops-41'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-41'>41</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>, opens this socket by performing <span class='texttt'>open(endpoint.protocol(), ec)</span>. If <span class='texttt'>ec</span>, the operation completes immediately with no further action. Initiates an asynchronous operation to connect this socket to the specified remote endpoint, as if by POSIX <span class='texttt'>connect(native_handle(), endpoint.data(), endpoint.size())</span>.</p></div></div><div class='para' id='socket.basic.ops-42'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-42'>42</a></div><div class='itemdescr'><p >When an asynchronous connect operation on this socket is simultaneously outstanding with another asynchronous connect, read, or write operation on this socket, the behavior is undefined.</p></div></div><div class='para' id='socket.basic.ops-43'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-43'>43</a></div><div class='itemdescr'><p >If a program performs a synchronous operation on this socket, other than <span class='texttt'>close</span> or <span class='texttt'>cancel</span>, while there is an outstanding asynchronous connect operation, the behavior is undefined.
</p></div></div><p ><code class='itemdecl'>
void wait(wait_type w);
void wait(wait_type w, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-44'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-44'>44</a></div><div class='itemdescr'><p ><i>Effects:</i> Waits for this socket to be ready to read, ready to write, or to have error conditions pending, as if by POSIX <span class='texttt'>poll</span>.</p></div></div><div class='para' id='socket.basic.ops-45'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-45'>45</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.basic.ops-45.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-45.1'>(45.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_wait(wait_type w, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.basic.ops-46'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-46'>46</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec)</span>.</p></div></div><div class='para' id='socket.basic.ops-47'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-47'>47</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to wait for this socket to be ready to read, ready to write, or to have error conditions pending, as if by POSIX <span class='texttt'>poll</span>.</p></div></div><div class='para' id='socket.basic.ops-48'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-48'>48</a></div><div class='itemdescr'><p >When there are multiple outstanding asynchronous wait operations on this socket with the same <span class='texttt'>wait_type</span> value, all of these operations complete when this socket enters the corresponding ready state. The order of invocation of the completion handlers for these operations is unspecified.</p></div></div><div class='para' id='socket.basic.ops-49'><div class='marginalizedparent'><a class='marginalized' href='#socket.basic.ops-49'>49</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.basic.ops-49.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.basic.ops-49.1'>(49.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='basic_datagram_socket'></a></span></p></div></div><div id='socket.dgram'><h2 ><a class='secnum' href='#socket.dgram' style='min-width:88pt'>18.7</a> Class template <span class='texttt'>basic_datagram_socket</span> <a class='abbr_ref' href='socket.dgram'>[socket.dgram]</a></h2><div class='para' id='socket.dgram-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram-1'>1</a></div><p >The class template <span class='texttt'>basic_datagram_socket&lt;Protocol&gt;</span> is used to send and receive discrete messages of fixed maximum length.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Protocol&gt;
  class basic_datagram_socket : public basic_socket&lt;Protocol&gt;
  {
  public:
    <span class='comment'>// types:
</span>
    using native_handle_type = <i>implementation defined</i>; <span class='comment'>// see <a href='socket.reqmts.native'>[socket.reqmts.native]</a>
</span>    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;

    <span class='comment'>// construct / copy / destroy:
</span>
    explicit basic_datagram_socket(io_context&amp; ctx);
    basic_datagram_socket(io_context&amp; ctx, const protocol_type&amp; protocol);
    basic_datagram_socket(io_context&amp; ctx, const endpoint_type&amp; endpoint);
    basic_datagram_socket(io_context&amp; ctx, const protocol_type&amp; protocol,
                          const native_handle_type&amp; native_socket);
    basic_datagram_socket(const basic_datagram_socket&amp;) = delete;
    basic_datagram_socket(basic_datagram_socket&amp;&amp; rhs);
    template&lt;class OtherProtocol&gt;
      basic_datagram_socket(basic_datagram_socket&lt;OtherProtocol&gt;&amp;&amp; rhs);

    ~basic_datagram_socket();

    basic_datagram_socket&amp; operator=(const basic_datagram_socket&amp;) = delete;
    basic_datagram_socket&amp; operator=(basic_datagram_socket&amp;&amp; rhs);
    template&lt;class OtherProtocol&gt;
      basic_datagram_socket&amp; operator=(basic_datagram_socket&lt;OtherProtocol&gt;&amp;&amp; rhs);

    <span class='comment'>// basic_datagram_socket operations:
</span>
    template&lt;class MutableBufferSequence&gt;
      size_t receive(const MutableBufferSequence&amp; buffers);
    template&lt;class MutableBufferSequence&gt;
      size_t receive(const MutableBufferSequence&amp; buffers,
                     error_code&amp; ec);

    template&lt;class MutableBufferSequence&gt;
      size_t receive(const MutableBufferSequence&amp; buffers,
                     socket_base::message_flags flags);
    template&lt;class MutableBufferSequence&gt;
      size_t receive(const MutableBufferSequence&amp; buffers,
                     socket_base::message_flags flags, error_code&amp; ec);

    template&lt;class MutableBufferSequence, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_receive(const MutableBufferSequence&amp; buffers,
                            CompletionToken&amp;&amp; token);

    template&lt;class MutableBufferSequence, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_receive(const MutableBufferSequence&amp; buffers,
                            socket_base::message_flags flags,
                            CompletionToken&amp;&amp; token);

    template&lt;class MutableBufferSequence&gt;
      size_t receive_from(const MutableBufferSequence&amp; buffers,
                          endpoint_type&amp; sender);
    template&lt;class MutableBufferSequence&gt;
      size_t receive_from(const MutableBufferSequence&amp; buffers,
                          endpoint_type&amp; sender, error_code&amp; ec);

    template&lt;class MutableBufferSequence&gt;
      size_t receive_from(const MutableBufferSequence&amp; buffers,
                          endpoint_type&amp; sender,
                          socket_base::message_flags flags);
    template&lt;class MutableBufferSequence&gt;
      size_t receive_from(const MutableBufferSequence&amp; buffers,
                          endpoint_type&amp; sender,
                          socket_base::message_flags flags,
                          error_code&amp; ec);

    template&lt;class MutableBufferSequence, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_receive_from(const MutableBufferSequence&amp; buffers,
                                 endpoint_type&amp; sender,
                                 CompletionToken&amp;&amp; token);

    template&lt;class MutableBufferSequence, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_receive_from(const MutableBufferSequence&amp; buffers,
                                 endpoint_type&amp; sender,
                                 socket_base::message_flags flags,
                                 CompletionToken&amp;&amp; token);

    template&lt;class ConstBufferSequence&gt;
      size_t send(const ConstBufferSequence&amp; buffers);
    template&lt;class ConstBufferSequence&gt;
      size_t send(const ConstBufferSequence&amp; buffers, error_code&amp; ec);

    template&lt;class ConstBufferSequence&gt;
      size_t send(const ConstBufferSequence&amp; buffers,
                  socket_base::message_flags flags);
    template&lt;class ConstBufferSequence&gt;
      size_t send(const ConstBufferSequence&amp; buffers,
                  socket_base::message_flags flags, error_code&amp; ec);

    template&lt;class ConstBufferSequence, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_send(const ConstBufferSequence&amp; buffers,
                         CompletionToken&amp;&amp; token);

    template&lt;class ConstBufferSequence, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_send(const ConstBufferSequence&amp; buffers,
                         socket_base::message_flags flags,
                         CompletionToken&amp;&amp; token);

    template&lt;class ConstBufferSequence&gt;
      size_t send_to(const ConstBufferSequence&amp; buffers,
                     const endpoint_type&amp; recipient);
    template&lt;class ConstBufferSequence&gt;
      size_t send_to(const ConstBufferSequence&amp; buffers,
                     const endpoint_type&amp; recipient, error_code&amp; ec);

    template&lt;class ConstBufferSequence&gt;
      size_t send_to(const ConstBufferSequence&amp; buffers,
                     const endpoint_type&amp; recipient,
                     socket_base::message_flags flags);
    template&lt;class ConstBufferSequence&gt;
      size_t send_to(const ConstBufferSequence&amp; buffers,
                     const endpoint_type&amp; recipient,
                     socket_base::message_flags flags, error_code&amp; ec);

    template&lt;class ConstBufferSequence, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_send_to(const ConstBufferSequence&amp; buffers,
                            const endpoint_type&amp; recipient,
                            CompletionToken&amp;&amp; token);

    template&lt;class ConstBufferSequence, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_send_to(const ConstBufferSequence&amp; buffers,
                            const endpoint_type&amp; recipient,
                            socket_base::message_flags flags,
                            CompletionToken&amp;&amp; token);
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='socket.dgram-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram-2'>2</a></div><p >Instances of class template <span class='texttt'>basic_datagram_socket</span> meet the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), and <span class='texttt'>MoveAssignable</span> (C++Std &sect;<a href='../n4140/moveassignable'>[moveassignable]</a>).</p></div><div class='para' id='socket.dgram-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram-3'>3</a></div><p >If a program performs a synchronous operation on this socket, other than <span class='texttt'>close</span>, <span class='texttt'>cancel</span>, <span class='texttt'>shutdown</span>, <span class='texttt'>send</span>, or <span class='texttt'>send_to</span>, while there is an outstanding asynchronous read operation, the behavior is undefined.</p></div><div class='para' id='socket.dgram-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram-4'>4</a></div><p >If a program performs a synchronous operation on this socket, other than <span class='texttt'>close</span>, <span class='texttt'>cancel</span>, <span class='texttt'>shutdown</span>, <span class='texttt'>receive</span>, or <span class='texttt'>receive_from</span>, while there is an outstanding asynchronous write operation, the behavior is undefined.</p></div><div class='para' id='socket.dgram-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram-5'>5</a></div><p >When an operation has its effects specified as if by passing the result of <span class='texttt'>native_handle()</span> to a POSIX function, then the operation fails with error condition <span class='texttt'>errc::bad_file_descriptor</span> if <span class='texttt'>is_open() == false</span> at the point in the effects when the POSIX function is called.</p></div><div id='socket.dgram.cons'><h3 ><a class='secnum' href='#socket.dgram.cons' style='min-width:103pt'>18.7.1</a> <span class='texttt'>basic_datagram_socket</span> constructors <a class='abbr_ref' href='socket.dgram.cons'>[socket.dgram.cons]</a></h3><p ><code class='itemdecl'>
explicit basic_datagram_socket(io_context&amp; ctx);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the base class with <span class='texttt'>basic_socket&lt;Protocol&gt;(ctx)</span>.
</p></div></div><p ><code class='itemdecl'>
basic_datagram_socket(io_context&amp; ctx, const protocol_type&amp; protocol);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the base class with <span class='texttt'>basic_socket&lt;Protocol&gt;(ctx, protocol)</span>.
</p></div></div><p ><code class='itemdecl'>
basic_datagram_socket(io_context&amp; ctx, const endpoint_type&amp; endpoint);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the base class with <span class='texttt'>basic_socket&lt;Protocol&gt;(ctx, endpoint)</span>.
</p></div></div><p ><code class='itemdecl'>
basic_datagram_socket(io_context&amp; ctx, const protocol_type&amp; protocol,
                      const native_handle_type&amp; native_socket);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the base class with <span class='texttt'>basic_socket&lt;Protocol&gt;(ctx, protocol, native_socket)</span>.
</p></div></div><p ><code class='itemdecl'>
basic_datagram_socket(basic_datagram_socket&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs an object of class <span class='texttt'>basic_datagram_socket&lt;Protocol&gt;</span>, initializing the base class with <span class='texttt'>basic_socket&lt;Protocol&gt;(std::move(rhs))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class OtherProtocol&gt;
  basic_datagram_socket(basic_datagram_socket&lt;OtherProtocol&gt;&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.cons-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.</p></div></div><div class='para' id='socket.dgram.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.cons-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs an object of class <span class='texttt'>basic_datagram_socket&lt;Protocol&gt;</span>, initializing the base class with <span class='texttt'>basic_socket&lt;Protocol&gt;(std::move(rhs))</span>.</p></div></div><div class='para' id='socket.dgram.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.cons-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This constructor shall not participate in overload resolution unless <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.
</p></div></div></div><div id='socket.dgram.assign'><h3 ><a class='secnum' href='#socket.dgram.assign' style='min-width:103pt'>18.7.2</a> <span class='texttt'>basic_datagram_socket</span> assignment <a class='abbr_ref' href='socket.dgram.assign'>[socket.dgram.assign]</a></h3><p ><code class='itemdecl'>
basic_datagram_socket&amp; operator=(basic_datagram_socket&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>basic_socket&lt;Protocol&gt;::operator=(std::move(rhs))</span>.</p></div></div><div class='para' id='socket.dgram.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class OtherProtocol&gt;
  basic_datagram_socket&amp; operator=(basic_datagram_socket&lt;OtherProtocol&gt;&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.assign-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.</p></div></div><div class='para' id='socket.dgram.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.assign-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>basic_socket&lt;Protocol&gt;::operator=(std::move(rhs))</span>.</p></div></div><div class='para' id='socket.dgram.assign-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.assign-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.</p></div></div><div class='para' id='socket.dgram.assign-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.assign-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i> This assignment operator shall not participate in overload resolution unless <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.
</p></div></div></div><div id='socket.dgram.op'><h3 ><a class='secnum' href='#socket.dgram.op' style='min-width:103pt'>18.7.3</a> <span class='texttt'>basic_datagram_socket</span> operations <a class='abbr_ref' href='socket.dgram.op'>[socket.dgram.op]</a></h3><p ><code class='itemdecl'>
template&lt;class MutableBufferSequence&gt;
  size_t receive(const MutableBufferSequence&amp; buffers);
template&lt;class MutableBufferSequence&gt;
  size_t receive(const MutableBufferSequence&amp; buffers,
                 error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>receive(buffers, socket_base::message_flags(), ec)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class MutableBufferSequence&gt;
  size_t receive(const MutableBufferSequence&amp; buffers,
                 socket_base::message_flags flags);
template&lt;class MutableBufferSequence&gt;
  size_t receive(const MutableBufferSequence&amp; buffers,
                 socket_base::message_flags flags, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-2'>2</a></div><div class='itemdescr'><p >A read operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='socket.dgram.op-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an array <span class='texttt'>iov</span> of POSIX type <span class='texttt'>struct iovec</span> and length <span class='texttt'>iovlen</span>, corresponding to <span class='texttt'>buffers</span>, and reads data from this socket as if by POSIX:
</p><pre class='codeblock'>
msghdr message;
message.msg_name = nullptr;
message.msg_namelen = 0;
message.msg_iov = iov;
message.msg_iovlen = iovlen;
message.msg_control = nullptr;
message.msg_controllen = 0;
message.msg_flags = 0;
recvmsg(native_handle(), &amp;message, static_cast&lt;int&gt;(flags));
</pre></div></div><div class='para' id='socket.dgram.op-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, the number of bytes received. Otherwise <span class='texttt'>0</span>.</p></div></div><div class='para' id='socket.dgram.op-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-5'>5</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> This operation may be used with connection-mode or connectionless-mode sockets, but it is normally used with connection-mode sockets because it does not permit the application to retrieve the source endpoint of received data. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><code class='itemdecl'>
template&lt;class MutableBufferSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_receive(const MutableBufferSequence&amp; buffers,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>async_receive(buffers, socket_base::message_flags(), std::forward&lt;CompletionToken&gt;(token))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class MutableBufferSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_receive(const MutableBufferSequence&amp; buffers,
                        socket_base::message_flags flags,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-7'>7</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='socket.dgram.op-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to read data from this socket. Constructs an array <span class='texttt'>iov</span> of POSIX type <span class='texttt'>struct iovec</span> and length <span class='texttt'>iovlen</span>, corresponding to <span class='texttt'>buffers</span>, then reads data as if by POSIX:
</p><pre class='codeblock'>
msghdr message;
message.msg_name = nullptr;
message.msg_namelen = 0;
message.msg_iov = iov;
message.msg_iovlen = iovlen;
message.msg_control = nullptr;
message.msg_controllen = 0;
message.msg_flags = 0;
recvmsg(native_handle(), &amp;message, static_cast&lt;int&gt;(flags));
</pre></div></div><div class='para' id='socket.dgram.op-9'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-9'>9</a></div><div class='itemdescr'><p >If the operation completes successfully, <span class='texttt'>n</span> is the number of bytes received. Otherwise <span class='texttt'>n</span> is <span class='texttt'>0</span>.</p></div></div><div class='para' id='socket.dgram.op-10'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-10'>10</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> This operation may be used with connection-mode or connectionless-mode sockets, but it is normally used with connection-mode sockets because it does not permit the application to retrieve the source endpoint of received data. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='socket.dgram.op-11'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-11'>11</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.dgram.op-11.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.dgram.op-11.1'>(11.1)</a></div><p ><span class='texttt'>errc::invalid_argument</span> — if <span class='texttt'>socket_base::message_peek</span> is set in flags.
</p></li></ul></div></div><p ><code class='itemdecl'>
template&lt;class MutableBufferSequence&gt;
  size_t receive_from(const MutableBufferSequence&amp; buffers,
                      endpoint_type&amp; sender);
template&lt;class MutableBufferSequence&gt;
  size_t receive_from(const MutableBufferSequence&amp; buffers,
                      endpoint_type&amp; sender, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-12'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>receive_from(buffers, sender, socket_base::message_flags(), ec)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class MutableBufferSequence&gt;
  size_t receive_from(const MutableBufferSequence&amp; buffers,
                      endpoint_type&amp; sender,
                      socket_base::message_flags flags);
template&lt;class MutableBufferSequence&gt;
  size_t receive_from(const MutableBufferSequence&amp; buffers,
                      endpoint_type&amp; sender,
                      socket_base::message_flags flags,
                      error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-13'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-13'>13</a></div><div class='itemdescr'><p >A read operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='socket.dgram.op-14'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an array <span class='texttt'>iov</span> of POSIX type <span class='texttt'>struct iovec</span> and length <span class='texttt'>iovlen</span>, corresponding to <span class='texttt'>buffers</span>, and reads data from this socket as if by POSIX:
</p><pre class='codeblock'>
msghdr message;
message.msg_name = sender.data();
message.msg_namelen = sender.capacity();
message.msg_iov = iov;
message.msg_iovlen = iovlen;
message.msg_control = nullptr;
message.msg_controllen = 0;
message.msg_flags = 0;
ssize_t result = recvmsg(native_handle(), &amp;message, static_cast&lt;int&gt;(flags));
if (result &gt;= 0)
  sender.resize(message.msg_namelen);
</pre></div></div><div class='para' id='socket.dgram.op-15'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, the number of bytes received. Otherwise <span class='texttt'>0</span>.</p></div></div><div class='para' id='socket.dgram.op-16'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-16'>16</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> This operation may be used with connection-mode or connectionless-mode sockets, but it is normally used with connectionless-mode sockets because it permits the application to retrieve the source endpoint of received data. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><code class='itemdecl'>
template&lt;class MutableBufferSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_receive_from(const MutableBufferSequence&amp; buffers,
                             endpoint_type&amp; sender,
                             CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-17'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-17'>17</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>async_receive_from(buffers, sender, socket_base::message_flags(), forward&lt;CompletionToken&gt;(token))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class MutableBufferSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_receive_from(const MutableBufferSequence&amp; buffers,
                             endpoint_type&amp; sender,
                             socket_base::message_flags flags,
                             CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-18'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-18'>18</a></div><div class='itemdescr'><p >A read operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='socket.dgram.op-19'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-19'>19</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='socket.dgram.op-20'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to read data from this socket. Constructs an array <span class='texttt'>iov</span> of POSIX type <span class='texttt'>struct iovec</span> and length <span class='texttt'>iovlen</span>, corresponding to <span class='texttt'>buffers</span>, then reads data as if by POSIX:
</p><pre class='codeblock'>
msghdr message;
message.msg_name = sender.data();
message.msg_namelen = sender.capacity();
message.msg_iov = iov;
message.msg_iovlen = iovlen;
message.msg_control = nullptr;
message.msg_controllen = 0;
message.msg_flags = 0;
ssize_t result = recvmsg(native_handle(), &amp;message, static_cast&lt;int&gt;(flags));
if (result &gt;= 0)
  sender.resize(message.msg_namelen);
</pre></div></div><div class='para' id='socket.dgram.op-21'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-21'>21</a></div><div class='itemdescr'><p >If the operation completes successfully, <span class='texttt'>n</span> is the number of bytes received. Otherwise <span class='texttt'>n</span> is <span class='texttt'>0</span>.</p></div></div><div class='para' id='socket.dgram.op-22'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-22'>22</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> This operation may be used with connection-mode or connectionless-mode sockets, but it is normally used with connectionless-mode sockets because it permits the application to retrieve the source endpoint of received data. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='socket.dgram.op-23'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-23'>23</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.dgram.op-23.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.dgram.op-23.1'>(23.1)</a></div><p ><span class='texttt'>errc::invalid_argument</span> — if <span class='texttt'>socket_base::message_peek</span> is set in flags.
</p></li></ul></div></div><p ><code class='itemdecl'>
template&lt;class ConstBufferSequence&gt;
  size_t send(const ConstBufferSequence&amp; buffers);
template&lt;class ConstBufferSequence&gt;
  size_t send(const ConstBufferSequence&amp; buffers, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-24'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-24'>24</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>send(buffers, socket_base::message_flags(), ec)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ConstBufferSequence&gt;
  size_t send(const ConstBufferSequence&amp; buffers,
              socket_base::message_flags flags);
template&lt;class ConstBufferSequence&gt;
  size_t send(const ConstBufferSequence&amp; buffers,
              socket_base::message_flags flags, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-25'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-25'>25</a></div><div class='itemdescr'><p >A write operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='socket.dgram.op-26'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-26'>26</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an array <span class='texttt'>iov</span> of POSIX type <span class='texttt'>struct iovec</span> and length <span class='texttt'>iovlen</span>, corresponding to <span class='texttt'>buffers</span>, and writes data to this socket as if by POSIX:
</p><pre class='codeblock'>
msghdr message;
message.msg_name = nullptr;
message.msg_namelen = 0;
message.msg_iov = iov;
message.msg_iovlen = iovlen;
message.msg_control = nullptr;
message.msg_controllen = 0;
message.msg_flags = 0;
sendmsg(native_handle(), &amp;message, static_cast&lt;int&gt;(flags));
</pre></div></div><div class='para' id='socket.dgram.op-27'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-27'>27</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, the number of bytes sent. Otherwise <span class='texttt'>0</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ConstBufferSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_send(const ConstBufferSequence&amp; buffers, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-28'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-28'>28</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>async_send(buffers, socket_base::message_flags(), forward&lt;CompletionToken&gt;(token))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ConstBufferSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_send(const ConstBufferSequence&amp; buffers,
                     socket_base::message_flags flags,
                     CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-29'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-29'>29</a></div><div class='itemdescr'><p >A write operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='socket.dgram.op-30'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-30'>30</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='socket.dgram.op-31'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-31'>31</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to write data to this socket. Constructs an array <span class='texttt'>iov</span> of POSIX type <span class='texttt'>struct iovec</span> and length <span class='texttt'>iovlen</span>, corresponding to <span class='texttt'>buffers</span>, then writes data as if by POSIX:
</p><pre class='codeblock'>
msghdr message;
message.msg_name = nullptr;
message.msg_namelen = 0;
message.msg_iov = iov;
message.msg_iovlen = iovlen;
message.msg_control = nullptr;
message.msg_controllen = 0;
message.msg_flags = 0;
sendmsg(native_handle(), &amp;message, static_cast&lt;int&gt;(flags));
</pre></div></div><div class='para' id='socket.dgram.op-32'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-32'>32</a></div><div class='itemdescr'><p >If the operation completes successfully, <span class='texttt'>n</span> is the number of bytes sent. Otherwise <span class='texttt'>n</span> is <span class='texttt'>0</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ConstBufferSequence&gt;
  size_t send_to(const ConstBufferSequence&amp; buffers,
                 const endpoint_type&amp; recipient);
template&lt;class ConstBufferSequence&gt;
  size_t send_to(const ConstBufferSequence&amp; buffers,
                 const endpoint_type&amp; recipient, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-33'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-33'>33</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>send_to(buffers, recipient, socket_base::message_flags(), ec)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ConstBufferSequence&gt;
  size_t send_to(const ConstBufferSequence&amp; buffers,
                 const endpoint_type&amp; recipient,
                 socket_base::message_flags flags);
template&lt;class ConstBufferSequence&gt;
  size_t send_to(const ConstBufferSequence&amp; buffers,
                 const endpoint_type&amp; recipient,
                 socket_base::message_flags flags, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-34'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-34'>34</a></div><div class='itemdescr'><p >A write operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='socket.dgram.op-35'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-35'>35</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an array <span class='texttt'>iov</span> of POSIX type <span class='texttt'>struct iovec</span> and length <span class='texttt'>iovlen</span>, corresponding to <span class='texttt'>buffers</span>, and writes data to this socket as if by POSIX:
</p><pre class='codeblock'>
msghdr message;
message.msg_name = recipient.data();
message.msg_namelen = recipient.size();
message.msg_iov = iov;
message.msg_iovlen = iovlen;
message.msg_control = nullptr;
message.msg_controllen = 0;
message.msg_flags = 0;
sendmsg(native_handle(), &amp;message, static_cast&lt;int&gt;(flags));
</pre></div></div><div class='para' id='socket.dgram.op-36'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-36'>36</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, the number of bytes sent. Otherwise <span class='texttt'>0</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ConstBufferSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_send_to(const ConstBufferSequence&amp; buffers,
                        const endpoint_type&amp; recipient,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-37'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-37'>37</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>async_send_to(buffers, recipient, socket_base::message_flags(), forward&lt;CompletionToken&gt;(token))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ConstBufferSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_send_to(const ConstBufferSequence&amp; buffers,
                        const endpoint_type&amp; recipient,
                        socket_base::message_flags flags,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.dgram.op-38'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-38'>38</a></div><div class='itemdescr'><p >A write operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='socket.dgram.op-39'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-39'>39</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='socket.dgram.op-40'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-40'>40</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to write data to this socket. Constructs an array <span class='texttt'>iov</span> of POSIX type <span class='texttt'>struct iovec</span> and length <span class='texttt'>iovlen</span>, corresponding to <span class='texttt'>buffers</span>, then writes data as if by POSIX:
</p><pre class='codeblock'>
msghdr message;
message.msg_name = recipient.data();
message.msg_namelen = recipient.size();
message.msg_iov = iov;
message.msg_iovlen = iovlen;
message.msg_control = nullptr;
message.msg_controllen = 0;
message.msg_flags = 0;
sendmsg(native_handle(), &amp;message, static_cast&lt;int&gt;(flags));
</pre></div></div><div class='para' id='socket.dgram.op-41'><div class='marginalizedparent'><a class='marginalized' href='#socket.dgram.op-41'>41</a></div><div class='itemdescr'><p >If the operation completes successfully, <span class='texttt'>n</span> is the number of bytes sent. Otherwise <span class='texttt'>n</span> is <span class='texttt'>0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_stream_socket'></a></span></p></div></div><div id='socket.stream'><h2 ><a class='secnum' href='#socket.stream' style='min-width:88pt'>18.8</a> Class template <span class='texttt'>basic_stream_socket</span> <a class='abbr_ref' href='socket.stream'>[socket.stream]</a></h2><div class='para' id='socket.stream-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream-1'>1</a></div><p >The class template <span class='texttt'>basic_stream_socket&lt;Protocol&gt;</span> is used to exchange data with a peer over a sequenced, reliable, bidirectional, connection-mode byte stream.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Protocol&gt;
  class basic_stream_socket : public basic_socket&lt;Protocol&gt;
  {
  public:
    <span class='comment'>// types:
</span>
    using native_handle_type = <i>implementation defined</i>; <span class='comment'>// see <a href='socket.reqmts.native'>[socket.reqmts.native]</a>
</span>    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;

    <span class='comment'>// construct / copy / destroy:
</span>
    explicit basic_stream_socket(io_context&amp; ctx);
    basic_stream_socket(io_context&amp; ctx, const protocol_type&amp; protocol);
    basic_stream_socket(io_context&amp; ctx, const endpoint_type&amp; endpoint);
    basic_stream_socket(io_context&amp; ctx, const protocol_type&amp; protocol,
                        const native_handle_type&amp; native_socket);
    basic_stream_socket(const basic_stream_socket&amp;) = delete;
    basic_stream_socket(basic_stream_socket&amp;&amp; rhs);
    template&lt;class OtherProtocol&gt;
      basic_stream_socket(basic_stream_socket&lt;OtherProtocol&gt;&amp;&amp; rhs);

    ~basic_stream_socket();

    basic_stream_socket&amp; operator=(const basic_stream_socket&amp;) = delete;
    basic_stream_socket&amp; operator=(basic_stream_socket&amp;&amp; rhs);
    template&lt;class OtherProtocol&gt;
      basic_stream_socket&amp; operator=(basic_stream_socket&lt;OtherProtocol&gt;&amp;&amp; rhs);

    <span class='comment'>// basic_stream_socket operations:
</span>
    template&lt;class MutableBufferSequence&gt;
      size_t receive(const MutableBufferSequence&amp; buffers);
    template&lt;class MutableBufferSequence&gt;
      size_t receive(const MutableBufferSequence&amp; buffers,
                     error_code&amp; ec);

    template&lt;class MutableBufferSequence&gt;
      size_t receive(const MutableBufferSequence&amp; buffers,
                     socket_base::message_flags flags);
    template&lt;class MutableBufferSequence&gt;
      size_t receive(const MutableBufferSequence&amp; buffers,
                     socket_base::message_flags flags, error_code&amp; ec);

    template&lt;class MutableBufferSequence, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_receive(const MutableBufferSequence&amp; buffers,
                            CompletionToken&amp;&amp; token);

    template&lt;class MutableBufferSequence, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_receive(const MutableBufferSequence&amp; buffers,
                            socket_base::message_flags flags,
                            CompletionToken&amp;&amp; token);

    template&lt;class ConstBufferSequence&gt;
      size_t send(const ConstBufferSequence&amp; buffers);
    template&lt;class ConstBufferSequence&gt;
      size_t send(const ConstBufferSequence&amp; buffers, error_code&amp; ec);

    template&lt;class ConstBufferSequence&gt;
      size_t send(const ConstBufferSequence&amp; buffers,
                  socket_base::message_flags flags);
    template&lt;class ConstBufferSequence&gt;
      size_t send(const ConstBufferSequence&amp; buffers,
                  socket_base::message_flags flags, error_code&amp; ec);

    template&lt;class ConstBufferSequence, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_send(const ConstBufferSequence&amp; buffers,
                         CompletionToken&amp;&amp; token);

    template&lt;class ConstBufferSequence, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_send(const ConstBufferSequence&amp; buffers,
                         socket_base::message_flags flags,
                         CompletionToken&amp;&amp; token);

    template&lt;class MutableBufferSequence&gt;
      size_t read_some(const MutableBufferSequence&amp; buffers);
    template&lt;class MutableBufferSequence&gt;
      size_t read_some(const MutableBufferSequence&amp; buffers,
                       error_code&amp; ec);

    template&lt;class MutableBufferSequence, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_read_some(const MutableBufferSequence&amp; buffers,
                              CompletionToken&amp;&amp; token);

    template&lt;class ConstBufferSequence&gt;
      size_t write_some(const ConstBufferSequence&amp; buffers);
    template&lt;class ConstBufferSequence&gt;
      size_t write_some(const ConstBufferSequence&amp; buffers,
                        error_code&amp; ec);

    template&lt;class ConstBufferSequence, class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_write_some(const ConstBufferSequence&amp; buffers,
                               CompletionToken&amp;&amp; token);
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='socket.stream-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream-2'>2</a></div><p >Instances of class template <span class='texttt'>basic_stream_socket</span> meet the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), <span class='texttt'>MoveAssignable</span> (C++Std &sect;<a href='../n4140/moveassignable'>[moveassignable]</a>), <span class='texttt'>SyncReadStream</span> (<a href='buffer.stream.reqmts.syncreadstream'>[buffer.stream.reqmts.syncreadstream]</a>), <span class='texttt'>SyncWriteStream</span> (<a href='buffer.stream.reqmts.syncwritestream'>[buffer.stream.reqmts.syncwritestream]</a>), <span class='texttt'>AsyncReadStream</span> (<a href='buffer.stream.reqmts.asyncreadstream'>[buffer.stream.reqmts.asyncreadstream]</a>), and <span class='texttt'>AsyncWriteStream</span> (<a href='buffer.stream.reqmts.asyncwritestream'>[buffer.stream.reqmts.asyncwritestream]</a>).</p></div><div class='para' id='socket.stream-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream-3'>3</a></div><p >If a program performs a synchronous operation on this socket, other than <span class='texttt'>close</span>, <span class='texttt'>cancel</span>, <span class='texttt'>shutdown</span>, or <span class='texttt'>send</span>, while there is an outstanding asynchronous read operation, the behavior is undefined.</p></div><div class='para' id='socket.stream-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream-4'>4</a></div><p >If a program performs a synchronous operation on this socket, other than <span class='texttt'>close</span>, <span class='texttt'>cancel</span>, <span class='texttt'>shutdown</span>, or <span class='texttt'>receive</span>, while there is an outstanding asynchronous write operation, the behavior is undefined.</p></div><div class='para' id='socket.stream-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream-5'>5</a></div><p >When an operation has its effects specified as if by passing the result of <span class='texttt'>native_handle()</span> to a POSIX function, then the operation fails with error condition <span class='texttt'>errc::bad_file_descriptor</span> if <span class='texttt'>is_open() == false</span> at the point in the effects when the POSIX function is called.</p></div><div id='socket.stream.cons'><h3 ><a class='secnum' href='#socket.stream.cons' style='min-width:103pt'>18.8.1</a> <span class='texttt'>basic_stream_socket</span> constructors <a class='abbr_ref' href='socket.stream.cons'>[socket.stream.cons]</a></h3><p ><code class='itemdecl'>
explicit basic_stream_socket(io_context&amp; ctx);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the base class with <span class='texttt'>basic_socket&lt;Protocol&gt;(ctx)</span>.
</p></div></div><p ><code class='itemdecl'>
basic_stream_socket(io_context&amp; ctx, const protocol_type&amp; protocol);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the base class with <span class='texttt'>basic_socket&lt;Protocol&gt;(ctx, protocol)</span>.
</p></div></div><p ><code class='itemdecl'>
basic_stream_socket(io_context&amp; ctx, const endpoint_type&amp; endpoint);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the base class with <span class='texttt'>basic_socket&lt;Protocol&gt;(ctx, endpoint)</span>.
</p></div></div><p ><code class='itemdecl'>
basic_stream_socket(io_context&amp; ctx, const protocol_type&amp; protocol,
                      const native_handle_type&amp; native_socket);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the base class with <span class='texttt'>basic_socket&lt;Protocol&gt;(ctx, protocol, native_socket)</span>.
</p></div></div><p ><code class='itemdecl'>
basic_stream_socket(basic_stream_socket&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs an object of class <span class='texttt'>basic_stream_socket&lt;Protocol&gt;</span>, initializing the base class with <span class='texttt'>basic_socket&lt;Protocol&gt;(std::move(rhs))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class OtherProtocol&gt;
  basic_stream_socket(basic_stream_socket&lt;OtherProtocol&gt;&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.cons-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.</p></div></div><div class='para' id='socket.stream.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.cons-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs an object of class <span class='texttt'>basic_stream_socket&lt;Protocol&gt;</span>, initializing the base class with <span class='texttt'>basic_socket&lt;Protocol&gt;(std::move(rhs))</span>.</p></div></div><div class='para' id='socket.stream.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.cons-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This constructor shall not participate in overload resolution unless <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.
</p></div></div></div><div id='socket.stream.assign'><h3 ><a class='secnum' href='#socket.stream.assign' style='min-width:103pt'>18.8.2</a> <span class='texttt'>basic_stream_socket</span> assignment <a class='abbr_ref' href='socket.stream.assign'>[socket.stream.assign]</a></h3><p ><code class='itemdecl'>
basic_stream_socket&amp; operator=(basic_stream_socket&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>basic_socket&lt;Protocol&gt;::operator=(std::move(rhs))</span>.</p></div></div><div class='para' id='socket.stream.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class OtherProtocol&gt;
  basic_stream_socket&amp; operator=(basic_stream_socket&lt;OtherProtocol&gt;&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.assign-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.</p></div></div><div class='para' id='socket.stream.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.assign-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>basic_socket&lt;Protocol&gt;::operator=(std::move(rhs))</span>.</p></div></div><div class='para' id='socket.stream.assign-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.assign-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.</p></div></div><div class='para' id='socket.stream.assign-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.assign-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i> This assignment operator shall not participate in overload resolution unless <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.
</p></div></div></div><div id='socket.stream.ops'><h3 ><a class='secnum' href='#socket.stream.ops' style='min-width:103pt'>18.8.3</a> <span class='texttt'>basic_stream_socket</span> operations <a class='abbr_ref' href='socket.stream.ops'>[socket.stream.ops]</a></h3><p ><code class='itemdecl'>
template&lt;class MutableBufferSequence&gt;
  size_t receive(const MutableBufferSequence&amp; buffers);
template&lt;class MutableBufferSequence&gt;
  size_t receive(const MutableBufferSequence&amp; buffers,
                 error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>receive(buffers, socket_base::message_flags(), ec)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class MutableBufferSequence&gt;
  size_t receive(const MutableBufferSequence&amp; buffers,
                 socket_base::message_flags flags);
template&lt;class MutableBufferSequence&gt;
  size_t receive(const MutableBufferSequence&amp; buffers,
                 socket_base::message_flags flags, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-2'>2</a></div><div class='itemdescr'><p >A read operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='socket.stream.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>buffer_size(buffers) == 0</span>, returns immediately with no error. Otherwise, constructs an array <span class='texttt'>iov</span> of POSIX type <span class='texttt'>struct iovec</span> and length <span class='texttt'>iovlen</span>, corresponding to <span class='texttt'>buffers</span>, and reads data from this socket as if by POSIX:
</p><pre class='codeblock'>
msghdr message;
message.msg_name = nullptr;
message.msg_namelen = 0;
message.msg_iov = iov;
message.msg_iovlen = iovlen;
message.msg_control = nullptr;
message.msg_controllen = 0;
message.msg_flags = 0;
recvmsg(native_handle(), &amp;message, static_cast&lt;int&gt;(flags));
</pre></div></div><div class='para' id='socket.stream.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, the number of bytes received. Otherwise <span class='texttt'>0</span>.</p></div></div><div class='para' id='socket.stream.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-5'>5</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.stream.ops-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.stream.ops-5.1'>(5.1)</a></div><p ><span class='texttt'>stream_errc::eof</span> — if there is no data to be received and the peer performed an orderly shutdown.
</p></li></ul></div></div><p ><code class='itemdecl'>
template&lt;class MutableBufferSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_receive(const MutableBufferSequence&amp; buffers,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>async_receive(buffers, socket_base::message_flags(), forward&lt;CompletionToken&gt;(token))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class MutableBufferSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_receive(const MutableBufferSequence&amp; buffers,
                        socket_base::message_flags flags,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-7'>7</a></div><div class='itemdescr'><p >A read operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='socket.stream.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-8'>8</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='socket.stream.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to read data from this socket. If <span class='texttt'>buffer_size(buffers) == 0</span>, the asynchronous operation completes immediately with no error and <span class='texttt'>n == 0</span>. Otherwise, constructs an array <span class='texttt'>iov</span> of POSIX type <span class='texttt'>struct iovec</span> and length <span class='texttt'>iovlen</span>, corresponding to <span class='texttt'>buffers</span>, then reads data as if by POSIX:
</p><pre class='codeblock'>
msghdr message;
message.msg_name = nullptr;
message.msg_namelen = 0;
message.msg_iov = iov;
message.msg_iovlen = iovlen;
message.msg_control = nullptr;
message.msg_controllen = 0;
message.msg_flags = 0;
recvmsg(native_handle(), &amp;message, static_cast&lt;int&gt;(flags));
</pre></div></div><div class='para' id='socket.stream.ops-10'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-10'>10</a></div><div class='itemdescr'><p >If the operation completes successfully, <span class='texttt'>n</span> is the number of bytes received. Otherwise <span class='texttt'>n</span> is <span class='texttt'>0</span>.</p></div></div><div class='para' id='socket.stream.ops-11'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-11'>11</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.stream.ops-11.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.stream.ops-11.1'>(11.1)</a></div><p ><span class='texttt'>errc::invalid_argument</span> — if <span class='texttt'>socket_base::message_peek</span> is set in flags.
</p></li><li id='socket.stream.ops-11.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.stream.ops-11.2'>(11.2)</a></div><p ><span class='texttt'>stream_errc::eof</span> — if there is no data to be received and the peer performed an orderly shutdown.
</p></li></ul></div></div><p ><code class='itemdecl'>
template&lt;class ConstBufferSequence&gt;
  size_t send(const ConstBufferSequence&amp; buffers);
template&lt;class ConstBufferSequence&gt;
  size_t send(const ConstBufferSequence&amp; buffers, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.ops-12'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>send(buffers, socket_base::message_flags(), ec)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ConstBufferSequence&gt;
  size_t send(const ConstBufferSequence&amp; buffers,
              socket_base::message_flags flags);
template&lt;class ConstBufferSequence&gt;
  size_t send(const ConstBufferSequence&amp; buffers,
              socket_base::message_flags flags, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.ops-13'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-13'>13</a></div><div class='itemdescr'><p >A write operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='socket.stream.ops-14'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>buffer_size(buffers) == 0</span>, returns immediately with no error. Otherwise, constructs an array <span class='texttt'>iov</span> of POSIX type <span class='texttt'>struct iovec</span> and length <span class='texttt'>iovlen</span>, corresponding to <span class='texttt'>buffers</span>, and writes data to this socket as if by POSIX: 
</p><pre class='codeblock'>
msghdr message;
message.msg_name = nullptr;
message.msg_namelen = 0;
message.msg_iov = iov;
message.msg_iovlen = iovlen;
message.msg_control = nullptr;
message.msg_controllen = 0;
message.msg_flags = 0;
sendmsg(native_handle(), &amp;message, static_cast&lt;int&gt;(flags));
</pre></div></div><div class='para' id='socket.stream.ops-15'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, the number of bytes sent. Otherwise <span class='texttt'>0</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ConstBufferSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_send(const ConstBufferSequence&amp; buffers, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.ops-16'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>async_send(buffers, socket_base::message_flags(), forward&lt;CompletionToken&gt;(token))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ConstBufferSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_send(const ConstBufferSequence&amp; buffers,
                     socket_base::message_flags flags,
                     CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.ops-17'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-17'>17</a></div><div class='itemdescr'><p >A write operation (<a href='buffer.reqmts.read.write'>[buffer.reqmts.read.write]</a>).</p></div></div><div class='para' id='socket.stream.ops-18'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-18'>18</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, size_t n)</span>.</p></div></div><div class='para' id='socket.stream.ops-19'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to write data to this socket. If <span class='texttt'>buffer_size(buffers) == 0</span>, the asynchronous operation completes immediately with no error and <span class='texttt'>n == 0</span>. Otherwise, constructs an array <span class='texttt'>iov</span> of POSIX type <span class='texttt'>struct iovec</span> and length <span class='texttt'>iovlen</span>, corresponding to <span class='texttt'>buffers</span>, then writes data as if by POSIX:
</p><pre class='codeblock'>
msghdr message;
message.msg_name = nullptr;
message.msg_namelen = 0;
message.msg_iov = iov;
message.msg_iovlen = iovlen;
message.msg_control = nullptr;
message.msg_controllen = 0;
message.msg_flags = 0;
sendmsg(native_handle(), &amp;message, static_cast&lt;int&gt;(flags));
</pre></div></div><div class='para' id='socket.stream.ops-20'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-20'>20</a></div><div class='itemdescr'><p >If the operation completes successfully, <span class='texttt'>n</span> is the number of bytes sent. Otherwise <span class='texttt'>n</span> is <span class='texttt'>0</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class MutableBufferSequence&gt;
  size_t read_some(const MutableBufferSequence&amp; buffers);
template&lt;class MutableBufferSequence&gt;
  size_t read_some(const MutableBufferSequence&amp; buffers,
                   error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.ops-21'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-21'>21</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>receive(buffers, ec)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class MutableBufferSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_read_some(const MutableBufferSequence&amp; buffers,
                          CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.ops-22'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-22'>22</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>async_receive(buffers, forward&lt;CompletionToken&gt;(token))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ConstBufferSequence&gt;
  size_t write_some(const ConstBufferSequence&amp; buffers);
template&lt;class ConstBufferSequence&gt;
  size_t write_some(const ConstBufferSequence&amp; buffers,
                    error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.ops-23'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-23'>23</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>send(buffers, ec)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class ConstBufferSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_write_some(const ConstBufferSequence&amp; buffers,
                           CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.stream.ops-24'><div class='marginalizedparent'><a class='marginalized' href='#socket.stream.ops-24'>24</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>async_send(buffers, forward&lt;CompletionToken&gt;(token))</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_socket_acceptor'></a></span></p></div></div><div id='socket.acceptor'><h2 ><a class='secnum' href='#socket.acceptor' style='min-width:88pt'>18.9</a> Class template <span class='texttt'>basic_socket_acceptor</span> <a class='abbr_ref' href='socket.acceptor'>[socket.acceptor]</a></h2><div class='para' id='socket.acceptor-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor-1'>1</a></div><p >An object of class template <span class='texttt'>basic_socket_acceptor&lt;AcceptableProtocol&gt;</span> is used to listen for, and queue, incoming socket connections. Socket objects that represent the incoming connections are dequeued by calling <span class='texttt'>accept</span> or <span class='texttt'>async_accept</span>.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class AcceptableProtocol&gt;
  class basic_socket_acceptor : public socket_base
  {
  public:
    <span class='comment'>// types:
</span>
    using executor_type = io_context::executor_type;
    using native_handle_type = <i>implementation defined</i>; <span class='comment'>// see <a href='socket.reqmts.native'>[socket.reqmts.native]</a>
</span>    using protocol_type = AcceptableProtocol;
    using endpoint_type = typename protocol_type::endpoint;
    using socket_type = typename protocol_type::socket;

    <span class='comment'>// construct / copy / destroy:
</span>
    explicit basic_socket_acceptor(io_context&amp; ctx);
    basic_socket_acceptor(io_context&amp; ctx, const protocol_type&amp; protocol);
    basic_socket_acceptor(io_context&amp; ctx, const endpoint_type&amp; endpoint,
                          bool reuse_addr = true);
    basic_socket_acceptor(io_context&amp; ctx, const protocol_type&amp; protocol,
                          const native_handle_type&amp; native_acceptor);
    basic_socket_acceptor(const basic_socket_acceptor&amp;) = delete;
    basic_socket_acceptor(basic_socket_acceptor&amp;&amp; rhs);
    template&lt;class OtherProtocol&gt;
      basic_socket_acceptor(basic_socket_acceptor&lt;OtherProtocol&gt;&amp;&amp; rhs);

    ~basic_socket_acceptor();

    basic_socket_acceptor&amp; operator=(const basic_socket_acceptor&amp;) = delete;
    basic_socket_acceptor&amp; operator=(basic_socket_acceptor&amp;&amp; rhs);
    template&lt;class OtherProtocol&gt;
      basic_socket_acceptor&amp; operator=(basic_socket_acceptor&lt;OtherProtocol&gt;&amp;&amp; rhs);

    <span class='comment'>// basic_socket_acceptor operations:
</span>
    executor_type get_executor() noexcept;

    native_handle_type native_handle(); <span class='comment'>// see <a href='socket.reqmts.native'>[socket.reqmts.native]</a>
</span>
    void open(const protocol_type&amp; protocol = protocol_type());
    void open(const protocol_type&amp; protocol, error_code&amp; ec);

    void assign(const protocol_type&amp; protocol,
                const native_handle_type&amp; native_acceptor); <span class='comment'>// see <a href='socket.reqmts.native'>[socket.reqmts.native]</a>
</span>    void assign(const protocol_type&amp; protocol,
                const native_handle_type&amp; native_acceptor,
                error_code&amp; ec); <span class='comment'>// see <a href='socket.reqmts.native'>[socket.reqmts.native]</a>
</span>
    bool is_open() const;

    void close();
    void close(error_code&amp; ec);

    void cancel();
    void cancel(error_code&amp; ec);

    template&lt;class SettableSocketOption&gt;
      void set_option(const SettableSocketOption&amp; option);
    template&lt;class SettableSocketOption&gt;
      void set_option(const SettableSocketOption&amp; option, error_code&amp; ec);

    template&lt;class GettableSocketOption&gt;
      void get_option(GettableSocketOption&amp; option) const;
    template&lt;class GettableSocketOption&gt;
      void get_option(GettableSocketOption&amp; option, error_code&amp; ec) const;

    template&lt;class IoControlCommand&gt;
      void io_control(IoControlCommand&amp; command);
    template&lt;class IoControlCommand&gt;
      void io_control(IoControlCommand&amp; command, error_code&amp; ec);

    void non_blocking(bool mode);
    void non_blocking(bool mode, error_code&amp; ec);
    bool non_blocking() const;

    void native_non_blocking(bool mode);
    void native_non_blocking(bool mode, error_code&amp; ec);
    bool native_non_blocking() const;

    void bind(const endpoint_type&amp; endpoint);
    void bind(const endpoint_type&amp; endpoint, error_code&amp; ec);

    void listen(int backlog = max_listen_connections);
    void listen(int backlog, error_code&amp; ec);

    endpoint_type local_endpoint() const;
    endpoint_type local_endpoint(error_code&amp; ec) const;

    void enable_connection_aborted(bool mode);
    bool enable_connection_aborted() const;

    socket_type accept();
    socket_type accept(error_code&amp; ec);
    socket_type accept(io_context&amp; ctx);
    socket_type accept(io_context&amp; ctx, error_code&amp; ec);

    template&lt;class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_accept(CompletionToken&amp;&amp; token);
    template&lt;class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_accept(io_context&amp; ctx, CompletionToken&amp;&amp; token);

    socket_type accept(endpoint_type&amp; endpoint);
    socket_type accept(endpoint_type&amp; endpoint, error_code&amp; ec);
    socket_type accept(io_context&amp; ctx, endpoint_type&amp; endpoint);
    socket_type accept(io_context&amp; ctx, endpoint_type&amp; endpoint,
                       error_code&amp; ec);

    template&lt;class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_accept(endpoint_type&amp; endpoint,
                           CompletionToken&amp;&amp; token);
    template&lt;class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_accept(io_context&amp; ctx, endpoint_type&amp; endpoint,
                           CompletionToken&amp;&amp; token);

    void wait(wait_type w);
    void wait(wait_type w, error_code&amp; ec);

    template&lt;class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_wait(wait_type w, CompletionToken&amp;&amp; token);

  private:
    protocol_type protocol_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='socket.acceptor-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor-2'>2</a></div><p >Instances of class template <span class='texttt'>basic_socket_acceptor</span> meet the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), and <span class='texttt'>MoveAssignable</span> (C++Std &sect;<a href='../n4140/moveassignable'>[moveassignable]</a>).</p></div><div class='para' id='socket.acceptor-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor-3'>3</a></div><p >When there are multiple outstanding asynchronous accept operations the order in which the incoming connections are dequeued, and the order of invocation of the completion handlers for these operations, is unspecified.</p></div><div class='para' id='socket.acceptor-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor-4'>4</a></div><p >When an operation has its effects specified as if by passing the result of <span class='texttt'>native_handle()</span> to a POSIX function, then the operation fails with error condition <span class='texttt'>errc::bad_file_descriptor</span> if <span class='texttt'>is_open() == false</span> at the point in the effects when the POSIX function is called.</p></div><div id='socket.acceptor.cons'><h3 ><a class='secnum' href='#socket.acceptor.cons' style='min-width:103pt'>18.9.1</a> <span class='texttt'>basic_socket_acceptor</span> constructors <a class='abbr_ref' href='socket.acceptor.cons'>[socket.acceptor.cons]</a></h3><p ><code class='itemdecl'>
explicit basic_socket_acceptor(io_context&amp; ctx);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.cons-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-1.1'>(1.1)</a></div><p ><span class='texttt'>get_executor() == ctx.get_executor()</span>.
</p></li><li id='socket.acceptor.cons-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-1.2'>(1.2)</a></div><p ><span class='texttt'>is_open() == false</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
basic_socket_acceptor(io_context&amp; ctx, const protocol_type&amp; protocol);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Opens this acceptor as if by calling <span class='texttt'>open(protocol)</span>.</p></div></div><div class='para' id='socket.acceptor.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.cons-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-3.1'>(3.1)</a></div><p ><span class='texttt'>get_executor() == ctx.get_executor()</span>.
</p></li><li id='socket.acceptor.cons-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-3.2'>(3.2)</a></div><p ><span class='texttt'>is_open() == true</span>.
</p></li><li id='socket.acceptor.cons-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-3.3'>(3.3)</a></div><p ><span class='texttt'>non_blocking() == false</span>.
</p></li><li id='socket.acceptor.cons-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-3.4'>(3.4)</a></div><p ><span class='texttt'>enable_connection_aborted() == false</span>.
</p></li><li id='socket.acceptor.cons-3.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-3.5'>(3.5)</a></div><p ><span class='texttt'>protocol_ == protocol</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
basic_socket_acceptor(io_context&amp; ctx, const endpoint_type&amp; endpoint,
                      bool reuse_addr = true);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Opens and binds this acceptor as if by calling:
</p><pre class='codeblock'>
open(endpoint.protocol());
if (reuse_addr)
  set_option(reuse_address(true));
bind(endpoint);
listen();
</pre></div></div><div class='para' id='socket.acceptor.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.cons-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.cons-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-5.1'>(5.1)</a></div><p ><span class='texttt'>get_executor() == ctx.get_executor()</span>.
</p></li><li id='socket.acceptor.cons-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-5.2'>(5.2)</a></div><p ><span class='texttt'>is_open() == true</span>.
</p></li><li id='socket.acceptor.cons-5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-5.3'>(5.3)</a></div><p ><span class='texttt'>non_blocking() == false</span>.
</p></li><li id='socket.acceptor.cons-5.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-5.4'>(5.4)</a></div><p ><span class='texttt'>enable_connection_aborted() == false</span>.
</p></li><li id='socket.acceptor.cons-5.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-5.5'>(5.5)</a></div><p ><span class='texttt'>protocol_ == endpoint.protocol()</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
basic_socket_acceptor(io_context&amp; ctx, const protocol_type&amp; protocol,
                      const native_handle_type&amp; native_acceptor);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.cons-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>native_acceptor</span> is a native handle to an open acceptor.</p></div></div><div class='para' id='socket.acceptor.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.cons-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns the existing native acceptor into this acceptor as if by calling <span class='texttt'>assign(protocol, native_acceptor)</span>.</p></div></div><div class='para' id='socket.acceptor.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.cons-8'>8</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.cons-8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-8.1'>(8.1)</a></div><p ><span class='texttt'>get_executor() == ctx.get_executor()</span>.
</p></li><li id='socket.acceptor.cons-8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-8.2'>(8.2)</a></div><p ><span class='texttt'>is_open() == true</span>.
</p></li><li id='socket.acceptor.cons-8.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-8.3'>(8.3)</a></div><p ><span class='texttt'>non_blocking() == false</span>.
</p></li><li id='socket.acceptor.cons-8.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-8.4'>(8.4)</a></div><p ><span class='texttt'>enable_connection_aborted() == false</span>.
</p></li><li id='socket.acceptor.cons-8.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-8.5'>(8.5)</a></div><p ><span class='texttt'>protocol_ == protocol</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
basic_socket_acceptor(basic_socket_acceptor&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.cons-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs an object of class <span class='texttt'>basic_socket_acceptor&lt;AcceptableProtocol&gt;</span> that refers to the state originally represented by <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='socket.acceptor.cons-10'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.cons-10'>10</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.cons-10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-10.1'>(10.1)</a></div><p ><span class='texttt'>get_executor() == rhs.get_executor()</span>.
</p></li><li id='socket.acceptor.cons-10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-10.2'>(10.2)</a></div><p ><span class='texttt'>is_open()</span> returns the same value as <span class='texttt'>rhs.is_open()</span> prior to the constructor invocation.
</p></li><li id='socket.acceptor.cons-10.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-10.3'>(10.3)</a></div><p ><span class='texttt'>non_blocking()</span> returns the same value as <span class='texttt'>rhs.non_blocking()</span> prior to the constructor invocation.
</p></li><li id='socket.acceptor.cons-10.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-10.4'>(10.4)</a></div><p ><span class='texttt'>enable_connection_aborted()</span> returns the same value as <span class='texttt'>rhs.enable_connection_aborted()</span> prior to the constructor invocation.
</p></li><li id='socket.acceptor.cons-10.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-10.5'>(10.5)</a></div><p ><span class='texttt'>protocol_</span> is equal to the prior value of <span class='texttt'>rhs.protocol_</span>.
</p></li><li id='socket.acceptor.cons-10.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-10.6'>(10.6)</a></div><p ><span class='texttt'>rhs.is_open() == false</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
template&lt;class OtherProtocol&gt;
  basic_socket_acceptor(basic_socket_acceptor&lt;OtherProtocol&gt;&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.cons-11'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.cons-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.</p></div></div><div class='para' id='socket.acceptor.cons-12'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.cons-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs an object of class <span class='texttt'>basic_socket_acceptor&lt;AcceptableProtocol&gt;</span> that refers to the state originally represented by <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='socket.acceptor.cons-13'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.cons-13'>13</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.cons-13.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-13.1'>(13.1)</a></div><p ><span class='texttt'>get_executor() == rhs.get_executor()</span>.
</p></li><li id='socket.acceptor.cons-13.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-13.2'>(13.2)</a></div><p ><span class='texttt'>is_open()</span> returns the same value as <span class='texttt'>rhs.is_open()</span> prior to the constructor invocation.
</p></li><li id='socket.acceptor.cons-13.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-13.3'>(13.3)</a></div><p ><span class='texttt'>non_blocking()</span> returns the same value as <span class='texttt'>rhs.non_blocking()</span> prior to the constructor invocation.
</p></li><li id='socket.acceptor.cons-13.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-13.4'>(13.4)</a></div><p ><span class='texttt'>enable_connection_aborted()</span> returns the same value as <span class='texttt'>rhs.enable_connection_aborted()</span> prior to the constructor invocation.
</p></li><li id='socket.acceptor.cons-13.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-13.5'>(13.5)</a></div><p ><span class='texttt'>native_handle()</span> returns the prior value of <span class='texttt'>rhs.native_handle()</span>.
</p></li><li id='socket.acceptor.cons-13.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-13.6'>(13.6)</a></div><p ><span class='texttt'>protocol_</span> is the result of converting the prior value of <span class='texttt'>rhs.protocol_</span>.
</p></li><li id='socket.acceptor.cons-13.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.cons-13.7'>(13.7)</a></div><p ><span class='texttt'>rhs.is_open() == false</span>.
</p></li></ul></div></div><div class='para' id='socket.acceptor.cons-14'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.cons-14'>14</a></div><div class='itemdescr'><p ><i>Remarks:</i> This constructor shall not participate in overload resolution unless <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.
</p></div></div></div><div id='socket.acceptor.dtor'><h3 ><a class='secnum' href='#socket.acceptor.dtor' style='min-width:103pt'>18.9.2</a> <span class='texttt'>basic_socket_acceptor</span> destructor <a class='abbr_ref' href='socket.acceptor.dtor'>[socket.acceptor.dtor]</a></h3><p ><code class='itemdecl'>
~basic_socket_acceptor();
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>is_open()</span> is <span class='texttt'>true</span>, cancels all outstanding asynchronous operations associated with this acceptor, and releases acceptor resources as if by POSIX <span class='texttt'>close(native_handle())</span>. Completion handlers for canceled operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.
</p></div></div></div><div id='socket.acceptor.assign'><h3 ><a class='secnum' href='#socket.acceptor.assign' style='min-width:103pt'>18.9.3</a> <span class='texttt'>basic_socket_acceptor</span> assignment <a class='abbr_ref' href='socket.acceptor.assign'>[socket.acceptor.assign]</a></h3><p ><code class='itemdecl'>
basic_socket_acceptor&amp; operator=(basic_socket_acceptor&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>is_open()</span> is <span class='texttt'>true</span>, cancels all outstanding asynchronous operations associated with this acceptor, and releases acceptor resources as if by POSIX <span class='texttt'>close(native_handle())</span>. Then moves into <span class='texttt'>*this</span> the state originally represented by <span class='texttt'>rhs</span>. Completion handlers for canceled operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='socket.acceptor.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.assign-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.assign-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.assign-2.1'>(2.1)</a></div><p ><span class='texttt'>get_executor() == rhs.get_executor()</span>.
</p></li><li id='socket.acceptor.assign-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.assign-2.2'>(2.2)</a></div><p ><span class='texttt'>is_open()</span> returns the same value as <span class='texttt'>rhs.is_open()</span> prior to the assignment.
</p></li><li id='socket.acceptor.assign-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.assign-2.3'>(2.3)</a></div><p ><span class='texttt'>non_blocking()</span> returns the same value as <span class='texttt'>rhs.non_blocking()</span> prior to the assignment.
</p></li><li id='socket.acceptor.assign-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.assign-2.4'>(2.4)</a></div><p ><span class='texttt'>enable_connection_aborted()</span> returns the same value as <span class='texttt'>rhs.enable_connection_aborted()</span> prior to the assignment.
</p></li><li id='socket.acceptor.assign-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.assign-2.5'>(2.5)</a></div><p ><span class='texttt'>native_handle()</span> returns the same value as <span class='texttt'>rhs.native_handle()</span> prior to the assignment.
</p></li><li id='socket.acceptor.assign-2.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.assign-2.6'>(2.6)</a></div><p ><span class='texttt'>protocol_</span> is the same value as <span class='texttt'>rhs.protocol_</span> prior to the assignment.
</p></li><li id='socket.acceptor.assign-2.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.assign-2.7'>(2.7)</a></div><p ><span class='texttt'>rhs.is_open() == false</span>.
</p></li></ul></div></div><div class='para' id='socket.acceptor.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.assign-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class OtherProtocol&gt;
  basic_socket_acceptor&amp; operator=(basic_socket_acceptor&lt;OtherProtocol&gt;&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.assign-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.</p></div></div><div class='para' id='socket.acceptor.assign-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.assign-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>is_open()</span> is <span class='texttt'>true</span>, cancels all outstanding asynchronous operations associated with this acceptor, and releases acceptor resources as if by POSIX <span class='texttt'>close(native_handle())</span>. Then moves into <span class='texttt'>*this</span> the state originally represented by <span class='texttt'>rhs</span>. Completion handlers for canceled operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='socket.acceptor.assign-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.assign-6'>6</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.assign-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.assign-6.1'>(6.1)</a></div><p ><span class='texttt'>get_executor() == rhs.get_executor()</span>.
</p></li><li id='socket.acceptor.assign-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.assign-6.2'>(6.2)</a></div><p ><span class='texttt'>is_open()</span> returns the same value as <span class='texttt'>rhs.is_open()</span> prior to the assignment.
</p></li><li id='socket.acceptor.assign-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.assign-6.3'>(6.3)</a></div><p ><span class='texttt'>non_blocking()</span> returns the same value as <span class='texttt'>rhs.non_blocking()</span> prior to the assignment.
</p></li><li id='socket.acceptor.assign-6.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.assign-6.4'>(6.4)</a></div><p ><span class='texttt'>enable_connection_aborted()</span> returns the same value as <span class='texttt'>rhs.enable_connection_aborted()</span> prior to the assignment.
</p></li><li id='socket.acceptor.assign-6.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.assign-6.5'>(6.5)</a></div><p ><span class='texttt'>native_handle()</span> returns the same value as <span class='texttt'>rhs.native_handle()</span> prior to the assignment.
</p></li><li id='socket.acceptor.assign-6.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.assign-6.6'>(6.6)</a></div><p ><span class='texttt'>protocol_</span> is the result of converting the value of <span class='texttt'>rhs.protocol_</span> prior to the assignment.
</p></li><li id='socket.acceptor.assign-6.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.assign-6.7'>(6.7)</a></div><p ><span class='texttt'>rhs.is_open() == false</span>.
</p></li></ul></div></div><div class='para' id='socket.acceptor.assign-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.assign-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.</p></div></div><div class='para' id='socket.acceptor.assign-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.assign-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> This assignment operator shall not participate in overload resolution unless <span class='texttt'>OtherProtocol</span> is implicitly convertible to <span class='texttt'>Protocol</span>.
</p></div></div></div><div id='socket.acceptor.ops'><h3 ><a class='secnum' href='#socket.acceptor.ops' style='min-width:103pt'>18.9.4</a> <span class='texttt'>basic_socket_acceptor</span> operations <a class='abbr_ref' href='socket.acceptor.ops'>[socket.acceptor.ops]</a></h3><p ><code class='itemdecl'>
executor_type get_executor() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The associated executor.
</p></div></div><p ><code class='itemdecl'>
native_handle_type native_handle();
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The native representation of this acceptor.
</p></div></div><p ><code class='itemdecl'>
void open(const protocol_type&amp; protocol);
void open(const protocol_type&amp; protocol, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Establishes the postcondition, as if by POSIX <span class='texttt'>socket(protocol.family(), protocol.type(), protocol.protocol())</span>.</p></div></div><div class='para' id='socket.acceptor.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.ops-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-4.1'>(4.1)</a></div><p ><span class='texttt'>is_open() == true</span>.
</p></li><li id='socket.acceptor.ops-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-4.2'>(4.2)</a></div><p ><span class='texttt'>non_blocking() == false</span>.
</p></li><li id='socket.acceptor.ops-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-4.3'>(4.3)</a></div><p ><span class='texttt'>enable_connection_aborted() == false</span>.
</p></li><li id='socket.acceptor.ops-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-4.4'>(4.4)</a></div><p ><span class='texttt'>protocol_ == protocol</span>.
</p></li></ul></div></div><div class='para' id='socket.acceptor.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-5'>5</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.ops-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-5.1'>(5.1)</a></div><p ><span class='texttt'>socket_errc::already_open</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>true</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
void assign(const protocol_type&amp; protocol,
            const native_handle_type&amp; native_acceptor);
void assign(const protocol_type&amp; protocol,
            const native_handle_type&amp; native_acceptor, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>native_acceptor</span> is a native handle to an open acceptor.</p></div></div><div class='para' id='socket.acceptor.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns the native acceptor handle to this acceptor object.</p></div></div><div class='para' id='socket.acceptor.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-8'>8</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.ops-8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-8.1'>(8.1)</a></div><p ><span class='texttt'>is_open() == true</span>.
</p></li><li id='socket.acceptor.ops-8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-8.2'>(8.2)</a></div><p ><span class='texttt'>non_blocking() == false</span>.
</p></li><li id='socket.acceptor.ops-8.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-8.3'>(8.3)</a></div><p ><span class='texttt'>enable_connection_aborted() == false</span>.
</p></li><li id='socket.acceptor.ops-8.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-8.4'>(8.4)</a></div><p ><span class='texttt'>protocol_ == protocol</span>.
</p></li></ul></div></div><div class='para' id='socket.acceptor.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-9'>9</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.ops-9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-9.1'>(9.1)</a></div><p ><span class='texttt'>socket_errc::already_open</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>true</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
bool is_open() const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-10'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>bool</span> indicating whether this acceptor was opened by a previous call to <span class='texttt'>open</span> or <span class='texttt'>assign</span>.
</p></div></div><p ><code class='itemdecl'>
void close();
void close(error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-11'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>is_open()</span> is <span class='texttt'>true</span>, cancels all outstanding asynchronous operations associated with this acceptor, and establishes the postcondition as if by POSIX <span class='texttt'>close(native_handle())</span>. Completion handlers for canceled asynchronous operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='socket.acceptor.ops-12'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-12'>12</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_open() == false</span>.
</p></div></div><p ><code class='itemdecl'>
void cancel();
void cancel(error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-13'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Cancels all outstanding asynchronous operations associated with this acceptor. Completion handlers for canceled asynchronous operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='socket.acceptor.ops-14'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-14'>14</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.ops-14.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-14.1'>(14.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li><li id='socket.acceptor.ops-14.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-14.2'>(14.2)</a></div><p ><span class='texttt'>errc::operation_not_supported</span> — current conditions do not permit cancelation. The conditions under which cancelation of asynchronous operations is permitted are <span class='indexparent'><a class='index' id='conditions_under_which_cancelation_of_asynchronous_operations_is_permitted'></a></span>implementation-defined.
</p></li></ul></div></div><p ><code class='itemdecl'>
template&lt;class SettableSocketOption&gt;
  void set_option(const SettableSocketOption&amp; option);
template&lt;class SettableSocketOption&gt;
  void set_option(const SettableSocketOption&amp; option, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-15'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets an option on this acceptor, as if by POSIX <span class='texttt'>setsockopt(native_handle(), option.level( protocol_), option.name(protocol_), option.data(protocol_), option.size(protocol_))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class GettableSocketOption&gt;
  void get_option(GettableSocketOption&amp; option);
template&lt;class GettableSocketOption&gt;
  void get_option(GettableSocketOption&amp; option, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-16'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> Gets an option from this acceptor, as if by POSIX:
</p><pre class='codeblock'>
socklen_t option_len = option.size(protocol_);
int result = getsockopt(native_handle(), option.level(protocol_),
                        option.name(protocol_), option.data(protocol_),
                        &amp;option_len);
if (result == 0)
  option.resize(option_len);
</pre></div></div><p ><code class='itemdecl'>
template&lt;class IoControlCommand&gt;
  void io_control(IoControlCommand&amp; command);
template&lt;class IoControlCommand&gt;
  void io_control(IoControlCommand&amp; command, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-17'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-17'>17</a></div><div class='itemdescr'><p ><i>Effects:</i> Executes an I/O control command on this acceptor, as if by POSIX <span class='texttt'>ioctl(native_handle(), command.name(), command.data())</span>.
</p></div></div><p ><code class='itemdecl'>
void non_blocking(bool mode);
void non_blocking(bool mode, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-18'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-18'>18</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets the non-blocking mode of this acceptor. The non-blocking mode determines whether subsequent synchronous socket operations (<a href='socket.reqmts.sync'>[socket.reqmts.sync]</a>) on <span class='texttt'>*this</span> block the calling thread.</p></div></div><div class='para' id='socket.acceptor.ops-19'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-19'>19</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.ops-19.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-19.1'>(19.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li></ul></div></div><div class='para' id='socket.acceptor.ops-20'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-20'>20</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>non_blocking() == mode</span>.</p></div></div><div class='para' id='socket.acceptor.ops-21'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-21'>21</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The non-blocking mode has no effect on the behavior of asynchronous operations. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><code class='itemdecl'>
bool non_blocking() const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-22'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-22'>22</a></div><div class='itemdescr'><p ><i>Returns:</i> The non-blocking mode of this acceptor.
</p></div></div><p ><code class='itemdecl'>
void native_non_blocking(bool mode);
void native_non_blocking(bool mode, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-23'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-23'>23</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets the non-blocking mode of the underlying native acceptor, as if by POSIX:
</p><pre class='codeblock'>
int flags = fcntl(native_handle(), F_GETFL, 0);
if (flags &gt;= 0){
  if (mode)
    flags |= O_NONBLOCK;
  else
    flags &amp;= ~O_NONBLOCK;
  fcntl(native_handle(), F_SETFL, flags);
}
</pre></div></div><div class='para' id='socket.acceptor.ops-24'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-24'>24</a></div><div class='itemdescr'><p >The native non-blocking mode has no effect on the behavior of the synchronous or asynchronous operations specified in this clause.</p></div></div><div class='para' id='socket.acceptor.ops-25'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-25'>25</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.ops-25.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-25.1'>(25.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li><li id='socket.acceptor.ops-25.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-25.2'>(25.2)</a></div><p ><span class='texttt'>errc::invalid_argument</span> — if <span class='texttt'>mode == false</span> and <span class='texttt'>non_blocking() == true</span>. [&nbsp;<i>Note:</i> As the combination does not make sense. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div></div><p ><code class='itemdecl'>
bool native_non_blocking() const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-26'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-26'>26</a></div><div class='itemdescr'><p ><i>Returns:</i> The non-blocking mode of the underlying native acceptor.</p></div></div><div class='para' id='socket.acceptor.ops-27'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-27'>27</a></div><div class='itemdescr'><p ><i>Remarks:</i> Implementations are permitted and encouraged to cache the native non-blocking mode that was applied through a prior call to <span class='texttt'>native_non_blocking</span>. Implementations may return an incorrect value if a program sets the non-blocking mode directly on the acceptor, by calling an operating system-specific function on the result of <span class='texttt'>native_handle()</span>.
</p></div></div><p ><code class='itemdecl'>
void bind(const endpoint_type&amp; endpoint);
void bind(const endpoint_type&amp; endpoint, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-28'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-28'>28</a></div><div class='itemdescr'><p ><i>Effects:</i> Binds this acceptor to the specified local endpoint, as if by POSIX <span class='texttt'>bind(native_handle(), endpoint.data(), endpoint.size())</span>.
</p></div></div><p ><code class='itemdecl'>
void listen(int backlog = socket_base::max_listen_connections);
void listen(int backlog, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-29'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-29'>29</a></div><div class='itemdescr'><p ><i>Effects:</i> Marks this acceptor as ready to accept connections, as if by POSIX <span class='texttt'>listen(native_handle(), backlog)</span>.
</p></div></div><p ><code class='itemdecl'>
endpoint_type local_endpoint() const;
endpoint_type local_endpoint(error_code&amp; ec) const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-30'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-30'>30</a></div><div class='itemdescr'><p ><i>Effects:</i> Determines the locally-bound endpoint associated with this acceptor, as if by POSIX:
</p><pre class='codeblock'>
endpoint_type endpoint;
socklen_t endpoint_len = endpoint.capacity();
int result = getsockname(native_handle(), endpoint.data(), &amp;endpoint_len);
if (result == 0)
  endpoint.resize(endpoint_len);
</pre></div></div><div class='para' id='socket.acceptor.ops-31'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-31'>31</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, <span class='texttt'>endpoint</span>. Otherwise <span class='texttt'>endpoint_type()</span>.
</p></div></div><p ><code class='itemdecl'>
void enable_connection_aborted(bool mode);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-32'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-32'>32</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>mode</span> is true, subsequent synchronous or asynchronous accept operations on this acceptor are permitted to fail with error condition <span class='texttt'>errc::connection_aborted</span>. If <span class='texttt'>mode</span> is <span class='texttt'>false</span>, subsequent accept operations will not fail with <span class='texttt'>errc::connection_aborted</span>. [&nbsp;<i>Note:</i> If <span class='texttt'>mode</span> is <span class='texttt'>false</span>, the implementation will restart the call to POSIX <span class='texttt'>accept</span> if it fails with <span class='texttt'>ECONNABORTED</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='socket.acceptor.ops-33'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-33'>33</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.ops-33.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-33.1'>(33.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
bool enable_connection_aborted() const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-34'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-34'>34</a></div><div class='itemdescr'><p ><i>Returns:</i> Whether accept operations on this acceptor are permitted to fail with <span class='texttt'>errc::connection_aborted</span>.
</p></div></div><p ><code class='itemdecl'>
socket_type accept();
socket_type accept(error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-35'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-35'>35</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>accept(get_executor().context(), ec)</span>.
</p></div></div><p ><code class='itemdecl'>
socket_type accept(io_context&amp; ctx);
socket_type accept(io_context&amp; ctx, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-36'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-36'>36</a></div><div class='itemdescr'><p ><i>Effects:</i> Extracts a socket from the queue of pending connections of the acceptor, as if by POSIX:
</p><pre class='codeblock'>
native_handle_type h = accept(native_handle(), nullptr, 0);
</pre></div></div><div class='para' id='socket.acceptor.ops-37'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-37'>37</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, <span class='texttt'>socket_type(ctx, protocol_, h)</span>. Otherwise <span class='texttt'>socket_type(ctx)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_accept(CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-38'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-38'>38</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>async_accept(get_executor().context(), forward&lt;CompletionToken&gt;(token))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_accept(io_context&amp; ctx, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-39'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-39'>39</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, socket_type s)</span>.</p></div></div><div class='para' id='socket.acceptor.ops-40'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-40'>40</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to extract a socket from the queue of pending connections of the acceptor, as if by POSIX:
</p><pre class='codeblock'>
native_handle_type h = accept(native_handle(), nullptr, 0);
</pre><p >On success, <span class='texttt'>s</span> is <span class='texttt'>socket_type(ctx, protocol_, h)</span>. Otherwise, <span class='texttt'>s</span> is <span class='texttt'>socket_type(ctx)</span>.
</p></div></div><p ><code class='itemdecl'>
socket_type accept(endpoint_type&amp; endpoint);
socket_type accept(endpoint_type&amp; endpoint, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-41'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-41'>41</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>accept(get_executor().context(), endpoint, ec)</span>.
</p></div></div><p ><code class='itemdecl'>
socket_type accept(io_context&amp; ctx, endpoint_type&amp; endpoint);
socket_type accept(io_context&amp; ctx, endpoint_type&amp; endpoint,
                   error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-42'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-42'>42</a></div><div class='itemdescr'><p ><i>Effects:</i> Extracts a socket from the queue of pending connections of the acceptor, as if by POSIX:
</p><pre class='codeblock'>
socklen_t endpoint_len = endpoint.capacity();
native_handle_type h = accept(native_handle(),
                              endpoint.data(),
                              &amp;endpoint_len);
if (h &gt;= 0)
  endpoint.resize(endpoint_len);
</pre></div></div><div class='para' id='socket.acceptor.ops-43'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-43'>43</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, <span class='texttt'>socket_type(ctx, protocol_, h)</span>. Otherwise <span class='texttt'>socket_type(ctx)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_accept(endpoint_type&amp; endpoint,
                       CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-44'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-44'>44</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>async_accept(get_executor().context(), endpoint, forward&lt;CompletionToken&gt;(token))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_accept(io_context&amp; ctx, endpoint_type&amp; endpoint,
                       CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-45'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-45'>45</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, socket_type s)</span>.</p></div></div><div class='para' id='socket.acceptor.ops-46'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-46'>46</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to extract a socket from the queue of pending connections of the acceptor, as if by POSIX:
</p><pre class='codeblock'>
socklen_t endpoint_len = endpoint.capacity();
native_handle_type h = accept(native_handle(),
                              endpoint.data(),
                              &amp;endpoint_len);
if (h &gt;= 0)
  endpoint.resize(endpoint_len);
</pre><p >On success, <span class='texttt'>s</span> is <span class='texttt'>socket_type(ctx, protocol_, h)</span>. Otherwise,  <span class='texttt'>s</span> is  <span class='texttt'>socket_type(ctx)</span>.
</p></div></div><p ><code class='itemdecl'>
void wait(wait_type w);
void wait(wait_type w, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-47'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-47'>47</a></div><div class='itemdescr'><p ><i>Effects:</i> Waits for the acceptor to have a queued incoming connection, or to have error conditions pending, as if by POSIX <span class='texttt'>poll</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_wait(wait_type w, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.acceptor.ops-48'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-48'>48</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec)</span>.</p></div></div><div class='para' id='socket.acceptor.ops-49'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-49'>49</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to wait for the acceptor to have a queued incoming connection, or to have error conditions pending, as if by POSIX <span class='texttt'>poll</span>.</p></div></div><div class='para' id='socket.acceptor.ops-50'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-50'>50</a></div><div class='itemdescr'><p >When multiple asynchronous wait operations are initiated with the same <span class='texttt'>wait_type</span> value, all outstanding operations complete when the acceptor enters the corresponding ready state. The order of invocation of the completions handlers for these operations is unspecified.</p></div></div><div class='para' id='socket.acceptor.ops-51'><div class='marginalizedparent'><a class='marginalized' href='#socket.acceptor.ops-51'>51</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.acceptor.ops-51.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.acceptor.ops-51.1'>(51.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li></ul></div></div></div></div></div><div id='socket.iostreams'><h1 ><a class='secnum' href='#socket.iostreams' style='min-width:73pt'>19</a> Socket iostreams <a class='abbr_ref' href='./#socket.iostreams'>[socket.iostreams]</a></h1><div id='socket.streambuf'><h2 ><a class='secnum' href='#socket.streambuf' style='min-width:88pt'>19.1</a> Class template <span class='texttt'>basic_socket_streambuf</span> <a class='abbr_ref' href='socket.streambuf'>[socket.streambuf]</a></h2><div class='para' id='socket.streambuf-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf-1'>1</a></div><p >The class <span class='texttt'>basic_socket_streambuf&lt;Protocol, Clock, WaitTraits&gt;</span> associates both the input sequence and the output sequence with a socket. The input and output sequences do not support seeking. [&nbsp;<i>Note:</i> The input and output sequences are independent as a stream socket provides full duplex I/O. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='socket.streambuf-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf-2'>2</a></div><p >[&nbsp;<i>Note:</i> This class is intended for sending and receiving bytes, not characters. The conversion from characters to bytes, and vice versa, must occur elsewhere. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Protocol, class Clock, class WaitTraits&gt;
  class basic_socket_streambuf : public basic_streambuf&lt;char&gt;
  {
  public:
    <span class='comment'>// types:
</span>
    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;
    using clock_type = Clock;
    using time_point = typename clock_type::time_point;
    using duration = typename clock_type::duration;
    using wait_traits_type = WaitTraits;

    <span class='comment'>// construct / copy / destroy:
</span>
    basic_socket_streambuf();
    explicit basic_socket_streambuf(basic_stream_socket&lt;protocol_type&gt; s);
    basic_socket_streambuf(const basic_socket_streambuf&amp;) = delete;
    basic_socket_streambuf(basic_socket_streambuf&amp;&amp; rhs);

    virtual ~basic_socket_streambuf();

    basic_socket_streambuf&amp; operator=(const basic_socket_streambuf&amp;) = delete;
    basic_socket_streambuf&amp; operator=(basic_socket_streambuf&amp;&amp; rhs);

    <span class='comment'>// members:
</span>
    basic_socket_streambuf* connect(const endpoint_type&amp; e);
    template&lt;class... Args&gt; basic_socket_streambuf* connect(Args&amp;&amp;... );

    basic_socket_streambuf* close();

    basic_socket&lt;protocol_type&gt;&amp; socket();
    error_code error() const;

    time_point expiry() const;
    void expires_at(const time_point&amp; t);
    void expires_after(const duration&amp; d);

  protected:
    <span class='comment'>// overridden virtual functions:
</span>    virtual int_type underflow() override;
    virtual int_type pbackfail(int_type c = traits_type::eof()) override;
    virtual int_type overflow(int_type c = traits_type::eof()) override;
    virtual int sync() override;
    virtual streambuf* setbuf(char_type* s, streamsize n) override;

  private:
    basic_stream_socket&lt;protocol_type&gt; socket_; <span class='comment'>// <i>exposition only</i>
</span>    error_code ec_; <span class='comment'>// <i>exposition only</i>
</span>    time_point expiry_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='socket.streambuf-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf-3'>3</a></div><p >Instances of class template <span class='texttt'>basic_socket_streambuf</span> meet the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), and <span class='texttt'>MoveAssignable</span> (C++Std &sect;<a href='../n4140/moveassignable'>[moveassignable]</a>).</p></div><div id='socket.streambuf.cons'><h3 ><a class='secnum' href='#socket.streambuf.cons' style='min-width:103pt'>19.1.1</a> <span class='texttt'>basic_socket_streambuf</span> constructors <a class='abbr_ref' href='socket.streambuf.cons'>[socket.streambuf.cons]</a></h3><p ><code class='itemdecl'>
basic_socket_streambuf();
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>socket_</span> with <span class='texttt'>ctx</span>, where <span class='texttt'>ctx</span> is an unspecified object of class <span class='texttt'>io_context</span>.</p></div></div><div class='para' id='socket.streambuf.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>expiry() == time_point::max()</span>.
</p></div></div><p ><code class='itemdecl'>
explicit basic_socket_streambuf(basic_stream_socket&lt;protocol_type&gt; s);
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>socket_</span> with <span class='texttt'>std::move(s)</span>.</p></div></div><div class='para' id='socket.streambuf.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.cons-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>expiry() == time_point::max()</span>.
</p></div></div><p ><code class='itemdecl'>
basic_socket_streambuf(basic_socket_streambuf&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs from the rvalue <span class='texttt'>rhs</span>. It is <span class='indexparent'><a class='index' id='whether_the_sequence_pointers_in_basic_socket_streambuf_obtain_the_source_object&#39;s_values_after_move-construction'></a></span>implementation-defined whether the sequence pointers in <span class='texttt'>*this</span> (<span class='texttt'>eback()</span>, <span class='texttt'>gptr()</span>, <span class='texttt'>egptr()</span>, <span class='texttt'>pbase()</span>, <span class='texttt'>pptr()</span>, <span class='texttt'>epptr()</span>) obtain the values which <span class='texttt'>rhs</span> had. Whether they do or not, <span class='texttt'>*this</span> and <span class='texttt'>rhs</span> reference separate buffers (if any at all) after the construction. Additionally <span class='texttt'>*this</span> references the socket which <span class='texttt'>rhs</span> did before the construction, and <span class='texttt'>rhs</span> references no open socket after the construction.</p></div></div><div class='para' id='socket.streambuf.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.cons-6'>6</a></div><div class='itemdescr'><p ><i>Postconditions:</i> Let <span class='texttt'>rhs_p</span> refer to the state of <span class='texttt'>rhs</span> just prior to this construction and let <span class='texttt'>rhs_a</span> refer to the state of <span class='texttt'>rhs</span> just after this construction.
</p><ul class='itemize'><li id='socket.streambuf.cons-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.cons-6.1'>(6.1)</a></div><p ><span class='texttt'>is_open() == rhs_p.is_open()</span>
</p></li><li id='socket.streambuf.cons-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.cons-6.2'>(6.2)</a></div><p ><span class='texttt'>rhs_a.is_open() == false</span>
</p></li><li id='socket.streambuf.cons-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.cons-6.3'>(6.3)</a></div><p ><span class='texttt'>expiry() == rhs_p.expiry()</span>
</p></li><li id='socket.streambuf.cons-6.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.cons-6.4'>(6.4)</a></div><p ><span class='texttt'>rhs_a.expiry() == time_point::max()</span>
</p></li><li id='socket.streambuf.cons-6.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.cons-6.5'>(6.5)</a></div><p ><span class='texttt'>gptr() - eback() == rhs_p.gptr() - rhs_p.eback()</span>
</p></li><li id='socket.streambuf.cons-6.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.cons-6.6'>(6.6)</a></div><p ><span class='texttt'>egptr() - eback() == rhs_p.egptr() - rhs_p.eback()</span>
</p></li><li id='socket.streambuf.cons-6.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.cons-6.7'>(6.7)</a></div><p ><span class='texttt'>ptr() - pbase() == rhs_p.pptr() - rhs_p.pbase()</span>
</p></li><li id='socket.streambuf.cons-6.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.cons-6.8'>(6.8)</a></div><p ><span class='texttt'>pptr() - pbase() == rhs_p.epptr() - rhs_p.pbase()</span>
</p></li><li id='socket.streambuf.cons-6.9'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.cons-6.9'>(6.9)</a></div><p ><span class='texttt'>if (eback()) eback() != rhs_a.eback()</span>
</p></li><li id='socket.streambuf.cons-6.10'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.cons-6.10'>(6.10)</a></div><p ><span class='texttt'>if (gptr()) gptr() != rhs_a.gptr()</span>
</p></li><li id='socket.streambuf.cons-6.11'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.cons-6.11'>(6.11)</a></div><p ><span class='texttt'>if (egptr()) egptr() != rhs_a.egptr()</span>
</p></li><li id='socket.streambuf.cons-6.12'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.cons-6.12'>(6.12)</a></div><p ><span class='texttt'>if (pbase()) pbase() != rhs_a.pbase()</span>
</p></li><li id='socket.streambuf.cons-6.13'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.cons-6.13'>(6.13)</a></div><p ><span class='texttt'>if (pptr()) pptr() != rhs_a.pptr()</span>
</p></li><li id='socket.streambuf.cons-6.14'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.cons-6.14'>(6.14)</a></div><p ><span class='texttt'>if (epptr()) epptr() != rhs_a.epptr()</span>
</p></li></ul></div></div><p ><code class='itemdecl'>
virtual ~basic_socket_streambuf();
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.cons-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> If a put area exists, calls <span class='texttt'>overflow(traits_type::eof())</span> to flush characters. [&nbsp;<i>Note:</i> The socket is closed by the <span class='texttt'>basic_stream_socket&lt;protocol_type&gt;</span> destructor. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><code class='itemdecl'>
basic_socket_streambuf&amp; operator=(basic_socket_streambuf&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.cons-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Calls <span class='texttt'>this-&gt;close()</span> then move assigns from <span class='texttt'>rhs</span>. After the move assignment <span class='texttt'>*this</span> has the observable state it would have had if it had been move constructed from <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='socket.streambuf.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.cons-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='socket.streambuf.members'><h3 ><a class='secnum' href='#socket.streambuf.members' style='min-width:103pt'>19.1.2</a> <span class='texttt'>basic_socket_streambuf</span> members <a class='abbr_ref' href='socket.streambuf.members'>[socket.streambuf.members]</a></h3><p ><code class='itemdecl'>
basic_socket_streambuf* connect(const endpoint_type&amp; e);
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.members-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the <span class='texttt'>basic_socket_streambuf</span> as required, closes and re-opens the socket by performing <span class='texttt'>socket_.close(ec_)</span> and <span class='texttt'>socket_.open(e.protocol(), ec_)</span>, then attempts to establish a connection as if by POSIX <span class='texttt'>connect(socket_.native_handle(), static_cast&lt;sockaddr*&gt;(e.data()), e.size())</span>. <span class='texttt'>ec_</span> is set to reflect the error code produced by the operation. If the operation does not complete before the absolute timeout specified by <span class='texttt'>expiry_</span>, the socket is closed and <span class='texttt'>ec_</span> is set to <span class='texttt'>errc::timed_out</span>.</p></div></div><div class='para' id='socket.streambuf.members-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> if <span class='texttt'>!ec_</span>, <span class='texttt'>this</span>; otherwise, a null pointer.
</p></div></div><p ><code class='itemdecl'>
template&lt;class... Args&gt;
  basic_socket_streambuf* connect(Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.members-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.members-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the <span class='texttt'>basic_socket_streambuf</span> as required and closes the socket as if by calling <span class='texttt'>socket_.close(ec_)</span>. Obtains an endpoint sequence <span class='texttt'>endpoints</span> by performing <span class='texttt'>protocol_type::resolver(ctx).resolve(forward&lt;Args&gt;(args)...)</span>, where <span class='texttt'>ctx</span> is an unspecified object of class <span class='texttt'>io_context</span>. For each endpoint <span class='texttt'>e</span> in the sequence, closes and re-opens the socket by performing <span class='texttt'>socket_.close(ec_)</span> and <span class='texttt'>socket_.open(e.protocol(), ec_)</span>, then attempts to establish a connection as if by POSIX <span class='texttt'>connect(socket_.native_handle(), static_cast&lt;sockaddr*&gt;(e.data()), e.size())</span>. <span class='texttt'>ec_</span> is set to reflect the error code produced by the operation. If the operation does not complete before the absolute timeout specified by <span class='texttt'>expiry_</span>, the socket is closed and <span class='texttt'>ec_</span> is set to <span class='texttt'>errc::timed_out</span>.</p></div></div><div class='para' id='socket.streambuf.members-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> if <span class='texttt'>!ec_</span>, <span class='texttt'>this</span>; otherwise, a null pointer.</p></div></div><div class='para' id='socket.streambuf.members-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.members-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>Protocol</span> meets the requirements for an internet protocol (<a href='internet.reqmts.protocol'>[internet.reqmts.protocol]</a>).
</p></div></div><p ><code class='itemdecl'>
basic_socket_streambuf* close();
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.members-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.members-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> If a put area exists, calls <span class='texttt'>overflow(traits_type::eof())</span> to flush characters. Regardless of whether the preceding call fails or throws an exception, the function closes the socket as if by <span class='texttt'>basic_socket&lt;protocol_type&gt;::close(ec_)</span>. If any of the calls made by the function fail, <span class='texttt'>close</span> fails by returning a null pointer. If one of these calls throws an exception, the exception is caught and rethrown after closing the socket.</p></div></div><div class='para' id='socket.streambuf.members-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>this</span> on success, a null pointer otherwise.</p></div></div><div class='para' id='socket.streambuf.members-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.members-8'>8</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_open() == false</span>.
</p></div></div><p ><code class='itemdecl'>
basic_socket&lt;protocol_type&gt;&amp; socket();
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.members-9'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.members-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>socket_</span>.
</p></div></div><p ><code class='itemdecl'>
error_code error() const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.members-10'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.members-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>ec_</span>.
</p></div></div><p ><code class='itemdecl'>
time_point expiry() const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.members-11'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.members-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>expiry_</span>.
</p></div></div><p ><code class='itemdecl'>
void expires_at(const time_point&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.members-12'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.members-12'>12</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>expiry_ == t</span>.
</p></div></div><p ><code class='itemdecl'>
void expires_after(const duration&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.members-13'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.members-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>expires_at(clock_type::now() + d)</span>.
</p></div></div></div><div id='socket.streambuf.virtual'><h3 ><a class='secnum' href='#socket.streambuf.virtual' style='min-width:103pt'>19.1.3</a> <span class='texttt'>basic_socket_streambuf</span> overridden virtual functions <a class='abbr_ref' href='socket.streambuf.virtual'>[socket.streambuf.virtual]</a></h3><p ><code class='itemdecl'>
virtual int_type underflow() override;
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.virtual-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.virtual-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Behaves according to the description of <span class='texttt'>basic_streambuf&lt;char&gt;::underflow()</span>, with the specialization that a sequence of characters is read from the input sequence as if by POSIX <span class='texttt'>recvmsg</span>, and <span class='texttt'>ec_</span> is set to reflect the error code produced by the operation. If the operation does not complete before the absolute timeout specified by <span class='texttt'>expiry_</span>, the socket is closed and <span class='texttt'>ec_</span> is set to <span class='texttt'>errc::timed_out</span>.</p></div></div><div class='para' id='socket.streambuf.virtual-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.virtual-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>traits_type::to_int_type(*gptr())</span> to indicate success,
and <span class='texttt'>traits_type::eof()</span> to indicate failure.
</p></div></div><p ><code class='itemdecl'>
virtual int_type pbackfail(int_type c = traits_type::eof()) override;
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.virtual-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.virtual-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Puts back the character designated by <span class='texttt'>c</span> to the input sequence, if possible, in one of three ways:</p><ul class='itemize'><li id='socket.streambuf.virtual-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.virtual-3.1'>(3.1)</a></div><p >If <span class='texttt'>traits_type::eq_int_type(c, traits_type::eof())</span> returns <span class='texttt'>false</span>, and if the function makes a putback position available, and if <span class='texttt'>traits_type::eq(traits_type::to_char_type(c), gptr()[-1])</span> returns <span class='texttt'>true</span>, decrements the next pointer for the input sequence, <span class='texttt'>gptr()</span>. Returns: <span class='texttt'>c</span>.</p></li><li id='socket.streambuf.virtual-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.virtual-3.2'>(3.2)</a></div><p >If <span class='texttt'>traits_type::eq_int_type(c, traits_type::eof())</span> returns <span class='texttt'>false</span>, and if the function makes a putback position available, and if the function is permitted to assign to the putback position, decrements the next pointer for the input sequence, and stores <span class='texttt'>c</span> there. Returns: <span class='texttt'>c</span>.</p></li><li id='socket.streambuf.virtual-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.streambuf.virtual-3.3'>(3.3)</a></div><p >If <span class='texttt'>traits_type::eq_int_type(c, traits_type::eof())</span> returns <span class='texttt'>true</span>, and if either the input sequence has a putback position available or the function makes a putback position available, decrements the next pointer for the input sequence, <span class='texttt'>gptr()</span>. Returns: <span class='texttt'>traits_type::not_eof(c)</span>.
</p></li></ul></div></div><div class='para' id='socket.streambuf.virtual-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.virtual-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>traits_type::eof()</span> to indicate failure.</p></div></div><div class='para' id='socket.streambuf.virtual-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.virtual-5'>5</a></div><div class='itemdescr'><p >Notes: The function does not put back a character directly to the input sequence. If the function can succeed in more than one of these ways, it is unspecified which way is chosen. The function can alter the number of putback positions available as a result of any call.
</p></div></div><p ><code class='itemdecl'>
virtual int_type overflow(int_type c = traits_type::eof()) override;
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.virtual-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.virtual-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Behaves according to the description of <span class='texttt'>basic_streambuf&lt;char&gt;::overflow(c)</span>, except that the behavior of “consuming characters” is performed by output of the characters to the socket as if by one or more calls to POSIX <span class='texttt'>sendmsg</span>, and <span class='texttt'>ec_</span> is set to reflect the error code produced by the operation. If the operation does not complete before the absolute timeout specified by <span class='texttt'>expiry_</span>, the socket is closed and <span class='texttt'>ec_</span> is set to <span class='texttt'>errc::timed_out</span>.</p></div></div><div class='para' id='socket.streambuf.virtual-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.virtual-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>traits_type::not_eof(c)</span> to indicate success, and <span class='texttt'>traits_type::eof()</span> to indicate failure.
</p></div></div><p ><code class='itemdecl'>
virtual int sync() override;
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.virtual-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.virtual-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> If a put area exists, calls <span class='texttt'>overflow(traits_type::eof())</span> to flush characters.
</p></div></div><p ><code class='itemdecl'>
virtual streambuf* setbuf(char_type* s, streamsize n) override;
</code></p><div class='itemdescr'></div><div class='para' id='socket.streambuf.virtual-9'><div class='marginalizedparent'><a class='marginalized' href='#socket.streambuf.virtual-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>setbuf(nullptr, 0)</span> is called on a stream before any I/O has occurred on that stream, the stream becomes unbuffered. Otherwise the results are unspecified. “Unbuffered” means that <span class='texttt'>pbase()</span> and <span class='texttt'>pptr()</span> always return null and output to the socket should appear as soon as possible.
</p></div></div></div></div><div id='socket.iostream'><h2 ><a class='secnum' href='#socket.iostream' style='min-width:88pt'>19.2</a> Class template <span class='texttt'>basic_socket_iostream</span> <a class='abbr_ref' href='socket.iostream'>[socket.iostream]</a></h2><div class='para' id='socket.iostream-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream-1'>1</a></div><p >The class template <span class='texttt'>basic_socket_iostream&lt;Protocol, Clock, WaitTraits&gt;</span> supports reading and writing on sockets. It uses a <span class='texttt'>basic_socket_streambuf&lt;Protocol, Clock, WaitTraits&gt;</span> object to control the associated sequences.</p></div><div class='para' id='socket.iostream-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream-2'>2</a></div><p >[&nbsp;<i>Note:</i> This class is intended for sending and receiving bytes, not characters. The conversion from characters to bytes, and vice versa, must occur elsewhere. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Protocol, class Clock, class WaitTraits&gt;
  class basic_socket_iostream : public basic_iostream&lt;char&gt;
  {
  public:
    <span class='comment'>// types:
</span>
    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;
    using clock_type = Clock;
    using time_point = typename clock_type::time_point;
    using duration = typename clock_type::duration;
    using wait_traits_type = WaitTraits;

    <span class='comment'>// construct / copy / destroy:
</span>
    basic_socket_iostream();
    explicit basic_socket_iostream(basic_stream_socket&lt;protocol_type&gt; s);
    basic_socket_iostream(const basic_socket_iostream&amp;) = delete;
    basic_socket_iostream(basic_socket_iostream&amp;&amp; rhs);
    template&lt;class... Args&gt;
      explicit basic_socket_iostream(Args&amp;&amp;... args);

    basic_socket_iostream&amp; operator=(const basic_socket_iostream&amp;) = delete;
    basic_socket_iostream&amp; operator=(basic_socket_iostream&amp;&amp; rhs);

    <span class='comment'>// members:
</span>
    template&lt;class... Args&gt; void connect(Args&amp;&amp;... args);

    void close();

    basic_socket_streambuf&lt;protocol_type, clock_type, wait_traits_type&gt;* rdbuf() const;

    basic_socket&lt;protocol_type&gt;&amp; socket();
    error_code error() const;

    time_point expiry() const;
    void expires_at(const time_point&amp; t);
    void expires_after(const duration&amp; d);

  private:
    basic_socket_streambuf&lt;protocol_type, clock_type, wait_traits_type&gt; sb_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='socket.iostream-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream-3'>3</a></div><p >Instances of class template <span class='texttt'>basic_socket_iostream</span> meet the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), and <span class='texttt'>MoveAssignable</span> (C++Std &sect;<a href='../n4140/moveassignable'>[moveassignable]</a>).</p></div><div id='socket.iostream.cons'><h3 ><a class='secnum' href='#socket.iostream.cons' style='min-width:103pt'>19.2.1</a> <span class='texttt'>basic_socket_iostream</span> constructors <a class='abbr_ref' href='socket.iostream.cons'>[socket.iostream.cons]</a></h3><p ><code class='itemdecl'>
basic_socket_iostream();
</code></p><div class='itemdescr'></div><div class='para' id='socket.iostream.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the base class as <span class='texttt'>basic_iostream&lt;char&gt;(&amp;sb_)</span>, <span class='texttt'>sb_</span> as <span class='texttt'>basic_socket_streambuf&lt;Protocol, Clock, WaitTraits&gt;()</span>, and performs <span class='texttt'>setf(std::ios_base::unitbuf)</span>.
</p></div></div><p ><code class='itemdecl'>
explicit basic_socket_iostream(basic_stream_socket&lt;protocol_type&gt; s);
</code></p><div class='itemdescr'></div><div class='para' id='socket.iostream.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the base class as <span class='texttt'>basic_iostream&lt;char&gt;(&amp;sb_)</span>, <span class='texttt'>sb_</span> as <span class='texttt'>basic_socket_streambuf&lt;Protocol, Clock, WaitTraits&gt;(std::move(s))</span>, and performs <span class='texttt'>setf(std::ios_base::unitbuf)</span>.
</p></div></div><p ><code class='itemdecl'>
basic_socket_iostream(basic_socket_iostream&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.iostream.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs from the rvalue <span class='texttt'>rhs</span>. This is accomplished by move constructing the base class, and the contained <span class='texttt'>basic_socket_streambuf</span>. Next <span class='texttt'>basic_iostream&lt;char&gt;::set_rdbuf(&amp;sb_)</span> is called to install the contained <span class='texttt'>basic_socket_streambuf</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class... Args&gt;
  explicit basic_socket_iostream(Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='socket.iostream.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the base class as <span class='texttt'>basic_iostream&lt;char&gt;(&amp;sb_)</span>, initializes <span class='texttt'>sb_</span> as <span class='texttt'>basic_socket_streambuf&lt;Protocol, Clock, WaitTraits&gt;()</span>, and performs <span class='texttt'>setf(std::ios_base::unitbuf)</span>. Then calls <span class='texttt'>rdbuf()-&gt;connect(forward&lt;Args&gt;(args)...)</span>. If that function returns a null pointer, calls <span class='texttt'>setstate(failbit)</span>.
</p></div></div><p ><code class='itemdecl'>
basic_socket_iostream&amp; operator=(basic_socket_iostream&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='socket.iostream.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Move assigns the base and members of <span class='texttt'>*this</span> from the base and corresponding members of <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='socket.iostream.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.cons-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='socket.iostream.members'><h3 ><a class='secnum' href='#socket.iostream.members' style='min-width:103pt'>19.2.2</a> <span class='texttt'>basic_socket_iostream</span> members <a class='abbr_ref' href='socket.iostream.members'>[socket.iostream.members]</a></h3><p ><code class='itemdecl'>
template&lt;class... Args&gt;
  void connect(Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='socket.iostream.members-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Calls <span class='texttt'>rdbuf()-&gt;connect(forward&lt;Args&gt;(args)...)</span>. If that function returns a null pointer, calls <span class='texttt'>setstate(failbit)</span> (which may throw <span class='texttt'>ios_base::failure</span>).
</p></div></div><p ><code class='itemdecl'>
void close();
</code></p><div class='itemdescr'></div><div class='para' id='socket.iostream.members-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.members-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Calls <span class='texttt'>rdbuf()-&gt;close()</span>. If that function returns a null pointer, calls <span class='texttt'>setstate(failbit)</span> (which may throw <span class='texttt'>ios_base::failure</span>).
</p></div></div><p ><code class='itemdecl'>
basic_socket_streambuf&lt;protocol_type, clock_type, wait_traits_type&gt;* rdbuf() const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.iostream.members-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.members-3'>3</a></div><div class='itemdescr'><p >Let <span class='texttt'>SB</span> be the type <span class='texttt'>basic_socket_streambuf&lt;protocol_type, clock_type, wait_traits_type&gt;</span>.</p></div></div><div class='para' id='socket.iostream.members-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>const_cast&lt;SB*&gt;(addressof(sb_))</span>.
</p></div></div><p ><code class='itemdecl'>
basic_socket&lt;protocol_type&gt;&amp; socket();
</code></p><div class='itemdescr'></div><div class='para' id='socket.iostream.members-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rdbuf()-&gt;socket()</span>.
</p></div></div><p ><code class='itemdecl'>
error_code error() const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.iostream.members-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rdbuf()-&gt;error()</span>.
</p></div></div><p ><code class='itemdecl'>
time_point expiry() const;
</code></p><div class='itemdescr'></div><div class='para' id='socket.iostream.members-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>rdbuf()-&gt;expiry()</span>.
</p></div></div><p ><code class='itemdecl'>
void expires_at(const time_point&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='socket.iostream.members-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.members-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>rdbuf()-&gt;expires_at(t)</span>.
</p></div></div><p ><code class='itemdecl'>
void expires_after(const duration&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='socket.iostream.members-9'><div class='marginalizedparent'><a class='marginalized' href='#socket.iostream.members-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>rdbuf()-&gt;expires_after(d)</span>.
</p></div></div></div></div></div><div id='socket.algo'><h1 ><a class='secnum' href='#socket.algo' style='min-width:73pt'>20</a> Socket algorithms <a class='abbr_ref' href='./#socket.algo'>[socket.algo]</a></h1><div id='socket.algo.connect'><h2 ><a class='secnum' href='#socket.algo.connect' style='min-width:88pt'>20.1</a> Synchronous connect operations <a class='abbr_ref' href='socket.algo.connect'>[socket.algo.connect]</a></h2><p ><code class='itemdecl'>
template&lt;class Protocol, class EndpointSequence&gt;
  typename Protocol::endpoint connect(basic_socket&lt;Protocol&gt;&amp; s,
                                      const EndpointSequence&amp; endpoints);
template&lt;class Protocol, class InputIterator&gt;
  typename Protocol::endpoint connect(basic_socket&lt;Protocol&gt;&amp; s,
                                      const EndpointSequence&amp; endpoints,
                                      error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.algo.connect-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.connect-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>connect(s, endpoints, [](auto, auto){ return true; }, ec)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol, class EndpointSequence, class ConnectCondition&gt;
  typename Protocol::endpoint connect(basic_socket&lt;Protocol&gt;&amp; s,
                                      const EndpointSequence&amp; endpoints,
                                      ConnectCondition c);
template&lt;class Protocol, class InputIterator, class ConnectCondition&gt;
  typename Protocol::endpoint connect(basic_socket&lt;Protocol&gt;&amp; s,
                                      const EndpointSequence&amp; endpoints,
                                      ConnectCondition c, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.algo.connect-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.connect-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Performs <span class='texttt'>ec.clear()</span>, then finds the first element <span class='texttt'>ep</span> in the sequence <span class='texttt'>endpoints</span> for which:
</p><ul class='itemize'><li id='socket.algo.connect-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.connect-2.1'>(2.1)</a></div><p ><span class='texttt'>c(ec, ep)</span> yields <span class='texttt'>true</span>;
</p></li><li id='socket.algo.connect-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.connect-2.2'>(2.2)</a></div><p ><span class='texttt'>s.close(ec)</span> succeeds;
</p></li><li id='socket.algo.connect-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.connect-2.3'>(2.3)</a></div><p ><span class='texttt'>s.open(ep.protocol(), ec)</span> succeeds; and
</p></li><li id='socket.algo.connect-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.connect-2.4'>(2.4)</a></div><p ><span class='texttt'>s.connect(ep, ec)</span> succeeds.
</p></li></ul></div></div><div class='para' id='socket.algo.connect-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.connect-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>typename Protocol::endpoint()</span> if no such element is found, otherwise <span class='texttt'>ep</span>.</p></div></div><div class='para' id='socket.algo.connect-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.connect-4'>4</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.algo.connect-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.connect-4.1'>(4.1)</a></div><p ><span class='texttt'>socket_errc::not_found</span> — if <span class='texttt'>endpoints.empty()</span> or if the function object <span class='texttt'>c</span> returned <span class='texttt'>false</span> for all elements in the sequence.
</p></li></ul></div></div><p ><code class='itemdecl'>
template&lt;class Protocol, class InputIterator&gt;
  InputIterator connect(basic_socket&lt;Protocol&gt;&amp; s,
                        InputIterator first, InputIterator last);
template&lt;class Protocol, class InputIterator&gt;
  InputIterator connect(basic_socket&lt;Protocol&gt;&amp; s,
                        InputIterator first, InputIterator last,
                        error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.algo.connect-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.connect-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>connect(s, first, last, [](auto, auto){ return true; }, ec)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol, class InputIterator, class ConnectCondition&gt;
  InputIterator connect(basic_socket&lt;Protocol&gt;&amp; s,
                        InputIterator first, InputIterator last,
                        ConnectCondition c);
template&lt;class Protocol, class InputIterator, class ConnectCondition&gt;
  InputIterator connect(basic_socket&lt;Protocol&gt;&amp; s,
                        InputIterator first, InputIterator last,
                        ConnectCondition c, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='socket.algo.connect-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.connect-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Performs <span class='texttt'>ec.clear()</span>, then finds the first iterator <span class='texttt'>i</span> in the range <span class='texttt'>[first, last)</span> for which:
</p><ul class='itemize'><li id='socket.algo.connect-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.connect-6.1'>(6.1)</a></div><p ><span class='texttt'>c(ec, *i)</span> yields <span class='texttt'>true</span>;
</p></li><li id='socket.algo.connect-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.connect-6.2'>(6.2)</a></div><p ><span class='texttt'>s.close(ec)</span> succeeds;
</p></li><li id='socket.algo.connect-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.connect-6.3'>(6.3)</a></div><p ><span class='texttt'>s.open(typename Protocol::endpoint(*i).protocol(), ec)</span> succeeds; and
</p></li><li id='socket.algo.connect-6.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.connect-6.4'>(6.4)</a></div><p ><span class='texttt'>s.connect(*i, ec)</span> succeeds.
</p></li></ul></div></div><div class='para' id='socket.algo.connect-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.connect-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>last</span> if no such iterator is found, otherwise <span class='texttt'>i</span>.</p></div></div><div class='para' id='socket.algo.connect-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.connect-8'>8</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.algo.connect-8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.connect-8.1'>(8.1)</a></div><p ><span class='texttt'>socket_errc::not_found</span> — if <span class='texttt'>first == last</span> or if the function object <span class='texttt'>c</span> returned <span class='texttt'>false</span> for all iterators in the range.
</p></li></ul></div></div></div><div id='socket.algo.async.connect'><h2 ><a class='secnum' href='#socket.algo.async.connect' style='min-width:88pt'>20.2</a> Asynchronous connect operations <a class='abbr_ref' href='socket.algo.async.connect'>[socket.algo.async.connect]</a></h2><p ><code class='itemdecl'>
template&lt;class Protocol, class EndpointSequence, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_connect(basic_socket&lt;Protocol&gt;&amp; s,
                        const EndpointSequence&amp; endpoints,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.algo.async.connect-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.async.connect-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>async_connect(s, endpoints, [](auto, auto){ return true; }, forward&lt;CompletionToken&gt;(token))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol, class InputIterator,
  class ConnectCondition, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_connect(basic_socket&lt;Protocol&gt;&amp; s,
                          const EndpointSequence&amp; endpoints,
                          ConnectCondition c,
                          CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.algo.async.connect-2'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.async.connect-2'>2</a></div><div class='itemdescr'><p >A composed asynchronous operation (<a href='async.reqmts.async.composed'>[async.reqmts.async.composed]</a>).</p></div></div><div class='para' id='socket.algo.async.connect-3'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.async.connect-3'>3</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, typename Protocol::endpoint ep)</span>.</p></div></div><div class='para' id='socket.algo.async.connect-4'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.async.connect-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Performs <span class='texttt'>ec.clear()</span>, then finds the first element <span class='texttt'>ep</span> in the sequence <span class='texttt'>endpoints</span> for which:
</p><ul class='itemize'><li id='socket.algo.async.connect-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.async.connect-4.1'>(4.1)</a></div><p ><span class='texttt'>c(ec, ep)</span> yields <span class='texttt'>true</span>;
</p></li><li id='socket.algo.async.connect-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.async.connect-4.2'>(4.2)</a></div><p ><span class='texttt'>s.close(ec)</span> succeeds;
</p></li><li id='socket.algo.async.connect-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.async.connect-4.3'>(4.3)</a></div><p ><span class='texttt'>s.open(ep.protocol(), ec)</span> succeeds; and
</p></li><li id='socket.algo.async.connect-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.async.connect-4.4'>(4.4)</a></div><p >the asynchronous operation <span class='texttt'>s.async_connect(ep, <i><span class='texttt'>unspecified</span></i>)</span> succeeds.
</p></li></ul></div></div><div class='para' id='socket.algo.async.connect-5'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.async.connect-5'>5</a></div><div class='itemdescr'><p ><span class='texttt'>ec</span> is updated with the result of the <span class='texttt'>s.async_connect(ep, <i><span class='texttt'>unspecified</span></i>)</span> operation, if any. If no such element is found, or if the operation fails with one of the error conditions listed below, <span class='texttt'>ep</span> is set to <span class='texttt'>typename Protocol::endpoint()</span>. [&nbsp;<i>Note:</i> The underlying <span class='texttt'>close</span>, <span class='texttt'>open</span>, and <span class='texttt'>async_connect</span> operations are performed sequentially. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='socket.algo.async.connect-6'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.async.connect-6'>6</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.algo.async.connect-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.async.connect-6.1'>(6.1)</a></div><p ><span class='texttt'>socket_errc::not_found</span> — if <span class='texttt'>endpoints.empty()</span> or if the function object <span class='texttt'>c</span> returned <span class='texttt'>false</span> for all elements in the sequence.
</p></li><li id='socket.algo.async.connect-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.async.connect-6.2'>(6.2)</a></div><p ><span class='texttt'>errc::operation_canceled</span> — if <span class='texttt'>s.is_open() == false</span> immediately following an <span class='texttt'>async_connect</span> operation on the underlying socket.
</p></li></ul></div></div><p ><code class='itemdecl'>
template&lt;class Protocol, class InputIterator, class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_connect(basic_socket&lt;Protocol&gt;&amp; s,
                        InputIterator first, InputIterator last,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.algo.async.connect-7'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.async.connect-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>async_connect(s, first, last, [](auto, auto){ return true; }, forward&lt;CompletionToken&gt;(token))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol, class InputIterator,
  class ConnectCondition, class CompletionToken&gt;
    <i><span class='texttt'>DEDUCED</span></i> async_connect(basic_socket&lt;Protocol&gt;&amp; s,
                          InputIterator first, InputIterator last,
                          ConnectCondition c,
                          CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='socket.algo.async.connect-8'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.async.connect-8'>8</a></div><div class='itemdescr'><p >A composed asynchronous operation (<a href='async.reqmts.async.composed'>[async.reqmts.async.composed]</a>).</p></div></div><div class='para' id='socket.algo.async.connect-9'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.async.connect-9'>9</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, InputIterator i)</span>.</p></div></div><div class='para' id='socket.algo.async.connect-10'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.async.connect-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Performs <span class='texttt'>ec.clear()</span>, then finds the first iterator <span class='texttt'>i</span> in the range <span class='texttt'>[first, last)</span> for which:
</p><ul class='itemize'><li id='socket.algo.async.connect-10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.async.connect-10.1'>(10.1)</a></div><p ><span class='texttt'>c(ec, *i)</span> yields <span class='texttt'>true</span>;
</p></li><li id='socket.algo.async.connect-10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.async.connect-10.2'>(10.2)</a></div><p ><span class='texttt'>s.close(ec)</span> succeeds;
</p></li><li id='socket.algo.async.connect-10.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.async.connect-10.3'>(10.3)</a></div><p ><span class='texttt'>s.open(typename Protocol::endpoint(*i).protocol(), ec)</span> succeeds; and
</p></li><li id='socket.algo.async.connect-10.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.async.connect-10.4'>(10.4)</a></div><p >the asynchronous operation <span class='texttt'>s.async_connect(*i, <i><span class='texttt'>unspecified</span></i>)</span> succeeds.
</p></li></ul></div></div><div class='para' id='socket.algo.async.connect-11'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.async.connect-11'>11</a></div><div class='itemdescr'><p ><span class='texttt'>ec</span> is updated with the result of the <span class='texttt'>s.async_connect(*i, <i><span class='texttt'>unspecified</span></i>)</span> operation, if any. If no such iterator is found, or if the operation fails with one of the error conditions listed below, <span class='texttt'>i</span> is set to <span class='texttt'>last</span>. [&nbsp;<i>Note:</i> The underlying <span class='texttt'>close</span>, <span class='texttt'>open</span>, and <span class='texttt'>async_connect</span> operations are performed sequentially. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='socket.algo.async.connect-12'><div class='marginalizedparent'><a class='marginalized' href='#socket.algo.async.connect-12'>12</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='socket.algo.async.connect-12.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.async.connect-12.1'>(12.1)</a></div><p ><span class='texttt'>socket_errc::not_found</span> — if <span class='texttt'>first == last</span> or if the function object <span class='texttt'>c</span> returned <span class='texttt'>false</span> for all iterators in the range.
</p></li><li id='socket.algo.async.connect-12.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#socket.algo.async.connect-12.2'>(12.2)</a></div><p ><span class='texttt'>errc::operation_canceled</span> — if <span class='texttt'>s.is_open() == false</span> immediately following an <span class='texttt'>async_connect</span> operation on the underlying socket.
</p></li></ul></div></div></div></div><div id='internet'><h1 ><a class='secnum' href='#internet' style='min-width:73pt'>21</a> Internet protocol <a class='abbr_ref' href='./#internet'>[internet]</a></h1><p ><span class='indexparent'><a class='index' id='experimental/internet'></a></span></p><div id='internet.synop'><h2 ><a class='secnum' href='#internet.synop' style='min-width:88pt'>21.1</a> Header <span class='texttt'>&lt;experimental/internet&gt;</span> synopsis <a class='abbr_ref' href='internet.synop'>[internet.synop]</a></h2><p ><span class='indexparent'><a class='index' id='resolver_errc'></a></span><span class='indexparent'><a class='index' id='port_type'></a></span><span class='indexparent'><a class='index' id='scope_id_type'></a></span><span class='indexparent'><a class='index' id='v4_mapped_t'></a></span><span class='indexparent'><a class='index' id='v4_mapped'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  enum class resolver_errc {
    host_not_found = <i>an <span class='indexparent'><a class='index' id='value_of_the_host_not_found_error_code'></a></span>implementation-defined non-zero value</i>, <span class='comment'>// <i>EAI_NONAME</i>
</span>    host_not_found_try_again = <i>an <span class='indexparent'><a class='index' id='value_of_the_host_not_found_try_again_error_code'></a></span>implementation-defined non-zero value</i>, <span class='comment'>// <i>EAI_AGAIN</i>
</span>    service_not_found = <i>an <span class='indexparent'><a class='index' id='value_of_the_service_not_found_error_code'></a></span>implementation-defined non-zero value</i> <span class='comment'>// <i>EAI_SERVICE</i>
</span>  };

  const error_category&amp; resolver_category() noexcept;

  error_code make_error_code(resolver_errc e) noexcept;
  error_condition make_error_condition(resolver_errc e) noexcept;

  using port_type = uint_least16_t;
  using scope_id_type = uint_least32_t;

  struct v4_mapped_t {};
  constexpr v4_mapped_t v4_mapped;

  class address;
  class address_v4;
  class address_v6;

  class bad_address_cast;

  <span class='comment'>// address comparisons:
</span>  constexpr bool operator==(const address&amp;, const address&amp;) noexcept;
  constexpr bool operator!=(const address&amp;, const address&amp;) noexcept;
  constexpr bool operator&lt; (const address&amp;, const address&amp;) noexcept;
  constexpr bool operator&gt; (const address&amp;, const address&amp;) noexcept;
  constexpr bool operator&lt;=(const address&amp;, const address&amp;) noexcept;
  constexpr bool operator&gt;=(const address&amp;, const address&amp;) noexcept;

  <span class='comment'>// address_v4 comparisons:
</span>  constexpr bool operator==(const address_v4&amp;, const address_v4&amp;) noexcept;
  constexpr bool operator!=(const address_v4&amp;, const address_v4&amp;) noexcept;
  constexpr bool operator&lt; (const address_v4&amp;, const address_v4&amp;) noexcept;
  constexpr bool operator&gt; (const address_v4&amp;, const address_v4&amp;) noexcept;
  constexpr bool operator&lt;=(const address_v4&amp;, const address_v4&amp;) noexcept;
  constexpr bool operator&gt;=(const address_v4&amp;, const address_v4&amp;) noexcept;

  <span class='comment'>// address_v6 comparisons:
</span>  constexpr bool operator==(const address_v6&amp;, const address_v6&amp;) noexcept;
  constexpr bool operator!=(const address_v6&amp;, const address_v6&amp;) noexcept;
  constexpr bool operator&lt; (const address_v6&amp;, const address_v6&amp;) noexcept;
  constexpr bool operator&gt; (const address_v6&amp;, const address_v6&amp;) noexcept;
  constexpr bool operator&lt;=(const address_v6&amp;, const address_v6&amp;) noexcept;
  constexpr bool operator&gt;=(const address_v6&amp;, const address_v6&amp;) noexcept;

  <span class='comment'>// address creation:
</span>  address make_address(const char*);
  address make_address(const char*, error_code&amp;) noexcept;
  address make_address(const string&amp;);
  address make_address(const string&amp;, error_code&amp;) noexcept;
  address make_address(string_view);
  address make_address(string_view, error_code&amp;) noexcept;

  <span class='comment'>// address_v4 creation:
</span>  constexpr address_v4 make_address_v4(const address_v4::bytes_type&amp;);
  constexpr address_v4 make_address_v4(address_v4::uint_type);
  constexpr address_v4 make_address_v4(v4_mapped_t, const address_v6&amp;);
  address_v4 make_address_v4(const char*);
  address_v4 make_address_v4(const char*, error_code&amp;) noexcept;
  address_v4 make_address_v4(const string&amp;);
  address_v4 make_address_v4(const string&amp;, error_code&amp;) noexcept;
  address_v4 make_address_v4(string_view);
  address_v4 make_address_v4(string_view, error_code&amp;) noexcept;

  <span class='comment'>// address_v6 creation:
</span>  constexpr address_v6 make_address_v6(const address_v6::bytes_type&amp;,
                                       scope_id_type = 0);
  constexpr address_v6 make_address_v6(v4_mapped_t, const address_v4&amp;) noexcept;
  address_v6 make_address_v6(const char*);
  address_v6 make_address_v6(const char*, error_code&amp;) noexcept;
  address_v6 make_address_v6(const string&amp;);
  address_v6 make_address_v6(const string&amp;, error_code&amp;) noexcept;
  address_v6 make_address_v6(string_view);
  address_v6 make_address_v6(string_view, error_code&amp;) noexcept;

  <span class='comment'>// address I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp;, const address&amp;);

  <span class='comment'>// address_v4 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp;, const address_v4&amp;);

  <span class='comment'>// address_v6 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp;, const address_v6&amp;);

  template&lt;class&gt; class basic_address_iterator; <span class='comment'>// <i>not defined</i>
</span>  template&lt;&gt; class basic_address_iterator&lt;address_v4&gt;;
  using address_v4_iterator = basic_address_iterator&lt;address_v4&gt;;
  template&lt;&gt; class basic_address_iterator&lt;address_v6&gt;;
  using address_v6_iterator = basic_address_iterator&lt;address_v6&gt;;

  template&lt;class&gt; class basic_address_range; <span class='comment'>// <i>not defined</i>
</span>  template&lt;&gt; class basic_address_range&lt;address_v4&gt;;
  using address_v4_range = basic_address_range&lt;address_v4&gt;;
  template&lt;&gt; class basic_address_range&lt;address_v6&gt;;
  using address_v6_range = basic_address_range&lt;address_v6&gt;;

  class network_v4;
  class network_v6;

  <span class='comment'>// network_v4 comparisons:
</span>  bool operator==(const network_v4&amp;, const network_v4&amp;) noexcept;
  bool operator!=(const network_v4&amp;, const network_v4&amp;) noexcept;

  <span class='comment'>// network_v6 comparisons:
</span>  bool operator==(const network_v6&amp;, const network_v6&amp;) noexcept;
  bool operator!=(const network_v6&amp;, const network_v6&amp;) noexcept;

  <span class='comment'>// network_v4 creation:
</span>  network_v4 make_network_v4(const address_v4&amp;, int);
  network_v4 make_network_v4(const address_v4&amp;, const address_v4&amp;);
  network_v4 make_network_v4(const char*);
  network_v4 make_network_v4(const char*, error_code&amp;) noexcept;
  network_v4 make_network_v4(const string&amp;);
  network_v4 make_network_v4(const string&amp;, error_code&amp;) noexcept;
  network_v4 make_network_v4(string_view);
  network_v4 make_network_v4(string_view, error_code&amp;) noexcept;

  <span class='comment'>// network_v6 creation:
</span>  network_v6 make_network_v6(const address_v6&amp;, int);
  network_v6 make_network_v6(const char*);
  network_v6 make_network_v6(const char*, error_code&amp;) noexcept;
  network_v6 make_network_v6(const string&amp;);
  network_v6 make_network_v6(const string&amp;, error_code&amp;) noexcept;
  network_v6 make_network_v6(string_view);
  network_v6 make_network_v6(string_view, error_code&amp;) noexcept;

  <span class='comment'>// network_v4 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp;, const network_v4&amp;);

  <span class='comment'>// network_v6 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp;, const network_v6&amp;);

  template&lt;class InternetProtocol&gt;
    class basic_endpoint;

  <span class='comment'>// basic_endpoint comparisons:
</span>  template&lt;class InternetProtocol&gt;
    bool operator==(const basic_endpoint&lt;InternetProtocol&gt;&amp;,
                    const basic_endpoint&lt;InternetProtocol&gt;&amp;);
  template&lt;class InternetProtocol&gt;
    bool operator!=(const basic_endpoint&lt;InternetProtocol&gt;&amp;,
                    const basic_endpoint&lt;InternetProtocol&gt;&amp;);
  template&lt;class InternetProtocol&gt;
    bool operator&lt; (const basic_endpoint&lt;InternetProtocol&gt;&amp;,
                    const basic_endpoint&lt;InternetProtocol&gt;&amp;);
  template&lt;class InternetProtocol&gt;
    bool operator&gt; (const basic_endpoint&lt;InternetProtocol&gt;&amp;,
                    const basic_endpoint&lt;InternetProtocol&gt;&amp;);
  template&lt;class InternetProtocol&gt;
    bool operator&lt;=(const basic_endpoint&lt;InternetProtocol&gt;&amp;,
                    const basic_endpoint&lt;InternetProtocol&gt;&amp;);
  template&lt;class InternetProtocol&gt;
    bool operator&gt;=(const basic_endpoint&lt;InternetProtocol&gt;&amp;,
                    const basic_endpoint&lt;InternetProtocol&gt;&amp;);

  <span class='comment'>// basic_endpoint I/O:
</span>  template&lt;class CharT, class Traits, class InternetProtocol&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp;,
      const basic_endpoint&lt;InternetProtocol&gt;&amp;);

  template&lt;class InternetProtocol&gt;
    class basic_resolver_entry;

  template&lt;class InternetProtocol&gt;
    bool operator==(const basic_resolver_entry&lt;InternetProtocol&gt;&amp;,
                    const basic_resolver_entry&lt;InternetProtocol&gt;&amp;);
  template&lt;class InternetProtocol&gt;
    bool operator!=(const basic_resolver_entry&lt;InternetProtocol&gt;&amp;,
                    const basic_resolver_entry&lt;InternetProtocol&gt;&amp;);

  template&lt;class InternetProtocol&gt;
    class basic_resolver_results;

  template&lt;class InternetProtocol&gt;
    bool operator==(const basic_resolver_results&lt;InternetProtocol&gt;&amp;,
                    const basic_resolver_results&lt;InternetProtocol&gt;&amp;);
  template&lt;class InternetProtocol&gt;
    bool operator!=(const basic_resolver_results&lt;InternetProtocol&gt;&amp;,
                    const basic_resolver_results&lt;InternetProtocol&gt;&amp;);

  class resolver_base;

  template&lt;class InternetProtocol&gt;
    class basic_resolver;

  string host_name();
  string host_name(error_code&amp;);
  template&lt;class Allocator&gt;
    basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
      host_name(const Allocator&amp;);
  template&lt;class Allocator&gt;
    basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
      host_name(const Allocator&amp;, error_code&amp;);

  class tcp;

  <span class='comment'>// tcp comparisons:
</span>  bool operator==(const tcp&amp; a, const tcp&amp; b);
  bool operator!=(const tcp&amp; a, const tcp&amp; b);

  class udp;

  <span class='comment'>// udp comparisons:
</span>  bool operator==(const udp&amp; a, const udp&amp; b);
  bool operator!=(const udp&amp; a, const udp&amp; b);

  class v6_only;

  namespace unicast {

    class hops;

  } <span class='comment'>// namespace unicast
</span>
  namespace multicast {

    class join_group;

    class leave_group;

    class outbound_interface;

    class hops;

    class enable_loopback;

  } <span class='comment'>// namespace multicast
</span>} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>
  template&lt;&gt; struct is_error_condition_enum&lt;
    experimental::net::v1::ip::resolver_errc&gt;
      : public true_type {};

  <span class='comment'>// hash support
</span>  template&lt;class T&gt; struct hash;
  template&lt;&gt; struct hash&lt;experimental::net::v1::ip::address&gt;;
  template&lt;&gt; struct hash&lt;experimental::net::v1::ip::address_v4&gt;;
  template&lt;&gt; struct hash&lt;experimental::net::v1::ip::address_v6&gt;;

} <span class='comment'>// namespace std
</span></pre></div><div id='internet.reqmts'><h2 ><a class='secnum' href='#internet.reqmts' style='min-width:88pt'>21.2</a> Requirements <a class='abbr_ref' href='internet.reqmts'>[internet.reqmts]</a></h2><p ><span class='indexparent'><a class='index' id='InternetProtocol'></a></span><span class='indexparent'><a class='index' id='requirements,InternetProtocol'></a></span></p><div id='internet.reqmts.protocol'><h3 ><a class='secnum' href='#internet.reqmts.protocol' style='min-width:103pt'>21.2.1</a> Internet protocol requirements <a class='abbr_ref' href='internet.reqmts.protocol'>[internet.reqmts.protocol]</a></h3><div class='para' id='internet.reqmts.protocol-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.reqmts.protocol-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>InternetProtocol</span> requirements if it satisfies the requirements of <span class='texttt'>AcceptableProtocol</span> (<a href='socket.reqmts.acceptableprotocol'>[socket.reqmts.acceptableprotocol]</a>), as well as the additional requirements listed below.</p></div><div class='para' id='internet.reqmts.protocol-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.reqmts.protocol-2'>2</a></div><p >In the table below,
<span class='texttt'>a</span> and <span class='texttt'>b</span> denote values of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>.</p><div class='numberedTable' id='tab:internet.reqmts.protocol.requirements'>Table <a href='#tab:internet.reqmts.protocol.requirements'>35</a> — InternetProtocol requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::resolver</span>  </td><td class='left'>
<span class='texttt'>ip::basic_resolver&lt;X&gt;</span>  </td><td class='left'>
 The type of a resolver for the protocol.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::v4()</span>  </td><td class='left'>
<span class='texttt'>X</span>  </td><td class='left'>
 Returns an object representing the IP version 4 protocol.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::v6()</span>  </td><td class='left'>
<span class='texttt'>X</span>  </td><td class='left'>
 Returns an object representing the IP version 6 protocol.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a == b</span>  </td><td class='left'>
convertible to <span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>true</span> if <span class='texttt'>a</span> and <span class='texttt'>b</span> represent the same IP protocol version, otherwise <span class='texttt'>false</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a != b</span>  </td><td class='left'>
convertible to <span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>!(a == b)</span>.  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='MulticastGroupSocketOption'></a></span><span class='indexparent'><a class='index' id='requirements,MulticastGroupSocketOption'></a></span></p></div></div><div id='internet.reqmts.opt.mcast'><h3 ><a class='secnum' href='#internet.reqmts.opt.mcast' style='min-width:103pt'>21.2.2</a> Multicast group socket options <a class='abbr_ref' href='internet.reqmts.opt.mcast'>[internet.reqmts.opt.mcast]</a></h3><div class='para' id='internet.reqmts.opt.mcast-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.reqmts.opt.mcast-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>MulticastGroupSocketOption</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>), and <span class='texttt'>SettableSocketOption</span> (<a href='socket.reqmts.settablesocketoption'>[socket.reqmts.settablesocketoption]</a>), as well as the additional requirements listed below.</p></div><div class='para' id='internet.reqmts.opt.mcast-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.reqmts.opt.mcast-2'>2</a></div><p >In the table below,
<span class='texttt'>a</span> denotes a value of type <span class='texttt'>address</span> or <span class='texttt'>const address</span>,
<span class='texttt'>b</span> and <span class='texttt'>c</span> denote values of type <span class='texttt'>address_v4</span> or <span class='texttt'>const address_v4</span>,
<span class='texttt'>d</span> denotes a value of type <span class='texttt'>address_v6</span> or <span class='texttt'>const address_v6</span>,
<span class='texttt'>e</span> denotes a value of type <span class='texttt'>unsigned int</span> or <span class='texttt'>const unsigned int</span>,
and <span class='texttt'>u</span> denotes an identifier.</p><div class='numberedTable' id='tab:internet.reqmts.opt.mcast.requirements'>Table <a href='#tab:internet.reqmts.opt.mcast.requirements'>36</a> — MulticastGroupSocketOption requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X u(a);</span>  </td><td class='left'>
  </td><td class='left'>
 Constructs a multicast group socket option to join the group with the specified version-independent address.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(b, c);</span>  </td><td class='left'>
  </td><td class='left'>
 Constructs a multicast group socket option to join the specified IPv4 address on a specified network interface.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(d, e);</span>  </td><td class='left'>
  </td><td class='left'>
 Constructs a multicast group socket option to join the specified IPv6 address on a specified network interface.  </td></tr></table></div></div><div class='para' id='internet.reqmts.opt.mcast-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.reqmts.opt.mcast-3'>3</a></div><p >In this Technical Specification, types that satisfy the <span class='texttt'>MulticastGroupSocketOption</span> requirements are defined as follows.</p><pre class='codeblock'>
class <i>C</i>{
public:
  <span class='comment'>// constructors:
</span>  explicit <i>C</i>(const address&amp; multicast_group) noexcept;
  explicit <i>C</i>(const address_v4&amp; multicast_group,
             const address_v4&amp; network_interface = address_v4::any()) noexcept;
  explicit <i>C</i>(const address_v6&amp; multicast_group,
             unsigned int network_interface = 0) noexcept;
};
</pre><p ><span class='indexparent'><a class='index' id='extensible_implementation,MulticastGroupSocketOption'></a></span><span class='indexparent'><a class='index' id='MulticastGroupSocketOption,extensible_implementation'></a></span></p></div><div class='para' id='internet.reqmts.opt.mcast-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.reqmts.opt.mcast-4'>4</a></div><p >Extensible implementations provide the following member functions:</p><pre class='codeblock'>
class <i>C</i>{
public:
  template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
  template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
  template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
  template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
  <span class='comment'>// <i>remainder unchanged</i>
</span>private:
  ip_mreq v4_value_; <span class='comment'>// <i>exposition only</i>
</span>  ipv6_mreq v6_value_; <span class='comment'>// <i>exposition only</i>
</span>};
</pre></div><div class='para' id='internet.reqmts.opt.mcast-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.reqmts.opt.mcast-5'>5</a></div><p >Let <i>L</i> and <i>N</i> identify the POSIX macros to be passed as the <span class='texttt'>level</span> and <span class='texttt'>option_name</span> arguments, respectively, to POSIX <span class='texttt'>setsockopt</span> and <span class='texttt'>getsockopt</span>.</p><p ><code class='itemdecl'>
explicit <i>C</i>(const address&amp; multicast_group) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='internet.reqmts.opt.mcast-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.reqmts.opt.mcast-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>multicast_group.is_v6()</span> is <span class='texttt'>true</span>, calls <i>C</i><span class='texttt'>(multicast_group.to_v6())</span>; otherwise, calls <i>C</i><span class='texttt'>(multicast_group.to_v4())</span>.
</p></div></div><p ><code class='itemdecl'>
explicit <i>C</i>(const address_v4&amp; multicast_group,
           const address_v4&amp; network_interface = address_v4::any()) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.reqmts.opt.mcast-7'><div class='marginalizedparent'><a class='marginalized' href='#internet.reqmts.opt.mcast-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> For extensible implementations, <span class='texttt'>v4_value_.imr_multiaddr</span> is initialized to correspond to the address <span class='texttt'>multicast_group</span>, <span class='texttt'>v4_value_.imr_interface</span> is initialized to correspond to address <span class='texttt'>network_interface</span>, and <span class='texttt'>v6_value_</span> is zero-initialized.
</p></div></div><p ><code class='itemdecl'>
explicit <i>C</i>(const address_v6&amp; multicast_group,
           unsigned int network_interface = 0) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.reqmts.opt.mcast-8'><div class='marginalizedparent'><a class='marginalized' href='#internet.reqmts.opt.mcast-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> For extensible implementations, <span class='texttt'>v6_value_.ipv6mr_multiaddr</span> is initialized to correspond to the address <span class='texttt'>multicast_group</span>, <span class='texttt'>v6_value_.ipv6mr_interface</span> is initialized to <span class='texttt'>network_interface</span>, and <span class='texttt'>v4_value_</span> is zero-initialized.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.reqmts.opt.mcast-9'><div class='marginalizedparent'><a class='marginalized' href='#internet.reqmts.opt.mcast-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <i>L</i>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.reqmts.opt.mcast-10'><div class='marginalizedparent'><a class='marginalized' href='#internet.reqmts.opt.mcast-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <i>N</i>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.reqmts.opt.mcast-11'><div class='marginalizedparent'><a class='marginalized' href='#internet.reqmts.opt.mcast-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>addressof(v6_value_)</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>addressof(v4_value_)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.reqmts.opt.mcast-12'><div class='marginalizedparent'><a class='marginalized' href='#internet.reqmts.opt.mcast-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>sizeof(v6_value_)</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>sizeof(v4_value_)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='error_codes,resolver'></a></span></p></div></div><div id='internet.resolver.err'><h2 ><a class='secnum' href='#internet.resolver.err' style='min-width:88pt'>21.3</a> Error codes <a class='abbr_ref' href='internet.resolver.err'>[internet.resolver.err]</a></h2><p ><span class='indexparent'><a class='index' id='resolver_category'></a></span><code class='itemdecl'>
const error_category&amp; resolver_category() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.err-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.err-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to an object of a type derived from class <span class='texttt'>error_category</span>. All calls to this function return references to the same object.</p></div></div><div class='para' id='internet.resolver.err-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.err-2'>2</a></div><div class='itemdescr'><p >The object's <span class='texttt'>default_error_condition</span> and <span class='texttt'>equivalent</span> virtual functions behave as specified for the class <span class='texttt'>error_category</span>. The object's <span class='texttt'>name</span> virtual function returns a pointer to the string <span class='texttt'>"resolver"</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_error_code'></a></span><span class='indexparent'><a class='index' id='resolver_errc,make_error_code'></a></span><code class='itemdecl'>
error_code make_error_code(resolver_errc e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.err-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.err-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>error_code(static_cast&lt;int&gt;(e), resolver_category())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_error_condition'></a></span><span class='indexparent'><a class='index' id='resolver_errc,make_error_condition'></a></span><code class='itemdecl'>
error_condition make_error_condition(resolver_errc e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.err-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.err-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>error_condition(static_cast&lt;int&gt;(e), resolver_category())</span>.
</p></div></div></div><div id='internet.address'><h2 ><a class='secnum' href='#internet.address' style='min-width:88pt'>21.4</a> Class <span class='texttt'>ip::address</span> <a class='abbr_ref' href='internet.address'>[internet.address]</a></h2><div class='para' id='internet.address-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address-1'>1</a></div><p >The class <span class='texttt'>address</span> is a version-independent representation for an IP address. An object of class <span class='texttt'>address</span> holds either an IPv4 address, an IPv6 address, or no valid address.</p><p ><span class='indexparent'><a class='index' id='address'></a></span><span class='indexparent'><a class='index' id='address,is_v4'></a></span><span class='indexparent'><a class='index' id='address,is_v6'></a></span><span class='indexparent'><a class='index' id='address,to_v4'></a></span><span class='indexparent'><a class='index' id='address,to_v6'></a></span><span class='indexparent'><a class='index' id='address,is_unspecified'></a></span><span class='indexparent'><a class='index' id='address,is_loopback'></a></span><span class='indexparent'><a class='index' id='address,is_multicast'></a></span><span class='indexparent'><a class='index' id='address,to_string'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class address
  {
  public:
    <span class='comment'>// constructors:
</span>    constexpr address() noexcept;
    constexpr address(const address&amp; a) noexcept;
    constexpr address(const address_v4&amp; a) noexcept;
    constexpr address(const address_v6&amp; a) noexcept;

    <span class='comment'>// assignment:
</span>    address&amp; operator=(const address&amp; a) noexcept;
    address&amp; operator=(const address_v4&amp; a) noexcept;
    address&amp; operator=(const address_v6&amp; a) noexcept;

    <span class='comment'>// members:
</span>    constexpr bool is_v4() const noexcept;
    constexpr bool is_v6() const noexcept;
    constexpr address_v4 to_v4() const;
    constexpr address_v6 to_v6() const;
    constexpr bool is_unspecified() const noexcept;
    constexpr bool is_loopback() const noexcept;
    constexpr bool is_multicast() const noexcept;
    template&lt;class Allocator = allocator&lt;char&gt;&gt;
      basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
        to_string(const Allocator&amp; a = Allocator()) const;

  private:
    address_v4 v4_; <span class='comment'>// <i>exposition only</i>
</span>    address_v6 v6_; <span class='comment'>// <i>exposition only</i>
</span>  };

  <span class='comment'>// address comparisons:
</span>  constexpr bool operator==(const address&amp; a, const address&amp; b) noexcept;
  constexpr bool operator!=(const address&amp; a, const address&amp; b) noexcept;
  constexpr bool operator&lt; (const address&amp; a, const address&amp; b) noexcept;
  constexpr bool operator&gt; (const address&amp; a, const address&amp; b) noexcept;
  constexpr bool operator&lt;=(const address&amp; a, const address&amp; b) noexcept;
  constexpr bool operator&gt;=(const address&amp; a, const address&amp; b) noexcept;

  <span class='comment'>// address creation:
</span>  address make_address(const char* str);
  address make_address(const char* str, error_code&amp; ec) noexcept;
  address make_address(const string&amp; str);
  address make_address(const string&amp; str, error_code&amp; ec) noexcept;
  address make_address(string_view str);
  address make_address(string_view str, error_code&amp; ec) noexcept;

  <span class='comment'>// address I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp; os, const address&amp; addr);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><span class='indexparent'><a class='index' id='address'></a></span></p></div><div class='para' id='internet.address-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address-2'>2</a></div><p ><span class='texttt'>address</span> satisfies the requirements for <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), and <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>).</p><p ><span class='indexparent'><a class='index' id='address,constructor'></a></span></p></div><div id='internet.address.cons'><h3 ><a class='secnum' href='#internet.address.cons' style='min-width:103pt'>21.4.1</a> <span class='texttt'>ip::address</span> constructors <a class='abbr_ref' href='internet.address.cons'>[internet.address.cons]</a></h3><p ><code class='itemdecl'>
constexpr address() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_v4() == true</span>, <span class='texttt'>is_v6() == false</span>, and <span class='texttt'>is_unspecified() == true</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr address(const address_v4&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>v4_</span> with <span class='texttt'>a</span>.</p></div></div><div class='para' id='internet.address.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_v4() == true</span> and <span class='texttt'>is_v6() == false</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr address(const address_v6&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>v6_</span> with <span class='texttt'>a</span>.</p></div></div><div class='para' id='internet.address.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.cons-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_v4() == false</span> and <span class='texttt'>is_v6() == true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,address'></a></span><span class='indexparent'><a class='index' id='address,operator='></a></span></p></div><div id='internet.address.assign'><h3 ><a class='secnum' href='#internet.address.assign' style='min-width:103pt'>21.4.2</a> <span class='texttt'>ip::address</span> assignment <a class='abbr_ref' href='internet.address.assign'>[internet.address.assign]</a></h3><p ><code class='itemdecl'>
address&amp; operator=(const address_v4&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.assign-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_v4() == true</span> and <span class='texttt'>is_v6() == false</span> and <span class='texttt'>to_v4() == a</span>.</p></div></div><div class='para' id='internet.address.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div><p ><code class='itemdecl'>
address&amp; operator=(const address_v6&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.assign-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_v4() == false</span> and <span class='texttt'>is_v6() == true</span> and <span class='texttt'>to_v6() == a</span>.</p></div></div><div class='para' id='internet.address.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.assign-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div></div><div id='internet.address.members'><h3 ><a class='secnum' href='#internet.address.members' style='min-width:103pt'>21.4.3</a> <span class='texttt'>ip::address</span> members <a class='abbr_ref' href='internet.address.members'>[internet.address.members]</a></h3><p ><span class='indexparent'><a class='index' id='is_v4,address'></a></span><span class='indexparent'><a class='index' id='address,is_v4'></a></span><code class='itemdecl'>
constexpr bool is_v4() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.members-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the object contains an IP version 4 address, otherwise <span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_v6,address'></a></span><span class='indexparent'><a class='index' id='address,is_v6'></a></span><code class='itemdecl'>
constexpr bool is_v6() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.members-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the object contains an IP version 6 address, otherwise <span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_v4,address'></a></span><span class='indexparent'><a class='index' id='address,to_v4'></a></span><code class='itemdecl'>
constexpr address_v4 to_v4() const;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.members-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>v4_</span>.</p></div></div><div class='para' id='internet.address.members-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.members-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>bad_address_cast</span> if <span class='texttt'>is_v4() == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_v6,address'></a></span><span class='indexparent'><a class='index' id='address,to_v6'></a></span><code class='itemdecl'>
constexpr address_v6 to_v6() const;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.members-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>v6_</span>.</p></div></div><div class='para' id='internet.address.members-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.members-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>bad_address_cast</span> if <span class='texttt'>is_v6() == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_unspecified,address'></a></span><span class='indexparent'><a class='index' id='address,is_unspecified'></a></span><code class='itemdecl'>
constexpr bool is_unspecified() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.members-7'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>is_v4()</span>, returns <span class='texttt'>v4_.is_unspecified()</span>. Otherwise returns <span class='texttt'>v6_.is_unspecified()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_loopback,address'></a></span><span class='indexparent'><a class='index' id='address,is_loopback'></a></span><code class='itemdecl'>
constexpr bool is_loopback() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.members-8'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>is_v4()</span>, returns <span class='texttt'>v4_.is_loopback()</span>. Otherwise returns <span class='texttt'>v6_.is_loopback()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_multicast,address'></a></span><span class='indexparent'><a class='index' id='address,is_multicast'></a></span><code class='itemdecl'>
constexpr bool is_multicast() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.members-9'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.members-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>is_v4()</span>, returns <span class='texttt'>v4_.is_multicast()</span>. Otherwise returns <span class='texttt'>v6_.is_multicast()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_string,address'></a></span><span class='indexparent'><a class='index' id='address,to_string'></a></span><code class='itemdecl'>
template&lt;class Allocator = allocator&lt;char&gt;&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    to_string(const Allocator&amp; a = Allocator()) const;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.members-10'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.members-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>is_v4()</span>, returns <span class='texttt'>v4_.to_string(a)</span>. Otherwise returns <span class='texttt'>v6_.to_string(a)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator==,address'></a></span><span class='indexparent'><a class='index' id='address,operator=='></a></span></p></div><div id='internet.address.comparisons'><h3 ><a class='secnum' href='#internet.address.comparisons' style='min-width:103pt'>21.4.4</a> <span class='texttt'>ip::address</span> comparisons <a class='abbr_ref' href='internet.address.comparisons'>[internet.address.comparisons]</a></h3><p ><code class='itemdecl'>
constexpr bool operator==(const address&amp; a, const address&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><ul class='itemize'><li id='internet.address.comparisons-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.address.comparisons-1.1'>(1.1)</a></div><p >if <span class='texttt'>a.is_v4() != b.is_v4()</span>, <span class='texttt'>false</span>;
</p></li><li id='internet.address.comparisons-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.address.comparisons-1.2'>(1.2)</a></div><p >if <span class='texttt'>a.is_v4()</span>, the result of <span class='texttt'>a.v4_ == b.v4_</span>;
</p></li><li id='internet.address.comparisons-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.address.comparisons-1.3'>(1.3)</a></div><p >otherwise, the result of <span class='texttt'>a.v6_ == b.v6_</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='operator!=,address'></a></span><span class='indexparent'><a class='index' id='address,operator!='></a></span><code class='itemdecl'>
constexpr bool operator!=(const address&amp; a, const address&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,address'></a></span><span class='indexparent'><a class='index' id='address,operator<'></a></span><code class='itemdecl'>
constexpr bool operator&lt; (const address&amp; a, const address&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.comparisons-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><ul class='itemize'><li id='internet.address.comparisons-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.address.comparisons-3.1'>(3.1)</a></div><p >if <span class='texttt'>a.is_v4() &amp;&amp; !b.is_v4()</span>, <span class='texttt'>true</span>;
</p></li><li id='internet.address.comparisons-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.address.comparisons-3.2'>(3.2)</a></div><p >if <span class='texttt'>!a.is_v4() &amp;&amp; b.is_v4()</span>, <span class='texttt'>false</span>;
</p></li><li id='internet.address.comparisons-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.address.comparisons-3.3'>(3.3)</a></div><p >if <span class='texttt'>a.is_v4()</span>, the result of <span class='texttt'>a.v4_ &lt; b.v4_</span>;
</p></li><li id='internet.address.comparisons-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.address.comparisons-3.4'>(3.4)</a></div><p >otherwise, the result of <span class='texttt'>a.v6_ &lt; b.v6_</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='operator>,address'></a></span><span class='indexparent'><a class='index' id='address,operator>'></a></span><code class='itemdecl'>
constexpr bool operator&gt; (const address&amp; a, const address&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.comparisons-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>b &lt; a</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,address'></a></span><span class='indexparent'><a class='index' id='address,operator<='></a></span><code class='itemdecl'>
constexpr bool operator&lt;=(const address&amp; a, const address&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.comparisons-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.comparisons-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(b &lt; a)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,address'></a></span><span class='indexparent'><a class='index' id='address,operator>='></a></span><code class='itemdecl'>
constexpr bool operator&gt;=(const address&amp; a, const address&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.comparisons-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.comparisons-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a &lt; b)</span>.
</p></div></div></div><div id='internet.address.creation'><h3 ><a class='secnum' href='#internet.address.creation' style='min-width:103pt'>21.4.5</a> <span class='texttt'>ip::address</span> creation <a class='abbr_ref' href='internet.address.creation'>[internet.address.creation]</a></h3><p ><span class='indexparent'><a class='index' id='make_address'></a></span><code class='itemdecl'>
address make_address(const char* str);
address make_address(const char* str, error_code&amp; ec) noexcept;
address make_address(const string&amp; str);
address make_address(const string&amp; str, error_code&amp; ec) noexcept;
address make_address(string_view str);
address make_address(string_view str, error_code&amp; ec) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.creation-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.creation-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Converts a textual representation of an address into an object of class <span class='texttt'>address</span>, as if by calling:
</p><pre class='codeblock'>
address a;
address_v6 v6a = make_address_v6(str, ec);
if (!ec)
  a = v6a;
else{
  address_v4 v4a = make_address_v4(str, ec);
  if (!ec)
    a = v4a;
}
</pre></div></div><div class='para' id='internet.address.creation-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.creation-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a</span>.
</p></div></div></div><div id='internet.address.io'><h3 ><a class='secnum' href='#internet.address.io' style='min-width:103pt'>21.4.6</a> <span class='texttt'>ip::address</span> I/O <a class='abbr_ref' href='internet.address.io'>[internet.address.io]</a></h3><p ><span class='indexparent'><a class='index' id='operator<<,address'></a></span><span class='indexparent'><a class='index' id='address,operator<<'></a></span><code class='itemdecl'>
template&lt;class CharT, class Traits&gt;
  basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
    basic_ostream&lt;CharT, Traits&gt;&amp; os, const address&amp; addr);
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.io-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.io-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>os &lt;&lt; addr.to_string().c_str()</span>.
</p></div></div></div></div><div id='internet.address.v4'><h2 ><a class='secnum' href='#internet.address.v4' style='min-width:88pt'>21.5</a> Class <span class='texttt'>ip::address_v4</span> <a class='abbr_ref' href='internet.address.v4'>[internet.address.v4]</a></h2><div class='para' id='internet.address.v4-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4-1'>1</a></div><p >The class <span class='texttt'>address_v4</span> is a representation of an IPv4 address.</p><p ><span class='indexparent'><a class='index' id='address_v4'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class address_v4
  {
  public:
    <span class='comment'>// types:
</span>    using uint_type = uint_least32_t;
    struct bytes_type;

    <span class='comment'>// constructors:
</span>    constexpr address_v4() noexcept;
    constexpr address_v4(const address_v4&amp; a) noexcept;
    constexpr address_v4(const bytes_type&amp; bytes);
    explicit constexpr address_v4(uint_type val);

    <span class='comment'>// assignment:
</span>    address_v4&amp; operator=(const address_v4&amp; a) noexcept;

    <span class='comment'>// members:
</span>    constexpr bool is_unspecified() const noexcept;
    constexpr bool is_loopback() const noexcept;
    constexpr bool is_multicast() const noexcept;
    constexpr bytes_type to_bytes() const noexcept;
    constexpr uint_type to_uint() const noexcept;
    template&lt;class Allocator = allocator&lt;char&gt;&gt;
      basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
        to_string(const Allocator&amp; a = Allocator()) const;

    <span class='comment'>// static members:
</span>    static constexpr address_v4 any() noexcept;
    static constexpr address_v4 loopback() noexcept;
    static constexpr address_v4 broadcast() noexcept;
  };

  <span class='comment'>// address_v4 comparisons:
</span>  constexpr bool operator==(const address_v4&amp; a, const address_v4&amp; b) noexcept;
  constexpr bool operator!=(const address_v4&amp; a, const address_v4&amp; b) noexcept;
  constexpr bool operator&lt; (const address_v4&amp; a, const address_v4&amp; b) noexcept;
  constexpr bool operator&gt; (const address_v4&amp; a, const address_v4&amp; b) noexcept;
  constexpr bool operator&lt;=(const address_v4&amp; a, const address_v4&amp; b) noexcept;
  constexpr bool operator&gt;=(const address_v4&amp; a, const address_v4&amp; b) noexcept;

  <span class='comment'>// address_v4 creation:
</span>  constexpr address_v4 make_address_v4(const address_v4::bytes_type&amp; bytes);
  constexpr address_v4 make_address_v4(address_v4::uint_type val);
  constexpr address_v4 make_address_v4(v4_mapped_t, const address_v6&amp; a);
  address_v4 make_address_v4(const char* str);
  address_v4 make_address_v4(const char* str, error_code&amp; ec) noexcept;
  address_v4 make_address_v4(const string&amp; str);
  address_v4 make_address_v4(const string&amp; str, error_code&amp; ec) noexcept;
  address_v4 make_address_v4(string_view str);
  address_v4 make_address_v4(string_view str, error_code&amp; ec) noexcept;

  <span class='comment'>// address_v4 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp; os, const address_v4&amp; addr);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='internet.address.v4-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4-2'>2</a></div><p ><span class='texttt'>address_v4</span> satisfies the requirements for <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), and <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>).</p></div><div id='internet.address.v4.bytes'><h3 ><a class='secnum' href='#internet.address.v4.bytes' style='min-width:103pt'>21.5.1</a> Struct <span class='texttt'>ip::address_v4::bytes_type</span> <a class='abbr_ref' href='internet.address.v4.bytes'>[internet.address.v4.bytes]</a></h3><p ><span class='indexparent'><a class='index' id='bytes_type,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,bytes_type'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  struct address_v4::bytes_type : array&lt;unsigned char, 4&gt;
  {
    template&lt;class... T&gt; explicit constexpr bytes_type(T... t)
      : array&lt;unsigned char, 4&gt;{{static_cast&lt;unsigned char&gt;(t)...}} {}
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='internet.address.v4.bytes-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.bytes-1'>1</a></div><p >The <span class='texttt'>ip::address_v4::bytes_type</span> type is a standard-layout struct that provides a byte-level representation of an IPv4 address in network byte order.</p><p ><span class='indexparent'><a class='index' id='address_v4,constructor'></a></span></p></div></div><div id='internet.address.v4.cons'><h3 ><a class='secnum' href='#internet.address.v4.cons' style='min-width:103pt'>21.5.2</a> <span class='texttt'>ip::address_v4</span> constructors <a class='abbr_ref' href='internet.address.v4.cons'>[internet.address.v4.cons]</a></h3><p ><code class='itemdecl'>
constexpr address_v4() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>to_bytes()</span> yields <span class='texttt'>{0, 0, 0, 0}</span> and <span class='texttt'>to_uint() == 0</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v4(const bytes_type&amp; bytes);
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.cons-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>out_of_range</span> if any element of <span class='texttt'>bytes</span> is not in the range <span class='texttt'>[0, 0xFF]</span>. [&nbsp;<i>Note:</i> For implementations where <span class='texttt'>numeric_limits&lt;unsigned char&gt;::max() == 0xFF</span>, no out-of-range detection is needed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='internet.address.v4.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>to_bytes() == bytes</span> and <span class='texttt'>to_uint() == (bytes[0] &lt;&lt; 24) | (bytes[1] &lt;&lt; 16) | (bytes[2] &lt;&lt; 8) | bytes[3]</span>.
</p></div></div><p ><code class='itemdecl'>
explicit constexpr address_v4(address_v4::uint_type val);
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.cons-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>out_of_range</span> if <span class='texttt'>val</span> is not in the range <span class='texttt'>[0, 0xFFFFFFFF]</span>. [&nbsp;<i>Note:</i> For implementations where <span class='texttt'>numeric_limits&lt;address_v4::uint_type&gt;::max() == 0xFFFFFFFF</span>, no out-of-range detection is needed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='internet.address.v4.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.cons-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>to_uint() == val</span> and <span class='texttt'>to_bytes()</span> is <span class='texttt'>{ (val &gt;&gt; 24) &amp; 0xFF, (val &gt;&gt; 16) &amp; 0xFF, (val &gt;&gt; 8) &amp; 0xFF, val &amp; 0xFF }</span>.
</p></div></div></div><div id='internet.address.v4.members'><h3 ><a class='secnum' href='#internet.address.v4.members' style='min-width:103pt'>21.5.3</a> <span class='texttt'>ip::address_v4</span> members <a class='abbr_ref' href='internet.address.v4.members'>[internet.address.v4.members]</a></h3><p ><span class='indexparent'><a class='index' id='is_unspecified,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,is_unspecified'></a></span><code class='itemdecl'>
constexpr bool is_unspecified() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.members-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>to_uint() == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_loopback,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,is_loopback'></a></span><code class='itemdecl'>
constexpr bool is_loopback() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.members-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>(to_uint() &amp; 0xFF000000) == 0x7F000000</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_multicast,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,is_multicast'></a></span><code class='itemdecl'>
constexpr bool is_multicast() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.members-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>(to_uint() &amp; 0xF0000000) == 0xE0000000</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_bytes,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,to_bytes'></a></span><code class='itemdecl'>
constexpr bytes_type to_bytes() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.members-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> A representation of the address in network byte order (<a href='defs.net.byte.order'>[defs.net.byte.order]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='to_uint,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,to_uint'></a></span><code class='itemdecl'>
constexpr address_v4::uint_type to_uint() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.members-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> A representation of the address in host byte order (<a href='defs.host.byte.order'>[defs.host.byte.order]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='to_string,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,to_string'></a></span><code class='itemdecl'>
template&lt;class Allocator = allocator&lt;char&gt;&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    to_string(const Allocator&amp; a = Allocator()) const;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.members-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> If successful, the textual representation of the address, determined as if by POSIX <span class='texttt'>inet_ntop</span> when invoked with address family <span class='texttt'>AF_INET</span>. Otherwise <span class='texttt'>basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;(a)</span>.
</p></div></div></div><div id='internet.address.v4.static'><h3 ><a class='secnum' href='#internet.address.v4.static' style='min-width:103pt'>21.5.4</a> <span class='texttt'>ip::address_v4</span> static members <a class='abbr_ref' href='internet.address.v4.static'>[internet.address.v4.static]</a></h3><p ><span class='indexparent'><a class='index' id='any,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,any'></a></span><code class='itemdecl'>
static constexpr address_v4 any() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.static-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.static-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>address_v4()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='loopback,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,loopback'></a></span><code class='itemdecl'>
static constexpr address_v4 loopback() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.static-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.static-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>address_v4(0x7F000001)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='multicast,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,multicast'></a></span><code class='itemdecl'>
static constexpr address_v4 broadcast() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.static-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.static-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>address_v4(0xFFFFFFFF)</span>.
</p></div></div></div><div id='internet.address.v4.comparisons'><h3 ><a class='secnum' href='#internet.address.v4.comparisons' style='min-width:103pt'>21.5.5</a> <span class='texttt'>ip::address_v4</span> comparisons <a class='abbr_ref' href='internet.address.v4.comparisons'>[internet.address.v4.comparisons]</a></h3><p ><span class='indexparent'><a class='index' id='operator==,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,operator=='></a></span><code class='itemdecl'>
constexpr bool operator==(const address_v4&amp; a, const address_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.to_uint() == b.to_uint()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,operator!='></a></span><code class='itemdecl'>
constexpr bool operator!=(const address_v4&amp; a, const address_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,operator<'></a></span><code class='itemdecl'>
constexpr bool operator&lt; (const address_v4&amp; a, const address_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.comparisons-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.to_uint() &lt; b.to_uint()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,operator>'></a></span><code class='itemdecl'>
constexpr bool operator&gt; (const address_v4&amp; a, const address_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.comparisons-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>b &lt; a</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,operator<='></a></span><code class='itemdecl'>
constexpr bool operator&lt;=(const address_v4&amp; a, const address_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.comparisons-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.comparisons-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(b &lt; a)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,operator>='></a></span><code class='itemdecl'>
constexpr bool operator&gt;=(const address_v4&amp; a, const address_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.comparisons-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.comparisons-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a &lt; b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_address_v4'></a></span></p></div><div id='internet.address.v4.creation'><h3 ><a class='secnum' href='#internet.address.v4.creation' style='min-width:103pt'>21.5.6</a> <span class='texttt'>ip::address_v4</span> creation <a class='abbr_ref' href='internet.address.v4.creation'>[internet.address.v4.creation]</a></h3><p ><code class='itemdecl'>
constexpr address_v4 make_address_v4(const address_v4::bytes_type&amp; bytes);
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.creation-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.creation-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>address_v4(bytes)</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v4 make_address_v4(address_v4::uint_type val);
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.creation-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.creation-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>address_v4(val)</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v4 make_address_v4(v4_mapped_t, const address_v6&amp; a);
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.creation-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.creation-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> An <span class='texttt'>address_v4</span> object corresponding to the IPv4-mapped IPv6 address, as if computed by the following method:
</p><pre class='codeblock'>
address_v6::bytes_type v6b = a.to_bytes();
address_v4::bytes_type v4b(v6b[12], v6b[13], v6b[14], v6b[15]);
return address_v4(v4b);
</pre></div></div><div class='para' id='internet.address.v4.creation-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.creation-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>bad_address_cast</span> if <span class='texttt'>a.is_v4_mapped()</span> is <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
address_v4 make_address_v4(const char* str);
address_v4 make_address_v4(const char* str, error_code&amp; ec) noexcept;
address_v4 make_address_v4(const string&amp; str);
address_v4 make_address_v4(const string&amp; str, error_code&amp; ec) noexcept;
address_v4 make_address_v4(string_view str);
address_v4 make_address_v4(string_view str, error_code&amp; ec) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.creation-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.creation-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Converts a textual representation of an address into a corresponding <span class='texttt'>address_v4</span> value, as if by POSIX <span class='texttt'>inet_pton</span> when invoked with address family <span class='texttt'>AF_INET</span>.</p></div></div><div class='para' id='internet.address.v4.creation-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.creation-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> If successful, an <span class='texttt'>address_v4</span> value corresponding to the string <span class='texttt'>str</span>. Otherwise <span class='texttt'>address_v4()</span>.</p></div></div><div class='para' id='internet.address.v4.creation-7'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.creation-7'>7</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='internet.address.v4.creation-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.address.v4.creation-7.1'>(7.1)</a></div><p ><span class='texttt'>errc::invalid_argument</span> — if <span class='texttt'>str</span> is not a valid textual representation of an IPv4 address.
</p></li></ul></div></div></div><div id='internet.address.v4.io'><h3 ><a class='secnum' href='#internet.address.v4.io' style='min-width:103pt'>21.5.7</a> <span class='texttt'>ip::address_v4</span> I/O <a class='abbr_ref' href='internet.address.v4.io'>[internet.address.v4.io]</a></h3><p ><span class='indexparent'><a class='index' id='operator<<,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,operator<<'></a></span><code class='itemdecl'>
template&lt;class CharT, class Traits&gt;
  basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
    basic_ostream&lt;CharT, Traits&gt;&amp; os, const address_v4&amp; addr);
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v4.io-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v4.io-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>os &lt;&lt; addr.to_string().c_str()</span>.
</p></div></div></div></div><div id='internet.address.v6'><h2 ><a class='secnum' href='#internet.address.v6' style='min-width:88pt'>21.6</a> Class <span class='texttt'>ip::address_v6</span> <a class='abbr_ref' href='internet.address.v6'>[internet.address.v6]</a></h2><div class='para' id='internet.address.v6-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6-1'>1</a></div><p >The class <span class='texttt'>address_v6</span> is a representation of an IPv6 address.</p><p ><span class='indexparent'><a class='index' id='address_v6'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class address_v6
  {
  public:
    <span class='comment'>// types:
</span>    struct bytes_type;

    <span class='comment'>// constructors:
</span>    constexpr address_v6() noexcept;
    constexpr address_v6(const address_v6&amp; a) noexcept;
    constexpr address_v6(const bytes_type&amp; bytes,
                         scope_id_type scope = 0);

    <span class='comment'>// assignment:
</span>    address_v6&amp; operator=(const address_v6&amp; a) noexcept;

    <span class='comment'>// members:
</span>    void scope_id(scope_id_type id) noexcept;
    constexpr scope_id_type scope_id() const noexcept;
    constexpr bool is_unspecified() const noexcept;
    constexpr bool is_loopback() const noexcept;
    constexpr bool is_multicast() const noexcept;
    constexpr bool is_link_local() const noexcept;
    constexpr bool is_site_local() const noexcept;
    constexpr bool is_v4_mapped() const noexcept;
    constexpr bool is_multicast_node_local() const noexcept;
    constexpr bool is_multicast_link_local() const noexcept;
    constexpr bool is_multicast_site_local() const noexcept;
    constexpr bool is_multicast_org_local() const noexcept;
    constexpr bool is_multicast_global() const noexcept;
    constexpr bytes_type to_bytes() const noexcept;
    template&lt;class Allocator = allocator&lt;char&gt;&gt;
      basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
        to_string(const Allocator&amp; a = Allocator()) const;

    <span class='comment'>// static members:
</span>    static constexpr address_v6 any() noexcept;
    static constexpr address_v6 loopback() noexcept;
  };

  <span class='comment'>// address_v6 comparisons:
</span>  constexpr bool operator==(const address_v6&amp; a, const address_v6&amp; b) noexcept;
  constexpr bool operator!=(const address_v6&amp; a, const address_v6&amp; b) noexcept;
  constexpr bool operator&lt; (const address_v6&amp; a, const address_v6&amp; b) noexcept;
  constexpr bool operator&gt; (const address_v6&amp; a, const address_v6&amp; b) noexcept;
  constexpr bool operator&lt;=(const address_v6&amp; a, const address_v6&amp; b) noexcept;
  constexpr bool operator&gt;=(const address_v6&amp; a, const address_v6&amp; b) noexcept;

  <span class='comment'>// address_v6 creation:
</span>  constexpr address_v6 make_address_v6(const address_v6::bytes_type&amp; bytes,
                                       scope_id_type scope_id = 0);
  constexpr address_v6 make_address_v6(v4_mapped_t, const address_v4&amp; a) noexcept;
  address_v6 make_address_v6(const char* str);
  address_v6 make_address_v6(const char* str, error_code&amp; ec) noexcept;
  address_v6 make_address_v6(const string&amp; str);
  address_v6 make_address_v6(const string&amp; str, error_code&amp; ec) noexcept;
  address_v6 make_address_v6(string_view str);
  address_v6 make_address_v6(string_view str, error_code&amp; ec) noexcept;

  <span class='comment'>// address_v6 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp; os, const address_v6&amp; addr);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='internet.address.v6-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6-2'>2</a></div><p ><span class='texttt'>address_v6</span> satisfies the requirements for <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), and <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>).</p></div><div class='para' id='internet.address.v6-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6-3'>3</a></div><p >[&nbsp;<i>Note:</i> The implementations of the functions <span class='texttt'>is_unspecified</span>, <span class='texttt'>is_loopback</span>, <span class='texttt'>is_multicast</span>, <span class='texttt'>is_link_local</span>, <span class='texttt'>is_site_local</span>, <span class='texttt'>is_v4_mapped</span>, <span class='texttt'>is_multicast_node_local</span>, <span class='texttt'>is_multicast_link_local</span>, <span class='texttt'>is_multicast_site_local</span>, <span class='texttt'>is_multicast_org_local</span> and <span class='texttt'>is_multicast_global</span> are determined by [RFC4291]. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='internet.address.v6.bytes'><h3 ><a class='secnum' href='#internet.address.v6.bytes' style='min-width:103pt'>21.6.1</a> Struct <span class='texttt'>ip::address_v6::bytes_type</span> <a class='abbr_ref' href='internet.address.v6.bytes'>[internet.address.v6.bytes]</a></h3><p ><span class='indexparent'><a class='index' id='bytes_type,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,bytes_type'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  struct address_v6::bytes_type : array&lt;unsigned char, 16&gt;
  {
    template&lt;class... T&gt; explicit constexpr bytes_type(T... t)
      : array&lt;unsigned char, 16&gt;{{static_cast&lt;unsigned char&gt;(t)...}} {}
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='internet.address.v6.bytes-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.bytes-1'>1</a></div><p >The <span class='texttt'>ip::address_v6::bytes_type</span> type is a standard-layout struct that provides a byte-level representation of an IPv6 address in network byte order.</p><p ><span class='indexparent'><a class='index' id='address_v6,constructor'></a></span></p></div></div><div id='internet.address.v6.cons'><h3 ><a class='secnum' href='#internet.address.v6.cons' style='min-width:103pt'>21.6.2</a> <span class='texttt'>ip::address_v6</span> constructors <a class='abbr_ref' href='internet.address.v6.cons'>[internet.address.v6.cons]</a></h3><p ><code class='itemdecl'>
constexpr address_v6() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_unspecified() == true</span> and <span class='texttt'>scope_id() == 0</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v6(const bytes_type&amp; bytes,
                     scope_id_type scope = 0);
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.cons-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>out_of_range</span> if any element of <span class='texttt'>bytes</span> is not in the range <span class='texttt'>[0, 0xFF]</span>. [&nbsp;<i>Note:</i> For implementations where <span class='texttt'>numeric_limits&lt;unsigned char&gt;::max() == 0xFF</span>, no out-of-range detection is needed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='internet.address.v6.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>to_bytes() == bytes</span> and <span class='texttt'>scope_id() == scope</span>.
</p></div></div></div><div id='internet.address.v6.members'><h3 ><a class='secnum' href='#internet.address.v6.members' style='min-width:103pt'>21.6.3</a> <span class='texttt'>ip::address_v6</span> members <a class='abbr_ref' href='internet.address.v6.members'>[internet.address.v6.members]</a></h3><p ><span class='indexparent'><a class='index' id='scope_id,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,scope_id'></a></span><code class='itemdecl'>
void scope_id(scope_id_type id) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>scope_id() == id</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr scope_id_type scope_id() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The scope identifier associated with the address.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_unspecified,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_unspecified'></a></span><code class='itemdecl'>
constexpr bool is_unspecified() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this == make_address_v6("::")</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_loopback,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_loopback'></a></span><code class='itemdecl'>
constexpr bool is_loopback() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this == make_address_v6("::1")</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_multicast,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_multicast'></a></span><code class='itemdecl'>
constexpr bool is_multicast() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> A boolean indicating whether the <span class='texttt'>address_v6</span> object represents a multicast address, as if computed by the following method:
</p><pre class='codeblock'>
bytes_type b = to_bytes();
return b[0] == 0xFF;
</pre></div></div><p ><span class='indexparent'><a class='index' id='is_link_local,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_link_local'></a></span><code class='itemdecl'>
constexpr bool is_link_local() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> A boolean indicating whether the <span class='texttt'>address_v6</span> object represents a unicast link-local address, as if computed by the following method:
</p><pre class='codeblock'>
bytes_type b = to_bytes();
return b[0] == 0xFE &amp;&amp; (b[1] &amp; 0xC0) == 0x80;
</pre></div></div><p ><span class='indexparent'><a class='index' id='is_site_local,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_site_local'></a></span><code class='itemdecl'>
constexpr bool is_site_local() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-7'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> A boolean indicating whether the <span class='texttt'>address_v6</span> object represents a unicast site-local address, as if computed by the following method:
</p><pre class='codeblock'>
bytes_type b = to_bytes();
return b[0] == 0xFE &amp;&amp; (b[1] &amp; 0xC0) == 0xC0;
</pre></div></div><p ><span class='indexparent'><a class='index' id='is_v4_mapped,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_v4_mapped'></a></span><code class='itemdecl'>
constexpr bool is_v4_mapped() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-8'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> A boolean indicating whether the <span class='texttt'>address_v6</span> object represents an IPv4-mapped IPv6 address, as if computed by the following method:
</p><pre class='codeblock'>
bytes_type b = to_bytes();
return b[ 0] == 0 &amp;&amp; b[ 1] == 0 &amp;&amp; b[ 2] == 0    &amp;&amp; b[ 3] == 0
    &amp;&amp; b[ 4] == 0 &amp;&amp; b[ 5] == 0 &amp;&amp; b[ 6] == 0    &amp;&amp; b[ 7] == 0
    &amp;&amp; b[ 8] == 0 &amp;&amp; b[ 9] == 0 &amp;&amp; b[10] == 0xFF &amp;&amp; b[11] == 0xFF;
</pre></div></div><p ><span class='indexparent'><a class='index' id='is_multicast_node_local,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_multicast_node_local'></a></span><code class='itemdecl'>
constexpr bool is_multicast_node_local() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-9'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>is_multicast() &amp;&amp; (to_bytes()[1] &amp; 0x0F) == 0x01</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_multicast_link_local,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_multicast_link_local'></a></span><code class='itemdecl'>
constexpr bool is_multicast_link_local() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-10'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>is_multicast() &amp;&amp; (to_bytes()[1] &amp; 0x0F) == 0x02</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_multicast_site_local,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_multicast_site_local'></a></span><code class='itemdecl'>
constexpr bool is_multicast_site_local() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-11'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>is_multicast() &amp;&amp; (to_bytes()[1] &amp; 0x0F) == 0x05</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_multicast_org_local,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_multicast_org_local'></a></span><code class='itemdecl'>
constexpr bool is_multicast_org_local() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-12'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>is_multicast() &amp;&amp; (to_bytes()[1] &amp; 0x0F) == 0x08</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_multicast_global,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_multicast_global'></a></span><code class='itemdecl'>
constexpr bool is_multicast_global() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-13'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>is_multicast() &amp;&amp; (to_bytes()[1] &amp; 0x0F) == 0x0E</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_bytes,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,to_bytes'></a></span><code class='itemdecl'>
constexpr bytes_type to_bytes() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-14'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> A representation of the address in network byte order (<a href='defs.net.byte.order'>[defs.net.byte.order]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='to_string,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,to_string'></a></span><code class='itemdecl'>
template&lt;class Allocator = allocator&lt;char&gt;&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    to_string(const Allocator&amp; a = Allocator()) const;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.members-15'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> Converts an address into a textual representation. If <span class='texttt'>scope_id() == 0</span>, converts as if by POSIX <span class='texttt'>inet_ntop</span> when invoked with address family <span class='texttt'>AF_INET6</span>. If <span class='texttt'>scope_id() != 0</span>, the format is <span class='texttt'>address</span><span class='texttt'>%</span><span class='texttt'>scope-id</span>, where <span class='texttt'>address</span> is the textual representation of the equivalent address having <span class='texttt'>scope_id() == 0</span>, and <span class='texttt'>scope-id</span> is an <span class='indexparent'><a class='index' id='textual_representation_of_IPv6_scope_identifiers'></a></span>implementation-defined textual representation of the scope identifier.</p></div></div><div class='para' id='internet.address.v6.members-16'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.members-16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i> If successful, the textual representation of the address. Otherwise <span class='texttt'>basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;(a)</span>.
</p></div></div></div><div id='internet.address.v6.static'><h3 ><a class='secnum' href='#internet.address.v6.static' style='min-width:103pt'>21.6.4</a> <span class='texttt'>ip::address_v6</span> static members <a class='abbr_ref' href='internet.address.v6.static'>[internet.address.v6.static]</a></h3><p ><span class='indexparent'><a class='index' id='any,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,any'></a></span><code class='itemdecl'>
static constexpr address_v6 any() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.static-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.static-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> An address <span class='texttt'>a</span> such that the <span class='texttt'>a.is_unspecified() == true</span> and <span class='texttt'>a.scope_id() == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='loopback,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,loopback'></a></span><code class='itemdecl'>
static constexpr address_v6 loopback() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.static-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.static-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> An address <span class='texttt'>a</span> such that the <span class='texttt'>a.is_loopback() == true</span> and <span class='texttt'>a.scope_id() == 0</span>.
</p></div></div></div><div id='internet.address.v6.comparisons'><h3 ><a class='secnum' href='#internet.address.v6.comparisons' style='min-width:103pt'>21.6.5</a> <span class='texttt'>ip::address_v6</span> comparisons <a class='abbr_ref' href='internet.address.v6.comparisons'>[internet.address.v6.comparisons]</a></h3><p ><span class='indexparent'><a class='index' id='operator==,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,operator=='></a></span><code class='itemdecl'>
constexpr bool operator==(const address_v6&amp; a, const address_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.to_bytes() == b.to_bytes() &amp;&amp; a.scope_id() == b.scope_id()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,operator!='></a></span><code class='itemdecl'>
constexpr bool operator!=(const address_v6&amp; a, const address_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,operator<'></a></span><code class='itemdecl'>
constexpr bool operator&lt; (const address_v6&amp; a, const address_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.comparisons-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.to_bytes() &lt; b.to_bytes() || (!(b.to_bytes() &lt; a.to_bytes()) &amp;&amp; a.scope_id() &lt; b.scope_id())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,operator>'></a></span><code class='itemdecl'>
constexpr bool operator&gt; (const address_v6&amp; a, const address_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.comparisons-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>b &lt; a</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,operator<='></a></span><code class='itemdecl'>
constexpr bool operator&lt;=(const address_v6&amp; a, const address_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.comparisons-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.comparisons-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(b &lt; a)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,operator>='></a></span><code class='itemdecl'>
constexpr bool operator&gt;=(const address_v6&amp; a, const address_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.comparisons-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.comparisons-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a &lt; b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_address_v6'></a></span></p></div><div id='internet.address.v6.creation'><h3 ><a class='secnum' href='#internet.address.v6.creation' style='min-width:103pt'>21.6.6</a> <span class='texttt'>ip::address_v6</span> creation <a class='abbr_ref' href='internet.address.v6.creation'>[internet.address.v6.creation]</a></h3><p ><code class='itemdecl'>
constexpr address_v6 make_address_v6(const address_v6::bytes_type&amp; bytes,
                                     scope_id_type scope_id);
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.creation-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.creation-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>address_v6(bytes, scope_id)</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v6 make_address_v6(v4_mapped_t, const address_v4&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.creation-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.creation-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> An <span class='texttt'>address_v6</span> object containing the IPv4-mapped IPv6 address corresponding to the specified IPv4 address, as if computed by the following method:
</p><pre class='codeblock'>
address_v4::bytes_type v4b = a.to_bytes();
address_v6::bytes_type v6b(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                           0xFF, 0xFF, v4b[0], v4b[1], v4b[2], v4b[3]);
return address_v6(v6b);
</pre></div></div><p ><code class='itemdecl'>
address_v6 make_address_v6(const char* str);
address_v6 make_address_v6(const char* str, error_code&amp; ec) noexcept;
address_v4 make_address_v6(const string&amp; str);
address_v4 make_address_v6(const string&amp; str, error_code&amp; ec) noexcept;
address_v6 make_address_v6(string_view str);
address_v6 make_address_v6(string_view str, error_code&amp; ec) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.creation-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.creation-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Converts a textual representation of an address into a corresponding <span class='texttt'>address_v6</span> value. The format is either <span class='texttt'>address</span> or <span class='texttt'>address</span><span class='texttt'>%</span><span class='texttt'>scope-id</span>, where <span class='texttt'>address</span> is in the format specified by POSIX <span class='texttt'>inet_pton</span> when invoked with address family <span class='texttt'>AF_INET6</span>, and <span class='texttt'>scope-id</span> is an optional string specifying the scope identifier. All implementations accept as <span class='texttt'>scope-id</span> a textual representation of an unsigned decimal integer. It is <span class='indexparent'><a class='index' id='whether_alternative_IPv6_scope_identifier_representations_are_permitted'></a></span>implementation-defined whether alternative scope identifier representations are permitted. If <span class='texttt'>scope-id</span> is not supplied, an <span class='texttt'>address_v6</span> object is returned such that <span class='texttt'>scope_id() == 0</span>.</p></div></div><div class='para' id='internet.address.v6.creation-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.creation-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> If successful, an <span class='texttt'>address_v6</span> value corresponding to the string <span class='texttt'>str</span>. Otherwise returns <span class='texttt'>address_v6()</span>.</p></div></div><div class='para' id='internet.address.v6.creation-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.creation-5'>5</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='internet.address.v6.creation-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.address.v6.creation-5.1'>(5.1)</a></div><p ><span class='texttt'>errc::invalid_argument</span> — if <span class='texttt'>str</span> is not a valid textual representation of an IPv6 address.
</p></li></ul></div></div></div><div id='internet.address.v6.io'><h3 ><a class='secnum' href='#internet.address.v6.io' style='min-width:103pt'>21.6.7</a> <span class='texttt'>ip::address_v6</span> I/O <a class='abbr_ref' href='internet.address.v6.io'>[internet.address.v6.io]</a></h3><p ><span class='indexparent'><a class='index' id='operator<<,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,operator<<'></a></span><code class='itemdecl'>
template&lt;class CharT, class Traits&gt;
  basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
    basic_ostream&lt;CharT, Traits&gt;&amp; os, const address_v6&amp; addr);
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.v6.io-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.v6.io-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>os &lt;&lt; addr.to_string().c_str()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bad_address_cast'></a></span></p></div></div><div id='internet.bad.address.cast'><h2 ><a class='secnum' href='#internet.bad.address.cast' style='min-width:88pt'>21.7</a> Class <span class='texttt'>ip::bad_address_cast</span> <a class='abbr_ref' href='internet.bad.address.cast'>[internet.bad.address.cast]</a></h2><div class='para' id='internet.bad.address.cast-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.bad.address.cast-1'>1</a></div><p >An exception of type <span class='texttt'>bad_address_cast</span> is thrown by a failed <span class='texttt'>address_cast</span>.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class bad_address_cast : public bad_cast
  {
  public:
    <span class='comment'>// constructor:
</span>    bad_address_cast() noexcept;
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><code class='itemdecl'>
bad_address_cast() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='internet.bad.address.cast-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.bad.address.cast-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> constructs a <span class='texttt'>bad_address_cast</span> object.</p></div></div><div class='para' id='internet.bad.address.cast-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.bad.address.cast-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>what()</span> returns an <span class='indexparent'><a class='index' id='result_of_bad_address_cast::what'></a></span>implementation-defined <span class='textsc'>ntbs</span>.
</p></div></div></div><div id='internet.hash'><h2 ><a class='secnum' href='#internet.hash' style='min-width:88pt'>21.8</a> Hash support <a class='abbr_ref' href='internet.hash'>[internet.hash]</a></h2><p ><code class='itemdecl'>
template&lt;&gt; struct hash&lt;experimental::net::v1::ip::address&gt;;
template&lt;&gt; struct hash&lt;experimental::net::v1::ip::address_v4&gt;;
template&lt;&gt; struct hash&lt;experimental::net::v1::ip::address_v6&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='internet.hash-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.hash-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> the template specializations shall meet the requirements of class template <span class='texttt'>hash</span> (C++Std &sect;<a href='../n4140/unord.hash'>[unord.hash]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_address_iterator'></a></span></p></div><div id='internet.address.iter'><h2 ><a class='secnum' href='#internet.address.iter' style='min-width:88pt'>21.9</a> Class template <span class='texttt'>ip::basic_address_iterator</span> specializations <a class='abbr_ref' href='internet.address.iter'>[internet.address.iter]</a></h2><div class='para' id='internet.address.iter-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.iter-1'>1</a></div><p >The class template <span class='texttt'>basic_address_iterator</span> enables iteration over IP addresses in network byte order. This clause defines two specializations of the class template <span class='texttt'>basic_address_iterator</span>: <span class='texttt'>basic_address_iterator&lt;address_v4&gt;</span> and <span class='texttt'>basic_address_iterator&lt;address_v6&gt;</span>. The members and operational semantics of these specializations are defined below.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;&gt; class basic_address_iterator&lt;<i>Address</i>&gt;
  {
  public:
    <span class='comment'>// types:
</span>    using value_type = <i>Address</i>;
    using difference_type = ptrdiff_t;
    using pointer = const <i>Address</i>*;
    using reference = const <i>Address</i>&amp;;
    using iterator_category = input_iterator_tag;

    <span class='comment'>// constructors:
</span>    basic_address_iterator(const <i>Address</i>&amp; a) noexcept;

    <span class='comment'>// members:
</span>    reference operator*() const noexcept;
    pointer operator-&gt;() const noexcept;
    basic_address_iterator&amp; operator++() noexcept;
    basic_address_iterator operator++(int) noexcept;
    basic_address_iterator&amp; operator--() noexcept;
    basic_address_iterator operator--(int) noexcept;

    <span class='comment'>// other members as required by C++Std &sect;<a href='../n4140/input.iterators'>[input.iterators]</a>
</span>
  private:
    <i>Address</i> address_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='internet.address.iter-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.iter-2'>2</a></div><p >Specializations of <span class='texttt'>basic_address_iterator</span> satisfy the requirements for input iterators (C++Std &sect;<a href='../n4140/input.iterators'>[input.iterators]</a>).</p><p ><code class='itemdecl'>
basic_address_iterator(const <i>Address</i>&amp; a) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='internet.address.iter-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.iter-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>address_</span> with <span class='texttt'>a</span>.
</p></div></div><p ><code class='itemdecl'>
reference operator*() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.iter-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.iter-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>address_</span>.
</p></div></div><p ><code class='itemdecl'>
pointer operator-&gt;() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.iter-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.iter-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>addressof(address_)</span>.
</p></div></div><p ><code class='itemdecl'>
basic_address_iterator&amp; operator++() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.iter-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.iter-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets <span class='texttt'>address_</span> to the next unique address in network byte order.</p></div></div><div class='para' id='internet.address.iter-7'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.iter-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
basic_address_iterator operator++(int) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.iter-8'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.iter-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets <span class='texttt'>address_</span> to the next unique address in network byte order.</p></div></div><div class='para' id='internet.address.iter-9'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.iter-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> The prior value of <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
basic_address_iterator&amp; operator--() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.iter-10'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.iter-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets <span class='texttt'>address_</span> to the prior unique address in network byte order.</p></div></div><div class='para' id='internet.address.iter-11'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.iter-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
basic_address_iterator operator--(int) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.iter-12'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.iter-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets <span class='texttt'>address_</span> to the prior unique address in network byte order.</p></div></div><div class='para' id='internet.address.iter-13'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.iter-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> The prior value of <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_address_range'></a></span></p></div><div id='internet.address.range'><h2 ><a class='secnum' href='#internet.address.range' style='min-width:88pt'>21.10</a> Class template <span class='texttt'>ip::basic_address_range</span> specializations <a class='abbr_ref' href='internet.address.range'>[internet.address.range]</a></h2><div class='para' id='internet.address.range-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.range-1'>1</a></div><p >The class template <span class='texttt'>basic_address_range</span> represents a range of IP addresses in network byte order. This clause defines two specializations of the class template <span class='texttt'>basic_address_range</span>: <span class='texttt'>basic_address_range&lt;address_v4&gt;</span> and <span class='texttt'>basic_address_range&lt;address_v6&gt;</span>. The members and operational semantics of these specializations are defined below.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;&gt; class basic_address_range&lt;<i>Address</i>&gt;
  {
  public:
    <span class='comment'>// types:
</span>    using iterator = basic_address_iterator&lt;<i>Address</i>&gt;;

    <span class='comment'>// constructors:
</span>    basic_address_range() noexcept;
    basic_address_range(const <i>Address</i>&amp; first,
                        const <i>Address</i>&amp; last) noexcept;

    <span class='comment'>// members:
</span>    iterator begin() const noexcept;
    iterator end() const noexcept;
    bool empty() const noexcept;
    size_t size() const noexcept; <i>// not always defined</i>
    iterator find(const <i>Address</i>&amp; addr) const noexcept;
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='internet.address.range-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.range-2'>2</a></div><p >Specializations of <span class='texttt'>basic_address_range</span> satisfy the requirements for <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), and <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>).</p><p ><code class='itemdecl'>
basic_address_range() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='internet.address.range-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.range-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>basic_address_range&lt;<i>Address</i>&gt;</span> that represents an empty range.
</p></div></div><p ><code class='itemdecl'>
basic_address_range(const <i>Address</i>&amp; first,
                    const <i>Address</i>&amp; last) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.range-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.range-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>basic_address_range&lt;<i>Address</i>&gt;</span> that represents the half-open range <span class='texttt'>[first, last)</span>.
</p></div></div><p ><code class='itemdecl'>
iterator begin() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.range-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.range-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> An iterator that points to the beginning of the range.
</p></div></div><p ><code class='itemdecl'>
iterator end() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.range-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.range-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> An iterator that points to the end of the range.
</p></div></div><p ><code class='itemdecl'>
bool empty() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.range-7'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.range-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>*this</span> represents an empty range, otherwise <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
size_t size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.range-8'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.range-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of unique addresses in the range.</p></div></div><div class='para' id='internet.address.range-9'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.range-9'>9</a></div><div class='itemdescr'><p ><i>Remarks:</i> This member function is not defined when <i>Address</i> is type <span class='texttt'>address_v6</span>.
</p></div></div><p ><code class='itemdecl'>
iterator find(const <i>Address</i>&amp; addr) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.address.range-10'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.range-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>addr</span> is in the range, an iterator that points to <span class='texttt'>addr</span>; otherwise, <span class='texttt'>end()</span>.</p></div></div><div class='para' id='internet.address.range-11'><div class='marginalizedparent'><a class='marginalized' href='#internet.address.range-11'>11</a></div><div class='itemdescr'><p >Complexity: Constant time.
</p></div></div><p ><span class='indexparent'><a class='index' id='network_v4'></a></span></p></div><div id='internet.network.v4'><h2 ><a class='secnum' href='#internet.network.v4' style='min-width:88pt'>21.11</a> Class template <span class='texttt'>ip::network_v4</span> <a class='abbr_ref' href='internet.network.v4'>[internet.network.v4]</a></h2><div class='para' id='internet.network.v4-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4-1'>1</a></div><p >The class <span class='texttt'>network_v4</span> provides the ability to use and manipulate IPv4 network addresses.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class network_v4
  {
  public:
    <span class='comment'>// constructors:
</span>    constexpr network_v4() noexcept;
    constexpr network_v4(const address_v4&amp; addr, int prefix_len);
    constexpr network_v4(const address_v4&amp; addr, const address_v4&amp; mask);

    <span class='comment'>// members:
</span>    constexpr address_v4 address() const noexcept;
    constexpr int prefix_length() const noexcept;
    constexpr address_v4 netmask() const noexcept;
    constexpr address_v4 network() const noexcept;
    constexpr address_v4 broadcast() const noexcept;
    address_v4_range hosts() const noexcept;
    constexpr network_v4 canonical() const noexcept;
    constexpr bool is_host() const noexcept;
    constexpr bool is_subnet_of(const network_v4&amp; other) const noexcept;
    template&lt;class Allocator = allocator&lt;char&gt;&gt;
      basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
        to_string(const Allocator&amp; a = Allocator()) const;
  };

  <span class='comment'>// network_v4 comparisons:
</span>  constexpr bool operator==(const network_v4&amp; a, const network_v4&amp; b) noexcept;
  constexpr bool operator!=(const network_v4&amp; a, const network_v4&amp; b) noexcept;

  <span class='comment'>// network_v4 creation:
</span>  constexpr network_v4 make_network_v4(const address_v4&amp; addr, int prefix_len);
  constexpr network_v4 make_network_v4(const address_v4&amp; addr, const address_v4&amp; mask);
  network_v4 make_network_v4(const char* str);
  network_v4 make_network_v4(const char* str, error_code&amp; ec) noexcept;
  network_v4 make_network_v4(const string&amp; str);
  network_v4 make_network_v4(const string&amp; str, error_code&amp; ec) noexcept;
  network_v4 make_network_v4(string_view str);
  network_v4 make_network_v4(string_view str, error_code&amp; ec) noexcept;

  <span class='comment'>// network_v4 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp; os, const network_v4&amp; net);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='internet.network.v4-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4-2'>2</a></div><p ><span class='texttt'>network_v4</span> satisfies the requirements for <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), and <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>).</p></div><div id='internet.network.v4.cons'><h3 ><a class='secnum' href='#internet.network.v4.cons' style='min-width:103pt'>21.11.1</a> <span class='texttt'>ip::network_v4</span> constructors <a class='abbr_ref' href='internet.network.v4.cons'>[internet.network.v4.cons]</a></h3><p ><code class='itemdecl'>
constexpr network_v4() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address().is_unspecified() == true</span> and <span class='texttt'>prefix_length() == 0</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr network_v4(const address_v4&amp; addr, int prefix_len);
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address() == addr</span> and <span class='texttt'>prefix_length() == prefix_len</span>.</p></div></div><div class='para' id='internet.network.v4.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.cons-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>out_of_range</span> if <span class='texttt'>prefix_len &lt; 0</span> or <span class='texttt'>prefix_len &gt; 32</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr network_v4(const address_v4&amp; addr, const address_v4&amp; mask);
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.cons-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address() == addr</span> and <span class='texttt'>prefix_length()</span> is equal to the number of contiguous non-zero bits in <span class='texttt'>mask</span>.</p></div></div><div class='para' id='internet.network.v4.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.cons-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>invalid_argument</span> if <span class='texttt'>mask</span> contains non-contiguous non-zero bits, or if the most significant bit is zero and any other bits are non-zero.
</p></div></div></div><div id='internet.network.v4.members'><h3 ><a class='secnum' href='#internet.network.v4.members' style='min-width:103pt'>21.11.2</a> <span class='texttt'>ip::network_v4</span> members <a class='abbr_ref' href='internet.network.v4.members'>[internet.network.v4.members]</a></h3><p ><code class='itemdecl'>
constexpr address_v4 address() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.members-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The address specified when the <span class='texttt'>network_v4</span> object was constructed.
</p></div></div><p ><code class='itemdecl'>
constexpr int prefix_length() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.members-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The prefix length of the network.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v4 netmask() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.members-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> An <span class='texttt'>address_v4</span> object with <span class='texttt'>prefix_length()</span> contiguous non-zero bits set, starting from the most significant bit in network byte order. All other bits are zero.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v4 network() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.members-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> An <span class='texttt'>address_v4</span> object with the first <span class='texttt'>prefix_length()</span> bits, starting from the most significant bit in network byte order, set to the corresponding bit value of <span class='texttt'>this-&gt;address()</span>. All other bits are zero.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v4 broadcast() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.members-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> An <span class='texttt'>address_v4</span> object with the first <span class='texttt'>prefix_length()</span> bits, starting from the most significant bit in network byte order, set to the corresponding bit value of <span class='texttt'>this-&gt;address()</span>. All other bits are non-zero.
</p></div></div><p ><code class='itemdecl'>
address_v4_range hosts() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.members-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>is_host() == true</span>, an <span class='texttt'>address_v4_range</span> object representing the single address <span class='texttt'>this-&gt;address()</span>. Otherwise, an <span class='texttt'>address_v4_range</span> object representing the range of unique host IP addresses in the network.</p></div></div><div class='para' id='internet.network.v4.members-7'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.members-7'>7</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> For IPv4, the network address and the broadcast address are not included in the range of host IP addresses. For example, given a network <span class='texttt'>192.168.1.0/24</span>, the range returned by <span class='texttt'>hosts()</span> is from <span class='texttt'>192.168.1.1</span> to <span class='texttt'>192.168.1.254</span> inclusive, and neither <span class='texttt'>192.168.1.0</span> nor the broadcast address <span class='texttt'>192.168.1.255</span> are in the range. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><code class='itemdecl'>
constexpr network_v4 canonical() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.members-8'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>network_v4(network(), prefix_length())</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool is_host() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.members-9'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.members-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>prefix_length() == 32</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool is_subnet_of(const network_v4&amp; other) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.members-10'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.members-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>other.prefix_length() &lt; prefix_length()</span> and <span class='texttt'>network_v4(this-&gt;address(), other.prefix_length()).canonical() == other.canonical()</span>, otherwise <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Allocator = allocator&lt;char&gt;&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    to_string(const Allocator&amp; a = Allocator()) const;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.members-11'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.members-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>this-&gt;address().to_string(a) + "/" + std::to_string(prefix_length())</span>.
</p></div></div></div><div id='internet.network.v4.comparisons'><h3 ><a class='secnum' href='#internet.network.v4.comparisons' style='min-width:103pt'>21.11.3</a> <span class='texttt'>ip::network_v4</span> comparisons <a class='abbr_ref' href='internet.network.v4.comparisons'>[internet.network.v4.comparisons]</a></h3><p ><code class='itemdecl'>
constexpr bool operator==(const network_v4&amp; a, const network_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>a.address() == b.address()</span> and <span class='texttt'>a.prefix_length() == b.prefix_length()</span>, otherwise <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool operator!=(const network_v4&amp; a, const network_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div></div><div id='internet.network.v4.creation'><h3 ><a class='secnum' href='#internet.network.v4.creation' style='min-width:103pt'>21.11.4</a> <span class='texttt'>ip::network_v4</span> creation <a class='abbr_ref' href='internet.network.v4.creation'>[internet.network.v4.creation]</a></h3><p ><code class='itemdecl'>
constexpr network_v4 make_network_v4(const address_v4&amp; addr, int prefix_len);
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.creation-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.creation-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>network_v4(addr, prefix_len)</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr network_v4 make_network_v4(const address_v4&amp; addr, const address_v4&amp; mask);
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.creation-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.creation-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>network_v4(addr, mask)</span>.
</p></div></div><p ><code class='itemdecl'>
network_v4 make_network_v4(const char* str);
network_v4 make_network_v4(const char* str, error_code&amp; ec) noexcept;
network_v4 make_network_v4(const string&amp; str);
network_v4 make_network_v4(const string&amp; str, error_code&amp; ec) noexcept;
network_v4 make_network_v4(string_view str);
network_v4 make_network_v4(string_view str, error_code&amp; ec) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.creation-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.creation-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>str</span> contains a value of the form address <span class='texttt'>'/'</span> prefix-length, a <span class='texttt'>network_v4</span> object constructed with the result of applying <span class='texttt'>make_address_v4()</span> to the address portion of the string, and the result of converting prefix-length to an integer of type <span class='texttt'>int</span>. Otherwise returns <span class='texttt'>network_v4()</span> and sets <span class='texttt'>ec</span> to reflect the error.</p></div></div><div class='para' id='internet.network.v4.creation-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.creation-4'>4</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='internet.network.v4.creation-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.network.v4.creation-4.1'>(4.1)</a></div><p ><span class='texttt'>errc::invalid_argument</span> — if <span class='texttt'>str</span> is not a valid textual representation of an IPv4 address and prefix length.
</p></li></ul></div></div></div><div id='internet.network.v4.io'><h3 ><a class='secnum' href='#internet.network.v4.io' style='min-width:103pt'>21.11.5</a> <span class='texttt'>ip::network_v4</span> I/O <a class='abbr_ref' href='internet.network.v4.io'>[internet.network.v4.io]</a></h3><p ><code class='itemdecl'>
template&lt;class CharT, class Traits&gt;
  basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
    basic_ostream&lt;CharT, Traits&gt;&amp; os, const network_v4&amp; net);
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v4.io-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v4.io-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>os &lt;&lt; net.to_string().c_str()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='network_v6'></a></span></p></div></div><div id='internet.network.v6'><h2 ><a class='secnum' href='#internet.network.v6' style='min-width:88pt'>21.12</a> Class template <span class='texttt'>ip::network_v6</span> <a class='abbr_ref' href='internet.network.v6'>[internet.network.v6]</a></h2><div class='para' id='internet.network.v6-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6-1'>1</a></div><p >The class <span class='texttt'>network_v6</span> provides the ability to use and manipulate IPv6 network addresses.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class network_v6
  {
  public:
    <span class='comment'>// constructors:
</span>    constexpr network_v6() noexcept;
    constexpr network_v6(const address_v6&amp; addr, int prefix_len);

    <span class='comment'>// members:
</span>    constexpr address_v6 address() const noexcept;
    constexpr int prefix_length() const noexcept;
    constexpr address_v6 network() const noexcept;
    address_v6_range hosts() const noexcept;
    constexpr network_v6 canonical() const noexcept;
    constexpr bool is_host() const noexcept;
    constexpr bool is_subnet_of(const network_v6&amp; other) const noexcept;
    template&lt;class Allocator = allocator&lt;char&gt;&gt;
      basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
        to_string(const Allocator&amp; a = Allocator()) const;
  };

  <span class='comment'>// network_v6 comparisons:
</span>  constexpr bool operator==(const network_v6&amp; a, const network_v6&amp; b) noexcept;
  constexpr bool operator!=(const network_v6&amp; a, const network_v6&amp; b) noexcept;

  <span class='comment'>// network_v6 creation:
</span>  constexpr network_v6 make_network_v6(const address_v6&amp; addr, int prefix_len);
  network_v6 make_network_v6(const char* str);
  network_v6 make_network_v6(const char* str, error_code&amp; ec) noexcept;
  network_v6 make_network_v6(const string&amp; str);
  network_v6 make_network_v6(const string&amp; str, error_code&amp; ec) noexcept;
  network_v6 make_network_v6(string_view str);
  network_v6 make_network_v6(string_view str, error_code&amp; ec) noexcept;

  <span class='comment'>// network_v6 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp; os, const network_v6&amp; net);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='internet.network.v6-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6-2'>2</a></div><p ><span class='texttt'>network_v6</span> satisfies the requirements for <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), and <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>).</p></div><div id='internet.network.v6.cons'><h3 ><a class='secnum' href='#internet.network.v6.cons' style='min-width:103pt'>21.12.1</a> <span class='texttt'>ip::network_v6</span> constructors <a class='abbr_ref' href='internet.network.v6.cons'>[internet.network.v6.cons]</a></h3><p ><code class='itemdecl'>
constexpr network_v6() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address().is_unspecified() == true</span> and <span class='texttt'>prefix_length() == 0</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr network_v6(const address_v6&amp; addr, int prefix_len);
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address() == addr</span> and <span class='texttt'>prefix_length() == prefix_len</span>.</p></div></div><div class='para' id='internet.network.v6.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.cons-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>out_of_range</span> if <span class='texttt'>prefix_len &lt; 0</span> or <span class='texttt'>prefix_len &gt; 128</span>.
</p></div></div></div><div id='internet.network.v6.members'><h3 ><a class='secnum' href='#internet.network.v6.members' style='min-width:103pt'>21.12.2</a> <span class='texttt'>ip::network_v6</span> members <a class='abbr_ref' href='internet.network.v6.members'>[internet.network.v6.members]</a></h3><p ><code class='itemdecl'>
constexpr address_v6 address() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.members-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The address specified when the <span class='texttt'>network_v6</span> object was constructed.
</p></div></div><p ><code class='itemdecl'>
constexpr int prefix_length() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.members-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The prefix length of the network.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v6 network() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.members-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> An <span class='texttt'>address_v6</span> object with the first <span class='texttt'>prefix_length()</span> bits, starting from the most significant bit in network byte order, set to the corresponding bit value of <span class='texttt'>this-&gt;address()</span>. All other bits are zero.
</p></div></div><p ><code class='itemdecl'>
address_v6_range hosts() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.members-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>is_host() == true</span>, an <span class='texttt'>address_v6_range</span> object representing the single address <span class='texttt'>this-&gt;address().</span> Otherwise, an <span class='texttt'>address_v6_range</span> object representing the range of unique host IP addresses in the network.
</p></div></div><p ><code class='itemdecl'>
constexpr network_v6 canonical() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.members-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>network_v6(network(), prefix_length())</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool is_host() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.members-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>prefix_length() == 128</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool is_subnet_of(const network_v6&amp; other) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.members-7'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>other.prefix_length() &lt; prefix_length()</span> and <span class='texttt'>network_v6(this-&gt;address(), other.prefix_length()).canonical() == other.canonical()</span>, otherwise <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Allocator = allocator&lt;char&gt;&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    to_string(const Allocator&amp; a = Allocator()) const;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.members-8'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>this-&gt;address().to_string(a) + "/" + to_string(prefix_length()).c_str()</span>.
</p></div></div></div><div id='internet.network.v6.comparisons'><h3 ><a class='secnum' href='#internet.network.v6.comparisons' style='min-width:103pt'>21.12.3</a> <span class='texttt'>ip::network_v6</span> comparisons <a class='abbr_ref' href='internet.network.v6.comparisons'>[internet.network.v6.comparisons]</a></h3><p ><code class='itemdecl'>
constexpr bool operator==(const network_v6&amp; a, const network_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>a.address() == b.address()</span> and <span class='texttt'>a.prefix_length() == b.prefix_length()</span>, otherwise <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool operator!=(const network_v6&amp; a, const network_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div></div><div id='internet.network.v6.creation'><h3 ><a class='secnum' href='#internet.network.v6.creation' style='min-width:103pt'>21.12.4</a> <span class='texttt'>ip::network_v6</span> creation <a class='abbr_ref' href='internet.network.v6.creation'>[internet.network.v6.creation]</a></h3><p ><code class='itemdecl'>
constexpr network_v6 make_network_v6(const address_v6&amp; addr, int prefix_len);
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.creation-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.creation-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>network_v6(addr, prefix_len)</span>.
</p></div></div><p ><code class='itemdecl'>
network_v6 make_network_v6(const char* str);
network_v6 make_network_v6(const char* str, error_code&amp; ec) noexcept;
network_v6 make_network_v6(const string&amp; str);
network_v6 make_network_v6(const string&amp; str, error_code&amp; ec) noexcept;
network_v6 make_network_v6(string_view str);
network_v6 make_network_v6(string_view str, error_code&amp; ec) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.creation-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.creation-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>str</span> contains a value of the form address <span class='texttt'>'/'</span> prefix-length, a <span class='texttt'>network_v6</span> object constructed with the result of applying <span class='texttt'>make_address_v6()</span> to the address portion of the string, and the result of converting prefix-length to an integer of type <span class='texttt'>int</span>. Otherwise returns <span class='texttt'>network_v6()</span> and sets <span class='texttt'>ec</span> to reflect the error.</p></div></div><div class='para' id='internet.network.v6.creation-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.creation-3'>3</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='internet.network.v6.creation-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.network.v6.creation-3.1'>(3.1)</a></div><p ><span class='texttt'>errc::invalid_argument</span> — if <span class='texttt'>str</span> is not a valid textual representation of an IPv6 address and prefix length.
</p></li></ul></div></div></div><div id='internet.network.v6.io'><h3 ><a class='secnum' href='#internet.network.v6.io' style='min-width:103pt'>21.12.5</a> <span class='texttt'>ip::network_v6</span> I/O <a class='abbr_ref' href='internet.network.v6.io'>[internet.network.v6.io]</a></h3><p ><code class='itemdecl'>
template&lt;class CharT, class Traits&gt;
  basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
    basic_ostream&lt;CharT, Traits&gt;&amp; os, const network_v6&amp; net);
</code></p><div class='itemdescr'></div><div class='para' id='internet.network.v6.io-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.network.v6.io-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>os &lt;&lt; net.to_string().c_str()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_endpoint'></a></span></p></div></div><div id='internet.endpoint'><h2 ><a class='secnum' href='#internet.endpoint' style='min-width:88pt'>21.13</a> Class template <span class='texttt'>ip::basic_endpoint</span> <a class='abbr_ref' href='internet.endpoint'>[internet.endpoint]</a></h2><div class='para' id='internet.endpoint-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint-1'>1</a></div><p >An object of type <span class='texttt'>basic_endpoint&lt;InternetProtocol&gt;</span> represents a protocol-specific endpoint, where an endpoint consists of an IP address and port number. Endpoints may be used to identify sources and destinations for socket connections and datagrams.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;class InternetProtocol&gt;
  class basic_endpoint
  {
  public:
    <span class='comment'>// types:
</span>    using protocol_type = InternetProtocol;

    <span class='comment'>// constructors:
</span>    constexpr basic_endpoint() noexcept;
    constexpr basic_endpoint(const protocol_type&amp; proto,
                             port_type port_num) noexcept;
    constexpr basic_endpoint(const ip::address&amp; addr,
                             port_type port_num) noexcept;

    <span class='comment'>// members:
</span>    constexpr protocol_type protocol() const noexcept;
    constexpr ip::address address() const noexcept;
    void address(const ip::address&amp; addr) noexcept;
    constexpr port_type port() const noexcept;
    void port(port_type port_num) noexcept;
  };

  <span class='comment'>// basic_endpoint comparisons:
</span>  template&lt;class InternetProtocol&gt;
    constexpr bool operator==(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                              const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
  template&lt;class InternetProtocol&gt;
    constexpr bool operator!=(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                              const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
  template&lt;class InternetProtocol&gt;
    constexpr bool operator&lt; (const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                              const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
  template&lt;class InternetProtocol&gt;
    constexpr bool operator&gt; (const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                              const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
  template&lt;class InternetProtocol&gt;
    constexpr bool operator&lt;=(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                              const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
  template&lt;class InternetProtocol&gt;
    constexpr bool operator&gt;=(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                              const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;

  <span class='comment'>// basic_endpoint I/O:
</span>  template&lt;class CharT, class Traits, class InternetProtocol&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp; os,
      const basic_endpoint&lt;InternetProtocol&gt;&amp; ep);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='internet.endpoint-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint-2'>2</a></div><p >Instances of the <span class='texttt'>basic_endpoint</span> class template meet the requirements for an <span class='texttt'>Endpoint</span> (<a href='socket.reqmts.endpoint'>[socket.reqmts.endpoint]</a>).</p><p ><span class='indexparent'><a class='index' id='extensible_implementation,basic_endpoint'></a></span><span class='indexparent'><a class='index' id='basic_endpoint,extensible_implementation'></a></span></p></div><div class='para' id='internet.endpoint-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint-3'>3</a></div><p >Extensible implementations provide the following member functions:</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;class InternetProtocol&gt;
  class basic_endpoint
  {
  public:
    void* data() noexcept;
    const void* data() const noexcept;
    constexpr size_t size() const noexcept;
    void resize(size_t s);
    constexpr size_t capacity() const noexcept;
    <i>// remainder unchanged</i>
  private:
    union
    {
      sockaddr_in v4_;
      sockaddr_in6 v6_;
    } data_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div id='internet.endpoint.cons'><h3 ><a class='secnum' href='#internet.endpoint.cons' style='min-width:103pt'>21.13.1</a> <span class='texttt'>ip::basic_endpoint</span> constructors <a class='abbr_ref' href='internet.endpoint.cons'>[internet.endpoint.cons]</a></h3><p ><code class='itemdecl'>
constexpr basic_endpoint() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address() == ip::address()</span> and <span class='texttt'>port() == 0</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr basic_endpoint(const protocol_type&amp; proto,
                         port_type port_num) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.cons-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>proto == protocol_type::v4() || proto == protocol_type::v6()</span>.</p></div></div><div class='para' id='internet.endpoint.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='internet.endpoint.cons-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.endpoint.cons-3.1'>(3.1)</a></div><p >If <span class='texttt'>proto == protocol_type::v6()</span>, <span class='texttt'>this-&gt;address() == ip::address_v6()</span>; otherwise, <span class='texttt'>this-&gt;address() == ip::address_v4()</span>.
</p></li><li id='internet.endpoint.cons-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.endpoint.cons-3.2'>(3.2)</a></div><p ><span class='texttt'>port() == port_num</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
constexpr basic_endpoint(const ip::address&amp; addr,
                         port_type port_num) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.cons-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address() == addr</span> and <span class='texttt'>port() == port_num</span>.
</p></div></div></div><div id='internet.endpoint.members'><h3 ><a class='secnum' href='#internet.endpoint.members' style='min-width:103pt'>21.13.2</a> <span class='texttt'>ip::basic_endpoint</span> members <a class='abbr_ref' href='internet.endpoint.members'>[internet.endpoint.members]</a></h3><p ><code class='itemdecl'>
constexpr protocol_type protocol() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.members-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>protocol_type::v6()</span> if the expression <span class='texttt'>this-&gt;address().is_v6()</span> is <span class='texttt'>true</span>, otherwise <span class='texttt'>protocol_type::v4()</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr ip::address address() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.members-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The address associated with the endpoint.
</p></div></div><p ><code class='itemdecl'>
void address(const ip::address&amp; addr) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.members-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.members-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address() == addr</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr port_type port() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.members-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> The port number associated with the endpoint.
</p></div></div><p ><code class='itemdecl'>
void port(port_type port_num) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.members-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.members-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>port() == port_num</span>.
</p></div></div></div><div id='internet.endpoint.comparisons'><h3 ><a class='secnum' href='#internet.endpoint.comparisons' style='min-width:103pt'>21.13.3</a> <span class='texttt'>ip::basic_endpoint</span> comparisons <a class='abbr_ref' href='internet.endpoint.comparisons'>[internet.endpoint.comparisons]</a></h3><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  constexpr bool operator==(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                            const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.address() == b.address() &amp;&amp; a.port() == b.port())</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  constexpr bool operator!=(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                            const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  constexpr bool operator&lt; (const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                            const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.comparisons-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.address() &lt; b.address() || (!(b.address() &lt; a.address()) &amp;&amp; a.port() &lt; b.port())</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  constexpr bool operator&gt; (const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                            const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.comparisons-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>b &lt; a</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  constexpr bool operator&lt;=(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                            const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.comparisons-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.comparisons-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(b &lt; a)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  constexpr bool operator&gt;=(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                            const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.comparisons-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.comparisons-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a &lt; b)</span>.
</p></div></div></div><div id='internet.endpoint.io'><h3 ><a class='secnum' href='#internet.endpoint.io' style='min-width:103pt'>21.13.4</a> <span class='texttt'>ip::basic_endpoint</span> I/O <a class='abbr_ref' href='internet.endpoint.io'>[internet.endpoint.io]</a></h3><p ><code class='itemdecl'>
template&lt;class CharT, class Traits, class InternetProtocol&gt;
  basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
    basic_ostream&lt;CharT, Traits&gt;&amp; os,
    const basic_endpoint&lt;InternetProtocol&gt;&amp; ep);
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.io-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.io-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Outputs a representation of the endpoint to the stream, as if it were implemented as follows:
</p><pre class='codeblock'>
basic_ostringstream&lt;CharT, Traits&gt; ss;
if (ep.protocol() == basic_endpoint&lt;InternetProtocol&gt;::protocol_type::v6())
  ss &lt;&lt; "[" &lt;&lt; ep.address() &lt;&lt; "]";
else
  ss &lt;&lt; ep.address();
ss &lt;&lt; ":" &lt;&lt; ep.port();
os &lt;&lt; ss.str();
</pre></div></div><div class='para' id='internet.endpoint.io-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.io-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>os</span>.
</p></div></div><div class='para' id='internet.endpoint.io-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.io-3'>3</a></div><p >[&nbsp;<i>Note:</i> The representation of the endpoint when it contains an IP version 6 address is based on [RFC2732]. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='internet.endpoint.extensible'><h3 ><a class='secnum' href='#internet.endpoint.extensible' style='min-width:103pt'>21.13.5</a> <span class='texttt'>ip::basic_endpoint</span> members (extensible implementations) <a class='abbr_ref' href='internet.endpoint.extensible'>[internet.endpoint.extensible]</a></h3><p ><code class='itemdecl'>
void* data() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.extensible-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.extensible-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>addressof(data_)</span>.
</p></div></div><p ><code class='itemdecl'>
const void* data() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.extensible-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.extensible-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>addressof(data_)</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr size_t size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.extensible-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.extensible-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>sizeof(sockaddr_in6)</span> if <span class='texttt'>protocol().family() == AF_INET6</span>, otherwise <span class='texttt'>sizeof(sockaddr_in)</span>.
</p></div></div><p ><code class='itemdecl'>
void resize(size_t s);
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.extensible-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.extensible-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>length_error</span> if the condition <span class='texttt'>protocol().family() == AF_INET6 &amp;&amp; s != sizeof(sockaddr_in6)</span> <span class='texttt'>||</span> <span class='texttt'>protocol().family() == AF_INET4 &amp;&amp; s != sizeof(sockaddr_in)</span> is <span class='texttt'>true</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr size_t capacity() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.endpoint.extensible-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.endpoint.extensible-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>sizeof(data_)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_resolver_entry'></a></span></p></div></div><div id='internet.resolver.entry'><h2 ><a class='secnum' href='#internet.resolver.entry' style='min-width:88pt'>21.14</a> Class template <span class='texttt'>ip::basic_resolver_entry</span> <a class='abbr_ref' href='internet.resolver.entry'>[internet.resolver.entry]</a></h2><div class='para' id='internet.resolver.entry-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.entry-1'>1</a></div><p >An object of type <span class='texttt'>basic_resolver_entry&lt;InternetProtocol&gt;</span> represents a single element in the results returned by a name resolution operation.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;class InternetProtocol&gt;
  class basic_resolver_entry
  {
  public:
    <span class='comment'>// types:
</span>    using protocol_type = InternetProtocol;
    using endpoint_type = typename InternetProtocol::endpoint;

    <span class='comment'>// constructors:
</span>    basic_resolver_entry();
    basic_resolver_entry(const endpoint_type&amp; ep,
                         string_view h,
                         string_view s);

    <span class='comment'>// members:
</span>    endpoint_type endpoint() const;
    operator endpoint_type() const;
    template&lt;class Allocator = allocator&lt;char&gt;&gt;
      basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
        host_name(const Allocator&amp; a = Allocator()) const;
    template&lt;class Allocator = allocator&lt;char&gt;&gt;
      basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
        service_name(const Allocator&amp; a = Allocator()) const;
  };

  <span class='comment'>// basic_resolver_entry comparisons:
</span>  template&lt;class InternetProtocol&gt;
    bool operator==(const basic_resolver_entry&lt;InternetProtocol&gt;&amp; a,
                    const basic_resolver_entry&lt;InternetProtocol&gt;&amp; b);
  template&lt;class InternetProtocol&gt;
    bool operator!=(const basic_resolver_entry&lt;InternetProtocol&gt;&amp; a,
                    const basic_resolver_entry&lt;InternetProtocol&gt;&amp; b);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div id='internet.resolver.entry.cons'><h3 ><a class='secnum' href='#internet.resolver.entry.cons' style='min-width:103pt'>21.14.1</a> <span class='texttt'>ip::basic_resolver_entry</span> constructors <a class='abbr_ref' href='internet.resolver.entry.cons'>[internet.resolver.entry.cons]</a></h3><p ><code class='itemdecl'>
basic_resolver_entry();
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.entry.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.entry.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>basic_resolver_entry&lt;InternetProtocol&gt;(endpoint_type(), "", "")</span>.
</p></div></div><p ><code class='itemdecl'>
basic_resolver_entry(const endpoint_type&amp; ep,
                     string_view h,
                     string_view s);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.entry.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.entry.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> 
</p><ul class='itemize'><li id='internet.resolver.entry.cons-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.resolver.entry.cons-2.1'>(2.1)</a></div><p ><span class='texttt'>endpoint() == ep</span>.
</p></li><li id='internet.resolver.entry.cons-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.resolver.entry.cons-2.2'>(2.2)</a></div><p ><span class='texttt'>host_name() == h</span>.
</p></li><li id='internet.resolver.entry.cons-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#internet.resolver.entry.cons-2.3'>(2.3)</a></div><p ><span class='texttt'>service_name() == s</span>.
</p></li></ul></div></div></div><div id='internet.resolver.entry.members'><h3 ><a class='secnum' href='#internet.resolver.entry.members' style='min-width:103pt'>21.14.2</a> <span class='texttt'>ip::basic_resolver_entry</span> members <a class='abbr_ref' href='internet.resolver.entry.members'>[internet.resolver.entry.members]</a></h3><p ><code class='itemdecl'>
endpoint_type endpoint() const;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.entry.members-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.entry.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The endpoint associated with the resolver entry.
</p></div></div><p ><code class='itemdecl'>
operator endpoint_type() const;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.entry.members-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.entry.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>endpoint()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Allocator = allocator&lt;char&gt;&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    host_name(const Allocator&amp; a = Allocator()) const;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.entry.members-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.entry.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> The host name associated with the resolver entry.</p></div></div><div class='para' id='internet.resolver.entry.members-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.entry.members-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> Ill-formed unless <span class='texttt'>allocator_traits&lt;Allocator&gt;::value_type</span> is <span class='texttt'>char</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Allocator = allocator&lt;char&gt;&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    service_name(const Allocator&amp; a = Allocator()) const;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.entry.members-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.entry.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> The service name associated with the resolver entry.</p></div></div><div class='para' id='internet.resolver.entry.members-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.entry.members-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i> Ill-formed unless <span class='texttt'>allocator_traits&lt;Allocator&gt;::value_type</span> is <span class='texttt'>char</span>.
</p></div></div></div><div id='internet.resolver.entry.comparisons'><h3 ><a class='secnum' href='#internet.resolver.entry.comparisons' style='min-width:103pt'>21.14.3</a> <span class='texttt'>op::basic_resolver_entry</span> comparisons <a class='abbr_ref' href='internet.resolver.entry.comparisons'>[internet.resolver.entry.comparisons]</a></h3><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  bool operator==(const basic_resolver_entry&lt;InternetProtocol&gt;&amp; a,
                  const basic_resolver_entry&lt;InternetProtocol&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.entry.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.entry.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.endpoint() == b.endpoint() &amp;&amp; a.host_name() == b.host_name() &amp;&amp; a.service_name() == b.service_name()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  bool operator!=(const basic_resolver_entry&lt;InternetProtocol&gt;&amp; a,
                  const basic_resolver_entry&lt;InternetProtocol&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.entry.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.entry.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_resolver_results'></a></span></p></div></div><div id='internet.resolver.results'><h2 ><a class='secnum' href='#internet.resolver.results' style='min-width:88pt'>21.15</a> Class template <span class='texttt'>ip::basic_resolver_results</span> <a class='abbr_ref' href='internet.resolver.results'>[internet.resolver.results]</a></h2><div class='para' id='internet.resolver.results-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results-1'>1</a></div><p >An object of type <span class='texttt'>basic_resolver_results&lt;InternetProtocol&gt;</span> represents a sequence of <span class='texttt'>basic_resolver_entry&lt;InternetProtocol&gt;</span> elements resulting from a single name resolution operation.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;class InternetProtocol&gt;
  class basic_resolver_results
  {
  public:
    <span class='comment'>// types:
</span>    using protocol_type = InternetProtocol;
    using endpoint_type = typename protocol_type::endpoint;
    using value_type = basic_resolver_entry&lt;protocol_type&gt;;
    using const_reference = const value_type&amp;;
    using reference = value_type&amp;;
    using const_iterator = <span class='indexparent'><a class='index' id='type_of_basic_resolver_results::const_iterator'></a></span><i>implementation-defined</i>;
    using iterator = const_iterator;
    using difference_type = ptrdiff_t;
    using size_type = size_t;

    <span class='comment'>// construct / copy / destroy:
</span>    basic_resolver_results();
    basic_resolver_results(const basic_resolver_results&amp; rhs);
    basic_resolver_results(basic_resolver_results&amp;&amp; rhs) noexcept;
    basic_resolver_results&amp; operator=(const basic_resolver_results&amp; rhs);
    basic_resolver_results&amp; operator=(basic_resolver_results&amp;&amp; rhs);
    ~basic_resolver_results();

    <span class='comment'>// size:
</span>    size_type size() const noexcept;
    size_type max_size() const noexcept;
    bool empty() const noexcept;

    <span class='comment'>// element access:
</span>    const_iterator begin() const;
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;

    <span class='comment'>// swap:
</span>    void swap(basic_resolver_results&amp; that) noexcept;
  };

  <span class='comment'>// basic_resolver_results comparisons:
</span>  template&lt;class InternetProtocol&gt;
    bool operator==(const basic_resolver_results&lt;InternetProtocol&gt;&amp; a,
                    const basic_resolver_results&lt;InternetProtocol&gt;&amp; b);
  template&lt;class InternetProtocol&gt;
    bool operator!=(const basic_resolver_results&lt;InternetProtocol&gt;&amp; a,
                    const basic_resolver_results&lt;InternetProtocol&gt;&amp; b);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='internet.resolver.results-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results-2'>2</a></div><p >The class template <span class='texttt'>basic_resolver_results</span> satisfies the requirements of a sequence container (C++Std &sect;<a href='../n4140/sequence.reqmts'>[sequence.reqmts]</a>), except that only the operations defined for const-qualified sequence containers are supported. The class template <span class='texttt'>basic_resolver_results</span> supports forward iterators.</p></div><div class='para' id='internet.resolver.results-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results-3'>3</a></div><p >A default-constructed <span class='texttt'>basic_resolver_results</span> object is empty. A non-empty results object is obtained only by calling a <span class='texttt'>basic_resolver</span> object's <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operations, or otherwise by copy construction, move construction, assignment, or swap from another non-empty results object.</p></div><div id='internet.resolver.results.cons'><h3 ><a class='secnum' href='#internet.resolver.results.cons' style='min-width:103pt'>21.15.1</a> <span class='texttt'>ip::basic_resolver_results</span> constructors <a class='abbr_ref' href='internet.resolver.results.cons'>[internet.resolver.results.cons]</a></h3><p ><code class='itemdecl'>
basic_resolver_results();
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.results.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>size() == 0</span>.
</p></div></div><p ><code class='itemdecl'>
basic_resolver_results(const basic_resolver_results&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.results.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this == rhs</span>.
</p></div></div><p ><code class='itemdecl'>
basic_resolver_results(basic_resolver_results&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.results.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>rhs</span>.
</p></div></div></div><div id='internet.resolver.results.assign'><h3 ><a class='secnum' href='#internet.resolver.results.assign' style='min-width:103pt'>21.15.2</a> <span class='texttt'>ip::basic_resolver_results</span> assignment <a class='abbr_ref' href='internet.resolver.results.assign'>[internet.resolver.results.assign]</a></h3><p ><code class='itemdecl'>
basic_resolver_results&amp; operator=(const basic_resolver_results&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.results.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.assign-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this == rhs</span>.</p></div></div><div class='para' id='internet.resolver.results.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
basic_resolver_results&amp; operator=(basic_resolver_results&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.results.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.assign-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='internet.resolver.results.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.assign-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='internet.resolver.results.size'><h3 ><a class='secnum' href='#internet.resolver.results.size' style='min-width:103pt'>21.15.3</a> <span class='texttt'>ip::basic_resolver_results</span> size <a class='abbr_ref' href='internet.resolver.results.size'>[internet.resolver.results.size]</a></h3><p ><code class='itemdecl'>
size_type size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.results.size-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.size-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of <span class='texttt'>basic_resolver_entry</span> elements in <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
size_type max_size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.results.size-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.size-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The maximum number of <span class='texttt'>basic_resolver_entry</span> elements that can be stored in <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
bool empty() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.results.size-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.size-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>size() == 0</span>.
</p></div></div></div><div id='internet.resolver.results.access'><h3 ><a class='secnum' href='#internet.resolver.results.access' style='min-width:103pt'>21.15.4</a> <span class='texttt'>ip::basic_resolver_results</span> element access <a class='abbr_ref' href='internet.resolver.results.access'>[internet.resolver.results.access]</a></h3><p ><code class='itemdecl'>
const_iterator begin() const;
const_iterator cbegin() const;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.results.access-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.access-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A starting iterator that enumerates over all the <span class='texttt'>basic_resolver_entry</span> elements stored in <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
const_iterator end() const;
const_iterator cend() const;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.results.access-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.access-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> A terminating iterator that enumerates over all the <span class='texttt'>basic_resolver_entry</span> elements stored in <span class='texttt'>*this</span>.
</p></div></div></div><div id='internet.resolver.results.swap'><h3 ><a class='secnum' href='#internet.resolver.results.swap' style='min-width:103pt'>21.15.5</a> <span class='texttt'>ip::basic_resolver_results</span> swap <a class='abbr_ref' href='internet.resolver.results.swap'>[internet.resolver.results.swap]</a></h3><p ><code class='itemdecl'>
void swap(basic_resolver_results&amp; that) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.results.swap-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.swap-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>that</span>, and <span class='texttt'>that</span> is equal to the prior value of <span class='texttt'>*this</span>.
</p></div></div></div><div id='internet.resolver.results.comparisons'><h3 ><a class='secnum' href='#internet.resolver.results.comparisons' style='min-width:103pt'>21.15.6</a> <span class='texttt'>ip::basic_resolver_results</span> comparisons <a class='abbr_ref' href='internet.resolver.results.comparisons'>[internet.resolver.results.comparisons]</a></h3><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  bool operator==(const basic_resolver_results&lt;InternetProtocol&gt;&amp; a,
                  const basic_resolver_results&lt;InternetProtocol&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.results.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.size() == b.size() &amp;&amp; equal(a.cbegin(), a.cend(), b.cbegin())</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  bool operator!=(const basic_resolver_results&lt;InternetProtocol&gt;&amp; a,
                  const basic_resolver_results&lt;InternetProtocol&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.results.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.results.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='resolver_base'></a></span></p></div></div><div id='internet.resolver.base'><h2 ><a class='secnum' href='#internet.resolver.base' style='min-width:88pt'>21.16</a> Class <span class='texttt'>ip::resolver_base</span> <a class='abbr_ref' href='internet.resolver.base'>[internet.resolver.base]</a></h2><p ><span class='indexparent'><a class='index' id='resolve_base'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class resolver_base
  {
  public:
    using flags = <i>T1</i>;
    static const flags passive;
    static const flags canonical_name;
    static const flags numeric_host;
    static const flags numeric_service;
    static const flags v4_mapped;
    static const flags all_matching;
    static const flags address_configured;

  protected:
    resolver_base();
    ~resolver_base();
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='internet.resolver.base-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.base-1'>1</a></div><p ><span class='texttt'>resolver_base</span> defines a bitmask type, <span class='texttt'>flags</span>, with the bitmask elements shown in Table <a href='internet.resolver.base#tab:internet.resolver.base.requirements'>[tab:internet.resolver.base.requirements]</a>.</p><div class='numberedTable' id='tab:internet.resolver.base.requirements'>Table <a href='#tab:internet.resolver.base.requirements'>37</a> — Resolver flags<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Constant name</b></td><td colspan='1' class='center'><b>POSIX macro</b></td><td colspan='1' class='center'><b>Definition or notes</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>passive</span>  </td><td class='left'>
<span class='texttt'>AI_PASSIVE</span>  </td><td class='left'>
 Returned endpoints are intended for use as locally bound socket endpoints.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>canonical_name</span>  </td><td class='left'>
<span class='texttt'>AI_CANONNAME</span>  </td><td class='left'>
 Determine the canonical name of the host specified in the query.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>numeric_host</span>  </td><td class='left'>
<span class='texttt'>AI_NUMERICHOST</span>  </td><td class='left'>
 Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no host name resolution should be attempted.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>numeric_service</span>  </td><td class='left'>
<span class='texttt'>AI_NUMERICSERV</span>  </td><td class='left'>
 Service name should be treated as a numeric string defining a port number and no service name resolution should be attempted.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>v4_mapped</span>  </td><td class='left'>
<span class='texttt'>AI_V4MAPPED</span>  </td><td class='left'>
 If the protocol is specified as an IPv6 protocol, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>all_matching</span>  </td><td class='left'>
<span class='texttt'>AI_ALL</span>  </td><td class='left'>
If used with <span class='texttt'>v4_mapped</span>, return all matching IPv6 and IPv4 addresses.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>address_configured</span>  </td><td class='left'>
<span class='texttt'>AI_ADDRCONFIG</span>  </td><td class='left'>
 Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system.  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='basic_resolver'></a></span></p></div></div><div id='internet.resolver'><h2 ><a class='secnum' href='#internet.resolver' style='min-width:88pt'>21.17</a> Class template <span class='texttt'>ip::basic_resolver</span> <a class='abbr_ref' href='internet.resolver'>[internet.resolver]</a></h2><div class='para' id='internet.resolver-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver-1'>1</a></div><p >Objects of type <span class='texttt'>basic_resolver&lt;InternetProtocol&gt;</span> are used to perform name resolution. Name resolution is the translation of a host name and service name into a sequence of endpoints, or the translation of an endpoint into its corresponding host name and service name.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;class InternetProtocol&gt;
  class basic_resolver : public resolver_base
  {
  public:
    <span class='comment'>// types:
</span>
    using executor_type = io_context::executor_type;
    using protocol_type = InternetProtocol;
    using endpoint_type = typename InternetProtocol::endpoint;
    using results_type = basic_resolver_results&lt;InternetProtocol&gt;;

    <span class='comment'>// construct / copy / destroy:
</span>
    explicit basic_resolver(io_context&amp; ctx);
    basic_resolver(const basic_resolver&amp;) = delete;
    basic_resolver(basic_resolver&amp;&amp; rhs) noexcept;

    ~basic_resolver();

    basic_resolver&amp; operator=(const basic_resolver&amp;) = delete;
    basic_resolver&amp; operator=(basic_resolver&amp;&amp; rhs);

    <span class='comment'>// basic_resolver operations:
</span>
    executor_type get_executor() noexcept;

    void cancel();

    results_type resolve(string_view host_name, string_view service_name);
    results_type resolve(string_view host_name, string_view service_name,
                         error_code&amp; ec);
    results_type resolve(string_view host_name, string_view service_name,
                         flags f);
    results_type resolve(string_view host_name, string_view service_name,
                         flags f, error_code&amp; ec);

    template&lt;class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_resolve(string_view host_name, string_view service_name,
                            CompletionToken&amp;&amp; token);
    template&lt;class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_resolve(string_view host_name, string_view service_name,
                            flags f, CompletionToken&amp;&amp; token);

    results_type resolve(const protocol_type&amp; protocol,
                         string_view host_name, string_view service_name);
    results_type resolve(const protocol_type&amp; protocol,
                         string_view host_name, string_view service_name,
                         error_code&amp; ec);
    results_type resolve(const protocol_type&amp; protocol,
                         string_view host_name, string_view service_name,
                         flags f);
    results_type resolve(const protocol_type&amp; protocol,
                         string_view host_name, string_view service_name,
                         flags f, error_code&amp; ec);

    template&lt;class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_resolve(const protocol_type&amp; protocol,
                            string_view host_name, string_view service_name,
                            CompletionToken&amp;&amp; token);
    template&lt;class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_resolve(const protocol_type&amp; protocol,
                            string_view host_name, string_view service_name,
                            flags f, CompletionToken&amp;&amp; token);

    results_type resolve(const endpoint_type&amp; e);
    results_type resolve(const endpoint_type&amp; e, error_code&amp; ec);

    template&lt;class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_resolve(const endpoint_type&amp; e,
                            CompletionToken&amp;&amp; token);
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div id='internet.resolver.cons'><h3 ><a class='secnum' href='#internet.resolver.cons' style='min-width:103pt'>21.17.1</a> <span class='texttt'>ip::basic_resolver</span> constructors <a class='abbr_ref' href='internet.resolver.cons'>[internet.resolver.cons]</a></h3><p ><code class='itemdecl'>
explicit basic_resolver(io_context&amp; ctx);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_executor() == ctx.get_executor()</span>.
</p></div></div><p ><code class='itemdecl'>
basic_resolver(basic_resolver&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs an object of class <span class='texttt'>basic_resolver&lt;InternetProtocol&gt;</span> that refers to the state originally represented by <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='internet.resolver.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_executor() == rhs.get_executor()</span>.
</p></div></div></div><div id='internet.resolver.dtor'><h3 ><a class='secnum' href='#internet.resolver.dtor' style='min-width:103pt'>21.17.2</a> <span class='texttt'>ip::basic_resolver</span> destructor <a class='abbr_ref' href='internet.resolver.dtor'>[internet.resolver.dtor]</a></h3><p ><code class='itemdecl'>
~basic_resolver();
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys the resolver, canceling all asynchronous operations associated with this resolver as if by calling <span class='texttt'>cancel()</span>.
</p></div></div></div><div id='internet.resolver.assign'><h3 ><a class='secnum' href='#internet.resolver.assign' style='min-width:103pt'>21.17.3</a> <span class='texttt'>ip::basic_resolver</span> assignment <a class='abbr_ref' href='internet.resolver.assign'>[internet.resolver.assign]</a></h3><p ><code class='itemdecl'>
basic_resolver&amp; operator=(basic_resolver&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Cancels all outstanding asynchronous operations associated with <span class='texttt'>*this</span> as if by calling <span class='texttt'>cancel()</span>, then moves into <span class='texttt'>*this</span> the state originally represented by <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='internet.resolver.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.assign-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_executor() == ctx.get_executor()</span>.</p></div></div><div class='para' id='internet.resolver.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.assign-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='internet.resolver.ops'><h3 ><a class='secnum' href='#internet.resolver.ops' style='min-width:103pt'>21.17.4</a> <span class='texttt'>ip::basic_resolver</span> operations <a class='abbr_ref' href='internet.resolver.ops'>[internet.resolver.ops]</a></h3><p ><code class='itemdecl'>
executor_type get_executor() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The associated executor.
</p></div></div><p ><code class='itemdecl'>
void cancel();
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Cancels all outstanding asynchronous resolve operations associated with <span class='texttt'>*this</span>. Completion handlers for canceled operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='internet.resolver.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> Does not block (C++Std &sect;<a href='../n4140/defns.block'>[defns.block]</a>) the calling thread pending completion of the canceled operations.
</p></div></div><p ><code class='itemdecl'>
results_type resolve(string_view host_name, string_view service_name);
results_type resolve(string_view host_name, string_view service_name,
                     error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>resolve(host_name, service_name, resolver_base::flags(), ec)</span>.
</p></div></div><p ><code class='itemdecl'>
results_type resolve(string_view host_name, string_view service_name,
                     flags f);
results_type resolve(string_view host_name, string_view service_name,
                     flags f, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>host_name.data() != nullptr</span>, let H be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>host_name</span>; otherwise, let H be <span class='texttt'>nullptr</span>. If <span class='texttt'>service_name.data() != nullptr</span>, let S be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>service_name</span>; otherwise, let S be <span class='texttt'>nullptr</span>. Resolves a host name and service name, as if by POSIX:
</p><pre class='codeblock'>
addrinfo hints;
hints.ai_flags = static_cast&lt;int&gt;(f);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = endpoint_type().protocol().type();
hints.ai_protocol = endpoint_type().protocol().protocol();
hints.ai_addr = nullptr;
hints.ai_addrlen = 0;
hints.ai_canonname = nullptr;
hints.ai_next = nullptr;
addrinfo* result = nullptr;
getaddrinfo(H, S, &amp;hints, &amp;result);
</pre></div></div><div class='para' id='internet.resolver.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, a non-empty results object containing the results of the resolve operation. Otherwise <span class='texttt'>results_type()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_resolve(string_view host_name, string_view service_name,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>async_resolve(host_name, service_name, resolver_base::flags(), forward&lt;CompletionToken&gt;(token))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_resolve(string_view host_name, string_view service_name,
                        flags f, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-8'>8</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, results_type r)</span>.</p></div></div><div class='para' id='internet.resolver.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>host_name.data() != nullptr</span>, let H be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>host_name</span>; otherwise, let H be <span class='texttt'>nullptr</span>. If <span class='texttt'>service_name.data() != nullptr</span>, let S be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>service_name</span>; otherwise, let S be <span class='texttt'>nullptr</span>. Initiates an asynchronous operation to resolve a host name and service name, as if by POSIX:
</p><pre class='codeblock'>
addrinfo hints;
hints.ai_flags = static_cast&lt;int&gt;(f);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = endpoint_type().protocol().type();
hints.ai_protocol = endpoint_type().protocol().protocol();
hints.ai_addr = nullptr;
hints.ai_addrlen = 0;
hints.ai_canonname = nullptr;
hints.ai_next = nullptr;
addrinfo* result = nullptr;
getaddrinfo(H, S, &amp;hints, &amp;result);
</pre><p >On success, <span class='texttt'>r</span> is a non-empty results object containing the results of the resolve operation. Otherwise, <span class='texttt'>r</span> is <span class='texttt'>results_type()</span>.
</p></div></div><p ><code class='itemdecl'>
results_type resolve(const protocol_type&amp; protocol,
                     string_view host_name, string_view service_name);
results_type resolve(const protocol_type&amp; protocol,
                     string_view host_name, string_view service_name,
                     error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.ops-10'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>resolve(protocol, host_name, service_name, resolver_base::flags(), ec)</span>.
</p></div></div><p ><code class='itemdecl'>
results_type resolve(const protocol_type&amp; protocol,
                     string_view host_name, string_view service_name,
                     flags f);
results_type resolve(const protocol_type&amp; protocol,
                     string_view host_name, string_view service_name,
                     flags f, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.ops-11'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>host_name.data() != nullptr</span>, let H be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>host_name</span>; otherwise, let H be <span class='texttt'>nullptr</span>. If <span class='texttt'>service_name.data() != nullptr</span>, let S be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>service_name</span>; otherwise, let S be <span class='texttt'>nullptr</span>. Resolves a host name and service name, as if by POSIX:
</p><pre class='codeblock'>
addrinfo hints;
hints.ai_flags = static_cast&lt;int&gt;(f);
hints.ai_family = protocol.family();
hints.ai_socktype = protocol.type();
hints.ai_protocol = protocol.protocol();
hints.ai_addr = nullptr;
hints.ai_addrlen = 0;
hints.ai_canonname = nullptr;
hints.ai_next = nullptr;
addrinfo* result = nullptr;
getaddrinfo(H, S, &amp;hints, &amp;result);
</pre></div></div><div class='para' id='internet.resolver.ops-12'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, a non-empty results object containing the results of the resolve operation. Otherwise <span class='texttt'>results_type()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_resolve(const protocol_type&amp; protocol,
                        string_view host_name, string_view service_name,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.ops-13'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>async_resolve(protocol, host_name, service_name, resolver_base::flags(), forward&lt;CompletionToken&gt;(token))</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_resolve(const protocol&amp; protocol,
                        string_view host_name, string_view service_name,
                        flags f, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.ops-14'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-14'>14</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, results_type r)</span>.</p></div></div><div class='para' id='internet.resolver.ops-15'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>host_name.data() != nullptr</span>, let H be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>host_name</span>; otherwise, let H be <span class='texttt'>nullptr</span>. If <span class='texttt'>service_name.data() != nullptr</span>, let S be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>service_name</span>; otherwise, let S be <span class='texttt'>nullptr</span>. Initiates an asynchronous operation to resolve a host name and service name, as if by POSIX:
</p><pre class='codeblock'>
addrinfo hints;
hints.ai_flags = static_cast&lt;int&gt;(f);
hints.ai_family = protocol.family();
hints.ai_socktype = protocol.type();
hints.ai_protocol = protocol.protocol();
hints.ai_addr = nullptr;
hints.ai_addrlen = 0;
hints.ai_canonname = nullptr;
hints.ai_next = nullptr;
addrinfo* result = nullptr;
getaddrinfo(H, S, &amp;hints, &amp;result);
</pre><p >On success, <span class='texttt'>r</span> is a non-empty results object containing the results of the resolve operation. Otherwise, <span class='texttt'>r</span> is <span class='texttt'>results_type()</span>.
</p></div></div><p ><code class='itemdecl'>
results_type resolve(const endpoint_type&amp; e);
results_type resolve(const endpoint_type&amp; e, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.ops-16'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> Let <span class='texttt'>S1</span> and <span class='texttt'>S2</span> be <span class='indexparent'><a class='index' id='maximum_length_of_host_and_service_names'></a></span>implementation-defined values that are sufficiently large to hold the host name and service name respectively. Resolves an endpoint as if by POSIX:
</p><pre class='codeblock'>
char host_name[S1];
char service_name[S2];
int flags = 0;
if (endpoint_type().protocol().type() == SOCK_DGRAM)
  flags |= NI_DGRAM;
int result = getnameinfo((const sockaddr*)e.data(), e.size(),
                         host_name, S1,
                         service_name, S2,
                         flags);
if (result != 0){
  flags |= NI_NUMERICSERV;
  result = getnameinfo((const sockaddr*)e.data(), e.size(),
                       host_name, S1,
                       service_name, S2,
                       flags);
}
</pre></div></div><div class='para' id='internet.resolver.ops-17'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-17'>17</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, a results object with <span class='texttt'>size() == 1</span> containing the results of the resolve operation. Otherwise <span class='texttt'>results_type()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_resolve(const endpoint_type&amp; e,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='internet.resolver.ops-18'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-18'>18</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec, results_type r)</span>.</p></div></div><div class='para' id='internet.resolver.ops-19'><div class='marginalizedparent'><a class='marginalized' href='#internet.resolver.ops-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> Let <span class='texttt'>S1</span> and <span class='texttt'>S2</span> be <span class='indexparent'><a class='index' id='maximum_length_of_host_and_service_names'></a></span>implementation-defined values that are sufficiently large to hold the host name and service name respectively. Initiates an asynchronous operation to resolve an endpoint as if by POSIX:
</p><pre class='codeblock'>
char host_name[S1];
char service_name[S2];
int flags = 0;
if (endpoint_type().protocol().type() == SOCK_DGRAM)
  flags |= NI_DGRAM;
int result = getnameinfo((const sockaddr*)e.data(), e.size(),
                         host_name, S1,
                         service_name, S2,
                         flags);
if (result != 0){
  flags |= NI_NUMERICSERV;
  result = getnameinfo((const sockaddr*)e.data(), e.size(),
                       host_name, S1,
                       service_name, S2,
                       flags);
}
</pre><p >On success, <span class='texttt'>r</span> is a results object with <span class='texttt'>size() == 1</span> containing the results of the resolve operation; otherwise, <span class='texttt'>r</span> is <span class='texttt'>results_type()</span>.
</p></div></div></div></div><div id='internet.host.name'><h2 ><a class='secnum' href='#internet.host.name' style='min-width:88pt'>21.18</a> Host name functions <a class='abbr_ref' href='internet.host.name'>[internet.host.name]</a></h2><p ><span class='indexparent'><a class='index' id='host_name'></a></span><code class='itemdecl'>
string host_name();
string host_name(error_code&amp; ec);
template&lt;class Allocator&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    host_name(const Allocator&amp; a);
template&lt;class Allocator&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    host_name(const Allocator&amp; a, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='internet.host.name-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.host.name-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The standard host name for the current machine, determined as if by POSIX <span class='texttt'>gethostname</span>.</p></div></div><div class='para' id='internet.host.name-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.host.name-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> In the last two overloads, ill-formed unless <span class='texttt'>allocator_traits&lt;Allocator&gt;::value_type</span> is <span class='texttt'>char</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tcp'></a></span></p></div><div id='internet.tcp'><h2 ><a class='secnum' href='#internet.tcp' style='min-width:88pt'>21.19</a> Class <span class='texttt'>ip::tcp</span> <a class='abbr_ref' href='internet.tcp'>[internet.tcp]</a></h2><div class='para' id='internet.tcp-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.tcp-1'>1</a></div><p >The class <span class='texttt'>tcp</span> encapsulates the types and flags necessary for TCP sockets.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class tcp
  {
  public:
    <span class='comment'>// types:
</span>    using endpoint = basic_endpoint&lt;tcp&gt;;
    using resolver = basic_resolver&lt;tcp&gt;;
    using socket = basic_stream_socket&lt;tcp&gt;;
    using acceptor = basic_socket_acceptor&lt;tcp&gt;;
    using iostream = basic_socket_iostream&lt;tcp&gt;;
    class no_delay;

    <span class='comment'>// static members:
</span>    static constexpr tcp v4() noexcept;
    static constexpr tcp v6() noexcept;

    tcp() = delete;
  };

  <span class='comment'>// tcp comparisons:
</span>  constexpr bool operator==(const tcp&amp; a, const tcp&amp; b) noexcept;
  constexpr bool operator!=(const tcp&amp; a, const tcp&amp; b) noexcept;

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='internet.tcp-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.tcp-2'>2</a></div><p >The <span class='texttt'>tcp</span> class meets the requirements for an <span class='texttt'>InternetProtocol</span> (<a href='internet.reqmts.protocol'>[internet.reqmts.protocol]</a>).</p><p ><span class='indexparent'><a class='index' id='extensible_implementation,tcp'></a></span><span class='indexparent'><a class='index' id='tcp,extensible_implementation'></a></span></p></div><div class='para' id='internet.tcp-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.tcp-3'>3</a></div><p >Extensible implementations provide the following member functions:</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class tcp
  {
  public:
    constexpr int family() const noexcept;
    constexpr int type() const noexcept;
    constexpr int protocol() const noexcept;
    <i>// remainder unchanged</i>
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='internet.tcp-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.tcp-4'>4</a></div><p >The return values for these member functions are listed in Table <a href='internet.tcp#tab:internet.tcp.requirements'>[tab:internet.tcp.requirements]</a>.</p><div class='numberedTable' id='tab:internet.tcp.requirements'>Table <a href='#tab:internet.tcp.requirements'>38</a> — Behavior of extensible <span class='texttt'>ip::tcp</span> implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>value</b></td><td colspan='1' class='center'><b>family()</b></td><td colspan='1' class='center'><b>type()</b></td><td colspan='1' class='center'><b>protocol()</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>tcp::v4()</span>  </td><td class='left'>
<span class='texttt'>AF_INET</span>  </td><td class='left'>
<span class='texttt'>SOCK_STREAM</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_TCP</span>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>tcp::v6()</span>  </td><td class='left'>
<span class='texttt'>AF_INET6</span>  </td><td class='left'>
<span class='texttt'>SOCK_STREAM</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_TCP</span>  </td></tr></table></div></div><div class='para' id='internet.tcp-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.tcp-5'>5</a></div><p >[&nbsp;<i>Note:</i> The constants <span class='texttt'>AF_INET</span>, <span class='texttt'>AF_INET6</span> and <span class='texttt'>SOCK_STREAM</span> are defined in the POSIX <span class='texttt'>&lt;sys/socket.h&gt;</span> header. The constant <span class='texttt'>IPPROTO_TCP</span> is defined in the POSIX <span class='texttt'>&lt;netinet/in.h&gt;</span> header. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='internet.tcp.comparisons'><h3 ><a class='secnum' href='#internet.tcp.comparisons' style='min-width:103pt'>21.19.1</a> <span class='texttt'>ip::tcp</span> comparisons <a class='abbr_ref' href='internet.tcp.comparisons'>[internet.tcp.comparisons]</a></h3><p ><code class='itemdecl'>
constexpr bool operator==(const tcp&amp; a, const tcp&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.tcp.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.tcp.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A boolean indicating whether two objects of class <span class='texttt'>tcp</span> are equal, such that the expression <span class='texttt'>tcp::v4() == tcp::v4()</span> is <span class='texttt'>true</span>, the expression <span class='texttt'>tcp::v6() == tcp::v6()</span> is <span class='texttt'>true</span>, and the expression <span class='texttt'>tcp::v4() == tcp::v6()</span> is <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool operator!=(const tcp&amp; a, const tcp&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.tcp.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.tcp.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='udp'></a></span></p></div></div><div id='internet.udp'><h2 ><a class='secnum' href='#internet.udp' style='min-width:88pt'>21.20</a> Class <span class='texttt'>ip::udp</span> <a class='abbr_ref' href='internet.udp'>[internet.udp]</a></h2><div class='para' id='internet.udp-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.udp-1'>1</a></div><p >The class <span class='texttt'>udp</span> encapsulates the types and flags necessary for UDP sockets.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class udp
  {
  public:
    <span class='comment'>// types:
</span>    using endpoint = basic_endpoint&lt;udp&gt;;
    using resolver = basic_resolver&lt;udp&gt;;
    using socket = basic_datagram_socket&lt;udp&gt;;

    <span class='comment'>// static members:
</span>    static constexpr udp v4() noexcept;
    static constexpr udp v6() noexcept;

    udp() = delete;
  };

  <span class='comment'>// udp comparisons:
</span>  constexpr bool operator==(const udp&amp; a, const udp&amp; b) noexcept;
  constexpr bool operator!=(const udp&amp; a, const udp&amp; b) noexcept;

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='internet.udp-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.udp-2'>2</a></div><p >The <span class='texttt'>udp</span> class meets the requirements for an <span class='texttt'>InternetProtocol</span> (<a href='internet.reqmts.protocol'>[internet.reqmts.protocol]</a>).</p><p ><span class='indexparent'><a class='index' id='extensible_implementation,udp'></a></span><span class='indexparent'><a class='index' id='udp,extensible_implementation'></a></span></p></div><div class='para' id='internet.udp-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.udp-3'>3</a></div><p >Extensible implementations provide the following member functions:</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class udp
  {
  public:
    constexpr int family() const noexcept;
    constexpr int type() const noexcept;
    constexpr int protocol() const noexcept;
    <i>// remainder unchanged</i>
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='internet.udp-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.udp-4'>4</a></div><p >The return values for these member functions are listed in Table <a href='internet.udp#tab:internet.udp.requirements'>[tab:internet.udp.requirements]</a>.</p><div class='numberedTable' id='tab:internet.udp.requirements'>Table <a href='#tab:internet.udp.requirements'>39</a> — Behavior of extensible <span class='texttt'>ip::udp</span> implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>value</b></td><td colspan='1' class='center'><b>family()</b></td><td colspan='1' class='center'><b>type()</b></td><td colspan='1' class='center'><b>protocol()</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>udp::v4()</span>  </td><td class='left'>
<span class='texttt'>AF_INET</span>  </td><td class='left'>
<span class='texttt'>SOCK_DGRAM</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_UDP</span>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>udp::v6()</span>  </td><td class='left'>
<span class='texttt'>AF_INET6</span>  </td><td class='left'>
<span class='texttt'>SOCK_DGRAM</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_UDP</span>  </td></tr></table></div></div><div class='para' id='internet.udp-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.udp-5'>5</a></div><p >[&nbsp;<i>Note:</i> The constants <span class='texttt'>AF_INET</span>, <span class='texttt'>AF_INET6</span> and <span class='texttt'>SOCK_DGRAM</span> are defined in the POSIX <span class='texttt'>&lt;sys/socket.h&gt;</span> header. The constant <span class='texttt'>IPPROTO_UDP</span> is defined in the POSIX <span class='texttt'>&lt;netinet/in.h&gt;</span> header. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='internet.udp.comparisons'><h3 ><a class='secnum' href='#internet.udp.comparisons' style='min-width:103pt'>21.20.1</a> <span class='texttt'>ip::udp</span> comparisons <a class='abbr_ref' href='internet.udp.comparisons'>[internet.udp.comparisons]</a></h3><p ><code class='itemdecl'>
constexpr bool operator==(const udp&amp; a, const udp&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.udp.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.udp.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A boolean indicating whether two objects of class <span class='texttt'>udp</span> are equal, such that the expression <span class='texttt'>udp::v4() == udp::v4()</span> is <span class='texttt'>true</span>, the expression <span class='texttt'>udp::v6() == udp::v6()</span> is <span class='texttt'>true</span>, and the expression <span class='texttt'>udp::v4() == udp::v6()</span> is <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool operator!=(const udp&amp; a, const udp&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.udp.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.udp.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div></div></div><div id='internet.socket.opt'><h2 ><a class='secnum' href='#internet.socket.opt' style='min-width:88pt'>21.21</a> Internet socket options <a class='abbr_ref' href='internet.socket.opt'>[internet.socket.opt]</a></h2><div class='para' id='internet.socket.opt-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.socket.opt-1'>1</a></div><p >In Table <a href='internet.socket.opt#tab:internet.socket.opt.requirements'>[tab:internet.socket.opt.requirements]</a>, let <i>C</i> denote a socket option class; let <i>L</i> identify the POSIX macro to be passed as the <span class='texttt'>level</span> argument to POSIX <span class='texttt'>setsockopt</span> and getsockopt; let <i>N</i> identify the POSIX macro to be passed as the <span class='texttt'>option_name</span> argument to POSIX <span class='texttt'>setsockopt</span> and <span class='texttt'>getsockopt</span>; let <i>T</i> identify the type of the value whose address will be passed as the <span class='texttt'>option_value</span> argument to POSIX <span class='texttt'>setsockopt</span> and <span class='texttt'>getsockopt</span>;
let <span class='texttt'>p</span> denote a value of a (possibly const) type meeting the protocol (<a href='socket.reqmts.protocol'>[socket.reqmts.protocol]</a>) requirements,
as passed to the socket option's <span class='texttt'>level</span> and <span class='texttt'>name</span> member functions;
and let <span class='texttt'>F</span> be the value of <span class='texttt'>p.family()</span>.</p><div class='numberedTable' id='tab:internet.socket.opt.requirements'>Table <a href='#tab:internet.socket.opt.requirements'>40</a> — Internet socket options<br><table ><tr class='rowsep'><td colspan='1' class='center'><b><i>C</i></b></td><td colspan='1' class='center'><b><i>L</i></b></td><td colspan='1' class='center'><b><i>N</i></b></td><td colspan='1' class='center'><b><i>T</i></b></td><td colspan='1' class='center'><b>Requirements,</b></td></tr><tr ><td class='left'>
  </td><td class='left'>
  </td><td class='left'>
  </td><td class='left'>
  </td><td colspan='1' class='center'><b>definition or notes</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>ip::tcp::</span><br/>
<span class='texttt'>no_delay</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_TCP</span>  </td><td class='left'>
<span class='texttt'>TCP_NODELAY</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether a TCP socket will avoid coalescing of small segments. [&nbsp;<i>Note:</i> That is, setting this option disables the Nagle algorithm. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::v6_only</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span>  </td><td class='left'>
<span class='texttt'>IPV6_V6ONLY</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether a socket created for an IPv6 protocol is restricted to IPv6 communications only. Implementations are not required to support setting the <span class='texttt'>v6_only</span> option to <span class='texttt'>false</span>, and the initial value of the <span class='texttt'>v6_only</span> option for a socket is <span class='indexparent'><a class='index' id='initial_value_of_the_v6_only_option_for_a_socket'></a></span>implementation-defined. [&nbsp;<i>Note:</i> As not all operating systems support dual stack IP networking. Some operating systems that do provide dual stack support offer a configuration option to disable it or to set the initial value of the <span class='texttt'>v6_only</span> socket option. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::unicast::</span>
<span class='texttt'>hops</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_UNICAST_HOPS</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_TTL</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the default number of hops (also known as time-to-live or TTL) on outbound datagrams. The constructor and assignment operator for the <span class='texttt'>ip::unicast::hops</span> class throw <span class='texttt'>out_of_range</span> if the <span class='texttt'>int</span> argument is not in the range <span class='texttt'>[0, 255]</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>join_group</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_JOIN_GROUP</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_ADD_MEMBERSHIP</span>  </td><td class='left'>
<span class='texttt'>ipv6_mreq</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>ip_mreq</span>  </td><td class='left'>
Satisfies the <span class='texttt'>MulticastGroupSocketOption</span> (<a href='internet.reqmts.opt.mcast'>[internet.reqmts.opt.mcast]</a>) type requirements. Requests that the socket join the specified multicast group.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>leave_group</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_LEAVE_GROUP</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_DROP_MEMBERSHIP</span>  </td><td class='left'>
<span class='texttt'>ipv6_mreq</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>ip_mreq</span>  </td><td class='left'>
Satisfies the <span class='texttt'>MulticastGroupSocketOption</span> (<a href='internet.reqmts.opt.mcast'>[internet.reqmts.opt.mcast]</a>) type requirements. Requests that the socket leave the specified multicast group.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>outbound_interface</span><br/> (<a href='internet.multicast.outbound'>[internet.multicast.outbound]</a>)  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_MULTICAST_IF</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_IF</span>  </td><td class='left'>
<span class='texttt'>unsigned int</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>in_addr</span>  </td><td class='left'>
 Specifies the network interface to use for outgoing multicast datagrams.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>hops</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_MULTICAST_HOPS</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_TTL</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the default number of hops (also known as time-to-live or TTL) on outbound datagrams. The constructor and assignment operator for the <span class='texttt'>ip::multicast::hops</span> class throw <span class='texttt'>out_of_range</span> if the <span class='texttt'>int</span> argument is not in the range <span class='texttt'>[0, 255]</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>enable_loopback</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_MULTICAST_LOOP</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_LOOP</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether multicast datagrams are delivered back to the local application.  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='outbound_interface'></a></span></p></div><div id='internet.multicast.outbound'><h3 ><a class='secnum' href='#internet.multicast.outbound' style='min-width:103pt'>21.21.1</a> Class <span class='texttt'>ip::multicast::outbound_interface</span> <a class='abbr_ref' href='internet.multicast.outbound'>[internet.multicast.outbound]</a></h3><div class='para' id='internet.multicast.outbound-1'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-1'>1</a></div><p >The <span class='texttt'>outbound_interface</span> class represents a socket option that specifies the network interface to use for outgoing multicast datagrams.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {
namespace multicast {

  class outbound_interface
  {
  public:
    <span class='comment'>// constructors:
</span>    explicit outbound_interface(const address_v4&amp; network_interface) noexcept;
    explicit outbound_interface(unsigned int network_interface) noexcept;
  };

} <span class='comment'>// namespace multicast
</span>} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='internet.multicast.outbound-2'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-2'>2</a></div><p ><span class='texttt'>outbound_interface</span> satisfies the requirements for <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>), <span class='texttt'>CopyConstructible</span> (C++Std &sect;<a href='../n4140/copyconstructible'>[copyconstructible]</a>), <span class='texttt'>CopyAssignable</span> (C++Std &sect;<a href='../n4140/copyassignable'>[copyassignable]</a>), and <span class='texttt'>SettableSocketOption</span> (<a href='socket.reqmts.settablesocketoption'>[socket.reqmts.settablesocketoption]</a>).</p><p ><span class='indexparent'><a class='index' id='extensible_implementation,outbound_interface'></a></span><span class='indexparent'><a class='index' id='outbound_interface,extensible_implementation'></a></span></p></div><div class='para' id='internet.multicast.outbound-3'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-3'>3</a></div><p >Extensible implementations provide the following member functions:</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {
namespace multicast {

  class outbound_interface
  {
  public:
    template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
    template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
    template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
    template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
    <span class='comment'>// <i>remainder unchanged</i>
</span>  private:
      in_addr v4_value_; <span class='comment'>// <i>exposition only</i>
</span>      unsigned int v6_value_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// namespace multicast
</span>} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><code class='itemdecl'>
explicit outbound_interface(const address_v4&amp; network_interface) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='internet.multicast.outbound-4'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> For extensible implementations, <span class='texttt'>v4_value_</span> is initialized to correspond to the IPv4 address <span class='texttt'>network_interface</span>, and <span class='texttt'>v6_value_</span> is zero-initialized.
</p></div></div><p ><code class='itemdecl'>
explicit outbound_interface(unsigned int network_interface) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.multicast.outbound-5'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> For extensible implementations, <span class='texttt'>v6_value_</span> is initialized to <span class='texttt'>network_interface</span>, and <span class='texttt'>v4_value_</span> is zero-initialized.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.multicast.outbound-6'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.multicast.outbound-7'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>IPV6_MULTICAST_IF</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_IF</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.multicast.outbound-8'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>addressof(v6_value_)</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>addressof(v4_value_)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='internet.multicast.outbound-9'><div class='marginalizedparent'><a class='marginalized' href='#internet.multicast.outbound-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>sizeof(v6_value_)</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>sizeof(v4_value_)</span>.
</p></div></div></div></div></div></div></body></html>