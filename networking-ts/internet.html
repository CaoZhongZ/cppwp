<!DOCTYPE html><html lang='en'><head><title>[internet]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='internet'><h1 ><a class='secnum' style='min-width:73pt'>21</a> Internet protocol <a class='abbr_ref' href='./#internet'>[internet]</a></h1><p ><span class='indexparent'><a class='index' id='experimental/internet'></a></span></p><div id='synop'><h2 ><a class='secnum' href='#synop' style='min-width:88pt'>21.1</a> Header <span class='texttt'>&lt;experimental/internet&gt;</span> synopsis <a class='abbr_ref' href='internet.synop'>[internet.synop]</a></h2><p ><span class='indexparent'><a class='index' id='resolver_errc'></a></span><span class='indexparent'><a class='index' id='port_type'></a></span><span class='indexparent'><a class='index' id='scope_id_type'></a></span><span class='indexparent'><a class='index' id='v4_mapped_t'></a></span><span class='indexparent'><a class='index' id='v4_mapped'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  enum class resolver_errc {
    host_not_found = <i>an <span class='indexparent'><a class='index' id='value_of_resolver_errc::host_not_found'></a></span>implementation-defined non-zero value</i>,   <span class='comment'>// <span class='texttt'><i>EAI_NONAME</i></span>
</span>    try_again = <i>an <span class='indexparent'><a class='index' id='value_of_resolver_errc::try_again'></a></span>implementation-defined non-zero value</i>,        <span class='comment'>// <span class='texttt'><i>EAI_AGAIN</i></span>
</span>    service_not_found = <i>an <span class='indexparent'><a class='index' id='value_of_resolver_errc::service_not_found'></a></span>implementation-defined non-zero value</i> <span class='comment'>// <span class='texttt'><i>EAI_SERVICE</i></span>
</span>  };

  const error_category&amp; resolver_category() noexcept;

  error_code make_error_code(resolver_errc e) noexcept;
  error_condition make_error_condition(resolver_errc e) noexcept;

  using port_type = uint_least16_t;
  using scope_id_type = uint_least32_t;

  struct v4_mapped_t {};
  constexpr v4_mapped_t v4_mapped;

  class address;
  class address_v4;
  class address_v6;

  class bad_address_cast;

  <span class='comment'>// <a href='internet.address.comparisons'>[internet.address.comparisons]</a>, address comparisons:
</span>  constexpr bool operator==(const address&amp;, const address&amp;) noexcept;
  constexpr bool operator!=(const address&amp;, const address&amp;) noexcept;
  constexpr bool operator&lt; (const address&amp;, const address&amp;) noexcept;
  constexpr bool operator&gt; (const address&amp;, const address&amp;) noexcept;
  constexpr bool operator&lt;=(const address&amp;, const address&amp;) noexcept;
  constexpr bool operator&gt;=(const address&amp;, const address&amp;) noexcept;

  <span class='comment'>// <a href='internet.address.v4.comparisons'>[internet.address.v4.comparisons]</a>, address_v4 comparisons:
</span>  constexpr bool operator==(const address_v4&amp;, const address_v4&amp;) noexcept;
  constexpr bool operator!=(const address_v4&amp;, const address_v4&amp;) noexcept;
  constexpr bool operator&lt; (const address_v4&amp;, const address_v4&amp;) noexcept;
  constexpr bool operator&gt; (const address_v4&amp;, const address_v4&amp;) noexcept;
  constexpr bool operator&lt;=(const address_v4&amp;, const address_v4&amp;) noexcept;
  constexpr bool operator&gt;=(const address_v4&amp;, const address_v4&amp;) noexcept;

  <span class='comment'>// <a href='internet.address.v6.comparisons'>[internet.address.v6.comparisons]</a>, address_v6 comparisons:
</span>  constexpr bool operator==(const address_v6&amp;, const address_v6&amp;) noexcept;
  constexpr bool operator!=(const address_v6&amp;, const address_v6&amp;) noexcept;
  constexpr bool operator&lt; (const address_v6&amp;, const address_v6&amp;) noexcept;
  constexpr bool operator&gt; (const address_v6&amp;, const address_v6&amp;) noexcept;
  constexpr bool operator&lt;=(const address_v6&amp;, const address_v6&amp;) noexcept;
  constexpr bool operator&gt;=(const address_v6&amp;, const address_v6&amp;) noexcept;

  <span class='comment'>// <a href='internet.address.creation'>[internet.address.creation]</a>, address creation:
</span>  address make_address(const char*);
  address make_address(const char*, error_code&amp;) noexcept;
  address make_address(const string&amp;);
  address make_address(const string&amp;, error_code&amp;) noexcept;
  address make_address(string_view);
  address make_address(string_view, error_code&amp;) noexcept;

  <span class='comment'>// <a href='internet.address.v4.creation'>[internet.address.v4.creation]</a>, address_v4 creation:
</span>  constexpr address_v4 make_address_v4(const address_v4::bytes_type&amp;);
  constexpr address_v4 make_address_v4(address_v4::uint_type);
  constexpr address_v4 make_address_v4(v4_mapped_t, const address_v6&amp;);
  address_v4 make_address_v4(const char*);
  address_v4 make_address_v4(const char*, error_code&amp;) noexcept;
  address_v4 make_address_v4(const string&amp;);
  address_v4 make_address_v4(const string&amp;, error_code&amp;) noexcept;
  address_v4 make_address_v4(string_view);
  address_v4 make_address_v4(string_view, error_code&amp;) noexcept;

  <span class='comment'>// <a href='internet.address.v6.creation'>[internet.address.v6.creation]</a>, address_v6 creation:
</span>  constexpr address_v6 make_address_v6(const address_v6::bytes_type&amp;,
                                       scope_id_type = 0);
  constexpr address_v6 make_address_v6(v4_mapped_t, const address_v4&amp;) noexcept;
  address_v6 make_address_v6(const char*);
  address_v6 make_address_v6(const char*, error_code&amp;) noexcept;
  address_v6 make_address_v6(const string&amp;);
  address_v6 make_address_v6(const string&amp;, error_code&amp;) noexcept;
  address_v6 make_address_v6(string_view);
  address_v6 make_address_v6(string_view, error_code&amp;) noexcept;

  <span class='comment'>// <a href='internet.address.io'>[internet.address.io]</a>, address I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp;, const address&amp;);

  <span class='comment'>// <a href='internet.address.v4.io'>[internet.address.v4.io]</a>, address_v4 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp;, const address_v4&amp;);

  <span class='comment'>// <a href='internet.address.v6.io'>[internet.address.v6.io]</a>, address_v6 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp;, const address_v6&amp;);

  template&lt;class&gt; class basic_address_iterator; <span class='comment'>// <i>not defined</i>
</span>  template&lt;&gt; class basic_address_iterator&lt;address_v4&gt;;
  using address_v4_iterator = basic_address_iterator&lt;address_v4&gt;;
  template&lt;&gt; class basic_address_iterator&lt;address_v6&gt;;
  using address_v6_iterator = basic_address_iterator&lt;address_v6&gt;;

  template&lt;class&gt; class basic_address_range; <span class='comment'>// <i>not defined</i>
</span>  template&lt;&gt; class basic_address_range&lt;address_v4&gt;;
  using address_v4_range = basic_address_range&lt;address_v4&gt;;
  template&lt;&gt; class basic_address_range&lt;address_v6&gt;;
  using address_v6_range = basic_address_range&lt;address_v6&gt;;

  class network_v4;
  class network_v6;

  <span class='comment'>// <a href='internet.network.v4.comparisons'>[internet.network.v4.comparisons]</a>, network_v4 comparisons:
</span>  bool operator==(const network_v4&amp;, const network_v4&amp;) noexcept;
  bool operator!=(const network_v4&amp;, const network_v4&amp;) noexcept;

  <span class='comment'>// <a href='internet.network.v6.comparisons'>[internet.network.v6.comparisons]</a>, network_v6 comparisons:
</span>  bool operator==(const network_v6&amp;, const network_v6&amp;) noexcept;
  bool operator!=(const network_v6&amp;, const network_v6&amp;) noexcept;

  <span class='comment'>// <a href='internet.network.v4.creation'>[internet.network.v4.creation]</a>, network_v4 creation:
</span>  network_v4 make_network_v4(const address_v4&amp;, int);
  network_v4 make_network_v4(const address_v4&amp;, const address_v4&amp;);
  network_v4 make_network_v4(const char*);
  network_v4 make_network_v4(const char*, error_code&amp;) noexcept;
  network_v4 make_network_v4(const string&amp;);
  network_v4 make_network_v4(const string&amp;, error_code&amp;) noexcept;
  network_v4 make_network_v4(string_view);
  network_v4 make_network_v4(string_view, error_code&amp;) noexcept;

  <span class='comment'>// <a href='internet.network.v6.creation'>[internet.network.v6.creation]</a>, network_v6 creation:
</span>  network_v6 make_network_v6(const address_v6&amp;, int);
  network_v6 make_network_v6(const char*);
  network_v6 make_network_v6(const char*, error_code&amp;) noexcept;
  network_v6 make_network_v6(const string&amp;);
  network_v6 make_network_v6(const string&amp;, error_code&amp;) noexcept;
  network_v6 make_network_v6(string_view);
  network_v6 make_network_v6(string_view, error_code&amp;) noexcept;

  <span class='comment'>// <a href='internet.network.v4.io'>[internet.network.v4.io]</a>, network_v4 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp;, const network_v4&amp;);

  <span class='comment'>// <a href='internet.network.v6.io'>[internet.network.v6.io]</a>, network_v6 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp;, const network_v6&amp;);

  template&lt;class InternetProtocol&gt;
    class basic_endpoint;

  <span class='comment'>// <a href='internet.endpoint.comparisons'>[internet.endpoint.comparisons]</a>, basic_endpoint comparisons:
</span>  template&lt;class InternetProtocol&gt;
    bool operator==(const basic_endpoint&lt;InternetProtocol&gt;&amp;,
                    const basic_endpoint&lt;InternetProtocol&gt;&amp;);
  template&lt;class InternetProtocol&gt;
    bool operator!=(const basic_endpoint&lt;InternetProtocol&gt;&amp;,
                    const basic_endpoint&lt;InternetProtocol&gt;&amp;);
  template&lt;class InternetProtocol&gt;
    bool operator&lt; (const basic_endpoint&lt;InternetProtocol&gt;&amp;,
                    const basic_endpoint&lt;InternetProtocol&gt;&amp;);
  template&lt;class InternetProtocol&gt;
    bool operator&gt; (const basic_endpoint&lt;InternetProtocol&gt;&amp;,
                    const basic_endpoint&lt;InternetProtocol&gt;&amp;);
  template&lt;class InternetProtocol&gt;
    bool operator&lt;=(const basic_endpoint&lt;InternetProtocol&gt;&amp;,
                    const basic_endpoint&lt;InternetProtocol&gt;&amp;);
  template&lt;class InternetProtocol&gt;
    bool operator&gt;=(const basic_endpoint&lt;InternetProtocol&gt;&amp;,
                    const basic_endpoint&lt;InternetProtocol&gt;&amp;);

  <span class='comment'>// <a href='internet.endpoint.io'>[internet.endpoint.io]</a>, basic_endpoint I/O:
</span>  template&lt;class CharT, class Traits, class InternetProtocol&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp;,
      const basic_endpoint&lt;InternetProtocol&gt;&amp;);

  template&lt;class InternetProtocol&gt;
    class basic_resolver_entry;

  template&lt;class InternetProtocol&gt;
    bool operator==(const basic_resolver_entry&lt;InternetProtocol&gt;&amp;,
                    const basic_resolver_entry&lt;InternetProtocol&gt;&amp;);
  template&lt;class InternetProtocol&gt;
    bool operator!=(const basic_resolver_entry&lt;InternetProtocol&gt;&amp;,
                    const basic_resolver_entry&lt;InternetProtocol&gt;&amp;);

  template&lt;class InternetProtocol&gt;
    class basic_resolver_results;

  template&lt;class InternetProtocol&gt;
    bool operator==(const basic_resolver_results&lt;InternetProtocol&gt;&amp;,
                    const basic_resolver_results&lt;InternetProtocol&gt;&amp;);
  template&lt;class InternetProtocol&gt;
    bool operator!=(const basic_resolver_results&lt;InternetProtocol&gt;&amp;,
                    const basic_resolver_results&lt;InternetProtocol&gt;&amp;);

  class resolver_base;

  template&lt;class InternetProtocol&gt;
    class basic_resolver;

  string host_name();
  string host_name(error_code&amp;);
  template&lt;class Allocator&gt;
    basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
      host_name(const Allocator&amp;);
  template&lt;class Allocator&gt;
    basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
      host_name(const Allocator&amp;, error_code&amp;);

  class tcp;

  <span class='comment'>// <a href='internet.tcp.comparisons'>[internet.tcp.comparisons]</a>, tcp comparisons:
</span>  bool operator==(const tcp&amp; a, const tcp&amp; b);
  bool operator!=(const tcp&amp; a, const tcp&amp; b);

  class udp;

  <span class='comment'>// <a href='internet.udp.comparisons'>[internet.udp.comparisons]</a>, udp comparisons:
</span>  bool operator==(const udp&amp; a, const udp&amp; b);
  bool operator!=(const udp&amp; a, const udp&amp; b);

  class v6_only;

  namespace unicast {

    class hops;

  } <span class='comment'>// namespace unicast
</span>
  namespace multicast {

    class join_group;

    class leave_group;

    class outbound_interface;

    class hops;

    class enable_loopback;

  } <span class='comment'>// namespace multicast
</span>} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>
  template&lt;&gt; struct is_error_condition_enum&lt;experimental::net::v1::ip::resolver_errc&gt;
    : public true_type {};

  <span class='comment'>// <a href='internet.hash'>[internet.hash]</a>, hash support
</span>  template&lt;class T&gt; struct hash;
  template&lt;&gt; struct hash&lt;experimental::net::v1::ip::address&gt;;
  template&lt;&gt; struct hash&lt;experimental::net::v1::ip::address_v4&gt;;
  template&lt;&gt; struct hash&lt;experimental::net::v1::ip::address_v6&gt;;

} <span class='comment'>// namespace std
</span></pre></div><div id='reqmts'><h2 ><a class='secnum' href='#reqmts' style='min-width:88pt'>21.2</a> Requirements <a class='abbr_ref' href='internet.reqmts'>[internet.reqmts]</a></h2><p ><span class='indexparent'><a class='index' id='InternetProtocol'></a></span><span class='indexparent'><a class='index' id='requirements,InternetProtocol'></a></span></p><div id='reqmts.protocol'><h3 ><a class='secnum' href='#reqmts.protocol' style='min-width:103pt'>21.2.1</a> Internet protocol requirements <a class='abbr_ref' href='internet.reqmts.protocol'>[internet.reqmts.protocol]</a></h3><div class='para' id='reqmts.protocol-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.protocol-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>InternetProtocol</span> requirements if it satisfies the requirements of <span class='texttt'>AcceptableProtocol</span> (<a href='socket.reqmts.acceptableprotocol'>[socket.reqmts.acceptableprotocol]</a>), as well as the additional requirements listed below.</p></div><div class='para' id='reqmts.protocol-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.protocol-2'>2</a></div><p >In the table below,
<span class='texttt'>a</span> and <span class='texttt'>b</span> denote (possibly const) values of type <span class='texttt'>X</span>.</p><div class='numberedTable' id='tab:internet.reqmts.protocol.requirements'>Table <a href='#tab:internet.reqmts.protocol.requirements'>35</a> — InternetProtocol requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>return type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::resolver</span>  </td><td class='left'>
<span class='texttt'>ip::basic_resolver&lt;X&gt;</span>  </td><td class='left'>
 The type of a resolver for the protocol.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::v4()</span>  </td><td class='left'>
<span class='texttt'>X</span>  </td><td class='left'>
 Returns an object representing the IP version 4 protocol.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::v6()</span>  </td><td class='left'>
<span class='texttt'>X</span>  </td><td class='left'>
 Returns an object representing the IP version 6 protocol.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a == b</span>  </td><td class='left'>
convertible to <span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>true</span> if <span class='texttt'>a</span> and <span class='texttt'>b</span> represent the same IP protocol version, otherwise <span class='texttt'>false</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>a != b</span>  </td><td class='left'>
convertible to <span class='texttt'>bool</span>  </td><td class='left'>
Returns <span class='texttt'>!(a == b)</span>.  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='MulticastGroupSocketOption'></a></span><span class='indexparent'><a class='index' id='requirements,MulticastGroupSocketOption'></a></span></p></div></div><div id='reqmts.opt.mcast'><h3 ><a class='secnum' href='#reqmts.opt.mcast' style='min-width:103pt'>21.2.2</a> Multicast group socket options <a class='abbr_ref' href='internet.reqmts.opt.mcast'>[internet.reqmts.opt.mcast]</a></h3><div class='para' id='reqmts.opt.mcast-1'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.opt.mcast-1'>1</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>MulticastGroupSocketOption</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (<span class='CppXref'>destructible</span>), <span class='texttt'>CopyConstructible</span> (<span class='CppXref'>copyconstructible</span>), <span class='texttt'>CopyAssignable</span> (<span class='CppXref'>copyassignable</span>), and <span class='texttt'>SettableSocketOption</span> (<a href='socket.reqmts.settablesocketoption'>[socket.reqmts.settablesocketoption]</a>), as well as the additional requirements listed below.</p></div><div class='para' id='reqmts.opt.mcast-2'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.opt.mcast-2'>2</a></div><p >In the table below,
<span class='texttt'>a</span> denotes a (possibly const) value of type <span class='texttt'>address</span>,
<span class='texttt'>b</span> and <span class='texttt'>c</span> denote (possibly const) values of type <span class='texttt'>address_v4</span>,
<span class='texttt'>d</span> denotes a (possibly const) value of type <span class='texttt'>address_v6</span>,
<span class='texttt'>e</span> denotes a (possibly const) value of type <span class='texttt'>unsigned int</span>,
and <span class='texttt'>u</span> denotes an identifier.</p><div class='numberedTable' id='tab:internet.reqmts.opt.mcast.requirements'>Table <a href='#tab:internet.reqmts.opt.mcast.requirements'>36</a> — MulticastGroupSocketOption requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X u(a);</span>  </td><td class='left'>
  </td><td class='left'>
 Constructs a multicast group socket option to join the group with the specified version-independent address.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(b, c);</span>  </td><td class='left'>
  </td><td class='left'>
 Constructs a multicast group socket option to join the specified IPv4 address on a specified network interface.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X u(d, e);</span>  </td><td class='left'>
  </td><td class='left'>
 Constructs a multicast group socket option to join the specified IPv6 address on a specified network interface.  </td></tr></table></div></div><div class='para' id='reqmts.opt.mcast-3'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.opt.mcast-3'>3</a></div><p >In this document, types that satisfy the <span class='texttt'>MulticastGroupSocketOption</span> requirements are defined as follows.</p><pre class='codeblock'>
class <i>C</i>{
public:
  <span class='comment'>// constructors:
</span>  explicit <i>C</i>(const address&amp; multicast_group) noexcept;
  explicit <i>C</i>(const address_v4&amp; multicast_group,
             const address_v4&amp; network_interface = address_v4::any()) noexcept;
  explicit <i>C</i>(const address_v6&amp; multicast_group,
             unsigned int network_interface = 0) noexcept;
};
</pre><p ><span class='indexextensible'>MulticastGroupSocketOption</span></p></div><div class='para' id='reqmts.opt.mcast-4'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.opt.mcast-4'>4</a></div><p >Extensible implementations provide the following member functions:</p><pre class='codeblock'>
class <i>C</i>{
public:
  template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
  template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
  template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
  template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
  <span class='comment'>// <i>remainder unchanged</i>
</span>private:
  ip_mreq v4_value_; <span class='comment'>// <i>exposition only</i>
</span>  ipv6_mreq v6_value_; <span class='comment'>// <i>exposition only</i>
</span>};
</pre></div><div class='para' id='reqmts.opt.mcast-5'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.opt.mcast-5'>5</a></div><p >Let <i>L</i> and <i>N</i> identify the POSIX macros to be passed as the <span class='texttt'>level</span> and <span class='texttt'>option_name</span> arguments, respectively, to POSIX <span class='texttt'>setsockopt</span> and <span class='texttt'>getsockopt</span>.</p><p ><code class='itemdecl'>
explicit <i>C</i>(const address&amp; multicast_group) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='reqmts.opt.mcast-6'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.opt.mcast-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>multicast_group.is_v6()</span> is <span class='texttt'>true</span>, calls <i>C</i><span class='texttt'>(multicast_group.to_v6())</span>; otherwise, calls <i>C</i><span class='texttt'>(multicast_group.to_v4())</span>.
</p></div></div><p ><code class='itemdecl'>
explicit <i>C</i>(const address_v4&amp; multicast_group,
           const address_v4&amp; network_interface = address_v4::any()) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='reqmts.opt.mcast-7'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.opt.mcast-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> For extensible implementations, <span class='texttt'>v4_value_.imr_multiaddr</span> is initialized to correspond to the address <span class='texttt'>multicast_group</span>, <span class='texttt'>v4_value_.imr_interface</span> is initialized to correspond to address <span class='texttt'>network_interface</span>, and <span class='texttt'>v6_value_</span> is zero-initialized.
</p></div></div><p ><code class='itemdecl'>
explicit <i>C</i>(const address_v6&amp; multicast_group,
           unsigned int network_interface = 0) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='reqmts.opt.mcast-8'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.opt.mcast-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> For extensible implementations, <span class='texttt'>v6_value_.ipv6mr_multiaddr</span> is initialized to correspond to the address <span class='texttt'>multicast_group</span>, <span class='texttt'>v6_value_.ipv6mr_interface</span> is initialized to <span class='texttt'>network_interface</span>, and <span class='texttt'>v4_value_</span> is zero-initialized.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='reqmts.opt.mcast-9'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.opt.mcast-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <i>L</i>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='reqmts.opt.mcast-10'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.opt.mcast-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <i>N</i>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='reqmts.opt.mcast-11'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.opt.mcast-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>addressof(v6_value_)</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>addressof(v4_value_)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='reqmts.opt.mcast-12'><div class='marginalizedparent'><a class='marginalized' href='#reqmts.opt.mcast-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>sizeof(v6_value_)</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>sizeof(v4_value_)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='error_codes,resolver'></a></span></p></div></div><div id='resolver.err'><h2 ><a class='secnum' href='#resolver.err' style='min-width:88pt'>21.3</a> Error codes <a class='abbr_ref' href='internet.resolver.err'>[internet.resolver.err]</a></h2><p ><span class='indexparent'><a class='index' id='resolver_category'></a></span><code class='itemdecl'>
const error_category&amp; resolver_category() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.err-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.err-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to an object of a type derived from class <span class='texttt'>error_category</span>. All calls to this function return references to the same object.</p></div></div><div class='para' id='resolver.err-2'><div class='marginalizedparent'><a class='marginalized' href='#resolver.err-2'>2</a></div><div class='itemdescr'><p >The object's <span class='texttt'>default_error_condition</span> and <span class='texttt'>equivalent</span> virtual functions behave as specified for the class <span class='texttt'>error_category</span>. The object's <span class='texttt'>name</span> virtual function returns a pointer to the string <span class='texttt'>"resolver"</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_error_code'></a></span><span class='indexparent'><a class='index' id='resolver_errc,make_error_code'></a></span><code class='itemdecl'>
error_code make_error_code(resolver_errc e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.err-3'><div class='marginalizedparent'><a class='marginalized' href='#resolver.err-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>error_code(static_cast&lt;int&gt;(e), resolver_category())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_error_condition'></a></span><span class='indexparent'><a class='index' id='resolver_errc,make_error_condition'></a></span><code class='itemdecl'>
error_condition make_error_condition(resolver_errc e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.err-4'><div class='marginalizedparent'><a class='marginalized' href='#resolver.err-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>error_condition(static_cast&lt;int&gt;(e), resolver_category())</span>.
</p></div></div></div><div id='address'><h2 ><a class='secnum' href='#address' style='min-width:88pt'>21.4</a> Class <span class='texttt'>ip::address</span> <a class='abbr_ref' href='internet.address'>[internet.address]</a></h2><div class='para' id='address-1'><div class='marginalizedparent'><a class='marginalized' href='#address-1'>1</a></div><p >The class <span class='texttt'>address</span> is a version-independent representation for an IP address. An object of class <span class='texttt'>address</span> holds either an IPv4 address, an IPv6 address, or no valid address.</p><p ><span class='indexparent'><a class='index' id='address'></a></span><span class='indexparent'><a class='index' id='address,is_v4'></a></span><span class='indexparent'><a class='index' id='address,is_v6'></a></span><span class='indexparent'><a class='index' id='address,to_v4'></a></span><span class='indexparent'><a class='index' id='address,to_v6'></a></span><span class='indexparent'><a class='index' id='address,is_unspecified'></a></span><span class='indexparent'><a class='index' id='address,is_loopback'></a></span><span class='indexparent'><a class='index' id='address,is_multicast'></a></span><span class='indexparent'><a class='index' id='address,to_string'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class address
  {
  public:
    <span class='comment'>// <a href='internet.address.cons'>[internet.address.cons]</a>, constructors:
</span>    constexpr address() noexcept;
    constexpr address(const address&amp; a) noexcept;
    constexpr address(const address_v4&amp; a) noexcept;
    constexpr address(const address_v6&amp; a) noexcept;

    <span class='comment'>// <a href='internet.address.assign'>[internet.address.assign]</a>, assignment:
</span>    address&amp; operator=(const address&amp; a) noexcept;
    address&amp; operator=(const address_v4&amp; a) noexcept;
    address&amp; operator=(const address_v6&amp; a) noexcept;

    <span class='comment'>// <a href='internet.address.members'>[internet.address.members]</a>, members:
</span>    constexpr bool is_v4() const noexcept;
    constexpr bool is_v6() const noexcept;
    constexpr address_v4 to_v4() const;
    constexpr address_v6 to_v6() const;
    constexpr bool is_unspecified() const noexcept;
    constexpr bool is_loopback() const noexcept;
    constexpr bool is_multicast() const noexcept;
    template&lt;class Allocator = allocator&lt;char&gt;&gt;
      basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
        to_string(const Allocator&amp; a = Allocator()) const;

  private:
    address_v4 v4_; <span class='comment'>// <i>exposition only</i>
</span>    address_v6 v6_; <span class='comment'>// <i>exposition only</i>
</span>  };

  <span class='comment'>// <a href='internet.address.comparisons'>[internet.address.comparisons]</a>, address comparisons:
</span>  constexpr bool operator==(const address&amp; a, const address&amp; b) noexcept;
  constexpr bool operator!=(const address&amp; a, const address&amp; b) noexcept;
  constexpr bool operator&lt; (const address&amp; a, const address&amp; b) noexcept;
  constexpr bool operator&gt; (const address&amp; a, const address&amp; b) noexcept;
  constexpr bool operator&lt;=(const address&amp; a, const address&amp; b) noexcept;
  constexpr bool operator&gt;=(const address&amp; a, const address&amp; b) noexcept;

  <span class='comment'>// <a href='internet.address.creation'>[internet.address.creation]</a>, address creation:
</span>  address make_address(const char* str);
  address make_address(const char* str, error_code&amp; ec) noexcept;
  address make_address(const string&amp; str);
  address make_address(const string&amp; str, error_code&amp; ec) noexcept;
  address make_address(string_view str);
  address make_address(string_view str, error_code&amp; ec) noexcept;

  <span class='comment'>// <a href='internet.address.io'>[internet.address.io]</a>, address I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp; os, const address&amp; addr);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><span class='indexparent'><a class='index' id='address'></a></span></p></div><div class='para' id='address-2'><div class='marginalizedparent'><a class='marginalized' href='#address-2'>2</a></div><p ><span class='texttt'>address</span> satisfies the requirements for <span class='texttt'>Destructible</span> (<span class='CppXref'>destructible</span>), <span class='texttt'>CopyConstructible</span> (<span class='CppXref'>copyconstructible</span>), and <span class='texttt'>CopyAssignable</span> (<span class='CppXref'>copyassignable</span>).</p><p ><span class='indexparent'><a class='index' id='address,constructor'></a></span></p></div><div id='address.cons'><h3 ><a class='secnum' href='#address.cons' style='min-width:103pt'>21.4.1</a> <span class='texttt'>ip::address</span> constructors <a class='abbr_ref' href='internet.address.cons'>[internet.address.cons]</a></h3><p ><code class='itemdecl'>
constexpr address() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#address.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_v4() == true</span>, <span class='texttt'>is_v6() == false</span>, and <span class='texttt'>is_unspecified() == true</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr address(const address_v4&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#address.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>v4_</span> with <span class='texttt'>a</span>.</p></div></div><div class='para' id='address.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#address.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_v4() == true</span> and <span class='texttt'>is_v6() == false</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr address(const address_v6&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#address.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>v6_</span> with <span class='texttt'>a</span>.</p></div></div><div class='para' id='address.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#address.cons-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_v4() == false</span> and <span class='texttt'>is_v6() == true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,address'></a></span><span class='indexparent'><a class='index' id='address,operator='></a></span></p></div><div id='address.assign'><h3 ><a class='secnum' href='#address.assign' style='min-width:103pt'>21.4.2</a> <span class='texttt'>ip::address</span> assignment <a class='abbr_ref' href='internet.address.assign'>[internet.address.assign]</a></h3><p ><code class='itemdecl'>
address&amp; operator=(const address_v4&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#address.assign-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_v4() == true</span> and <span class='texttt'>is_v6() == false</span> and <span class='texttt'>to_v4() == a</span>.</p></div></div><div class='para' id='address.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#address.assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div><p ><code class='itemdecl'>
address&amp; operator=(const address_v6&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#address.assign-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_v4() == false</span> and <span class='texttt'>is_v6() == true</span> and <span class='texttt'>to_v6() == a</span>.</p></div></div><div class='para' id='address.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#address.assign-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div></div><div id='address.members'><h3 ><a class='secnum' href='#address.members' style='min-width:103pt'>21.4.3</a> <span class='texttt'>ip::address</span> members <a class='abbr_ref' href='internet.address.members'>[internet.address.members]</a></h3><p ><span class='indexparent'><a class='index' id='is_v4,address'></a></span><span class='indexparent'><a class='index' id='address,is_v4'></a></span><code class='itemdecl'>
constexpr bool is_v4() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.members-1'><div class='marginalizedparent'><a class='marginalized' href='#address.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the object contains an IP version 4 address, otherwise <span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_v6,address'></a></span><span class='indexparent'><a class='index' id='address,is_v6'></a></span><code class='itemdecl'>
constexpr bool is_v6() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.members-2'><div class='marginalizedparent'><a class='marginalized' href='#address.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the object contains an IP version 6 address, otherwise <span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_v4,address'></a></span><span class='indexparent'><a class='index' id='address,to_v4'></a></span><code class='itemdecl'>
constexpr address_v4 to_v4() const;
</code></p><div class='itemdescr'></div><div class='para' id='address.members-3'><div class='marginalizedparent'><a class='marginalized' href='#address.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>v4_</span>.</p></div></div><div class='para' id='address.members-4'><div class='marginalizedparent'><a class='marginalized' href='#address.members-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>bad_address_cast</span> if <span class='texttt'>is_v4() == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_v6,address'></a></span><span class='indexparent'><a class='index' id='address,to_v6'></a></span><code class='itemdecl'>
constexpr address_v6 to_v6() const;
</code></p><div class='itemdescr'></div><div class='para' id='address.members-5'><div class='marginalizedparent'><a class='marginalized' href='#address.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>v6_</span>.</p></div></div><div class='para' id='address.members-6'><div class='marginalizedparent'><a class='marginalized' href='#address.members-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>bad_address_cast</span> if <span class='texttt'>is_v6() == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_unspecified,address'></a></span><span class='indexparent'><a class='index' id='address,is_unspecified'></a></span><code class='itemdecl'>
constexpr bool is_unspecified() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.members-7'><div class='marginalizedparent'><a class='marginalized' href='#address.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>is_v4()</span>, returns <span class='texttt'>v4_.is_unspecified()</span>. Otherwise returns <span class='texttt'>v6_.is_unspecified()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_loopback,address'></a></span><span class='indexparent'><a class='index' id='address,is_loopback'></a></span><code class='itemdecl'>
constexpr bool is_loopback() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.members-8'><div class='marginalizedparent'><a class='marginalized' href='#address.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>is_v4()</span>, returns <span class='texttt'>v4_.is_loopback()</span>. Otherwise returns <span class='texttt'>v6_.is_loopback()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_multicast,address'></a></span><span class='indexparent'><a class='index' id='address,is_multicast'></a></span><code class='itemdecl'>
constexpr bool is_multicast() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.members-9'><div class='marginalizedparent'><a class='marginalized' href='#address.members-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>is_v4()</span>, returns <span class='texttt'>v4_.is_multicast()</span>. Otherwise returns <span class='texttt'>v6_.is_multicast()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_string,address'></a></span><span class='indexparent'><a class='index' id='address,to_string'></a></span><code class='itemdecl'>
template&lt;class Allocator = allocator&lt;char&gt;&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    to_string(const Allocator&amp; a = Allocator()) const;
</code></p><div class='itemdescr'></div><div class='para' id='address.members-10'><div class='marginalizedparent'><a class='marginalized' href='#address.members-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>is_v4()</span>, returns <span class='texttt'>v4_.to_string(a)</span>. Otherwise returns <span class='texttt'>v6_.to_string(a)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator==,address'></a></span><span class='indexparent'><a class='index' id='address,operator=='></a></span></p></div><div id='address.comparisons'><h3 ><a class='secnum' href='#address.comparisons' style='min-width:103pt'>21.4.4</a> <span class='texttt'>ip::address</span> comparisons <a class='abbr_ref' href='internet.address.comparisons'>[internet.address.comparisons]</a></h3><p ><code class='itemdecl'>
constexpr bool operator==(const address&amp; a, const address&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#address.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><ul class='itemize'><li id='address.comparisons-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#address.comparisons-1.1'>(1.1)</a></div><p >if <span class='texttt'>a.is_v4() != b.is_v4()</span>, <span class='texttt'>false</span>;
</p></li><li id='address.comparisons-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#address.comparisons-1.2'>(1.2)</a></div><p >if <span class='texttt'>a.is_v4()</span>, the result of <span class='texttt'>a.v4_ == b.v4_</span>;
</p></li><li id='address.comparisons-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#address.comparisons-1.3'>(1.3)</a></div><p >otherwise, the result of <span class='texttt'>a.v6_ == b.v6_</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='operator!=,address'></a></span><span class='indexparent'><a class='index' id='address,operator!='></a></span><code class='itemdecl'>
constexpr bool operator!=(const address&amp; a, const address&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#address.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,address'></a></span><span class='indexparent'><a class='index' id='address,operator<'></a></span><code class='itemdecl'>
constexpr bool operator&lt; (const address&amp; a, const address&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#address.comparisons-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><ul class='itemize'><li id='address.comparisons-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#address.comparisons-3.1'>(3.1)</a></div><p >if <span class='texttt'>a.is_v4() &amp;&amp; !b.is_v4()</span>, <span class='texttt'>true</span>;
</p></li><li id='address.comparisons-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#address.comparisons-3.2'>(3.2)</a></div><p >if <span class='texttt'>!a.is_v4() &amp;&amp; b.is_v4()</span>, <span class='texttt'>false</span>;
</p></li><li id='address.comparisons-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#address.comparisons-3.3'>(3.3)</a></div><p >if <span class='texttt'>a.is_v4()</span>, the result of <span class='texttt'>a.v4_ &lt; b.v4_</span>;
</p></li><li id='address.comparisons-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#address.comparisons-3.4'>(3.4)</a></div><p >otherwise, the result of <span class='texttt'>a.v6_ &lt; b.v6_</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='operator>,address'></a></span><span class='indexparent'><a class='index' id='address,operator>'></a></span><code class='itemdecl'>
constexpr bool operator&gt; (const address&amp; a, const address&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#address.comparisons-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>b &lt; a</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,address'></a></span><span class='indexparent'><a class='index' id='address,operator<='></a></span><code class='itemdecl'>
constexpr bool operator&lt;=(const address&amp; a, const address&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.comparisons-5'><div class='marginalizedparent'><a class='marginalized' href='#address.comparisons-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(b &lt; a)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,address'></a></span><span class='indexparent'><a class='index' id='address,operator>='></a></span><code class='itemdecl'>
constexpr bool operator&gt;=(const address&amp; a, const address&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.comparisons-6'><div class='marginalizedparent'><a class='marginalized' href='#address.comparisons-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a &lt; b)</span>.
</p></div></div></div><div id='address.creation'><h3 ><a class='secnum' href='#address.creation' style='min-width:103pt'>21.4.5</a> <span class='texttt'>ip::address</span> creation <a class='abbr_ref' href='internet.address.creation'>[internet.address.creation]</a></h3><p ><span class='indexparent'><a class='index' id='make_address'></a></span><code class='itemdecl'>
address make_address(const char* str);
address make_address(const char* str, error_code&amp; ec) noexcept;
address make_address(const string&amp; str);
address make_address(const string&amp; str, error_code&amp; ec) noexcept;
address make_address(string_view str);
address make_address(string_view str, error_code&amp; ec) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.creation-1'><div class='marginalizedparent'><a class='marginalized' href='#address.creation-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Converts a textual representation of an address into an object of class <span class='texttt'>address</span>, as if by calling:
</p><pre class='codeblock'>
address a;
address_v6 v6a = make_address_v6(str, ec);
if (!ec)
  a = v6a;
else{
  address_v4 v4a = make_address_v4(str, ec);
  if (!ec)
    a = v4a;
}
</pre></div></div><div class='para' id='address.creation-2'><div class='marginalizedparent'><a class='marginalized' href='#address.creation-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a</span>.
</p></div></div></div><div id='address.io'><h3 ><a class='secnum' href='#address.io' style='min-width:103pt'>21.4.6</a> <span class='texttt'>ip::address</span> I/O <a class='abbr_ref' href='internet.address.io'>[internet.address.io]</a></h3><p ><span class='indexparent'><a class='index' id='operator<<,address'></a></span><span class='indexparent'><a class='index' id='address,operator<<'></a></span><code class='itemdecl'>
template&lt;class CharT, class Traits&gt;
  basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
    basic_ostream&lt;CharT, Traits&gt;&amp; os, const address&amp; addr);
</code></p><div class='itemdescr'></div><div class='para' id='address.io-1'><div class='marginalizedparent'><a class='marginalized' href='#address.io-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>os &lt;&lt; addr.to_string().c_str()</span>.
</p></div></div></div></div><div id='address.v4'><h2 ><a class='secnum' href='#address.v4' style='min-width:88pt'>21.5</a> Class <span class='texttt'>ip::address_v4</span> <a class='abbr_ref' href='internet.address.v4'>[internet.address.v4]</a></h2><div class='para' id='address.v4-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v4-1'>1</a></div><p >The class <span class='texttt'>address_v4</span> is a representation of an IPv4 address.</p><p ><span class='indexparent'><a class='index' id='address_v4'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class address_v4
  {
  public:
    <span class='comment'>// <a href='internet.address.v4.bytes'>[internet.address.v4.bytes]</a>, types:
</span>    using uint_type = uint_least32_t;
    struct bytes_type;

    <span class='comment'>// <a href='internet.address.v4.cons'>[internet.address.v4.cons]</a>, constructors:
</span>    constexpr address_v4() noexcept;
    constexpr address_v4(const address_v4&amp; a) noexcept;
    constexpr address_v4(const bytes_type&amp; bytes);
    explicit constexpr address_v4(uint_type val);

    <span class='comment'>// assignment:
</span>    address_v4&amp; operator=(const address_v4&amp; a) noexcept;

    <span class='comment'>// <a href='internet.address.v4.members'>[internet.address.v4.members]</a>, members:
</span>    constexpr bool is_unspecified() const noexcept;
    constexpr bool is_loopback() const noexcept;
    constexpr bool is_multicast() const noexcept;
    constexpr bytes_type to_bytes() const noexcept;
    constexpr uint_type to_uint() const noexcept;
    template&lt;class Allocator = allocator&lt;char&gt;&gt;
      basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
        to_string(const Allocator&amp; a = Allocator()) const;

    <span class='comment'>// <a href='internet.address.v4.static'>[internet.address.v4.static]</a>, static members:
</span>    static constexpr address_v4 any() noexcept;
    static constexpr address_v4 loopback() noexcept;
    static constexpr address_v4 broadcast() noexcept;
  };

  <span class='comment'>// <a href='internet.address.v4.comparisons'>[internet.address.v4.comparisons]</a>, address_v4 comparisons:
</span>  constexpr bool operator==(const address_v4&amp; a, const address_v4&amp; b) noexcept;
  constexpr bool operator!=(const address_v4&amp; a, const address_v4&amp; b) noexcept;
  constexpr bool operator&lt; (const address_v4&amp; a, const address_v4&amp; b) noexcept;
  constexpr bool operator&gt; (const address_v4&amp; a, const address_v4&amp; b) noexcept;
  constexpr bool operator&lt;=(const address_v4&amp; a, const address_v4&amp; b) noexcept;
  constexpr bool operator&gt;=(const address_v4&amp; a, const address_v4&amp; b) noexcept;

  <span class='comment'>// <a href='internet.address.v4.creation'>[internet.address.v4.creation]</a>, address_v4 creation:
</span>  constexpr address_v4 make_address_v4(const address_v4::bytes_type&amp; bytes);
  constexpr address_v4 make_address_v4(address_v4::uint_type val);
  constexpr address_v4 make_address_v4(v4_mapped_t, const address_v6&amp; a);
  address_v4 make_address_v4(const char* str);
  address_v4 make_address_v4(const char* str, error_code&amp; ec) noexcept;
  address_v4 make_address_v4(const string&amp; str);
  address_v4 make_address_v4(const string&amp; str, error_code&amp; ec) noexcept;
  address_v4 make_address_v4(string_view str);
  address_v4 make_address_v4(string_view str, error_code&amp; ec) noexcept;

  <span class='comment'>// <a href='internet.address.v4.io'>[internet.address.v4.io]</a>, address_v4 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp; os, const address_v4&amp; addr);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='address.v4-2'><div class='marginalizedparent'><a class='marginalized' href='#address.v4-2'>2</a></div><p ><span class='texttt'>address_v4</span> satisfies the requirements for <span class='texttt'>Destructible</span> (<span class='CppXref'>destructible</span>), <span class='texttt'>CopyConstructible</span> (<span class='CppXref'>copyconstructible</span>), and <span class='texttt'>CopyAssignable</span> (<span class='CppXref'>copyassignable</span>).</p></div><div id='address.v4.bytes'><h3 ><a class='secnum' href='#address.v4.bytes' style='min-width:103pt'>21.5.1</a> Struct <span class='texttt'>ip::address_v4::bytes_type</span> <a class='abbr_ref' href='internet.address.v4.bytes'>[internet.address.v4.bytes]</a></h3><p ><span class='indexparent'><a class='index' id='bytes_type,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,bytes_type'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  struct address_v4::bytes_type : array&lt;unsigned char, 4&gt;
  {
    template&lt;class... T&gt; explicit constexpr bytes_type(T... t)
      : array&lt;unsigned char, 4&gt;{{static_cast&lt;unsigned char&gt;(t)...}} {}
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='address.v4.bytes-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.bytes-1'>1</a></div><p >The <span class='texttt'>ip::address_v4::bytes_type</span> type is a standard-layout struct that provides a byte-level representation of an IPv4 address in network byte order.</p><p ><span class='indexparent'><a class='index' id='address_v4,constructor'></a></span></p></div></div><div id='address.v4.cons'><h3 ><a class='secnum' href='#address.v4.cons' style='min-width:103pt'>21.5.2</a> <span class='texttt'>ip::address_v4</span> constructors <a class='abbr_ref' href='internet.address.v4.cons'>[internet.address.v4.cons]</a></h3><p ><code class='itemdecl'>
constexpr address_v4() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>to_bytes()</span> yields <span class='texttt'>{0, 0, 0, 0}</span> and <span class='texttt'>to_uint() == 0</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v4(const bytes_type&amp; bytes);
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.cons-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>out_of_range</span> if any element of <span class='texttt'>bytes</span> is not in the range <span class='texttt'>[0, 0xFF]</span>. [&nbsp;<i>Note:</i> For implementations where <span class='texttt'>numeric_limits&lt;unsigned char&gt;::max() == 0xFF</span>, no out-of-range detection is needed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='address.v4.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>to_bytes() == bytes</span> and <span class='texttt'>to_uint() == (bytes[0] &lt;&lt; 24) | (bytes[1] &lt;&lt; 16) | (bytes[2] &lt;&lt; 8) | bytes[3]</span>.
</p></div></div><p ><code class='itemdecl'>
explicit constexpr address_v4(address_v4::uint_type val);
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.cons-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>out_of_range</span> if <span class='texttt'>val</span> is not in the range <span class='texttt'>[0, 0xFFFFFFFF]</span>. [&nbsp;<i>Note:</i> For implementations where <span class='texttt'>numeric_limits&lt;address_v4::uint_type&gt;::max() == 0xFFFFFFFF</span>, no out-of-range detection is needed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='address.v4.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.cons-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>to_uint() == val</span> and <span class='texttt'>to_bytes()</span> is:
</p><pre class='codeblock'>
</pre></div></div></div><div id='address.v4.members'><h3 ><a class='secnum' href='#address.v4.members' style='min-width:103pt'>21.5.3</a> <span class='texttt'>ip::address_v4</span> members <a class='abbr_ref' href='internet.address.v4.members'>[internet.address.v4.members]</a></h3><p ><span class='indexparent'><a class='index' id='is_unspecified,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,is_unspecified'></a></span><code class='itemdecl'>
constexpr bool is_unspecified() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.members-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>to_uint() == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_loopback,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,is_loopback'></a></span><code class='itemdecl'>
constexpr bool is_loopback() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.members-2'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>(to_uint() &amp; 0xFF000000) == 0x7F000000</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_multicast,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,is_multicast'></a></span><code class='itemdecl'>
constexpr bool is_multicast() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.members-3'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>(to_uint() &amp; 0xF0000000) == 0xE0000000</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_bytes,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,to_bytes'></a></span><code class='itemdecl'>
constexpr bytes_type to_bytes() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.members-4'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> A representation of the address in network byte order (<a href='defs.net.byte.order'>[defs.net.byte.order]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='to_uint,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,to_uint'></a></span><code class='itemdecl'>
constexpr address_v4::uint_type to_uint() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.members-5'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> A representation of the address in host byte order (<a href='defs.host.byte.order'>[defs.host.byte.order]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='to_string,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,to_string'></a></span><code class='itemdecl'>
template&lt;class Allocator = allocator&lt;char&gt;&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    to_string(const Allocator&amp; a = Allocator()) const;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.members-6'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> If successful, the textual representation of the address, determined as if by POSIX <span class='texttt'>inet_ntop</span> when invoked with address family <span class='texttt'>AF_INET</span>. Otherwise <span class='texttt'>basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;(a)</span>.
</p></div></div></div><div id='address.v4.static'><h3 ><a class='secnum' href='#address.v4.static' style='min-width:103pt'>21.5.4</a> <span class='texttt'>ip::address_v4</span> static members <a class='abbr_ref' href='internet.address.v4.static'>[internet.address.v4.static]</a></h3><p ><span class='indexparent'><a class='index' id='any,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,any'></a></span><code class='itemdecl'>
static constexpr address_v4 any() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.static-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.static-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>address_v4()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='loopback,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,loopback'></a></span><code class='itemdecl'>
static constexpr address_v4 loopback() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.static-2'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.static-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>address_v4(0x7F000001)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='multicast,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,multicast'></a></span><code class='itemdecl'>
static constexpr address_v4 broadcast() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.static-3'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.static-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>address_v4(0xFFFFFFFF)</span>.
</p></div></div></div><div id='address.v4.comparisons'><h3 ><a class='secnum' href='#address.v4.comparisons' style='min-width:103pt'>21.5.5</a> <span class='texttt'>ip::address_v4</span> comparisons <a class='abbr_ref' href='internet.address.v4.comparisons'>[internet.address.v4.comparisons]</a></h3><p ><span class='indexparent'><a class='index' id='operator==,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,operator=='></a></span><code class='itemdecl'>
constexpr bool operator==(const address_v4&amp; a, const address_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.to_uint() == b.to_uint()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,operator!='></a></span><code class='itemdecl'>
constexpr bool operator!=(const address_v4&amp; a, const address_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,operator<'></a></span><code class='itemdecl'>
constexpr bool operator&lt; (const address_v4&amp; a, const address_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.comparisons-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.to_uint() &lt; b.to_uint()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,operator>'></a></span><code class='itemdecl'>
constexpr bool operator&gt; (const address_v4&amp; a, const address_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.comparisons-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>b &lt; a</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,operator<='></a></span><code class='itemdecl'>
constexpr bool operator&lt;=(const address_v4&amp; a, const address_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.comparisons-5'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.comparisons-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(b &lt; a)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,operator>='></a></span><code class='itemdecl'>
constexpr bool operator&gt;=(const address_v4&amp; a, const address_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.comparisons-6'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.comparisons-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a &lt; b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_address_v4'></a></span></p></div><div id='address.v4.creation'><h3 ><a class='secnum' href='#address.v4.creation' style='min-width:103pt'>21.5.6</a> <span class='texttt'>ip::address_v4</span> creation <a class='abbr_ref' href='internet.address.v4.creation'>[internet.address.v4.creation]</a></h3><p ><code class='itemdecl'>
constexpr address_v4 make_address_v4(const address_v4::bytes_type&amp; bytes);
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.creation-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.creation-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>address_v4(bytes)</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v4 make_address_v4(address_v4::uint_type val);
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.creation-2'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.creation-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>address_v4(val)</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v4 make_address_v4(v4_mapped_t, const address_v6&amp; a);
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.creation-3'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.creation-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> An <span class='texttt'>address_v4</span> object corresponding to the IPv4-mapped IPv6 address, as if computed by the following method:
</p><pre class='codeblock'>
address_v6::bytes_type v6b = a.to_bytes();
address_v4::bytes_type v4b(v6b[12], v6b[13], v6b[14], v6b[15]);
return address_v4(v4b);
</pre></div></div><div class='para' id='address.v4.creation-4'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.creation-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>bad_address_cast</span> if <span class='texttt'>a.is_v4_mapped()</span> is <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
address_v4 make_address_v4(const char* str);
address_v4 make_address_v4(const char* str, error_code&amp; ec) noexcept;
address_v4 make_address_v4(const string&amp; str);
address_v4 make_address_v4(const string&amp; str, error_code&amp; ec) noexcept;
address_v4 make_address_v4(string_view str);
address_v4 make_address_v4(string_view str, error_code&amp; ec) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.creation-5'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.creation-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Converts a textual representation of an address into a corresponding <span class='texttt'>address_v4</span> value, as if by POSIX <span class='texttt'>inet_pton</span> when invoked with address family <span class='texttt'>AF_INET</span>.</p></div></div><div class='para' id='address.v4.creation-6'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.creation-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> If successful, an <span class='texttt'>address_v4</span> value corresponding to the string <span class='texttt'>str</span>. Otherwise <span class='texttt'>address_v4()</span>.</p></div></div><div class='para' id='address.v4.creation-7'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.creation-7'>7</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='address.v4.creation-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#address.v4.creation-7.1'>(7.1)</a></div><p ><span class='texttt'>errc::invalid_argument</span> — if <span class='texttt'>str</span> is not a valid textual representation of an IPv4 address.
</p></li></ul></div></div></div><div id='address.v4.io'><h3 ><a class='secnum' href='#address.v4.io' style='min-width:103pt'>21.5.7</a> <span class='texttt'>ip::address_v4</span> I/O <a class='abbr_ref' href='internet.address.v4.io'>[internet.address.v4.io]</a></h3><p ><span class='indexparent'><a class='index' id='operator<<,address_v4'></a></span><span class='indexparent'><a class='index' id='address_v4,operator<<'></a></span><code class='itemdecl'>
template&lt;class CharT, class Traits&gt;
  basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
    basic_ostream&lt;CharT, Traits&gt;&amp; os, const address_v4&amp; addr);
</code></p><div class='itemdescr'></div><div class='para' id='address.v4.io-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v4.io-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>os &lt;&lt; addr.to_string().c_str()</span>.
</p></div></div></div></div><div id='address.v6'><h2 ><a class='secnum' href='#address.v6' style='min-width:88pt'>21.6</a> Class <span class='texttt'>ip::address_v6</span> <a class='abbr_ref' href='internet.address.v6'>[internet.address.v6]</a></h2><div class='para' id='address.v6-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v6-1'>1</a></div><p >The class <span class='texttt'>address_v6</span> is a representation of an IPv6 address.</p><p ><span class='indexparent'><a class='index' id='address_v6'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class address_v6
  {
  public:
    <span class='comment'>// <a href='internet.address.v6.bytes'>[internet.address.v6.bytes]</a>, types:
</span>    struct bytes_type;

    <span class='comment'>// <a href='internet.address.v6.cons'>[internet.address.v6.cons]</a>, constructors:
</span>    constexpr address_v6() noexcept;
    constexpr address_v6(const address_v6&amp; a) noexcept;
    constexpr address_v6(const bytes_type&amp; bytes,
                         scope_id_type scope = 0);

    <span class='comment'>// assignment:
</span>    address_v6&amp; operator=(const address_v6&amp; a) noexcept;

    <span class='comment'>// <a href='internet.address.v6.members'>[internet.address.v6.members]</a>, members:
</span>    void scope_id(scope_id_type id) noexcept;
    constexpr scope_id_type scope_id() const noexcept;
    constexpr bool is_unspecified() const noexcept;
    constexpr bool is_loopback() const noexcept;
    constexpr bool is_multicast() const noexcept;
    constexpr bool is_link_local() const noexcept;
    constexpr bool is_site_local() const noexcept;
    constexpr bool is_v4_mapped() const noexcept;
    constexpr bool is_multicast_node_local() const noexcept;
    constexpr bool is_multicast_link_local() const noexcept;
    constexpr bool is_multicast_site_local() const noexcept;
    constexpr bool is_multicast_org_local() const noexcept;
    constexpr bool is_multicast_global() const noexcept;
    constexpr bytes_type to_bytes() const noexcept;
    template&lt;class Allocator = allocator&lt;char&gt;&gt;
      basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
        to_string(const Allocator&amp; a = Allocator()) const;

    <span class='comment'>// <a href='internet.address.v6.static'>[internet.address.v6.static]</a>, static members:
</span>    static constexpr address_v6 any() noexcept;
    static constexpr address_v6 loopback() noexcept;
  };

  <span class='comment'>// <a href='internet.address.v6.comparisons'>[internet.address.v6.comparisons]</a>, address_v6 comparisons:
</span>  constexpr bool operator==(const address_v6&amp; a, const address_v6&amp; b) noexcept;
  constexpr bool operator!=(const address_v6&amp; a, const address_v6&amp; b) noexcept;
  constexpr bool operator&lt; (const address_v6&amp; a, const address_v6&amp; b) noexcept;
  constexpr bool operator&gt; (const address_v6&amp; a, const address_v6&amp; b) noexcept;
  constexpr bool operator&lt;=(const address_v6&amp; a, const address_v6&amp; b) noexcept;
  constexpr bool operator&gt;=(const address_v6&amp; a, const address_v6&amp; b) noexcept;

  <span class='comment'>// <a href='internet.address.v6.creation'>[internet.address.v6.creation]</a>, address_v6 creation:
</span>  constexpr address_v6 make_address_v6(const address_v6::bytes_type&amp; bytes,
                                       scope_id_type scope_id = 0);
  constexpr address_v6 make_address_v6(v4_mapped_t, const address_v4&amp; a) noexcept;
  address_v6 make_address_v6(const char* str);
  address_v6 make_address_v6(const char* str, error_code&amp; ec) noexcept;
  address_v6 make_address_v6(const string&amp; str);
  address_v6 make_address_v6(const string&amp; str, error_code&amp; ec) noexcept;
  address_v6 make_address_v6(string_view str);
  address_v6 make_address_v6(string_view str, error_code&amp; ec) noexcept;

  <span class='comment'>// <a href='internet.address.v6.io'>[internet.address.v6.io]</a>, address_v6 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp; os, const address_v6&amp; addr);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='address.v6-2'><div class='marginalizedparent'><a class='marginalized' href='#address.v6-2'>2</a></div><p ><span class='texttt'>address_v6</span> satisfies the requirements for <span class='texttt'>Destructible</span> (<span class='CppXref'>destructible</span>), <span class='texttt'>CopyConstructible</span> (<span class='CppXref'>copyconstructible</span>), and <span class='texttt'>CopyAssignable</span> (<span class='CppXref'>copyassignable</span>).</p></div><div class='para' id='address.v6-3'><div class='marginalizedparent'><a class='marginalized' href='#address.v6-3'>3</a></div><p >[&nbsp;<i>Note:</i> The implementations of the functions <span class='texttt'>is_unspecified</span>, <span class='texttt'>is_loopback</span>, <span class='texttt'>is_multicast</span>, <span class='texttt'>is_link_local</span>, <span class='texttt'>is_site_local</span>, <span class='texttt'>is_v4_mapped</span>, <span class='texttt'>is_multicast_node_local</span>, <span class='texttt'>is_multicast_link_local</span>, <span class='texttt'>is_multicast_site_local</span>, <span class='texttt'>is_multicast_org_local</span> and <span class='texttt'>is_multicast_global</span> are determined by [RFC4291]. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='address.v6.bytes'><h3 ><a class='secnum' href='#address.v6.bytes' style='min-width:103pt'>21.6.1</a> Struct <span class='texttt'>ip::address_v6::bytes_type</span> <a class='abbr_ref' href='internet.address.v6.bytes'>[internet.address.v6.bytes]</a></h3><p ><span class='indexparent'><a class='index' id='bytes_type,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,bytes_type'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  struct address_v6::bytes_type : array&lt;unsigned char, 16&gt;
  {
    template&lt;class... T&gt; explicit constexpr bytes_type(T... t)
      : array&lt;unsigned char, 16&gt;{{static_cast&lt;unsigned char&gt;(t)...}} {}
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='address.v6.bytes-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.bytes-1'>1</a></div><p >The <span class='texttt'>ip::address_v6::bytes_type</span> type is a standard-layout struct that provides a byte-level representation of an IPv6 address in network byte order.</p><p ><span class='indexparent'><a class='index' id='address_v6,constructor'></a></span></p></div></div><div id='address.v6.cons'><h3 ><a class='secnum' href='#address.v6.cons' style='min-width:103pt'>21.6.2</a> <span class='texttt'>ip::address_v6</span> constructors <a class='abbr_ref' href='internet.address.v6.cons'>[internet.address.v6.cons]</a></h3><p ><code class='itemdecl'>
constexpr address_v6() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_unspecified() == true</span> and <span class='texttt'>scope_id() == 0</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v6(const bytes_type&amp; bytes,
                     scope_id_type scope = 0);
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.cons-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>out_of_range</span> if any element of <span class='texttt'>bytes</span> is not in the range <span class='texttt'>[0, 0xFF]</span>. [&nbsp;<i>Note:</i> For implementations where <span class='texttt'>numeric_limits&lt;unsigned char&gt;::max() == 0xFF</span>, no out-of-range detection is needed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='address.v6.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>to_bytes() == bytes</span> and <span class='texttt'>scope_id() == scope</span>.
</p></div></div></div><div id='address.v6.members'><h3 ><a class='secnum' href='#address.v6.members' style='min-width:103pt'>21.6.3</a> <span class='texttt'>ip::address_v6</span> members <a class='abbr_ref' href='internet.address.v6.members'>[internet.address.v6.members]</a></h3><p ><span class='indexparent'><a class='index' id='scope_id,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,scope_id'></a></span><code class='itemdecl'>
void scope_id(scope_id_type id) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>scope_id() == id</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr scope_id_type scope_id() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-2'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The scope identifier associated with the address.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_unspecified,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_unspecified'></a></span><code class='itemdecl'>
constexpr bool is_unspecified() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-3'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this == make_address_v6("::")</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_loopback,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_loopback'></a></span><code class='itemdecl'>
constexpr bool is_loopback() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-4'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this == make_address_v6("::1")</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_multicast,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_multicast'></a></span><code class='itemdecl'>
constexpr bool is_multicast() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-5'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> A boolean indicating whether the <span class='texttt'>address_v6</span> object represents a multicast address, as if computed by the following method:
</p><pre class='codeblock'>
bytes_type b = to_bytes();
return b[0] == 0xFF;
</pre></div></div><p ><span class='indexparent'><a class='index' id='is_link_local,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_link_local'></a></span><code class='itemdecl'>
constexpr bool is_link_local() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-6'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> A boolean indicating whether the <span class='texttt'>address_v6</span> object represents a unicast link-local address, as if computed by the following method:
</p><pre class='codeblock'>
bytes_type b = to_bytes();
return b[0] == 0xFE &amp;&amp; (b[1] &amp; 0xC0) == 0x80;
</pre></div></div><p ><span class='indexparent'><a class='index' id='is_site_local,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_site_local'></a></span><code class='itemdecl'>
constexpr bool is_site_local() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-7'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> A boolean indicating whether the <span class='texttt'>address_v6</span> object represents a unicast site-local address, as if computed by the following method:
</p><pre class='codeblock'>
bytes_type b = to_bytes();
return b[0] == 0xFE &amp;&amp; (b[1] &amp; 0xC0) == 0xC0;
</pre></div></div><p ><span class='indexparent'><a class='index' id='is_v4_mapped,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_v4_mapped'></a></span><code class='itemdecl'>
constexpr bool is_v4_mapped() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-8'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> A boolean indicating whether the <span class='texttt'>address_v6</span> object represents an IPv4-mapped IPv6 address, as if computed by the following method:
</p><pre class='codeblock'>
bytes_type b = to_bytes();
return b[ 0] == 0 &amp;&amp; b[ 1] == 0 &amp;&amp; b[ 2] == 0    &amp;&amp; b[ 3] == 0
    &amp;&amp; b[ 4] == 0 &amp;&amp; b[ 5] == 0 &amp;&amp; b[ 6] == 0    &amp;&amp; b[ 7] == 0
    &amp;&amp; b[ 8] == 0 &amp;&amp; b[ 9] == 0 &amp;&amp; b[10] == 0xFF &amp;&amp; b[11] == 0xFF;
</pre></div></div><p ><span class='indexparent'><a class='index' id='is_multicast_node_local,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_multicast_node_local'></a></span><code class='itemdecl'>
constexpr bool is_multicast_node_local() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-9'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>is_multicast() &amp;&amp; (to_bytes()[1] &amp; 0x0F) == 0x01</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_multicast_link_local,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_multicast_link_local'></a></span><code class='itemdecl'>
constexpr bool is_multicast_link_local() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-10'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>is_multicast() &amp;&amp; (to_bytes()[1] &amp; 0x0F) == 0x02</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_multicast_site_local,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_multicast_site_local'></a></span><code class='itemdecl'>
constexpr bool is_multicast_site_local() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-11'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>is_multicast() &amp;&amp; (to_bytes()[1] &amp; 0x0F) == 0x05</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_multicast_org_local,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_multicast_org_local'></a></span><code class='itemdecl'>
constexpr bool is_multicast_org_local() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-12'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>is_multicast() &amp;&amp; (to_bytes()[1] &amp; 0x0F) == 0x08</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_multicast_global,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,is_multicast_global'></a></span><code class='itemdecl'>
constexpr bool is_multicast_global() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-13'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>is_multicast() &amp;&amp; (to_bytes()[1] &amp; 0x0F) == 0x0E</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_bytes,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,to_bytes'></a></span><code class='itemdecl'>
constexpr bytes_type to_bytes() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-14'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> A representation of the address in network byte order (<a href='defs.net.byte.order'>[defs.net.byte.order]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='to_string,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,to_string'></a></span><code class='itemdecl'>
template&lt;class Allocator = allocator&lt;char&gt;&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    to_string(const Allocator&amp; a = Allocator()) const;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.members-15'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> Converts an address into a textual representation. If <span class='texttt'>scope_id() == 0</span>, converts as if by POSIX <span class='texttt'>inet_ntop</span> when invoked with address family <span class='texttt'>AF_INET6</span>. If <span class='texttt'>scope_id() != 0</span>, the format is <span class='texttt'>address</span><span class='texttt'>%</span><span class='texttt'>scope-id</span>, where <span class='texttt'>address</span> is the textual representation of the equivalent address having <span class='texttt'>scope_id() == 0</span>, and <span class='texttt'>scope-id</span> is an <span class='indexparent'><a class='index' id='textual_representation_of_IPv6_scope_identifiers'></a></span>implementation-defined textual representation of the scope identifier.</p></div></div><div class='para' id='address.v6.members-16'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.members-16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i> If successful, the textual representation of the address. Otherwise <span class='texttt'>basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;(a)</span>.
</p></div></div></div><div id='address.v6.static'><h3 ><a class='secnum' href='#address.v6.static' style='min-width:103pt'>21.6.4</a> <span class='texttt'>ip::address_v6</span> static members <a class='abbr_ref' href='internet.address.v6.static'>[internet.address.v6.static]</a></h3><p ><span class='indexparent'><a class='index' id='any,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,any'></a></span><code class='itemdecl'>
static constexpr address_v6 any() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.static-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.static-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> An address <span class='texttt'>a</span> such that the <span class='texttt'>a.is_unspecified() == true</span> and <span class='texttt'>a.scope_id() == 0</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='loopback,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,loopback'></a></span><code class='itemdecl'>
static constexpr address_v6 loopback() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.static-2'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.static-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> An address <span class='texttt'>a</span> such that the <span class='texttt'>a.is_loopback() == true</span> and <span class='texttt'>a.scope_id() == 0</span>.
</p></div></div></div><div id='address.v6.comparisons'><h3 ><a class='secnum' href='#address.v6.comparisons' style='min-width:103pt'>21.6.5</a> <span class='texttt'>ip::address_v6</span> comparisons <a class='abbr_ref' href='internet.address.v6.comparisons'>[internet.address.v6.comparisons]</a></h3><p ><span class='indexparent'><a class='index' id='operator==,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,operator=='></a></span><code class='itemdecl'>
constexpr bool operator==(const address_v6&amp; a, const address_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.to_bytes() == b.to_bytes() &amp;&amp; a.scope_id() == b.scope_id()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,operator!='></a></span><code class='itemdecl'>
constexpr bool operator!=(const address_v6&amp; a, const address_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,operator<'></a></span><code class='itemdecl'>
constexpr bool operator&lt; (const address_v6&amp; a, const address_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.comparisons-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>tie(a.to_bytes(), a.scope_id()) &lt; tie(b.to_bytes(), b.scope_id())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,operator>'></a></span><code class='itemdecl'>
constexpr bool operator&gt; (const address_v6&amp; a, const address_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.comparisons-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>b &lt; a</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,operator<='></a></span><code class='itemdecl'>
constexpr bool operator&lt;=(const address_v6&amp; a, const address_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.comparisons-5'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.comparisons-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(b &lt; a)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,operator>='></a></span><code class='itemdecl'>
constexpr bool operator&gt;=(const address_v6&amp; a, const address_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.comparisons-6'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.comparisons-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a &lt; b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_address_v6'></a></span></p></div><div id='address.v6.creation'><h3 ><a class='secnum' href='#address.v6.creation' style='min-width:103pt'>21.6.6</a> <span class='texttt'>ip::address_v6</span> creation <a class='abbr_ref' href='internet.address.v6.creation'>[internet.address.v6.creation]</a></h3><p ><code class='itemdecl'>
constexpr address_v6 make_address_v6(const address_v6::bytes_type&amp; bytes,
                                     scope_id_type scope_id);
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.creation-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.creation-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>address_v6(bytes, scope_id)</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v6 make_address_v6(v4_mapped_t, const address_v4&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.creation-2'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.creation-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> An <span class='texttt'>address_v6</span> object containing the IPv4-mapped IPv6 address corresponding to the specified IPv4 address, as if computed by the following method:
</p><pre class='codeblock'>
address_v4::bytes_type v4b = a.to_bytes();
address_v6::bytes_type v6b(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                           0xFF, 0xFF, v4b[0], v4b[1], v4b[2], v4b[3]);
return address_v6(v6b);
</pre></div></div><p ><code class='itemdecl'>
address_v6 make_address_v6(const char* str);
address_v6 make_address_v6(const char* str, error_code&amp; ec) noexcept;
address_v4 make_address_v6(const string&amp; str);
address_v4 make_address_v6(const string&amp; str, error_code&amp; ec) noexcept;
address_v6 make_address_v6(string_view str);
address_v6 make_address_v6(string_view str, error_code&amp; ec) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.creation-3'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.creation-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Converts a textual representation of an address into a corresponding <span class='texttt'>address_v6</span> value. The format is either <span class='texttt'>address</span> or <span class='texttt'>address</span><span class='texttt'>%</span><span class='texttt'>scope-id</span>, where <span class='texttt'>address</span> is in the format specified by POSIX <span class='texttt'>inet_pton</span> when invoked with address family <span class='texttt'>AF_INET6</span>, and <span class='texttt'>scope-id</span> is an optional string specifying the scope identifier. All implementations accept as <span class='texttt'>scope-id</span> a textual representation of an unsigned decimal integer. It is <span class='indexparent'><a class='index' id='whether_alternative_IPv6_scope_identifier_representations_are_permitted'></a></span>implementation-defined whether alternative scope identifier representations are permitted. If <span class='texttt'>scope-id</span> is not supplied, an <span class='texttt'>address_v6</span> object is returned such that <span class='texttt'>scope_id() == 0</span>.</p></div></div><div class='para' id='address.v6.creation-4'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.creation-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> If successful, an <span class='texttt'>address_v6</span> value corresponding to the string <span class='texttt'>str</span>. Otherwise returns <span class='texttt'>address_v6()</span>.</p></div></div><div class='para' id='address.v6.creation-5'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.creation-5'>5</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='address.v6.creation-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#address.v6.creation-5.1'>(5.1)</a></div><p ><span class='texttt'>errc::invalid_argument</span> — if <span class='texttt'>str</span> is not a valid textual representation of an IPv6 address.
</p></li></ul></div></div></div><div id='address.v6.io'><h3 ><a class='secnum' href='#address.v6.io' style='min-width:103pt'>21.6.7</a> <span class='texttt'>ip::address_v6</span> I/O <a class='abbr_ref' href='internet.address.v6.io'>[internet.address.v6.io]</a></h3><p ><span class='indexparent'><a class='index' id='operator<<,address_v6'></a></span><span class='indexparent'><a class='index' id='address_v6,operator<<'></a></span><code class='itemdecl'>
template&lt;class CharT, class Traits&gt;
  basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
    basic_ostream&lt;CharT, Traits&gt;&amp; os, const address_v6&amp; addr);
</code></p><div class='itemdescr'></div><div class='para' id='address.v6.io-1'><div class='marginalizedparent'><a class='marginalized' href='#address.v6.io-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>os &lt;&lt; addr.to_string().c_str()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bad_address_cast'></a></span></p></div></div><div id='bad.address.cast'><h2 ><a class='secnum' href='#bad.address.cast' style='min-width:88pt'>21.7</a> Class <span class='texttt'>ip::bad_address_cast</span> <a class='abbr_ref' href='internet.bad.address.cast'>[internet.bad.address.cast]</a></h2><div class='para' id='bad.address.cast-1'><div class='marginalizedparent'><a class='marginalized' href='#bad.address.cast-1'>1</a></div><p >An exception of type <span class='texttt'>bad_address_cast</span> is thrown by a failed <span class='texttt'>address_cast</span>.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class bad_address_cast : public bad_cast
  {
  public:
    <span class='comment'>// constructor:
</span>    bad_address_cast() noexcept;
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><code class='itemdecl'>
bad_address_cast() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='bad.address.cast-2'><div class='marginalizedparent'><a class='marginalized' href='#bad.address.cast-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> constructs a <span class='texttt'>bad_address_cast</span> object.</p></div></div><div class='para' id='bad.address.cast-3'><div class='marginalizedparent'><a class='marginalized' href='#bad.address.cast-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>what()</span> returns an <span class='indexparent'><a class='index' id='result_of_bad_address_cast::what'></a></span>implementation-defined <span class='textsc'>ntbs</span>.
</p></div></div></div><div id='hash'><h2 ><a class='secnum' href='#hash' style='min-width:88pt'>21.8</a> Hash support <a class='abbr_ref' href='internet.hash'>[internet.hash]</a></h2><p ><code class='itemdecl'>
template&lt;&gt; struct hash&lt;experimental::net::v1::ip::address&gt;;
template&lt;&gt; struct hash&lt;experimental::net::v1::ip::address_v4&gt;;
template&lt;&gt; struct hash&lt;experimental::net::v1::ip::address_v6&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='hash-1'><div class='marginalizedparent'><a class='marginalized' href='#hash-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> the template specializations shall meet the requirements of class template <span class='texttt'>hash</span> (<span class='CppXref'>unord.hash</span>).
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_address_iterator'></a></span></p></div><div id='address.iter'><h2 ><a class='secnum' href='#address.iter' style='min-width:88pt'>21.9</a> Class template <span class='texttt'>ip::basic_address_iterator</span> specializations <a class='abbr_ref' href='internet.address.iter'>[internet.address.iter]</a></h2><div class='para' id='address.iter-1'><div class='marginalizedparent'><a class='marginalized' href='#address.iter-1'>1</a></div><p >The class template <span class='texttt'>basic_address_iterator</span> enables iteration over IP addresses in network byte order. This clause defines two specializations of the class template <span class='texttt'>basic_address_iterator</span>: <span class='texttt'>basic_address_iterator&lt;address_v4&gt;</span> and <span class='texttt'>basic_address_iterator&lt;address_v6&gt;</span>. The members and operational semantics of these specializations are defined below.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;&gt; class basic_address_iterator&lt;<i>Address</i>&gt;
  {
  public:
    <span class='comment'>// types:
</span>    using value_type = <i>Address</i>;
    using difference_type = ptrdiff_t;
    using pointer = const <i>Address</i>*;
    using reference = const <i>Address</i>&amp;;
    using iterator_category = input_iterator_tag;

    <span class='comment'>// constructors:
</span>    basic_address_iterator(const <i>Address</i>&amp; a) noexcept;

    <span class='comment'>// members:
</span>    reference operator*() const noexcept;
    pointer operator-&gt;() const noexcept;
    basic_address_iterator&amp; operator++() noexcept;
    basic_address_iterator operator++(int) noexcept;
    basic_address_iterator&amp; operator--() noexcept;
    basic_address_iterator operator--(int) noexcept;

    <span class='comment'>// other members as required by <span class='CppXref'>input.iterators</span>
</span>
  private:
    <i>Address</i> address_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='address.iter-2'><div class='marginalizedparent'><a class='marginalized' href='#address.iter-2'>2</a></div><p >Specializations of <span class='texttt'>basic_address_iterator</span> satisfy the requirements for input iterators (<span class='CppXref'>input.iterators</span>).</p><p ><code class='itemdecl'>
basic_address_iterator(const <i>Address</i>&amp; a) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='address.iter-3'><div class='marginalizedparent'><a class='marginalized' href='#address.iter-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>address_</span> with <span class='texttt'>a</span>.
</p></div></div><p ><code class='itemdecl'>
reference operator*() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.iter-4'><div class='marginalizedparent'><a class='marginalized' href='#address.iter-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>address_</span>.
</p></div></div><p ><code class='itemdecl'>
pointer operator-&gt;() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.iter-5'><div class='marginalizedparent'><a class='marginalized' href='#address.iter-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>addressof(address_)</span>.
</p></div></div><p ><code class='itemdecl'>
basic_address_iterator&amp; operator++() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.iter-6'><div class='marginalizedparent'><a class='marginalized' href='#address.iter-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets <span class='texttt'>address_</span> to the next unique address in network byte order.</p></div></div><div class='para' id='address.iter-7'><div class='marginalizedparent'><a class='marginalized' href='#address.iter-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
basic_address_iterator operator++(int) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.iter-8'><div class='marginalizedparent'><a class='marginalized' href='#address.iter-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets <span class='texttt'>address_</span> to the next unique address in network byte order.</p></div></div><div class='para' id='address.iter-9'><div class='marginalizedparent'><a class='marginalized' href='#address.iter-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> The prior value of <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
basic_address_iterator&amp; operator--() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.iter-10'><div class='marginalizedparent'><a class='marginalized' href='#address.iter-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets <span class='texttt'>address_</span> to the prior unique address in network byte order.</p></div></div><div class='para' id='address.iter-11'><div class='marginalizedparent'><a class='marginalized' href='#address.iter-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
basic_address_iterator operator--(int) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.iter-12'><div class='marginalizedparent'><a class='marginalized' href='#address.iter-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets <span class='texttt'>address_</span> to the prior unique address in network byte order.</p></div></div><div class='para' id='address.iter-13'><div class='marginalizedparent'><a class='marginalized' href='#address.iter-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> The prior value of <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_address_range'></a></span></p></div><div id='address.range'><h2 ><a class='secnum' href='#address.range' style='min-width:88pt'>21.10</a> Class template <span class='texttt'>ip::basic_address_range</span> specializations <a class='abbr_ref' href='internet.address.range'>[internet.address.range]</a></h2><div class='para' id='address.range-1'><div class='marginalizedparent'><a class='marginalized' href='#address.range-1'>1</a></div><p >The class template <span class='texttt'>basic_address_range</span> represents a range of IP addresses in network byte order. This clause defines two specializations of the class template <span class='texttt'>basic_address_range</span>: <span class='texttt'>basic_address_range&lt;address_v4&gt;</span> and <span class='texttt'>basic_address_range&lt;address_v6&gt;</span>. The members and operational semantics of these specializations are defined below.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;&gt; class basic_address_range&lt;<i>Address</i>&gt;
  {
  public:
    <span class='comment'>// types:
</span>    using iterator = basic_address_iterator&lt;<i>Address</i>&gt;;

    <span class='comment'>// constructors:
</span>    basic_address_range() noexcept;
    basic_address_range(const <i>Address</i>&amp; first,
                        const <i>Address</i>&amp; last) noexcept;

    <span class='comment'>// members:
</span>    iterator begin() const noexcept;
    iterator end() const noexcept;
    bool empty() const noexcept;
    size_t size() const noexcept; <i>// not always defined</i>
    iterator find(const <i>Address</i>&amp; addr) const noexcept;
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='address.range-2'><div class='marginalizedparent'><a class='marginalized' href='#address.range-2'>2</a></div><p >Specializations of <span class='texttt'>basic_address_range</span> satisfy the requirements for <span class='texttt'>Destructible</span> (<span class='CppXref'>destructible</span>), <span class='texttt'>CopyConstructible</span> (<span class='CppXref'>copyconstructible</span>), and <span class='texttt'>CopyAssignable</span> (<span class='CppXref'>copyassignable</span>).</p><p ><code class='itemdecl'>
basic_address_range() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='address.range-3'><div class='marginalizedparent'><a class='marginalized' href='#address.range-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>basic_address_range&lt;<i>Address</i>&gt;</span> that represents an empty range.
</p></div></div><p ><code class='itemdecl'>
basic_address_range(const <i>Address</i>&amp; first,
                    const <i>Address</i>&amp; last) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.range-4'><div class='marginalizedparent'><a class='marginalized' href='#address.range-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>basic_address_range&lt;<i>Address</i>&gt;</span> that represents the half-open range <span class='texttt'>[first, last)</span>.
</p></div></div><p ><code class='itemdecl'>
iterator begin() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.range-5'><div class='marginalizedparent'><a class='marginalized' href='#address.range-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> An iterator that points to the beginning of the range.
</p></div></div><p ><code class='itemdecl'>
iterator end() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.range-6'><div class='marginalizedparent'><a class='marginalized' href='#address.range-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> An iterator that points to the end of the range.
</p></div></div><p ><code class='itemdecl'>
bool empty() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.range-7'><div class='marginalizedparent'><a class='marginalized' href='#address.range-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>*this</span> represents an empty range, otherwise <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
size_t size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.range-8'><div class='marginalizedparent'><a class='marginalized' href='#address.range-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of unique addresses in the range.</p></div></div><div class='para' id='address.range-9'><div class='marginalizedparent'><a class='marginalized' href='#address.range-9'>9</a></div><div class='itemdescr'><p ><i>Remarks:</i> This member function is not defined when <i>Address</i> is type <span class='texttt'>address_v6</span>.
</p></div></div><p ><code class='itemdecl'>
iterator find(const <i>Address</i>&amp; addr) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='address.range-10'><div class='marginalizedparent'><a class='marginalized' href='#address.range-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>addr</span> is in the range, an iterator that points to <span class='texttt'>addr</span>; otherwise, <span class='texttt'>end()</span>.</p></div></div><div class='para' id='address.range-11'><div class='marginalizedparent'><a class='marginalized' href='#address.range-11'>11</a></div><div class='itemdescr'><p >Complexity: Constant time.
</p></div></div><p ><span class='indexparent'><a class='index' id='network_v4'></a></span></p></div><div id='network.v4'><h2 ><a class='secnum' href='#network.v4' style='min-width:88pt'>21.11</a> Class template <span class='texttt'>ip::network_v4</span> <a class='abbr_ref' href='internet.network.v4'>[internet.network.v4]</a></h2><div class='para' id='network.v4-1'><div class='marginalizedparent'><a class='marginalized' href='#network.v4-1'>1</a></div><p >The class <span class='texttt'>network_v4</span> provides the ability to use and manipulate IPv4 network addresses.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class network_v4
  {
  public:
    <span class='comment'>// <a href='internet.network.v4.cons'>[internet.network.v4.cons]</a>, constructors:
</span>    constexpr network_v4() noexcept;
    constexpr network_v4(const address_v4&amp; addr, int prefix_len);
    constexpr network_v4(const address_v4&amp; addr, const address_v4&amp; mask);

    <span class='comment'>// <a href='internet.network.v4.members'>[internet.network.v4.members]</a>, members:
</span>    constexpr address_v4 address() const noexcept;
    constexpr int prefix_length() const noexcept;
    constexpr address_v4 netmask() const noexcept;
    constexpr address_v4 network() const noexcept;
    constexpr address_v4 broadcast() const noexcept;
    address_v4_range hosts() const noexcept;
    constexpr network_v4 canonical() const noexcept;
    constexpr bool is_host() const noexcept;
    constexpr bool is_subnet_of(const network_v4&amp; other) const noexcept;
    template&lt;class Allocator = allocator&lt;char&gt;&gt;
      basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
        to_string(const Allocator&amp; a = Allocator()) const;
  };

  <span class='comment'>// <a href='internet.network.v4.comparisons'>[internet.network.v4.comparisons]</a>, network_v4 comparisons:
</span>  constexpr bool operator==(const network_v4&amp; a, const network_v4&amp; b) noexcept;
  constexpr bool operator!=(const network_v4&amp; a, const network_v4&amp; b) noexcept;

  <span class='comment'>// <a href='internet.network.v4.creation'>[internet.network.v4.creation]</a>, network_v4 creation:
</span>  constexpr network_v4 make_network_v4(const address_v4&amp; addr, int prefix_len);
  constexpr network_v4 make_network_v4(const address_v4&amp; addr, const address_v4&amp; mask);
  network_v4 make_network_v4(const char* str);
  network_v4 make_network_v4(const char* str, error_code&amp; ec) noexcept;
  network_v4 make_network_v4(const string&amp; str);
  network_v4 make_network_v4(const string&amp; str, error_code&amp; ec) noexcept;
  network_v4 make_network_v4(string_view str);
  network_v4 make_network_v4(string_view str, error_code&amp; ec) noexcept;

  <span class='comment'>// <a href='internet.network.v4.io'>[internet.network.v4.io]</a>, network_v4 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp; os, const network_v4&amp; net);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='network.v4-2'><div class='marginalizedparent'><a class='marginalized' href='#network.v4-2'>2</a></div><p ><span class='texttt'>network_v4</span> satisfies the requirements for <span class='texttt'>Destructible</span> (<span class='CppXref'>destructible</span>), <span class='texttt'>CopyConstructible</span> (<span class='CppXref'>copyconstructible</span>), and <span class='texttt'>CopyAssignable</span> (<span class='CppXref'>copyassignable</span>).</p></div><div id='network.v4.cons'><h3 ><a class='secnum' href='#network.v4.cons' style='min-width:103pt'>21.11.1</a> <span class='texttt'>ip::network_v4</span> constructors <a class='abbr_ref' href='internet.network.v4.cons'>[internet.network.v4.cons]</a></h3><p ><code class='itemdecl'>
constexpr network_v4() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address().is_unspecified() == true</span> and <span class='texttt'>prefix_length() == 0</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr network_v4(const address_v4&amp; addr, int prefix_len);
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address() == addr</span> and <span class='texttt'>prefix_length() == prefix_len</span>.</p></div></div><div class='para' id='network.v4.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.cons-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>out_of_range</span> if <span class='texttt'>prefix_len &lt; 0</span> or <span class='texttt'>prefix_len &gt; 32</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr network_v4(const address_v4&amp; addr, const address_v4&amp; mask);
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.cons-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address() == addr</span> and <span class='texttt'>prefix_length()</span> is equal to the number of contiguous non-zero bits in <span class='texttt'>mask</span>.</p></div></div><div class='para' id='network.v4.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.cons-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>invalid_argument</span> if <span class='texttt'>mask</span> contains non-contiguous non-zero bits, or if the most significant bit is zero and any other bits are non-zero.
</p></div></div></div><div id='network.v4.members'><h3 ><a class='secnum' href='#network.v4.members' style='min-width:103pt'>21.11.2</a> <span class='texttt'>ip::network_v4</span> members <a class='abbr_ref' href='internet.network.v4.members'>[internet.network.v4.members]</a></h3><p ><code class='itemdecl'>
constexpr address_v4 address() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.members-1'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The address specified when the <span class='texttt'>network_v4</span> object was constructed.
</p></div></div><p ><code class='itemdecl'>
constexpr int prefix_length() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.members-2'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The prefix length of the network.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v4 netmask() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.members-3'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> An <span class='texttt'>address_v4</span> object with <span class='texttt'>prefix_length()</span> contiguous non-zero bits set, starting from the most significant bit in network byte order. All other bits are zero.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v4 network() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.members-4'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> An <span class='texttt'>address_v4</span> object with the first <span class='texttt'>prefix_length()</span> bits, starting from the most significant bit in network byte order, set to the corresponding bit value of <span class='texttt'>this-&gt;address()</span>. All other bits are zero.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v4 broadcast() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.members-5'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> An <span class='texttt'>address_v4</span> object with the first <span class='texttt'>prefix_length()</span> bits, starting from the most significant bit in network byte order, set to the corresponding bit value of <span class='texttt'>this-&gt;address()</span>. All other bits are non-zero.
</p></div></div><p ><code class='itemdecl'>
address_v4_range hosts() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.members-6'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>is_host()</span> is <span class='texttt'>true</span>, an <span class='texttt'>address_v4_range</span> object representing the single address <span class='texttt'>this-&gt;address()</span>. Otherwise, an <span class='texttt'>address_v4_range</span> object representing the range of unique host IP addresses in the network.</p></div></div><div class='para' id='network.v4.members-7'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.members-7'>7</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> For IPv4, the network address and the broadcast address are not included in the range of host IP addresses. For example, given a network <span class='texttt'>192.168.1.0/24</span>, the range returned by <span class='texttt'>hosts()</span> is from <span class='texttt'>192.168.1.1</span> to <span class='texttt'>192.168.1.254</span> inclusive, and neither <span class='texttt'>192.168.1.0</span> nor the broadcast address <span class='texttt'>192.168.1.255</span> are in the range. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><code class='itemdecl'>
constexpr network_v4 canonical() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.members-8'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>network_v4(network(), prefix_length())</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool is_host() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.members-9'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.members-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>prefix_length() == 32</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool is_subnet_of(const network_v4&amp; other) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.members-10'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.members-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>other.prefix_length() &lt; prefix_length()</span> and <span class='texttt'>network_v4(this-&gt;address(), other.prefix_length()).canonical() == other.canonical()</span>, otherwise <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Allocator = allocator&lt;char&gt;&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    to_string(const Allocator&amp; a = Allocator()) const;
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.members-11'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.members-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>this-&gt;address().to_string(a) + "/" + std::to_string(prefix_length())</span>.
</p></div></div></div><div id='network.v4.comparisons'><h3 ><a class='secnum' href='#network.v4.comparisons' style='min-width:103pt'>21.11.3</a> <span class='texttt'>ip::network_v4</span> comparisons <a class='abbr_ref' href='internet.network.v4.comparisons'>[internet.network.v4.comparisons]</a></h3><p ><code class='itemdecl'>
constexpr bool operator==(const network_v4&amp; a, const network_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>a.address() == b.address()</span> and <span class='texttt'>a.prefix_length() == b.prefix_length()</span>, otherwise <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool operator!=(const network_v4&amp; a, const network_v4&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div></div><div id='network.v4.creation'><h3 ><a class='secnum' href='#network.v4.creation' style='min-width:103pt'>21.11.4</a> <span class='texttt'>ip::network_v4</span> creation <a class='abbr_ref' href='internet.network.v4.creation'>[internet.network.v4.creation]</a></h3><p ><code class='itemdecl'>
constexpr network_v4 make_network_v4(const address_v4&amp; addr, int prefix_len);
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.creation-1'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.creation-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>network_v4(addr, prefix_len)</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr network_v4 make_network_v4(const address_v4&amp; addr, const address_v4&amp; mask);
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.creation-2'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.creation-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>network_v4(addr, mask)</span>.
</p></div></div><p ><code class='itemdecl'>
network_v4 make_network_v4(const char* str);
network_v4 make_network_v4(const char* str, error_code&amp; ec) noexcept;
network_v4 make_network_v4(const string&amp; str);
network_v4 make_network_v4(const string&amp; str, error_code&amp; ec) noexcept;
network_v4 make_network_v4(string_view str);
network_v4 make_network_v4(string_view str, error_code&amp; ec) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.creation-3'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.creation-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>str</span> contains a value of the form address <span class='texttt'>'/'</span> prefix-length, a <span class='texttt'>network_v4</span> object constructed with the result of applying <span class='texttt'>make_address_v4()</span> to the address portion of the string, and the result of converting prefix-length to an integer of type <span class='texttt'>int</span>. Otherwise returns <span class='texttt'>network_v4()</span> and sets <span class='texttt'>ec</span> to reflect the error.</p></div></div><div class='para' id='network.v4.creation-4'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.creation-4'>4</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='network.v4.creation-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#network.v4.creation-4.1'>(4.1)</a></div><p ><span class='texttt'>errc::invalid_argument</span> — if <span class='texttt'>str</span> is not a valid textual representation of an IPv4 address and prefix length.
</p></li></ul></div></div></div><div id='network.v4.io'><h3 ><a class='secnum' href='#network.v4.io' style='min-width:103pt'>21.11.5</a> <span class='texttt'>ip::network_v4</span> I/O <a class='abbr_ref' href='internet.network.v4.io'>[internet.network.v4.io]</a></h3><p ><code class='itemdecl'>
template&lt;class CharT, class Traits&gt;
  basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
    basic_ostream&lt;CharT, Traits&gt;&amp; os, const network_v4&amp; net);
</code></p><div class='itemdescr'></div><div class='para' id='network.v4.io-1'><div class='marginalizedparent'><a class='marginalized' href='#network.v4.io-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>os &lt;&lt; net.to_string().c_str()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='network_v6'></a></span></p></div></div><div id='network.v6'><h2 ><a class='secnum' href='#network.v6' style='min-width:88pt'>21.12</a> Class template <span class='texttt'>ip::network_v6</span> <a class='abbr_ref' href='internet.network.v6'>[internet.network.v6]</a></h2><div class='para' id='network.v6-1'><div class='marginalizedparent'><a class='marginalized' href='#network.v6-1'>1</a></div><p >The class <span class='texttt'>network_v6</span> provides the ability to use and manipulate IPv6 network addresses.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class network_v6
  {
  public:
    <span class='comment'>// <a href='internet.network.v6.cons'>[internet.network.v6.cons]</a>, constructors:
</span>    constexpr network_v6() noexcept;
    constexpr network_v6(const address_v6&amp; addr, int prefix_len);

    <span class='comment'>// <a href='internet.network.v6.members'>[internet.network.v6.members]</a>, members:
</span>    constexpr address_v6 address() const noexcept;
    constexpr int prefix_length() const noexcept;
    constexpr address_v6 network() const noexcept;
    address_v6_range hosts() const noexcept;
    constexpr network_v6 canonical() const noexcept;
    constexpr bool is_host() const noexcept;
    constexpr bool is_subnet_of(const network_v6&amp; other) const noexcept;
    template&lt;class Allocator = allocator&lt;char&gt;&gt;
      basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
        to_string(const Allocator&amp; a = Allocator()) const;
  };

  <span class='comment'>// <a href='internet.network.v6.comparisons'>[internet.network.v6.comparisons]</a>, network_v6 comparisons:
</span>  constexpr bool operator==(const network_v6&amp; a, const network_v6&amp; b) noexcept;
  constexpr bool operator!=(const network_v6&amp; a, const network_v6&amp; b) noexcept;

  <span class='comment'>// <a href='internet.network.v6.creation'>[internet.network.v6.creation]</a>, network_v6 creation:
</span>  constexpr network_v6 make_network_v6(const address_v6&amp; addr, int prefix_len);
  network_v6 make_network_v6(const char* str);
  network_v6 make_network_v6(const char* str, error_code&amp; ec) noexcept;
  network_v6 make_network_v6(const string&amp; str);
  network_v6 make_network_v6(const string&amp; str, error_code&amp; ec) noexcept;
  network_v6 make_network_v6(string_view str);
  network_v6 make_network_v6(string_view str, error_code&amp; ec) noexcept;

  <span class='comment'>// <a href='internet.network.v6.io'>[internet.network.v6.io]</a>, network_v6 I/O:
</span>  template&lt;class CharT, class Traits&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp; os, const network_v6&amp; net);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='network.v6-2'><div class='marginalizedparent'><a class='marginalized' href='#network.v6-2'>2</a></div><p ><span class='texttt'>network_v6</span> satisfies the requirements for <span class='texttt'>Destructible</span> (<span class='CppXref'>destructible</span>), <span class='texttt'>CopyConstructible</span> (<span class='CppXref'>copyconstructible</span>), and <span class='texttt'>CopyAssignable</span> (<span class='CppXref'>copyassignable</span>).</p></div><div id='network.v6.cons'><h3 ><a class='secnum' href='#network.v6.cons' style='min-width:103pt'>21.12.1</a> <span class='texttt'>ip::network_v6</span> constructors <a class='abbr_ref' href='internet.network.v6.cons'>[internet.network.v6.cons]</a></h3><p ><code class='itemdecl'>
constexpr network_v6() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address().is_unspecified() == true</span> and <span class='texttt'>prefix_length() == 0</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr network_v6(const address_v6&amp; addr, int prefix_len);
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address() == addr</span> and <span class='texttt'>prefix_length() == prefix_len</span>.</p></div></div><div class='para' id='network.v6.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.cons-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>out_of_range</span> if <span class='texttt'>prefix_len &lt; 0</span> or <span class='texttt'>prefix_len &gt; 128</span>.
</p></div></div></div><div id='network.v6.members'><h3 ><a class='secnum' href='#network.v6.members' style='min-width:103pt'>21.12.2</a> <span class='texttt'>ip::network_v6</span> members <a class='abbr_ref' href='internet.network.v6.members'>[internet.network.v6.members]</a></h3><p ><code class='itemdecl'>
constexpr address_v6 address() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.members-1'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The address specified when the <span class='texttt'>network_v6</span> object was constructed.
</p></div></div><p ><code class='itemdecl'>
constexpr int prefix_length() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.members-2'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The prefix length of the network.
</p></div></div><p ><code class='itemdecl'>
constexpr address_v6 network() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.members-3'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> An <span class='texttt'>address_v6</span> object with the first <span class='texttt'>prefix_length()</span> bits, starting from the most significant bit in network byte order, set to the corresponding bit value of <span class='texttt'>this-&gt;address()</span>. All other bits are zero.
</p></div></div><p ><code class='itemdecl'>
address_v6_range hosts() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.members-4'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>is_host()</span> is <span class='texttt'>true</span>, an <span class='texttt'>address_v6_range</span> object representing the single address <span class='texttt'>this-&gt;address()</span>. Otherwise, an <span class='texttt'>address_v6_range</span> object representing the range of unique host IP addresses in the network.
</p></div></div><p ><code class='itemdecl'>
constexpr network_v6 canonical() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.members-5'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>network_v6(network(), prefix_length())</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool is_host() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.members-6'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>prefix_length() == 128</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool is_subnet_of(const network_v6&amp; other) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.members-7'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>other.prefix_length() &lt; prefix_length()</span> and <span class='texttt'>network_v6(this-&gt;address(), other.prefix_length()).canonical() == other.canonical()</span>, otherwise <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Allocator = allocator&lt;char&gt;&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    to_string(const Allocator&amp; a = Allocator()) const;
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.members-8'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>this-&gt;address().to_string(a) + "/" + to_string(prefix_length()).c_str()</span>.
</p></div></div></div><div id='network.v6.comparisons'><h3 ><a class='secnum' href='#network.v6.comparisons' style='min-width:103pt'>21.12.3</a> <span class='texttt'>ip::network_v6</span> comparisons <a class='abbr_ref' href='internet.network.v6.comparisons'>[internet.network.v6.comparisons]</a></h3><p ><code class='itemdecl'>
constexpr bool operator==(const network_v6&amp; a, const network_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>a.address() == b.address()</span> and <span class='texttt'>a.prefix_length() == b.prefix_length()</span>, otherwise <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool operator!=(const network_v6&amp; a, const network_v6&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div></div><div id='network.v6.creation'><h3 ><a class='secnum' href='#network.v6.creation' style='min-width:103pt'>21.12.4</a> <span class='texttt'>ip::network_v6</span> creation <a class='abbr_ref' href='internet.network.v6.creation'>[internet.network.v6.creation]</a></h3><p ><code class='itemdecl'>
constexpr network_v6 make_network_v6(const address_v6&amp; addr, int prefix_len);
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.creation-1'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.creation-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>network_v6(addr, prefix_len)</span>.
</p></div></div><p ><code class='itemdecl'>
network_v6 make_network_v6(const char* str);
network_v6 make_network_v6(const char* str, error_code&amp; ec) noexcept;
network_v6 make_network_v6(const string&amp; str);
network_v6 make_network_v6(const string&amp; str, error_code&amp; ec) noexcept;
network_v6 make_network_v6(string_view str);
network_v6 make_network_v6(string_view str, error_code&amp; ec) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.creation-2'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.creation-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>str</span> contains a value of the form address <span class='texttt'>'/'</span> prefix-length, a <span class='texttt'>network_v6</span> object constructed with the result of applying <span class='texttt'>make_address_v6()</span> to the address portion of the string, and the result of converting prefix-length to an integer of type <span class='texttt'>int</span>. Otherwise returns <span class='texttt'>network_v6()</span> and sets <span class='texttt'>ec</span> to reflect the error.</p></div></div><div class='para' id='network.v6.creation-3'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.creation-3'>3</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='network.v6.creation-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#network.v6.creation-3.1'>(3.1)</a></div><p ><span class='texttt'>errc::invalid_argument</span> — if <span class='texttt'>str</span> is not a valid textual representation of an IPv6 address and prefix length.
</p></li></ul></div></div></div><div id='network.v6.io'><h3 ><a class='secnum' href='#network.v6.io' style='min-width:103pt'>21.12.5</a> <span class='texttt'>ip::network_v6</span> I/O <a class='abbr_ref' href='internet.network.v6.io'>[internet.network.v6.io]</a></h3><p ><code class='itemdecl'>
template&lt;class CharT, class Traits&gt;
  basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
    basic_ostream&lt;CharT, Traits&gt;&amp; os, const network_v6&amp; net);
</code></p><div class='itemdescr'></div><div class='para' id='network.v6.io-1'><div class='marginalizedparent'><a class='marginalized' href='#network.v6.io-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>os &lt;&lt; net.to_string().c_str()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_endpoint'></a></span></p></div></div><div id='endpoint'><h2 ><a class='secnum' href='#endpoint' style='min-width:88pt'>21.13</a> Class template <span class='texttt'>ip::basic_endpoint</span> <a class='abbr_ref' href='internet.endpoint'>[internet.endpoint]</a></h2><div class='para' id='endpoint-1'><div class='marginalizedparent'><a class='marginalized' href='#endpoint-1'>1</a></div><p >An object of type <span class='texttt'>basic_endpoint&lt;InternetProtocol&gt;</span> represents a protocol-specific endpoint, where an endpoint consists of an IP address and port number. Endpoints may be used to identify sources and destinations for socket connections and datagrams.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;class InternetProtocol&gt;
  class basic_endpoint
  {
  public:
    <span class='comment'>// types:
</span>    using protocol_type = InternetProtocol;

    <span class='comment'>// <a href='internet.endpoint.cons'>[internet.endpoint.cons]</a>, constructors:
</span>    constexpr basic_endpoint() noexcept;
    constexpr basic_endpoint(const protocol_type&amp; proto,
                             port_type port_num) noexcept;
    constexpr basic_endpoint(const ip::address&amp; addr,
                             port_type port_num) noexcept;

    <span class='comment'>// <a href='internet.endpoint.members'>[internet.endpoint.members]</a>, members:
</span>    constexpr protocol_type protocol() const noexcept;
    constexpr ip::address address() const noexcept;
    void address(const ip::address&amp; addr) noexcept;
    constexpr port_type port() const noexcept;
    void port(port_type port_num) noexcept;
  };

  <span class='comment'>// <a href='internet.endpoint.comparisons'>[internet.endpoint.comparisons]</a>, basic_endpoint comparisons:
</span>  template&lt;class InternetProtocol&gt;
    constexpr bool operator==(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                              const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
  template&lt;class InternetProtocol&gt;
    constexpr bool operator!=(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                              const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
  template&lt;class InternetProtocol&gt;
    constexpr bool operator&lt; (const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                              const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
  template&lt;class InternetProtocol&gt;
    constexpr bool operator&gt; (const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                              const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
  template&lt;class InternetProtocol&gt;
    constexpr bool operator&lt;=(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                              const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
  template&lt;class InternetProtocol&gt;
    constexpr bool operator&gt;=(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                              const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;

  <span class='comment'>// <a href='internet.endpoint.io'>[internet.endpoint.io]</a>, basic_endpoint I/O:
</span>  template&lt;class CharT, class Traits, class InternetProtocol&gt;
    basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
      basic_ostream&lt;CharT, Traits&gt;&amp; os,
      const basic_endpoint&lt;InternetProtocol&gt;&amp; ep);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='endpoint-2'><div class='marginalizedparent'><a class='marginalized' href='#endpoint-2'>2</a></div><p >Instances of the <span class='texttt'>basic_endpoint</span> class template meet the requirements for an <span class='texttt'>Endpoint</span> (<a href='socket.reqmts.endpoint'>[socket.reqmts.endpoint]</a>).</p><p ><span class='indexextensible'>basic_endpoint</span></p></div><div class='para' id='endpoint-3'><div class='marginalizedparent'><a class='marginalized' href='#endpoint-3'>3</a></div><p >Extensible implementations provide the following member functions:</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;class InternetProtocol&gt;
  class basic_endpoint
  {
  public:
    void* data() noexcept;
    const void* data() const noexcept;
    constexpr size_t size() const noexcept;
    void resize(size_t s);
    constexpr size_t capacity() const noexcept;
    <i>// remainder unchanged</i>
  private:
    union
    {
      sockaddr_in v4_;
      sockaddr_in6 v6_;
    } data_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div id='endpoint.cons'><h3 ><a class='secnum' href='#endpoint.cons' style='min-width:103pt'>21.13.1</a> <span class='texttt'>ip::basic_endpoint</span> constructors <a class='abbr_ref' href='internet.endpoint.cons'>[internet.endpoint.cons]</a></h3><p ><code class='itemdecl'>
constexpr basic_endpoint() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address() == ip::address()</span> and <span class='texttt'>port() == 0</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr basic_endpoint(const protocol_type&amp; proto,
                         port_type port_num) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.cons-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>proto == protocol_type::v4() || proto == protocol_type::v6()</span>.</p></div></div><div class='para' id='endpoint.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='endpoint.cons-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#endpoint.cons-3.1'>(3.1)</a></div><p >If <span class='texttt'>proto == protocol_type::v6()</span>, <span class='texttt'>this-&gt;address() == ip::address_v6()</span>; otherwise,<br/>
<span class='texttt'>this-&gt;address() == ip::address_v4()</span>.
</p></li><li id='endpoint.cons-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#endpoint.cons-3.2'>(3.2)</a></div><p ><span class='texttt'>port() == port_num</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
constexpr basic_endpoint(const ip::address&amp; addr,
                         port_type port_num) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.cons-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address() == addr</span> and <span class='texttt'>port() == port_num</span>.
</p></div></div></div><div id='endpoint.members'><h3 ><a class='secnum' href='#endpoint.members' style='min-width:103pt'>21.13.2</a> <span class='texttt'>ip::basic_endpoint</span> members <a class='abbr_ref' href='internet.endpoint.members'>[internet.endpoint.members]</a></h3><p ><code class='itemdecl'>
constexpr protocol_type protocol() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.members-1'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>protocol_type::v6()</span> if the expression <span class='texttt'>this-&gt;address().is_v6()</span> is <span class='texttt'>true</span>, otherwise <span class='texttt'>protocol_type::v4()</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr ip::address address() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.members-2'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The address associated with the endpoint.
</p></div></div><p ><code class='itemdecl'>
void address(const ip::address&amp; addr) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.members-3'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.members-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>this-&gt;address() == addr</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr port_type port() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.members-4'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> The port number associated with the endpoint.
</p></div></div><p ><code class='itemdecl'>
void port(port_type port_num) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.members-5'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.members-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>port() == port_num</span>.
</p></div></div></div><div id='endpoint.comparisons'><h3 ><a class='secnum' href='#endpoint.comparisons' style='min-width:103pt'>21.13.3</a> <span class='texttt'>ip::basic_endpoint</span> comparisons <a class='abbr_ref' href='internet.endpoint.comparisons'>[internet.endpoint.comparisons]</a></h3><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  constexpr bool operator==(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                            const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.address() == b.address() &amp;&amp; a.port() == b.port())</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  constexpr bool operator!=(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                            const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  constexpr bool operator&lt; (const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                            const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.comparisons-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>tie(a.address(), a.port()) &lt; tie(b.address(), b.port())</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  constexpr bool operator&gt; (const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                            const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.comparisons-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>b &lt; a</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  constexpr bool operator&lt;=(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                            const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.comparisons-5'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.comparisons-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(b &lt; a)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  constexpr bool operator&gt;=(const basic_endpoint&lt;InternetProtocol&gt;&amp; a,
                            const basic_endpoint&lt;InternetProtocol&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.comparisons-6'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.comparisons-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a &lt; b)</span>.
</p></div></div></div><div id='endpoint.io'><h3 ><a class='secnum' href='#endpoint.io' style='min-width:103pt'>21.13.4</a> <span class='texttt'>ip::basic_endpoint</span> I/O <a class='abbr_ref' href='internet.endpoint.io'>[internet.endpoint.io]</a></h3><p ><code class='itemdecl'>
template&lt;class CharT, class Traits, class InternetProtocol&gt;
  basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(
    basic_ostream&lt;CharT, Traits&gt;&amp; os,
    const basic_endpoint&lt;InternetProtocol&gt;&amp; ep);
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.io-1'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.io-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Outputs a representation of the endpoint to the stream, as if it were implemented as follows:
</p><pre class='codeblock'>
basic_ostringstream&lt;CharT, Traits&gt; ss;
if (ep.protocol() == basic_endpoint&lt;InternetProtocol&gt;::protocol_type::v6())
  ss &lt;&lt; "[" &lt;&lt; ep.address() &lt;&lt; "]";
else
  ss &lt;&lt; ep.address();
ss &lt;&lt; ":" &lt;&lt; ep.port();
os &lt;&lt; ss.str();
</pre></div></div><div class='para' id='endpoint.io-2'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.io-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>os</span>.
</p></div></div><div class='para' id='endpoint.io-3'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.io-3'>3</a></div><p >[&nbsp;<i>Note:</i> The representation of the endpoint when it contains an IP version 6 address is based on [RFC2732]. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='endpoint.extensible'><h3 ><a class='secnum' href='#endpoint.extensible' style='min-width:103pt'>21.13.5</a> <span class='texttt'>ip::basic_endpoint</span> members (extensible implementations) <a class='abbr_ref' href='internet.endpoint.extensible'>[internet.endpoint.extensible]</a></h3><p ><code class='itemdecl'>
void* data() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.extensible-1'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.extensible-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>addressof(data_)</span>.
</p></div></div><p ><code class='itemdecl'>
const void* data() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.extensible-2'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.extensible-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>addressof(data_)</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr size_t size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.extensible-3'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.extensible-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>sizeof(sockaddr_in6)</span> if <span class='texttt'>protocol().family() == AF_INET6</span>, otherwise <span class='texttt'>sizeof(sockaddr_in)</span>.
</p></div></div><p ><code class='itemdecl'>
void resize(size_t s);
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.extensible-4'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.extensible-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> <span class='texttt'>length_error</span> if either of the following conditions is <span class='texttt'>true</span>:
</p><ul class='itemize'><li id='endpoint.extensible-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#endpoint.extensible-4.1'>(4.1)</a></div><p ><span class='texttt'>protocol().family() == AF_INET6 &amp;&amp; s != sizeof(sockaddr_in6)</span>,
</p></li><li id='endpoint.extensible-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#endpoint.extensible-4.2'>(4.2)</a></div><p ><span class='texttt'>protocol().family() == AF_INET4 &amp;&amp; s != sizeof(sockaddr_in)</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
constexpr size_t capacity() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='endpoint.extensible-5'><div class='marginalizedparent'><a class='marginalized' href='#endpoint.extensible-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>sizeof(data_)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_resolver_entry'></a></span></p></div></div><div id='resolver.entry'><h2 ><a class='secnum' href='#resolver.entry' style='min-width:88pt'>21.14</a> Class template <span class='texttt'>ip::basic_resolver_entry</span> <a class='abbr_ref' href='internet.resolver.entry'>[internet.resolver.entry]</a></h2><div class='para' id='resolver.entry-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.entry-1'>1</a></div><p >An object of type <span class='texttt'>basic_resolver_entry&lt;InternetProtocol&gt;</span> represents a single element in the results returned by a name resolution operation.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;class InternetProtocol&gt;
  class basic_resolver_entry
  {
  public:
    <span class='comment'>// types:
</span>    using protocol_type = InternetProtocol;
    using endpoint_type = typename InternetProtocol::endpoint;

    <span class='comment'>// <a href='internet.resolver.entry.cons'>[internet.resolver.entry.cons]</a>, constructors:
</span>    basic_resolver_entry();
    basic_resolver_entry(const endpoint_type&amp; ep,
                         string_view h,
                         string_view s);

    <span class='comment'>// <a href='internet.resolver.entry.members'>[internet.resolver.entry.members]</a>, members:
</span>    endpoint_type endpoint() const;
    operator endpoint_type() const;
    template&lt;class Allocator = allocator&lt;char&gt;&gt;
      basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
        host_name(const Allocator&amp; a = Allocator()) const;
    template&lt;class Allocator = allocator&lt;char&gt;&gt;
      basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
        service_name(const Allocator&amp; a = Allocator()) const;
  };

  <span class='comment'>// <a href='internet.resolver.entry.comparisons'>[internet.resolver.entry.comparisons]</a>, basic_resolver_entry comparisons:
</span>  template&lt;class InternetProtocol&gt;
    bool operator==(const basic_resolver_entry&lt;InternetProtocol&gt;&amp; a,
                    const basic_resolver_entry&lt;InternetProtocol&gt;&amp; b);
  template&lt;class InternetProtocol&gt;
    bool operator!=(const basic_resolver_entry&lt;InternetProtocol&gt;&amp; a,
                    const basic_resolver_entry&lt;InternetProtocol&gt;&amp; b);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div id='resolver.entry.cons'><h3 ><a class='secnum' href='#resolver.entry.cons' style='min-width:103pt'>21.14.1</a> <span class='texttt'>ip::basic_resolver_entry</span> constructors <a class='abbr_ref' href='internet.resolver.entry.cons'>[internet.resolver.entry.cons]</a></h3><p ><code class='itemdecl'>
basic_resolver_entry();
</code></p><div class='itemdescr'></div><div class='para' id='resolver.entry.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.entry.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>basic_resolver_entry&lt;InternetProtocol&gt;(endpoint_type(), "", "")</span>.
</p></div></div><p ><code class='itemdecl'>
basic_resolver_entry(const endpoint_type&amp; ep,
                     string_view h,
                     string_view s);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.entry.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#resolver.entry.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> 
</p><ul class='itemize'><li id='resolver.entry.cons-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#resolver.entry.cons-2.1'>(2.1)</a></div><p ><span class='texttt'>endpoint() == ep</span>.
</p></li><li id='resolver.entry.cons-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#resolver.entry.cons-2.2'>(2.2)</a></div><p ><span class='texttt'>host_name() == h</span>.
</p></li><li id='resolver.entry.cons-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#resolver.entry.cons-2.3'>(2.3)</a></div><p ><span class='texttt'>service_name() == s</span>.
</p></li></ul></div></div></div><div id='resolver.entry.members'><h3 ><a class='secnum' href='#resolver.entry.members' style='min-width:103pt'>21.14.2</a> <span class='texttt'>ip::basic_resolver_entry</span> members <a class='abbr_ref' href='internet.resolver.entry.members'>[internet.resolver.entry.members]</a></h3><p ><code class='itemdecl'>
endpoint_type endpoint() const;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.entry.members-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.entry.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The endpoint associated with the resolver entry.
</p></div></div><p ><code class='itemdecl'>
operator endpoint_type() const;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.entry.members-2'><div class='marginalizedparent'><a class='marginalized' href='#resolver.entry.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>endpoint()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Allocator = allocator&lt;char&gt;&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    host_name(const Allocator&amp; a = Allocator()) const;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.entry.members-3'><div class='marginalizedparent'><a class='marginalized' href='#resolver.entry.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> The host name associated with the resolver entry.</p></div></div><div class='para' id='resolver.entry.members-4'><div class='marginalizedparent'><a class='marginalized' href='#resolver.entry.members-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> Ill-formed unless <span class='texttt'>allocator_traits&lt;Allocator&gt;::value_type</span> is <span class='texttt'>char</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Allocator = allocator&lt;char&gt;&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    service_name(const Allocator&amp; a = Allocator()) const;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.entry.members-5'><div class='marginalizedparent'><a class='marginalized' href='#resolver.entry.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> The service name associated with the resolver entry.</p></div></div><div class='para' id='resolver.entry.members-6'><div class='marginalizedparent'><a class='marginalized' href='#resolver.entry.members-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i> Ill-formed unless <span class='texttt'>allocator_traits&lt;Allocator&gt;::value_type</span> is <span class='texttt'>char</span>.
</p></div></div></div><div id='resolver.entry.comparisons'><h3 ><a class='secnum' href='#resolver.entry.comparisons' style='min-width:103pt'>21.14.3</a> <span class='texttt'>op::basic_resolver_entry</span> comparisons <a class='abbr_ref' href='internet.resolver.entry.comparisons'>[internet.resolver.entry.comparisons]</a></h3><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  bool operator==(const basic_resolver_entry&lt;InternetProtocol&gt;&amp; a,
                  const basic_resolver_entry&lt;InternetProtocol&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.entry.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.entry.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.endpoint() == b.endpoint() &amp;&amp; a.host_name() == b.host_name() &amp;&amp; a.service_name() == b.service_name()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  bool operator!=(const basic_resolver_entry&lt;InternetProtocol&gt;&amp; a,
                  const basic_resolver_entry&lt;InternetProtocol&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.entry.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#resolver.entry.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_resolver_results'></a></span></p></div></div><div id='resolver.results'><h2 ><a class='secnum' href='#resolver.results' style='min-width:88pt'>21.15</a> Class template <span class='texttt'>ip::basic_resolver_results</span> <a class='abbr_ref' href='internet.resolver.results'>[internet.resolver.results]</a></h2><div class='para' id='resolver.results-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results-1'>1</a></div><p >An object of type <span class='texttt'>basic_resolver_results&lt;InternetProtocol&gt;</span>
represents a sequence of <span class='texttt'>basic_resolver_entry&lt;InternetProtocol&gt;</span> elements
resulting from a single name resolution operation.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;class InternetProtocol&gt;
  class basic_resolver_results
  {
  public:
    <span class='comment'>// types:
</span>    using protocol_type = InternetProtocol;
    using endpoint_type = typename protocol_type::endpoint;
    using value_type = basic_resolver_entry&lt;protocol_type&gt;;
    using const_reference = const value_type&amp;;
    using reference = value_type&amp;;
    using const_iterator = <span class='indexparent'><a class='index' id='type_of_basic_resolver_results::const_iterator'></a></span><i>implementation-defined</i>;
    using iterator = const_iterator;
    using difference_type = ptrdiff_t;
    using size_type = size_t;

    <span class='comment'>// <a href='internet.resolver.results.cons'>[internet.resolver.results.cons]</a>, construct / copy / destroy:
</span>    basic_resolver_results();
    basic_resolver_results(const basic_resolver_results&amp; rhs);
    basic_resolver_results(basic_resolver_results&amp;&amp; rhs) noexcept;
    basic_resolver_results&amp; operator=(const basic_resolver_results&amp; rhs);
    basic_resolver_results&amp; operator=(basic_resolver_results&amp;&amp; rhs);
    ~basic_resolver_results();

    <span class='comment'>// <a href='internet.resolver.results.size'>[internet.resolver.results.size]</a>, size:
</span>    size_type size() const noexcept;
    size_type max_size() const noexcept;
    bool empty() const noexcept;

    <span class='comment'>// <a href='internet.resolver.results.access'>[internet.resolver.results.access]</a>, element access:
</span>    const_iterator begin() const;
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;

    <span class='comment'>// <a href='internet.resolver.results.swap'>[internet.resolver.results.swap]</a>, swap:
</span>    void swap(basic_resolver_results&amp; that) noexcept;
  };

  <span class='comment'>// <a href='internet.resolver.results.comparisons'>[internet.resolver.results.comparisons]</a>, basic_resolver_results comparisons:
</span>  template&lt;class InternetProtocol&gt;
    bool operator==(const basic_resolver_results&lt;InternetProtocol&gt;&amp; a,
                    const basic_resolver_results&lt;InternetProtocol&gt;&amp; b);
  template&lt;class InternetProtocol&gt;
    bool operator!=(const basic_resolver_results&lt;InternetProtocol&gt;&amp; a,
                    const basic_resolver_results&lt;InternetProtocol&gt;&amp; b);

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='resolver.results-2'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results-2'>2</a></div><p >The class template <span class='texttt'>basic_resolver_results</span> satisfies the requirements of a sequence container (<span class='CppXref'>sequence.reqmts</span>), except that only the operations defined for const-qualified sequence containers are supported. The class template <span class='texttt'>basic_resolver_results</span> supports forward iterators.</p></div><div class='para' id='resolver.results-3'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results-3'>3</a></div><p >A default-constructed <span class='texttt'>basic_resolver_results</span> object is empty. A non-empty results object is obtained only by calling a <span class='texttt'>basic_resolver</span> object's <span class='texttt'>wait</span> or <span class='texttt'>async_wait</span> operations, or otherwise by copy construction, move construction, assignment, or swap from another non-empty results object.</p></div><div id='resolver.results.cons'><h3 ><a class='secnum' href='#resolver.results.cons' style='min-width:103pt'>21.15.1</a> <span class='texttt'>ip::basic_resolver_results</span> constructors <a class='abbr_ref' href='internet.resolver.results.cons'>[internet.resolver.results.cons]</a></h3><p ><code class='itemdecl'>
basic_resolver_results();
</code></p><div class='itemdescr'></div><div class='para' id='resolver.results.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>size() == 0</span>.
</p></div></div><p ><code class='itemdecl'>
basic_resolver_results(const basic_resolver_results&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.results.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this == rhs</span>.
</p></div></div><p ><code class='itemdecl'>
basic_resolver_results(basic_resolver_results&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.results.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>rhs</span>.
</p></div></div></div><div id='resolver.results.assign'><h3 ><a class='secnum' href='#resolver.results.assign' style='min-width:103pt'>21.15.2</a> <span class='texttt'>ip::basic_resolver_results</span> assignment <a class='abbr_ref' href='internet.resolver.results.assign'>[internet.resolver.results.assign]</a></h3><p ><code class='itemdecl'>
basic_resolver_results&amp; operator=(const basic_resolver_results&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.results.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.assign-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this == rhs</span>.</p></div></div><div class='para' id='resolver.results.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
basic_resolver_results&amp; operator=(basic_resolver_results&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.results.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.assign-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='resolver.results.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.assign-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='resolver.results.size'><h3 ><a class='secnum' href='#resolver.results.size' style='min-width:103pt'>21.15.3</a> <span class='texttt'>ip::basic_resolver_results</span> size <a class='abbr_ref' href='internet.resolver.results.size'>[internet.resolver.results.size]</a></h3><p ><code class='itemdecl'>
size_type size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.results.size-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.size-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of <span class='texttt'>basic_resolver_entry</span> elements in <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
size_type max_size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.results.size-2'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.size-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The maximum number of <span class='texttt'>basic_resolver_entry</span> elements that can be stored in <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
bool empty() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.results.size-3'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.size-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>size() == 0</span>.
</p></div></div></div><div id='resolver.results.access'><h3 ><a class='secnum' href='#resolver.results.access' style='min-width:103pt'>21.15.4</a> <span class='texttt'>ip::basic_resolver_results</span> element access <a class='abbr_ref' href='internet.resolver.results.access'>[internet.resolver.results.access]</a></h3><p ><code class='itemdecl'>
const_iterator begin() const;
const_iterator cbegin() const;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.results.access-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.access-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A starting iterator that enumerates over all the <span class='texttt'>basic_resolver_entry</span> elements stored in <span class='texttt'>*this</span>.
</p></div></div><p ><code class='itemdecl'>
const_iterator end() const;
const_iterator cend() const;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.results.access-2'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.access-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> A terminating iterator that enumerates over all the <span class='texttt'>basic_resolver_entry</span> elements stored in <span class='texttt'>*this</span>.
</p></div></div></div><div id='resolver.results.swap'><h3 ><a class='secnum' href='#resolver.results.swap' style='min-width:103pt'>21.15.5</a> <span class='texttt'>ip::basic_resolver_results</span> swap <a class='abbr_ref' href='internet.resolver.results.swap'>[internet.resolver.results.swap]</a></h3><p ><code class='itemdecl'>
void swap(basic_resolver_results&amp; that) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.results.swap-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.swap-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> is equal to the prior value of <span class='texttt'>that</span>, and <span class='texttt'>that</span> is equal to the prior value of <span class='texttt'>*this</span>.
</p></div></div></div><div id='resolver.results.comparisons'><h3 ><a class='secnum' href='#resolver.results.comparisons' style='min-width:103pt'>21.15.6</a> <span class='texttt'>ip::basic_resolver_results</span> comparisons <a class='abbr_ref' href='internet.resolver.results.comparisons'>[internet.resolver.results.comparisons]</a></h3><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  bool operator==(const basic_resolver_results&lt;InternetProtocol&gt;&amp; a,
                  const basic_resolver_results&lt;InternetProtocol&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.results.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.size() == b.size() &amp;&amp; equal(a.cbegin(), a.cend(), b.cbegin())</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class InternetProtocol&gt;
  bool operator!=(const basic_resolver_results&lt;InternetProtocol&gt;&amp; a,
                  const basic_resolver_results&lt;InternetProtocol&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.results.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#resolver.results.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='resolver_base'></a></span></p></div></div><div id='resolver.base'><h2 ><a class='secnum' href='#resolver.base' style='min-width:88pt'>21.16</a> Class <span class='texttt'>ip::resolver_base</span> <a class='abbr_ref' href='internet.resolver.base'>[internet.resolver.base]</a></h2><p ><span class='indexparent'><a class='index' id='resolve_base'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class resolver_base
  {
  public:
    using flags = <i>T1</i>;
    static const flags passive;
    static const flags canonical_name;
    static const flags numeric_host;
    static const flags numeric_service;
    static const flags v4_mapped;
    static const flags all_matching;
    static const flags address_configured;

  protected:
    resolver_base();
    ~resolver_base();
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='resolver.base-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.base-1'>1</a></div><p ><span class='texttt'>resolver_base</span> defines a bitmask type, <span class='texttt'>flags</span>, with the bitmask elements shown in Table <a href='#tab:internet.resolver.base.requirements'>[tab:internet.resolver.base.requirements]</a>.</p><div class='numberedTable' id='tab:internet.resolver.base.requirements'>Table <a href='#tab:internet.resolver.base.requirements'>37</a> — Resolver flags<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Constant name</b></td><td colspan='1' class='center'><b>POSIX macro</b></td><td colspan='1' class='center'><b>Definition or notes</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>passive</span>  </td><td class='left'>
<span class='texttt'>AI_PASSIVE</span>  </td><td class='left'>
 Returned endpoints are intended for use as locally bound socket endpoints.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>canonical_name</span>  </td><td class='left'>
<span class='texttt'>AI_CANONNAME</span>  </td><td class='left'>
 Determine the canonical name of the host specified in the query.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>numeric_host</span>  </td><td class='left'>
<span class='texttt'>AI_NUMERICHOST</span>  </td><td class='left'>
 Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no host name resolution should be attempted.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>numeric_service</span>  </td><td class='left'>
<span class='texttt'>AI_NUMERICSERV</span>  </td><td class='left'>
 Service name should be treated as a numeric string defining a port number and no service name resolution should be attempted.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>v4_mapped</span>  </td><td class='left'>
<span class='texttt'>AI_V4MAPPED</span>  </td><td class='left'>
 If the protocol is specified as an IPv6 protocol, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>all_matching</span>  </td><td class='left'>
<span class='texttt'>AI_ALL</span>  </td><td class='left'>
If used with <span class='texttt'>v4_mapped</span>, return all matching IPv6 and IPv4 addresses.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>address_configured</span>  </td><td class='left'>
<span class='texttt'>AI_ADDRCONFIG</span>  </td><td class='left'>
 Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system.  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='basic_resolver'></a></span></p></div></div><div id='resolver'><h2 ><a class='secnum' href='#resolver' style='min-width:88pt'>21.17</a> Class template <span class='texttt'>ip::basic_resolver</span> <a class='abbr_ref' href='internet.resolver'>[internet.resolver]</a></h2><div class='para' id='resolver-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver-1'>1</a></div><p >Objects of type <span class='texttt'>basic_resolver&lt;InternetProtocol&gt;</span> are used to perform name resolution. Name resolution is the translation of a host name and service name into a sequence of endpoints, or the translation of an endpoint into its corresponding host name and service name.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  template&lt;class InternetProtocol&gt;
  class basic_resolver : public resolver_base
  {
  public:
    <span class='comment'>// types:
</span>
    using executor_type = io_context::executor_type;
    using protocol_type = InternetProtocol;
    using endpoint_type = typename InternetProtocol::endpoint;
    using results_type = basic_resolver_results&lt;InternetProtocol&gt;;

    <span class='comment'>// <a href='internet.resolver.cons'>[internet.resolver.cons]</a>, construct / copy / destroy:
</span>
    explicit basic_resolver(io_context&amp; ctx);
    basic_resolver(const basic_resolver&amp;) = delete;
    basic_resolver(basic_resolver&amp;&amp; rhs) noexcept;

    ~basic_resolver();

    basic_resolver&amp; operator=(const basic_resolver&amp;) = delete;
    basic_resolver&amp; operator=(basic_resolver&amp;&amp; rhs);

    <span class='comment'>// <a href='internet.resolver.ops'>[internet.resolver.ops]</a>, basic_resolver operations:
</span>
    executor_type get_executor() noexcept;

    void cancel();

    results_type resolve(string_view host_name, string_view service_name);
    results_type resolve(string_view host_name, string_view service_name,
                         error_code&amp; ec);
    results_type resolve(string_view host_name, string_view service_name,
                         flags f);
    results_type resolve(string_view host_name, string_view service_name,
                         flags f, error_code&amp; ec);

    template&lt;class CompletionToken&gt;
      <span class='DEDUCED'></span> async_resolve(string_view host_name, string_view service_name,
                            CompletionToken&amp;&amp; token);
    template&lt;class CompletionToken&gt;
      <span class='DEDUCED'></span> async_resolve(string_view host_name, string_view service_name,
                            flags f, CompletionToken&amp;&amp; token);

    results_type resolve(const protocol_type&amp; protocol,
                         string_view host_name, string_view service_name);
    results_type resolve(const protocol_type&amp; protocol,
                         string_view host_name, string_view service_name,
                         error_code&amp; ec);
    results_type resolve(const protocol_type&amp; protocol,
                         string_view host_name, string_view service_name,
                         flags f);
    results_type resolve(const protocol_type&amp; protocol,
                         string_view host_name, string_view service_name,
                         flags f, error_code&amp; ec);

    template&lt;class CompletionToken&gt;
      <span class='DEDUCED'></span> async_resolve(const protocol_type&amp; protocol,
                            string_view host_name, string_view service_name,
                            CompletionToken&amp;&amp; token);
    template&lt;class CompletionToken&gt;
      <span class='DEDUCED'></span> async_resolve(const protocol_type&amp; protocol,
                            string_view host_name, string_view service_name,
                            flags f, CompletionToken&amp;&amp; token);

    results_type resolve(const endpoint_type&amp; e);
    results_type resolve(const endpoint_type&amp; e, error_code&amp; ec);

    template&lt;class CompletionToken&gt;
      <span class='DEDUCED'></span> async_resolve(const endpoint_type&amp; e,
                            CompletionToken&amp;&amp; token);
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div id='resolver.cons'><h3 ><a class='secnum' href='#resolver.cons' style='min-width:103pt'>21.17.1</a> <span class='texttt'>ip::basic_resolver</span> constructors <a class='abbr_ref' href='internet.resolver.cons'>[internet.resolver.cons]</a></h3><p ><code class='itemdecl'>
explicit basic_resolver(io_context&amp; ctx);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.cons-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_executor() == ctx.get_executor()</span>.
</p></div></div><p ><code class='itemdecl'>
basic_resolver(basic_resolver&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#resolver.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs an object of class <span class='texttt'>basic_resolver&lt;InternetProtocol&gt;</span> that refers to the state originally represented by <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='resolver.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#resolver.cons-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_executor() == rhs.get_executor()</span>.
</p></div></div></div><div id='resolver.dtor'><h3 ><a class='secnum' href='#resolver.dtor' style='min-width:103pt'>21.17.2</a> <span class='texttt'>ip::basic_resolver</span> destructor <a class='abbr_ref' href='internet.resolver.dtor'>[internet.resolver.dtor]</a></h3><p ><code class='itemdecl'>
~basic_resolver();
</code></p><div class='itemdescr'></div><div class='para' id='resolver.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys the resolver, canceling all asynchronous operations associated with this resolver as if by calling <span class='texttt'>cancel()</span>.
</p></div></div></div><div id='resolver.assign'><h3 ><a class='secnum' href='#resolver.assign' style='min-width:103pt'>21.17.3</a> <span class='texttt'>ip::basic_resolver</span> assignment <a class='abbr_ref' href='internet.resolver.assign'>[internet.resolver.assign]</a></h3><p ><code class='itemdecl'>
basic_resolver&amp; operator=(basic_resolver&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Cancels all outstanding asynchronous operations associated with <span class='texttt'>*this</span> as if by calling <span class='texttt'>cancel()</span>, then moves into <span class='texttt'>*this</span> the state originally represented by <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='resolver.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#resolver.assign-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_executor() == rhs.get_executor()</span>.</p></div></div><div class='para' id='resolver.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#resolver.assign-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='resolver.ops'><h3 ><a class='secnum' href='#resolver.ops' style='min-width:103pt'>21.17.4</a> <span class='texttt'>ip::basic_resolver</span> operations <a class='abbr_ref' href='internet.resolver.ops'>[internet.resolver.ops]</a></h3><p ><code class='itemdecl'>
executor_type get_executor() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='resolver.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The associated executor.
</p></div></div><p ><code class='itemdecl'>
void cancel();
</code></p><div class='itemdescr'></div><div class='para' id='resolver.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Cancels all outstanding asynchronous resolve operations associated with <span class='texttt'>*this</span>. Completion handlers for canceled operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='resolver.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> Does not block (<span class='CppXref'>defns.block</span>) the calling thread pending completion of the canceled operations.
</p></div></div><p ><code class='itemdecl'>
results_type resolve(string_view host_name, string_view service_name);
results_type resolve(string_view host_name, string_view service_name,
                     error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>resolve(host_name, service_name, resolver_base::flags(), ec)</span>.
</p></div></div><p ><code class='itemdecl'>
results_type resolve(string_view host_name, string_view service_name,
                     flags f);
results_type resolve(string_view host_name, string_view service_name,
                     flags f, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>host_name.data() != nullptr</span>, let H be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>host_name</span>; otherwise, let H be <span class='texttt'>nullptr</span>. If <span class='texttt'>service_name.data() != nullptr</span>, let S be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>service_name</span>; otherwise, let S be <span class='texttt'>nullptr</span>. Resolves a host name and service name, as if by POSIX:
</p><pre class='codeblock'>
addrinfo hints;
hints.ai_flags = static_cast&lt;int&gt;(f);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = endpoint_type().protocol().type();
hints.ai_protocol = endpoint_type().protocol().protocol();
hints.ai_addr = nullptr;
hints.ai_addrlen = 0;
hints.ai_canonname = nullptr;
hints.ai_next = nullptr;
addrinfo* result = nullptr;
getaddrinfo(H, S, &amp;hints, &amp;result);
</pre></div></div><div class='para' id='resolver.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, a non-empty results object containing the results of the resolve operation. Otherwise <span class='texttt'>results_type()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <span class='DEDUCED'></span> async_resolve(string_view host_name, string_view service_name,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><pre class='codeblock'>
async_resolve(host_name, service_name, resolver_base::flags(),
              forward&lt;CompletionToken&gt;(token))
</pre></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <span class='DEDUCED'></span> async_resolve(string_view host_name, string_view service_name,
                        flags f, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-8'>8</a></div><div class='itemdescr'><p ><span class='completionsig'></span> <span class='texttt'>void(error_code ec, results_type r)</span>.</p></div></div><div class='para' id='resolver.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>host_name.data() != nullptr</span>, let H be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>host_name</span>; otherwise, let H be <span class='texttt'>nullptr</span>. If <span class='texttt'>service_name.data() != nullptr</span>, let S be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>service_name</span>; otherwise, let S be <span class='texttt'>nullptr</span>. Initiates an asynchronous operation to resolve a host name and service name, as if by POSIX:
</p><pre class='codeblock'>
addrinfo hints;
hints.ai_flags = static_cast&lt;int&gt;(f);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = endpoint_type().protocol().type();
hints.ai_protocol = endpoint_type().protocol().protocol();
hints.ai_addr = nullptr;
hints.ai_addrlen = 0;
hints.ai_canonname = nullptr;
hints.ai_next = nullptr;
addrinfo* result = nullptr;
getaddrinfo(H, S, &amp;hints, &amp;result);
</pre><p >On success, <span class='texttt'>r</span> is a non-empty results object containing the results of the resolve operation. Otherwise, <span class='texttt'>r</span> is <span class='texttt'>results_type()</span>.
</p></div></div><p ><code class='itemdecl'>
results_type resolve(const protocol_type&amp; protocol,
                     string_view host_name, string_view service_name);
results_type resolve(const protocol_type&amp; protocol,
                     string_view host_name, string_view service_name,
                     error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.ops-10'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>resolve(protocol, host_name, service_name, resolver_base::flags(), ec)</span>.
</p></div></div><p ><code class='itemdecl'>
results_type resolve(const protocol_type&amp; protocol,
                     string_view host_name, string_view service_name,
                     flags f);
results_type resolve(const protocol_type&amp; protocol,
                     string_view host_name, string_view service_name,
                     flags f, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.ops-11'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>host_name.data() != nullptr</span>, let H be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>host_name</span>; otherwise, let H be <span class='texttt'>nullptr</span>. If <span class='texttt'>service_name.data() != nullptr</span>, let S be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>service_name</span>; otherwise, let S be <span class='texttt'>nullptr</span>. Resolves a host name and service name, as if by POSIX:
</p><pre class='codeblock'>
addrinfo hints;
hints.ai_flags = static_cast&lt;int&gt;(f);
hints.ai_family = protocol.family();
hints.ai_socktype = protocol.type();
hints.ai_protocol = protocol.protocol();
hints.ai_addr = nullptr;
hints.ai_addrlen = 0;
hints.ai_canonname = nullptr;
hints.ai_next = nullptr;
addrinfo* result = nullptr;
getaddrinfo(H, S, &amp;hints, &amp;result);
</pre></div></div><div class='para' id='resolver.ops-12'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, a non-empty results object containing the results of the resolve operation. Otherwise <span class='texttt'>results_type()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <span class='DEDUCED'></span> async_resolve(const protocol_type&amp; protocol,
                        string_view host_name, string_view service_name,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.ops-13'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><pre class='codeblock'>
async_resolve(protocol, host_name, service_name, resolver_base::flags(),
              forward&lt;CompletionToken&gt;(token))
</pre></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <span class='DEDUCED'></span> async_resolve(const protocol&amp; protocol,
                        string_view host_name, string_view service_name,
                        flags f, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.ops-14'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-14'>14</a></div><div class='itemdescr'><p ><span class='completionsig'></span> <span class='texttt'>void(error_code ec, results_type r)</span>.</p></div></div><div class='para' id='resolver.ops-15'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>host_name.data() != nullptr</span>, let H be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>host_name</span>; otherwise, let H be <span class='texttt'>nullptr</span>. If <span class='texttt'>service_name.data() != nullptr</span>, let S be an <span class='textsc'>ntbs</span> constructed from <span class='texttt'>service_name</span>; otherwise, let S be <span class='texttt'>nullptr</span>. Initiates an asynchronous operation to resolve a host name and service name, as if by POSIX:
</p><pre class='codeblock'>
addrinfo hints;
hints.ai_flags = static_cast&lt;int&gt;(f);
hints.ai_family = protocol.family();
hints.ai_socktype = protocol.type();
hints.ai_protocol = protocol.protocol();
hints.ai_addr = nullptr;
hints.ai_addrlen = 0;
hints.ai_canonname = nullptr;
hints.ai_next = nullptr;
addrinfo* result = nullptr;
getaddrinfo(H, S, &amp;hints, &amp;result);
</pre><p >On success, <span class='texttt'>r</span> is a non-empty results object containing the results of the resolve operation. Otherwise, <span class='texttt'>r</span> is <span class='texttt'>results_type()</span>.
</p></div></div><p ><code class='itemdecl'>
results_type resolve(const endpoint_type&amp; e);
results_type resolve(const endpoint_type&amp; e, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.ops-16'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> Let <span class='texttt'>S1</span> and <span class='texttt'>S2</span> be <span class='indexparent'><a class='index' id='maximum_length_of_host_and_service_names'></a></span>implementation-defined values that are sufficiently large to hold the host name and service name respectively. Resolves an endpoint as if by POSIX:
</p><pre class='codeblock'>
char host_name[S1];
char service_name[S2];
int flags = 0;
if (endpoint_type().protocol().type() == SOCK_DGRAM)
  flags |= NI_DGRAM;
int result = getnameinfo((const sockaddr*)e.data(), e.size(),
                         host_name, S1,
                         service_name, S2,
                         flags);
if (result != 0){
  flags |= NI_NUMERICSERV;
  result = getnameinfo((const sockaddr*)e.data(), e.size(),
                       host_name, S1,
                       service_name, S2,
                       flags);
}
</pre></div></div><div class='para' id='resolver.ops-17'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-17'>17</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, a results object with <span class='texttt'>size() == 1</span> containing the results of the resolve operation. Otherwise <span class='texttt'>results_type()</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <span class='DEDUCED'></span> async_resolve(const endpoint_type&amp; e,
                        CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='resolver.ops-18'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-18'>18</a></div><div class='itemdescr'><p ><span class='completionsig'></span> <span class='texttt'>void(error_code ec, results_type r)</span>.</p></div></div><div class='para' id='resolver.ops-19'><div class='marginalizedparent'><a class='marginalized' href='#resolver.ops-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> Let <span class='texttt'>S1</span> and <span class='texttt'>S2</span> be <span class='indexparent'><a class='index' id='maximum_length_of_host_and_service_names'></a></span>implementation-defined values that are sufficiently large to hold the host name and service name respectively. Initiates an asynchronous operation to resolve an endpoint as if by POSIX:
</p><pre class='codeblock'>
char host_name[S1];
char service_name[S2];
int flags = 0;
if (endpoint_type().protocol().type() == SOCK_DGRAM)
  flags |= NI_DGRAM;
int result = getnameinfo((const sockaddr*)e.data(), e.size(),
                         host_name, S1,
                         service_name, S2,
                         flags);
if (result != 0){
  flags |= NI_NUMERICSERV;
  result = getnameinfo((const sockaddr*)e.data(), e.size(),
                       host_name, S1,
                       service_name, S2,
                       flags);
}
</pre><p >On success, <span class='texttt'>r</span> is a results object with <span class='texttt'>size() == 1</span> containing the results of the resolve operation; otherwise, <span class='texttt'>r</span> is <span class='texttt'>results_type()</span>.
</p></div></div></div></div><div id='host.name'><h2 ><a class='secnum' href='#host.name' style='min-width:88pt'>21.18</a> Host name functions <a class='abbr_ref' href='internet.host.name'>[internet.host.name]</a></h2><p ><span class='indexparent'><a class='index' id='host_name'></a></span><code class='itemdecl'>
string host_name();
string host_name(error_code&amp; ec);
template&lt;class Allocator&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    host_name(const Allocator&amp; a);
template&lt;class Allocator&gt;
  basic_string&lt;char, char_traits&lt;char&gt;, Allocator&gt;
    host_name(const Allocator&amp; a, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='host.name-1'><div class='marginalizedparent'><a class='marginalized' href='#host.name-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The standard host name for the current machine, determined as if by POSIX <span class='texttt'>gethostname</span>.</p></div></div><div class='para' id='host.name-2'><div class='marginalizedparent'><a class='marginalized' href='#host.name-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> In the last two overloads, ill-formed unless <span class='texttt'>allocator_traits&lt;Allocator&gt;::value_type</span> is <span class='texttt'>char</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='tcp'></a></span></p></div><div id='tcp'><h2 ><a class='secnum' href='#tcp' style='min-width:88pt'>21.19</a> Class <span class='texttt'>ip::tcp</span> <a class='abbr_ref' href='internet.tcp'>[internet.tcp]</a></h2><div class='para' id='tcp-1'><div class='marginalizedparent'><a class='marginalized' href='#tcp-1'>1</a></div><p >The class <span class='texttt'>tcp</span> encapsulates the types and flags necessary for TCP sockets.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class tcp
  {
  public:
    <span class='comment'>// types:
</span>    using endpoint = basic_endpoint&lt;tcp&gt;;
    using resolver = basic_resolver&lt;tcp&gt;;
    using socket = basic_stream_socket&lt;tcp&gt;;
    using acceptor = basic_socket_acceptor&lt;tcp&gt;;
    using iostream = basic_socket_iostream&lt;tcp&gt;;
    class no_delay;

    <span class='comment'>// static members:
</span>    static constexpr tcp v4() noexcept;
    static constexpr tcp v6() noexcept;

    tcp() = delete;
  };

  <span class='comment'>// <a href='internet.tcp.comparisons'>[internet.tcp.comparisons]</a>, tcp comparisons:
</span>  constexpr bool operator==(const tcp&amp; a, const tcp&amp; b) noexcept;
  constexpr bool operator!=(const tcp&amp; a, const tcp&amp; b) noexcept;

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='tcp-2'><div class='marginalizedparent'><a class='marginalized' href='#tcp-2'>2</a></div><p >The <span class='texttt'>tcp</span> class meets the requirements for an <span class='texttt'>InternetProtocol</span> (<a href='internet.reqmts.protocol'>[internet.reqmts.protocol]</a>).</p><p ><span class='indexextensible'>tcp</span></p></div><div class='para' id='tcp-3'><div class='marginalizedparent'><a class='marginalized' href='#tcp-3'>3</a></div><p >Extensible implementations provide the following member functions:</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class tcp
  {
  public:
    constexpr int family() const noexcept;
    constexpr int type() const noexcept;
    constexpr int protocol() const noexcept;
    <i>// remainder unchanged</i>
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='tcp-4'><div class='marginalizedparent'><a class='marginalized' href='#tcp-4'>4</a></div><p >The return values for these member functions are listed in Table <a href='#tab:internet.tcp.requirements'>[tab:internet.tcp.requirements]</a>.</p><div class='numberedTable' id='tab:internet.tcp.requirements'>Table <a href='#tab:internet.tcp.requirements'>38</a> — Behavior of extensible <span class='texttt'>ip::tcp</span> implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>value</b></td><td colspan='1' class='center'><b>family()</b></td><td colspan='1' class='center'><b>type()</b></td><td colspan='1' class='center'><b>protocol()</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>tcp::v4()</span>  </td><td class='left'>
<span class='texttt'>AF_INET</span>  </td><td class='left'>
<span class='texttt'>SOCK_STREAM</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_TCP</span>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>tcp::v6()</span>  </td><td class='left'>
<span class='texttt'>AF_INET6</span>  </td><td class='left'>
<span class='texttt'>SOCK_STREAM</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_TCP</span>  </td></tr></table></div></div><div class='para' id='tcp-5'><div class='marginalizedparent'><a class='marginalized' href='#tcp-5'>5</a></div><p >[&nbsp;<i>Note:</i> The constants <span class='texttt'>AF_INET</span>, <span class='texttt'>AF_INET6</span> and <span class='texttt'>SOCK_STREAM</span> are defined in the POSIX <span class='texttt'>&lt;sys/socket.h&gt;</span> header. The constant <span class='texttt'>IPPROTO_TCP</span> is defined in the POSIX <span class='texttt'>&lt;netinet/in.h&gt;</span> header. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='tcp.comparisons'><h3 ><a class='secnum' href='#tcp.comparisons' style='min-width:103pt'>21.19.1</a> <span class='texttt'>ip::tcp</span> comparisons <a class='abbr_ref' href='internet.tcp.comparisons'>[internet.tcp.comparisons]</a></h3><p ><code class='itemdecl'>
constexpr bool operator==(const tcp&amp; a, const tcp&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='tcp.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#tcp.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A boolean indicating whether two objects of class <span class='texttt'>tcp</span> are equal, such that the expression <span class='texttt'>tcp::v4() == tcp::v4()</span> is <span class='texttt'>true</span>, the expression <span class='texttt'>tcp::v6() == tcp::v6()</span> is <span class='texttt'>true</span>, and the expression <span class='texttt'>tcp::v4() == tcp::v6()</span> is <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool operator!=(const tcp&amp; a, const tcp&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='tcp.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#tcp.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='udp'></a></span></p></div></div><div id='udp'><h2 ><a class='secnum' href='#udp' style='min-width:88pt'>21.20</a> Class <span class='texttt'>ip::udp</span> <a class='abbr_ref' href='internet.udp'>[internet.udp]</a></h2><div class='para' id='udp-1'><div class='marginalizedparent'><a class='marginalized' href='#udp-1'>1</a></div><p >The class <span class='texttt'>udp</span> encapsulates the types and flags necessary for UDP sockets.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class udp
  {
  public:
    <span class='comment'>// types:
</span>    using endpoint = basic_endpoint&lt;udp&gt;;
    using resolver = basic_resolver&lt;udp&gt;;
    using socket = basic_datagram_socket&lt;udp&gt;;

    <span class='comment'>// static members:
</span>    static constexpr udp v4() noexcept;
    static constexpr udp v6() noexcept;

    udp() = delete;
  };

  <span class='comment'>// <a href='internet.udp.comparisons'>[internet.udp.comparisons]</a>, udp comparisons:
</span>  constexpr bool operator==(const udp&amp; a, const udp&amp; b) noexcept;
  constexpr bool operator!=(const udp&amp; a, const udp&amp; b) noexcept;

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='udp-2'><div class='marginalizedparent'><a class='marginalized' href='#udp-2'>2</a></div><p >The <span class='texttt'>udp</span> class meets the requirements for an <span class='texttt'>InternetProtocol</span> (<a href='internet.reqmts.protocol'>[internet.reqmts.protocol]</a>).</p><p ><span class='indexextensible'>udp</span></p></div><div class='para' id='udp-3'><div class='marginalizedparent'><a class='marginalized' href='#udp-3'>3</a></div><p >Extensible implementations provide the following member functions:</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {

  class udp
  {
  public:
    constexpr int family() const noexcept;
    constexpr int type() const noexcept;
    constexpr int protocol() const noexcept;
    <i>// remainder unchanged</i>
  };

} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='udp-4'><div class='marginalizedparent'><a class='marginalized' href='#udp-4'>4</a></div><p >The return values for these member functions are listed in Table <a href='#tab:internet.udp.requirements'>[tab:internet.udp.requirements]</a>.</p><div class='numberedTable' id='tab:internet.udp.requirements'>Table <a href='#tab:internet.udp.requirements'>39</a> — Behavior of extensible <span class='texttt'>ip::udp</span> implementations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>value</b></td><td colspan='1' class='center'><b>family()</b></td><td colspan='1' class='center'><b>type()</b></td><td colspan='1' class='center'><b>protocol()</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>udp::v4()</span>  </td><td class='left'>
<span class='texttt'>AF_INET</span>  </td><td class='left'>
<span class='texttt'>SOCK_DGRAM</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_UDP</span>  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>udp::v6()</span>  </td><td class='left'>
<span class='texttt'>AF_INET6</span>  </td><td class='left'>
<span class='texttt'>SOCK_DGRAM</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_UDP</span>  </td></tr></table></div></div><div class='para' id='udp-5'><div class='marginalizedparent'><a class='marginalized' href='#udp-5'>5</a></div><p >[&nbsp;<i>Note:</i> The constants <span class='texttt'>AF_INET</span>, <span class='texttt'>AF_INET6</span> and <span class='texttt'>SOCK_DGRAM</span> are defined in the POSIX <span class='texttt'>&lt;sys/socket.h&gt;</span> header. The constant <span class='texttt'>IPPROTO_UDP</span> is defined in the POSIX <span class='texttt'>&lt;netinet/in.h&gt;</span> header. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='udp.comparisons'><h3 ><a class='secnum' href='#udp.comparisons' style='min-width:103pt'>21.20.1</a> <span class='texttt'>ip::udp</span> comparisons <a class='abbr_ref' href='internet.udp.comparisons'>[internet.udp.comparisons]</a></h3><p ><code class='itemdecl'>
constexpr bool operator==(const udp&amp; a, const udp&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='udp.comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#udp.comparisons-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A boolean indicating whether two objects of class <span class='texttt'>udp</span> are equal, such that the expression <span class='texttt'>udp::v4() == udp::v4()</span> is <span class='texttt'>true</span>, the expression <span class='texttt'>udp::v6() == udp::v6()</span> is <span class='texttt'>true</span>, and the expression <span class='texttt'>udp::v4() == udp::v6()</span> is <span class='texttt'>false</span>.
</p></div></div><p ><code class='itemdecl'>
constexpr bool operator!=(const udp&amp; a, const udp&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='udp.comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#udp.comparisons-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div></div></div><div id='socket.opt'><h2 ><a class='secnum' href='#socket.opt' style='min-width:88pt'>21.21</a> Internet socket options <a class='abbr_ref' href='internet.socket.opt'>[internet.socket.opt]</a></h2><div class='para' id='socket.opt-1'><div class='marginalizedparent'><a class='marginalized' href='#socket.opt-1'>1</a></div><p >In Table <a href='#tab:internet.socket.opt.requirements'>[tab:internet.socket.opt.requirements]</a>, let <i>C</i> denote a socket option class; let <i>L</i> identify the POSIX macro to be passed as the <span class='texttt'>level</span> argument to POSIX <span class='texttt'>setsockopt</span> and getsockopt; let <i>N</i> identify the POSIX macro to be passed as the <span class='texttt'>option_name</span> argument to POSIX <span class='texttt'>setsockopt</span> and <span class='texttt'>getsockopt</span>; let <i>T</i> identify the type of the value whose address will be passed as the <span class='texttt'>option_value</span> argument to POSIX <span class='texttt'>setsockopt</span> and <span class='texttt'>getsockopt</span>;
let <span class='texttt'>p</span> denote a (possibly const) value of a type meeting the protocol (<a href='socket.reqmts.protocol'>[socket.reqmts.protocol]</a>) requirements,
as passed to the socket option's <span class='texttt'>level</span> and <span class='texttt'>name</span> member functions;
and let <span class='texttt'>F</span> be the value of <span class='texttt'>p.family()</span>.</p><div class='numberedTable' id='tab:internet.socket.opt.requirements'>Table <a href='#tab:internet.socket.opt.requirements'>40</a> — Internet socket options<br><table ><tr class='rowsep'><td colspan='1' class='center'><b><i>C</i></b></td><td colspan='1' class='center'><b><i>L</i></b></td><td colspan='1' class='center'><b><i>N</i></b></td><td colspan='1' class='center'><b><i>T</i></b></td><td colspan='1' class='center'><b>Requirements,</b></td></tr><tr ><td class='left'>
  </td><td class='left'>
  </td><td class='left'>
  </td><td class='left'>
  </td><td colspan='1' class='center'><b>definition or notes</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>ip::tcp::</span><br/>
<span class='texttt'>no_delay</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_TCP</span>  </td><td class='left'>
<span class='texttt'>TCP_NODELAY</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether a TCP socket will avoid coalescing of small segments. [&nbsp;<i>Note:</i> That is, setting this option disables the Nagle algorithm. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::v6_only</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span>  </td><td class='left'>
<span class='texttt'>IPV6_V6ONLY</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether a socket created for an IPv6 protocol is restricted to IPv6 communications only. Implementations are not required to support setting the <span class='texttt'>v6_only</span> option to <span class='texttt'>false</span>, and the initial value of the <span class='texttt'>v6_only</span> option for a socket is <span class='indexparent'><a class='index' id='initial_value_of_the_v6_only_option_for_a_socket'></a></span>implementation-defined. [&nbsp;<i>Note:</i> As not all operating systems support dual stack IP networking. Some operating systems that do provide dual stack support offer a configuration option to disable it or to set the initial value of the <span class='texttt'>v6_only</span> socket option. <i>&nbsp;—&nbsp;end note</i>&nbsp;]  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::unicast::</span>
<span class='texttt'>hops</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_UNICAST_HOPS</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_TTL</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the default number of hops (also known as time-to-live or TTL) on outbound datagrams. The constructor and assignment operator for the <span class='texttt'>ip::unicast::hops</span> class throw <span class='texttt'>out_of_range</span> if the <span class='texttt'>int</span> argument is not in the range <span class='texttt'>[0, 255]</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>join_group</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_JOIN_GROUP</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_ADD_MEMBERSHIP</span>  </td><td class='left'>
<span class='texttt'>ipv6_mreq</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>ip_mreq</span>  </td><td class='left'>
Satisfies the <span class='texttt'>MulticastGroupSocketOption</span> (<a href='internet.reqmts.opt.mcast'>[internet.reqmts.opt.mcast]</a>) type requirements. Requests that the socket join the specified multicast group.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>leave_group</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_LEAVE_GROUP</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_DROP_MEMBERSHIP</span>  </td><td class='left'>
<span class='texttt'>ipv6_mreq</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>ip_mreq</span>  </td><td class='left'>
Satisfies the <span class='texttt'>MulticastGroupSocketOption</span> (<a href='internet.reqmts.opt.mcast'>[internet.reqmts.opt.mcast]</a>) type requirements. Requests that the socket leave the specified multicast group.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>outbound_interface</span><br/> (<a href='internet.multicast.outbound'>[internet.multicast.outbound]</a>)  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_MULTICAST_IF</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_IF</span>  </td><td class='left'>
<span class='texttt'>unsigned int</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>in_addr</span>  </td><td class='left'>
 Specifies the network interface to use for outgoing multicast datagrams.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>hops</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_MULTICAST_HOPS</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_TTL</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>IntegerSocketOption</span> (<a href='socket.reqmts.opt.int'>[socket.reqmts.opt.int]</a>) type requirements. Specifies the default number of hops (also known as time-to-live or TTL) on outbound datagrams. The constructor and assignment operator for the <span class='texttt'>ip::multicast::hops</span> class throw <span class='texttt'>out_of_range</span> if the <span class='texttt'>int</span> argument is not in the range <span class='texttt'>[0, 255]</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>ip::multicast::</span>
<span class='texttt'>enable_loopback</span>  </td><td class='left'>
<span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>  </td><td class='left'>
<span class='texttt'>IPV6_MULTICAST_LOOP</span> if <span class='texttt'>F == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_LOOP</span>  </td><td class='left'>
<span class='texttt'>int</span>  </td><td class='left'>
Satisfies the <span class='texttt'>BooleanSocketOption</span> (<a href='socket.reqmts.opt.bool'>[socket.reqmts.opt.bool]</a>) type requirements. Determines whether multicast datagrams are delivered back to the local application.  </td></tr></table></div><p ><span class='indexparent'><a class='index' id='outbound_interface'></a></span></p></div><div id='multicast.outbound'><h3 ><a class='secnum' href='#multicast.outbound' style='min-width:103pt'>21.21.1</a> Class <span class='texttt'>ip::multicast::outbound_interface</span> <a class='abbr_ref' href='internet.multicast.outbound'>[internet.multicast.outbound]</a></h3><div class='para' id='multicast.outbound-1'><div class='marginalizedparent'><a class='marginalized' href='#multicast.outbound-1'>1</a></div><p >The <span class='texttt'>outbound_interface</span> class represents a socket option that specifies the network interface to use for outgoing multicast datagrams.</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {
namespace multicast {

  class outbound_interface
  {
  public:
    <span class='comment'>// constructors:
</span>    explicit outbound_interface(const address_v4&amp; network_interface) noexcept;
    explicit outbound_interface(unsigned int network_interface) noexcept;
  };

} <span class='comment'>// namespace multicast
</span>} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre></div><div class='para' id='multicast.outbound-2'><div class='marginalizedparent'><a class='marginalized' href='#multicast.outbound-2'>2</a></div><p ><span class='texttt'>outbound_interface</span> satisfies the requirements for <span class='texttt'>Destructible</span> (<span class='CppXref'>destructible</span>), <span class='texttt'>CopyConstructible</span> (<span class='CppXref'>copyconstructible</span>), <span class='texttt'>CopyAssignable</span> (<span class='CppXref'>copyassignable</span>), and <span class='texttt'>SettableSocketOption</span> (<a href='socket.reqmts.settablesocketoption'>[socket.reqmts.settablesocketoption]</a>).</p><p ><span class='indexextensible'>outbound_interface</span></p></div><div class='para' id='multicast.outbound-3'><div class='marginalizedparent'><a class='marginalized' href='#multicast.outbound-3'>3</a></div><p >Extensible implementations provide the following member functions:</p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {
namespace ip {
namespace multicast {

  class outbound_interface
  {
  public:
    template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
    template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
    template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
    template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
    <span class='comment'>// <i>remainder unchanged</i>
</span>  private:
      in_addr v4_value_; <span class='comment'>// <i>exposition only</i>
</span>      unsigned int v6_value_; <span class='comment'>// <i>exposition only</i>
</span>  };

} <span class='comment'>// namespace multicast
</span>} <span class='comment'>// namespace ip
</span>} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><p ><code class='itemdecl'>
explicit outbound_interface(const address_v4&amp; network_interface) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='multicast.outbound-4'><div class='marginalizedparent'><a class='marginalized' href='#multicast.outbound-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> For extensible implementations, <span class='texttt'>v4_value_</span> is initialized to correspond to the IPv4 address <span class='texttt'>network_interface</span>, and <span class='texttt'>v6_value_</span> is zero-initialized.
</p></div></div><p ><code class='itemdecl'>
explicit outbound_interface(unsigned int network_interface) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='multicast.outbound-5'><div class='marginalizedparent'><a class='marginalized' href='#multicast.outbound-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> For extensible implementations, <span class='texttt'>v6_value_</span> is initialized to <span class='texttt'>network_interface</span>, and <span class='texttt'>v4_value_</span> is zero-initialized.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int level(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='multicast.outbound-6'><div class='marginalizedparent'><a class='marginalized' href='#multicast.outbound-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>IPPROTO_IPV6</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>IPPROTO_IP</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; int name(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='multicast.outbound-7'><div class='marginalizedparent'><a class='marginalized' href='#multicast.outbound-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>IPV6_MULTICAST_IF</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>IP_MULTICAST_IF</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; const void* data(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='multicast.outbound-8'><div class='marginalizedparent'><a class='marginalized' href='#multicast.outbound-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>addressof(v6_value_)</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>addressof(v4_value_)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class Protocol&gt; size_t size(const Protocol&amp; p) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='multicast.outbound-9'><div class='marginalizedparent'><a class='marginalized' href='#multicast.outbound-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>sizeof(v6_value_)</span> if <span class='texttt'>p.family() == AF_INET6</span>, otherwise <span class='texttt'>sizeof(v4_value_)</span>.
</p></div></div></div></div></div></div></body></html>