<!DOCTYPE html><html lang='en'><head><title>[async.use.future.members]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Asynchronous model <a class='abbr_ref' href='./#async'>[async]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>13.26</a> Class template <span class='texttt'>use_future_t</span> <a class='abbr_ref' href='async.use.future#members'>[async.use.future]</a></h2><div id='async.use.future.members'><h3 ><a class='secnum' style='min-width:103pt'>13.26.2</a> <span class='texttt'>use_future_t</span> members <a class='abbr_ref'>[async.use.future.members]</a></h3><p ><span class='indexparent'><a class='index' id='rebind,use_future_t'></a></span><span class='indexparent'><a class='index' id='use_future_t,rebind'></a></span><code class='itemdecl'>
template&lt;class OtherProtoAllocator&gt; use_future_t&lt;OtherProtoAllocator&gt;
  rebind(const OtherProtoAllocator&amp; a) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>use_future_t</span> object where <span class='texttt'>get_allocator() == a</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_allocator,use_future_t'></a></span><span class='indexparent'><a class='index' id='use_future_t,get_allocator'></a></span><code class='itemdecl'>
allocator_type get_allocator() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The associated allocator object.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator(),use_future_t'></a></span><span class='indexparent'><a class='index' id='use_future_t,operator()'></a></span><code class='itemdecl'>
template &lt;class F&gt; <i><span class='texttt'>unspecified</span></i> operator()(F&amp;&amp; f) const;
</code></p><div class='itemdescr'></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><p >Let <span class='texttt'>T</span> be a completion token type. Let <span class='texttt'>H</span> be a completion handler type and let <span class='texttt'>h</span> be an object of type <span class='texttt'>H</span>. Let <span class='texttt'>FD</span> be the type <span class='texttt'>decay_t&lt;F&gt;</span> and let <span class='texttt'>fd</span> be an lvalue of type <span class='texttt'>FD</span> constructed with <span class='texttt'>std::forward&lt;F&gt;(f)</span>. Let <span class='texttt'>R(Args...)</span> be the completion signature of an asynchronous operation using <span class='texttt'>H</span> and let <i>N</i> be <span class='texttt'>sizeof...(Args)</span>. Let <i>i</i> be in the range <span class='texttt'>[0, <i>N</i>)</span> and let <span class='texttt'>A<span class='math'><sub ><span class='mathalpha'>i</span></sub></span></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='text'>th</span></sup></span> type in <span class='texttt'>Args</span>. Let <span class='texttt'>a<span class='math'><sub ><span class='mathalpha'>i</span></sub></span></span> be the argument associated with <span class='texttt'>A<span class='math'><sub ><span class='mathalpha'>i</span></sub></span></span>.</p></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> A completion token <span class='texttt'>t</span> of type <span class='texttt'>T</span>.</p></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> The return type <span class='texttt'>T</span> satisfies the <span class='texttt'>Destructible</span> (<span class='CppXref'>destructible</span>) and <span class='texttt'>MoveConstructible</span> (<span class='CppXref'>moveconstructible</span>) requirements.</p></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><p >The object <span class='texttt'>h</span> of type <span class='texttt'>H</span> is an asynchronous provider with an associated shared state (<span class='CppXref'>futures.state</span>). The effect of <span class='texttt'>h(a<span class='math'><sub >0</sub></span>, ..., a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>)</span> is to atomically store the result of <span class='texttt'><i>INVOKE</i>(fd, forward&lt;A<span class='math'><sub >0</sub></span>&gt;(a<span class='math'><sub >0</sub></span>), ..., forward&lt;A<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>&gt;(a<span class='math'><sub ><span class='mathalpha'>N</span>-1</sub></span>))</span> (<span class='CppXref'>func.require</span>) in the shared state and make the shared state ready. If <span class='texttt'>fd</span> exits via an exception then that exception is atomically stored in the shared state and the shared state is made ready.</p></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><p >The implementation provides a partial specialization <span class='texttt'>template &lt;class Result, class... Args&gt; async_result&lt;T, Result(Args...)&gt;</span> such that:
</p><ul class='itemize'><li id='7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.1'>(7.1)</a></div><p >the nested type <span class='texttt'>completion_handler_type</span> is a type <span class='texttt'>H</span>;
</p></li><li id='7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.2'>(7.2)</a></div><p >the nested type <span class='texttt'>return_type</span> is <span class='texttt'>future&lt;result_of_t&lt;FD(decay_t&lt;Args&gt;...)&gt;&gt;</span>; and
</p></li><li id='7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.3'>(7.3)</a></div><p >when an object <span class='texttt'>r1</span> of type <span class='texttt'>async_result&lt;T, Result(Args...)&gt;</span> is constructed from <span class='texttt'>h</span>, the expression <span class='texttt'>r1.get()</span> returns a future with the same shared state as <span class='texttt'>h</span>.
</p></li></ul></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='itemdescr'><p >For any executor type <span class='texttt'>E</span>, the associated object for the associator <span class='texttt'>associated_executor&lt;H, E&gt;</span> is an executor where, for function objects executed using the executor's <span class='texttt'>dispatch()</span>, <span class='texttt'>post()</span> or <span class='texttt'>defer()</span> functions, any exception thrown is caught by a function object and stored in the associated shared state.
</p></div></div></div></div></body></html>