<!DOCTYPE html><html lang='en'><head><title>[buffer.reqmts.dynamicbuffer]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>16</a> Buffers <a class='abbr_ref' href='./#buffer'>[buffer]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>16.2</a> Requirements <a class='abbr_ref' href='buffer.reqmts#dynamicbuffer'>[buffer.reqmts]</a></h2><div id='buffer.reqmts.dynamicbuffer'><h3 ><a class='secnum' style='min-width:103pt'>16.2.3</a> Dynamic buffer requirements <a class='abbr_ref'>[buffer.reqmts.dynamicbuffer]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A <a class='hidden_link' href='#def:dynamic_buffer' id='def:dynamic_buffer'><i>dynamic buffer</i></a> encapsulates memory storage that may be automatically resized as required, where the memory is divided into two regions: readable bytes followed by writable bytes. These memory regions are internal to the dynamic buffer, but direct access to the elements is provided to permit them to be efficiently used with I/O operations. [&nbsp;<i>Note:</i> Such as the <span class='texttt'>send</span> or <span class='texttt'>receive</span> operations of a socket. The readable bytes would be used as the constant buffer sequence for <span class='texttt'>send</span>, and the writable bytes used as the mutable buffer sequence for <span class='texttt'>receive</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Data written to the writable bytes of a dynamic buffer object is appended to the readable bytes of the same object.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A type <span class='texttt'>X</span> meets the <span class='texttt'>DynamicBuffer</span> requirements if it satisfies the requirements of <span class='texttt'>Destructible</span> (C++Std &sect;<a href='../n4140/destructible'>[destructible]</a>) and <span class='texttt'>MoveConstructible</span> (C++Std &sect;<a href='../n4140/moveconstructible'>[moveconstructible]</a>), as well as the additional requirements listed in Table <a href='#tab:buffer.reqmts.dynamicbuffer.requirements'>[tab:buffer.reqmts.dynamicbuffer.requirements]</a>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >In Table <a href='#tab:buffer.reqmts.dynamicbuffer.requirements'>[tab:buffer.reqmts.dynamicbuffer.requirements]</a>,
<span class='texttt'>x</span> denotes a value of type <span class='texttt'>X</span>,
<span class='texttt'>x1</span> denotes a value of type <span class='texttt'>X</span> or <span class='texttt'>const X</span>,
and <span class='texttt'>n</span> denotes a value of type <span class='texttt'>size_t</span> or <span class='texttt'>const size_t</span>.</p><p ><span class='indexparent'><a class='index' id='requirements,DynamicBuffer'></a></span>
 
 
 </p><div class='numberedTable' id='tab:buffer.reqmts.dynamicbuffer.requirements'>Table <a href='#tab:buffer.reqmts.dynamicbuffer.requirements'>14</a> — DynamicBuffer requirements<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>expression</b></td><td colspan='1' class='center'><b>type</b></td><td colspan='1' class='center'><b>assertion/note pre/post-conditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>X::const_buffers_type</span>  </td><td class='left'>
type meeting ConstBufferSequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) requirements.  </td><td class='left'>
 This type represents the memory associated with the readable bytes.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>X::mutable_buffers_type</span>  </td><td class='left'>
type meeting MutableBufferSequence (<a href='buffer.reqmts.constbuffersequence'>[buffer.reqmts.constbuffersequence]</a>) requirements.  </td><td class='left'>
 This type represents the memory associated with the writable bytes.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.size()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
 Returns the number of readable bytes.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.max_size()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns the maximum number of bytes, both readable and writable, that can be held by <span class='texttt'>x1</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.capacity()</span>  </td><td class='left'>
<span class='texttt'>size_t</span>  </td><td class='left'>
Returns the maximum number of bytes, both readable and writable, that can be held by <span class='texttt'>x1</span> without requiring reallocation.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x1.data()</span>  </td><td class='left'>
<span class='texttt'>X::const_buffers_type</span>  </td><td class='left'>
Returns a constant buffer sequence <span class='texttt'>u</span> that represents the readable bytes, and where <span class='texttt'>buffer_size(u) == size()</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.prepare(n)</span>  </td><td class='left'>
<span class='texttt'>X::mutable_buffers_type</span>  </td><td class='left'>
Returns a mutable buffer sequence <span class='texttt'>u</span> representing the writable bytes, and where <span class='texttt'>buffer_size(u) == n</span>. The dynamic buffer reallocates memory as required. All constant or mutable buffer sequences previously obtained using <span class='texttt'>data()</span> or <span class='texttt'>prepare()</span> are invalidated.<br/> <i>Throws:</i> <span class='texttt'>length_error</span> if <span class='texttt'>size() + n</span> exceeds <span class='texttt'>max_size()</span>.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.commit(n)</span>  </td><td class='left'>
  </td><td class='left'>
Appends <span class='texttt'>n</span> bytes from the start of the writable bytes to the end of the readable bytes. The remainder of the writable bytes are discarded. If <span class='texttt'>n</span> is greater than the number of writable bytes, all writable bytes are appended to the readable bytes. All constant or mutable buffer sequences previously obtained using <span class='texttt'>data()</span> or <span class='texttt'>prepare()</span> are invalidated.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>x.consume(n)</span>  </td><td class='left'>
  </td><td class='left'>
Removes <span class='texttt'>n</span> bytes from beginning of the readable bytes. If <span class='texttt'>n</span> is greater than the number of readable bytes, all readable bytes are removed. All constant or mutable buffer sequences previously obtained using <span class='texttt'>data()</span> or <span class='texttt'>prepare()</span> are invalidated.  </td></tr></table></div></div></div></div></body></html>