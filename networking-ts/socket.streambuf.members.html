<!DOCTYPE html><html lang='en'><head><title>[socket.streambuf.members]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>19</a> Socket iostreams <a class='abbr_ref' href='./#socket.iostreams'>[socket.iostreams]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>19.1</a> Class template <span class='texttt'>basic_socket_streambuf</span> <a class='abbr_ref' href='socket.streambuf#members'>[socket.streambuf]</a></h2><div id='socket.streambuf.members'><h3 ><a class='secnum' style='min-width:103pt'>19.1.2</a> <span class='texttt'>basic_socket_streambuf</span> members <a class='abbr_ref'>[socket.streambuf.members]</a></h3><p ><code class='itemdecl'>
basic_socket_streambuf* connect(const endpoint_type&amp; e);
</code></p><div class='itemdescr'></div><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the <span class='texttt'>basic_socket_streambuf</span> as required, closes and re-opens the socket by performing <span class='texttt'>socket_.close(ec_)</span> and <span class='texttt'>socket_.open(e.protocol(), ec_)</span>, then attempts to establish a connection as if by POSIX <span class='texttt'>connect(socket_.native_handle(), static_cast&lt;sockaddr*&gt;(e.data()), e.size())</span>. <span class='texttt'>ec_</span> is set to reflect the error code produced by the operation. If the operation does not complete before the absolute timeout specified by <span class='texttt'>expiry_</span>, the socket is closed and <span class='texttt'>ec_</span> is set to <span class='texttt'>errc::timed_out</span>.</p></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> if <span class='texttt'>!ec_</span>, <span class='texttt'>this</span>; otherwise, a null pointer.
</p></div></div><p ><code class='itemdecl'>
template&lt;class... Args&gt;
  basic_socket_streambuf* connect(Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the <span class='texttt'>basic_socket_streambuf</span> as required and closes the socket as if by calling <span class='texttt'>socket_.close(ec_)</span>. Obtains an endpoint sequence <span class='texttt'>endpoints</span> by performing <span class='texttt'>protocol_type::resolver(ctx).resolve(forward&lt;Args&gt;(args)...)</span>, where <span class='texttt'>ctx</span> is an unspecified object of class <span class='texttt'>io_context</span>. For each endpoint <span class='texttt'>e</span> in the sequence, closes and re-opens the socket by performing <span class='texttt'>socket_.close(ec_)</span> and <span class='texttt'>socket_.open(e.protocol(), ec_)</span>, then attempts to establish a connection as if by POSIX <span class='texttt'>connect(socket_.native_handle(), static_cast&lt;sockaddr*&gt;(e.data()), e.size())</span>. <span class='texttt'>ec_</span> is set to reflect the error code produced by the operation. If the operation does not complete before the absolute timeout specified by <span class='texttt'>expiry_</span>, the socket is closed and <span class='texttt'>ec_</span> is set to <span class='texttt'>errc::timed_out</span>.</p></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> if <span class='texttt'>!ec_</span>, <span class='texttt'>this</span>; otherwise, a null pointer.</p></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution unless <span class='texttt'>Protocol</span> meets the requirements for an internet protocol (<a href='internet.reqmts.protocol'>[internet.reqmts.protocol]</a>).
</p></div></div><p ><code class='itemdecl'>
basic_socket_streambuf* close();
</code></p><div class='itemdescr'></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> If a put area exists, calls <span class='texttt'>overflow(traits_type::eof())</span> to flush characters. Regardless of whether the preceding call fails or throws an exception, the function closes the socket as if by <span class='texttt'>basic_socket&lt;protocol_type&gt;::close(ec_)</span>. If any of the calls made by the function fail, <span class='texttt'>close</span> fails by returning a null pointer. If one of these calls throws an exception, the exception is caught and rethrown after closing the socket.</p></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>this</span> on success, a null pointer otherwise.</p></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_open() == false</span>.
</p></div></div><p ><code class='itemdecl'>
basic_socket&lt;protocol_type&gt;&amp; socket();
</code></p><div class='itemdescr'></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>socket_</span>.
</p></div></div><p ><code class='itemdecl'>
error_code error() const;
</code></p><div class='itemdescr'></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>ec_</span>.
</p></div></div><p ><code class='itemdecl'>
time_point expiry() const;
</code></p><div class='itemdescr'></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>expiry_</span>.
</p></div></div><p ><code class='itemdecl'>
void expires_at(const time_point&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>expiry_ == t</span>.
</p></div></div><p ><code class='itemdecl'>
void expires_after(const duration&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>expires_at(clock_type::now() + d)</span>.
</p></div></div></div></div></body></html>