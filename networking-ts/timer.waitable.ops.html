<!DOCTYPE html><html lang='en'><head><title>[timer.waitable.ops]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>15</a> Timers <a class='abbr_ref' href='./#timer'>[timer]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>15.4</a> Class template <span class='texttt'>basic_waitable_timer</span> <a class='abbr_ref' href='timer.waitable#ops'>[timer.waitable]</a></h2><div id='timer.waitable.ops'><h3 ><a class='secnum' style='min-width:103pt'>15.4.4</a> <span class='texttt'>basic_waitable_timer</span> operations <a class='abbr_ref'>[timer.waitable.ops]</a></h3><p ><span class='indexparent'><a class='index' id='get_executor,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,get_executor'></a></span><code class='itemdecl'>
executor_type get_executor() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The associated executor.
</p></div></div><p ><span class='indexparent'><a class='index' id='cancel,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,cancel'></a></span><code class='itemdecl'>
size_t cancel();
</code></p><div class='itemdescr'></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Causes any outstanding asynchronous wait operations to complete. Completion handlers for canceled operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of operations that were canceled.</p></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> Does not block (<span class='CppXref'>defns.block</span>) the calling thread pending completion of the canceled operations.
</p></div></div><p ><span class='indexparent'><a class='index' id='cancel_one,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,cancel_one'></a></span><code class='itemdecl'>
size_t cancel_one();
</code></p><div class='itemdescr'></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Causes the outstanding asynchronous wait operation that was initiated first, if any, to complete as soon as possible. The completion handler for the canceled operation is passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>1</span> if an operation was canceled, otherwise <span class='texttt'>0</span>.</p></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i> Does not block (<span class='CppXref'>defns.block</span>) the calling thread pending completion of the canceled operation.
</p></div></div><p ><span class='indexparent'><a class='index' id='expiry,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,expiry'></a></span><code class='itemdecl'>
time_point expiry() const;
</code></p><div class='itemdescr'></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> The expiry time associated with the timer, as previously set using <span class='texttt'>expires_at()</span> or <span class='texttt'>expires_after()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='expires_at,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,expires_at'></a></span><code class='itemdecl'>
size_t expires_at(const time_point&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Cancels outstanding asynchronous wait operations, as if by calling <span class='texttt'>cancel()</span>. Sets the expiry time associated with the timer.</p></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of operations that were canceled.</p></div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>expiry() == t</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='expires_after,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,expires_after'></a></span><code class='itemdecl'>
size_t expires_after(const duration&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>expires_at(clock_type::now() + d)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='wait,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,wait'></a></span><code class='itemdecl'>
void wait();
void wait(error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Establishes the postcondition as if by repeatedly blocking the calling thread (<span class='CppXref'>defns.block</span>) for the relative time produced by <span class='texttt'>WaitTraits::to_wait_duration(expiry())</span>.</p></div></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>ec || expiry() &lt;= clock_type::now()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='asynchronous_wait_operation'></a></span><span class='indexparent'><a class='index' id='async_wait,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,async_wait'></a></span><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <span class='DEDUCED'></span> async_wait(CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><div class='itemdescr'><p ><span class='completionsig'></span> <span class='texttt'>void(error_code ec)</span>.</p></div></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous wait operation to repeatedly wait for the relative time produced by <span class='texttt'>WaitTraits::to_wait_duration(e)</span>, where <span class='texttt'>e</span> is a value of type <span class='texttt'>time_point</span> such that <span class='texttt'>e &lt;= expiry()</span>. The completion handler is submitted for execution only when the condition <span class='texttt'>ec || expiry() &lt;= clock_type::now()</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> To implement <span class='texttt'>async_wait</span>, an <span class='texttt'>io_context</span> object <span class='texttt'>ctx</span> could maintain a priority queue for each specialization of <span class='texttt'>basic_waitable_timer&lt;Clock, WaitTraits&gt;</span> for which a timer object was initialized with <span class='texttt'>ctx</span>. Only the time point <span class='texttt'>e</span> of the earliest outstanding expiry need be passed to <span class='texttt'>WaitTraits::to_wait_duration(e)</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
</p></div></div></div></div></body></html>