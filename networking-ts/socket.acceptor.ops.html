<!DOCTYPE html><html lang='en'><head><title>[socket.acceptor.ops]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>18</a> Sockets <a class='abbr_ref' href='./#socket'>[socket]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>18.9</a> Class template <span class='texttt'>basic_socket_acceptor</span> <a class='abbr_ref' href='socket.acceptor#ops'>[socket.acceptor]</a></h2><div id='socket.acceptor.ops'><h3 ><a class='secnum' style='min-width:103pt'>18.9.4</a> <span class='texttt'>basic_socket_acceptor</span> operations <a class='abbr_ref'>[socket.acceptor.ops]</a></h3><p ><code class='itemdecl'>
executor_type get_executor() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The associated executor.
</p></div></div><p ><code class='itemdecl'>
native_handle_type native_handle();
</code></p><div class='itemdescr'></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The native representation of this acceptor.
</p></div></div><p ><code class='itemdecl'>
void open(const protocol_type&amp; protocol);
void open(const protocol_type&amp; protocol, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Establishes the postcondition, as if by POSIX:
</p><pre class='codeblock'>
socket(protocol.family(), protocol.type(), protocol.protocol());
</pre></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><p ><span class='texttt'>is_open() == true</span>.
</p></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><p ><span class='texttt'>non_blocking() == false</span>.
</p></li><li id='4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.3'>(4.3)</a></div><p ><span class='texttt'>enable_connection_aborted() == false</span>.
</p></li><li id='4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.4'>(4.4)</a></div><p ><span class='texttt'>protocol_ == protocol</span>.
</p></li></ul></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.1'>(5.1)</a></div><p ><span class='texttt'>socket_errc::already_open</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>true</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
void assign(const protocol_type&amp; protocol,
            const native_handle_type&amp; native_acceptor);
void assign(const protocol_type&amp; protocol,
            const native_handle_type&amp; native_acceptor, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>native_acceptor</span> is a native handle to an open acceptor.</p></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns the native acceptor handle to this acceptor object.</p></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.1'>(8.1)</a></div><p ><span class='texttt'>is_open() == true</span>.
</p></li><li id='8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.2'>(8.2)</a></div><p ><span class='texttt'>non_blocking() == false</span>.
</p></li><li id='8.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.3'>(8.3)</a></div><p ><span class='texttt'>enable_connection_aborted() == false</span>.
</p></li><li id='8.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#8.4'>(8.4)</a></div><p ><span class='texttt'>protocol_ == protocol</span>.
</p></li></ul></div></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.1'>(9.1)</a></div><p ><span class='texttt'>socket_errc::already_open</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>true</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
native_handle_type release();
native_handle_type release(error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>is_open() == true</span>.</p></div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> Cancels all outstanding asynchronous operations associated with this acceptor.
Completion handlers for canceled asynchronous operations are passed an error code <span class='texttt'>ec</span>
such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> The native representation of this acceptor.</p></div></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_open() == false</span>.</p></div></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='itemdescr'><p ><i>Remarks:</i> Since the native acceptor is not closed prior to returning it,
the caller is responsible for closing it.
</p></div></div><p ><code class='itemdecl'>
bool is_open() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>bool</span> indicating whether this acceptor was opened by a previous call to <span class='texttt'>open</span> or <span class='texttt'>assign</span>.
</p></div></div><p ><code class='itemdecl'>
void close();
void close(error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>is_open()</span> is <span class='texttt'>true</span>, cancels all outstanding asynchronous operations associated with this acceptor, and establishes the postcondition as if by POSIX <span class='texttt'>close(native_handle())</span>. Completion handlers for canceled asynchronous operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>is_open() == false</span>.
</p></div></div><p ><code class='itemdecl'>
void cancel();
void cancel(error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><div class='itemdescr'><p ><i>Effects:</i> Cancels all outstanding asynchronous operations associated with this acceptor. Completion handlers for canceled asynchronous operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='19'><div class='marginalizedparent'><a class='marginalized' href='#19'>19</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='19.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#19.1'>(19.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li><li id='19.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#19.2'>(19.2)</a></div><p ><span class='texttt'>errc::operation_not_supported</span> — current conditions do not permit cancelation. The conditions under which cancelation of asynchronous operations is permitted are <span class='indexparent'><a class='index' id='conditions_under_which_cancelation_of_asynchronous_operations_is_permitted'></a></span>implementation-defined.
</p></li></ul></div></div><p ><code class='itemdecl'>
template&lt;class SettableSocketOption&gt;
  void set_option(const SettableSocketOption&amp; option);
template&lt;class SettableSocketOption&gt;
  void set_option(const SettableSocketOption&amp; option, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='20'><div class='marginalizedparent'><a class='marginalized' href='#20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets an option on this acceptor, as if by POSIX:
</p><pre class='codeblock'>
setsockopt(native_handle(), option.level(protocol_), option.name(protocol_),
           option.data(protocol_), option.size(protocol_));
</pre></div></div><p ><code class='itemdecl'>
template&lt;class GettableSocketOption&gt;
  void get_option(GettableSocketOption&amp; option);
template&lt;class GettableSocketOption&gt;
  void get_option(GettableSocketOption&amp; option, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='21'><div class='marginalizedparent'><a class='marginalized' href='#21'>21</a></div><div class='itemdescr'><p ><i>Effects:</i> Gets an option from this acceptor, as if by POSIX:
</p><pre class='codeblock'>
socklen_t option_len = option.size(protocol_);
int result = getsockopt(native_handle(), option.level(protocol_),
                        option.name(protocol_), option.data(protocol_),
                        &amp;option_len);
if (result == 0)
  option.resize(option_len);
</pre></div></div><p ><code class='itemdecl'>
template&lt;class IoControlCommand&gt;
  void io_control(IoControlCommand&amp; command);
template&lt;class IoControlCommand&gt;
  void io_control(IoControlCommand&amp; command, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='22'><div class='marginalizedparent'><a class='marginalized' href='#22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i> Executes an I/O control command on this acceptor, as if by POSIX:
</p><pre class='codeblock'>
ioctl(native_handle(), command.name(), command.data());
</pre></div></div><p ><code class='itemdecl'>
void non_blocking(bool mode);
void non_blocking(bool mode, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='23'><div class='marginalizedparent'><a class='marginalized' href='#23'>23</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets the non-blocking mode of this acceptor. The non-blocking mode determines whether subsequent synchronous socket operations (<a href='socket.reqmts.sync'>[socket.reqmts.sync]</a>) on <span class='texttt'>*this</span> block the calling thread.</p></div></div><div class='para' id='24'><div class='marginalizedparent'><a class='marginalized' href='#24'>24</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='24.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#24.1'>(24.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li></ul></div></div><div class='para' id='25'><div class='marginalizedparent'><a class='marginalized' href='#25'>25</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>non_blocking() == mode</span>.</p></div></div><div class='para' id='26'><div class='marginalizedparent'><a class='marginalized' href='#26'>26</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The non-blocking mode has no effect on the behavior of asynchronous operations. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><code class='itemdecl'>
bool non_blocking() const;
</code></p><div class='itemdescr'></div><div class='para' id='27'><div class='marginalizedparent'><a class='marginalized' href='#27'>27</a></div><div class='itemdescr'><p ><i>Returns:</i> The non-blocking mode of this acceptor.
</p></div></div><p ><code class='itemdecl'>
void native_non_blocking(bool mode);
void native_non_blocking(bool mode, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='28'><div class='marginalizedparent'><a class='marginalized' href='#28'>28</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets the non-blocking mode of the underlying native acceptor, as if by POSIX:
</p><pre class='codeblock'>
int flags = fcntl(native_handle(), F_GETFL, 0);
if (flags &gt;= 0){
  if (mode)
    flags |= O_NONBLOCK;
  else
    flags &amp;= ~O_NONBLOCK;
  fcntl(native_handle(), F_SETFL, flags);
}
</pre></div></div><div class='para' id='29'><div class='marginalizedparent'><a class='marginalized' href='#29'>29</a></div><div class='itemdescr'><p >The native non-blocking mode has no effect on the behavior of the synchronous or asynchronous operations specified in this clause.</p></div></div><div class='para' id='30'><div class='marginalizedparent'><a class='marginalized' href='#30'>30</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='30.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#30.1'>(30.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li><li id='30.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#30.2'>(30.2)</a></div><p ><span class='texttt'>errc::invalid_argument</span> — if <span class='texttt'>mode == false</span> and <span class='texttt'>non_blocking() == true</span>. [&nbsp;<i>Note:</i> As the combination does not make sense. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div></div><p ><code class='itemdecl'>
bool native_non_blocking() const;
</code></p><div class='itemdescr'></div><div class='para' id='31'><div class='marginalizedparent'><a class='marginalized' href='#31'>31</a></div><div class='itemdescr'><p ><i>Returns:</i> The non-blocking mode of the underlying native acceptor.</p></div></div><div class='para' id='32'><div class='marginalizedparent'><a class='marginalized' href='#32'>32</a></div><div class='itemdescr'><p ><i>Remarks:</i> Implementations are permitted and encouraged to cache the native non-blocking mode that was applied through a prior call to <span class='texttt'>native_non_blocking</span>. Implementations may return an incorrect value if a program sets the non-blocking mode directly on the acceptor, by calling an operating system-specific function on the result of <span class='texttt'>native_handle()</span>.
</p></div></div><p ><code class='itemdecl'>
void bind(const endpoint_type&amp; endpoint);
void bind(const endpoint_type&amp; endpoint, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='33'><div class='marginalizedparent'><a class='marginalized' href='#33'>33</a></div><div class='itemdescr'><p ><i>Effects:</i> Binds this acceptor to the specified local endpoint, as if by POSIX:
</p><pre class='codeblock'>
bind(native_handle(), endpoint.data(), endpoint.size());
</pre></div></div><p ><code class='itemdecl'>
void listen(int backlog = socket_base::max_listen_connections);
void listen(int backlog, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='34'><div class='marginalizedparent'><a class='marginalized' href='#34'>34</a></div><div class='itemdescr'><p ><i>Effects:</i> Marks this acceptor as ready to accept connections, as if by POSIX:
</p><pre class='codeblock'>
listen(native_handle(), backlog);
</pre></div></div><p ><code class='itemdecl'>
endpoint_type local_endpoint() const;
endpoint_type local_endpoint(error_code&amp; ec) const;
</code></p><div class='itemdescr'></div><div class='para' id='35'><div class='marginalizedparent'><a class='marginalized' href='#35'>35</a></div><div class='itemdescr'><p ><i>Effects:</i> Determines the locally-bound endpoint associated with this acceptor, as if by POSIX:
</p><pre class='codeblock'>
endpoint_type endpoint;
socklen_t endpoint_len = endpoint.capacity();
int result = getsockname(native_handle(), endpoint.data(), &amp;endpoint_len);
if (result == 0)
  endpoint.resize(endpoint_len);
</pre></div></div><div class='para' id='36'><div class='marginalizedparent'><a class='marginalized' href='#36'>36</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, <span class='texttt'>endpoint</span>. Otherwise <span class='texttt'>endpoint_type()</span>.
</p></div></div><p ><code class='itemdecl'>
void enable_connection_aborted(bool mode);
</code></p><div class='itemdescr'></div><div class='para' id='37'><div class='marginalizedparent'><a class='marginalized' href='#37'>37</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>mode</span> is true, subsequent synchronous or asynchronous accept operations on this acceptor are permitted to fail with error condition <span class='texttt'>errc::connection_aborted</span>. If <span class='texttt'>mode</span> is <span class='texttt'>false</span>, subsequent accept operations will not fail with <span class='texttt'>errc::connection_aborted</span>. [&nbsp;<i>Note:</i> If <span class='texttt'>mode</span> is <span class='texttt'>false</span>, the implementation will restart the call to POSIX <span class='texttt'>accept</span> if it fails with <span class='texttt'>ECONNABORTED</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='38'><div class='marginalizedparent'><a class='marginalized' href='#38'>38</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='38.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#38.1'>(38.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
bool enable_connection_aborted() const;
</code></p><div class='itemdescr'></div><div class='para' id='39'><div class='marginalizedparent'><a class='marginalized' href='#39'>39</a></div><div class='itemdescr'><p ><i>Returns:</i> Whether accept operations on this acceptor are permitted to fail with <span class='texttt'>errc::connection_aborted</span>.
</p></div></div><p ><code class='itemdecl'>
socket_type accept();
socket_type accept(error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='40'><div class='marginalizedparent'><a class='marginalized' href='#40'>40</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>accept(get_executor().context(), ec)</span>.
</p></div></div><p ><code class='itemdecl'>
socket_type accept(io_context&amp; ctx);
socket_type accept(io_context&amp; ctx, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='41'><div class='marginalizedparent'><a class='marginalized' href='#41'>41</a></div><div class='itemdescr'><p ><i>Effects:</i> Extracts a socket from the queue of pending connections of the acceptor, as if by POSIX:
</p><pre class='codeblock'>
native_handle_type h = accept(native_handle(), nullptr, 0);
</pre></div></div><div class='para' id='42'><div class='marginalizedparent'><a class='marginalized' href='#42'>42</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, <span class='texttt'>socket_type(ctx, protocol_, h)</span>. Otherwise <span class='texttt'>socket_type(ctx)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <span class='DEDUCED'></span> async_accept(CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='43'><div class='marginalizedparent'><a class='marginalized' href='#43'>43</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><pre class='codeblock'>
async_accept(get_executor().context(), forward&lt;CompletionToken&gt;(token))
</pre></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <span class='DEDUCED'></span> async_accept(io_context&amp; ctx, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='44'><div class='marginalizedparent'><a class='marginalized' href='#44'>44</a></div><div class='itemdescr'><p ><span class='completionsig'></span> <span class='texttt'>void(error_code ec, socket_type s)</span>.</p></div></div><div class='para' id='45'><div class='marginalizedparent'><a class='marginalized' href='#45'>45</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to extract a socket from the queue of pending connections of the acceptor, as if by POSIX:
</p><pre class='codeblock'>
native_handle_type h = accept(native_handle(), nullptr, 0);
</pre><p >On success, <span class='texttt'>s</span> is <span class='texttt'>socket_type(ctx, protocol_, h)</span>. Otherwise, <span class='texttt'>s</span> is <span class='texttt'>socket_type(ctx)</span>.
</p></div></div><p ><code class='itemdecl'>
socket_type accept(endpoint_type&amp; endpoint);
socket_type accept(endpoint_type&amp; endpoint, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='46'><div class='marginalizedparent'><a class='marginalized' href='#46'>46</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>accept(get_executor().context(), endpoint, ec)</span>.
</p></div></div><p ><code class='itemdecl'>
socket_type accept(io_context&amp; ctx, endpoint_type&amp; endpoint);
socket_type accept(io_context&amp; ctx, endpoint_type&amp; endpoint,
                   error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='47'><div class='marginalizedparent'><a class='marginalized' href='#47'>47</a></div><div class='itemdescr'><p ><i>Effects:</i> Extracts a socket from the queue of pending connections of the acceptor, as if by POSIX:
</p><pre class='codeblock'>
socklen_t endpoint_len = endpoint.capacity();
native_handle_type h = accept(native_handle(),
                              endpoint.data(),
                              &amp;endpoint_len);
if (h &gt;= 0)
  endpoint.resize(endpoint_len);
</pre></div></div><div class='para' id='48'><div class='marginalizedparent'><a class='marginalized' href='#48'>48</a></div><div class='itemdescr'><p ><i>Returns:</i> On success, <span class='texttt'>socket_type(ctx, protocol_, h)</span>. Otherwise <span class='texttt'>socket_type(ctx)</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <span class='DEDUCED'></span> async_accept(endpoint_type&amp; endpoint,
                       CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='49'><div class='marginalizedparent'><a class='marginalized' href='#49'>49</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><pre class='codeblock'>
async_accept(get_executor().context(), endpoint, forward&lt;CompletionToken&gt;(token))
</pre></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <span class='DEDUCED'></span> async_accept(io_context&amp; ctx, endpoint_type&amp; endpoint,
                       CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='50'><div class='marginalizedparent'><a class='marginalized' href='#50'>50</a></div><div class='itemdescr'><p ><span class='completionsig'></span> <span class='texttt'>void(error_code ec, socket_type s)</span>.</p></div></div><div class='para' id='51'><div class='marginalizedparent'><a class='marginalized' href='#51'>51</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to extract a socket from the queue of pending connections of the acceptor, as if by POSIX:
</p><pre class='codeblock'>
socklen_t endpoint_len = endpoint.capacity();
native_handle_type h = accept(native_handle(),
                              endpoint.data(),
                              &amp;endpoint_len);
if (h &gt;= 0)
  endpoint.resize(endpoint_len);
</pre><p >On success, <span class='texttt'>s</span> is <span class='texttt'>socket_type(ctx, protocol_, h)</span>. Otherwise,  <span class='texttt'>s</span> is  <span class='texttt'>socket_type(ctx)</span>.
</p></div></div><p ><code class='itemdecl'>
void wait(wait_type w);
void wait(wait_type w, error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='52'><div class='marginalizedparent'><a class='marginalized' href='#52'>52</a></div><div class='itemdescr'><p ><i>Effects:</i> Waits for the acceptor to have a queued incoming connection, or to have error conditions pending, as if by POSIX <span class='texttt'>poll</span>.
</p></div></div><p ><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <span class='DEDUCED'></span> async_wait(wait_type w, CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='53'><div class='marginalizedparent'><a class='marginalized' href='#53'>53</a></div><div class='itemdescr'><p ><span class='completionsig'></span> <span class='texttt'>void(error_code ec)</span>.</p></div></div><div class='para' id='54'><div class='marginalizedparent'><a class='marginalized' href='#54'>54</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous operation to wait for the acceptor to have a queued incoming connection, or to have error conditions pending, as if by POSIX <span class='texttt'>poll</span>.</p></div></div><div class='para' id='55'><div class='marginalizedparent'><a class='marginalized' href='#55'>55</a></div><div class='itemdescr'><p >When multiple asynchronous wait operations are initiated with the same <span class='texttt'>wait_type</span> value, all outstanding operations complete when the acceptor enters the corresponding ready state. The order of invocation of the completions handlers for these operations is unspecified.</p></div></div><div class='para' id='56'><div class='marginalizedparent'><a class='marginalized' href='#56'>56</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul class='itemize'><li id='56.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#56.1'>(56.1)</a></div><p ><span class='texttt'>errc::bad_file_descriptor</span> — if <span class='texttt'>is_open()</span> is <span class='texttt'>false</span>.
</p></li></ul></div></div></div></div></body></html>