<!DOCTYPE html><html lang='en'><head><title>[timer.waitable]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>15</a> Timers <a class='abbr_ref' href='./#timer'>[timer]</a></h1><div id='timer.waitable'><h2 ><a class='secnum' style='min-width:88pt'>15.4</a> Class template <span class='texttt'>basic_waitable_timer</span> <a class='abbr_ref'>[timer.waitable]</a></h2><p ><span class='indexparent'><a class='index' id='basic_waitable_timer'></a></span></p><pre class='codeblock'>
namespace std {
namespace experimental {
namespace net {
inline namespace v1 {

  template&lt;class Clock, class WaitTraits = wait_traits&lt;Clock&gt;&gt;
  class basic_waitable_timer
  {
  public:
    <span class='comment'>// types:
</span>
    using executor_type = io_context::executor_type;
    using clock_type = Clock;
    using duration = typename clock_type::duration;
    using time_point = typename clock_type::time_point;
    using traits_type = WaitTraits;

    <span class='comment'>// <a href='timer.waitable.cons'>[timer.waitable.cons]</a>, construct / copy / destroy:
</span>
    explicit basic_waitable_timer(io_context&amp; ctx);
    basic_waitable_timer(io_context&amp; ctx, const time_point&amp; t);
    basic_waitable_timer(io_context&amp; ctx, const duration&amp; d);
    basic_waitable_timer(const basic_waitable_timer&amp;) = delete;
    basic_waitable_timer(basic_waitable_timer&amp;&amp; rhs);

    ~basic_waitable_timer();

    basic_waitable_timer&amp; operator=(const basic_waitable_timer&amp;) = delete;
    basic_waitable_timer&amp; operator=(basic_waitable_timer&amp;&amp; rhs);

    <span class='comment'>// <a href='timer.waitable.ops'>[timer.waitable.ops]</a>, basic_waitable_timer operations:
</span>
    executor_type get_executor() noexcept;

    size_t cancel();
    size_t cancel_one();

    time_point expiry() const;
    size_t expires_at(const time_point&amp; t);
    size_t expires_after(const duration&amp; d);

    void wait();
    void wait(error_code&amp; ec);

    template&lt;class CompletionToken&gt;
      <i><span class='texttt'>DEDUCED</span></i> async_wait(CompletionToken&amp;&amp; token);
  };

} <span class='comment'>// inline namespace v1
</span>} <span class='comment'>// namespace net
</span>} <span class='comment'>// namespace experimental
</span>} <span class='comment'>// namespace std
</span></pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Instances of class template <span class='texttt'>basic_waitable_timer</span> meet the requirements of <span class='texttt'>Destructible</span> (C++ 2014 [destructible]), <span class='texttt'>MoveConstructible</span> (C++ 2014 [moveconstructible]), and <span class='texttt'>MoveAssignable</span> (C++ 2014 [moveassignable]).</p></div><div id='cons'><h3 ><a class='secnum' href='#cons' style='min-width:103pt'>15.4.1</a> <span class='texttt'>basic_waitable_timer</span> constructors <a class='abbr_ref' href='timer.waitable.cons'>[timer.waitable.cons]</a></h3><p ><span class='indexparent'><a class='index' id='basic_waitable_timer,constructor'></a></span><code class='itemdecl'>
explicit basic_waitable_timer(io_context&amp; ctx);
</code></p><div class='itemdescr'></div><div class='para' id='cons-1'><div class='marginalizedparent'><a class='marginalized' href='#cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>basic_waitable_timer(ctx, time_point())</span>.
</p></div></div><p ><code class='itemdecl'>
basic_waitable_timer(io_context&amp; ctx, const time_point&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='cons-2'><div class='marginalizedparent'><a class='marginalized' href='#cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='cons-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#cons-2.1'>(2.1)</a></div><p ><span class='texttt'>get_executor() == ctx.get_executor()</span>.
</p></li><li id='cons-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#cons-2.2'>(2.2)</a></div><p ><span class='texttt'>expiry() == t</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
basic_waitable_timer(io_context&amp; ctx, const duration&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='cons-3'><div class='marginalizedparent'><a class='marginalized' href='#cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Sets the expiry time as if by calling <span class='texttt'>expires_after(d)</span>.</p></div></div><div class='para' id='cons-4'><div class='marginalizedparent'><a class='marginalized' href='#cons-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_executor() == ctx.get_executor()</span>.
</p></div></div><p ><code class='itemdecl'>
basic_waitable_timer(basic_waitable_timer&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='cons-5'><div class='marginalizedparent'><a class='marginalized' href='#cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs an object of class <span class='texttt'>basic_waitable_timer&lt;Clock, WaitTraits&gt;</span> that refers to the state originally represented by <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='cons-6'><div class='marginalizedparent'><a class='marginalized' href='#cons-6'>6</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='cons-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#cons-6.1'>(6.1)</a></div><p ><span class='texttt'>get_executor() == rhs.get_executor()</span>.
</p></li><li id='cons-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#cons-6.2'>(6.2)</a></div><p ><span class='texttt'>expiry()</span> returns the same value as <span class='texttt'>rhs.expiry()</span> prior to the constructor invocation.
</p></li><li id='cons-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#cons-6.3'>(6.3)</a></div><p ><span class='texttt'>rhs.expiry() == time_point()</span>.
</p></li></ul></div></div></div><div id='dtor'><h3 ><a class='secnum' href='#dtor' style='min-width:103pt'>15.4.2</a> <span class='texttt'>basic_waitable_timer</span> destructor <a class='abbr_ref' href='timer.waitable.dtor'>[timer.waitable.dtor]</a></h3><p ><span class='indexparent'><a class='index' id='basic_waitable_timer,destructor'></a></span><code class='itemdecl'>
~basic_waitable_timer();
</code></p><div class='itemdescr'></div><div class='para' id='dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys the timer, canceling any asynchronous wait operations associated with the timer as if by calling <span class='texttt'>cancel()</span>.
</p></div></div></div><div id='assign'><h3 ><a class='secnum' href='#assign' style='min-width:103pt'>15.4.3</a> <span class='texttt'>basic_waitable_timer</span> assignment <a class='abbr_ref' href='timer.waitable.assign'>[timer.waitable.assign]</a></h3><p ><span class='indexparent'><a class='index' id='operator=,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,operator='></a></span><code class='itemdecl'>
basic_waitable_timer&amp; operator=(basic_waitable_timer&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='assign-1'><div class='marginalizedparent'><a class='marginalized' href='#assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Cancels any outstanding asynchronous operations associated with <span class='texttt'>*this</span> as if by calling <span class='texttt'>cancel()</span>, then moves into <span class='texttt'>*this</span> the state originally represented by <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='assign-2'><div class='marginalizedparent'><a class='marginalized' href='#assign-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul class='itemize'><li id='assign-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-2.1'>(2.1)</a></div><p ><span class='texttt'>get_executor() == rhs.get_executor()</span>.
</p></li><li id='assign-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-2.2'>(2.2)</a></div><p ><span class='texttt'>expiry()</span> returns the same value as <span class='texttt'>rhs.expiry()</span> prior to the assignment.
</p></li><li id='assign-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assign-2.3'>(2.3)</a></div><p ><span class='texttt'>rhs.expiry() == time_point()</span>.
</p></li></ul></div></div><div class='para' id='assign-3'><div class='marginalizedparent'><a class='marginalized' href='#assign-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='ops'><h3 ><a class='secnum' href='#ops' style='min-width:103pt'>15.4.4</a> <span class='texttt'>basic_waitable_timer</span> operations <a class='abbr_ref' href='timer.waitable.ops'>[timer.waitable.ops]</a></h3><p ><span class='indexparent'><a class='index' id='get_executor,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,get_executor'></a></span><code class='itemdecl'>
executor_type get_executor() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ops-1'><div class='marginalizedparent'><a class='marginalized' href='#ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The associated executor.
</p></div></div><p ><span class='indexparent'><a class='index' id='cancel,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,cancel'></a></span><code class='itemdecl'>
size_t cancel();
</code></p><div class='itemdescr'></div><div class='para' id='ops-2'><div class='marginalizedparent'><a class='marginalized' href='#ops-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Causes any outstanding asynchronous wait operations to complete. Completion handlers for canceled operations are passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='ops-3'><div class='marginalizedparent'><a class='marginalized' href='#ops-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of operations that were canceled.</p></div></div><div class='para' id='ops-4'><div class='marginalizedparent'><a class='marginalized' href='#ops-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> Does not block (C++ 2014 [defns.block]) the calling thread pending completion of the canceled operations.
</p></div></div><p ><span class='indexparent'><a class='index' id='cancel_one,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,cancel_one'></a></span><code class='itemdecl'>
size_t cancel_one();
</code></p><div class='itemdescr'></div><div class='para' id='ops-5'><div class='marginalizedparent'><a class='marginalized' href='#ops-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Causes the outstanding asynchronous wait operation that was initiated first, if any, to complete as soon as possible. The completion handler for the canceled operation is passed an error code <span class='texttt'>ec</span> such that <span class='texttt'>ec == errc::operation_canceled</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='ops-6'><div class='marginalizedparent'><a class='marginalized' href='#ops-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>1</span> if an operation was canceled, otherwise <span class='texttt'>0</span>.</p></div></div><div class='para' id='ops-7'><div class='marginalizedparent'><a class='marginalized' href='#ops-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i> Does not block (C++ 2014 [defns.block]) the calling thread pending completion of the canceled operation.
</p></div></div><p ><span class='indexparent'><a class='index' id='expiry,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,expiry'></a></span><code class='itemdecl'>
time_point expiry() const;
</code></p><div class='itemdescr'></div><div class='para' id='ops-8'><div class='marginalizedparent'><a class='marginalized' href='#ops-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> The expiry time associated with the timer, as previously set using <span class='texttt'>expires_at()</span> or <span class='texttt'>expires_after()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='expires_at,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,expires_at'></a></span><code class='itemdecl'>
size_t expires_at(const time_point&amp; t);
</code></p><div class='itemdescr'></div><div class='para' id='ops-9'><div class='marginalizedparent'><a class='marginalized' href='#ops-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Cancels outstanding asynchronous wait operations, as if by calling <span class='texttt'>cancel()</span>. Sets the expiry time associated with the timer.</p></div></div><div class='para' id='ops-10'><div class='marginalizedparent'><a class='marginalized' href='#ops-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of operations that were canceled.</p></div></div><div class='para' id='ops-11'><div class='marginalizedparent'><a class='marginalized' href='#ops-11'>11</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>expiry() == t</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='expires_after,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,expires_after'></a></span><code class='itemdecl'>
size_t expires_after(const duration&amp; d);
</code></p><div class='itemdescr'></div><div class='para' id='ops-12'><div class='marginalizedparent'><a class='marginalized' href='#ops-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>expires_at(clock_type::now() + d)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='wait,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,wait'></a></span><code class='itemdecl'>
void wait();
void wait(error_code&amp; ec);
</code></p><div class='itemdescr'></div><div class='para' id='ops-13'><div class='marginalizedparent'><a class='marginalized' href='#ops-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Establishes the postcondition as if by repeatedly blocking the calling thread (C++ 2014 [defns.block]) for the relative time produced by <span class='texttt'>WaitTraits::to_wait_duration(expiry())</span>.</p></div></div><div class='para' id='ops-14'><div class='marginalizedparent'><a class='marginalized' href='#ops-14'>14</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>ec || expiry() &lt;= clock_type::now()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='asynchronous_wait_operation'></a></span><span class='indexparent'><a class='index' id='async_wait,basic_waitable_timer'></a></span><span class='indexparent'><a class='index' id='basic_waitable_timer,async_wait'></a></span><code class='itemdecl'>
template&lt;class CompletionToken&gt;
  <i><span class='texttt'>DEDUCED</span></i> async_wait(CompletionToken&amp;&amp; token);
</code></p><div class='itemdescr'></div><div class='para' id='ops-15'><div class='marginalizedparent'><a class='marginalized' href='#ops-15'>15</a></div><div class='itemdescr'><p ><i>Completion signature:</i> <span class='texttt'>void(error_code ec)</span>.</p></div></div><div class='para' id='ops-16'><div class='marginalizedparent'><a class='marginalized' href='#ops-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> Initiates an asynchronous wait operation to repeatedly wait for the relative time produced by <span class='texttt'>WaitTraits::to_wait_duration(e)</span>, where <span class='texttt'>e</span> is a value of type <span class='texttt'>time_point</span> such that <span class='texttt'>e &lt;= expiry()</span>. The completion handler is submitted for execution only when the condition <span class='texttt'>ec || expiry() &lt;= clock_type::now()</span> yields <span class='texttt'>true</span>.</p></div></div><div class='para' id='ops-17'><div class='marginalizedparent'><a class='marginalized' href='#ops-17'>17</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> To implement <span class='texttt'>async_wait</span>, an <span class='texttt'>io_context</span> object <span class='texttt'>ctx</span> could maintain a priority queue for each specialization of <span class='texttt'>basic_waitable_timer&lt;Clock, WaitTraits&gt;</span> for which a timer object was initialized with <span class='texttt'>ctx</span>. Only the time point <span class='texttt'>e</span> of the earliest outstanding expiry need be passed to <span class='texttt'>WaitTraits::to_wait_duration(e)</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div></div></div></body></html>