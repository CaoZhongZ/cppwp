<!DOCTYPE html><html lang='en'><head><title>[re.syn]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>28</a> Regular expressions library <a class='abbr_ref' href='./#re'>[re]</a></h1><div id='re.syn'><h2 ><a class='secnum' style='min-width:88pt'>28.4</a> Header <span class='texttt'>&lt;regex&gt;</span> synopsis <a class='abbr_ref'>[re.syn]</a></h2><p ><span class='indexparent'><a class='index' id='regex'></a></span><span class='indexparent'><a class='index' id='basic_regex'></a></span><span class='indexparent'><a class='index' id='regex'></a></span><span class='indexparent'><a class='index' id='wregex'></a></span></p><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// <a href='re.const'>[re.const]</a>, regex constants:
</span>  namespace regex_constants {
    using syntax_option_type = <i>T1</i>;
    using match_flag_type = <i>T2</i>;
    using error_type = <i>T3</i>;
  }

  <span class='comment'>// <a href='re.badexp'>[re.badexp]</a>, class regex_error:
</span>  class regex_error;

  <span class='comment'>// <a href='re.traits'>[re.traits]</a>, class template regex_traits:
</span>  template &lt;class charT&gt; struct regex_traits;

  <span class='comment'>// <a href='re.regex'>[re.regex]</a>, class template basic_regex:
</span>  template &lt;class charT, class traits = regex_traits&lt;charT&gt;&gt; class basic_regex;

  using regex  = basic_regex&lt;char&gt;;
  using wregex = basic_regex&lt;wchar_t&gt;;

  <span class='comment'>// <a href='re.regex.swap'>[re.regex.swap]</a>, basic_regex swap:
</span>  template &lt;class charT, class traits&gt;
    void swap(basic_regex&lt;charT, traits&gt;&amp; e1, basic_regex&lt;charT, traits&gt;&amp; e2);

  <span class='comment'>// <a href='re.submatch'>[re.submatch]</a>, class template sub_match:
</span>  template &lt;class BidirectionalIterator&gt; 
    class sub_match;

  using csub_match  = sub_match&lt;const char*&gt;;
  using wcsub_match = sub_match&lt;const wchar_t*&gt;;
  using ssub_match  = sub_match&lt;string::const_iterator&gt;;
  using wssub_match = sub_match&lt;wstring::const_iterator&gt;;

  <span class='comment'>// <a href='re.submatch.op'>[re.submatch.op]</a>, sub_match non-member operators:
</span>  template &lt;class BiIter&gt;
    bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter&gt;
    bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);

  template &lt;class BiIter, class ST, class SA&gt; 
    bool operator==(
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt; 
    bool operator!=(
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt; 
    bool operator&lt;(
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt; 
    bool operator&gt;(
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt; 
    bool operator&gt;=(
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt; 
    bool operator&lt;=(
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
      const sub_match&lt;BiIter&gt;&amp; rhs);

  template &lt;class BiIter, class ST, class SA&gt; 
    bool operator==(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt; 
    bool operator!=(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt; 
    bool operator&lt;(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt; 
    bool operator&gt;(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt; 
    bool operator&gt;=(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template &lt;class BiIter, class ST, class SA&gt; 
    bool operator&lt;=(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;
        typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);

  template &lt;class BiIter&gt; 
    bool operator==(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs, 
                    const sub_match&lt;BiIter&gt;&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator!=(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs, 
                    const sub_match&lt;BiIter&gt;&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator&lt;(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs, 
                   const sub_match&lt;BiIter&gt;&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator&gt;(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs, 
                   const sub_match&lt;BiIter&gt;&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator&gt;=(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs, 
                    const sub_match&lt;BiIter&gt;&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator&lt;=(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs, 
                    const sub_match&lt;BiIter&gt;&amp; rhs); 

  template &lt;class BiIter&gt; 
    bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs, 
                    typename iterator_traits&lt;BiIter&gt;::value_type const* rhs); 
  template &lt;class BiIter&gt; 
    bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs, 
                    typename iterator_traits&lt;BiIter&gt;::value_type const* rhs); 
  template &lt;class BiIter&gt; 
    bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs, 
                   typename iterator_traits&lt;BiIter&gt;::value_type const* rhs); 
  template &lt;class BiIter&gt; 
    bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs, 
                   typename iterator_traits&lt;BiIter&gt;::value_type const* rhs); 
  template &lt;class BiIter&gt; 
    bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs, 
                    typename iterator_traits&lt;BiIter&gt;::value_type const* rhs); 
  template &lt;class BiIter&gt; 
    bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs, 
                    typename iterator_traits&lt;BiIter&gt;::value_type const* rhs); 

  template &lt;class BiIter&gt; 
    bool operator==(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs, 
                    const sub_match&lt;BiIter&gt;&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator!=(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs, 
                    const sub_match&lt;BiIter&gt;&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator&lt;(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs, 
                   const sub_match&lt;BiIter&gt;&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator&gt;(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs, 
                   const sub_match&lt;BiIter&gt;&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator&gt;=(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs, 
                    const sub_match&lt;BiIter&gt;&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator&lt;=(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs, 
                    const sub_match&lt;BiIter&gt;&amp; rhs); 

  template &lt;class BiIter&gt; 
    bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs, 
                    typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs, 
                    typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs, 
                   typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs, 
                   typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs, 
                    typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs); 
  template &lt;class BiIter&gt; 
    bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs, 
                    typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs); 

  template &lt;class charT, class ST, class BiIter&gt;
    basic_ostream&lt;charT, ST&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, ST&gt;&amp; os, const sub_match&lt;BiIter&gt;&amp; m);

  <span class='comment'>// <a href='re.results'>[re.results]</a>, class template match_results:
</span>  template &lt;class BidirectionalIterator,
            class Allocator = allocator&lt;sub_match&lt;BidirectionalIterator&gt;&gt;&gt;
    class match_results;

  using cmatch  = match_results&lt;const char*&gt;;
  using wcmatch = match_results&lt;const wchar_t*&gt;;
  using smatch  = match_results&lt;string::const_iterator&gt;;
  using wsmatch = match_results&lt;wstring::const_iterator&gt;;

  <span class='comment'>// match_results comparisons
</span>  template &lt;class BidirectionalIterator, class Allocator&gt;
    bool operator==(const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
                    const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
  template &lt;class BidirectionalIterator, class Allocator&gt;
    bool operator!=(const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
                    const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);

  <span class='comment'>// <a href='re.results.swap'>[re.results.swap]</a>, match_results swap:
</span>  template &lt;class BidirectionalIterator, class Allocator&gt;
    void swap(match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
              match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);

  <span class='comment'>// <a href='re.alg.match'>[re.alg.match]</a>, function template regex_match:
</span>  template &lt;class BidirectionalIterator, class Allocator,
      class charT, class traits&gt;
    bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                     match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);
  template &lt;class BidirectionalIterator, class charT, class traits&gt;
  bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                   const basic_regex&lt;charT, traits&gt;&amp; e,
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default);
  template &lt;class charT, class Allocator, class traits&gt;
    bool regex_match(const charT* str, match_results&lt;const charT*, Allocator&gt;&amp; m,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);
  template &lt;class ST, class SA, class Allocator, class charT, class traits&gt;
    bool regex_match(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                     match_results&lt;
                       typename basic_string&lt;charT, ST, SA&gt;::const_iterator, 
                       Allocator&gt;&amp; m, 
                     const basic_regex&lt;charT, traits&gt;&amp; e, 
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);
  template &lt;class ST, class SA, class Allocator, class charT, class traits&gt; 
    bool regex_match(const basic_string&lt;charT, ST, SA&gt;&amp;&amp;, 
                     match_results&lt;
                       typename basic_string&lt;charT, ST, SA&gt;::const_iterator, 
                       Allocator&gt;&amp;, 
                     const basic_regex&lt;charT, traits&gt;&amp;, 
                     regex_constants::match_flag_type = 
                       regex_constants::match_default) = delete;
  template &lt;class charT, class traits&gt;
    bool regex_match(const charT* str,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);
  template &lt;class ST, class SA, class charT, class traits&gt;
    bool regex_match(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                     const basic_regex&lt;charT, traits&gt;&amp; e,
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);

  <span class='comment'>// <a href='re.alg.search'>[re.alg.search]</a>, function template regex_search:
</span>  template &lt;class BidirectionalIterator, class Allocator,
      class charT, class traits&gt;
    bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                      match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template &lt;class BidirectionalIterator, class charT, class traits&gt;
    bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template &lt;class charT, class Allocator, class traits&gt;
    bool regex_search(const charT* str,
                      match_results&lt;const charT*, Allocator&gt;&amp; m,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template &lt;class charT, class traits&gt;
    bool regex_search(const charT* str,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template &lt;class ST, class SA, class charT, class traits&gt;
    bool regex_search(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template &lt;class ST, class SA, class Allocator, class charT, class traits&gt;
    bool regex_search(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                      match_results&lt;
                        typename basic_string&lt;charT, ST, SA&gt;::const_iterator, 
                        Allocator&gt;&amp; m,
                      const basic_regex&lt;charT, traits&gt;&amp; e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template &lt;class ST, class SA, class Allocator, class charT, class traits&gt; 
    bool regex_search(const basic_string&lt;charT, ST, SA&gt;&amp;&amp;, 
                      match_results&lt;
                        typename basic_string&lt;charT, ST, SA&gt;::const_iterator, 
                        Allocator&gt;&amp;, 
                      const basic_regex&lt;charT, traits&gt;&amp;, 
                      regex_constants::match_flag_type = 
                        regex_constants::match_default) = delete;

  <span class='comment'>// <a href='re.alg.replace'>[re.alg.replace]</a>, function template regex_replace:
</span>  template &lt;class OutputIterator, class BidirectionalIterator,
      class traits, class charT, class ST, class SA&gt;
    OutputIterator 
    regex_replace(OutputIterator out,
                  BidirectionalIterator first, BidirectionalIterator last,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  const basic_string&lt;charT, ST, SA&gt;&amp; fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
  template &lt;class OutputIterator, class BidirectionalIterator,
      class traits, class charT&gt;
    OutputIterator
    regex_replace(OutputIterator out,
                  BidirectionalIterator first, BidirectionalIterator last,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  const charT* fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
  template &lt;class traits, class charT, class ST, class SA,
      class FST, class FSA&gt;
    basic_string&lt;charT, ST, SA&gt;
    regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  const basic_string&lt;charT, FST, FSA&gt;&amp; fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
  template &lt;class traits, class charT, class ST, class SA&gt;
    basic_string&lt;charT, ST, SA&gt;
    regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  const charT* fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
  template &lt;class traits, class charT, class ST, class SA&gt;
    basic_string&lt;charT&gt;
    regex_replace(const charT* s,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  const basic_string&lt;charT, ST, SA&gt;&amp; fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
  template &lt;class traits, class charT&gt;
    basic_string&lt;charT&gt;
    regex_replace(const charT* s,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  const charT* fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);

  <span class='comment'>// <a href='re.regiter'>[re.regiter]</a>, class template regex_iterator:
</span>  template &lt;class BidirectionalIterator, 
            class charT = typename iterator_traits&lt;
              BidirectionalIterator&gt;::value_type,
            class traits = regex_traits&lt;charT&gt;&gt;
    class regex_iterator;

  using cregex_iterator  = regex_iterator&lt;const char*&gt;;
  using wcregex_iterator = regex_iterator&lt;const wchar_t*&gt;;
  using sregex_iterator  = regex_iterator&lt;string::const_iterator&gt;;
  using wsregex_iterator = regex_iterator&lt;wstring::const_iterator&gt;;

  <span class='comment'>// <a href='re.tokiter'>[re.tokiter]</a>, class template regex_token_iterator:
</span>  template &lt;class BidirectionalIterator, 
            class charT = typename iterator_traits&lt;
              BidirectionalIterator&gt;::value_type,
            class traits = regex_traits&lt;charT&gt;&gt;
    class regex_token_iterator;

  using cregex_token_iterator  = regex_token_iterator&lt;const char*&gt;;
  using wcregex_token_iterator = regex_token_iterator&lt;const wchar_t*&gt;;
  using sregex_token_iterator  = regex_token_iterator&lt;string::const_iterator&gt;;
  using wsregex_token_iterator = regex_token_iterator&lt;wstring::const_iterator&gt;;

  namespace pmr {
    template &lt;class BidirectionalIterator&gt;
      using match_results =
        std::match_results&lt;BidirectionalIterator,
                           polymorphic_allocator&lt;sub_match&lt;BidirectionalIterator&gt;&gt;&gt;;

    using cmatch  = match_results&lt;const char*&gt;;
    using wcmatch = match_results&lt;const wchar_t*&gt;;
    using smatch  = match_results&lt;string::const_iterator&gt;;
    using wsmatch = match_results&lt;wstring::const_iterator&gt;;
  }
}
</pre></div></div></body></html>