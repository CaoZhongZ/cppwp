<!DOCTYPE html><html lang='en'><head><title>[cpp.cond]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>16</a> Preprocessing directives <a class='abbr_ref' href='./#cpp'>[cpp]</a></h1><div id='cpp.cond'><h2 ><a class='secnum' style='min-width:88pt'>16.1</a> Conditional inclusion <a class='abbr_ref'>[cpp.cond]</a></h2><p ><span class='indexparent'><a class='index' id='preprocessing_directive,conditional_inclusion'></a></span><span class='indexparent'><a class='index' id='inclusion,conditional'></a></span></p><p ><span class='indexparent'><a class='index' id='defined'></a></span></p><pre class='bnf'><a id='nt:defined-macro-expression'>defined-macro-expression:</a>
    <span class='terminal'>defined</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i>
    <span class='terminal'>defined (</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>)</span></pre><pre class='bnf'><a id='nt:h-preprocessing-token'>h-preprocessing-token:</a>
    <span class='textnormal'>any <span class='small'></span><span class='rmfamily'></span><i> preprocessing-token</i> other than <span class='terminal'>&gt;</span></span></pre><pre class='bnf'><a id='nt:h-pp-tokens'>h-pp-tokens:</a>
    <i ><a href='cpp.cond#nt:h-preprocessing-token'>h-preprocessing-token</a></i>
    <i ><a href='cpp.cond#nt:h-pp-tokens'>h-pp-tokens</a></i> <i ><a href='cpp.cond#nt:h-preprocessing-token'>h-preprocessing-token</a></i></pre><p ><span class='indexparent'><a class='index' id='__HAS_INCLUDE'></a></span></p><pre class='bnf'><a id='nt:has-include-expression'>has-include-expression:</a>
    <span class='terminal'><span class='texttt'>__has_include</span> ( &lt;</span> <i ><a href='lex.header#nt:h-char-sequence'>h-char-sequence</a></i> <span class='terminal'>&gt; )</span>
    <span class='terminal'><span class='texttt'>__has_include</span> ( "</span> <i ><a href='lex.header#nt:q-char-sequence'>q-char-sequence</a></i> <span class='terminal'>" )</span>
    <span class='terminal'><span class='texttt'>__has_include</span> (</span>   <i ><a href='lex.string#nt:string-literal'>string-literal</a></i>  <span class='terminal'>)</span>
    <span class='terminal'><span class='texttt'>__has_include</span> ( &lt;</span> <i ><a href='cpp.cond#nt:h-pp-tokens'>h-pp-tokens</a></i>     <span class='terminal'>&gt; )</span></pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The expression that controls conditional inclusion
shall be an integral constant expression except that
identifiers
(including those lexically identical to keywords)
are interpreted as described below<a class='footnotenum' href='#footnote-146'>146</a>
and it may contain zero or more <i ><a href='cpp.cond#nt:defined-macro-expression'>defined-macro-expressions</a></i> and/or
<i ><a href='cpp.cond#nt:has-include-expression'>has-include-expressions</a></i> as unary operator expressions.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A <i ><a href='cpp.cond#nt:defined-macro-expression'>defined-macro-expression</a></i> evaluates to <span class='texttt'>1</span>
if the identifier is currently defined
as a macro name
(that is, if it is predefined
or if it has been the subject of a
<span class='texttt'>#define</span>
preprocessing directive
without an intervening
<span class='texttt'>#undef</span>
directive with the same subject identifier), <span class='texttt'>0</span> if it is not.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The third and fourth forms of <i ><a href='cpp.cond#nt:has-include-expression'>has-include-expression</a></i>
are considered only if neither of the first or second forms matches,
in which case the preprocessing tokens are processed just as in normal text.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The header or source file identified by
the parenthesized preprocessing token sequence
in each contained <i ><a href='cpp.cond#nt:has-include-expression'>has-include-expression</a></i>
is searched for as if that preprocessing token sequence
were the <i ><a href='cpp#nt:pp-tokens'>pp-tokens</a></i> in a <span class='texttt'>#include</span> directive,
except that no further macro expansion is performed.
If such a directive would not satisfy the syntactic requirements
of a <span class='texttt'>#include</span> directive, the program is ill-formed.
The <i ><a href='cpp.cond#nt:has-include-expression'>has-include-expression</a></i> evaluates
to <span class='texttt'>1</span> if the search for the source file succeeds, and
to <span class='texttt'>0</span> if the search fails.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >The <span class='texttt'>#ifdef</span> and <span class='texttt'>#ifndef</span> directives, and
the <span class='texttt'>defined</span> conditional inclusion operator,
shall treat <span class='texttt'>__has_include</span> as if it were the name of a defined macro.
The identifier <span class='texttt'>__has_include</span> shall not appear
in any context not mentioned in this section.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >Each preprocessing token that remains (in the list of preprocessing tokens that
will become the controlling expression)
after all macro replacements have occurred
shall be in the lexical form of a token (<a href='lex.token'>[lex.token]</a>).</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >Preprocessing directives of the forms</p><pre class='bnf'><span class='indexparent'><a class='index' id='#if'></a></span><span class='terminal'># if</span>&#9;&#9;<i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> <i ><a href='cpp#nt:new-line'>new-line</a></i> <i ><a href='cpp#nt:group'>group</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='indexparent'><a class='index' id='#elif'></a></span><span class='terminal'># elif</span>&#9;&#9;<i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> <i ><a href='cpp#nt:new-line'>new-line</a></i> <i ><a href='cpp#nt:group'>group</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><p >check whether the controlling constant expression evaluates to nonzero.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >Prior to evaluation,
macro invocations in the list of preprocessing tokens
that will become the controlling constant expression
are replaced
(except for those macro names modified by the
<span class='texttt'>defined</span>
unary operator),
just as in normal text.
If the token
<span class='texttt'>defined</span>
is generated as a result of this replacement process
or use of the
<span class='texttt'>defined</span>
unary operator does not match one of the two specified forms
prior to macro replacement,
the behavior is undefined.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >After all replacements due to macro expansion and
evaluations of <i ><a href='cpp.cond#nt:defined-macro-expression'>defined-macro-expressions</a></i> and
<i ><a href='cpp.cond#nt:has-include-expression'>has-include-expressions</a></i>
have been performed,
all remaining identifiers and keywords,
except for
<span class='texttt'>true</span>
and
<span class='texttt'>false</span>,
are replaced with the pp-number
<span class='texttt'>0</span>,
and then each preprocessing token is converted into a token.
[&nbsp;<i>Note:</i><span class='space'></span>
An alternative
token (<a href='lex.digraph'>[lex.digraph]</a>) is not an identifier,
even when its spelling consists entirely of letters and underscores.
Therefore it is not subject to this replacement.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >The resulting tokens comprise the controlling constant expression
which is evaluated according to the rules of <a href='expr.const'>[expr.const]</a>
using arithmetic that has at least the ranges specified
in <a href='support.limits'>[support.limits]</a>. For the purposes of this token conversion and evaluation
all signed and unsigned integer types
act as if they have the same representation as, respectively,
<span class='texttt'>intmax_t</span> or <span class='texttt'>uintmax_t</span> (<a href='cstdint'>[cstdint]</a>).
[&nbsp;<i>Note:</i><span class='space'></span>
Thus on an
implementation where <span class='texttt'>std::numeric_limits&lt;int&gt;::max()</span> is <span class='texttt'>0x7FFF</span>
and <span class='texttt'>std::numeric_limits&lt;unsigned int&gt;::max()</span> is <span class='texttt'>0xFFFF</span>,
the integer literal <span class='texttt'>0x8000</span> is signed and positive within a <span class='texttt'>#if</span>
expression even though it is unsigned in translation phase
7 (<a href='lex.phases'>[lex.phases]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
This includes interpreting character literals, which may involve
converting escape sequences into execution character set members.
Whether the numeric value for these character literals
matches the value obtained when an identical character literal
occurs in an expression
(other than within a
<span class='texttt'>#if</span>
or
<span class='texttt'>#elif</span>
directive)
is <span class='indexparent'><a class='index' id='numeric_values_of_character_literals_in_#if_directives'></a></span>implementation-defined.
[&nbsp;<i>Note:</i><span class='space'></span>
Thus, the constant expression in the following
<span class='texttt'>#if</span>
directive and
<span class='texttt'>if</span>
statement is not guaranteed to evaluate to the same value in these two
contexts:
</p><pre class='codeblock'>
#if 'z' - 'a' == 25
if ('z' - 'a' == 25)
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]
Also, whether a single-character character literal may have a negative
value is <span class='indexparent'><a class='index' id='negative_value_of_character_literal_in_preprocessor'></a></span>implementation-defined.
Each subexpression with type
<span class='texttt'>bool</span>
is subjected to integral promotion before processing continues.</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >Preprocessing directives of the forms</p><pre class='bnf'><span class='terminal'># ifdef</span>&#9;&#9;<i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='cpp#nt:new-line'>new-line</a></i> <i ><a href='cpp#nt:group'>group</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='indexparent'><a class='index' id='#ifdef'></a></span><span class='terminal'># ifndef</span>&#9;&#9;<i ><a href='lex.name#nt:identifier'>identifier</a></i> <i ><a href='cpp#nt:new-line'>new-line</a></i> <i ><a href='cpp#nt:group'>group</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
<span class='indexparent'><a class='index' id='#ifndef'></a></span></pre><p >check whether the identifier is or is not currently defined as a macro name.
Their conditions are equivalent to
<span class='texttt'>#if</span>
<span class='texttt'>defined</span>
<a class='hidden_link' href='#def:identifier' id='def:identifier'><i>identifier</i></a>
and
<span class='texttt'>#if</span>
<span class='texttt'>!defined</span>
<a class='hidden_link' href='#def:identifier' id='def:identifier'><i>identifier</i></a>
respectively.</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >Each directive's condition is checked in order.
If it evaluates to false (zero),
the group that it controls is skipped:
directives are processed only through the name that determines
the directive in order to keep track of the level
of nested conditionals;
the rest of the directives' preprocessing tokens are ignored,
as are the other preprocessing tokens in the group.
Only the first group
whose control condition evaluates to true (nonzero) is processed;
any following groups are skipped and their controlling directives
are processed as if they were in a group that is skipped.
If none of the conditions evaluates to true,
and there is a
<span class='texttt'>#else</span>
<span class='indexparent'><a class='index' id='#else'></a></span>directive,
the group controlled by the
<span class='texttt'>#else</span>
is processed; lacking a
<span class='texttt'>#else</span>
directive, all the groups until the
<span class='texttt'>#endif</span>
<span class='indexparent'><a class='index' id='#endif'></a></span>are skipped.<a class='footnotenum' href='#footnote-147'>147</a></p><p >[&nbsp;<i>Example:</i><span class='space'></span>
This demonstrates a way to include a library <span class='texttt'>optional</span> facility
only if it is available:</p><pre class='codeblock'>
#if __has_include(&lt;optional&gt;)
#  include &lt;optional&gt;
#  define have_optional 1
#elif __has_include(&lt;experimental/optional&gt;)
#  include &lt;experimental/optional&gt;
#  define have_optional 1
#  define experimental_optional 1
#else
#  define have_optional 0
#endif
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='footnote' id='footnote-146'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-146'>146)</a></div><p >Because the controlling constant expression is evaluated
during translation phase 4,
all identifiers either are or are not macro names —
there simply are no keywords, enumeration constants, etc.</p></div><div class='footnote' id='footnote-147'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-147'>147)</a></div><p >As indicated by the syntax,
a preprocessing token shall not follow a
<span class='texttt'>#else</span>
or
<span class='texttt'>#endif</span>
directive before the terminating new-line character.
However,
comments may appear anywhere in a source file,
including within a preprocessing directive.</p></div></div></div></body></html>