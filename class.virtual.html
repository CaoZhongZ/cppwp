<!DOCTYPE html><html lang='en'><head><title>[class.virtual]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Derived classes <a class='abbr_ref' href='./#class.derived'>[class.derived]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>13.3</a> Virtual functions <a class='abbr_ref'>[class.virtual]</a></h2><p ><span class='indexparent'><a class='index' id=':virtual_function'></a></span><span class='indexparent'><a class='index' id=':type,polymorphic'></a></span>
</p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L578'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
Virtual functions support dynamic binding and object-oriented
programming. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]  A class that declares or inherits a virtual function is
called a <a class='hidden_link' href='#def:class,polymorphic' id='def:class,polymorphic'><i >polymorphic class</i></a>.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L584'>#</a></div><p >If a virtual member function <span class='texttt'>vf</span> is declared in a class
<span class='texttt'>Base</span> and in a class <span class='texttt'>Derived</span>, derived directly or
indirectly from <span class='texttt'>Base</span>, a member function <span class='texttt'>vf</span> with the same
name, <a href='dcl.fct#def:parameter-type-list'>parameter-type-list</a>, cv-qualification, and ref-qualifier
(or absence of same) as
<span class='texttt'>Base&#x200b;::&#x200b;vf</span> is declared, then <span class='texttt'>Derived&#x200b;::&#x200b;vf</span> is also virtual
(whether or not it is so declared) and it <a class='hidden_link' href='#def:overrides' id='def:overrides'><i>overrides</i></a><a class='footnotenum' href='#footnote-111'>111</a>
<span class='texttt'>Base&#x200b;::&#x200b;vf</span>. For convenience we say that any virtual function
overrides itself.
<span class='indexparent'><a class='index' id=':overrider,final'></a></span>A virtual member function <span class='texttt'>C&#x200b;::&#x200b;vf</span> of a class object <span class='texttt'>S</span> is a <a class='hidden_link' href='#def:final_overrider' id='def:final_overrider'><i >final
overrider</i></a> unless the <a href='intro.object#def:most_derived_class'>most derived class</a> of which <span class='texttt'>S</span> is a
base class subobject (if any) declares or inherits another member function that overrides
<span class='texttt'>vf</span>. In a derived class, if a virtual member function of a base class subobject
has more than one final overrider the program is ill-formed.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
struct A {
  virtual void f();
};
struct B : virtual A {
  virtual void f();
};
struct C : B , virtual A {
  using A::f;
};

void foo() {
  C c;
  c.f();              <span class='comment'>// calls <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;f</span>, the final overrider
</span>  c.C::f();           <span class='comment'>// calls <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;f</span> because of the using-declaration
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
struct A { virtual void f(); };
struct B : A { };
struct C : A { void f(); };
struct D : B, C { };  <span class='comment'>// OK: <span class='tcode_in_codeblock'>A&#x200b;::&#x200b;f</span> and <span class='tcode_in_codeblock'>C&#x200b;::&#x200b;f</span> are the final overriders
</span>                      <span class='comment'>// for the <span class='tcode_in_codeblock'>B</span> and <span class='tcode_in_codeblock'>C</span> subobjects, respectively
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L635'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
A virtual member function does not have to be visible to be overridden,
for example,
</p><pre class='codeblock'>
struct B {
  virtual void f();
};
struct D : B {
  void f(int);
};
struct D2 : D {
  void f();
};</pre><p >the function <span class='texttt'>f(int)</span> in class <span class='texttt'>D</span> hides the virtual
function <span class='texttt'>f()</span> in its base class <span class='texttt'>B</span>; <span class='texttt'>D&#x200b;::&#x200b;f(int)</span> is
not a virtual function. However, <span class='texttt'>f()</span> declared in class
<span class='texttt'>D2</span> has the same name and the same parameter list as
<span class='texttt'>B&#x200b;::&#x200b;f()</span>, and therefore is a virtual function that overrides the
function <span class='texttt'>B&#x200b;::&#x200b;f()</span> even though <span class='texttt'>B&#x200b;::&#x200b;f()</span> is not visible in
class <span class='texttt'>D2</span>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L659'>#</a></div><p >If a virtual function <span class='texttt'>f</span> in some class <span class='texttt'>B</span> is marked with the
<i ><a href='class.mem#nt:virt-specifier'>virt-specifier</a></i> <span class='texttt'>final</span> and in a class <span class='texttt'>D</span> derived from <span class='texttt'>B</span>
a function <span class='texttt'>D&#x200b;::&#x200b;f</span> overrides <span class='texttt'>B&#x200b;::&#x200b;f</span>, the program is ill-formed. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
struct B {
  virtual void f() const final;
};

struct D : B {
  void f() const;     <span class='comment'>// error: <span class='tcode_in_codeblock'>D&#x200b;::&#x200b;f</span> attempts to override <span class='tcode_in_codeblock'>final</span> <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;f</span>
</span>};</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L674'>#</a></div><p >If a virtual function is marked with the <i ><a href='class.mem#nt:virt-specifier'>virt-specifier</a></i> <span class='texttt'>override</span> and
does not override a member function of a base class, the program is ill-formed. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
struct B {
  virtual void f(int);
};

struct D : B {
  virtual void f(long) override;  <span class='comment'>// error: wrong signature overriding <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;f</span>
</span>  virtual void f(int) override;   <span class='comment'>// OK
</span>};</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L689'>#</a></div><p >Even though destructors are not inherited, a destructor in a derived
class overrides a base class destructor declared virtual;
see <a href='class.dtor'>[class.dtor]</a> and <a href='class.free'>[class.free]</a>.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L694'>#</a></div><p >The return type of an overriding function shall be either identical to
the return type of the overridden function or <a class='hidden_link' href='#def:return_type,covariant' id='def:return_type,covariant'><i >covariant</i></a> with
the classes of the functions. If a function <span class='texttt'>D&#x200b;::&#x200b;f</span> overrides a
function <span class='texttt'>B&#x200b;::&#x200b;f</span>, the return types of the functions are covariant
if they satisfy the following criteria:
</p><ul class='itemize'><li id='7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.1'>(7.1)</a></div><p >both are pointers to classes, both are lvalue references to
classes, or both are rvalue references to classes<a class='footnotenum' href='#footnote-112'>112</a></p></li><li id='7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.2'>(7.2)</a></div><p >the class in the return type of <span class='texttt'>B&#x200b;::&#x200b;f</span> is the same class as
the class in the return type of <span class='texttt'>D&#x200b;::&#x200b;f</span>, or is an unambiguous and
accessible direct or indirect base class of the class in the return type
of <span class='texttt'>D&#x200b;::&#x200b;f</span></p></li><li id='7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.3'>(7.3)</a></div><p >both pointers or references have the same cv-qualification and the
class type in the return type of <span class='texttt'>D&#x200b;::&#x200b;f</span> has the same
cv-qualification as or less cv-qualification than the class type in the
return type of <span class='texttt'>B&#x200b;::&#x200b;f</span>.
</p></li></ul></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L717'>#</a></div><p >If the class type in the covariant return type of <span class='texttt'>D&#x200b;::&#x200b;f</span> differs from that of
<span class='texttt'>B&#x200b;::&#x200b;f</span>, the class type in the return type of <span class='texttt'>D&#x200b;::&#x200b;f</span> shall be
complete at the point of declaration of <span class='texttt'>D&#x200b;::&#x200b;f</span> or shall be the
class type <span class='texttt'>D</span>. When the overriding function is called as the
final overrider of the overridden function, its result is converted to
the type returned by the (statically chosen) overridden
function (<a href='expr.call'>[expr.call]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
<span class='indexparent'><a class='index' id=':example,virtual_function'></a></span></p><pre class='codeblock'>
class B { };
class D : private B { friend class Derived; };
struct Base {
  virtual void vf1();
  virtual void vf2();
  virtual void vf3();
  virtual B*   vf4();
  virtual B*   vf5();
  void f();
};

struct No_good : public Base {
  D*  vf4();        <span class='comment'>// error: <span class='tcode_in_codeblock'>B</span> (base class of <span class='tcode_in_codeblock'>D</span>) inaccessible
</span>};

class A;
struct Derived : public Base {
    void vf1();     <span class='comment'>// virtual and overrides <span class='tcode_in_codeblock'>Base&#x200b;::&#x200b;vf1()</span>
</span>    void vf2(int);  <span class='comment'>// not virtual, hides <span class='tcode_in_codeblock'>Base&#x200b;::&#x200b;vf2()</span>
</span>    char vf3();     <span class='comment'>// error: invalid difference in return type only
</span>    D*   vf4();     <span class='comment'>// OK: returns pointer to derived class
</span>    A*   vf5();     <span class='comment'>// error: returns pointer to incomplete class
</span>    void f();
};

void g() {
  Derived d;
  Base* bp = &amp;d;                <span class='comment'>// standard conversion:
</span>                                <span class='comment'>// <span class='tcode_in_codeblock'>Derived*</span> to <span class='tcode_in_codeblock'>Base*</span>
</span>  bp-&gt;vf1();                    <span class='comment'>// calls <span class='tcode_in_codeblock'>Derived&#x200b;::&#x200b;vf1()</span>
</span>  bp-&gt;vf2();                    <span class='comment'>// calls <span class='tcode_in_codeblock'>Base&#x200b;::&#x200b;vf2()</span>
</span>  bp-&gt;f();                      <span class='comment'>// calls <span class='tcode_in_codeblock'>Base&#x200b;::&#x200b;f()</span> (not virtual)
</span>  B*  p = bp-&gt;vf4();            <span class='comment'>// calls <span class='tcode_in_codeblock'>Derived&#x200b;::&#x200b;pf()</span> and converts the
</span>                                <span class='comment'>// result to <span class='tcode_in_codeblock'>B*</span>
</span>  Derived*  dp = &amp;d;
  D*  q = dp-&gt;vf4();            <span class='comment'>// calls <span class='tcode_in_codeblock'>Derived&#x200b;::&#x200b;pf()</span> and does not
</span>                                <span class='comment'>// convert the result to <span class='tcode_in_codeblock'>B*</span>
</span>  dp-&gt;vf2();                    <span class='comment'>// ill-formed: argument mismatch
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L770'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
The interpretation of the call of a virtual function depends on the type
of the object for which it is called (the dynamic type), whereas the
interpretation of a call of a non-virtual member function depends only
on the type of the pointer or reference denoting that object (the static
type) (<a href='expr.call'>[expr.call]</a>).
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L779'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
The <span class='texttt'>virtual</span> specifier implies membership, so a virtual function
cannot be a non-member (<a href='dcl.fct.spec'>[dcl.fct.spec]</a>) function. Nor can a virtual
function be a static member, since a virtual function call relies on a
specific object for determining which function to invoke. A virtual
function declared in one class can be declared a <span class='texttt'>friend</span> in
another class.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L789'>#</a></div><p ><span class='indexparent'><a class='index' id=':definition,virtual_function'></a></span>A virtual function declared in a class shall be defined, or declared
<a href='class.abstract#def:pure'>pure</a> in that class, or both; no diagnostic is
required (<a href='basic.def.odr'>[basic.def.odr]</a>).
<span class='indexparent'><a class='index' id=':friend,virtual_and'></a></span>
</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L796'>#</a></div><p ><span class='indexparent'><a class='index' id=':multiple_inheritance,virtual_and'></a></span>[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
Here are some uses of virtual functions with multiple base classes:
<span class='indexparent'><a class='index' id=':example,virtual_function_'></a></span></p><pre class='codeblock'>
struct A {
  virtual void f();
};

struct B1 : A {                 <span class='comment'>// note non-virtual derivation
</span>  void f();
};

struct B2 : A {
  void f();
};

struct D : B1, B2 {             <span class='comment'>// <span class='tcode_in_codeblock'>D</span> has two separate <span class='tcode_in_codeblock'>A</span> subobjects
</span>};

void foo() {
  D   d;
<span class='comment'>//<span class='tcode_in_codeblock'>   A*  ap = &amp;d;</span>                  // would be ill-formed: ambiguous
</span>  B1*  b1p = &amp;d;
  A*   ap = b1p;
  D*   dp = &amp;d;
  ap-&gt;f();                      <span class='comment'>// calls <span class='tcode_in_codeblock'>D&#x200b;::&#x200b;B1&#x200b;::&#x200b;f</span>
</span>  dp-&gt;f();                      <span class='comment'>// ill-formed: ambiguous
</span>}</pre><p >In class <span class='texttt'>D</span> above there are two occurrences of class <span class='texttt'>A</span>
and hence two occurrences of the virtual member function <span class='texttt'>A&#x200b;::&#x200b;f</span>.
The final overrider of <span class='texttt'>B1&#x200b;::&#x200b;A&#x200b;::&#x200b;f</span> is <span class='texttt'>B1&#x200b;::&#x200b;f</span> and the final
overrider of <span class='texttt'>B2&#x200b;::&#x200b;A&#x200b;::&#x200b;f</span> is <span class='texttt'>B2&#x200b;::&#x200b;f</span>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L833'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
The following example shows a function that does not have a unique final
overrider:
</p><pre class='codeblock'>
struct A {
  virtual void f();
};

struct VB1 : virtual A {        <span class='comment'>// note virtual derivation
</span>  void f();
};

struct VB2 : virtual A {
  void f();
};

struct Error : VB1, VB2 {       <span class='comment'>// ill-formed
</span>};

struct Okay : VB1, VB2 {
  void f();
};</pre><p >Both <span class='texttt'>VB1&#x200b;::&#x200b;f</span> and <span class='texttt'>VB2&#x200b;::&#x200b;f</span> override <span class='texttt'>A&#x200b;::&#x200b;f</span> but there
is no overrider of both of them in class <span class='texttt'>Error</span>. This example is
therefore ill-formed. Class <span class='texttt'>Okay</span> is well formed, however,
because <span class='texttt'>Okay&#x200b;::&#x200b;f</span> is a final overrider.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L863'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
The following example uses the well-formed classes from above.
</p><pre class='codeblock'>
struct VB1a : virtual A {       <span class='comment'>// does not declare <span class='tcode_in_codeblock'>f</span>
</span>};

struct Da : VB1a, VB2 {
};

void foe() {
  VB1a*  vb1ap = new Da;
  vb1ap-&gt;f();                   <span class='comment'>// calls <span class='tcode_in_codeblock'>VB2&#x200b;::&#x200b;f</span>
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L880'>#</a></div><p ><span class='indexparent'><a class='index' id=':operator,scope_resolution'></a></span><span class='indexparent'><a class='index' id=':virtual_function_call'></a></span>Explicit qualification with the scope operator (<a href='expr.prim'>[expr.prim]</a>)
suppresses the virtual call mechanism.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
class B { public: virtual void f(); };
class D : public B { public: void f(); };

void D::f() { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> B::f(); }</pre><p >Here, the function call in
<span class='texttt'>D&#x200b;::&#x200b;f</span>
really does call
<span class='texttt'>B&#x200b;::&#x200b;f</span>
and not
<span class='texttt'>D&#x200b;::&#x200b;f</span>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/derived.tex#L901'>#</a></div><p >A function with a deleted definition (<a href='dcl.fct.def'>[dcl.fct.def]</a>) shall
not override a function that does not have a deleted definition. Likewise,
a function that does not have a deleted definition shall not override a
function with a deleted definition.</p></div><div class='footnote' id='footnote-111'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-111'>111)</a></div><p >A function with the same name but a different parameter list
(Clause <a href='over'>[over]</a>) as a virtual function is not necessarily virtual and
does not override. The use of the <span class='texttt'>virtual</span> specifier in the
declaration of an overriding function is legal but redundant (has empty
semantics). <a href='class.access'>Access control</a> is not considered in
determining overriding.</p></div><div class='footnote' id='footnote-112'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-112'>112)</a></div><p >Multi-level pointers to classes or references to multi-level pointers to
classes are not allowed.</p></div></div></body></html>