<!DOCTYPE html><html lang='en'><head><title>[basic.lookup.argdep]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>3.4</a> Name lookup <a class='abbr_ref' href='basic.lookup#argdep'>[basic.lookup]</a></h2><div id='basic.lookup.argdep'><h3 ><a class='secnum' style='min-width:103pt'>3.4.2</a> Argument-dependent name lookup <a class='abbr_ref'>[basic.lookup.argdep]</a></h3><p ><span class='indexparent'><a class='index' id='lookup,argument-dependent'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >When the <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> in
a function call (<a href='expr.call'>[expr.call]</a>) is an <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i>, other namespaces not considered
during the usual unqualified lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>) may be
searched, and in those namespaces, namespace-scope friend function or
function template declarations (<a href='class.friend'>[class.friend]</a>) not otherwise
visible may be found.
These modifications to the search depend on the types of the arguments
(and for template template arguments, the namespace of the template
argument).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace N {
  struct S { };
  void f(S);
}

void g() {
  N::S s;
  f(s);                         <span class='comment'>// OK: calls <span class='texttt'>N::f</span>
</span>  (f)(s);                       <span class='comment'>// error: <span class='texttt'>N::f</span> not considered; parentheses
</span>                                <span class='comment'>// prevent argument-dependent lookup
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >For each argument type <span class='texttt'>T</span> in the function call, there is a set of
zero or more associated namespaces and a set of zero or more associated
classes to be considered. The sets of namespaces and classes are
determined entirely by the types of the function arguments (and the
namespace of any template template argument). Typedef names and
<i ><a href='namespace.udecl#nt:using-declaration'>using-declarations</a></i> used to specify the types do not
contribute to this set. The sets of namespaces and classes are
determined in the following way:</p><ul ><li ><p >If <span class='texttt'>T</span> is a fundamental type, its associated sets of
namespaces and classes are both empty.</p></li><li ><p >If <span class='texttt'>T</span> is a class type (including unions), its associated
classes are: the class itself; the class of which it is a member, if
any; and its direct and indirect base classes. Its associated namespaces
are the innermost enclosing namespaces of its associated classes.
Furthermore, if <span class='texttt'>T</span> is a class template specialization, its
associated namespaces and classes also include: the namespaces and
classes associated with the types of the template arguments provided for
template type parameters (excluding template template parameters); the
namespaces of which any template template arguments are members; and the
classes of which any member templates used as template template
arguments are members. [&nbsp;<i>Note:</i><span class='space'></span> Non-type template arguments do not
contribute to the set of associated namespaces.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li ><p >If <span class='texttt'>T</span> is an enumeration type, its associated namespace is
the innermost enclosing namespace of its declaration. If it is a class member, its
associated class is the member's class; else it has no associated class.</p></li><li ><p >If <span class='texttt'>T</span> is a pointer to <span class='texttt'>U</span> or an array of <span class='texttt'>U</span>,
its associated namespaces and classes are those associated with
<span class='texttt'>U</span>.</p></li><li ><p >If <span class='texttt'>T</span> is a function type, its associated namespaces and
classes are those associated with the function parameter types and those
associated with the return type.</p></li><li ><p >If <span class='texttt'>T</span> is a pointer to a member function of a class
<span class='texttt'>X</span>, its associated namespaces and classes are those associated
with the function parameter types and return type, together with those
associated with <span class='texttt'>X</span>.</p></li><li ><p >If <span class='texttt'>T</span> is a pointer to a data member of class <span class='texttt'>X</span>, its
associated namespaces and classes are those associated with the member
type together with those associated with <span class='texttt'>X</span>.</p></li></ul><p >If an associated namespace is an inline namespace (<a href='namespace.def'>[namespace.def]</a>), its
enclosing namespace is also included in the set. If an associated namespace
directly contains inline namespaces, those inline namespaces are also included
in the set.
In addition, if the argument is the name or address of a set of
overloaded functions and/or function templates, its associated classes
and namespaces are the union of those associated with each of the
members of the set, i.e., the classes and namespaces associated with its
parameter types and return type.
Additionally, if the aforementioned set of overloaded functions is named with
a <i ><a href='temp.names#nt:template-id'>template-id</a></i>, its associated classes and namespaces also include
those of its type <i ><a href='temp.names#nt:template-argument'>template-arguments</a></i> and its template
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >Let <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a> be the lookup set produced by unqualified
lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>) and let <a class='hidden_link' href='#def:Y' id='def:Y'><i>Y</i></a> be the lookup set produced
by argument dependent lookup (defined as follows). If <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a> contains
</p><ul ><li ><p >a declaration of a class member, or</p></li><li ><p >a block-scope function declaration that is not a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>, or</p></li><li ><p >a declaration that is neither a function nor a function template</p></li></ul><p >then <a class='hidden_link' href='#def:Y' id='def:Y'><i>Y</i></a> is empty. Otherwise <a class='hidden_link' href='#def:Y' id='def:Y'><i>Y</i></a> is the set of declarations
found in the namespaces associated with the argument types as described
below. The set of declarations found by the lookup of the name is the
union of <a class='hidden_link' href='#def:X' id='def:X'><i>X</i></a> and <a class='hidden_link' href='#def:Y' id='def:Y'><i>Y</i></a>. [&nbsp;<i>Note:</i><span class='space'></span> The namespaces and classes
associated with the argument types can include namespaces and classes
already considered by the ordinary unqualified lookup. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace NS {
  class T { };
  void f(T);
  void g(T, int);
}
NS::T parm;
void g(NS::T, float);
int main() {
  f(parm);                      <span class='comment'>// OK: calls <span class='texttt'>NS::f</span>
</span>  extern void g(NS::T, float);
  g(parm, 1);                   <span class='comment'>// OK: calls <span class='texttt'>g(NS::T, float)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >When considering an associated namespace, the lookup is the same as the
lookup performed when the associated namespace is used as a
qualifier (<a href='namespace.qual'>[namespace.qual]</a>) except that:</p><ul ><li ><p >Any <i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> in the associated namespace are
ignored.</p></li><li ><p >Any namespace-scope friend functions or friend function templates
declared in associated classes are visible within their respective
namespaces even if they are not visible during an ordinary
lookup (<a href='class.friend'>[class.friend]</a>).</p></li><li ><p >All names except those of (possibly overloaded) functions and
function templates are ignored.</p></li></ul></div></div></div></body></html>