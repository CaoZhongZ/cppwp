<!DOCTYPE html><html lang='en'><head><title>[support.types]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>18</a> Language support library <a class='abbr_ref' href='./#language.support'>[language.support]</a></h1><div id='support.types'><h2 ><a class='secnum' style='min-width:88pt'>18.2</a> Common definitions <a class='abbr_ref'>[support.types]</a></h2><div id='cstddef.syn'><h3 ><a class='secnum' href='#cstddef.syn' style='min-width:103pt'>18.2.1</a> Header <span class='texttt'>&lt;cstddef&gt;</span> synopsis <a class='abbr_ref' href='cstddef.syn'>[cstddef.syn]</a></h3><p ><span class='indexparent'><a class='index' id='NULL'></a></span><span class='indexparent'><a class='index' id='offsetof'></a></span><span class='indexparent'><a class='index' id='ptrdiff_t'></a></span><span class='indexparent'><a class='index' id='size_t'></a></span><span class='indexparent'><a class='index' id='max_align_t'></a></span><span class='indexparent'><a class='index' id='nullptr_t'></a></span></p><pre class='codeblock'>
namespace std {
  using ptrdiff_t = <i><span class='texttt'>see below</span></i>;
  using size_t = <i><span class='texttt'>see below</span></i>;
  using max_align_t = <i><span class='texttt'>see below</span></i>;
  using nullptr_t = decltype(nullptr);
}

#define NULL <i><span class='texttt'>see below</span></i>
#define offsetof(P, D) <i><span class='texttt'>see below</span></i>
</pre></div><div id='cstdlib.syn'><h3 ><a class='secnum' href='#cstdlib.syn' style='min-width:103pt'>18.2.2</a> Header <span class='texttt'>&lt;cstdlib&gt;</span> synopsis <a class='abbr_ref' href='cstdlib.syn'>[cstdlib.syn]</a></h3><p ><span class='indexparent'><a class='index' id='cstdlib'></a></span><span class='indexparent'><a class='index' id='cstdlib'></a></span><span class='indexparent'><a class='index' id='EXIT_FAILURE'></a></span><span class='indexparent'><a class='index' id='EXIT_SUCCESS'></a></span><span class='indexparent'><a class='index' id='MB_CUR_MAX'></a></span><span class='indexparent'><a class='index' id='NULL'></a></span><span class='indexparent'><a class='index' id='RAND_MAX'></a></span><span class='indexparent'><a class='index' id='_Exit'></a></span><span class='indexparent'><a class='index' id='abort'></a></span><span class='indexparent'><a class='index' id='abs'></a></span><span class='indexparent'><a class='index' id='aligned_alloc'></a></span><span class='indexparent'><a class='index' id='at_quick_exit'></a></span><span class='indexparent'><a class='index' id='atexit'></a></span><span class='indexparent'><a class='index' id='atof'></a></span><span class='indexparent'><a class='index' id='atoi'></a></span><span class='indexparent'><a class='index' id='atol'></a></span><span class='indexparent'><a class='index' id='atoll'></a></span><span class='indexparent'><a class='index' id='bsearch'></a></span><span class='indexparent'><a class='index' id='calloc'></a></span><span class='indexparent'><a class='index' id='div'></a></span><span class='indexparent'><a class='index' id='div_t'></a></span><span class='indexparent'><a class='index' id='exit'></a></span><span class='indexparent'><a class='index' id='free'></a></span><span class='indexparent'><a class='index' id='getenv'></a></span><span class='indexparent'><a class='index' id='labs'></a></span><span class='indexparent'><a class='index' id='ldiv'></a></span><span class='indexparent'><a class='index' id='ldiv_t'></a></span><span class='indexparent'><a class='index' id='llabs'></a></span><span class='indexparent'><a class='index' id='lldiv'></a></span><span class='indexparent'><a class='index' id='lldiv_t'></a></span><span class='indexparent'><a class='index' id='malloc'></a></span><span class='indexparent'><a class='index' id='mblen'></a></span><span class='indexparent'><a class='index' id='mbstowcs'></a></span><span class='indexparent'><a class='index' id='mbtowc'></a></span><span class='indexparent'><a class='index' id='qsort'></a></span><span class='indexparent'><a class='index' id='quick_exit'></a></span><span class='indexparent'><a class='index' id='rand'></a></span><span class='indexparent'><a class='index' id='realloc'></a></span><span class='indexparent'><a class='index' id='size_t'></a></span><span class='indexparent'><a class='index' id='srand'></a></span><span class='indexparent'><a class='index' id='strtod'></a></span><span class='indexparent'><a class='index' id='strtof'></a></span><span class='indexparent'><a class='index' id='strtol'></a></span><span class='indexparent'><a class='index' id='strtold'></a></span><span class='indexparent'><a class='index' id='strtoll'></a></span><span class='indexparent'><a class='index' id='strtoul'></a></span><span class='indexparent'><a class='index' id='strtoull'></a></span><span class='indexparent'><a class='index' id='system'></a></span><span class='indexparent'><a class='index' id='wcstombs'></a></span><span class='indexparent'><a class='index' id='wctomb'></a></span></p><pre class='codeblock'>
namespace std {
  using size_t = <i><span class='texttt'>see below</span></i>;
  using div_t = <i><span class='texttt'>see below</span></i>;
  using ldiv_t = <i><span class='texttt'>see below</span></i>;
  using lldiv_t = <i><span class='texttt'>see below</span></i>;
}

#define NULL <i><span class='texttt'>see below</span></i>
#define EXIT_FAILURE <i><span class='texttt'>see below</span></i>
#define EXIT_SUCCESS <i><span class='texttt'>see below</span></i>
#define RAND_MAX <i><span class='texttt'>see below</span></i>
#define MB_CUR_MAX <i><span class='texttt'>see below</span></i>

namespace std {
  <span class='comment'>// Exposition-only function type aliases
</span>  extern "C" using <i>c-atexit-handler</i> = void();                        <span class='comment'>// <i>exposition only</i>
</span>  extern "C++" using <i>atexit-handler</i> = void();                        <span class='comment'>// <i>exposition only</i>
</span>  extern "C" using <i>c-compare-pred</i> = int(const void* , const void*);  <span class='comment'>// <i>exposition only</i>
</span>  extern "C++" using <i>compare-pred</i> = int(const void* , const void*);  <span class='comment'>// <i>exposition only</i>
</span>
  <span class='comment'>// <a href='support.start.term'>[support.start.term]</a>, start and termination
</span>  [[noreturn]] void abort() noexcept;
  int atexit(<i>c-atexit-handler</i>* func) noexcept;
  int atexit(<i>atexit-handler</i>* func) noexcept;
  int at_quick_exit(<i>c-atexit-handler</i>* func) noexcept;
  int at_quick_exit(<i>atexit-handler</i>* func) noexcept;
  [[noreturn]] void exit(int status);
  [[noreturn]] void _Exit(int status) noexcept;
  [[noreturn]] void quick_exit(int status) noexcept;

  char* getenv(const char* name);
  int system(const char* string);

  <span class='comment'>// <a href='c.malloc'>[c.malloc]</a>, C library memory allocation
</span>  void* aligned_alloc(size_t alignment, size_t size);
  void* calloc(size_t nmemb, size_t size);
  void free(void* ptr);
  void* malloc(size_t size);
  void* realloc(void* ptr, size_t size);

  double atof(const char* nptr);
  int atoi(const char* nptr);
  long int atol(const char* nptr);
  long long int atoll(const char* nptr);
  double strtod(const char* nptr, char** endptr);
  float strtof(const char* nptr, char** endptr);
  long double strtold(const char* nptr, char** endptr);
  long int strtol(const char* nptr, char** endptr, int base);
  long long int strtoll(const char* nptr, char** endptr, int base);
  unsigned long int strtoul(const char* nptr, char** endptr, int base);
  unsigned long long int strtoull(const char* nptr, char** endptr, int base);

  <span class='comment'>// <a href='c.mb.wcs'>[c.mb.wcs]</a>, multibyte / wide string and character conversion functions
</span>  int mblen(const char* s, size_t n);
  int mbtowc(wchar_t* pwc, const char* s, size_t n);
  int wctomb(char* s, wchar_t wchar);
  size_t mbstowcs(wchar_t* pwcs, const char* s, size_t n);
  size_t wcstombs(char* s, const wchar_t* pwcs, size_t n);

  <span class='comment'>// <a href='alg.c.library'>[alg.c.library]</a>, C standard library algorithms
</span>  void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
                <i>c-compare-pred</i>* compar);
  void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
                <i>compare-pred</i>* compar);
  void qsort(void* base, size_t nmemb, size_t size, <i>c-compare-pred</i>* compar);
  void qsort(void* base, size_t nmemb, size_t size, <i>compare-pred</i>* compar);

  <span class='comment'>// <a href='c.math.rand'>[c.math.rand]</a>, low-quality random number generation
</span>  int rand();
  void srand(unsigned int seed);

  <span class='comment'>// <a href='c.math.abs'>[c.math.abs]</a>, absolute values
</span>  int abs(int j);
  long int abs(long int j);
  long long int abs(long long int j);
  float abs(float j);
  double abs(double j);
  long double abs(long double j);

  long int labs(long int j);
  long long int llabs(long long int j);

  div_t div(int numer, int denom);
  ldiv_t div(long int numer, long int denom);             <span class='comment'>// see <a href='library.c'>[library.c]</a>
</span>  lldiv_t div(long long int numer, long long int denom);  <span class='comment'>// see <a href='library.c'>[library.c]</a>
</span>  ldiv_t ldiv(long int numer, long int denom);
  lldiv_t lldiv(long long int numer, long long int denom);
}
</pre><div class='para' id='cstdlib.syn-1'><div class='marginalizedparent'><a class='marginalized' href='#cstdlib.syn-1'>1</a></div><p >The contents and meaning of the header <span class='texttt'>&lt;cstdlib&gt;</span> are the same as
the C standard library header <span class='texttt'>&lt;stdlib.h&gt;</span>,
except that it does not declare the type <span class='texttt'>wchar_t</span>,
and except as noted in
<a href='support.types.nullptr'>[support.types.nullptr]</a>,
<a href='support.types.layout'>[support.types.layout]</a>,
<a href='support.start.term'>[support.start.term]</a>,
<a href='c.malloc'>[c.malloc]</a>,
<a href='c.mb.wcs'>[c.mb.wcs]</a>,
<a href='alg.c.library'>[alg.c.library]</a>,
<a href='c.math.rand'>[c.math.rand]</a>, and
<a href='c.math.abs'>[c.math.abs]</a>.
[&nbsp;<i>Note:</i>
Several functions have additional overloads in this International Standard,
but they have the same behavior as in the C standard library (<a href='library.c'>[library.c]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='textsc'>See also:</span> ISO C 7.22</p></div></div><div id='nullptr'><h3 ><a class='secnum' href='#nullptr' style='min-width:103pt'>18.2.3</a> Null pointers <a class='abbr_ref' href='support.types.nullptr'>[support.types.nullptr]</a></h3><div class='para' id='nullptr-1'><div class='marginalizedparent'><a class='marginalized' href='#nullptr-1'>1</a></div><p ><span class='indexparent'><a class='index' id='nullptr_t'></a></span>The type <span class='texttt'>nullptr_t</span> is a synonym
for the type of a <span class='texttt'>nullptr</span> expression, and it
has the characteristics
described in <a href='basic.fundamental'>[basic.fundamental]</a> and <a href='conv.ptr'>[conv.ptr]</a>.
[&nbsp;<i>Note:</i>
Although <span class='texttt'>nullptr</span>'s address cannot be taken, the address of another
<span class='texttt'>nullptr_t</span> object that is an lvalue can be taken.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='nullptr-2'><div class='marginalizedparent'><a class='marginalized' href='#nullptr-2'>2</a></div><p >The macro
<span class='indexparent'><a class='index' id='NULL'></a></span><span class='texttt'>NULL</span>
is an <span class='indexparent'><a class='index' id='definition_of_NULL'></a></span>implementation-defined null pointer constant.<a class='footnotenum' href='#footnote-187'>187</a></p></div><div class='footnote' id='footnote-187'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-187'>187)</a></div><p >Possible definitions include
<span class='texttt'>0</span>
and
<span class='texttt'>0L</span>,
but not
<span class='texttt'>(void*)0</span>.</p></div></div><div id='layout'><h3 ><a class='secnum' href='#layout' style='min-width:103pt'>18.2.4</a> Sizes, alignments, and offsets <a class='abbr_ref' href='support.types.layout'>[support.types.layout]</a></h3><div class='para' id='layout-1'><div class='marginalizedparent'><a class='marginalized' href='#layout-1'>1</a></div><p >The macro
<span class='indexparent'><a class='index' id='offsetof'></a></span><span class='texttt'>offsetof(<i>type</i>, <i>member-designator</i>)</span>
has the same semantics as the corresponding macro in
the C standard library header <span class='texttt'>&lt;stddef.h&gt;</span>, but
accepts a restricted set of <span class='texttt'><i>type</i></span>
arguments in this International Standard.
Use of the <span class='texttt'>offsetof</span> macro with a <span class='texttt'><i>type</i></span>
other than a standard-layout class (Clause <a href='class'>[class]</a>)
is conditionally-supported.<a class='footnotenum' href='#footnote-188'>188</a>
The expression <span class='texttt'>offsetof(<i>type</i>, <i>member-designator</i>)</span>
is never type-dependent (<a href='temp.dep.expr'>[temp.dep.expr]</a>) and it is
value-dependent (<a href='temp.dep.constexpr'>[temp.dep.constexpr]</a>) if and only if <span class='texttt'><i>type</i></span> is
dependent. The result of applying the <span class='texttt'>offsetof</span> macro to
a static data member or a function member is undefined.
No operation invoked by the <span class='texttt'>offsetof</span> macro shall throw an exception and
<span class='texttt'>noexcept(offsetof(<i>type</i>, <i>member-designator</i>))</span> shall be <span class='texttt'>true</span>.</p></div><div class='para' id='layout-2'><div class='marginalizedparent'><a class='marginalized' href='#layout-2'>2</a></div><p >The type <span class='texttt'>ptrdiff_t</span> is an
<span class='indexparent'><a class='index' id='type_of_ptrdiff_t'></a></span>implementation-defined
signed integer type that can
hold the difference of two subscripts in an array object, as described in <a href='expr.add'>[expr.add]</a>.</p></div><div class='para' id='layout-3'><div class='marginalizedparent'><a class='marginalized' href='#layout-3'>3</a></div><p >The type <span class='texttt'>size_t</span> is an
<span class='indexparent'><a class='index' id='type_of_size_t'></a></span>implementation-defined
unsigned integer type that is large enough
to contain the size in bytes of any object.</p></div><div class='para' id='layout-4'><div class='marginalizedparent'><a class='marginalized' href='#layout-4'>4</a></div><p >[&nbsp;<i>Note:</i>
It is recommended that implementations choose types for <span class='texttt'>ptrdiff_t</span> and <span class='texttt'>size_t</span>
whose integer conversion ranks (<a href='conv.rank'>[conv.rank]</a>) are no greater than that of
<span class='texttt'>signed long int</span> unless a larger size is necessary to contain all the possible values.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='layout-5'><div class='marginalizedparent'><a class='marginalized' href='#layout-5'>5</a></div><p >The type
<span class='indexparent'><a class='index' id='max_align_t'></a></span><span class='texttt'>max_align_t</span> is a POD type whose alignment requirement
is at least as great as that of every scalar type, and whose alignment
requirement is supported in every context.</p><p ><span class='textsc'>See also:</span> Alignment (<a href='basic.align'>[basic.align]</a>), Sizeof (<a href='expr.sizeof'>[expr.sizeof]</a>), Additive
operators (<a href='expr.add'>[expr.add]</a>), Free store (<a href='class.free'>[class.free]</a>), and ISO C 7.19.</p></div><div class='footnote' id='footnote-188'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-188'>188)</a></div><p >Note that <span class='texttt'>offsetof</span>
is required to work as specified even if unary
<span class='texttt'>operator&amp;</span>
is overloaded for any of the types involved.</p></div></div></div></div></body></html>