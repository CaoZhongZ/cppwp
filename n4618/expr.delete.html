<!DOCTYPE html><html lang='en'><head><title>[expr.delete]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>5.3</a> Unary expressions <a class='abbr_ref' href='expr.unary#expr.delete'>[expr.unary]</a></h2><div id='expr.delete'><h3 ><a class='secnum' style='min-width:103pt'>5.3.5</a> Delete <a class='abbr_ref'>[expr.delete]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='expression,delete'></a></span><span class='indexparent'><a class='index' id='delete'></a></span>The <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> operator destroys a most derived
object (<a href='intro.object'>[intro.object]</a>) or array created by a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.</p><pre class='bnf'><a id='nt:delete-expression'>delete-expression:</a>
    <span class='terminal'>::</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>delete</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
    <span class='terminal'>::</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>delete [ ]</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i></pre><p >The first alternative is for non-array objects, and the second is for arrays. Whenever
the <span class='texttt'>delete</span> keyword is immediately followed by empty square brackets, it shall be
interpreted as the second alternative.<a class='footnotenum' href='#footnote-81'>81</a>
The operand shall be of pointer to object type or of class type. If of
class type, the operand is contextually implicitly converted
(Clause <a href='conv'>[conv]</a>) to a pointer to object
type.<a class='footnotenum' href='#footnote-82'>82</a>
The <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>'s result has type
<span class='texttt'>void</span>.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='delete,object'></a></span>If the operand has a class type, the operand is converted to a pointer
type by calling the above-mentioned conversion function, and the
converted operand is used in place of the original operand for the
remainder of this section.
<span class='indexparent'><a class='index' id='object,delete'></a></span>In the first alternative
(<a class='hidden_link' href='#def:delete_object' id='def:delete_object'><i>delete object</i></a>), the value of the operand of <span class='texttt'>delete</span> may
be a null pointer value, a pointer to a non-array object
created by a previous <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>,
or a pointer to a
subobject (<a href='intro.object'>[intro.object]</a>) representing a base class of such an
object (Clause <a href='class.derived'>[class.derived]</a>). If not, the behavior is undefined.
<span class='indexparent'><a class='index' id='array,delete'></a></span><span class='indexparent'><a class='index' id='delete,array'></a></span>In the second alternative (<a class='hidden_link' href='#def:delete_array' id='def:delete_array'><i>delete array</i></a>), the value of the
operand of <span class='texttt'>delete</span>
may be a null pointer value or a pointer value
that resulted from
a previous array <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.<a class='footnotenum' href='#footnote-83'>83</a>
If not, the behavior is undefined.
[&nbsp;<i>Note:</i>
This means that the syntax of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> must
match the type of the object allocated by <span class='texttt'>new</span>, not the syntax of the
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i>
a pointer to a <span class='texttt'>const</span> type can be the operand of a
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>; it is not necessary to cast away the
constness (<a href='expr.const.cast'>[expr.const.cast]</a>) of the pointer expression before it is
used as the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='delete,undefined'></a></span>In the first alternative (<a class='hidden_link' href='#def:delete_object' id='def:delete_object'><i>delete object</i></a>), if the static type of
the object to be deleted is different from its dynamic type, the static type shall be
a base class of the dynamic type of the object to be deleted and the static type shall
have a virtual destructor or the behavior is undefined. In the second
alternative (<a class='hidden_link' href='#def:delete_array' id='def:delete_array'><i>delete array</i></a>) if the dynamic type of the object to
be deleted differs from its static type, the behavior is undefined.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i> in a <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> shall
be evaluated exactly once.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='type,incomplete'></a></span>If the object being deleted has incomplete class type at the point of
deletion and the complete class has a non-trivial destructor or a
deallocation function, the behavior is undefined.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='delete,destructor_and'></a></span>If the value of the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is not a
null pointer value, the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> will invoke the
destructor (if any) for the object or the elements of the array being
deleted. In the case of an array, the elements will be destroyed in
order of decreasing address (that is, in reverse order of the completion
of their constructor; see <a href='class.base.init'>[class.base.init]</a>).</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >If the value of the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is not a
null pointer value, then:</p><ul class='itemize'><li id='7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.1'>(7.1)</a></div><p >If the allocation call for the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> for the object to
be deleted was not omitted and the allocation was not extended (<a href='expr.new'>[expr.new]</a>), the
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> shall call a deallocation
function (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>). The value returned from the
allocation call of the <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> shall be passed as the
first argument to the deallocation function.</p></li><li id='7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.2'>(7.2)</a></div><p >Otherwise, if the allocation was extended or was provided by extending the
allocation of another <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>, and the
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> for every other pointer value produced by a
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> that had storage provided by the extended
<i ><a href='expr.new#nt:new-expression'>new-expression</a></i> has been evaluated, the
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> shall call a deallocation function. The value
returned from the allocation call of the extended <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>
shall be passed as the first argument to the deallocation function.</p></li><li id='7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.3'>(7.3)</a></div><p >Otherwise, the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> will not call a
deallocation function.
</p></li></ul><p >[&nbsp;<i>Note:</i>
The deallocation function is called regardless of whether the destructor
for the object or some element of the array throws an exception.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If the value of the operand of the <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is a
null pointer value, it is unspecified whether a deallocation function will be
called as described above.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >[&nbsp;<i>Note:</i>
An implementation provides default definitions of the global
deallocation functions <span class='texttt'>operator delete()</span> for
non-arrays (<a href='new.delete.single'>[new.delete.single]</a>) and
<span class='indexparent'><a class='index' id='operator_'></a></span><span class='indexparent'><a class='index' id='operator_delete'></a></span><span class='texttt'>operator delete[]()</span> for arrays (<a href='new.delete.array'>[new.delete.array]</a>). A C++
program can provide alternative definitions of these
functions (<a href='replacement.functions'>[replacement.functions]</a>), and/or class-specific
versions (<a href='class.free'>[class.free]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >When the keyword <span class='texttt'>delete</span> in a <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> is
preceded by the unary <span class='texttt'>::</span> operator, the deallocation function's name is looked
up in global scope. Otherwise, the lookup considers class-specific deallocation
functions (<a href='class.free'>[class.free]</a>). If no class-specific deallocation function is found,
the deallocation function's name is looked up in global scope.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >If deallocation function lookup finds more than one usual
deallocation function,
the function to be called is selected as follows:
</p><ul class='itemize'><li id='10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.1'>(10.1)</a></div><p >If the type has new-extended alignment,
a function with a parameter of type <span class='texttt'>std::align_val_t</span> is preferred;
otherwise a function without such a parameter is preferred.
If exactly one preferred function is found,
that function is selected and the selection process terminates.
If more than one preferred function is found,
all non-preferred functions are eliminated from further consideration.
</p></li><li id='10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.2'>(10.2)</a></div><p >If the deallocation functions have class scope,
the one without a parameter of type <span class='texttt'>std::size_t</span> is selected.
</p></li><li id='10.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.3'>(10.3)</a></div><p >If the type is complete and if, for the second alternative (delete
array) only, the operand is a pointer to a class type with a
non-trivial destructor or a (possibly multi-dimensional) array thereof,
the function with a parameter of type <span class='texttt'>std::size_t</span> is selected.
</p></li><li id='10.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.4'>(10.4)</a></div><p >Otherwise, it is unspecified
whether a deallocation function with a parameter of type <span class='texttt'>std::size_t</span>
is selected.
</p></li></ul></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >When a <i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i>
is executed, the selected deallocation function shall be called with
the address of the block of storage to be reclaimed as its first argument.
If a deallocation function
with a parameter of type <span class='texttt'>std::align_val_t</span>
is used,
the alignment of the type of the object to be deleted
is passed as the corresponding argument.
If a deallocation function
with a parameter of type <span class='texttt'>std::size_t</span>
is used,
the size of the block
is passed as the corresponding argument.<a class='footnotenum' href='#footnote-84'>84</a></p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >Access and ambiguity control are done for both the deallocation function
and the destructor (<a href='class.dtor'>[class.dtor]</a>, <a href='class.free'>[class.free]</a>).</p></div><div class='footnote' id='footnote-81'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-81'>81)</a></div><p >A lambda expression with a
<i ><a href='expr.prim.lambda#nt:lambda-introducer'>lambda-introducer</a></i> that consists of
empty square brackets can follow the <span class='texttt'>delete</span> keyword if the lambda expression is
enclosed in parentheses.</p></div><div class='footnote' id='footnote-82'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-82'>82)</a></div><p >This implies that an object
cannot be deleted using a pointer of type
<span class='texttt'>void*</span> because <span class='texttt'>void</span> is not an object type.</p></div><div class='footnote' id='footnote-83'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-83'>83)</a></div><p >For nonzero-length
arrays, this is the same as a pointer to the first
element of the array created by that <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>.
Zero-length arrays do not have a first element.</p></div><div class='footnote' id='footnote-84'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-84'>84)</a></div><p >If the static type of the object to be deleted is complete
and is different from the dynamic type, and the destructor is not virtual, the size might
be incorrect, but that case is already undefined, as stated above.</p></div></div></div></body></html>