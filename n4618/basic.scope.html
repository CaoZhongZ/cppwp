<!DOCTYPE html><html lang='en'><head><title>[basic.scope]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><div id='basic.scope'><h2 ><a class='secnum' style='min-width:88pt'>3.3</a> Scope <a class='abbr_ref'>[basic.scope]</a></h2><p ><span class='indexparent'><a class='index' id='scope'></a></span></p><div id='declarative'><h3 ><a class='secnum' href='#declarative' style='min-width:103pt'>3.3.1</a> Declarative regions and scopes <a class='abbr_ref' href='basic.scope.declarative'>[basic.scope.declarative]</a></h3><p ><span class='indexparent'><a class='index' id='scope,declarations_and'></a></span></p><div class='para' id='declarative-1'><div class='marginalizedparent'><a class='marginalized' href='#declarative-1'>1</a></div><p ><span class='indexparent'><a class='index' id='name,scope_of'></a></span>Every name is introduced in some portion of program text called a
<span class='indexparent'><a class='index' id='region,declarative'></a></span><span class='indexparent'><a class='index' id='scope,potential'></a></span><a class='hidden_link' href='#def:declarative_region' id='def:declarative_region'><i>declarative region</i></a>, which is the largest part of the program
in which that name is <a class='hidden_link' href='#def:valid' id='def:valid'><i>valid</i></a>, that is, in which that name may
be used as an unqualified name to refer to the same entity. In general,
each particular name is valid only within some possibly discontiguous
portion of program text called its <a class='hidden_link' href='#def:scope' id='def:scope'><i>scope</i></a>. To determine the
scope of a declaration, it is sometimes convenient to refer to the
<a class='hidden_link' href='#def:potential_scope' id='def:potential_scope'><i>potential scope</i></a> of a declaration. The scope of a declaration
is the same as its potential scope unless the potential scope contains
another declaration of the same name. In that case, the potential scope
of the declaration in the inner (contained) declarative region is
excluded from the scope of the declaration in the outer (containing)
declarative region.</p></div><div class='para' id='declarative-2'><div class='marginalizedparent'><a class='marginalized' href='#declarative-2'>2</a></div><p >[&nbsp;<i>Example:</i>
in</p><pre class='codeblock'>
int j = 24;
int main() {
  int i = j, j;
  j = 42;
}
</pre><p >the identifier <span class='texttt'>j</span> is declared twice as a name (and used twice).
The declarative region of the first <span class='texttt'>j</span> includes the entire
example. The potential scope of the first <span class='texttt'>j</span> begins immediately
after that <span class='texttt'>j</span> and extends to the end of the program, but its
(actual) scope excludes the text between the <span class='texttt'>,</span> and the
<span class='texttt'>}</span>. The declarative region of the second declaration of
<span class='texttt'>j</span> (the <span class='texttt'>j</span> immediately before the semicolon) includes all
the text between <span class='texttt'>{</span> and <span class='texttt'>}</span>, but its potential scope
excludes the declaration of <span class='texttt'>i</span>. The scope of the second
declaration of <span class='texttt'>j</span> is the same as its potential scope.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='declarative-3'><div class='marginalizedparent'><a class='marginalized' href='#declarative-3'>3</a></div><p >The names declared by a declaration are introduced into the scope in
which the declaration occurs, except that the presence of a
<span class='texttt'>friend</span> specifier (<a href='class.friend'>[class.friend]</a>), certain uses of the
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> (<a href='dcl.type.elab'>[dcl.type.elab]</a>), and
<i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> (<a href='namespace.udir'>[namespace.udir]</a>) alter this general
behavior.</p></div><div class='para' id='declarative-4'><div class='marginalizedparent'><a class='marginalized' href='#declarative-4'>4</a></div><p >Given a set of declarations in a single declarative region, each of
which specifies the same unqualified name,
</p><ul class='itemize'><li id='declarative-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#declarative-4.1'>(4.1)</a></div><p >they shall all refer to the same entity, or all refer to functions
and function templates; or
</p></li><li id='declarative-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#declarative-4.2'>(4.2)</a></div><p >exactly one declaration shall declare a class name or enumeration
name that is not a typedef name and the other declarations shall
all refer to the same variable, non-static data member, or enumerator,
or all refer to functions and function templates;
in this case the class name or enumeration name is
hidden (<a href='basic.scope.hiding'>[basic.scope.hiding]</a>). [&nbsp;<i>Note:</i> A namespace name or a
class template name must be unique in its declarative
region (<a href='namespace.alias'>[namespace.alias]</a>, Clause <a href='temp'>[temp]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >[&nbsp;<i>Note:</i> These restrictions apply to the declarative region into which
a name is introduced, which is not necessarily the same as the region in
which the declaration occurs. In particular,
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifiers</a></i> (<a href='dcl.type.elab'>[dcl.type.elab]</a>) and
friend declarations (<a href='class.friend'>[class.friend]</a>) may introduce a (possibly not
visible) name into an enclosing namespace; these restrictions apply to
that region. Local extern declarations (<a href='basic.link'>[basic.link]</a>) may introduce
a name into the declarative region where the declaration appears and
also introduce a (possibly not visible) name into an enclosing
namespace; these restrictions apply to both regions. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='declarative-5'><div class='marginalizedparent'><a class='marginalized' href='#declarative-5'>5</a></div><p >[&nbsp;<i>Note:</i> The name lookup rules are summarized in <a href='basic.lookup'>[basic.lookup]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='pdecl'><h3 ><a class='secnum' href='#pdecl' style='min-width:103pt'>3.3.2</a> Point of declaration <a class='abbr_ref' href='basic.scope.pdecl'>[basic.scope.pdecl]</a></h3><div class='para' id='pdecl-1'><div class='marginalizedparent'><a class='marginalized' href='#pdecl-1'>1</a></div><p ><span class='indexparent'><a class='index' id='name,point_of_declaration'></a></span>The <a class='hidden_link' href='#def:point_of_declaration' id='def:point_of_declaration'><i>point of declaration</i></a> for a name is immediately after its
complete declarator (Clause <a href='dcl.decl'>[dcl.decl]</a>) and before its
<i ><a href='dcl.init#nt:initializer'>initializer</a></i> (if any), except as noted below. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
unsigned char x = 12;{ unsigned char x = x; }
</pre><p >Here the second <span class='texttt'>x</span> is initialized with its own (indeterminate)
value. <i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='pdecl-2'><div class='marginalizedparent'><a class='marginalized' href='#pdecl-2'>2</a></div><p >[&nbsp;<i>Note:</i>
<span class='indexparent'><a class='index' id='name_hiding'></a></span>a name from an outer scope remains visible up
to the point of declaration of the name that hides it. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
const int  i = 2;{ int  i[i]; }
</pre><p >declares a block-scope array of two integers. <i>&nbsp;—&nbsp;end example</i>&nbsp;] <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='pdecl-3'><div class='marginalizedparent'><a class='marginalized' href='#pdecl-3'>3</a></div><p >The point of declaration for a class or class template first declared by a
<i ><a href='class#nt:class-specifier'>class-specifier</a></i> is immediately after the <i ><a href='lex.name#nt:identifier'>identifier</a></i> or
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> (if any) in its <i ><a href='class#nt:class-head'>class-head</a></i>
(Clause <a href='class'>[class]</a>). The point of declaration for an enumeration is
immediately after the <i ><a href='lex.name#nt:identifier'>identifier</a></i> (if any) in either its
<i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i> (<a href='dcl.enum'>[dcl.enum]</a>) or its first
<i ><a href='dcl.enum#nt:opaque-enum-declaration'>opaque-enum-declaration</a></i> (<a href='dcl.enum'>[dcl.enum]</a>), whichever comes first.
The point of declaration of an alias or alias template immediately
follows the <i ><a href='dcl.name#nt:type-id'>type-id</a></i> to which the
alias refers.</p></div><div class='para' id='pdecl-4'><div class='marginalizedparent'><a class='marginalized' href='#pdecl-4'>4</a></div><p >The point of declaration of a <i ><a href='namespace.udecl#nt:using-declarator'>using-declarator</a></i> that does not name a
constructor is immediately after the <i ><a href='namespace.udecl#nt:using-declarator'>using-declarator</a></i> (<a href='namespace.udecl'>[namespace.udecl]</a>).</p></div><div class='para' id='pdecl-5'><div class='marginalizedparent'><a class='marginalized' href='#pdecl-5'>5</a></div><p ><span class='indexparent'><a class='index' id='declaration,enumerator_point_of'></a></span>The point of declaration for an enumerator is immediately after its
<i ><a href='dcl.enum#nt:enumerator-definition'>enumerator-definition</a></i>. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
const int x = 12;{ enum { x = x }; }
</pre><p >Here, the enumerator <span class='texttt'>x</span> is initialized with the value of the
constant <span class='texttt'>x</span>, namely 12. <i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='pdecl-6'><div class='marginalizedparent'><a class='marginalized' href='#pdecl-6'>6</a></div><p >After the point of declaration of a class member, the member name can be
looked up in the scope of its class. [&nbsp;<i>Note:</i>
<span class='indexparent'><a class='index' id='type,incomplete'></a></span>this is true even if the class is an incomplete class. For example,</p><pre class='codeblock'>
struct X {
  enum E { z = 16 };
  int b[X::z];      <span class='comment'>// OK
</span>};
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='pdecl-7'><div class='marginalizedparent'><a class='marginalized' href='#pdecl-7'>7</a></div><p >The point of declaration of a class first declared in an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> is as follows:
</p><ul class='itemize'><li id='pdecl-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#pdecl-7.1'>(7.1)</a></div><p >for a declaration of the form</p><pre class='bnf'><i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span></pre><p >the <i ><a href='lex.name#nt:identifier'>identifier</a></i> is declared to be a
<i ><a href='class#nt:class-name'>class-name</a></i> in the scope that contains the declaration,
otherwise
</p></li><li id='pdecl-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#pdecl-7.2'>(7.2)</a></div><p >for an <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> of the form</p><pre class='bnf'><i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><p >if the
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> is used in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> or <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i>
of a function defined in namespace scope, the <i ><a href='lex.name#nt:identifier'>identifier</a></i> is
declared as a <i ><a href='class#nt:class-name'>class-name</a></i> in the namespace that contains the
declaration; otherwise, except as a friend declaration, the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> is declared in the smallest namespace or block
scope that contains the declaration. [&nbsp;<i>Note:</i>
These rules also apply within templates. <i>&nbsp;—&nbsp;end note</i>&nbsp;] [&nbsp;<i>Note:</i> Other
forms of <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> do not declare a new name,
and therefore must refer to an existing <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>.
See <a href='basic.lookup.elab'>[basic.lookup.elab]</a> and <a href='dcl.type.elab'>[dcl.type.elab]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div><div class='para' id='pdecl-8'><div class='marginalizedparent'><a class='marginalized' href='#pdecl-8'>8</a></div><p >The point of declaration for an
<span class='grammarterm'>injected-class-name</span> (Clause <a href='class'>[class]</a>) is immediately following
the opening brace of the class definition.</p></div><div class='para' id='pdecl-9'><div class='marginalizedparent'><a class='marginalized' href='#pdecl-9'>9</a></div><p >The point of declaration for a function-local predefined
variable (<a href='dcl.fct.def'>[dcl.fct.def]</a>) is immediately before the
<i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> of a function definition.</p></div><div class='para' id='pdecl-10'><div class='marginalizedparent'><a class='marginalized' href='#pdecl-10'>10</a></div><p >The point of declaration for a template parameter is immediately after its complete
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
typedef unsigned char T;
template&lt;class T
  = T     <span class='comment'>// lookup finds the typedef name of <span class='texttt'>unsigned char</span>
</span>  , T     <span class='comment'>// lookup finds the template parameter
</span>    N = 0&gt; struct A { };
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='pdecl-11'><div class='marginalizedparent'><a class='marginalized' href='#pdecl-11'>11</a></div><p >[&nbsp;<i>Note:</i> Friend declarations refer to functions or classes that are
members of the nearest enclosing namespace, but they do not introduce
new names into that namespace (<a href='namespace.memdef'>[namespace.memdef]</a>). Function
declarations at block scope and variable declarations with the
<span class='texttt'>extern</span> specifier at block scope refer to declarations that are
members of an enclosing namespace, but they do not introduce new names
into that scope.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='pdecl-12'><div class='marginalizedparent'><a class='marginalized' href='#pdecl-12'>12</a></div><p >[&nbsp;<i>Note:</i> For point of instantiation of a template,
see <a href='temp.point'>[temp.point]</a>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]<span class='indexparent'><a class='index' id='scope,declarations_and'></a></span></p></div></div><div id='block'><h3 ><a class='secnum' href='#block' style='min-width:103pt'>3.3.3</a> Block scope <a class='abbr_ref' href='basic.scope.block'>[basic.scope.block]</a></h3><div class='para' id='block-1'><div class='marginalizedparent'><a class='marginalized' href='#block-1'>1</a></div><p ><span class='indexparent'><a class='index' id='scope,block'></a></span><span class='indexparent'><a class='index' id='local_scope'></a></span>A name declared in a block (<a href='stmt.block'>[stmt.block]</a>) is local to that block; it has
<a class='hidden_link' href='#def:block_scope' id='def:block_scope'><i>block scope</i></a>.
Its potential scope begins at its point of
declaration (<a href='basic.scope.pdecl'>[basic.scope.pdecl]</a>) and ends at the end of its block.
A variable declared at block scope is a <a class='hidden_link' href='#def:local_variable' id='def:local_variable'><i>local variable</i></a>.</p></div><div class='para' id='block-2'><div class='marginalizedparent'><a class='marginalized' href='#block-2'>2</a></div><p ><span class='indexparent'><a class='index' id='parameter,scope_of'></a></span>The potential scope of a function parameter name
(including one appearing in a 
<i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i>)
or of a function-local predefined variable
in a function
definition (<a href='dcl.fct.def'>[dcl.fct.def]</a>) begins at its point of declaration. If
the function has a <i ><a href='except#nt:function-try-block'>function-try-block</a></i> the potential scope of
a parameter
or of a function-local predefined variable
ends at the end of the last associated handler, otherwise it ends
at the end of the outermost block of the function definition. A
parameter name shall not be redeclared in the outermost block of the
function definition nor in the outermost block of any handler associated
with a <i ><a href='except#nt:function-try-block'>function-try-block</a></i>.</p></div><div class='para' id='block-3'><div class='marginalizedparent'><a class='marginalized' href='#block-3'>3</a></div><p ><span class='indexparent'><a class='index' id='scope,exception_declaration'></a></span>The name declared in an <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i>
is local to the
<i ><a href='except#nt:handler'>handler</a></i> and shall not be redeclared in the outermost block of the
<i ><a href='except#nt:handler'>handler</a></i>.</p></div><div class='para' id='block-4'><div class='marginalizedparent'><a class='marginalized' href='#block-4'>4</a></div><p >Names declared in the <i ><a href='stmt.stmt#nt:init-statement'>init-statement</a></i>, the <i ><a href='stmt.iter#nt:for-range-declaration'>for-range-declaration</a></i>, and in the
<i ><a href='stmt.stmt#nt:condition'>condition</a></i> of <span class='texttt'>if</span>, <span class='texttt'>while</span>, <span class='texttt'>for</span>, and
<span class='texttt'>switch</span> statements are local to the <span class='texttt'>if</span>, <span class='texttt'>while</span>,
<span class='texttt'>for</span>, or <span class='texttt'>switch</span> statement (including the controlled
statement), and shall not be redeclared in a subsequent condition of
that statement nor in the outermost block (or, for the <span class='texttt'>if</span>
statement, any of the outermost blocks) of the controlled statement;
see <a href='stmt.select'>[stmt.select]</a>.</p></div></div><div id='proto'><h3 ><a class='secnum' href='#proto' style='min-width:103pt'>3.3.4</a> Function prototype scope <a class='abbr_ref' href='basic.scope.proto'>[basic.scope.proto]</a></h3><div class='para' id='proto-1'><div class='marginalizedparent'><a class='marginalized' href='#proto-1'>1</a></div><p ><span class='indexparent'><a class='index' id='scope,function_prototype'></a></span><span class='indexparent'><a class='index' id='function_prototype'></a></span>In a function declaration, or in any function declarator except the
declarator of a function definition (<a href='dcl.fct.def'>[dcl.fct.def]</a>), names of
parameters (if supplied) have function prototype scope, which terminates
at the end of the nearest enclosing function declarator.</p></div></div><div id='basic.funscope'><h3 ><a class='secnum' href='#basic.funscope' style='min-width:103pt'>3.3.5</a> Function scope <a class='abbr_ref' href='basic.funscope'>[basic.funscope]</a></h3><div class='para' id='basic.funscope-1'><div class='marginalizedparent'><a class='marginalized' href='#basic.funscope-1'>1</a></div><p ><span class='indexparent'><a class='index' id='label,scope_of'></a></span>Labels (<a href='stmt.label'>[stmt.label]</a>) have <a class='hidden_link' href='#def:scope,function' id='def:scope,function'><i>function scope</i></a> and
may be used anywhere in the function in which they are declared. Only
labels have function scope.</p></div></div><div id='namespace'><h3 ><a class='secnum' href='#namespace' style='min-width:103pt'>3.3.6</a> Namespace scope <a class='abbr_ref' href='basic.scope.namespace'>[basic.scope.namespace]</a></h3><div class='para' id='namespace-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace-1'>1</a></div><p ><span class='indexparent'><a class='index' id='scope,namespace'></a></span>The declarative region of a <i ><a href='namespace.def#nt:namespace-definition'>namespace-definition</a></i> is its
<i ><a href='namespace.def#nt:namespace-body'>namespace-body</a></i>.  Entities declared in a
<i ><a href='namespace.def#nt:namespace-body'>namespace-body</a></i> are said to be <a class='hidden_link' href='#def:members' id='def:members'><i>members</i></a> of the
namespace, and names introduced by these declarations into the
declarative region of the namespace are said to be <a class='hidden_link' href='#def:member_names' id='def:member_names'><i>member
names</i></a> of the namespace. A namespace member name has namespace scope.
Its potential scope includes its namespace from the name's point of
declaration (<a href='basic.scope.pdecl'>[basic.scope.pdecl]</a>) onwards; and for each
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> (<a href='namespace.udir'>[namespace.udir]</a>) that nominates the
member's namespace, the member's potential scope includes that portion
of the potential scope of the <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> that follows
the member's point of declaration. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace N {
  int i;
  int g(int a) { return a; }
  int j();
  void q();
}
namespace { int l=1; }
<span class='comment'>// the potential scope of <span class='texttt'>l</span> is from its point of declaration
</span><span class='comment'>// to the end of the translation unit
</span>
namespace N {
  int g(char a) {   <span class='comment'>// overloads <span class='texttt'>N::g(int)</span>
</span>    return l+a;     <span class='comment'>// <span class='texttt'>l</span> is from unnamed namespace
</span>  }

  int i;            <span class='comment'>// error: duplicate definition
</span>  int j();          <span class='comment'>// OK: duplicate function declaration
</span>
  int j() {         <span class='comment'>// OK: definition of <span class='texttt'>N::j()</span>
</span>    return g(i);    <span class='comment'>// calls <span class='texttt'>N::g(int)</span>
</span>  }
  int q();          <span class='comment'>// error: different return type
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace-2'><div class='marginalizedparent'><a class='marginalized' href='#namespace-2'>2</a></div><p >A namespace member can also be referred to after the <span class='texttt'>::</span> scope
resolution operator (<a href='expr.prim'>[expr.prim]</a>) applied to the name of its
namespace or the name of a namespace which nominates the member's
namespace in a <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i>; see <a href='namespace.qual'>[namespace.qual]</a>.</p></div><div class='para' id='namespace-3'><div class='marginalizedparent'><a class='marginalized' href='#namespace-3'>3</a></div><p ><span class='indexparent'><a class='index' id='scope,global_namespace'></a></span><span class='indexparent'><a class='index' id='scope,global'></a></span>The outermost declarative region of a translation unit is also a
namespace, called the <a class='hidden_link' href='#def:global_namespace' id='def:global_namespace'><i>global namespace</i></a>. A name declared in
the global namespace has <a class='hidden_link' href='#def:global_namespace_scope' id='def:global_namespace_scope'><i>global namespace scope</i></a> (also called
<a class='hidden_link' href='#def:global_scope' id='def:global_scope'><i>global scope</i></a>). The potential scope of such a name begins at
its point of declaration (<a href='basic.scope.pdecl'>[basic.scope.pdecl]</a>) and ends at the end
of the translation unit that is its declarative region.
<span class='indexparent'><a class='index' id='name,global'></a></span>A name with global namespace scope is said to be a
<a class='hidden_link' href='#def:global' id='def:global'><i>global name</i></a>.</p></div></div><div id='class'><h3 ><a class='secnum' href='#class' style='min-width:103pt'>3.3.7</a> Class scope <a class='abbr_ref' href='basic.scope.class'>[basic.scope.class]</a></h3><p ><span class='indexparent'><a class='index' id='scope,class'></a></span>
</p><div class='para' id='class-1'><div class='marginalizedparent'><a class='marginalized' href='#class-1'>1</a></div><p >The potential scope of a name declared in a class consists not
only of the declarative region following the name's point of
declaration, but also of all function bodies, default arguments,
<i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifiers</a></i>, and
<span class='grammarterm'>brace-or-equal-initializers</span> of non-static data members
in that class (including such
things in nested classes).</p></div><div class='para' id='class-2'><div class='marginalizedparent'><a class='marginalized' href='#class-2'>2</a></div><p >A name <span class='texttt'>N</span> used in a class <span class='texttt'>S</span> shall refer to the same
declaration in its context and when re-evaluated in the completed scope
of <span class='texttt'>S</span>. No diagnostic is required for a violation of this rule.</p></div><div class='para' id='class-3'><div class='marginalizedparent'><a class='marginalized' href='#class-3'>3</a></div><p >A name declared within a member function hides a declaration of
the same name whose scope extends to or past the end of the member
function's class.</p></div><div class='para' id='class-4'><div class='marginalizedparent'><a class='marginalized' href='#class-4'>4</a></div><p >The potential scope of a declaration that extends to or past the
end of a class definition also extends to the regions defined by its
member definitions, even if the members are defined lexically outside
the class (this includes static data member definitions, nested class
definitions, and member function definitions, including the member function
body and any portion of the
declarator part of such definitions which follows the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i>,
including a <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> and any default
arguments (<a href='dcl.fct.default'>[dcl.fct.default]</a>)).</p></div><div class='para' id='class-5'><div class='marginalizedparent'><a class='marginalized' href='#class-5'>5</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
typedef int  c;
enum { i = 1 };

class X {
  char  v[i];                       <span class='comment'>// error: <span class='texttt'>i</span> refers to <span class='texttt'>::i</span>
</span>                                    <span class='comment'>// but when reevaluated is <span class='texttt'>X::i</span>
</span>  int  f() { return sizeof(c); }    <span class='comment'>// OK: <span class='texttt'>X::c</span>
</span>  char  c;
  enum { i = 2 };
};

typedef char*  T;
struct Y {
  T  a;                             <span class='comment'>// error: <span class='texttt'>T</span> refers to <span class='texttt'>::T</span>
</span>                                    <span class='comment'>// but when reevaluated is <span class='texttt'>Y::T</span>
</span>  typedef long  T;
  T  b;
};

typedef int I;
class D {
  typedef I I;                      <span class='comment'>// error, even though no reordering involved
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class-6'><div class='marginalizedparent'><a class='marginalized' href='#class-6'>6</a></div><p >The name of a class member shall only be used as follows:
</p><ul class='itemize'><li id='class-6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class-6.1'>(6.1)</a></div><p >in the scope of its class (as described above) or a class derived
(Clause <a href='class.derived'>[class.derived]</a>) from its class,
</p></li><li id='class-6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class-6.2'>(6.2)</a></div><p >after the <span class='texttt'>.</span> operator applied to an expression of the type
of its class (<a href='expr.ref'>[expr.ref]</a>) or a class derived from its class,
</p></li><li id='class-6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class-6.3'>(6.3)</a></div><p >after the <span class='texttt'>-&gt;</span> operator applied to a pointer to an object of
its class (<a href='expr.ref'>[expr.ref]</a>) or a class derived from its class,
</p></li><li id='class-6.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#class-6.4'>(6.4)</a></div><p >after the <span class='texttt'>::</span> scope resolution operator (<a href='expr.prim'>[expr.prim]</a>)
applied to the name of its class or a class derived from its class.
</p></li></ul></div></div><div id='enum'><h3 ><a class='secnum' href='#enum' style='min-width:103pt'>3.3.8</a> Enumeration scope <a class='abbr_ref' href='basic.scope.enum'>[basic.scope.enum]</a></h3><p ><span class='indexparent'><a class='index' id='enumeration_scope'></a></span><span class='indexparent'><a class='index' id='scope,enumeration'></a></span></p><div class='para' id='enum-1'><div class='marginalizedparent'><a class='marginalized' href='#enum-1'>1</a></div><p >The name of a scoped enumerator (<a href='dcl.enum'>[dcl.enum]</a>) has
<a class='hidden_link' href='#def:enumeration_scope' id='def:enumeration_scope'><i>enumeration scope</i></a>. Its potential scope begins at
its point of declaration and terminates at the end of the
<i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i>.</p></div></div><div id='temp'><h3 ><a class='secnum' href='#temp' style='min-width:103pt'>3.3.9</a> Template parameter scope <a class='abbr_ref' href='basic.scope.temp'>[basic.scope.temp]</a></h3><p ><span class='indexparent'><a class='index' id='template_parameter_scope'></a></span><span class='indexparent'><a class='index' id='scope,template_parameter'></a></span>
</p><div class='para' id='temp-1'><div class='marginalizedparent'><a class='marginalized' href='#temp-1'>1</a></div><p >The declarative region of the name of a template parameter of a template
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> is the smallest <i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i>
in which the name was introduced.</p></div><div class='para' id='temp-2'><div class='marginalizedparent'><a class='marginalized' href='#temp-2'>2</a></div><p >The declarative region of the name of a template parameter of a template is the smallest
<i ><a href='temp#nt:template-declaration'>template-declaration</a></i> in which the name was introduced. Only template
parameter names belong to this declarative region; any other kind of name introduced by
the <i ><a href='dcl.dcl#nt:declaration'>declaration</a></i> of a <i ><a href='temp#nt:template-declaration'>template-declaration</a></i> is instead
introduced into the same declarative region where it would be introduced as a result of
a non-template declaration of the same name. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace N {
  template&lt;class T&gt; struct A { };               <span class='comment'>// #1
</span>  template&lt;class U&gt; void f(U) { }               <span class='comment'>// #2
</span>  struct B {
    template&lt;class V&gt; friend int g(struct C*);  <span class='comment'>// #3
</span>  };
}
</pre><p >The declarative regions of <span class='texttt'>T</span>, <span class='texttt'>U</span> and <span class='texttt'>V</span> are the
<i ><a href='temp#nt:template-declaration'>template-declarations</a></i> on lines <span class='texttt'>#1</span>, <span class='texttt'>#2</span> and <span class='texttt'>#3</span>,
respectively. But the names <span class='texttt'>A</span>, <span class='texttt'>f</span>, <span class='texttt'>g</span> and <span class='texttt'>C</span> all belong to
the same declarative region — namely, the <i ><a href='namespace.def#nt:namespace-body'>namespace-body</a></i> of <span class='texttt'>N</span>.
(<span class='texttt'>g</span> is still considered to belong to this declarative region in spite of its
being hidden during qualified and unqualified name lookup.)
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp-3'><div class='marginalizedparent'><a class='marginalized' href='#temp-3'>3</a></div><p >The potential scope of a template parameter name begins at its point of
declaration (<a href='basic.scope.pdecl'>[basic.scope.pdecl]</a>) and ends at the end of its declarative region.
[&nbsp;<i>Note:</i> This implies that a <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> can be used in the
declaration of subsequent <i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i> and their default
arguments but cannot be used in preceding <i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i> or their
default arguments. For example,</p><pre class='codeblock'>
template&lt;class T, T* p, class U = T&gt; class X { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; void f(T* p = new T);
</pre><p >This also implies that a <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> can be used in the
specification of base classes. For example,</p><pre class='codeblock'>
template&lt;class T&gt; class X : public Array&lt;T&gt; { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; class Y : public T { <span class='comment'>/* ... */</span> };
</pre><p >The use of a template parameter as a base class implies that a class used as a template
argument must be defined and not just declared when the class template is instantiated.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp-4'><div class='marginalizedparent'><a class='marginalized' href='#temp-4'>4</a></div><p >The declarative region of the name of a template parameter is nested within the
immediately-enclosing declarative region. [&nbsp;<i>Note:</i> As a result, a
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> hides any entity with the same name in an enclosing
scope (<a href='basic.scope.hiding'>[basic.scope.hiding]</a>). [&nbsp;<i>Example:</i></p><pre class='codeblock'>
typedef int N;
template&lt;N X, typename N, template&lt;N Y&gt; class T&gt; struct A;
</pre><p >Here, <span class='texttt'>X</span> is a non-type template parameter of type <span class='texttt'>int</span> and <span class='texttt'>Y</span> is a
non-type template parameter of the same type as the second template parameter of
<span class='texttt'>A</span>. <i>&nbsp;—&nbsp;end example</i>&nbsp;]<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp-5'><div class='marginalizedparent'><a class='marginalized' href='#temp-5'>5</a></div><p >[&nbsp;<i>Note:</i> Because the name of a template parameter cannot be redeclared within its
potential scope (<a href='temp.local'>[temp.local]</a>), a template parameter's scope is often its potential
scope. However, it is still possible for a template parameter name to be hidden;
see <a href='temp.local'>[temp.local]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='hiding'><h3 ><a class='secnum' href='#hiding' style='min-width:103pt'>3.3.10</a> Name hiding <a class='abbr_ref' href='basic.scope.hiding'>[basic.scope.hiding]</a></h3><div class='para' id='hiding-1'><div class='marginalizedparent'><a class='marginalized' href='#hiding-1'>1</a></div><p ><span class='indexparent'><a class='index' id='scope_name_hiding_and'></a></span><span class='indexparent'><a class='index' id='name_hiding'></a></span><span class='indexparent'><a class='index' id='hiding'></a></span>A name can be hidden by an explicit declaration of that same name in a
nested declarative region or derived class (<a href='class.member.lookup'>[class.member.lookup]</a>).</p></div><div class='para' id='hiding-2'><div class='marginalizedparent'><a class='marginalized' href='#hiding-2'>2</a></div><p ><span class='indexparent'><a class='index' id='name_hiding'></a></span>A class name (<a href='class.name'>[class.name]</a>) or enumeration name (<a href='dcl.enum'>[dcl.enum]</a>) can
be hidden by the name of a variable, data member, function, or enumerator declared in
the same scope. If a class or enumeration name and a variable, data member, function,
or enumerator are declared in the same scope (in any order) with the
same name, the class or enumeration name is hidden wherever the variable, data member,
function, or enumerator name is visible.</p></div><div class='para' id='hiding-3'><div class='marginalizedparent'><a class='marginalized' href='#hiding-3'>3</a></div><p >In a member function definition, the declaration of a name
at block scope
hides
the declaration of a member of the class with the same name;
see <a href='basic.scope.class'>[basic.scope.class]</a>. The declaration of a member in a derived
class (Clause <a href='class.derived'>[class.derived]</a>) hides the declaration of a member of
a base class of the same name; see <a href='class.member.lookup'>[class.member.lookup]</a>.</p></div><div class='para' id='hiding-4'><div class='marginalizedparent'><a class='marginalized' href='#hiding-4'>4</a></div><p >During the lookup of a name qualified by a namespace name, declarations
that would otherwise be made visible by a <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> can
be hidden by declarations with the same name in the namespace containing
the <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i>; see <a href='namespace.qual'>[namespace.qual]</a>.</p></div><div class='para' id='hiding-5'><div class='marginalizedparent'><a class='marginalized' href='#hiding-5'>5</a></div><p ><span class='indexparent'><a class='index' id='visibility'></a></span>If a name is in scope and is not hidden it is said to be <a class='hidden_link' href='#def:visible' id='def:visible'><i>visible</i></a>.<span class='indexparent'><a class='index' id='scope'></a></span></p></div></div></div></div></body></html>