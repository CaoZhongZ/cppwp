<!DOCTYPE html><html lang='en'><head><title>[namespace.qual]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>3.4</a> Name lookup <a class='abbr_ref' href='basic.lookup#namespace.qual'>[basic.lookup]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>3.4.3</a> Qualified name lookup <a class='abbr_ref' href='basic.lookup.qual#namespace.qual'>[basic.lookup.qual]</a></h3><div id='namespace.qual'><h4 ><a class='secnum' style='min-width:118pt'>3.4.3.2</a> Namespace members <a class='abbr_ref'>[namespace.qual]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='lookup,namespace_member'></a></span>If the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> of a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
nominates a namespace (including the case where the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> is <span class='texttt'>::</span>, i.e., nominating
the global namespace), the name specified after the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> is looked up in the scope of the
namespace.
The names in a <i ><a href='temp.names#nt:template-argument'>template-argument</a></i> of a
<i ><a href='temp.names#nt:template-id'>template-id</a></i> are looked up in the context in which the
entire <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> occurs.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >For a namespace <span class='texttt'>X</span> and name <span class='texttt'>m</span>, the namespace-qualified lookup set
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> is defined as follows: Let <span class='math'><span class='mathalpha'>S</span>'(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> be the set of all
declarations of <span class='texttt'>m</span> in <span class='texttt'>X</span> and the inline namespace set of
<span class='texttt'>X</span> (<a href='namespace.def'>[namespace.def]</a>). If <span class='math'><span class='mathalpha'>S</span>'(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> is not empty, <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span>
is <span class='math'><span class='mathalpha'>S</span>'(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span>; otherwise, <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> is the union of <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>N</span><sub ><span class='mathalpha'>i</span></sub>, <span class='mathalpha'>m</span>)</span> for
all namespaces <span class='math'><span class='mathalpha'>N</span><sub ><span class='mathalpha'>i</span></sub></span> nominated by <span class='grammarterm'>using-directives</span> in
<span class='texttt'>X</span> and its inline namespace set.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >Given <span class='texttt'>X::m</span> (where <span class='texttt'>X</span> is a user-declared namespace), or
given <span class='texttt'>::m</span> (where X is the global namespace), if
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> is the empty set, the program is ill-formed. Otherwise, if
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> has exactly one member, or if the context of the reference is
a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> (<a href='namespace.udecl'>[namespace.udecl]</a>), <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span>
is the
required set of declarations of <span class='texttt'>m</span>. Otherwise if the use of
<span class='texttt'>m</span> is not one that allows a unique declaration to be chosen from
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span>, the program is ill-formed. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
int x;
namespace Y {
  void f(float);
  void h(int);
}

namespace Z {
  void h(double);
}

namespace A {
  using namespace Y;
  void f(int);
  void g(int);
  int i;
}

namespace B {
  using namespace Z;
  void f(char);
  int i;
}

namespace AB {
  using namespace A;
  using namespace B;
  void g();
}

void h(){
  AB::g();          <span class='comment'>// <span class='texttt'>g</span> is declared directly in <span class='texttt'>AB,</span>
</span>                    <span class='comment'>// therefore <span class='texttt'>S</span> is { <span class='texttt'>AB::g()</span> } and <span class='texttt'>AB::g()</span> is chosen
</span>  AB::f(1);         <span class='comment'>// <span class='texttt'>f</span> is not declared directly in <span class='texttt'>AB</span> so the rules are
</span>                    <span class='comment'>// applied recursively to <span class='texttt'>A</span> and <span class='texttt'>B;</span>
</span>                    <span class='comment'>// namespace <span class='texttt'>Y</span> is not searched and <span class='texttt'>Y::f(float)</span>
</span>                    <span class='comment'>// is not considered;
</span>                    <span class='comment'>// <span class='texttt'>S</span> is { <span class='texttt'>A::f(int)</span>, <span class='texttt'>B::f(char)</span> } and overload
</span>                    <span class='comment'>// resolution chooses <span class='texttt'>A::f(int)</span>
</span>  AB::f('c');       <span class='comment'>// as above but resolution chooses <span class='texttt'>B::f(char)</span>
</span>
  AB::x++;          <span class='comment'>// <span class='texttt'>x</span> is not declared directly in <span class='texttt'>AB</span>, and
</span>                    <span class='comment'>// is not declared in <span class='texttt'>A</span> or <span class='texttt'>B</span> , so the rules are
</span>                    <span class='comment'>// applied recursively to <span class='texttt'>Y</span> and <span class='texttt'>Z</span>,
</span>                    <span class='comment'>// <span class='texttt'>S</span> is { } so the program is ill-formed
</span>  AB::i++;          <span class='comment'>// <span class='texttt'>i</span> is not declared directly in <span class='texttt'>AB</span> so the rules are
</span>                    <span class='comment'>// applied recursively to <span class='texttt'>A</span> and <span class='texttt'>B</span>,
</span>                    <span class='comment'>// <span class='texttt'>S</span> is { <span class='texttt'>A::i</span> , <span class='texttt'>B::i</span> } so the use is ambiguous
</span>                    <span class='comment'>// and the program is ill-formed
</span>  AB::h(16.8);      <span class='comment'>// <span class='texttt'>h</span> is not declared directly in <span class='texttt'>AB</span> and
</span>                    <span class='comment'>// not declared directly in <span class='texttt'>A</span> or <span class='texttt'>B</span> so the rules are
</span>                    <span class='comment'>// applied recursively to <span class='texttt'>Y</span> and <span class='texttt'>Z</span>,
</span>                    <span class='comment'>// <span class='texttt'>S</span> is { <span class='texttt'>Y::h(int)</span>, <span class='texttt'>Z::h(double)</span> } and overload
</span>                    <span class='comment'>// resolution chooses <span class='texttt'>Z::h(double)</span>
</span>}
</pre></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The same declaration found more than once is not an ambiguity (because
it is still a unique declaration). For example:</p><pre class='codeblock'>
namespace A {
  int a;
}

namespace B {
  using namespace A;
}

namespace C {
  using namespace A;
}

namespace BC {
  using namespace B;
  using namespace C;
}

void f(){
  BC::a++;          <span class='comment'>// OK: <span class='texttt'>S</span> is { <span class='texttt'>A::a</span>, <span class='texttt'>A::a</span> }
</span>}

namespace D {
  using A::a;
}

namespace BD {
  using namespace B;
  using namespace D;
}

void g(){
  BD::a++;          <span class='comment'>// OK: S is { <span class='texttt'> A::a</span>, <span class='texttt'> A::a</span> }
</span>}
</pre></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >Because each referenced namespace is searched at most once, the
following is well-defined:</p><pre class='codeblock'>
namespace B {
  int b;
}

namespace A {
  using namespace B;
  int a;
}

namespace B {
  using namespace A;
}

void f(){
  A::a++;           <span class='comment'>// OK: <span class='texttt'>a</span> declared directly in <span class='texttt'>A</span>, <span class='texttt'>S</span> is {<span class='texttt'>A::a</span>}
</span>  B::a++;           <span class='comment'>// OK: both <span class='texttt'>A</span> and <span class='texttt'>B</span> searched (once), <span class='texttt'>S</span> is {<span class='texttt'>A::a</span>}
</span>  A::b++;           <span class='comment'>// OK: both <span class='texttt'>A</span> and <span class='texttt'>B</span> searched (once), <span class='texttt'>S</span> is {<span class='texttt'>B::b</span>}
</span>  B::b++;           <span class='comment'>// OK: <span class='texttt'>b</span> declared directly in <span class='texttt'>B</span>, <span class='texttt'>S</span> is {<span class='texttt'>B::b</span>}
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >During the lookup of a qualified namespace member name, if the lookup
finds more than one declaration of the member, and if one declaration
introduces a class name or enumeration name and the other declarations
either introduce the same variable, the same enumerator or a set of
functions, the non-type name hides the class or enumeration name if and
only if the declarations are from the same namespace; otherwise (the
declarations are from different namespaces), the program is ill-formed.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace A {
  struct x { };
  int x;
  int y;
}

namespace B {
  struct y { };
}

namespace C {
  using namespace A;
  using namespace B;
  int i = C::x;     <span class='comment'>// OK, <span class='texttt'>A::x</span> (of type <span class='texttt'>int</span> )
</span>  int j = C::y;     <span class='comment'>// ambiguous, <span class='texttt'>A::y</span> or <span class='texttt'>B::y</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >In a declaration for a namespace member in which the
<i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> is a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>, given that the
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> for the namespace member has the form</p><pre class='bnf'><i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i></pre><p >the
<i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> shall name a member of the namespace
designated by the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
or of an element of the inline namespace set (<a href='namespace.def'>[namespace.def]</a>) of that namespace.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace A {
  namespace B {
    void f1(int);
  }
  using namespace B;
}
void A::f1(int){ }  <span class='comment'>// ill-formed, <span class='texttt'>f1</span> is not a member of <span class='texttt'>A</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;] However, in such namespace member declarations, the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> may rely on <i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i>
to implicitly provide the initial part of the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
namespace A {
  namespace B {
    void f1(int);
  }
}

namespace C {
  namespace D {
    void f1(int);
  }
}

using namespace A;
using namespace C::D;
void B::f1(int){ }  <span class='comment'>// OK, defines <span class='texttt'>A::B::f1(int)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<span class='indexparent'><a class='index' id='lookup,qualified_name'></a></span>
</p></div></div></div></body></html>