<!DOCTYPE html><html lang='en'><head><title>[thread]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='thread'><h1 ><a class='secnum' style='min-width:73pt'>30</a> Thread support library <a class='abbr_ref' href='./#thread'>[thread]</a></h1><div id='general'><h2 ><a class='secnum' href='#general' style='min-width:88pt'>30.1</a> General <a class='abbr_ref' href='thread.general'>[thread.general]</a></h2><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p >The following subclauses describe components to create and manage
threads (<a href='intro.multithread'>[intro.multithread]</a>), perform mutual exclusion, and communicate conditions
and values
between threads, as summarized in Table <a href='#tab:thread.lib.summary'>[tab:thread.lib.summary]</a>.</p><div class='numberedTable' id='tab:thread.lib.summary'>Table <a href='#tab:thread.lib.summary'>135</a> — Thread support library summary<br><table ><tr class='rowsep'><td colspan='2' class='center'><b>Subclause</b></td><td class='left'>	<b>Header(s)</b>	</td></tr><tr class='capsep'><td class='left'> 


<a href='thread.req'>[thread.req]</a>      </td><td class='left'> Requirements          </td><td class='left'>                               </td></tr><tr class='rowsep'><td class='left'> 
<a href='thread.threads'>[thread.threads]</a>  </td><td class='left'> Threads               </td><td class='left'> <span class='texttt'>&lt;thread&gt;</span>              </td></tr><tr class='rowsep'><td class='left'> 
<a href='thread.mutex'>[thread.mutex]</a>    </td><td class='left'> Mutual exclusion      </td><td class='left'> <span class='texttt'>&lt;mutex&gt;</span>               </td></tr><tr ><td class='left'>
                      </td><td class='left'>                       </td><td class='left'> <span class='texttt'>&lt;shared_mutex&gt;</span>        </td></tr><tr class='rowsep'><td class='left'> 
<a href='thread.condition'>[thread.condition]</a></td><td class='left'> Condition variables   </td><td class='left'> <span class='texttt'>&lt;condition_variable&gt;</span>  </td></tr><tr class='rowsep'><td class='left'> 
<a href='futures'>[futures]</a>         </td><td class='left'> Futures               </td><td class='left'> <span class='texttt'>&lt;future&gt;</span>              </td></tr></table></div></div></div><div id='req'><h2 ><a class='secnum' href='#req' style='min-width:88pt'>30.2</a> Requirements <a class='abbr_ref' href='thread.req'>[thread.req]</a></h2><div id='req.paramname'><h3 ><a class='secnum' href='#req.paramname' style='min-width:103pt'>30.2.1</a> Template parameter names <a class='abbr_ref' href='thread.req.paramname'>[thread.req.paramname]</a></h3><div class='para' id='req.paramname-1'><div class='marginalizedparent'><a class='marginalized' href='#req.paramname-1'>1</a></div><p >Throughout this Clause, the names of template parameters are used to express type
requirements.
If a template parameter is named <span class='texttt'>Predicate</span>, <span class='texttt'>operator()</span> applied to
the template argument shall return a value that is convertible to <span class='texttt'>bool</span>.</p></div></div><div id='req.exception'><h3 ><a class='secnum' href='#req.exception' style='min-width:103pt'>30.2.2</a> Exceptions <a class='abbr_ref' href='thread.req.exception'>[thread.req.exception]</a></h3><div class='para' id='req.exception-1'><div class='marginalizedparent'><a class='marginalized' href='#req.exception-1'>1</a></div><p >Some functions described in this Clause are specified to throw exceptions of type
<span class='texttt'>system_error</span> (<a href='syserr.syserr'>[syserr.syserr]</a>). Such exceptions shall be thrown if
any of the function's error conditions is detected or
a call to
an operating system or other underlying API results in an error that prevents the
library function from
meeting its specifications. Failure to allocate storage shall be reported as described
in <a href='res.on.exception.handling'>[res.on.exception.handling]</a>.</p><p >[&nbsp;<i>Example:</i><span class='space'></span>
Consider a function in this clause that is specified to throw exceptions of type
<span class='texttt'>system_error</span> and specifies error conditions that include
<span class='texttt'>operation_not_permitted</span> for a thread that does not have the privilege to
perform the operation. Assume that, during the execution of this function, an <span class='texttt'>errno</span>
of <span class='texttt'>EPERM</span> is reported by a POSIX API call used by the implementation. Since POSIX
specifies an <span class='texttt'>errno</span> of <span class='texttt'>EPERM</span> when “the caller does not have the privilege
to perform the operation”, the implementation maps <span class='texttt'>EPERM</span> to an
<span class='texttt'>error_condition</span> of <span class='texttt'>operation_not_permitted</span> (<a href='syserr'>[syserr]</a>) and an exception
of type <span class='texttt'>system_error</span> is thrown.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='req.exception-2'><div class='marginalizedparent'><a class='marginalized' href='#req.exception-2'>2</a></div><p >The <span class='texttt'>error_code</span> reported by such an exception's <span class='texttt'>code()</span> member function
shall compare equal to one of the conditions specified in the function's error condition
element.</p></div></div><div id='req.native'><h3 ><a class='secnum' href='#req.native' style='min-width:103pt'>30.2.3</a> Native handles <a class='abbr_ref' href='thread.req.native'>[thread.req.native]</a></h3><div class='para' id='req.native-1'><div class='marginalizedparent'><a class='marginalized' href='#req.native-1'>1</a></div><p >Several classes described in this Clause have members <span class='texttt'>native_handle_type</span> and
<span class='texttt'>native_handle</span>. The presence of these members and their semantics is
<span class='indexparent'><a class='index' id='presence_and_meaning_of_native_handle_type_and_native_handle'></a></span>implementation-defined.
[&nbsp;<i>Note:</i><span class='space'></span> These members allow implementations to provide access
to implementation details. Their names are specified to facilitate portable compile-time
detection. Actual use of these members is inherently non-portable. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='req.timing'><h3 ><a class='secnum' href='#req.timing' style='min-width:103pt'>30.2.4</a> Timing specifications <a class='abbr_ref' href='thread.req.timing'>[thread.req.timing]</a></h3><div class='para' id='req.timing-1'><div class='marginalizedparent'><a class='marginalized' href='#req.timing-1'>1</a></div><p >Several functions described in this Clause take an argument to specify a timeout. These
timeouts are specified as either a <span class='texttt'>duration</span> or a <span class='texttt'>time_point</span> type as
specified in <a href='time'>[time]</a>.</p></div><div class='para' id='req.timing-2'><div class='marginalizedparent'><a class='marginalized' href='#req.timing-2'>2</a></div><p >Implementations necessarily have some delay in returning from a timeout. Any overhead in
interrupt response, function return, and scheduling induces a “quality of implementation”
delay, expressed as duration <span class='math'><span class='mathalpha'>D</span><sub ><span class='mathalpha'>i</span></sub></span>. Ideally, this delay would be zero. Further, any contention for
processor and memory resources induces a “quality of management” delay, expressed as duration
<span class='math'><span class='mathalpha'>D</span><sub ><span class='mathalpha'>m</span></sub></span>. The delay durations may vary from timeout to timeout, but in all cases shorter is better.</p></div><div class='para' id='req.timing-3'><div class='marginalizedparent'><a class='marginalized' href='#req.timing-3'>3</a></div><p >The member functions whose names end in <span class='texttt'>_for</span> take an argument that
specifies a duration. These functions produce relative timeouts. Implementations
should use a steady clock to measure time for these functions.<a class='footnotenum' href='#footnote-333'>333</a> Given a duration
argument <span class='math'><span class='mathalpha'>D</span><sub ><span class='mathalpha'>t</span></sub></span>, the real-time duration of the timeout is <span class='math'><span class='mathalpha'>D</span><sub ><span class='mathalpha'>t</span></sub> + <span class='mathalpha'>D</span><sub ><span class='mathalpha'>i</span></sub> + <span class='mathalpha'>D</span><sub ><span class='mathalpha'>m</span></sub></span>.</p></div><div class='para' id='req.timing-4'><div class='marginalizedparent'><a class='marginalized' href='#req.timing-4'>4</a></div><p >The member functions whose names end in <span class='texttt'>_until</span> take an argument that specifies a time
point. These functions produce absolute timeouts. Implementations should use the clock
specified in the time point to measure time for these functions. Given a clock time point
argument <span class='math'><span class='mathalpha'>C</span><sub ><span class='mathalpha'>t</span></sub></span>, the clock time point of the return from timeout should be <span class='math'><span class='mathalpha'>C</span><sub ><span class='mathalpha'>t</span></sub> + <span class='mathalpha'>D</span><sub ><span class='mathalpha'>i</span></sub> + <span class='mathalpha'>D</span><sub ><span class='mathalpha'>m</span></sub></span>
when the clock is not adjusted during the timeout. If the clock is adjusted to the time <span class='math'><span class='mathalpha'>C</span><sub ><span class='mathalpha'>a</span></sub></span>
during the timeout, the behavior should be as follows:</p><ul ><li ><p >if <span class='math'><span class='mathalpha'>C</span><sub ><span class='mathalpha'>a</span></sub> &gt; <span class='mathalpha'>C</span><sub ><span class='mathalpha'>t</span></sub></span>, the waiting function should wake as soon as possible, i.e. <span class='math'><span class='mathalpha'>C</span><sub ><span class='mathalpha'>a</span></sub> + <span class='mathalpha'>D</span><sub ><span class='mathalpha'>i</span></sub> + <span class='mathalpha'>D</span><sub ><span class='mathalpha'>m</span></sub></span>,
since the timeout is already satisfied. [&nbsp;<i>Note:</i><span class='space'></span> This specification may result in the total
duration of the wait decreasing when measured against a steady clock. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li ><p >if <span class='math'><span class='mathalpha'>C</span><sub ><span class='mathalpha'>a</span></sub> &lt;= <span class='mathalpha'>C</span><sub ><span class='mathalpha'>t</span></sub></span>, the waiting function should not time out until <span class='texttt'>Clock::now()</span> returns a
time <span class='math'><span class='mathalpha'>C</span><sub ><span class='mathalpha'>n</span></sub> &gt;= <span class='mathalpha'>C</span><sub ><span class='mathalpha'>t</span></sub></span>, i.e. waking at <span class='math'><span class='mathalpha'>C</span><sub ><span class='mathalpha'>t</span></sub> + <span class='mathalpha'>D</span><sub ><span class='mathalpha'>i</span></sub> + <span class='mathalpha'>D</span><sub ><span class='mathalpha'>m</span></sub></span>. [&nbsp;<i>Note:</i><span class='space'></span> When the clock is adjusted
backwards, this specification may result in the total duration of the wait increasing when
measured against a steady clock. When the clock is adjusted forwards, this specification may
result in the total duration of the wait decreasing when measured against a steady clock.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >An implementation shall return from such a timeout at any point from the time specified above to
the time it would return from a steady-clock relative timeout on the difference between <span class='math'><span class='mathalpha'>C</span><sub ><span class='mathalpha'>t</span></sub></span>
and the time point of the call to the <span class='texttt'>_until</span> function. [&nbsp;<i>Note:</i><span class='space'></span> Implementations
should decrease the duration of the wait when the clock is adjusted forwards.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='req.timing-5'><div class='marginalizedparent'><a class='marginalized' href='#req.timing-5'>5</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> If the clock is not synchronized with a steady clock, e.g., a CPU time clock, these
timeouts might not provide useful functionality. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='req.timing-6'><div class='marginalizedparent'><a class='marginalized' href='#req.timing-6'>6</a></div><p >The resolution of timing provided by an implementation depends on both operating system
and hardware. The finest resolution provided by an implementation is called the
<a class='hidden_link' href='#def:native_resolution' id='def:native_resolution'><i>native resolution</i></a>.</p></div><div class='para' id='req.timing-7'><div class='marginalizedparent'><a class='marginalized' href='#req.timing-7'>7</a></div><p >Implementation-provided clocks that are used for these functions shall meet the
<span class='texttt'>TrivialClock</span> requirements (<a href='time.clock.req'>[time.clock.req]</a>).</p></div><div class='para' id='req.timing-8'><div class='marginalizedparent'><a class='marginalized' href='#req.timing-8'>8</a></div><p >A function that takes an argument which specifies a timeout will throw if,
during its execution, a clock, time point, or time duration throws an exception.
Such exceptions are referred to as <a class='hidden_link' href='#def:timeout-related_exceptions' id='def:timeout-related_exceptions'><i>timeout-related exceptions</i></a>.
[&nbsp;<i>Note:</i><span class='space'></span> instantiations of clock, time point and duration types supplied by
the implementation as specified in <a href='time.clock'>[time.clock]</a> do not throw exceptions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-333'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-333'>333)</a></div><p >All
implementations for which standard time units are meaningful must necessarily
have a steady clock within their hardware implementation.</p></div></div><div id='req.lockable'><h3 ><a class='secnum' href='#req.lockable' style='min-width:103pt'>30.2.5</a> Requirements for Lockable types <a class='abbr_ref' href='thread.req.lockable'>[thread.req.lockable]</a></h3><div id='req.lockable.general'><h4 ><a class='secnum' href='#req.lockable.general' style='min-width:118pt'>30.2.5.1</a> In general <a class='abbr_ref' href='thread.req.lockable.general'>[thread.req.lockable.general]</a></h4><div class='para' id='req.lockable.general-1'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.general-1'>1</a></div><p >An <a class='hidden_link' href='#def:execution_agent' id='def:execution_agent'><i>execution agent</i></a> is an entity such as a thread that may perform work in parallel with
other execution agents. [&nbsp;<i>Note:</i><span class='space'></span> Implementations or users may introduce other kinds of
agents such as processes or thread-pool tasks. <i>&nbsp;—&nbsp;end note</i>&nbsp;] The calling agent is determined by
context, e.g. the calling thread that contains the call, and so on.</p></div><div class='para' id='req.lockable.general-2'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.general-2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Some lockable objects are “agent oblivious” in that they work for any
execution agent model because they do not determine or store the agent's ID (e.g., an
ordinary spin lock). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='req.lockable.general-3'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.general-3'>3</a></div><p >The standard library templates <span class='texttt'>unique_lock</span> (<a href='thread.lock.unique'>[thread.lock.unique]</a>),
<span class='texttt'>lock_guard</span> (<a href='thread.lock.guard'>[thread.lock.guard]</a>), <span class='texttt'>lock</span>,
<span class='texttt'>try_lock</span> (<a href='thread.lock.algorithm'>[thread.lock.algorithm]</a>), and
<span class='texttt'>condition_variable_any</span> (<a href='thread.condition.condvarany'>[thread.condition.condvarany]</a>) all operate on user-supplied
lockable objects. The <span class='texttt'>BasicLockable</span> requirements, the <span class='texttt'>Lockable</span> requirements,
and the <span class='texttt'>TimedLockable</span> requirements list the requirements imposed by these library types
in order to acquire or release ownership of a <span class='texttt'>lock</span> by a given execution agent.
[&nbsp;<i>Note:</i><span class='space'></span> The nature of any lock ownership and any synchronization it may entail are not part
of these requirements. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='req.lockable.basic'><h4 ><a class='secnum' href='#req.lockable.basic' style='min-width:118pt'>30.2.5.2</a> <span class='texttt'>BasicLockable</span> requirements <a class='abbr_ref' href='thread.req.lockable.basic'>[thread.req.lockable.basic]</a></h4><div class='para' id='req.lockable.basic-1'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.basic-1'>1</a></div><p >A type <span class='texttt'>L</span> meets the <span class='texttt'>BasicLockable</span> requirements if the following expressions are
well-formed and have the specified semantics (<span class='texttt'>m</span> denotes a value of type <span class='texttt'>L</span>).</p><p ><code class='itemdecl'>
m.lock()
</code></p></div><div class='itemdescr'></div><div class='para' id='req.lockable.basic-2'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.basic-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Blocks until a lock can be acquired for the current execution agent. If an exception
is thrown then a lock shall not have been acquired for the current execution agent.
</p></div></div><p ><code class='itemdecl'>
m.unlock()
</code></p><div class='itemdescr'></div><div class='para' id='req.lockable.basic-3'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.basic-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> The current execution agent shall hold a lock on <span class='texttt'>m</span>.</p></div></div><div class='para' id='req.lockable.basic-4'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.basic-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Releases a lock on <span class='texttt'>m</span> held by the current execution agent.</p></div></div><div class='para' id='req.lockable.basic-5'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.basic-5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div></div><div id='req.lockable.req'><h4 ><a class='secnum' href='#req.lockable.req' style='min-width:118pt'>30.2.5.3</a> <span class='texttt'>Lockable</span> requirements <a class='abbr_ref' href='thread.req.lockable.req'>[thread.req.lockable.req]</a></h4><div class='para' id='req.lockable.req-1'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.req-1'>1</a></div><p >A type <span class='texttt'>L</span> meets the <span class='texttt'>Lockable</span> requirements if it meets the <span class='texttt'>BasicLockable</span>
requirements and the following expressions are well-formed and have the specified semantics
(<span class='texttt'>m</span> denotes a value of type <span class='texttt'>L</span>).</p><p ><code class='itemdecl'>
m.try_lock()
</code></p></div><div class='itemdescr'></div><div class='para' id='req.lockable.req-2'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.req-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Attempts to acquire a lock for the current execution agent without blocking. If an
exception is thrown then a lock shall not have been acquired for the current execution agent.</p></div></div><div class='para' id='req.lockable.req-3'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.req-3'>3</a></div><div class='itemdescr'><p ><i>Return type:</i> <span class='texttt'>bool</span>.</p></div></div><div class='para' id='req.lockable.req-4'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.req-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the lock was acquired, <span class='texttt'>false</span> otherwise.
</p></div></div></div><div id='req.lockable.timed'><h4 ><a class='secnum' href='#req.lockable.timed' style='min-width:118pt'>30.2.5.4</a> <span class='texttt'>TimedLockable</span> requirements <a class='abbr_ref' href='thread.req.lockable.timed'>[thread.req.lockable.timed]</a></h4><div class='para' id='req.lockable.timed-1'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.timed-1'>1</a></div><p >A type <span class='texttt'>L</span> meets the <span class='texttt'>TimedLockable</span> requirements if it meets the <span class='texttt'>Lockable</span>
requirements and the following expressions are well-formed and have the specified semantics
(<span class='texttt'>m</span> denotes a value of type <span class='texttt'>L</span>, <span class='texttt'>rel_time</span> denotes a value of an
instantiation of <span class='texttt'>duration</span> (<a href='time.duration'>[time.duration]</a>), and <span class='texttt'>abs_time</span> denotes a value
of an instantiation of <span class='texttt'>time_point</span> (<a href='time.point'>[time.point]</a>)).</p><p ><code class='itemdecl'>
m.try_lock_for(rel_time)
</code></p></div><div class='itemdescr'></div><div class='para' id='req.lockable.timed-2'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.timed-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Attempts to acquire a lock for the current execution agent within the relative
timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>rel_time</span>. The function shall not return
within the timeout specified by <span class='texttt'>rel_time</span> unless it has obtained a lock on <span class='texttt'>m</span>
for the current execution agent. If an exception is thrown then a lock shall not have been
acquired for the current execution agent.</p></div></div><div class='para' id='req.lockable.timed-3'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.timed-3'>3</a></div><div class='itemdescr'><p ><i>Return type:</i> <span class='texttt'>bool</span>.</p></div></div><div class='para' id='req.lockable.timed-4'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.timed-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the lock was acquired, <span class='texttt'>false</span> otherwise.
</p></div></div><p ><code class='itemdecl'>
m.try_lock_until(abs_time)
</code></p><div class='itemdescr'></div><div class='para' id='req.lockable.timed-5'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.timed-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Attempts to acquire a lock for the current execution agent before the absolute
timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span>. The function shall not return
before the timeout specified by <span class='texttt'>abs_time</span> unless it has obtained a lock on <span class='texttt'>m</span> for
the current execution agent. If an exception is thrown then a lock shall not have been acquired
for the current execution agent.</p></div></div><div class='para' id='req.lockable.timed-6'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.timed-6'>6</a></div><div class='itemdescr'><p ><i>Return type:</i> <span class='texttt'>bool</span>.</p></div></div><div class='para' id='req.lockable.timed-7'><div class='marginalizedparent'><a class='marginalized' href='#req.lockable.timed-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the lock was acquired, <span class='texttt'>false</span> otherwise.
</p></div></div></div></div><div id='decaycopy'><h3 ><a class='secnum' href='#decaycopy' style='min-width:103pt'>30.2.6</a> <span class='texttt'>decay_copy</span> <a class='abbr_ref' href='thread.decaycopy'>[thread.decaycopy]</a></h3><div class='para' id='decaycopy-1'><div class='marginalizedparent'><a class='marginalized' href='#decaycopy-1'>1</a></div><p >In several places in this Clause the operation
<span class='indexparent'><a class='index' id='DECAY_COPY'></a></span><span class='indexparent'><a class='index' id='DECAY_COPY'></a></span>such uses mean call the function <span class='texttt'>decay_copy(x)</span> and use the
result, where <span class='texttt'>decay_copy</span> is defined as follows:</p><pre class='codeblock'>
template &lt;class T&gt; decay_t&lt;T&gt; decay_copy(T&amp;&amp; v)
  { return std::forward&lt;T&gt;(v); }
</pre></div></div></div><div id='threads'><h2 ><a class='secnum' href='#threads' style='min-width:88pt'>30.3</a> Threads <a class='abbr_ref' href='thread.threads'>[thread.threads]</a></h2><div class='para' id='threads-1'><div class='marginalizedparent'><a class='marginalized' href='#threads-1'>1</a></div><p ><a href='thread.threads'>[thread.threads]</a> describes components that can be used to create and manage threads.
[&nbsp;<i>Note:</i><span class='space'></span> These threads are intended to map one-to-one with operating system threads.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><b>Header <span class='texttt'>&lt;thread&gt;</span> synopsis</b>
<span class='indexparent'><a class='index' id='thread'></a></span>
</p><pre class='codeblock'>
namespace std {
  class thread;

  void swap(thread&amp; x, thread&amp; y) noexcept;

  namespace this_thread {
    thread::id get_id() noexcept;

    void yield() noexcept;
    template &lt;class Clock, class Duration&gt;
      void sleep_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    template &lt;class Rep, class Period&gt;
      void sleep_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
  }
}
</pre></div><div id='thread.class'><h3 ><a class='secnum' href='#thread.class' style='min-width:103pt'>30.3.1</a> Class <span class='texttt'>thread</span> <a class='abbr_ref' href='thread.thread.class'>[thread.thread.class]</a></h3><div class='para' id='thread.class-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.class-1'>1</a></div><p >The class <span class='texttt'>thread</span> provides a mechanism to create a new thread of execution, to join with
a thread (i.e., wait for a thread to complete), and to perform other operations that manage and
query the state of a thread. A <span class='texttt'>thread</span> object uniquely represents a particular thread of
execution. That representation may be transferred to other <span class='texttt'>thread</span> objects in such a way
that no two <span class='texttt'>thread</span> objects simultaneously represent the same thread of execution. A
thread of execution is <a class='hidden_link' href='#def:detached' id='def:detached'><i>detached</i></a> when no <span class='texttt'>thread</span> object represents that thread.
Objects of class <span class='texttt'>thread</span> can be in a state that does not represent a thread of
execution. [&nbsp;<i>Note:</i><span class='space'></span> A <span class='texttt'>thread</span> object does not represent a thread of execution after
default construction, after being moved from, or after a successful call to <span class='texttt'>detach</span> or
<span class='texttt'>join</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='thread'></a></span></p><pre class='codeblock'>
namespace std {
  class thread {
  public:
    <span class='comment'>// types:
</span>    class id;
    using native_handle_type = <i>implementation-defined</i>; <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>
    <span class='comment'>// construct/copy/destroy:
</span>    thread() noexcept;
    template &lt;class F, class... Args&gt; explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);
    ~thread();
    thread(const thread&amp;) = delete;
    thread(thread&amp;&amp;) noexcept;
    thread&amp; operator=(const thread&amp;) = delete;
    thread&amp; operator=(thread&amp;&amp;) noexcept;

    <span class='comment'>// members:
</span>    void swap(thread&amp;) noexcept;
    bool joinable() const noexcept;
    void join();
    void detach();
    id get_id() const noexcept;
    native_handle_type native_handle(); <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>
    <span class='comment'>// static members:
</span>    static unsigned hardware_concurrency() noexcept;
  };
}
</pre></div><div id='thread.id'><h4 ><a class='secnum' href='#thread.id' style='min-width:118pt'>30.3.1.1</a> Class <span class='texttt'>thread::id</span> <a class='abbr_ref' href='thread.thread.id'>[thread.thread.id]</a></h4><p ><span class='indexparent'><a class='index' id='thread::id'></a></span><span class='indexparent'><a class='index' id='thread,id'></a></span></p><pre class='codeblock'>
namespace std {
  class thread::id {
  public:
      id() noexcept;
  };

  bool operator==(thread::id x, thread::id y) noexcept;
  bool operator!=(thread::id x, thread::id y) noexcept;
  bool operator&lt;(thread::id x, thread::id y) noexcept;
  bool operator&lt;=(thread::id x, thread::id y) noexcept;
  bool operator&gt;(thread::id x, thread::id y) noexcept;
  bool operator&gt;=(thread::id x, thread::id y) noexcept;

  template&lt;class charT, class traits&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp; out, thread::id id);

  <span class='comment'>// Hash support
</span>  template &lt;class T&gt; struct hash;
  template &lt;&gt; struct hash&lt;thread::id&gt;;
}
</pre><div class='para' id='thread.id-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.id-1'>1</a></div><p >An object of type <span class='texttt'>thread::id</span> provides a unique identifier for
each thread of execution and a single distinct value for all <span class='texttt'>thread</span>
objects that do not represent a thread of
execution (<a href='thread.thread.class'>[thread.thread.class]</a>). Each thread of execution has an
associated <span class='texttt'>thread::id</span> object that is not equal to the
<span class='texttt'>thread::id</span> object of any other thread of execution and that is not
equal to the <span class='texttt'>thread::id</span> object of any <span class='texttt'>std::thread</span> object that
does not represent threads of execution.</p></div><div class='para' id='thread.id-2'><div class='marginalizedparent'><a class='marginalized' href='#thread.id-2'>2</a></div><p ><span class='texttt'>thread::id</span> shall be a trivially copyable class (Clause <a href='class'>[class]</a>).
The library may reuse the value of a <span class='texttt'>thread::id</span> of a terminated thread that can no longer be joined.</p></div><div class='para' id='thread.id-3'><div class='marginalizedparent'><a class='marginalized' href='#thread.id-3'>3</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Relational operators allow <span class='texttt'>thread::id</span> objects to be used as
keys in associative containers. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='thread::id,constructor'></a></span><code class='itemdecl'>
id() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='thread.id-4'><div class='marginalizedparent'><a class='marginalized' href='#thread.id-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>id</span>.</p></div></div><div class='para' id='thread.id-5'><div class='marginalizedparent'><a class='marginalized' href='#thread.id-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> The constructed object does not represent a thread of execution.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator==,thread::id'></a></span><span class='indexparent'><a class='index' id='thread::id,operator=='></a></span><code class='itemdecl'>
bool operator==(thread::id x, thread::id y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.id-6'><div class='marginalizedparent'><a class='marginalized' href='#thread.id-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> only if <span class='texttt'>x</span> and <span class='texttt'>y</span> represent the same
thread of execution or neither <span class='texttt'>x</span> nor <span class='texttt'>y</span> represents a thread of
execution.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,thread::id'></a></span><span class='indexparent'><a class='index' id='thread::id,operator!='></a></span><code class='itemdecl'>
bool operator!=(thread::id x, thread::id y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.id-7'><div class='marginalizedparent'><a class='marginalized' href='#thread.id-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(x == y)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,thread::id'></a></span><span class='indexparent'><a class='index' id='thread::id,operator<'></a></span><code class='itemdecl'>
bool operator&lt;(thread::id x, thread::id y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.id-8'><div class='marginalizedparent'><a class='marginalized' href='#thread.id-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> A value such that <span class='texttt'>operator&lt;</span> is a total ordering as described in <a href='alg.sorting'>[alg.sorting]</a>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,thread::id'></a></span><span class='indexparent'><a class='index' id='thread::id,operator<='></a></span><code class='itemdecl'>
bool operator&lt;=(thread::id x, thread::id y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.id-9'><div class='marginalizedparent'><a class='marginalized' href='#thread.id-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(y &lt; x)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,thread::id'></a></span><span class='indexparent'><a class='index' id='thread::id,operator>'></a></span><code class='itemdecl'>
bool operator&gt;(thread::id x, thread::id y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.id-10'><div class='marginalizedparent'><a class='marginalized' href='#thread.id-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>y &lt; x</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,thread::id'></a></span><span class='indexparent'><a class='index' id='thread::id,operator>='></a></span><code class='itemdecl'>
bool operator&gt;=(thread::id x, thread::id y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.id-11'><div class='marginalizedparent'><a class='marginalized' href='#thread.id-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(x &lt; y)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<<,thread::id'></a></span><span class='indexparent'><a class='index' id='thread::id,operator<<'></a></span><code class='itemdecl'>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp; out, thread::id id);
</code></p><div class='itemdescr'></div><div class='para' id='thread.id-12'><div class='marginalizedparent'><a class='marginalized' href='#thread.id-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Inserts an unspecified text representation of <span class='texttt'>id</span> into
<span class='texttt'>out</span>. For two objects of type <span class='texttt'>thread::id</span> <span class='texttt'>x</span> and <span class='texttt'>y</span>,
if <span class='texttt'>x == y</span> the <span class='texttt'>thread::id</span> objects shall have the same text
representation and if <span class='texttt'>x != y</span> the <span class='texttt'>thread::id</span> objects shall have
distinct text representations.</p></div></div><div class='para' id='thread.id-13'><div class='marginalizedparent'><a class='marginalized' href='#thread.id-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>out</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='hash,thread::id'></a></span><code class='itemdecl'>
template &lt;&gt; struct hash&lt;thread::id&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='thread.id-14'><div class='marginalizedparent'><a class='marginalized' href='#thread.id-14'>14</a></div><div class='itemdescr'><p >The template specialization shall meet the requirements of class template
<span class='texttt'>hash</span> (<a href='unord.hash'>[unord.hash]</a>).
</p></div></div></div><div id='thread.constr'><h4 ><a class='secnum' href='#thread.constr' style='min-width:118pt'>30.3.1.2</a> <span class='texttt'>thread</span> constructors <a class='abbr_ref' href='thread.thread.constr'>[thread.thread.constr]</a></h4><p ><span class='indexparent'><a class='index' id='thread,constructor'></a></span><code class='itemdecl'>
thread() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.constr-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.constr-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>thread</span> object that does not represent a thread of execution.</p></div></div><div class='para' id='thread.constr-2'><div class='marginalizedparent'><a class='marginalized' href='#thread.constr-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_id() == id()</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='thread,constructor'></a></span><code class='itemdecl'>
template &lt;class F, class... Args&gt; explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='thread.constr-3'><div class='marginalizedparent'><a class='marginalized' href='#thread.constr-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>F</span> and each <span class='texttt'>Ti</span> in <span class='texttt'>Args</span> shall satisfy the
<span class='texttt'>MoveConstructible</span> requirements.
<span class='texttt'><i>INVOKE</i>(<i>DECAY_COPY</i>(</span>
<span class='texttt'>std::forward&lt;F&gt;(f)), <i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...)</span> (<a href='func.require'>[func.require]</a>) shall be
a valid expression.</p></div></div><div class='para' id='thread.constr-4'><div class='marginalizedparent'><a class='marginalized' href='#thread.constr-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This constructor shall not participate in overload resolution if <span class='texttt'>decay_t&lt;F&gt;</span>
is the same type as <span class='texttt'>std::thread</span>.</p></div></div><div class='para' id='thread.constr-5'><div class='marginalizedparent'><a class='marginalized' href='#thread.constr-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>thread</span>. The new thread of execution executes
<span class='texttt'><i>INVOKE</i>(<i>DECAY_COPY</i>(</span>
<span class='texttt'>std::forward&lt;F&gt;(f)), <i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...)</span> with the calls to
<span class='discretionary'></span><span class='texttt'><i>DECAY_COPY</i></span> being evaluated in the constructing thread. Any return value from this invocation
is ignored. [&nbsp;<i>Note:</i><span class='space'></span> This implies that any exceptions not thrown from the invocation of the copy
of <span class='texttt'>f</span> will be thrown in the constructing thread, not the new thread. <i>&nbsp;—&nbsp;end note</i>&nbsp;] If the
invocation of
<span class='texttt'><i>INVOKE</i>(<i>DECAY_COPY</i>(</span>
<span class='texttt'>std::forward&lt;F&gt;(f)), <i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...)</span>
terminates with an uncaught exception, <span class='texttt'>std::terminate</span> shall be called.</p></div></div><div class='para' id='thread.constr-6'><div class='marginalizedparent'><a class='marginalized' href='#thread.constr-6'>6</a></div><div class='itemdescr'><p ><i>Synchronization:</i> The completion of the invocation of the constructor
synchronizes with the beginning of the invocation of the copy of <span class='texttt'>f</span>.</p></div></div><div class='para' id='thread.constr-7'><div class='marginalizedparent'><a class='marginalized' href='#thread.constr-7'>7</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_id() != id()</span>. <span class='texttt'>*this</span> represents the newly started thread.</p></div></div><div class='para' id='thread.constr-8'><div class='marginalizedparent'><a class='marginalized' href='#thread.constr-8'>8</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> if unable to start the new thread.</p></div></div><div class='para' id='thread.constr-9'><div class='marginalizedparent'><a class='marginalized' href='#thread.constr-9'>9</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>resource_unavailable_try_again</span> — the system lacked the necessary
resources to create another thread, or the system-imposed limit on the number of
threads in a process would be exceeded.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='thread,constructor'></a></span><code class='itemdecl'>
thread(thread&amp;&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.constr-10'><div class='marginalizedparent'><a class='marginalized' href='#thread.constr-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>thread</span> from <span class='texttt'>x</span>, and sets
<span class='texttt'>x</span> to a default constructed state.</p></div></div><div class='para' id='thread.constr-11'><div class='marginalizedparent'><a class='marginalized' href='#thread.constr-11'>11</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>x.get_id() == id()</span> and <span class='texttt'>get_id()</span> returns the
value of <span class='texttt'>x.get_id()</span> prior to the start of construction.</p></div></div></div><div id='thread.destr'><h4 ><a class='secnum' href='#thread.destr' style='min-width:118pt'>30.3.1.3</a> <span class='texttt'>thread</span> destructor <a class='abbr_ref' href='thread.thread.destr'>[thread.thread.destr]</a></h4><p ><span class='indexparent'><a class='index' id='thread,destructor'></a></span><code class='itemdecl'>
~thread();
</code></p><div class='itemdescr'></div><div class='para' id='thread.destr-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.destr-1'>1</a></div><div class='itemdescr'><p >If <span class='texttt'>joinable()</span>, calls <span class='texttt'>std::terminate()</span>. Otherwise, has no effects.
[&nbsp;<i>Note:</i><span class='space'></span> Either implicitly detaching or joining a <span class='texttt'>joinable()</span> thread in its
destructor could result in difficult to debug correctness (for detach) or performance
(for join) bugs encountered only when an exception is thrown. Thus the programmer must
ensure that the destructor is never executed while the thread is still joinable.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='thread.assign'><h4 ><a class='secnum' href='#thread.assign' style='min-width:118pt'>30.3.1.4</a> <span class='texttt'>thread</span> assignment <a class='abbr_ref' href='thread.thread.assign'>[thread.thread.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,thread'></a></span><span class='indexparent'><a class='index' id='thread,operator='></a></span><code class='itemdecl'>
thread&amp; operator=(thread&amp;&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>joinable()</span>, calls <span class='texttt'>std::terminate()</span>. Otherwise, assigns the
state of <span class='texttt'>x</span> to <span class='texttt'>*this</span> and sets <span class='texttt'>x</span> to a default constructed state.</p></div></div><div class='para' id='thread.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#thread.assign-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>x.get_id() == id()</span> and <span class='texttt'>get_id()</span> returns the value of
<span class='texttt'>x.get_id()</span> prior to the assignment.</p></div></div><div class='para' id='thread.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#thread.assign-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div></div><div id='thread.member'><h4 ><a class='secnum' href='#thread.member' style='min-width:118pt'>30.3.1.5</a> <span class='texttt'>thread</span> members <a class='abbr_ref' href='thread.thread.member'>[thread.thread.member]</a></h4><p ><span class='indexparent'><a class='index' id='swap,thread'></a></span><span class='indexparent'><a class='index' id='thread,swap'></a></span><code class='itemdecl'>
void swap(thread&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.member-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.member-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Swaps the state of <span class='texttt'>*this</span> and <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='joinable,thread'></a></span><span class='indexparent'><a class='index' id='thread,joinable'></a></span><code class='itemdecl'>
bool joinable() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.member-2'><div class='marginalizedparent'><a class='marginalized' href='#thread.member-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>get_id() != id()</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='join,thread'></a></span><span class='indexparent'><a class='index' id='thread,join'></a></span><code class='itemdecl'>
void join();
</code></p><div class='itemdescr'></div><div class='para' id='thread.member-3'><div class='marginalizedparent'><a class='marginalized' href='#thread.member-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Blocks until the thread represented by <span class='texttt'>*this</span> has completed.</p></div></div><div class='para' id='thread.member-4'><div class='marginalizedparent'><a class='marginalized' href='#thread.member-4'>4</a></div><div class='itemdescr'><p ><i>Synchronization:</i> The completion of the thread represented by <span class='texttt'>*this</span> synchronizes with (<a href='intro.multithread'>[intro.multithread]</a>)
the corresponding successful
<span class='texttt'>join()</span> return. [&nbsp;<i>Note:</i><span class='space'></span> Operations on
<span class='texttt'>*this</span> are not synchronized. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='thread.member-5'><div class='marginalizedparent'><a class='marginalized' href='#thread.member-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> The thread represented by <span class='texttt'>*this</span> has completed. <span class='texttt'>get_id() == id()</span>.</p></div></div><div class='para' id='thread.member-6'><div class='marginalizedparent'><a class='marginalized' href='#thread.member-6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='thread.member-7'><div class='marginalizedparent'><a class='marginalized' href='#thread.member-7'>7</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>resource_deadlock_would_occur</span> — if deadlock is detected or
<span class='texttt'>get_id() == std::this_thread::get_id()</span>.</p></li><li ><p ><span class='texttt'>no_such_process</span> — if the thread is not valid.</p></li><li ><p ><span class='texttt'>invalid_argument</span> — if the thread is not joinable.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='detach,thread'></a></span><span class='indexparent'><a class='index' id='thread,detach'></a></span><code class='itemdecl'>
void detach();
</code></p><div class='itemdescr'></div><div class='para' id='thread.member-8'><div class='marginalizedparent'><a class='marginalized' href='#thread.member-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> The thread represented by <span class='texttt'>*this</span> continues execution without the calling thread
blocking. When <span class='texttt'>detach()</span> returns, <span class='texttt'>*this</span> no longer represents the possibly continuing
thread of execution. When the thread previously represented by <span class='texttt'>*this</span> ends execution, the
implementation shall release any owned resources.</p></div></div><div class='para' id='thread.member-9'><div class='marginalizedparent'><a class='marginalized' href='#thread.member-9'>9</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>get_id() == id()</span>.</p></div></div><div class='para' id='thread.member-10'><div class='marginalizedparent'><a class='marginalized' href='#thread.member-10'>10</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='thread.member-11'><div class='marginalizedparent'><a class='marginalized' href='#thread.member-11'>11</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>no_such_process</span> — if the thread is not valid.
</p></li><li ><p ><span class='texttt'>invalid_argument</span> — if the thread is not joinable.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='get_id,thread'></a></span><span class='indexparent'><a class='index' id='thread,get_id'></a></span><code class='itemdecl'>
id get_id() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.member-12'><div class='marginalizedparent'><a class='marginalized' href='#thread.member-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> A default constructed <span class='texttt'>id</span> object if <span class='texttt'>*this</span> does not represent a thread,
otherwise <span class='texttt'>this_thread::get_id()</span> for the thread of execution represented by
<span class='texttt'>*this</span>.
</p></div></div></div><div id='thread.static'><h4 ><a class='secnum' href='#thread.static' style='min-width:118pt'>30.3.1.6</a> <span class='texttt'>thread</span> static members <a class='abbr_ref' href='thread.thread.static'>[thread.thread.static]</a></h4><p ><span class='indexparent'><a class='index' id='hardware_concurrency,thread'></a></span><span class='indexparent'><a class='index' id='thread,hardware_concurrency'></a></span><code class='itemdecl'>
unsigned hardware_concurrency() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.static-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.static-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of hardware thread contexts. [&nbsp;<i>Note:</i><span class='space'></span> This value should
only be considered to be a hint. <i>&nbsp;—&nbsp;end note</i>&nbsp;] If this value is not computable or
well defined an implementation should return 0.
</p></div></div></div><div id='thread.algorithm'><h4 ><a class='secnum' href='#thread.algorithm' style='min-width:118pt'>30.3.1.7</a> <span class='texttt'>thread</span> specialized algorithms <a class='abbr_ref' href='thread.thread.algorithm'>[thread.thread.algorithm]</a></h4><p ><span class='indexparent'><a class='index' id='swap,thread'></a></span><span class='indexparent'><a class='index' id='thread,swap'></a></span><code class='itemdecl'>
void swap(thread&amp; x, thread&amp; y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.algorithm-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.algorithm-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>x.swap(y)</span>.
</p></div></div></div></div><div id='thread.this'><h3 ><a class='secnum' href='#thread.this' style='min-width:103pt'>30.3.2</a> Namespace <span class='texttt'>this_thread</span> <a class='abbr_ref' href='thread.thread.this'>[thread.thread.this]</a></h3><pre class='codeblock'>
namespace std::this_thread {
  thread::id get_id() noexcept;

  void yield() noexcept;
  template &lt;class Clock, class Duration&gt;
    void sleep_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
  template &lt;class Rep, class Period&gt;
    void sleep_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
}
</pre><p ><span class='indexparent'><a class='index' id='get_id,this_thread'></a></span><span class='indexparent'><a class='index' id='this_thread,get_id'></a></span><code class='itemdecl'>
thread::id this_thread::get_id() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.this-1'><div class='marginalizedparent'><a class='marginalized' href='#thread.this-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> An object of type <span class='texttt'>thread::id</span> that uniquely identifies the current thread of
execution. No other thread of execution shall have this id and this thread of execution shall
always have this id. The object returned shall not compare equal to a default constructed
<span class='texttt'>thread::id</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='yield,this_thread'></a></span><span class='indexparent'><a class='index' id='this_thread,yield'></a></span><code class='itemdecl'>
void this_thread::yield() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='thread.this-2'><div class='marginalizedparent'><a class='marginalized' href='#thread.this-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Offers the implementation the opportunity to reschedule.</p></div></div><div class='para' id='thread.this-3'><div class='marginalizedparent'><a class='marginalized' href='#thread.this-3'>3</a></div><div class='itemdescr'><p ><i>Synchronization:</i> None.
</p></div></div><p ><span class='indexparent'><a class='index' id='sleep_until,this_thread'></a></span><span class='indexparent'><a class='index' id='this_thread,sleep_until'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration&gt;
  void sleep_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</code></p><div class='itemdescr'></div><div class='para' id='thread.this-4'><div class='marginalizedparent'><a class='marginalized' href='#thread.this-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Blocks the calling thread for the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified
by <span class='texttt'>abs_time</span>.</p></div></div><div class='para' id='thread.this-5'><div class='marginalizedparent'><a class='marginalized' href='#thread.this-5'>5</a></div><div class='itemdescr'><p ><i>Synchronization:</i> None.</p></div></div><div class='para' id='thread.this-6'><div class='marginalizedparent'><a class='marginalized' href='#thread.this-6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='sleep_for,this_thread'></a></span><span class='indexparent'><a class='index' id='this_thread,sleep_for'></a></span><code class='itemdecl'>
template &lt;class Rep, class Period&gt;
  void sleep_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></p><div class='itemdescr'></div><div class='para' id='thread.this-7'><div class='marginalizedparent'><a class='marginalized' href='#thread.this-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Blocks the calling thread for the relative timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified
by <span class='texttt'>rel_time</span>.</p></div></div><div class='para' id='thread.this-8'><div class='marginalizedparent'><a class='marginalized' href='#thread.this-8'>8</a></div><div class='itemdescr'><p ><i>Synchronization:</i> None.</p></div></div><div class='para' id='thread.this-9'><div class='marginalizedparent'><a class='marginalized' href='#thread.this-9'>9</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).
</p></div></div></div></div><div id='mutex'><h2 ><a class='secnum' href='#mutex' style='min-width:88pt'>30.4</a> Mutual exclusion <a class='abbr_ref' href='thread.mutex'>[thread.mutex]</a></h2><div class='para' id='mutex-1'><div class='marginalizedparent'><a class='marginalized' href='#mutex-1'>1</a></div><p >This section provides mechanisms for mutual exclusion: mutexes, locks, and call
once. These mechanisms ease the production of race-free
programs (<a href='intro.multithread'>[intro.multithread]</a>).</p><p ><b>Header <span class='texttt'>&lt;mutex&gt;</span> synopsis</b>
<span class='indexparent'><a class='index' id='mutex'></a></span>
</p><pre class='codeblock'>
namespace std {
  class mutex;
  class recursive_mutex;
  class timed_mutex;
  class recursive_timed_mutex;

  struct defer_lock_t { };
  struct try_to_lock_t { };
  struct adopt_lock_t { };

  constexpr defer_lock_t  defer_lock { };
  constexpr try_to_lock_t try_to_lock { };
  constexpr adopt_lock_t  adopt_lock { };

  template &lt;class... MutexTypes&gt; class lock_guard;
  template &lt;class Mutex&gt; class unique_lock;

  template &lt;class Mutex&gt;
    void swap(unique_lock&lt;Mutex&gt;&amp; x, unique_lock&lt;Mutex&gt;&amp; y) noexcept;

  template &lt;class L1, class L2, class... L3&gt; int try_lock(L1&amp;, L2&amp;, L3&amp;...);
  template &lt;class L1, class L2, class... L3&gt; void lock(L1&amp;, L2&amp;, L3&amp;...);

  struct once_flag;

  template&lt;class Callable, class... Args&gt;
    void call_once(once_flag&amp; flag, Callable&amp;&amp; func, Args&amp;&amp;... args);
}
</pre><p ><b>Header <span class='texttt'>&lt;shared_mutex&gt;</span> synopsis</b>
<span class='indexparent'><a class='index' id='shared_mutex'></a></span>
</p><pre class='codeblock'>
namespace std {
  class shared_mutex;
  class shared_timed_mutex;
  template &lt;class Mutex&gt; class shared_lock;
  template &lt;class Mutex&gt;
    void swap(shared_lock&lt;Mutex&gt;&amp; x, shared_lock&lt;Mutex&gt;&amp; y) noexcept;
}
</pre></div><div id='mutex.requirements'><h3 ><a class='secnum' href='#mutex.requirements' style='min-width:103pt'>30.4.1</a> Mutex requirements <a class='abbr_ref' href='thread.mutex.requirements'>[thread.mutex.requirements]</a></h3><div id='mutex.requirements.general'><h4 ><a class='secnum' href='#mutex.requirements.general' style='min-width:118pt'>30.4.1.1</a> In general <a class='abbr_ref' href='thread.mutex.requirements.general'>[thread.mutex.requirements.general]</a></h4><div class='para' id='mutex.requirements.general-1'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.general-1'>1</a></div><p >A mutex object facilitates protection against data races and allows safe synchronization of
data between execution agents (<a href='thread.req.lockable'>[thread.req.lockable]</a>).
An execution agent <a class='hidden_link' href='#def:owns' id='def:owns'><i>owns</i></a> a mutex from the time it successfully calls one of the
lock functions until it calls unlock. Mutexes can be either recursive or non-recursive, and can
grant simultaneous ownership to one or many execution agents. Both
recursive and non-recursive mutexes are supplied.</p></div></div><div id='mutex.requirements.mutex'><h4 ><a class='secnum' href='#mutex.requirements.mutex' style='min-width:118pt'>30.4.1.2</a> Mutex types <a class='abbr_ref' href='thread.mutex.requirements.mutex'>[thread.mutex.requirements.mutex]</a></h4><div class='para' id='mutex.requirements.mutex-1'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-1'>1</a></div><p >The <a class='hidden_link' href='#def:mutex_types' id='def:mutex_types'><i>mutex types</i></a> are the standard library types <span class='texttt'>std::mutex</span>,
<span class='texttt'>std::recursive_mutex</span>, <span class='texttt'>std::timed_mutex</span>, <span class='texttt'>std::recursive_timed_mutex</span>,
<span class='texttt'>std::shared_mutex</span>, and <span class='texttt'>std::shared_timed_mutex</span>.
They shall meet the requirements set out in this section. In this description, <span class='texttt'>m</span>
denotes an object of a mutex type.</p></div><div class='para' id='mutex.requirements.mutex-2'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-2'>2</a></div><p >The mutex types shall meet the <span class='texttt'>Lockable</span> requirements (<a href='thread.req.lockable.req'>[thread.req.lockable.req]</a>).</p></div><div class='para' id='mutex.requirements.mutex-3'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-3'>3</a></div><p >The mutex types shall be <span class='texttt'>DefaultConstructible</span> and <span class='texttt'>Destructible</span>. If
initialization of an object of a mutex type fails, an exception of type
<span class='texttt'>system_error</span> shall be thrown. The mutex types shall not be copyable or movable.</p></div><div class='para' id='mutex.requirements.mutex-4'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-4'>4</a></div><p >The error conditions for error codes, if any, reported by member functions of the mutex types
shall be:
</p><ul ><li ><p ><span class='texttt'>resource_unavailable_try_again</span> — if any native handle type manipulated is not available.
</p></li><li ><p ><span class='texttt'>operation_not_permitted</span> — if the thread does not have the
privilege to perform the operation.
</p></li><li ><p ><span class='texttt'>invalid_argument</span> — if any native handle type manipulated as part of mutex
construction is incorrect.
</p></li></ul></div><div class='para' id='mutex.requirements.mutex-5'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-5'>5</a></div><p >The implementation shall provide lock and unlock operations, as described below.
For purposes of determining the existence of a data race, these behave as
atomic operations (<a href='intro.multithread'>[intro.multithread]</a>). The lock and unlock operations on
a single mutex shall appear to occur in a single total order. [&nbsp;<i>Note:</i><span class='space'></span> this
can be viewed as the modification order (<a href='intro.multithread'>[intro.multithread]</a>) of the
mutex. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span> Construction and
destruction of an object of a mutex type need not be thread-safe; other
synchronization should be used to ensure that mutex objects are initialized
and visible to other threads. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mutex.requirements.mutex-6'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-6'>6</a></div><p >The expression <span class='texttt'>m.lock()</span> shall be well-formed and have the following semantics:</p></div><div class='itemdescr'></div><div class='para' id='mutex.requirements.mutex-7'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>m</span> is of type <span class='texttt'>std::mutex</span>, <span class='texttt'>std::timed_mutex</span>,
<span class='texttt'>std::shared_mutex</span>, or <span class='texttt'>std::shared_timed_mutex</span>, the calling
thread does not own the mutex.</p></div></div><div class='para' id='mutex.requirements.mutex-8'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Blocks the calling thread until ownership of the mutex can be obtained for the calling thread.</p></div></div><div class='para' id='mutex.requirements.mutex-9'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-9'>9</a></div><div class='itemdescr'><p ><i>Postconditions:</i> The calling thread owns the mutex.</p></div></div><div class='para' id='mutex.requirements.mutex-10'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-10'>10</a></div><div class='itemdescr'><p ><i>Return type:</i> <span class='texttt'>void</span></p></div></div><div class='para' id='mutex.requirements.mutex-11'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-11'>11</a></div><div class='itemdescr'><p ><i>Synchronization:</i> Prior <span class='texttt'>unlock()</span> operations on the same object shall
<a class='hidden_link' href='#def:synchronize_with' id='def:synchronize_with'><i>synchronize with</i></a> (<a href='intro.multithread'>[intro.multithread]</a>) this operation.</p></div></div><div class='para' id='mutex.requirements.mutex-12'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-12'>12</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='mutex.requirements.mutex-13'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-13'>13</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>operation_not_permitted</span> — if the thread does not have the
privilege to perform the operation.</p></li><li ><p ><span class='texttt'>resource_deadlock_would_occur</span> — if the implementation detects
that a deadlock would occur.
</p></li></ul></div></div><div class='para' id='mutex.requirements.mutex-14'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-14'>14</a></div><p >The expression <span class='texttt'>m.try_lock()</span> shall be well-formed and have the following semantics:</p></div><div class='itemdescr'></div><div class='para' id='mutex.requirements.mutex-15'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-15'>15</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>m</span> is of type <span class='texttt'>std::mutex</span>, <span class='texttt'>std::timed_mutex</span>,
<span class='texttt'>std::shared_mutex</span>, or <span class='texttt'>std::shared_timed_mutex</span>, the calling
thread does not own the mutex.</p></div></div><div class='para' id='mutex.requirements.mutex-16'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> Attempts to obtain ownership of the mutex for the calling thread without
blocking. If ownership is not obtained, there is no effect and <span class='texttt'>try_lock()</span>
immediately returns. An implementation may fail to obtain the lock even if it is not
held by any other thread. [&nbsp;<i>Note:</i><span class='space'></span> This spurious failure is normally uncommon, but
allows interesting implementations based on a simple
compare and exchange
(Clause <a href='atomics'>[atomics]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]
An implementation should ensure that <span class='texttt'>try_lock()</span> does not consistently return <span class='texttt'>false</span>
in the absence of contending mutex acquisitions.</p></div></div><div class='para' id='mutex.requirements.mutex-17'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-17'>17</a></div><div class='itemdescr'><p ><i>Return type:</i> <span class='texttt'>bool</span></p></div></div><div class='para' id='mutex.requirements.mutex-18'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-18'>18</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if ownership of the mutex was obtained for the calling
thread, otherwise <span class='texttt'>false</span>.</p></div></div><div class='para' id='mutex.requirements.mutex-19'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-19'>19</a></div><div class='itemdescr'><p ><i>Synchronization:</i> If <span class='texttt'>try_lock()</span> returns <span class='texttt'>true</span>, prior <span class='texttt'>unlock()</span> operations
on the same object <a class='hidden_link' href='#def:synchronize_with' id='def:synchronize_with'><i>synchronize with</i></a> (<a href='intro.multithread'>[intro.multithread]</a>) this operation.
[&nbsp;<i>Note:</i><span class='space'></span> Since <span class='texttt'>lock()</span> does not synchronize with a failed subsequent
<span class='texttt'>try_lock()</span>, the visibility rules are weak enough that little would be
known about the state after a failure, even in the absence of spurious failures. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='mutex.requirements.mutex-20'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-20'>20</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><div class='para' id='mutex.requirements.mutex-21'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-21'>21</a></div><p >The expression <span class='texttt'>m.unlock()</span> shall be well-formed and have the following semantics:</p></div><div class='itemdescr'></div><div class='para' id='mutex.requirements.mutex-22'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-22'>22</a></div><div class='itemdescr'><p ><i>Requires:</i> The calling thread shall own the mutex.</p></div></div><div class='para' id='mutex.requirements.mutex-23'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-23'>23</a></div><div class='itemdescr'><p ><i>Effects:</i> Releases the calling thread's ownership of the mutex.</p></div></div><div class='para' id='mutex.requirements.mutex-24'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-24'>24</a></div><div class='itemdescr'><p ><i>Return type:</i> <span class='texttt'>void</span></p></div></div><div class='para' id='mutex.requirements.mutex-25'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-25'>25</a></div><div class='itemdescr'><p ><i>Synchronization:</i> This operation synchronizes with (<a href='intro.multithread'>[intro.multithread]</a>) subsequent
lock operations that obtain ownership on the same object.</p></div></div><div class='para' id='mutex.requirements.mutex-26'><div class='marginalizedparent'><a class='marginalized' href='#mutex.requirements.mutex-26'>26</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><div id='mutex.class'><h4 ><a class='secnum' href='#mutex.class' style='min-width:133pt'>30.4.1.2.1</a> Class <span class='texttt'>mutex</span> <a class='abbr_ref' href='thread.mutex.class'>[thread.mutex.class]</a></h4><p ><span class='indexparent'><a class='index' id='mutex'></a></span></p><pre class='codeblock'>
namespace std {
  class mutex {
  public:
    constexpr mutex() noexcept;
    ~mutex();

    mutex(const mutex&amp;) = delete;
    mutex&amp; operator=(const mutex&amp;) = delete;

    void lock();
    bool try_lock();
    void unlock();

    using native_handle_type = <i>implementation-defined</i>; <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>    native_handle_type native_handle();                <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>  };
}
</pre><div class='para' id='mutex.class-1'><div class='marginalizedparent'><a class='marginalized' href='#mutex.class-1'>1</a></div><p >The class <span class='texttt'>mutex</span> provides a non-recursive mutex with exclusive ownership
semantics. If one thread owns a mutex object, attempts by another thread to acquire
ownership of that object will fail (for <span class='texttt'>try_lock()</span>) or block (for
<span class='texttt'>lock()</span>) until the owning thread has released ownership with a call to
<span class='texttt'>unlock()</span>.</p></div><div class='para' id='mutex.class-2'><div class='marginalizedparent'><a class='marginalized' href='#mutex.class-2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
After a thread <span class='texttt'>A</span> has called <span class='texttt'>unlock()</span>, releasing a mutex, it is possible for another
thread <span class='texttt'>B</span> to lock the same mutex, observe that it is no longer in use, unlock it, and
destroy it, before thread <span class='texttt'>A</span> appears to have returned from its unlock call. Implementations
are required to handle such scenarios correctly, as long as thread <span class='texttt'>A</span> doesn't access the
mutex after the unlock call returns. These cases typically occur when a reference-counted object
contains a mutex that is used to protect the reference count.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mutex.class-3'><div class='marginalizedparent'><a class='marginalized' href='#mutex.class-3'>3</a></div><p >The class <span class='texttt'>mutex</span> shall satisfy all the <span class='texttt'>Mutex</span>
requirements (<a href='thread.mutex.requirements'>[thread.mutex.requirements]</a>). It shall be a standard-layout
class (Clause <a href='class'>[class]</a>).</p></div><div class='para' id='mutex.class-4'><div class='marginalizedparent'><a class='marginalized' href='#mutex.class-4'>4</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> A program may deadlock if the thread that owns a <span class='texttt'>mutex</span> object calls
<span class='texttt'>lock()</span> on that object. If the implementation can detect the deadlock,
a <span class='texttt'>resource_deadlock_would_occur</span> error condition may be observed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='mutex.class-5'><div class='marginalizedparent'><a class='marginalized' href='#mutex.class-5'>5</a></div><p >The behavior of a program is undefined if
it destroys a <span class='texttt'>mutex</span> object owned by any thread or
a thread terminates while owning a <span class='texttt'>mutex</span> object.</p></div></div><div id='mutex.recursive'><h4 ><a class='secnum' href='#mutex.recursive' style='min-width:133pt'>30.4.1.2.2</a> Class <span class='texttt'>recursive_mutex</span> <a class='abbr_ref' href='thread.mutex.recursive'>[thread.mutex.recursive]</a></h4><p ><span class='indexparent'><a class='index' id='recursive_mutex'></a></span></p><pre class='codeblock'>
namespace std {
  class recursive_mutex {
  public:
    recursive_mutex();
    ~recursive_mutex();

    recursive_mutex(const recursive_mutex&amp;) = delete;
    recursive_mutex&amp; operator=(const recursive_mutex&amp;) = delete;

    void lock();
    bool try_lock() noexcept;
    void unlock();

    using native_handle_type = <i>implementation-defined</i>; <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>    native_handle_type native_handle();                <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>  };
}
</pre><div class='para' id='mutex.recursive-1'><div class='marginalizedparent'><a class='marginalized' href='#mutex.recursive-1'>1</a></div><p >The class <span class='texttt'>recursive_mutex</span> provides a recursive mutex with exclusive ownership
semantics. If one thread owns a <span class='texttt'>recursive_mutex</span> object, attempts by another
thread to acquire ownership of that object will fail (for <span class='texttt'>try_lock()</span>) or block
(for <span class='texttt'>lock()</span>) until the first thread has completely released ownership.</p></div><div class='para' id='mutex.recursive-2'><div class='marginalizedparent'><a class='marginalized' href='#mutex.recursive-2'>2</a></div><p >The class <span class='texttt'>recursive_mutex</span> shall satisfy all the Mutex
requirements (<a href='thread.mutex.requirements'>[thread.mutex.requirements]</a>). It shall be a standard-layout
class (Clause <a href='class'>[class]</a>).</p></div><div class='para' id='mutex.recursive-3'><div class='marginalizedparent'><a class='marginalized' href='#mutex.recursive-3'>3</a></div><p >A thread that owns a <span class='texttt'>recursive_mutex</span> object may acquire additional levels of
ownership by calling <span class='texttt'>lock()</span> or <span class='texttt'>try_lock()</span> on that object. It is
unspecified how many levels of ownership may be acquired by a single thread. If a thread
has already acquired the maximum level of ownership for a <span class='texttt'>recursive_mutex</span>
object, additional calls to <span class='texttt'>try_lock()</span> shall fail, and additional calls to
<span class='texttt'>lock()</span> shall throw an exception of type <span class='texttt'>system_error</span>. A thread
shall call <span class='texttt'>unlock()</span> once for each level of ownership acquired by calls to
<span class='texttt'>lock()</span> and <span class='texttt'>try_lock()</span>. Only when all levels of ownership have been
released may ownership be acquired by another thread.</p></div><div class='para' id='mutex.recursive-4'><div class='marginalizedparent'><a class='marginalized' href='#mutex.recursive-4'>4</a></div><p >The behavior of a program is undefined if:</p><ul ><li ><p >it destroys a <span class='texttt'>recursive_mutex</span> object owned by any thread or
</p></li><li ><p >a thread terminates while owning a <span class='texttt'>recursive_mutex</span> object.
</p></li></ul></div></div></div><div id='timedmutex.requirements'><h4 ><a class='secnum' href='#timedmutex.requirements' style='min-width:118pt'>30.4.1.3</a> Timed mutex types <a class='abbr_ref' href='thread.timedmutex.requirements'>[thread.timedmutex.requirements]</a></h4><div class='para' id='timedmutex.requirements-1'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-1'>1</a></div><p >The <a class='hidden_link' href='#def:timed_mutex_types' id='def:timed_mutex_types'><i>timed mutex types</i></a> are the standard library types <span class='texttt'>std::timed_mutex</span>,
<span class='texttt'>std::recursive_timed_mutex</span>, and <span class='texttt'>std::shared_timed_mutex</span>. They shall
meet the requirements set out below.
In this description, <span class='texttt'>m</span> denotes an object of a mutex type,
<span class='texttt'>rel_time</span> denotes an object of an
instantiation of <span class='texttt'>duration</span> (<a href='time.duration'>[time.duration]</a>), and <span class='texttt'>abs_time</span> denotes an
object of an
instantiation of <span class='texttt'>time_point</span> (<a href='time.point'>[time.point]</a>).</p></div><div class='para' id='timedmutex.requirements-2'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-2'>2</a></div><p >The timed mutex types shall meet the <span class='texttt'>TimedLockable</span>
requirements (<a href='thread.req.lockable.timed'>[thread.req.lockable.timed]</a>).</p></div><div class='para' id='timedmutex.requirements-3'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-3'>3</a></div><p >The expression <span class='texttt'>m.try_lock_for(rel_time)</span> shall be well-formed and have the
following semantics:</p></div><div class='itemdescr'></div><div class='para' id='timedmutex.requirements-4'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>m</span> is of type <span class='texttt'>std::timed_mutex</span> or
<span class='texttt'>std::shared_timed_mutex</span>, the calling thread does not
own the mutex.</p></div></div><div class='para' id='timedmutex.requirements-5'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> The function attempts to obtain ownership of the mutex within the
relative timeout (<a href='thread.req.timing'>[thread.req.timing]</a>)
specified by <span class='texttt'>rel_time</span>. If the time specified by <span class='texttt'>rel_time</span> is less than or
equal to <span class='texttt'>rel_time.zero()</span>, the function attempts to obtain ownership without blocking (as if by calling
<span class='texttt'>try_lock()</span>). The function shall return within the timeout specified by
<span class='texttt'>rel_time</span> only if it has obtained ownership of the mutex object. [&nbsp;<i>Note:</i><span class='space'></span> As
with <span class='texttt'>try_lock()</span>, there is no guarantee that ownership will be obtained if the
lock is available, but implementations are expected to make a strong effort to do so.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='timedmutex.requirements-6'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-6'>6</a></div><div class='itemdescr'><p ><i>Return type:</i> <span class='texttt'>bool</span></p></div></div><div class='para' id='timedmutex.requirements-7'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if ownership was obtained, otherwise <span class='texttt'>false</span>.</p></div></div><div class='para' id='timedmutex.requirements-8'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-8'>8</a></div><div class='itemdescr'><p ><i>Synchronization:</i> If <span class='texttt'>try_lock_for()</span> returns <span class='texttt'>true</span>, prior <span class='texttt'>unlock()</span> operations
on the same object <a class='hidden_link' href='#def:synchronize_with' id='def:synchronize_with'><i>synchronize with</i></a> (<a href='intro.multithread'>[intro.multithread]</a>) this operation.</p></div></div><div class='para' id='timedmutex.requirements-9'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-9'>9</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).
</p></div></div><div class='para' id='timedmutex.requirements-10'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-10'>10</a></div><p >The expression <span class='texttt'>m.try_lock_until(abs_time)</span> shall be well-formed and have the
following semantics:</p></div><div class='itemdescr'></div><div class='para' id='timedmutex.requirements-11'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>m</span> is of type <span class='texttt'>std::timed_mutex</span> or
<span class='texttt'>std::shared_timed_mutex</span>, the calling thread does not own the
mutex.</p></div></div><div class='para' id='timedmutex.requirements-12'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> The function attempts to obtain ownership of the mutex. If
<span class='texttt'>abs_time</span> has already passed, the function attempts to obtain ownership
without blocking (as if by calling <span class='texttt'>try_lock()</span>). The function shall
return before the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by
<span class='texttt'>abs_time</span> only if it has obtained ownership of the mutex object.
[&nbsp;<i>Note:</i><span class='space'></span> As with <span class='texttt'>try_lock()</span>, there is no guarantee that ownership will
be obtained if the lock is available, but implementations are expected to make a
strong effort to do so. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='timedmutex.requirements-13'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-13'>13</a></div><div class='itemdescr'><p ><i>Return type:</i> <span class='texttt'>bool</span></p></div></div><div class='para' id='timedmutex.requirements-14'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if ownership was obtained, otherwise <span class='texttt'>false</span>.</p></div></div><div class='para' id='timedmutex.requirements-15'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-15'>15</a></div><div class='itemdescr'><p ><i>Synchronization:</i> If <span class='texttt'>try_lock_until()</span> returns <span class='texttt'>true</span>, prior <span class='texttt'>unlock()</span>
operations on the same object <a class='hidden_link' href='#def:synchronize_with' id='def:synchronize_with'><i>synchronize with</i></a> (<a href='intro.multithread'>[intro.multithread]</a>)
this operation.</p></div></div><div class='para' id='timedmutex.requirements-16'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.requirements-16'>16</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).
</p></div></div><div id='timedmutex.class'><h4 ><a class='secnum' href='#timedmutex.class' style='min-width:133pt'>30.4.1.3.1</a> Class <span class='texttt'>timed_mutex</span> <a class='abbr_ref' href='thread.timedmutex.class'>[thread.timedmutex.class]</a></h4><p ><span class='indexparent'><a class='index' id='timed_mutex'></a></span></p><pre class='codeblock'>
namespace std {
  class timed_mutex {
  public:
    timed_mutex();
    ~timed_mutex();

    timed_mutex(const timed_mutex&amp;) = delete;
    timed_mutex&amp; operator=(const timed_mutex&amp;) = delete;

    void lock();  <span class='comment'>// blocking
</span>    bool try_lock();
    template &lt;class Rep, class Period&gt;
      bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template &lt;class Clock, class Duration&gt;
      bool try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    void unlock();

    using native_handle_type = <i>implementation-defined</i>; <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>    native_handle_type native_handle();                <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>  };
}
</pre><div class='para' id='timedmutex.class-1'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.class-1'>1</a></div><p >The class <span class='texttt'>timed_mutex</span> provides a non-recursive mutex with exclusive ownership
semantics. If one thread owns a <span class='texttt'>timed_mutex</span> object, attempts by another thread
to acquire ownership of that object will fail (for <span class='texttt'>try_lock()</span>) or block
(for <span class='texttt'>lock()</span>, <span class='texttt'>try_lock_for()</span>, and <span class='texttt'>try_lock_until()</span>) until
the owning thread has released ownership with a call to <span class='texttt'>unlock()</span> or the
call to <span class='texttt'>try_lock_for()</span> or <span class='texttt'>try_lock_until()</span> times out (having
failed to obtain ownership).</p></div><div class='para' id='timedmutex.class-2'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.class-2'>2</a></div><p >The class <span class='texttt'>timed_mutex</span> shall satisfy all of the <span class='texttt'>TimedMutex</span>
requirements (<a href='thread.timedmutex.requirements'>[thread.timedmutex.requirements]</a>). It shall be a standard-layout
class (Clause <a href='class'>[class]</a>).</p></div><div class='para' id='timedmutex.class-3'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.class-3'>3</a></div><p >The behavior of a program is undefined if:</p><ul ><li ><p >it destroys a <span class='texttt'>timed_mutex</span> object owned by any thread,
</p></li><li ><p >a thread that owns a <span class='texttt'>timed_mutex</span> object calls <span class='texttt'>lock()</span>,
<span class='texttt'>try_lock()</span>, <span class='texttt'>try_lock_for()</span>, or <span class='texttt'>try_lock_until()</span> on that object, or
</p></li><li ><p >a thread terminates while owning a <span class='texttt'>timed_mutex</span> object.
</p></li></ul></div></div><div id='timedmutex.recursive'><h4 ><a class='secnum' href='#timedmutex.recursive' style='min-width:133pt'>30.4.1.3.2</a> Class <span class='texttt'>recursive_timed_mutex</span> <a class='abbr_ref' href='thread.timedmutex.recursive'>[thread.timedmutex.recursive]</a></h4><p ><span class='indexparent'><a class='index' id='recursive_timed_mutex'></a></span></p><pre class='codeblock'>
namespace std {
  class recursive_timed_mutex {
  public:
    recursive_timed_mutex();
    ~recursive_timed_mutex();

    recursive_timed_mutex(const recursive_timed_mutex&amp;) = delete;
    recursive_timed_mutex&amp; operator=(const recursive_timed_mutex&amp;) = delete;

    void lock();  <span class='comment'>// blocking
</span>    bool try_lock() noexcept;
    template &lt;class Rep, class Period&gt;
      bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template &lt;class Clock, class Duration&gt;
      bool try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    void unlock();

    using native_handle_type = <i>implementation-defined</i>; <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>    native_handle_type native_handle();                <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>  };
}
</pre><div class='para' id='timedmutex.recursive-1'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.recursive-1'>1</a></div><p >The class <span class='texttt'>recursive_timed_mutex</span> provides a recursive mutex with exclusive
ownership semantics. If one thread owns a <span class='texttt'>recursive_timed_mutex</span> object,
attempts by another thread to acquire ownership of that object will fail (for
<span class='texttt'>try_lock()</span>) or block (for <span class='texttt'>lock()</span>, <span class='texttt'>try_lock_for()</span>, and
<span class='texttt'>try_lock_until()</span>) until the owning thread has completely released
ownership or the call to <span class='texttt'>try_lock_for()</span> or <span class='texttt'>try_lock_until()</span>
times out (having failed to obtain ownership).</p></div><div class='para' id='timedmutex.recursive-2'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.recursive-2'>2</a></div><p >The class <span class='texttt'>recursive_timed_mutex</span> shall satisfy all of the <span class='texttt'>TimedMutex</span>
requirements (<a href='thread.timedmutex.requirements'>[thread.timedmutex.requirements]</a>). It shall be a standard-layout
class (Clause <a href='class'>[class]</a>).</p></div><div class='para' id='timedmutex.recursive-3'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.recursive-3'>3</a></div><p >A thread that owns a <span class='texttt'>recursive_timed_mutex</span> object may acquire additional
levels of ownership by calling <span class='texttt'>lock()</span>, <span class='texttt'>try_lock()</span>,
<span class='texttt'>try_lock_for()</span>, or <span class='texttt'>try_lock_until()</span> on that object. It is
unspecified how many levels of ownership may be acquired by a single thread. If
a thread has already acquired the maximum level of ownership for a
<span class='texttt'>recursive_timed_mutex</span> object, additional calls to <span class='texttt'>try_lock()</span>,
<span class='texttt'>try_lock_for()</span>, or <span class='texttt'>try_lock_until()</span> shall fail, and additional
calls to <span class='texttt'>lock()</span> shall throw an exception of type <span class='texttt'>system_error</span>. A
thread shall call <span class='texttt'>unlock()</span> once for each level of ownership acquired by
calls to <span class='texttt'>lock()</span>, <span class='texttt'>try_lock()</span>, <span class='texttt'>try_lock_for()</span>, and
<span class='texttt'>try_lock_until()</span>. Only when all levels of ownership have been released
may ownership of the object be acquired by another thread.</p></div><div class='para' id='timedmutex.recursive-4'><div class='marginalizedparent'><a class='marginalized' href='#timedmutex.recursive-4'>4</a></div><p >The behavior of a program is undefined if:</p><ul ><li ><p >it destroys a <span class='texttt'>recursive_timed_mutex</span> object owned by any thread, or
</p></li><li ><p >a thread terminates while owning a <span class='texttt'>recursive_timed_mutex</span> object.
</p></li></ul></div></div></div><div id='sharedmutex.requirements'><h4 ><a class='secnum' href='#sharedmutex.requirements' style='min-width:118pt'>30.4.1.4</a> Shared mutex types <a class='abbr_ref' href='thread.sharedmutex.requirements'>[thread.sharedmutex.requirements]</a></h4><div class='para' id='sharedmutex.requirements-1'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-1'>1</a></div><p >The standard library types <span class='texttt'>std::shared_mutex</span> and <span class='texttt'>std::shared_timed_mutex</span>
are <a class='hidden_link' href='#def:shared_mutex_types' id='def:shared_mutex_types'><i>shared mutex types</i></a>. Shared mutex types shall meet the requirements of
mutex types (<a href='thread.mutex.requirements.mutex'>[thread.mutex.requirements.mutex]</a>), and additionally
shall meet the requirements set out below. In this description,
<span class='texttt'>m</span> denotes an object of a shared mutex type.</p></div><div class='para' id='sharedmutex.requirements-2'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-2'>2</a></div><p >In addition to the exclusive lock ownership mode specified
in <a href='thread.mutex.requirements.mutex'>[thread.mutex.requirements.mutex]</a>, shared mutex types provide a
<a class='hidden_link' href='#def:shared_lock' id='def:shared_lock'><i>shared lock</i></a> ownership mode. Multiple execution agents can
simultaneously hold a shared lock ownership of a shared mutex type. But no
execution agent shall hold a shared lock while another execution agent holds an
exclusive lock on the same shared mutex type, and vice-versa. The maximum
number of execution agents which can share a shared lock on a single shared
mutex type is unspecified, but shall be at least 10000. If more than the
maximum number of execution agents attempt to obtain a shared lock, the
excess execution agents shall block until the number of shared locks are
reduced below the maximum amount by other execution agents releasing their
shared lock.</p></div><div class='para' id='sharedmutex.requirements-3'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-3'>3</a></div><p >The expression <span class='texttt'>m.lock_shared()</span> shall be well-formed and have the
following semantics:</p></div><div class='itemdescr'></div><div class='para' id='sharedmutex.requirements-4'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> The calling thread has no ownership of the mutex.</p></div></div><div class='para' id='sharedmutex.requirements-5'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Blocks the calling thread until shared ownership of the mutex can be obtained for the calling thread.
If an exception is thrown then a shared lock shall not have been acquired for the current thread.</p></div></div><div class='para' id='sharedmutex.requirements-6'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-6'>6</a></div><div class='itemdescr'><p ><i>Postconditions:</i> The calling thread has a shared lock on the mutex.</p></div></div><div class='para' id='sharedmutex.requirements-7'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-7'>7</a></div><div class='itemdescr'><p ><i>Return type:</i> <span class='texttt'>void</span>.</p></div></div><div class='para' id='sharedmutex.requirements-8'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-8'>8</a></div><div class='itemdescr'><p ><i>Synchronization:</i> Prior <span class='texttt'>unlock()</span> operations on the same object shall synchronize with  (<a href='intro.multithread'>[intro.multithread]</a>) this operation.</p></div></div><div class='para' id='sharedmutex.requirements-9'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-9'>9</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when an exception is required  (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='sharedmutex.requirements-10'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-10'>10</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>operation_not_permitted</span> — if the thread does not have the privilege to perform the operation.
</p></li><li ><p ><span class='texttt'>resource_deadlock_would_occur</span> — if the implementation detects that a deadlock would occur.
</p></li></ul></div></div><div class='para' id='sharedmutex.requirements-11'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-11'>11</a></div><p >The expression <span class='texttt'>m.unlock_shared()</span> shall be well-formed and have the following semantics:</p></div><div class='itemdescr'></div><div class='para' id='sharedmutex.requirements-12'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-12'>12</a></div><div class='itemdescr'><p ><i>Requires:</i> The calling thread shall hold a shared lock on the mutex.</p></div></div><div class='para' id='sharedmutex.requirements-13'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Releases a shared lock on the mutex held by the calling thread.</p></div></div><div class='para' id='sharedmutex.requirements-14'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-14'>14</a></div><div class='itemdescr'><p ><i>Return type:</i> <span class='texttt'>void</span>.</p></div></div><div class='para' id='sharedmutex.requirements-15'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-15'>15</a></div><div class='itemdescr'><p ><i>Synchronization:</i> This operation synchronizes with (<a href='intro.multithread'>[intro.multithread]</a>) subsequent
<span class='texttt'>lock()</span> operations that obtain ownership on the same object.</p></div></div><div class='para' id='sharedmutex.requirements-16'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-16'>16</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><div class='para' id='sharedmutex.requirements-17'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-17'>17</a></div><p >The expression <span class='texttt'>m.try_lock_shared()</span> shall be well-formed and have the following semantics:</p></div><div class='itemdescr'></div><div class='para' id='sharedmutex.requirements-18'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-18'>18</a></div><div class='itemdescr'><p ><i>Requires:</i> The calling thread has no ownership of the mutex.</p></div></div><div class='para' id='sharedmutex.requirements-19'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> Attempts to obtain shared ownership of the mutex for the calling
thread without blocking. If shared ownership is not obtained, there is no
effect and <span class='texttt'>try_lock_shared()</span> immediately returns. An implementation
may fail to obtain the lock even if it is not held by any other thread.</p></div></div><div class='para' id='sharedmutex.requirements-20'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-20'>20</a></div><div class='itemdescr'><p ><i>Return type:</i> <span class='texttt'>bool</span>.</p></div></div><div class='para' id='sharedmutex.requirements-21'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-21'>21</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the shared ownership lock was acquired, <span class='texttt'>false</span>
otherwise.</p></div></div><div class='para' id='sharedmutex.requirements-22'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-22'>22</a></div><div class='itemdescr'><p ><i>Synchronization:</i> If <span class='texttt'>try_lock_shared()</span> returns <span class='texttt'>true</span>, prior <span class='texttt'>unlock()</span>
operations on the same object synchronize with  (<a href='intro.multithread'>[intro.multithread]</a>) this
operation.</p></div></div><div class='para' id='sharedmutex.requirements-23'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.requirements-23'>23</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><div id='sharedmutex.class'><h4 ><a class='secnum' href='#sharedmutex.class' style='min-width:133pt'>30.4.1.4.1</a> Class shared_mutex <a class='abbr_ref' href='thread.sharedmutex.class'>[thread.sharedmutex.class]</a></h4><p ><span class='indexparent'><a class='index' id='shared_mutex'></a></span></p><pre class='codeblock'>
namespace std {
  class shared_mutex {
  public:
     shared_mutex();
     ~shared_mutex();

     shared_mutex(const shared_mutex&amp;) = delete;
     shared_mutex&amp; operator=(const shared_mutex&amp;) = delete;

     <span class='comment'>// Exclusive ownership
</span>     void lock(); <span class='comment'>// blocking
</span>     bool try_lock();
     void unlock();

     <span class='comment'>// Shared ownership
</span>     void lock_shared(); <span class='comment'>// blocking
</span>     bool try_lock_shared();
     void unlock_shared();

     using native_handle_type = <i>implementation-defined</i>; <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>     native_handle_type native_handle();                <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>  };
}
</pre><div class='para' id='sharedmutex.class-1'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.class-1'>1</a></div><p >The class <span class='texttt'>shared_mutex</span> provides a non-recursive mutex
with shared ownership semantics.</p></div><div class='para' id='sharedmutex.class-2'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.class-2'>2</a></div><p >The class <span class='texttt'>shared_mutex</span> shall satisfy all of the requirements for
shared mutexes (<a href='thread.sharedmutex.requirements'>[thread.sharedmutex.requirements]</a>).
It shall be a standard-layout class (Clause <a href='class'>[class]</a>).</p></div><div class='para' id='sharedmutex.class-3'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.class-3'>3</a></div><p >The behavior of a program is undefined if:
</p><ul ><li ><p >it destroys a <span class='texttt'>shared_mutex</span> object owned by any thread,
</p></li><li ><p >a thread attempts to recursively gain any ownership of a <span class='texttt'>shared_mutex</span>, or
</p></li><li ><p >a thread terminates while possessing any ownership of a <span class='texttt'>shared_mutex</span>.
</p></li></ul></div><div class='para' id='sharedmutex.class-4'><div class='marginalizedparent'><a class='marginalized' href='#sharedmutex.class-4'>4</a></div><p ><span class='texttt'>shared_mutex</span> may be a synonym for <span class='texttt'>shared_timed_mutex</span>.</p></div></div></div><div id='sharedtimedmutex.requirements'><h4 ><a class='secnum' href='#sharedtimedmutex.requirements' style='min-width:118pt'>30.4.1.5</a> Shared timed mutex types <a class='abbr_ref' href='thread.sharedtimedmutex.requirements'>[thread.sharedtimedmutex.requirements]</a></h4><div class='para' id='sharedtimedmutex.requirements-1'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-1'>1</a></div><p >The standard library type <span class='texttt'>std::shared_timed_mutex</span> is a
<a class='hidden_link' href='#def:shared_timed_mutex_type' id='def:shared_timed_mutex_type'><i>shared timed mutex type</i></a>. Shared timed mutex types shall meet the requirements of
timed mutex types (<a href='thread.timedmutex.requirements'>[thread.timedmutex.requirements]</a>),
shared mutex types (<a href='thread.sharedmutex.requirements'>[thread.sharedmutex.requirements]</a>), and additionally
shall meet the requirements set out below. In this description,
<span class='texttt'>m</span> denotes an object of a shared timed mutex type,
<span class='texttt'>rel_type</span> denotes an object of an instantiation of
<span class='texttt'>duration</span> (<a href='time.duration'>[time.duration]</a>), and
<span class='texttt'>abs_time</span> denotes an object of an instantiation of
<span class='texttt'>time_point</span> (<a href='time.point'>[time.point]</a>).</p></div><div class='para' id='sharedtimedmutex.requirements-2'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-2'>2</a></div><p >The expression <span class='texttt'>m.try_lock_shared_for(rel_time)</span> shall be well-formed and
have the following semantics:</p></div><div class='itemdescr'></div><div class='para' id='sharedtimedmutex.requirements-3'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> The calling thread has no ownership of the mutex.</p></div></div><div class='para' id='sharedtimedmutex.requirements-4'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Attempts to obtain
shared lock ownership for the calling thread within the relative
timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>rel_time</span>. If the time
specified by <span class='texttt'>rel_time</span> is less than or equal to <span class='texttt'>rel_time.zero()</span>,
the function attempts to obtain ownership without blocking (as if by calling
<span class='texttt'>try_lock_shared()</span>). The function shall return within the timeout
specified by <span class='texttt'>rel_time</span> only if it has obtained shared ownership of the
mutex object. [&nbsp;<i>Note:</i><span class='space'></span> As with <span class='texttt'>try_lock()</span>, there is no guarantee that
ownership will be obtained if the lock is available, but implementations are
expected to make a strong effort to do so. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
If an exception is thrown then a shared lock shall not have been acquired for
the current thread.</p></div></div><div class='para' id='sharedtimedmutex.requirements-5'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-5'>5</a></div><div class='itemdescr'><p ><i>Return type:</i> <span class='texttt'>bool</span>.</p></div></div><div class='para' id='sharedtimedmutex.requirements-6'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the shared lock was acquired, <span class='texttt'>false</span> otherwise.</p></div></div><div class='para' id='sharedtimedmutex.requirements-7'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-7'>7</a></div><div class='itemdescr'><p ><i>Synchronization:</i> If <span class='texttt'>try_lock_shared_for()</span> returns <span class='texttt'>true</span>, prior
<span class='texttt'>unlock()</span> operations on the same object synchronize
with (<a href='intro.multithread'>[intro.multithread]</a>) this operation.</p></div></div><div class='para' id='sharedtimedmutex.requirements-8'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-8'>8</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).
</p></div></div><div class='para' id='sharedtimedmutex.requirements-9'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-9'>9</a></div><p >The expression <span class='texttt'>m.try_lock_shared_until(abs_time)</span> shall be well-formed
and have the following semantics:</p></div><div class='itemdescr'></div><div class='para' id='sharedtimedmutex.requirements-10'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-10'>10</a></div><div class='itemdescr'><p ><i>Requires:</i> The calling thread has no ownership of the mutex.</p></div></div><div class='para' id='sharedtimedmutex.requirements-11'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> The function attempts to obtain shared ownership of the mutex. If
<span class='texttt'>abs_time</span> has already passed, the function attempts to obtain shared
ownership without blocking (as if by calling <span class='texttt'>try_lock_shared()</span>). The
function shall return before the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>)
specified by <span class='texttt'>abs_time</span> only if it has obtained shared ownership of the
mutex object. [&nbsp;<i>Note:</i><span class='space'></span> As with <span class='texttt'>try_lock()</span>, there is no guarantee that
ownership will be obtained if the lock is available, but implementations are
expected to make a strong effort to do so. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
If an exception is thrown then a shared lock shall not have been acquired for
the current thread.</p></div></div><div class='para' id='sharedtimedmutex.requirements-12'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-12'>12</a></div><div class='itemdescr'><p ><i>Return type:</i> <span class='texttt'>bool</span>.</p></div></div><div class='para' id='sharedtimedmutex.requirements-13'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if the shared lock was acquired, <span class='texttt'>false</span> otherwise.</p></div></div><div class='para' id='sharedtimedmutex.requirements-14'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-14'>14</a></div><div class='itemdescr'><p ><i>Synchronization:</i> If <span class='texttt'>try_lock_shared_until()</span> returns <span class='texttt'>true</span>, prior
<span class='texttt'>unlock()</span> operations on the same object synchronize
with (<a href='intro.multithread'>[intro.multithread]</a>) this operation.</p></div></div><div class='para' id='sharedtimedmutex.requirements-15'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.requirements-15'>15</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).
</p></div></div><div id='sharedtimedmutex.class'><h4 ><a class='secnum' href='#sharedtimedmutex.class' style='min-width:133pt'>30.4.1.5.1</a> Class <span class='texttt'>shared_timed_mutex</span> <a class='abbr_ref' href='thread.sharedtimedmutex.class'>[thread.sharedtimedmutex.class]</a></h4><p ><span class='indexparent'><a class='index' id='shared_timed_mutex'></a></span></p><pre class='codeblock'>
namespace std {
  class shared_timed_mutex {
  public:
    shared_timed_mutex();
    ~shared_timed_mutex();
  
    shared_timed_mutex(const shared_timed_mutex&amp;) = delete;
    shared_timed_mutex&amp; operator=(const shared_timed_mutex&amp;) = delete;
  
    <span class='comment'>// Exclusive ownership
</span>    void lock();  <span class='comment'>// blocking
</span>    bool try_lock();
    template &lt;class Rep, class Period&gt;
      bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template &lt;class Clock, class Duration&gt;
      bool try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    void unlock();
  
    <span class='comment'>// Shared ownership
</span>    void lock_shared();  <span class='comment'>// blocking
</span>    bool try_lock_shared();
    template &lt;class Rep, class Period&gt;
      bool
      try_lock_shared_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template &lt;class Clock, class Duration&gt;
      bool
      try_lock_shared_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    void unlock_shared();
  };
}
</pre><div class='para' id='sharedtimedmutex.class-1'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.class-1'>1</a></div><p >The class <span class='texttt'>shared_timed_mutex</span> provides a non-recursive mutex with shared
ownership semantics.</p></div><div class='para' id='sharedtimedmutex.class-2'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.class-2'>2</a></div><p >The class <span class='texttt'>shared_timed_mutex</span> shall satisfy all of the
requirements for shared timed mutexes (<a href='thread.sharedtimedmutex.requirements'>[thread.sharedtimedmutex.requirements]</a>).
It shall be a standard-layout class (Clause <a href='class'>[class]</a>).</p></div><div class='para' id='sharedtimedmutex.class-3'><div class='marginalizedparent'><a class='marginalized' href='#sharedtimedmutex.class-3'>3</a></div><p >The behavior of a program is undefined if:
</p><ul ><li ><p >it destroys a <span class='texttt'>shared_timed_mutex</span> object owned by any thread,
</p></li><li ><p >a thread attempts to recursively gain any ownership of a <span class='texttt'>shared_timed_mutex</span>, or
</p></li><li ><p >a thread terminates while possessing any ownership of a <span class='texttt'>shared_timed_mutex</span>.
</p></li></ul></div></div></div></div><div id='lock'><h3 ><a class='secnum' href='#lock' style='min-width:103pt'>30.4.2</a> Locks <a class='abbr_ref' href='thread.lock'>[thread.lock]</a></h3><div class='para' id='lock-1'><div class='marginalizedparent'><a class='marginalized' href='#lock-1'>1</a></div><p >A <a class='hidden_link' href='#def:lock' id='def:lock'><i>lock</i></a> is an object that holds a reference to a lockable object and may unlock the
lockable object during the lock's destruction (such as when leaving block scope). An execution
agent may use a lock to aid in managing ownership of a lockable object in an exception safe
manner. A lock is said to <a class='hidden_link' href='#def:own' id='def:own'><i>own</i></a> a lockable object if it is currently managing the
ownership of that lockable object for an execution agent. A lock does not manage the lifetime
of the lockable object it references. [&nbsp;<i>Note:</i><span class='space'></span> Locks are intended to ease the burden of
unlocking the lockable object under both normal and exceptional circumstances. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='lock-2'><div class='marginalizedparent'><a class='marginalized' href='#lock-2'>2</a></div><p >Some lock constructors take tag types which describe what should be done with the lockable
object during the lock's construction.</p><p ><span class='indexparent'><a class='index' id='defer_lock_t'></a></span><span class='indexparent'><a class='index' id='try_to_lock_t'></a></span><span class='indexparent'><a class='index' id='adopt_lock_t'></a></span><span class='indexparent'><a class='index' id='defer_lock'></a></span><span class='indexparent'><a class='index' id='try_to_lock'></a></span><span class='indexparent'><a class='index' id='adopt_lock'></a></span></p><pre class='codeblock'>
namespace std {
  struct defer_lock_t  { };     <span class='comment'>// do not acquire ownership of the mutex
</span>  struct try_to_lock_t { };     <span class='comment'>// try to acquire ownership of the mutex
</span>                                <span class='comment'>// without blocking
</span>  struct adopt_lock_t  { };     <span class='comment'>// assume the calling thread has already
</span>                                <span class='comment'>// obtained mutex ownership and manage it
</span>
  constexpr defer_lock_t   defer_lock { };
  constexpr try_to_lock_t  try_to_lock { };
  constexpr adopt_lock_t   adopt_lock { };
}
</pre></div><div id='lock.guard'><h4 ><a class='secnum' href='#lock.guard' style='min-width:118pt'>30.4.2.1</a> Class template <span class='texttt'>lock_guard</span> <a class='abbr_ref' href='thread.lock.guard'>[thread.lock.guard]</a></h4><p ><span class='indexparent'><a class='index' id='lock_guard'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class... MutexTypes&gt;
  class lock_guard {
  public:
    using mutex_type = Mutex;  <span class='comment'>// If <span class='texttt'>MutexTypes...</span> consists of the single type <span class='texttt'>Mutex</span>
</span>
    explicit lock_guard(MutexTypes&amp;... m);
    lock_guard(MutexTypes&amp;... m, adopt_lock_t);
    ~lock_guard();

    lock_guard(lock_guard const&amp;) = delete;
    lock_guard&amp; operator=(lock_guard const&amp;) = delete;

  private:
    tuple&lt;MutexTypes&amp;...&gt; pm; <span class='comment'>// <i>exposition only</i>
</span>  };
}
</pre><div class='para' id='lock.guard-1'><div class='marginalizedparent'><a class='marginalized' href='#lock.guard-1'>1</a></div><p >An object of type <span class='texttt'>lock_guard</span> controls the ownership of lockable objects
within a scope. A <span class='texttt'>lock_guard</span> object maintains ownership of lockable
objects throughout the <span class='texttt'>lock_guard</span> object's lifetime (<a href='basic.life'>[basic.life]</a>).
The behavior of a program is undefined if the lockable objects referenced by
<span class='texttt'>pm</span> do not exist for the entire lifetime of the <span class='texttt'>lock_guard</span>
object.
When <span class='texttt'>sizeof...(MutexTypes)</span> is <span class='texttt'>1</span>,
the supplied <span class='texttt'>Mutex</span> type
shall meet the <span class='texttt'>BasicLockable</span> requirements.
Otherwise, each of the mutex types
shall meet the <span class='texttt'>Lockable</span> requirements (<a href='thread.req.lockable.basic'>[thread.req.lockable.basic]</a>).</p><p ><span class='indexparent'><a class='index' id='lock_guard,constructor'></a></span><code class='itemdecl'>
explicit lock_guard(MutexTypes&amp;... m);
</code></p></div><div class='itemdescr'></div><div class='para' id='lock.guard-2'><div class='marginalizedparent'><a class='marginalized' href='#lock.guard-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> If a <span class='texttt'>MutexTypes</span> type is not a recursive mutex,
the calling thread does not own the corresponding mutex element of <span class='texttt'>m</span>.</p></div></div><div class='para' id='lock.guard-3'><div class='marginalizedparent'><a class='marginalized' href='#lock.guard-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>pm</span> with <span class='texttt'>tie(m...)</span>.
Then if <span class='texttt'>sizeof...(MutexTypes)</span> is <span class='texttt'>0</span>, no effects.
Otherwise if <span class='texttt'>sizeof...(MutexTypes)</span> is <span class='texttt'>1</span>, then <span class='texttt'>m.lock()</span>.
Otherwise, then <span class='texttt'>lock(m...)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='lock_guard,constructor'></a></span><code class='itemdecl'>
lock_guard(MutexTypes&amp;... m, adopt_lock_t);
</code></p><div class='itemdescr'></div><div class='para' id='lock.guard-4'><div class='marginalizedparent'><a class='marginalized' href='#lock.guard-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> The calling thread owns all the mutexes in <span class='texttt'>m</span>.</p></div></div><div class='para' id='lock.guard-5'><div class='marginalizedparent'><a class='marginalized' href='#lock.guard-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes <span class='texttt'>pm</span> with <span class='texttt'>tie(m...)</span>.</p></div></div><div class='para' id='lock.guard-6'><div class='marginalizedparent'><a class='marginalized' href='#lock.guard-6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='lock_guard,destructor'></a></span><code class='itemdecl'>
~lock_guard();
</code></p><div class='itemdescr'></div><div class='para' id='lock.guard-7'><div class='marginalizedparent'><a class='marginalized' href='#lock.guard-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> For all <span class='texttt'>i</span> in <span class='texttt'>[0, sizeof...(MutexTypes))</span>,
<span class='texttt'>get&lt;i&gt;(pm).unlock()</span>.
</p></div></div></div><div id='lock.unique'><h4 ><a class='secnum' href='#lock.unique' style='min-width:118pt'>30.4.2.2</a> Class template <span class='texttt'>unique_lock</span> <a class='abbr_ref' href='thread.lock.unique'>[thread.lock.unique]</a></h4><p ><span class='indexparent'><a class='index' id='unique_lock'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class Mutex&gt;
  class unique_lock {
  public:
    using mutex_type = Mutex;

    <span class='comment'>// <a href='thread.lock.unique.cons'>[thread.lock.unique.cons]</a>, construct/copy/destroy:
</span>    unique_lock() noexcept;
    explicit unique_lock(mutex_type&amp; m);
    unique_lock(mutex_type&amp; m, defer_lock_t) noexcept;
    unique_lock(mutex_type&amp; m, try_to_lock_t);
    unique_lock(mutex_type&amp; m, adopt_lock_t);
    template &lt;class Clock, class Duration&gt;
      unique_lock(mutex_type&amp; m, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    template &lt;class Rep, class Period&gt;
      unique_lock(mutex_type&amp; m, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    ~unique_lock();

    unique_lock(unique_lock const&amp;) = delete;
    unique_lock&amp; operator=(unique_lock const&amp;) = delete;

    unique_lock(unique_lock&amp;&amp; u) noexcept;
    unique_lock&amp; operator=(unique_lock&amp;&amp; u);

    <span class='comment'>// <a href='thread.lock.unique.locking'>[thread.lock.unique.locking]</a>, locking:
</span>    void lock();
    bool try_lock();

    template &lt;class Rep, class Period&gt;
      bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template &lt;class Clock, class Duration&gt;
      bool try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);

    void unlock();

    <span class='comment'>// <a href='thread.lock.unique.mod'>[thread.lock.unique.mod]</a>, modifiers:
</span>    void swap(unique_lock&amp; u) noexcept;
    mutex_type* release() noexcept;

    <span class='comment'>// <a href='thread.lock.unique.obs'>[thread.lock.unique.obs]</a>, observers:
</span>    bool owns_lock() const noexcept;
    explicit operator bool () const noexcept;
    mutex_type* mutex() const noexcept;

  private:
    mutex_type* pm; <span class='comment'>// <i>exposition only</i>
</span>    bool owns;      <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class Mutex&gt;
    void swap(unique_lock&lt;Mutex&gt;&amp; x, unique_lock&lt;Mutex&gt;&amp; y) noexcept;
}
</pre><div class='para' id='lock.unique-1'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique-1'>1</a></div><p >An object of type <span class='texttt'>unique_lock</span> controls the ownership of a lockable
object within a scope. Ownership of the lockable object may be acquired at
construction or after construction, and may be transferred, after
acquisition, to another <span class='texttt'>unique_lock</span> object. Objects of type <span class='texttt'>unique_lock</span> are not
copyable but are movable. The behavior of a program is undefined if the contained pointer
<span class='texttt'>pm</span> is not null and the lockable object pointed
to by <span class='texttt'>pm</span> does not exist for the entire remaining
lifetime (<a href='basic.life'>[basic.life]</a>) of the <span class='texttt'>unique_lock</span> object. The supplied
<span class='texttt'>Mutex</span> type shall meet the <span class='texttt'>BasicLockable</span>
requirements (<a href='thread.req.lockable.basic'>[thread.req.lockable.basic]</a>).</p></div><div class='para' id='lock.unique-2'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique-2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> <span class='texttt'>unique_lock&lt;Mutex&gt;</span> meets the <span class='texttt'>BasicLockable</span> requirements. If <span class='texttt'>Mutex</span>
meets the <span class='texttt'>Lockable</span> requirements (<a href='thread.req.lockable.req'>[thread.req.lockable.req]</a>),
<span class='texttt'>unique_lock&lt;Mutex&gt;</span> also meets the <span class='texttt'>Lockable</span> requirements;
if <span class='texttt'>Mutex</span>
meets the <span class='texttt'>TimedLockable</span> requirements (<a href='thread.req.lockable.timed'>[thread.req.lockable.timed]</a>),
<span class='texttt'>unique_lock&lt;Mutex&gt;</span> also meets the <span class='texttt'>TimedLockable</span> requirements. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='lock.unique.cons'><h4 ><a class='secnum' href='#lock.unique.cons' style='min-width:133pt'>30.4.2.2.1</a> <span class='texttt'>unique_lock</span> constructors, destructor, and assignment <a class='abbr_ref' href='thread.lock.unique.cons'>[thread.lock.unique.cons]</a></h4><p ><span class='indexparent'><a class='index' id='unique_lock,constructor'></a></span><code class='itemdecl'>
unique_lock() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>unique_lock</span>.</p></div></div><div class='para' id='lock.unique.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == 0</span> and <span class='texttt'>owns == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_lock,constructor'></a></span><code class='itemdecl'>
explicit unique_lock(mutex_type&amp; m);
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>mutex_type</span> is not a recursive mutex the calling thread does not own the mutex.</p></div></div><div class='para' id='lock.unique.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>unique_lock</span> and calls <span class='texttt'>m.lock()</span>.</p></div></div><div class='para' id='lock.unique.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == addressof(m)</span> and <span class='texttt'>owns == true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_lock,constructor'></a></span><code class='itemdecl'>
unique_lock(mutex_type&amp; m, defer_lock_t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>unique_lock</span>.</p></div></div><div class='para' id='lock.unique.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-7'>7</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == addressof(m)</span> and <span class='texttt'>owns == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_lock,constructor'></a></span><code class='itemdecl'>
unique_lock(mutex_type&amp; m, try_to_lock_t);
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i>
The supplied <span class='texttt'>Mutex</span> type shall meet the <span class='texttt'>Lockable</span>
requirements (<a href='thread.req.lockable.req'>[thread.req.lockable.req]</a>).
If <span class='texttt'>mutex_type</span> is not a recursive mutex the calling thread does not own the mutex.</p></div></div><div class='para' id='lock.unique.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>unique_lock</span> and calls <span class='texttt'>m.try_lock()</span>.</p></div></div><div class='para' id='lock.unique.cons-10'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-10'>10</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == addressof(m)</span> and <span class='texttt'>owns == res</span>,
where <span class='texttt'>res</span> is the value returned by the call to <span class='texttt'>m.try_lock()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_lock,constructor'></a></span><code class='itemdecl'>
unique_lock(mutex_type&amp; m, adopt_lock_t);
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.cons-11'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i> The calling thread owns the mutex.</p></div></div><div class='para' id='lock.unique.cons-12'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>unique_lock</span>.</p></div></div><div class='para' id='lock.unique.cons-13'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-13'>13</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == addressof(m)</span> and <span class='texttt'>owns == true</span>.</p></div></div><div class='para' id='lock.unique.cons-14'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-14'>14</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_lock,constructor'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration&gt;
  unique_lock(mutex_type&amp; m, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.cons-15'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-15'>15</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>mutex_type</span> is not a recursive mutex the calling thread
does not own the mutex. The supplied <span class='texttt'>Mutex</span> type shall meet the
<span class='texttt'>TimedLockable</span> requirements (<a href='thread.req.lockable.timed'>[thread.req.lockable.timed]</a>).</p></div></div><div class='para' id='lock.unique.cons-16'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>unique_lock</span> and calls <span class='texttt'>m.try_lock_until(abs_time)</span>.</p></div></div><div class='para' id='lock.unique.cons-17'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-17'>17</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == addressof(m)</span> and <span class='texttt'>owns == res</span>,
where <span class='texttt'>res</span> is
the value returned by the call to <span class='texttt'>m.try_lock_until(abs_time)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_lock,constructor'></a></span><code class='itemdecl'>
template &lt;class Rep, class Period&gt;
  unique_lock(mutex_type&amp; m, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.cons-18'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-18'>18</a></div><div class='itemdescr'><p ><i>Requires:</i> If <span class='texttt'>mutex_type</span> is not a recursive mutex the calling thread does not own the mutex.
The supplied <span class='texttt'>Mutex</span> type shall meet the <span class='texttt'>TimedLockable</span> requirements (<a href='thread.req.lockable.timed'>[thread.req.lockable.timed]</a>).</p></div></div><div class='para' id='lock.unique.cons-19'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>unique_lock</span> and calls <span class='texttt'>m.try_lock_for(rel_time)</span>.</p></div></div><div class='para' id='lock.unique.cons-20'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-20'>20</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == addressof(m)</span> and <span class='texttt'>owns == res</span>,
where <span class='texttt'>res</span> is the value returned by the call to <span class='texttt'>m.try_lock_for(rel_time)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_lock,constructor'></a></span><code class='itemdecl'>
unique_lock(unique_lock&amp;&amp; u) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.cons-21'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-21'>21</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == u_p.pm</span> and <span class='texttt'>owns == u_p.owns</span> (where <span class='texttt'>u_p</span> is the state of <span class='texttt'>u</span> just prior to this construction),  <span class='texttt'>u.pm == 0</span> and <span class='texttt'>u.owns == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,unique_lock'></a></span><span class='indexparent'><a class='index' id='unique_lock,operator='></a></span><code class='itemdecl'>
unique_lock&amp; operator=(unique_lock&amp;&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.cons-22'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>owns</span> calls <span class='texttt'>pm-&gt;unlock()</span>.</p></div></div><div class='para' id='lock.unique.cons-23'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-23'>23</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == u_p.pm</span> and <span class='texttt'>owns == u_p.owns</span> (where <span class='texttt'>u_p</span> is the state of <span class='texttt'>u</span> just prior to this construction),  <span class='texttt'>u.pm == 0</span> and <span class='texttt'>u.owns == false</span>.</p></div></div><div class='para' id='lock.unique.cons-24'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-24'>24</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span> With a recursive mutex it is possible for both <span class='texttt'>*this</span> and <span class='texttt'>u</span> to own the same mutex before the assignment. In this case, <span class='texttt'>*this</span> will own the mutex after the assignment and <span class='texttt'>u</span> will not. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='lock.unique.cons-25'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-25'>25</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='unique_lock,destructor'></a></span><code class='itemdecl'>
~unique_lock();
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.cons-26'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.cons-26'>26</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>owns</span> calls <span class='texttt'>pm-&gt;unlock()</span>.
</p></div></div></div><div id='lock.unique.locking'><h4 ><a class='secnum' href='#lock.unique.locking' style='min-width:133pt'>30.4.2.2.2</a> <span class='texttt'>unique_lock</span> locking <a class='abbr_ref' href='thread.lock.unique.locking'>[thread.lock.unique.locking]</a></h4><p ><span class='indexparent'><a class='index' id='lock,unique_lock'></a></span><span class='indexparent'><a class='index' id='unique_lock,lock'></a></span><code class='itemdecl'>
void lock();
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.locking-1'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>pm-&gt;lock()</span>.</p></div></div><div class='para' id='lock.unique.locking-2'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>owns == true</span></p></div></div><div class='para' id='lock.unique.locking-3'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i>
Any exception thrown by <span class='texttt'>pm-&gt;lock()</span>. <span class='texttt'>system_error</span> if an exception
is required (<a href='thread.req.exception'>[thread.req.exception]</a>). <span class='texttt'>system_error</span> with an error
condition of <span class='texttt'>operation_not_permitted</span> if <span class='texttt'>pm</span> is 0. <span class='texttt'>system_error</span>
with an error condition of <span class='texttt'>resource_deadlock_would_occur</span> if on entry <span class='texttt'>owns</span>
is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='try_lock,unique_lock'></a></span><span class='indexparent'><a class='index' id='unique_lock,try_lock'></a></span><code class='itemdecl'>
bool try_lock();
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.locking-4'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> The supplied <span class='texttt'>Mutex</span> shall meet the <span class='texttt'>Lockable</span>
requirements (<a href='thread.req.lockable.req'>[thread.req.lockable.req]</a>).</p></div></div><div class='para' id='lock.unique.locking-5'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>pm-&gt;try_lock()</span>.</p></div></div><div class='para' id='lock.unique.locking-6'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> The value returned by the call to <span class='texttt'>try_lock()</span>.</p></div></div><div class='para' id='lock.unique.locking-7'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-7'>7</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>owns == res</span>, where <span class='texttt'>res</span> is the value returned by
the call to <span class='texttt'>try_lock()</span>.</p></div></div><div class='para' id='lock.unique.locking-8'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-8'>8</a></div><div class='itemdescr'><p ><i>Throws:</i>
Any exception thrown by <span class='texttt'>pm-&gt;try_lock()</span>. <span class='texttt'>system_error</span> if an exception
is required (<a href='thread.req.exception'>[thread.req.exception]</a>). <span class='texttt'>system_error</span> with an error
condition of <span class='texttt'>operation_not_permitted</span> if <span class='texttt'>pm</span> is 0. <span class='texttt'>system_error</span>
with an error condition of <span class='texttt'>resource_deadlock_would_occur</span> if on entry <span class='texttt'>owns</span>
is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='try_lock_until,unique_lock'></a></span><span class='indexparent'><a class='index' id='unique_lock,try_lock_until'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration&gt;
  bool try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.locking-9'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> The supplied <span class='texttt'>Mutex</span> type shall meet the <span class='texttt'>TimedLockable</span>
requirements (<a href='thread.req.lockable.timed'>[thread.req.lockable.timed]</a>).</p></div></div><div class='para' id='lock.unique.locking-10'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>pm-&gt;try_lock_until(abs_time)</span>.</p></div></div><div class='para' id='lock.unique.locking-11'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> The value returned by the call to <span class='texttt'>try_lock_until(abs_time)</span>.</p></div></div><div class='para' id='lock.unique.locking-12'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-12'>12</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>owns == res</span>, where <span class='texttt'>res</span> is the value returned by
the call to <span class='texttt'>try_lock_until(abs_time)</span>.</p></div></div><div class='para' id='lock.unique.locking-13'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-13'>13</a></div><div class='itemdescr'><p ><i>Throws:</i> Any exception thrown by <span class='texttt'>pm-&gt;try_lock_until()</span>. <span class='texttt'>system_error</span> if an
exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>). <span class='texttt'>system_error</span> with an error
condition of <span class='texttt'>operation_not_permitted</span> if <span class='texttt'>pm</span> is 0. <span class='texttt'>system_error</span> with an
error condition of <span class='texttt'>resource_deadlock_would_occur</span> if on entry <span class='texttt'>owns</span> is
<span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='try_lock_for,unique_lock'></a></span><span class='indexparent'><a class='index' id='unique_lock,try_lock_for'></a></span><code class='itemdecl'>
template &lt;class Rep, class Period&gt;
  bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.locking-14'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-14'>14</a></div><div class='itemdescr'><p ><i>Requires:</i> The supplied <span class='texttt'>Mutex</span> type shall meet the <span class='texttt'>TimedLockable</span> requirements (<a href='thread.req.lockable.timed'>[thread.req.lockable.timed]</a>).</p></div></div><div class='para' id='lock.unique.locking-15'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>pm-&gt;try_lock_for(rel_time)</span>.</p></div></div><div class='para' id='lock.unique.locking-16'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i> The value returned by the call to <span class='texttt'>try_lock_until(rel_time)</span>.</p></div></div><div class='para' id='lock.unique.locking-17'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-17'>17</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>owns == res</span>, where <span class='texttt'>res</span> is the value returned by the call to <span class='texttt'>try_lock_for(rel_time)</span>.</p></div></div><div class='para' id='lock.unique.locking-18'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-18'>18</a></div><div class='itemdescr'><p ><i>Throws:</i> Any exception thrown by <span class='texttt'>pm-&gt;try_lock_for()</span>. <span class='texttt'>system_error</span> if an
exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>). <span class='texttt'>system_error</span> with an error
condition of <span class='texttt'>operation_not_permitted</span> if <span class='texttt'>pm</span> is 0. <span class='texttt'>system_error</span> with an
error condition of <span class='texttt'>resource_deadlock_would_occur</span> if on entry <span class='texttt'>owns</span> is
<span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='unlock,unique_lock'></a></span><span class='indexparent'><a class='index' id='unique_lock,unlock'></a></span><code class='itemdecl'>
void unlock();
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.locking-19'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>pm-&gt;unlock()</span>.</p></div></div><div class='para' id='lock.unique.locking-20'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-20'>20</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>owns == false</span></p></div></div><div class='para' id='lock.unique.locking-21'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-21'>21</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='lock.unique.locking-22'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.locking-22'>22</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>operation_not_permitted</span> — if on entry <span class='texttt'>owns</span> is <span class='texttt'>false</span>.
</p></li></ul></div></div></div><div id='lock.unique.mod'><h4 ><a class='secnum' href='#lock.unique.mod' style='min-width:133pt'>30.4.2.2.3</a> <span class='texttt'>unique_lock</span> modifiers <a class='abbr_ref' href='thread.lock.unique.mod'>[thread.lock.unique.mod]</a></h4><p ><span class='indexparent'><a class='index' id='swap,unique_lock'></a></span><span class='indexparent'><a class='index' id='unique_lock,swap'></a></span><code class='itemdecl'>
void swap(unique_lock&amp; u) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.mod-1'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.mod-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Swaps the data members of <span class='texttt'>*this</span> and <span class='texttt'>u</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='release,unique_lock'></a></span><span class='indexparent'><a class='index' id='unique_lock,release'></a></span><code class='itemdecl'>
mutex_type* release() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.mod-2'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.mod-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The previous value of <span class='texttt'>pm</span>.</p></div></div><div class='para' id='lock.unique.mod-3'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.mod-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == 0</span> and <span class='texttt'>owns == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,unique_lock'></a></span><span class='indexparent'><a class='index' id='unique_lock,swap'></a></span><code class='itemdecl'>
template &lt;class Mutex&gt;
  void swap(unique_lock&lt;Mutex&gt;&amp; x, unique_lock&lt;Mutex&gt;&amp; y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.mod-4'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.mod-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>x.swap(y)</span>.
</p></div></div></div><div id='lock.unique.obs'><h4 ><a class='secnum' href='#lock.unique.obs' style='min-width:133pt'>30.4.2.2.4</a> <span class='texttt'>unique_lock</span> observers <a class='abbr_ref' href='thread.lock.unique.obs'>[thread.lock.unique.obs]</a></h4><p ><span class='indexparent'><a class='index' id='owns_lock,unique_lock'></a></span><span class='indexparent'><a class='index' id='unique_lock,owns_lock'></a></span><code class='itemdecl'>
bool owns_lock() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.obs-1'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.obs-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>owns</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator_bool,unique_lock'></a></span><span class='indexparent'><a class='index' id='unique_lock,operator_bool'></a></span><code class='itemdecl'>
explicit operator bool() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.obs-2'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.obs-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>owns</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='mutex,unique_lock'></a></span><span class='indexparent'><a class='index' id='unique_lock,mutex'></a></span><code class='itemdecl'>
mutex_type *mutex() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.unique.obs-3'><div class='marginalizedparent'><a class='marginalized' href='#lock.unique.obs-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>pm</span>
</p></div></div></div></div><div id='lock.shared'><h4 ><a class='secnum' href='#lock.shared' style='min-width:118pt'>30.4.2.3</a> Class template <span class='texttt'>shared_lock</span> <a class='abbr_ref' href='thread.lock.shared'>[thread.lock.shared]</a></h4><p ><span class='indexparent'><a class='index' id='shared_lock'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class Mutex&gt;
  class shared_lock {
  public:
    using mutex_type = Mutex;

    <span class='comment'>// Shared locking
</span>    shared_lock() noexcept;
    explicit shared_lock(mutex_type&amp; m);  <span class='comment'>// blocking
</span>    shared_lock(mutex_type&amp; m, defer_lock_t) noexcept;
    shared_lock(mutex_type&amp; m, try_to_lock_t);
    shared_lock(mutex_type&amp; m, adopt_lock_t);
    template &lt;class Clock, class Duration&gt;
      shared_lock(mutex_type&amp; m,
                  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    template &lt;class Rep, class Period&gt;
      shared_lock(mutex_type&amp; m,
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    ~shared_lock();

    shared_lock(shared_lock const&amp;) = delete;
    shared_lock&amp; operator=(shared_lock const&amp;) = delete;

    shared_lock(shared_lock&amp;&amp; u) noexcept;
    shared_lock&amp; operator=(shared_lock&amp;&amp; u) noexcept;

    void lock();  <span class='comment'>// blocking
</span>    bool try_lock();
    template &lt;class Rep, class Period&gt;
      bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template &lt;class Clock, class Duration&gt;
      bool try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    void unlock();

    <span class='comment'>// Setters
</span>    void swap(shared_lock&amp; u) noexcept;
    mutex_type* release() noexcept;

    <span class='comment'>// Getters
</span>    bool owns_lock() const noexcept;
    explicit operator bool () const noexcept;
    mutex_type* mutex() const noexcept;

  private:
    mutex_type* pm; <span class='comment'>// <i>exposition only</i>
</span>    bool owns;      <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class Mutex&gt;
    void swap(shared_lock&lt;Mutex&gt;&amp; x, shared_lock&lt;Mutex&gt;&amp; y) noexcept;
}
</pre><div class='para' id='lock.shared-1'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared-1'>1</a></div><p >An object of type <span class='texttt'>shared_lock</span> controls the shared ownership of a
lockable object within a scope. Shared ownership of the lockable object may be
acquired at construction or after construction, and may be transferred, after
acquisition, to another <span class='texttt'>shared_lock</span> object. Objects of type
<span class='texttt'>shared_lock</span> are not copyable but are movable. The behavior of a program
is undefined if the contained pointer <span class='texttt'>pm</span> is not null and the lockable
object pointed to by <span class='texttt'>pm</span> does not exist for the entire remaining
lifetime (<a href='basic.life'>[basic.life]</a>) of the <span class='texttt'>shared_lock</span> object. The supplied
<span class='texttt'>Mutex</span> type shall meet the shared mutex
requirements (<a href='thread.sharedtimedmutex.requirements'>[thread.sharedtimedmutex.requirements]</a>).</p></div><div class='para' id='lock.shared-2'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared-2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> <span class='texttt'>shared_lock&lt;Mutex&gt;</span> meets the <span class='texttt'>TimedLockable</span>
requirements (<a href='thread.req.lockable.timed'>[thread.req.lockable.timed]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='lock.shared.cons'><h4 ><a class='secnum' href='#lock.shared.cons' style='min-width:133pt'>30.4.2.3.1</a> <span class='texttt'>shared_lock</span> constructors, destructor, and assignment <a class='abbr_ref' href='thread.lock.shared.cons'>[thread.lock.shared.cons]</a></h4><p ><span class='indexparent'><a class='index' id='shared_lock,constructor'></a></span><code class='itemdecl'>
shared_lock() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>shared_lock</span>.</p></div></div><div class='para' id='lock.shared.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == nullptr</span> and <span class='texttt'>owns == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_lock,constructor'></a></span><code class='itemdecl'>
explicit shared_lock(mutex_type&amp; m);
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> The calling thread does not own the mutex for any ownership mode.</p></div></div><div class='para' id='lock.shared.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>shared_lock</span> and calls <span class='texttt'>m.lock_shared()</span>.</p></div></div><div class='para' id='lock.shared.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-5'>5</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == addressof(m)</span> and <span class='texttt'>owns == true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_lock,constructor'></a></span><code class='itemdecl'>
shared_lock(mutex_type&amp; m, defer_lock_t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>shared_lock</span>.</p></div></div><div class='para' id='lock.shared.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-7'>7</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == addressof(m)</span> and <span class='texttt'>owns == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_lock,constructor'></a></span><code class='itemdecl'>
shared_lock(mutex_type&amp; m, try_to_lock_t);
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i> The calling thread does not own the mutex for any ownership mode.</p></div></div><div class='para' id='lock.shared.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>shared_lock</span> and calls <span class='texttt'>m.try_lock_shared()</span>.</p></div></div><div class='para' id='lock.shared.cons-10'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-10'>10</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == addressof(m)</span> and <span class='texttt'>owns == res</span>
where <span class='texttt'>res</span> is the
value returned by the call to <span class='texttt'>m.try_lock_shared()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_lock,constructor'></a></span><code class='itemdecl'>
shared_lock(mutex_type&amp; m, adopt_lock_t);
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.cons-11'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i> The calling thread has shared ownership of the mutex.</p></div></div><div class='para' id='lock.shared.cons-12'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>shared_lock</span>.</p></div></div><div class='para' id='lock.shared.cons-13'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-13'>13</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == addressof(m)</span> and <span class='texttt'>owns == true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_lock,constructor'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration&gt;
  shared_lock(mutex_type&amp; m,
              const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.cons-14'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-14'>14</a></div><div class='itemdescr'><p ><i>Requires:</i> The calling thread does not own the mutex for any ownership mode.</p></div></div><div class='para' id='lock.shared.cons-15'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>shared_lock</span> and calls
<span class='texttt'>m.try_lock_shared_until(abs_time)</span>.</p></div></div><div class='para' id='lock.shared.cons-16'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-16'>16</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == addressof(m)</span> and <span class='texttt'>owns == res</span>
where <span class='texttt'>res</span>
is the value returned by the call to <span class='texttt'>m.try_lock_shared_until(abs_time)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_lock,constructor'></a></span><code class='itemdecl'>
template &lt;class Rep, class Period&gt;
  shared_lock(mutex_type&amp; m,
              const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.cons-17'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-17'>17</a></div><div class='itemdescr'><p ><i>Requires:</i> The calling thread does not own the mutex for any ownership mode.</p></div></div><div class='para' id='lock.shared.cons-18'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-18'>18</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>shared_lock</span> and calls
<span class='texttt'>m.try_lock_shared_for(rel_time)</span>.</p></div></div><div class='para' id='lock.shared.cons-19'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-19'>19</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == addressof(m)</span> and <span class='texttt'>owns == res</span>
where <span class='texttt'>res</span> is
the value returned by the call to <span class='texttt'>m.try_lock_shared_for(rel_time)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_lock,destructor'></a></span><code class='itemdecl'>
~shared_lock();
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.cons-20'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>owns</span> calls <span class='texttt'>pm-&gt;unlock_shared()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_lock,constructor'></a></span><code class='itemdecl'>
shared_lock(shared_lock&amp;&amp; sl) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.cons-21'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-21'>21</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == sl_p.pm</span> and <span class='texttt'>owns == sl_p.owns</span> (where
<span class='texttt'>sl_p</span> is the state of <span class='texttt'>sl</span> just prior to this construction),
<span class='texttt'>sl.pm == nullptr</span> and <span class='texttt'>sl.owns == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,shared_lock'></a></span><span class='indexparent'><a class='index' id='shared_lock,operator='></a></span><code class='itemdecl'>
shared_lock&amp; operator=(shared_lock&amp;&amp; sl) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.cons-22'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>owns</span> calls <span class='texttt'>pm-&gt;unlock_shared()</span>.</p></div></div><div class='para' id='lock.shared.cons-23'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.cons-23'>23</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == sl_p.pm</span> and <span class='texttt'>owns == sl_p.owns</span> (where
<span class='texttt'>sl_p</span> is the state of <span class='texttt'>sl</span> just prior to this assignment),
<span class='texttt'>sl.pm == nullptr</span> and <span class='texttt'>sl.owns == false</span>.
</p></div></div></div><div id='lock.shared.locking'><h4 ><a class='secnum' href='#lock.shared.locking' style='min-width:133pt'>30.4.2.3.2</a> <span class='texttt'>shared_lock</span> locking <a class='abbr_ref' href='thread.lock.shared.locking'>[thread.lock.shared.locking]</a></h4><p ><span class='indexparent'><a class='index' id='lock,shared_lock'></a></span><span class='indexparent'><a class='index' id='shared_lock,lock'></a></span><code class='itemdecl'>
void lock();
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.locking-1'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>pm-&gt;lock_shared()</span>.</p></div></div><div class='para' id='lock.shared.locking-2'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>owns == true</span>.</p></div></div><div class='para' id='lock.shared.locking-3'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i> Any exception thrown by <span class='texttt'>pm-&gt;lock_shared()</span>.
<span class='texttt'>system_error</span> if an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).
<span class='texttt'>system_error</span> with an error condition of
<span class='texttt'>operation_not_permitted</span> if <span class='texttt'>pm</span> is <span class='texttt'>nullptr</span>.
<span class='texttt'>system_error</span> with an error condition of
<span class='texttt'>resource_deadlock_would_occur</span> if on entry <span class='texttt'>owns</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='try_lock,shared_lock'></a></span><span class='indexparent'><a class='index' id='shared_lock,try_lock'></a></span><code class='itemdecl'>
bool try_lock();
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.locking-4'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>pm-&gt;try_lock_shared()</span>.</p></div></div><div class='para' id='lock.shared.locking-5'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> The value returned by the call to <span class='texttt'>pm-&gt;try_lock_shared()</span>.</p></div></div><div class='para' id='lock.shared.locking-6'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-6'>6</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>owns == res</span>, where <span class='texttt'>res</span> is the value returned by
the call to <span class='texttt'>pm-&gt;try_lock_shared()</span>.</p></div></div><div class='para' id='lock.shared.locking-7'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-7'>7</a></div><div class='itemdescr'><p ><i>Throws:</i> Any exception thrown by <span class='texttt'>pm-&gt;try_lock_shared()</span>.
<span class='texttt'>system_error</span> if an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).
<span class='texttt'>system_error</span> with an error condition of
<span class='texttt'>operation_not_permitted</span> if <span class='texttt'>pm</span> is <span class='texttt'>nullptr</span>.
<span class='texttt'>system_error</span> with an error condition of
<span class='texttt'>resource_deadlock_would_occur</span> if on entry <span class='texttt'>owns</span> is <span class='texttt'>true</span>.</p></div></div><p ><span class='indexparent'><a class='index' id='try_lock_until,shared_lock'></a></span><span class='indexparent'><a class='index' id='shared_lock,try_lock_until'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration&gt;
  bool
  try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.locking-8'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>pm-&gt;try_lock_shared_until(abs_time)</span>.</p></div></div><div class='para' id='lock.shared.locking-9'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> The value returned by the call to
<span class='texttt'>pm-&gt;try_lock_shared_until(abs_time)</span>.</p></div></div><div class='para' id='lock.shared.locking-10'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-10'>10</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>owns == res</span>, where <span class='texttt'>res</span> is the value returned by
the call to <span class='texttt'>pm-&gt;try_lock_shared_until(abs_time)</span>.</p></div></div><div class='para' id='lock.shared.locking-11'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-11'>11</a></div><div class='itemdescr'><p ><i>Throws:</i> Any exception thrown by <span class='texttt'>pm-&gt;try_lock_shared_until(abs_time)</span>.
<span class='texttt'>system_error</span> if an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).
<span class='texttt'>system_error</span> with an error condition of
<span class='texttt'>operation_not_permitted</span> if <span class='texttt'>pm</span> is <span class='texttt'>nullptr</span>.
<span class='texttt'>system_error</span> with an error condition of
<span class='texttt'>resource_deadlock_would_occur</span> if on entry <span class='texttt'>owns</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='try_lock_for,shared_lock'></a></span><span class='indexparent'><a class='index' id='shared_lock,try_lock_for'></a></span><code class='itemdecl'>
template &lt;class Rep, class Period&gt;
  bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.locking-12'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>pm-&gt;try_lock_shared_for(rel_time)</span>.</p></div></div><div class='para' id='lock.shared.locking-13'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> The value returned by the call to <span class='texttt'>pm-&gt;try_lock_shared_for(rel_time)</span>.</p></div></div><div class='para' id='lock.shared.locking-14'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-14'>14</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>owns == res</span>, where <span class='texttt'>res</span> is the value returned by the call to <span class='texttt'>pm-&gt;try_lock_shared_for(rel_time)</span>.</p></div></div><div class='para' id='lock.shared.locking-15'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-15'>15</a></div><div class='itemdescr'><p ><i>Throws:</i> Any exception thrown by <span class='texttt'>pm-&gt;try_lock_shared_for(rel_time)</span>. <span class='texttt'>system_error</span> if an exception is required  (<a href='thread.req.exception'>[thread.req.exception]</a>). <span class='texttt'>system_error</span> with an error condition of <span class='texttt'>operation_not_permitted</span> if <span class='texttt'>pm</span> is <span class='texttt'>nullptr</span>. <span class='texttt'>system_error</span> with an error condition of <span class='texttt'>resource_deadlock_would_occur</span> if on entry <span class='texttt'>owns</span> is <span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='unlock,shared_lock'></a></span><span class='indexparent'><a class='index' id='shared_lock,unlock'></a></span><code class='itemdecl'>
void unlock();
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.locking-16'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>pm-&gt;unlock_shared()</span>.</p></div></div><div class='para' id='lock.shared.locking-17'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-17'>17</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>owns == false</span>.</p></div></div><div class='para' id='lock.shared.locking-18'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-18'>18</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when an exception is required  (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='lock.shared.locking-19'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.locking-19'>19</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>operation_not_permitted</span> — if on entry <span class='texttt'>owns</span> is
<span class='texttt'>false</span>.
</p></li></ul></div></div></div><div id='lock.shared.mod'><h4 ><a class='secnum' href='#lock.shared.mod' style='min-width:133pt'>30.4.2.3.3</a> <span class='texttt'>shared_lock</span> modifiers <a class='abbr_ref' href='thread.lock.shared.mod'>[thread.lock.shared.mod]</a></h4><p ><span class='indexparent'><a class='index' id='swap,shared_lock'></a></span><span class='indexparent'><a class='index' id='shared_lock,swap'></a></span><code class='itemdecl'>
void swap(shared_lock&amp; sl) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.mod-1'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.mod-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Swaps the data members of <span class='texttt'>*this</span> and <span class='texttt'>sl</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='release,shared_lock'></a></span><span class='indexparent'><a class='index' id='shared_lock,release'></a></span><code class='itemdecl'>
mutex_type* release() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.mod-2'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.mod-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The previous value of <span class='texttt'>pm</span>.</p></div></div><div class='para' id='lock.shared.mod-3'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.mod-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>pm == nullptr</span> and <span class='texttt'>owns == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,shared_lock'></a></span><span class='indexparent'><a class='index' id='shared_lock,swap'></a></span><code class='itemdecl'>
template &lt;class Mutex&gt;
  void swap(shared_lock&lt;Mutex&gt;&amp; x, shared_lock&lt;Mutex&gt;&amp; y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.mod-4'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.mod-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>x.swap(y)</span>.
</p></div></div></div><div id='lock.shared.obs'><h4 ><a class='secnum' href='#lock.shared.obs' style='min-width:133pt'>30.4.2.3.4</a> <span class='texttt'>shared_lock</span> observers <a class='abbr_ref' href='thread.lock.shared.obs'>[thread.lock.shared.obs]</a></h4><p ><span class='indexparent'><a class='index' id='owns_lock,shared_lock'></a></span><span class='indexparent'><a class='index' id='shared_lock,owns_lock'></a></span><code class='itemdecl'>
bool owns_lock() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.obs-1'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.obs-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>owns</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator_bool,shared_lock'></a></span><span class='indexparent'><a class='index' id='shared_lock,operator_bool'></a></span><code class='itemdecl'>
explicit operator bool() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.obs-2'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.obs-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>owns</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='mutex,shared_lock'></a></span><span class='indexparent'><a class='index' id='shared_lock,mutex'></a></span><code class='itemdecl'>
mutex_type* mutex() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='lock.shared.obs-3'><div class='marginalizedparent'><a class='marginalized' href='#lock.shared.obs-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>pm</span>.
</p></div></div></div></div></div><div id='lock.algorithm'><h3 ><a class='secnum' href='#lock.algorithm' style='min-width:103pt'>30.4.3</a> Generic locking algorithms <a class='abbr_ref' href='thread.lock.algorithm'>[thread.lock.algorithm]</a></h3><p ><span class='indexparent'><a class='index' id='try_lock'></a></span><code class='itemdecl'>
template &lt;class L1, class L2, class... L3&gt; int try_lock(L1&amp;, L2&amp;, L3&amp;...);
</code></p><div class='itemdescr'></div><div class='para' id='lock.algorithm-1'><div class='marginalizedparent'><a class='marginalized' href='#lock.algorithm-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> Each template parameter type shall meet the <span class='texttt'>Lockable</span> requirements. [&nbsp;<i>Note:</i><span class='space'></span> The
<span class='texttt'>unique_lock</span> class template meets these requirements when suitably instantiated.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='lock.algorithm-2'><div class='marginalizedparent'><a class='marginalized' href='#lock.algorithm-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Calls <span class='texttt'>try_lock()</span> for each argument in order beginning with the
first until all arguments have been processed or a call to <span class='texttt'>try_lock()</span> fails,
either by returning <span class='texttt'>false</span> or by throwing an exception. If a call to
<span class='texttt'>try_lock()</span> fails, <span class='texttt'>unlock()</span> shall be called for all prior arguments
and there shall be no further calls to <span class='texttt'>try_lock()</span>.</p></div></div><div class='para' id='lock.algorithm-3'><div class='marginalizedparent'><a class='marginalized' href='#lock.algorithm-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>-1</span> if all calls to <span class='texttt'>try_lock()</span> returned <span class='texttt'>true</span>,
otherwise a 0-based index value that indicates the argument for which <span class='texttt'>try_lock()</span>
returned <span class='texttt'>false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='lock'></a></span><code class='itemdecl'>
template &lt;class L1, class L2, class... L3&gt; void lock(L1&amp;, L2&amp;, L3&amp;...);
</code></p><div class='itemdescr'></div><div class='para' id='lock.algorithm-4'><div class='marginalizedparent'><a class='marginalized' href='#lock.algorithm-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> Each template parameter type shall meet the <span class='texttt'>Lockable</span> requirements,
[&nbsp;<i>Note:</i><span class='space'></span> The
<span class='texttt'>unique_lock</span> class template meets these requirements when suitably instantiated.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='lock.algorithm-5'><div class='marginalizedparent'><a class='marginalized' href='#lock.algorithm-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> All arguments are locked via a sequence of calls to <span class='texttt'>lock()</span>,
<span class='texttt'>try_lock()</span>, or <span class='texttt'>unlock()</span> on each argument. The sequence of calls shall
not result in deadlock, but is otherwise unspecified. [&nbsp;<i>Note:</i><span class='space'></span> A deadlock avoidance
algorithm such as try-and-back-off must be used, but the specific algorithm is not
specified to avoid over-constraining implementations. <i>&nbsp;—&nbsp;end note</i>&nbsp;] If a call to
<span class='texttt'>lock()</span> or <span class='texttt'>try_lock()</span> throws an exception, <span class='texttt'>unlock()</span> shall be
called for any argument that had been locked by a call to <span class='texttt'>lock()</span> or
<span class='texttt'>try_lock()</span>.
</p></div></div></div><div id='once'><h3 ><a class='secnum' href='#once' style='min-width:103pt'>30.4.4</a> Call once <a class='abbr_ref' href='thread.once'>[thread.once]</a></h3><div id='once.onceflag'><h4 ><a class='secnum' href='#once.onceflag' style='min-width:118pt'>30.4.4.1</a> Struct <span class='texttt'>once_flag</span> <a class='abbr_ref' href='thread.once.onceflag'>[thread.once.onceflag]</a></h4><p ><span class='indexparent'><a class='index' id='once_flag'></a></span></p><pre class='codeblock'>
namespace std {
  struct once_flag {
    constexpr once_flag() noexcept;

    once_flag(const once_flag&amp;) = delete;
    once_flag&amp; operator=(const once_flag&amp;) = delete;
  };
}
</pre><div class='para' id='once.onceflag-1'><div class='marginalizedparent'><a class='marginalized' href='#once.onceflag-1'>1</a></div><p >The class <span class='texttt'>once_flag</span> is an opaque data structure that <span class='texttt'>call_once</span> uses to
initialize data without causing a data race or deadlock.</p><p ><span class='indexparent'><a class='index' id='once_flag'></a></span><code class='itemdecl'>
constexpr once_flag() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='once.onceflag-2'><div class='marginalizedparent'><a class='marginalized' href='#once.onceflag-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>once_flag</span>.</p></div></div><div class='para' id='once.onceflag-3'><div class='marginalizedparent'><a class='marginalized' href='#once.onceflag-3'>3</a></div><div class='itemdescr'><p ><i>Synchronization:</i> The construction of a <span class='texttt'>once_flag</span> object is not synchronized.</p></div></div><div class='para' id='once.onceflag-4'><div class='marginalizedparent'><a class='marginalized' href='#once.onceflag-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> The object's internal state is set to indicate to an invocation of
<span class='texttt'>call_once</span> with the object as its initial argument that no function has been
called.
</p></div></div></div><div id='once.callonce'><h4 ><a class='secnum' href='#once.callonce' style='min-width:118pt'>30.4.4.2</a> Function <span class='texttt'>call_once</span> <a class='abbr_ref' href='thread.once.callonce'>[thread.once.callonce]</a></h4><p ><span class='indexparent'><a class='index' id='call_once'></a></span><code class='itemdecl'>
template&lt;class Callable, class... Args&gt;
  void call_once(once_flag&amp; flag, Callable&amp;&amp; func, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='once.callonce-1'><div class='marginalizedparent'><a class='marginalized' href='#once.callonce-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'><i>INVOKE</i>(<span class='discretionary'></span></span>
<span class='texttt'>std::forward&lt;Callable&gt;(func),
std::forward&lt;Args&gt;(args)...)</span> <span class='discretionary'></span>(<a href='func.require'>[func.require]</a>) shall be
a valid expression.</p></div></div><div class='para' id='once.callonce-2'><div class='marginalizedparent'><a class='marginalized' href='#once.callonce-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> An execution of <span class='texttt'>call_once</span> that does not call its <span class='texttt'>func</span> is a
<a class='hidden_link' href='#def:passive' id='def:passive'><i>passive</i></a> execution. An execution of <span class='texttt'>call_once</span> that calls its <span class='texttt'>func</span>
is an <a class='hidden_link' href='#def:active' id='def:active'><i>active</i></a> execution. An active execution shall call
<span class='texttt'><i>INVOKE</i>(</span>
<span class='texttt'>std::forward&lt;Callable&gt;(func),
std::forward&lt;Args&gt;(args)...)</span>. If such a call to <span class='texttt'>func</span>
throws an exception the execution is <a class='hidden_link' href='#def:exceptional' id='def:exceptional'><i>exceptional</i></a>, otherwise it is <a class='hidden_link' href='#def:returning' id='def:returning'><i>returning</i></a>.
An exceptional execution shall propagate the exception to the caller of
<span class='texttt'>call_once</span>. Among all executions of <span class='texttt'>call_once</span> for any given
<span class='texttt'>once_flag</span>: at most one shall be a returning execution; if there is a
returning execution, it shall be the last active execution; and there are
passive executions only if there is a returning execution. [&nbsp;<i>Note:</i><span class='space'></span> passive
executions allow other threads to reliably observe the results produced by the
earlier returning execution. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='once.callonce-3'><div class='marginalizedparent'><a class='marginalized' href='#once.callonce-3'>3</a></div><div class='itemdescr'><p ><i>Synchronization:</i> For any given <span class='texttt'>once_flag</span>: all active executions occur in a total
order; completion of an active execution synchronizes with (<a href='intro.multithread'>[intro.multithread]</a>)
the start of the next one in this total order; and the returning execution
synchronizes with the return from all passive executions.</p></div></div><div class='para' id='once.callonce-4'><div class='marginalizedparent'><a class='marginalized' href='#once.callonce-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when
an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>), or any exception thrown by <span class='texttt'>func</span>.</p></div></div><div class='para' id='once.callonce-5'><div class='marginalizedparent'><a class='marginalized' href='#once.callonce-5'>5</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
<span class='comment'>// global flag, regular function
</span>void init();
std::once_flag flag;

void f() {
  std::call_once(flag, init);
}

<span class='comment'>// function static flag, function object
</span>struct initializer {
  void operator()();
};

void g() {
  static std::once_flag flag2;
  std::call_once(flag2, initializer());
}

<span class='comment'>// object flag, member function
</span>class information {
  std::once_flag verified;
  void verifier();
public:
  void verify() { std::call_once(verified, &amp;information::verifier, *this); }
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div></div></div></div><div id='condition'><h2 ><a class='secnum' href='#condition' style='min-width:88pt'>30.5</a> Condition variables <a class='abbr_ref' href='thread.condition'>[thread.condition]</a></h2><div class='para' id='condition-1'><div class='marginalizedparent'><a class='marginalized' href='#condition-1'>1</a></div><p >Condition variables provide synchronization primitives used to block a thread until
notified by some other thread that some condition is met or until a system time is
reached. Class <span class='texttt'>condition_variable</span> provides a condition variable that can only
wait on an object of type <span class='texttt'>unique_lock&lt;mutex&gt;</span>, allowing maximum efficiency on some
platforms. Class <span class='texttt'>condition_variable_any</span> provides a general condition variable
that can wait on objects of user-supplied lock types.</p></div><div class='para' id='condition-2'><div class='marginalizedparent'><a class='marginalized' href='#condition-2'>2</a></div><p >Condition variables permit concurrent invocation of the <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>,
<span class='texttt'>wait_until</span>, <span class='texttt'>notify_one</span> and <span class='texttt'>notify_all</span> member functions.</p></div><div class='para' id='condition-3'><div class='marginalizedparent'><a class='marginalized' href='#condition-3'>3</a></div><p >The execution of <span class='texttt'>notify_one</span> and <span class='texttt'>notify_all</span> shall be atomic. The
execution of <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, and <span class='texttt'>wait_until</span> shall be performed
in three atomic parts:</p><ol ><li ><p >the release of the mutex and entry into the waiting state;
</p></li><li ><p >the unblocking of the wait; and
</p></li><li ><p >the reacquisition of the lock.
</p></li></ol></div><div class='para' id='condition-4'><div class='marginalizedparent'><a class='marginalized' href='#condition-4'>4</a></div><p >The implementation shall behave as if all executions of <span class='texttt'>notify_one</span>, <span class='texttt'>notify_all</span>, and each
part of the <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, and <span class='texttt'>wait_until</span> executions are
executed in a single unspecified total order consistent with the "happens before" order.</p></div><div class='para' id='condition-5'><div class='marginalizedparent'><a class='marginalized' href='#condition-5'>5</a></div><p >Condition variable construction and destruction need not be synchronized.</p><p ><b>Header <span class='texttt'>&lt;condition_variable&gt;</span> synopsis</b>
<span class='indexparent'><a class='index' id='condition_variable'></a></span>
<span class='indexparent'><a class='index' id='cv_status'></a></span></p><pre class='codeblock'>
namespace std {
  class condition_variable;
  class condition_variable_any;

  void notify_all_at_thread_exit(condition_variable&amp; cond, unique_lock&lt;mutex&gt; lk);

  enum class cv_status { no_timeout, timeout };
}
</pre><p ><span class='indexparent'><a class='index' id='notify_all_at_thread_exit'></a></span><code class='itemdecl'>
void notify_all_at_thread_exit(condition_variable&amp; cond, unique_lock&lt;mutex&gt; lk);
</code></p></div><div class='itemdescr'></div><div class='para' id='condition-6'><div class='marginalizedparent'><a class='marginalized' href='#condition-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lk</span> is locked by the calling thread and either</p><ul ><li ><p >no other thread is waiting on <span class='texttt'>cond</span>, or
</p></li><li ><p ><span class='texttt'>lk.mutex()</span> returns the same value for each of the lock arguments
supplied by all concurrently waiting (via <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>,
or <span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='condition-7'><div class='marginalizedparent'><a class='marginalized' href='#condition-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Transfers ownership of the lock associated with <span class='texttt'>lk</span> into
internal storage and schedules <span class='texttt'>cond</span> to be notified when the current
thread exits, after all objects of thread storage duration associated with
the current thread have been destroyed. This notification shall be as if:
</p><pre class='codeblock'>
lk.unlock();
cond.notify_all();
</pre></div></div><div class='para' id='condition-8'><div class='marginalizedparent'><a class='marginalized' href='#condition-8'>8</a></div><div class='itemdescr'><p ><i>Synchronization:</i> The implied <span class='texttt'>lk.unlock()</span> call is sequenced after the destruction of
all objects with thread storage duration associated with the current thread.</p></div></div><div class='para' id='condition-9'><div class='marginalizedparent'><a class='marginalized' href='#condition-9'>9</a></div><div class='itemdescr'><p ><i>Note:</i> The supplied lock will be held until the thread exits, and care
must be taken to ensure that this does not cause deadlock due to lock
ordering issues. After calling <span class='texttt'>notify_all_at_thread_exit</span> it is
recommended that the thread should be exited as soon as possible, and
that no blocking or time-consuming tasks are run on that thread.</p></div></div><div class='para' id='condition-10'><div class='marginalizedparent'><a class='marginalized' href='#condition-10'>10</a></div><div class='itemdescr'><p ><i>Note:</i> It is the user's responsibility to ensure that waiting threads
do not erroneously assume that the thread has finished if they experience
spurious wakeups. This typically requires that the condition being waited
for is satisfied while holding the lock on <span class='texttt'>lk</span>, and that this lock
is not released and reacquired prior to calling <span class='texttt'>notify_all_at_thread_exit</span>.
</p></div></div><div id='condition.condvar'><h3 ><a class='secnum' href='#condition.condvar' style='min-width:103pt'>30.5.1</a> Class <span class='texttt'>condition_variable</span> <a class='abbr_ref' href='thread.condition.condvar'>[thread.condition.condvar]</a></h3><p ><span class='indexparent'><a class='index' id='condition_variable'></a></span></p><pre class='codeblock'>
namespace std {
  class condition_variable {
  public:

    condition_variable();
    ~condition_variable();

    condition_variable(const condition_variable&amp;) = delete;
    condition_variable&amp; operator=(const condition_variable&amp;) = delete;

    void notify_one() noexcept;
    void notify_all() noexcept;
    void wait(unique_lock&lt;mutex&gt;&amp; lock);
    template &lt;class Predicate&gt;
      void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
    template &lt;class Clock, class Duration&gt;
      cv_status wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                           const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    template &lt;class Clock, class Duration, class Predicate&gt;
      bool wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                      const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
                      Predicate pred);

    template &lt;class Rep, class Period&gt;
      cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                         const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template &lt;class Rep, class Period, class Predicate&gt;
      bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                    const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
                    Predicate pred);

    using native_handle_type = <i>implementation-defined</i>; <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>    native_handle_type native_handle();                <span class='comment'>// See <a href='thread.req.native'>[thread.req.native]</a>
</span>  };
}
</pre><div class='para' id='condition.condvar-1'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-1'>1</a></div><p >The class <span class='texttt'>condition_variable</span> shall be a standard-layout class (Clause <a href='class'>[class]</a>).</p><p ><span class='indexparent'><a class='index' id='condition_variable,constructor'></a></span><code class='itemdecl'>
condition_variable();
</code></p></div><div class='itemdescr'></div><div class='para' id='condition.condvar-2'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>condition_variable</span>.</p></div></div><div class='para' id='condition.condvar-3'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> when an exception is required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='condition.condvar-4'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-4'>4</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>resource_unavailable_try_again</span> — if some non-memory resource
limitation prevents initialization.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='condition_variable,destructor'></a></span><code class='itemdecl'>
~condition_variable();
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvar-5'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> There shall be no thread blocked on <span class='texttt'>*this</span>. [&nbsp;<i>Note:</i><span class='space'></span> That is, all
threads shall have been notified; they may subsequently block on the lock specified in the
wait.
This relaxes the usual rules, which would have required all wait calls to happen before
destruction. Only the notification to unblock the wait must happen before destruction.
The user must take care to ensure that no threads wait on <span class='texttt'>*this</span> once the destructor has
been started, especially when the waiting threads are calling the wait functions in a loop or
using the overloads of <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span> that take a predicate.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvar-6'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys the object.
</p></div></div><p ><span class='indexparent'><a class='index' id='notify_one,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,notify_one'></a></span><code class='itemdecl'>
void notify_one() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvar-7'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> If any threads are blocked waiting for <span class='texttt'>*this</span>, unblocks one of those threads.
</p></div></div><p ><span class='indexparent'><a class='index' id='notify_all,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,notify_all'></a></span><code class='itemdecl'>
void notify_all() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvar-8'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Unblocks all threads that are blocked waiting for <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='wait,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,wait'></a></span><code class='itemdecl'>
void wait(unique_lock&lt;mutex&gt;&amp; lock);
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvar-9'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread, and either
</p><ul ><li ><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li ><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span>
arguments supplied by all concurrently waiting (via <span class='texttt'>wait</span>,
<span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='condition.condvar-10'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >Atomically calls <span class='texttt'>lock.unlock()</span> and blocks on <span class='texttt'>*this</span>.
</p></li><li ><p >When unblocked, calls <span class='texttt'>lock.lock()</span> (possibly blocking on the lock), then returns.
</p></li><li ><p >The function will unblock when signaled by a call to <span class='texttt'>notify_one()</span>
or a call to <span class='texttt'>notify_all()</span>, or spuriously.
</p></li></ul></div></div><div class='para' id='condition.condvar-11'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvar-12'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-12'>12</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='condition.condvar-13'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-13'>13</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><p ><span class='indexparent'><a class='index' id='wait,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,wait'></a></span><code class='itemdecl'>
template &lt;class Predicate&gt;
  void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvar-14'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-14'>14</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span> is
locked by the calling thread, and either</p><ul ><li ><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li ><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span>
arguments supplied by all concurrently waiting (via <span class='texttt'>wait</span>,
<span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='condition.condvar-15'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
while (!pred())
  wait(lock);
</pre></div></div><div class='para' id='condition.condvar-16'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-16'>16</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvar-17'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-17'>17</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='condition.condvar-18'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-18'>18</a></div><div class='itemdescr'><p ><i>Throws:</i> Any exception thrown by <span class='texttt'>pred</span>.</p></div></div><p ><span class='indexparent'><a class='index' id='wait_until,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,wait_until'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration&gt;
  cv_status wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                       const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvar-19'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-19'>19</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread, and either
</p><ul ><li ><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li ><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span>
arguments supplied by all concurrently waiting (via <span class='texttt'>wait</span>,
<span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='condition.condvar-20'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >Atomically calls <span class='texttt'>lock.unlock()</span> and blocks on <span class='texttt'>*this</span>.</p></li><li ><p >When unblocked, calls <span class='texttt'>lock.lock()</span> (possibly blocking on the lock), then returns.</p></li><li ><p >The function will unblock when signaled by a call to <span class='texttt'>notify_one()</span>, a call to <span class='texttt'>notify_all()</span>,
expiration of the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span>,
or spuriously.</p></li><li ><p >If the function exits via an exception, <span class='texttt'>lock.lock()</span> shall be called prior to exiting the function.
</p></li></ul></div></div><div class='para' id='condition.condvar-21'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-21'>21</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvar-22'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-22'>22</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='condition.condvar-23'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-23'>23</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cv_status::timeout</span> if
the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span> expired,
otherwise <span class='texttt'>cv_status::no_timeout</span>.</p></div></div><div class='para' id='condition.condvar-24'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-24'>24</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related
exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).</p></div></div><p ><span class='indexparent'><a class='index' id='wait_for,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,wait_for'></a></span><code class='itemdecl'>
template &lt;class Rep, class Period&gt;
  cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                     const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvar-25'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-25'>25</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread, and either
</p><ul ><li ><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li ><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span> arguments
supplied by all concurrently waiting (via <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, or
<span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='condition.condvar-26'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-26'>26</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
return wait_until(lock, chrono::steady_clock::now() + rel_time);
</pre></div></div><div class='para' id='condition.condvar-27'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-27'>27</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cv_status::timeout</span> if
the relative timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>rel_time</span> expired,
otherwise <span class='texttt'>cv_status::no_timeout</span>.</p></div></div><div class='para' id='condition.condvar-28'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-28'>28</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvar-29'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-29'>29</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='condition.condvar-30'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-30'>30</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related
exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).</p></div></div><p ><span class='indexparent'><a class='index' id='wait_until,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,wait_until'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration, class Predicate&gt;
  bool wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
                  Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvar-31'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-31'>31</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span> is
locked by the calling thread, and either</p><ul ><li ><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or
</p></li><li ><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span>
arguments supplied by all concurrently waiting (via <span class='texttt'>wait</span>,
<span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='condition.condvar-32'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-32'>32</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
while (!pred())
  if (wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
return true;
</pre></div></div><div class='para' id='condition.condvar-33'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-33'>33</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvar-34'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-34'>34</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='condition.condvar-35'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-35'>35</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span> The returned value indicates whether the predicate evaluated to
<span class='texttt'>true</span> regardless of whether the timeout was triggered. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvar-36'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-36'>36</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related
exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>) or any exception thrown by <span class='texttt'>pred</span>.</p></div></div><p ><span class='indexparent'><a class='index' id='wait_for,condition_variable'></a></span><span class='indexparent'><a class='index' id='condition_variable,wait_for'></a></span><code class='itemdecl'>
template &lt;class Rep, class Period, class Predicate&gt;
  bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
                Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvar-37'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-37'>37</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread, and either
</p><ul ><li ><p >no other thread is waiting on this <span class='texttt'>condition_variable</span> object or</p></li><li ><p ><span class='texttt'>lock.mutex()</span> returns the same value for each of the <span class='texttt'>lock</span> arguments
supplied by all concurrently waiting (via <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, or
<span class='texttt'>wait_until</span>) threads.
</p></li></ul></div></div><div class='para' id='condition.condvar-38'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-38'>38</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));
</pre></div></div><div class='para' id='condition.condvar-39'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-39'>39</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span> There is no blocking if <span class='texttt'>pred()</span> is initially <span class='texttt'>true</span>, even if the
timeout has already expired. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvar-40'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-40'>40</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvar-41'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-41'>41</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock.owns_lock()</span> is <span class='texttt'>true</span> and <span class='texttt'>lock.mutex()</span>
is locked by the calling thread.</p></div></div><div class='para' id='condition.condvar-42'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-42'>42</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span> The returned value indicates whether the predicate evaluates to <span class='texttt'>true</span>
regardless of whether the timeout was triggered. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvar-43'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvar-43'>43</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related
exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>) or any exception thrown by <span class='texttt'>pred</span>.</p></div></div></div><div id='condition.condvarany'><h3 ><a class='secnum' href='#condition.condvarany' style='min-width:103pt'>30.5.2</a> Class <span class='texttt'>condition_variable_any</span> <a class='abbr_ref' href='thread.condition.condvarany'>[thread.condition.condvarany]</a></h3><div class='para' id='condition.condvarany-1'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-1'>1</a></div><p >A <span class='texttt'>Lock</span> type shall meet the <span class='texttt'>BasicLockable</span>
requirements (<a href='thread.req.lockable.basic'>[thread.req.lockable.basic]</a>). [&nbsp;<i>Note:</i><span class='space'></span> All of the standard
mutex types meet this requirement. If a <span class='texttt'>Lock</span> type other than one of the
standard mutex types or a <span class='texttt'>unique_lock</span> wrapper for a standard mutex type
is used with <span class='texttt'>condition_variable_any</span>, the user must ensure that any
necessary synchronization is in place with respect to the predicate associated
with the <span class='texttt'>condition_variable_any</span> instance. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='condition_variable_any'></a></span></p><pre class='codeblock'>
namespace std {
  class condition_variable_any {
  public:
    condition_variable_any();
    ~condition_variable_any();

    condition_variable_any(const condition_variable_any&amp;) = delete;
    condition_variable_any&amp; operator=(const condition_variable_any&amp;) = delete;

    void notify_one() noexcept;
    void notify_all() noexcept;
    template &lt;class Lock&gt;
      void wait(Lock&amp; lock);
    template &lt;class Lock, class Predicate&gt;
      void wait(Lock&amp; lock, Predicate pred);

    template &lt;class Lock, class Clock, class Duration&gt;
      cv_status wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
    template &lt;class Lock, class Clock, class Duration, class Predicate&gt;
      bool wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
        Predicate pred);
    template &lt;class Lock, class Rep, class Period&gt;
      cv_status wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
    template &lt;class Lock, class Rep, class Period, class Predicate&gt;
      bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
        Predicate pred);
  };
}
</pre><p ><span class='indexparent'><a class='index' id='condition_variable_any,constructor'></a></span><code class='itemdecl'>
condition_variable_any();
</code></p></div><div class='itemdescr'></div><div class='para' id='condition.condvarany-2'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an object of type <span class='texttt'>condition_variable_any</span>.</p></div></div><div class='para' id='condition.condvarany-3'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>bad_alloc</span> or <span class='texttt'>system_error</span> when an exception is
required (<a href='thread.req.exception'>[thread.req.exception]</a>).</p></div></div><div class='para' id='condition.condvarany-4'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-4'>4</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>resource_unavailable_try_again</span> — if some non-memory resource
limitation prevents initialization.</p></li><li ><p ><span class='texttt'>operation_not_permitted</span> — if the thread does not have the
privilege to perform the operation.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='condition_variable_any,destructor'></a></span><code class='itemdecl'>
~condition_variable_any();
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvarany-5'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> There shall be no thread blocked on <span class='texttt'>*this</span>. [&nbsp;<i>Note:</i><span class='space'></span> That is, all
threads shall have been notified; they may subsequently block on the lock specified in the
wait.
This relaxes the usual rules, which would have required all wait calls to happen before
destruction. Only the notification to unblock the wait must happen before destruction.
The user must take care to ensure that no threads wait on <span class='texttt'>*this</span> once the destructor has
been started, especially when the waiting threads are calling the wait functions in a loop or
using the overloads of <span class='texttt'>wait</span>, <span class='texttt'>wait_for</span>, or <span class='texttt'>wait_until</span> that take a predicate.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvarany-6'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Destroys the object.
</p></div></div><p ><span class='indexparent'><a class='index' id='notify_one,condition_variable_any'></a></span><span class='indexparent'><a class='index' id='condition_variable_any,notify_one'></a></span><code class='itemdecl'>
void notify_one() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvarany-7'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> If any threads are blocked waiting for <span class='texttt'>*this</span>, unblocks one of those threads.
</p></div></div><p ><span class='indexparent'><a class='index' id='notify_all,condition_variable_any'></a></span><span class='indexparent'><a class='index' id='condition_variable_any,notify_all'></a></span><code class='itemdecl'>
void notify_all() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvarany-8'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Unblocks all threads that are blocked waiting for <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='wait,condition_variable_any'></a></span><span class='indexparent'><a class='index' id='condition_variable_any,wait'></a></span><code class='itemdecl'>
template &lt;class Lock&gt;
  void wait(Lock&amp; lock);
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvarany-9'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-9'>9</a></div><div class='itemdescr'><p ><i>Note:</i> if any of the <span class='texttt'>wait</span> functions exits via an exception, it is
unspecified whether the <span class='texttt'>Lock</span> is held. One can use a <span class='texttt'>Lock</span> type
that allows to query that, such as the <span class='texttt'>unique_lock</span> wrapper.</p></div></div><div class='para' id='condition.condvarany-10'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >Atomically calls <span class='texttt'>lock.unlock()</span> and blocks on <span class='texttt'>*this</span>.
</p></li><li ><p >When unblocked, calls <span class='texttt'>lock.lock()</span> (possibly blocking on the lock) and returns.
</p></li><li ><p >The function will unblock when signaled by a call to <span class='texttt'>notify_one()</span>,
a call to <span class='texttt'>notify_all()</span>, or spuriously.
</p></li></ul></div></div><div class='para' id='condition.condvarany-11'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvarany-12'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-12'>12</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock</span> is locked by the calling thread.</p></div></div><div class='para' id='condition.condvarany-13'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-13'>13</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><p ><span class='indexparent'><a class='index' id='wait,condition_variable_any'></a></span><span class='indexparent'><a class='index' id='condition_variable_any,wait'></a></span><code class='itemdecl'>
template &lt;class Lock, class Predicate&gt;
  void wait(Lock&amp; lock, Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvarany-14'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
while (!pred())
  wait(lock);
</pre></div></div><p ><span class='indexparent'><a class='index' id='wait_until,condition_variable_any'></a></span><span class='indexparent'><a class='index' id='condition_variable_any,wait_until'></a></span><code class='itemdecl'>
template &lt;class Lock, class Clock, class Duration&gt;
  cv_status wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvarany-15'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i></p><ul ><li ><p >Atomically calls <span class='texttt'>lock.unlock()</span> and blocks on <span class='texttt'>*this</span>.</p></li><li ><p >When unblocked, calls <span class='texttt'>lock.lock()</span> (possibly blocking on the lock) and returns.</p></li><li ><p >The function will unblock when signaled by a call to <span class='texttt'>notify_one()</span>, a call to <span class='texttt'>notify_all()</span>,
expiration of the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span>,
or spuriously.</p></li><li ><p >If the function exits via an exception, <span class='texttt'>lock.lock()</span> shall be called prior to exiting the function.
</p></li></ul></div></div><div class='para' id='condition.condvarany-16'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-16'>16</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvarany-17'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-17'>17</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock</span> is locked by the calling thread.</p></div></div><div class='para' id='condition.condvarany-18'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-18'>18</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cv_status::timeout</span> if
the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span> expired,
otherwise <span class='texttt'>cv_status::no_timeout</span>.</p></div></div><div class='para' id='condition.condvarany-19'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-19'>19</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related
exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).</p></div></div><p ><span class='indexparent'><a class='index' id='wait_for,condition_variable_any'></a></span><span class='indexparent'><a class='index' id='condition_variable_any,wait_for'></a></span><code class='itemdecl'>
template &lt;class Lock, class Rep, class Period&gt;
  cv_status wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvarany-20'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
return wait_until(lock, chrono::steady_clock::now() + rel_time);
</pre></div></div><div class='para' id='condition.condvarany-21'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-21'>21</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cv_status::timeout</span> if
the relative timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>rel_time</span> expired,
otherwise <span class='texttt'>cv_status::no_timeout</span>.</p></div></div><div class='para' id='condition.condvarany-22'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-22'>22</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If the function fails to meet the postcondition, <span class='texttt'>std::terminate()</span>
shall be called (<a href='except.terminate'>[except.terminate]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> This can happen if the re-locking of the mutex throws an exception. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvarany-23'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-23'>23</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>lock</span> is locked by the calling thread.</p></div></div><div class='para' id='condition.condvarany-24'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-24'>24</a></div><div class='itemdescr'><p ><i>Throws:</i> Timeout-related
exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).</p></div></div><p ><span class='indexparent'><a class='index' id='wait_until,condition_variable_any'></a></span><span class='indexparent'><a class='index' id='condition_variable_any,wait_until'></a></span><code class='itemdecl'>
template &lt;class Lock, class Clock, class Duration, class Predicate&gt;
  bool wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvarany-25'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-25'>25</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
while (!pred())
  if (wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
return true;
</pre></div></div><div class='para' id='condition.condvarany-26'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-26'>26</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span> There is no blocking if <span class='texttt'>pred()</span> is initially <span class='texttt'>true</span>, or
if the timeout has already expired. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='condition.condvarany-27'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-27'>27</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span> The returned value indicates whether the predicate evaluates to <span class='texttt'>true</span>
regardless of whether the timeout was triggered. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='wait_for,condition_variable_any'></a></span><span class='indexparent'><a class='index' id='condition_variable_any,wait_for'></a></span><code class='itemdecl'>
template &lt;class Lock, class Rep, class Period, class Predicate&gt;
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);
</code></p><div class='itemdescr'></div><div class='para' id='condition.condvarany-28'><div class='marginalizedparent'><a class='marginalized' href='#condition.condvarany-28'>28</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));
</pre></div></div></div></div><div id='futures'><h2 ><a class='secnum' href='#futures' style='min-width:88pt'>30.6</a> Futures <a class='abbr_ref' href='futures'>[futures]</a></h2><div id='futures.overview'><h3 ><a class='secnum' href='#futures.overview' style='min-width:103pt'>30.6.1</a> Overview <a class='abbr_ref' href='futures.overview'>[futures.overview]</a></h3><div class='para' id='futures.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#futures.overview-1'>1</a></div><p ><a href='futures'>[futures]</a> describes components that a C++ program can use to retrieve in one thread the
result (value or exception) from a function that has run in the same thread or another thread.
[&nbsp;<i>Note:</i><span class='space'></span> These components are not restricted to multi-threaded programs but can be useful in
single-threaded programs as well. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><b>Header <span class='texttt'>&lt;future&gt;</span> synopsis</b></p><p ><span class='indexparent'><a class='index' id='future'></a></span></p><pre class='codeblock'>
namespace std {
  enum class future_errc {
    broken_promise = <i>implementation-defined</i>,
    future_already_retrieved = <i>implementation-defined</i>,
    promise_already_satisfied = <i>implementation-defined</i>,
    no_state = <i>implementation-defined</i>
  };

  enum class launch : <i><span class='texttt'>unspecified</span></i> {
    async = <i><span class='texttt'>unspecified</span></i>,
    deferred = <i><span class='texttt'>unspecified</span></i>,
    <i>implementation-defined</i>
  };

  enum class future_status {
    ready,
    timeout,
    deferred
  };

  template &lt;&gt; struct is_error_code_enum&lt;future_errc&gt; : public true_type { };
  error_code make_error_code(future_errc e) noexcept;
  error_condition make_error_condition(future_errc e) noexcept;

  const error_category&amp; future_category() noexcept;

  class future_error;

  template &lt;class R&gt; class promise;
  template &lt;class R&gt; class promise&lt;R&amp;&gt;;
  template &lt;&gt; class promise&lt;void&gt;;

  template &lt;class R&gt;
    void swap(promise&lt;R&gt;&amp; x, promise&lt;R&gt;&amp; y) noexcept;

  template &lt;class R, class Alloc&gt;
    struct uses_allocator&lt;promise&lt;R&gt;, Alloc&gt;;

  template &lt;class R&gt; class future;
  template &lt;class R&gt; class future&lt;R&amp;&gt;;
  template &lt;&gt; class future&lt;void&gt;;

  template &lt;class R&gt; class shared_future;
  template &lt;class R&gt; class shared_future&lt;R&amp;&gt;;
  template &lt;&gt; class shared_future&lt;void&gt;;

  template &lt;class&gt; class packaged_task;   <span class='comment'>// not defined
</span>  template &lt;class R, class... ArgTypes&gt;
    class packaged_task&lt;R(ArgTypes...)&gt;;

  template &lt;class R, class... ArgTypes&gt;
    void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp;, packaged_task&lt;R(ArgTypes...)&gt;&amp;) noexcept;

  template &lt;class R, class Alloc&gt;
    struct uses_allocator&lt;packaged_task&lt;R&gt;, Alloc&gt;;

  template &lt;class F, class... Args&gt;
    future&lt;result_of_t&lt;decay_t&lt;F&gt;(decay_t&lt;Args&gt;...)&gt;&gt;
    async(F&amp;&amp; f, Args&amp;&amp;... args);
  template &lt;class F, class... Args&gt;
    future&lt;result_of_t&lt;decay_t&lt;F&gt;(decay_t&lt;Args&gt;...)&gt;&gt;
    async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args);
}
</pre></div><div class='para' id='futures.overview-2'><div class='marginalizedparent'><a class='marginalized' href='#futures.overview-2'>2</a></div><p >The <span class='texttt'>enum</span> type <span class='texttt'>launch</span> is a bitmask type (<a href='bitmask.types'>[bitmask.types]</a>) with
<span class='texttt'>launch::async</span> and <span class='texttt'>launch::deferred</span> denoting individual bits.
[&nbsp;<i>Note:</i><span class='space'></span> Implementations can provide bitmasks to specify restrictions on task
interaction by functions launched by <span class='texttt'>async()</span> applicable to a
corresponding subset of available launch policies. Implementations can extend
the behavior of the first overload of <span class='texttt'>async()</span> by adding their extensions
to the launch policy under the “as if” rule. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='futures.overview-3'><div class='marginalizedparent'><a class='marginalized' href='#futures.overview-3'>3</a></div><p >The enum values of <span class='texttt'>future_errc</span> are distinct and not zero.</p></div></div><div id='futures.errors'><h3 ><a class='secnum' href='#futures.errors' style='min-width:103pt'>30.6.2</a> Error handling <a class='abbr_ref' href='futures.errors'>[futures.errors]</a></h3><p ><span class='indexparent'><a class='index' id='future_category'></a></span><code class='itemdecl'>
const error_category&amp; future_category() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.errors-1'><div class='marginalizedparent'><a class='marginalized' href='#futures.errors-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to an object of a type derived from class <span class='texttt'>error_category</span>.</p></div></div><div class='para' id='futures.errors-2'><div class='marginalizedparent'><a class='marginalized' href='#futures.errors-2'>2</a></div><div class='itemdescr'><p >The object's <span class='texttt'>default_error_condition</span> and equivalent virtual functions shall
behave as specified for the class <span class='texttt'>error_category</span>. The object's <span class='texttt'>name</span>
virtual function shall return a pointer to the string <span class='texttt'>"future"</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_error_code,future_errc'></a></span><span class='indexparent'><a class='index' id='future_errc,make_error_code'></a></span><code class='itemdecl'>
error_code make_error_code(future_errc e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.errors-3'><div class='marginalizedparent'><a class='marginalized' href='#futures.errors-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>error_code(static_cast&lt;int&gt;(e), future_category())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='make_error_condition,future_errc'></a></span><span class='indexparent'><a class='index' id='future_errc,make_error_condition'></a></span><code class='itemdecl'>
error_condition make_error_condition(future_errc e) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.errors-4'><div class='marginalizedparent'><a class='marginalized' href='#futures.errors-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>error_condition(static_cast&lt;int&gt;(e), future_category())</span>.
</p></div></div></div><div id='futures.future_error'><h3 ><a class='secnum' href='#futures.future_error' style='min-width:103pt'>30.6.3</a> Class <span class='texttt'>future_error</span> <a class='abbr_ref' href='futures.future_error'>[futures.future_error]</a></h3><p ><span class='indexparent'><a class='index' id='future_error'></a></span></p><pre class='codeblock'>
namespace std {
  class future_error : public logic_error {
  public:
    future_error(error_code ec);  <span class='comment'>// <i>exposition only</i>
</span>
    const error_code&amp; code() const noexcept;
    const char*       what() const noexcept;
  };
}
</pre><p ><span class='indexparent'><a class='index' id='code,future_error'></a></span><span class='indexparent'><a class='index' id='future_error,code'></a></span><code class='itemdecl'>
const error_code&amp; code() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.future_error-1'><div class='marginalizedparent'><a class='marginalized' href='#futures.future_error-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The value of <span class='texttt'>ec</span> that was passed to the object's constructor.
</p></div></div><p ><span class='indexparent'><a class='index' id='what,future_error'></a></span><span class='indexparent'><a class='index' id='future_error,what'></a></span><code class='itemdecl'>
const char* what() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.future_error-2'><div class='marginalizedparent'><a class='marginalized' href='#futures.future_error-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> An <span class='textsc'>ntbs</span> incorporating <span class='texttt'>code().message()</span>.
</p></div></div></div><div id='futures.state'><h3 ><a class='secnum' href='#futures.state' style='min-width:103pt'>30.6.4</a> Shared state <a class='abbr_ref' href='futures.state'>[futures.state]</a></h3><div class='para' id='futures.state-1'><div class='marginalizedparent'><a class='marginalized' href='#futures.state-1'>1</a></div><p >Many of the classes introduced in this subclause use some state to communicate results. This
<span class='indexparent'><a class='index' id='shared_state'></a></span>
<a class='hidden_link' href='#def:future,shared_state' id='def:future,shared_state'><i>shared state</i></a> consists of some state information and some (possibly not
yet evaluated) <a class='hidden_link' href='#def:result' id='def:result'><i>result</i></a>, which can be a (possibly void) value or an exception. [&nbsp;<i>Note:</i><span class='space'></span>
Futures, promises, and tasks defined in this clause reference such shared state. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='futures.state-2'><div class='marginalizedparent'><a class='marginalized' href='#futures.state-2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> The result can be any kind of object including a function to compute that result,
as used by <span class='texttt'>async</span> when <span class='texttt'>policy</span> is <span class='texttt'>launch::deferred</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='futures.state-3'><div class='marginalizedparent'><a class='marginalized' href='#futures.state-3'>3</a></div><p >An <a class='hidden_link' href='#def:asynchronous_return_object' id='def:asynchronous_return_object'><i>asynchronous return object</i></a> is an object that reads results from a
shared state. A <a class='hidden_link' href='#def:waiting_function' id='def:waiting_function'><i>waiting function</i></a> of an asynchronous return object is one
that potentially blocks to wait for the shared state to be made
ready.
If a waiting function can return before the state is made ready because of a
timeout (<a href='thread.req.lockable'>[thread.req.lockable]</a>), then it is a <a class='hidden_link' href='#def:timed_waiting_function' id='def:timed_waiting_function'><i>timed waiting function</i></a>, otherwise
it is a <a class='hidden_link' href='#def:non-timed_waiting_function' id='def:non-timed_waiting_function'><i>non-timed waiting function</i></a>.</p></div><div class='para' id='futures.state-4'><div class='marginalizedparent'><a class='marginalized' href='#futures.state-4'>4</a></div><p >An <a class='hidden_link' href='#def:asynchronous_provider' id='def:asynchronous_provider'><i>asynchronous provider</i></a> is an object that provides a result to a shared
state.
The result of a shared state is set by
respective functions on the asynchronous provider. [&nbsp;<i>Note:</i><span class='space'></span> Such as promises or tasks.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] The means of setting the result of a shared state is specified
in the description of those classes and functions that create such a state object.</p></div><div class='para' id='futures.state-5'><div class='marginalizedparent'><a class='marginalized' href='#futures.state-5'>5</a></div><p >When an asynchronous return object or an asynchronous provider is said to release its
shared state, it means:</p><ul ><li ><p >if the return object or provider holds the last reference to its shared state,
the shared state is destroyed; and</p></li><li ><p >the return object or provider gives up its reference to its shared state; and</p></li><li ><p >these actions will not block for the shared state to become ready, except that it
may block if all of the following are true: the shared state was created by a call to
<span class='texttt'>std::async</span>, the shared state is not yet ready, and this was the last reference
to the shared state.
</p></li></ul></div><div class='para' id='futures.state-6'><div class='marginalizedparent'><a class='marginalized' href='#futures.state-6'>6</a></div><p >When an asynchronous provider is said to make its shared state ready, it means:</p><ul ><li ><p >first, the provider marks its shared state as ready; and</p></li><li ><p >second, the provider unblocks any execution agents waiting for its shared
state to become ready.
</p></li></ul></div><div class='para' id='futures.state-7'><div class='marginalizedparent'><a class='marginalized' href='#futures.state-7'>7</a></div><p >When an asynchronous provider is said to abandon its shared state, it means:</p><ul ><li ><p >first, if that state is not ready, the provider</p><ul ><li ><p >stores an exception object of type <span class='texttt'>future_error</span> with an error condition of
<span class='texttt'>broken_promise</span> within its shared state; and then</p></li><li ><p >makes its shared state ready;
</p></li></ul></li><li ><p >second, the provider releases its shared state.
</p></li></ul></div><div class='para' id='futures.state-8'><div class='marginalizedparent'><a class='marginalized' href='#futures.state-8'>8</a></div><p >A shared state is <a class='hidden_link' href='#def:ready' id='def:ready'><i>ready</i></a> only if it holds a value or an exception ready for
retrieval.
Waiting for a shared state to become ready may invoke code to compute the result on 
the waiting thread if so specified in the description of the class or function that creates
the state object.</p></div><div class='para' id='futures.state-9'><div class='marginalizedparent'><a class='marginalized' href='#futures.state-9'>9</a></div><p >Calls to functions that successfully set the stored result of a shared
state synchronize
with (<a href='intro.multithread'>[intro.multithread]</a>) calls to functions
successfully detecting the ready state resulting from that setting.
The storage of the result
(whether normal or exceptional) into the shared state
synchronizes with (<a href='intro.multithread'>[intro.multithread]</a>)
the successful return from a call to a waiting function on the shared state.</p></div><div class='para' id='futures.state-10'><div class='marginalizedparent'><a class='marginalized' href='#futures.state-10'>10</a></div><p >Some functions (e.g., <span class='texttt'>promise::set_value_at_thread_exit</span>) delay making
the shared state ready until the calling thread exits. The destruction of
each of that thread's objects with thread storage duration (<a href='basic.stc.thread'>[basic.stc.thread]</a>)
is sequenced before making that shared state ready.</p></div><div class='para' id='futures.state-11'><div class='marginalizedparent'><a class='marginalized' href='#futures.state-11'>11</a></div><p >Access to the result of the same shared state may conflict (<a href='intro.multithread'>[intro.multithread]</a>).
[&nbsp;<i>Note:</i><span class='space'></span> this explicitly specifies that the result of the shared state is
visible in the objects that reference this state in the sense of data race
avoidance (<a href='res.on.data.races'>[res.on.data.races]</a>). For example, concurrent accesses through
references returned by <span class='texttt'>shared_future::get()</span> (<a href='futures.shared_future'>[futures.shared_future]</a>)
must either use read-only operations or provide additional synchronization.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='futures.promise'><h3 ><a class='secnum' href='#futures.promise' style='min-width:103pt'>30.6.5</a> Class template <span class='texttt'>promise</span> <a class='abbr_ref' href='futures.promise'>[futures.promise]</a></h3><p ><span class='indexparent'><a class='index' id='promise'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class R&gt;
  class promise {
  public:
    promise();
    template &lt;class Allocator&gt;
      promise(allocator_arg_t, const Allocator&amp; a);
    promise(promise&amp;&amp; rhs) noexcept;
    promise(const promise&amp; rhs) = delete;
    ~promise();

    <span class='comment'>// assignment
</span>    promise&amp; operator=(promise&amp;&amp; rhs) noexcept;
    promise&amp; operator=(const promise&amp; rhs) = delete;
    void swap(promise&amp; other) noexcept;

    <span class='comment'>// retrieving the result
</span>    future&lt;R&gt; get_future();

    <span class='comment'>// setting the result
</span>    void set_value(<i><span class='texttt'>see below</span></i>);
    void set_exception(exception_ptr p);

    <span class='comment'>// setting the result with deferred notification
</span>    void set_value_at_thread_exit(<i><span class='texttt'>see below</span></i>);
    void set_exception_at_thread_exit(exception_ptr p);
  };
  template &lt;class R&gt;
    void swap(promise&lt;R&gt;&amp; x, promise&lt;R&gt;&amp; y) noexcept;
  template &lt;class R, class Alloc&gt;
    struct uses_allocator&lt;promise&lt;R&gt;, Alloc&gt;;
}
</pre><div class='para' id='futures.promise-1'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-1'>1</a></div><p >The implementation shall provide the template <span class='texttt'>promise</span> and two specializations,
<span class='texttt'>promise&lt;R&amp;&gt;</span> and <span class='texttt'>promise&lt;<span class='discretionary'></span>void&gt;</span>. These differ only in the argument type
of the member functions <span class='texttt'>set_value</span> and <span class='texttt'>set_value_at_thread_exit</span>,
as set out in their descriptions, below.</p></div><div class='para' id='futures.promise-2'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-2'>2</a></div><p >The <span class='texttt'>set_value</span>, <span class='texttt'>set_exception</span>, <span class='texttt'>set_value_at_thread_exit</span>,
and <span class='texttt'>set_exception_at_thread_exit</span> member functions behave as though
they acquire a single mutex associated with the promise object while updating the
promise object.</p><p ><span class='indexparent'><a class='index' id='uses_allocator,promise'></a></span><code class='itemdecl'>
template &lt;class R, class Alloc&gt;
  struct uses_allocator&lt;promise&lt;R&gt;, Alloc&gt;
    : true_type { };
</code></p></div><div class='itemdescr'></div><div class='para' id='futures.promise-3'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>Alloc</span> shall be an Allocator (<a href='allocator.requirements'>[allocator.requirements]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='promise,constructor'></a></span><code class='itemdecl'>
promise();
template &lt;class Allocator&gt;
  promise(allocator_arg_t, const Allocator&amp; a);
</code></p><div class='itemdescr'></div><div class='para' id='futures.promise-4'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> constructs a <span class='texttt'>promise</span> object and a shared state. The second
constructor uses the allocator <span class='texttt'>a</span> to allocate memory for the shared
state.
</p></div></div><p ><span class='indexparent'><a class='index' id='promise,constructor'></a></span><code class='itemdecl'>
promise(promise&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.promise-5'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> constructs a new <span class='texttt'>promise</span> object and transfers ownership of the shared state
of <span class='texttt'>rhs</span> (if any) to the newly-constructed object.</p></div></div><div class='para' id='futures.promise-6'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-6'>6</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>rhs</span> has no shared state.
</p></div></div><p ><span class='indexparent'><a class='index' id='promise,destructor'></a></span><code class='itemdecl'>
~promise();
</code></p><div class='itemdescr'></div><div class='para' id='futures.promise-7'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
Abandons any shared state (<a href='futures.state'>[futures.state]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,promise'></a></span><span class='indexparent'><a class='index' id='promise,operator='></a></span><code class='itemdecl'>
promise&amp; operator=(promise&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.promise-8'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i>
Abandons any shared state (<a href='futures.state'>[futures.state]</a>) and then as if
<span class='texttt'>promise(std::move(rhs)).swap(*this)</span>.</p></div></div><div class='para' id='futures.promise-9'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,promise'></a></span><span class='indexparent'><a class='index' id='promise,swap'></a></span><code class='itemdecl'>
void swap(promise&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.promise-10'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Exchanges the shared state of <span class='texttt'>*this</span> and <span class='texttt'>other</span>.</p></div></div><div class='para' id='futures.promise-11'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-11'>11</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> has the shared state (if any) that <span class='texttt'>other</span> had
prior to the call to <span class='texttt'>swap</span>. <span class='texttt'>other</span> has the shared state (if any) that
<span class='texttt'>*this</span> had prior to the call to <span class='texttt'>swap</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_future,promise'></a></span><span class='indexparent'><a class='index' id='promise,get_future'></a></span><code class='itemdecl'>
future&lt;R&gt; get_future();
</code></p><div class='itemdescr'></div><div class='para' id='futures.promise-12'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>future&lt;R&gt;</span> object with the same shared state as
<span class='texttt'>*this</span>.</p></div></div><div class='para' id='futures.promise-13'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-13'>13</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>future_error</span> if <span class='texttt'>*this</span> has no shared state or if
<span class='texttt'>get_future</span> has already been called on a <span class='texttt'>promise</span> with the same
shared state as <span class='texttt'>*this</span>.</p></div></div><div class='para' id='futures.promise-14'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-14'>14</a></div><div class='itemdescr'><p ><i>Error conditions:</i></p><ul ><li ><p ><span class='texttt'>future_already_retrieved</span> if <span class='texttt'>get_future</span> has already been called on
a <span class='texttt'>promise</span> with the same shared state as <span class='texttt'>*this</span>.</p></li><li ><p ><span class='texttt'>no_state</span> if <span class='texttt'>*this</span> has no shared state.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='set_value,promise'></a></span><span class='indexparent'><a class='index' id='promise,set_value'></a></span><code class='itemdecl'>
void promise::set_value(const R&amp; r);
void promise::set_value(R&amp;&amp; r);
void promise&lt;R&amp;&gt;::set_value(R&amp; r);
void promise&lt;void&gt;::set_value();
</code></p><div class='itemdescr'></div><div class='para' id='futures.promise-15'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> Atomically stores the value <span class='texttt'>r</span> in the shared state and
makes that state ready (<a href='futures.state'>[futures.state]</a>).</p></div></div><div class='para' id='futures.promise-16'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-16'>16</a></div><div class='itemdescr'><p ><i>Throws:</i></p><ul ><li ><p ><span class='texttt'>future_error</span> if its shared state
already has a stored value or exception, or
</p></li><li ><p >for the first version, any exception thrown by the constructor selected to copy an object of <span class='texttt'>R</span>, or
</p></li><li ><p >for the second version, any exception thrown by the constructor selected to move an object of <span class='texttt'>R</span>.
</p></li></ul></div></div><div class='para' id='futures.promise-17'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-17'>17</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>promise_already_satisfied</span> if its shared state
already has a stored value or exception.
</p></li><li ><p ><span class='texttt'>no_state</span> if <span class='texttt'>*this</span> has no shared state.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='set_exception,promise'></a></span><span class='indexparent'><a class='index' id='promise,set_exception'></a></span><code class='itemdecl'>
void set_exception(exception_ptr p);
</code></p><div class='itemdescr'></div><div class='para' id='futures.promise-18'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-18'>18</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>p</span> is not null.</p></div></div><div class='para' id='futures.promise-19'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> Atomically stores the exception pointer <span class='texttt'>p</span> in the shared state
and makes that state ready (<a href='futures.state'>[futures.state]</a>).</p></div></div><div class='para' id='futures.promise-20'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-20'>20</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>future_error</span> if its shared state
already has a stored value or exception.</p></div></div><div class='para' id='futures.promise-21'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-21'>21</a></div><div class='itemdescr'><p ><i>Error conditions:</i></p><ul ><li ><p ><span class='texttt'>promise_already_satisfied</span> if its shared state
already has a stored value or exception.
</p></li><li ><p ><span class='texttt'>no_state</span> if <span class='texttt'>*this</span> has no shared state.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='set_value_at_thread_exit,promise'></a></span><span class='indexparent'><a class='index' id='promise,set_value_at_thread_exit'></a></span><code class='itemdecl'>
void promise::set_value_at_thread_exit(const R&amp; r);
void promise::set_value_at_thread_exit(R&amp;&amp; r);
void promise&lt;R&amp;&gt;::set_value_at_thread_exit(R&amp; r);
void promise&lt;void&gt;::set_value_at_thread_exit();
</code></p><div class='itemdescr'></div><div class='para' id='futures.promise-22'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i> Stores the value <span class='texttt'>r</span> in the shared state without making that
state ready immediately. Schedules that state to be made ready when the current
thread exits, after all objects of thread storage duration associated with the
current thread have been destroyed.</p></div></div><div class='para' id='futures.promise-23'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-23'>23</a></div><div class='itemdescr'><p ><i>Throws:</i></p><ul ><li ><p ><span class='texttt'>future_error</span> if its shared state
already has a stored value or exception, or
</p></li><li ><p >for the first version, any exception thrown by the constructor selected to copy an object of <span class='texttt'>R</span>, or
</p></li><li ><p >for the second version, any exception thrown by the constructor selected to move an object of <span class='texttt'>R</span>.
</p></li></ul></div></div><div class='para' id='futures.promise-24'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-24'>24</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>promise_already_satisfied</span> if its shared state
already has a stored value or exception.
</p></li><li ><p ><span class='texttt'>no_state</span> if <span class='texttt'>*this</span> has no shared state.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='set_exception_at_thread_exit,promise'></a></span><span class='indexparent'><a class='index' id='promise,set_exception_at_thread_exit'></a></span><code class='itemdecl'>
void set_exception_at_thread_exit(exception_ptr p);
</code></p><div class='itemdescr'></div><div class='para' id='futures.promise-25'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-25'>25</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>p</span> is not null.</p></div></div><div class='para' id='futures.promise-26'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-26'>26</a></div><div class='itemdescr'><p ><i>Effects:</i> Stores the exception pointer <span class='texttt'>p</span> in the shared state without
making that state ready immediately. Schedules that state to be made ready when
the current thread exits, after all objects of thread storage duration
associated with the current thread have been destroyed.</p></div></div><div class='para' id='futures.promise-27'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-27'>27</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>future_error</span> if an error condition occurs.</p></div></div><div class='para' id='futures.promise-28'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-28'>28</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>promise_already_satisfied</span> if its shared state
already has a stored value or exception.
</p></li><li ><p ><span class='texttt'>no_state</span> if <span class='texttt'>*this</span> has no shared state.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='swap,promise'></a></span><span class='indexparent'><a class='index' id='promise,swap'></a></span><code class='itemdecl'>
template &lt;class R&gt;
  void swap(promise&lt;R&gt;&amp; x, promise&lt;R&gt;&amp; y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.promise-29'><div class='marginalizedparent'><a class='marginalized' href='#futures.promise-29'>29</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>x.swap(y)</span>.
</p></div></div></div><div id='futures.unique_future'><h3 ><a class='secnum' href='#futures.unique_future' style='min-width:103pt'>30.6.6</a> Class template <span class='texttt'>future</span> <a class='abbr_ref' href='futures.unique_future'>[futures.unique_future]</a></h3><div class='para' id='futures.unique_future-1'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-1'>1</a></div><p >The class template <span class='texttt'>future</span> defines a type for asynchronous return objects which
do not share their shared state with other asynchronous return objects.
A default-constructed <span class='texttt'>future</span> object has no
shared state. A <span class='texttt'>future</span> object with shared state can be created by
functions on asynchronous providers (<a href='futures.state'>[futures.state]</a>) or by the move constructor
and shares its shared state with
the original asynchronous provider. The result (value or exception) of
a <span class='texttt'>future</span> object
can be
set by
calling a respective function on an
object that shares the same
shared state.</p></div><div class='para' id='futures.unique_future-2'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Member functions of <span class='texttt'>future</span> do not synchronize with themselves or with
member functions of <span class='texttt'>shared_future</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='futures.unique_future-3'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-3'>3</a></div><p >The effect of calling any member function other than the destructor, the
move-assignment operator, or <span class='texttt'>valid</span> on a <span class='texttt'>future</span> object for which
<span class='texttt'>valid() == false</span>
is undefined.
[&nbsp;<i>Note:</i><span class='space'></span> Implementations are encouraged to detect this case and throw an object of type
<span class='texttt'>future_error</span> with an error condition of <span class='texttt'>future_errc::no_state</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='future'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class R&gt;
  class future {
  public:
    future() noexcept;
    future(future &amp;&amp;) noexcept;
    future(const future&amp; rhs) = delete;
    ~future();
    future&amp; operator=(const future&amp; rhs) = delete;
    future&amp; operator=(future&amp;&amp;) noexcept;
    shared_future&lt;R&gt; share();

    <span class='comment'>// retrieving the value
</span>    <i><span class='texttt'>see below</span></i> get();

    <span class='comment'>// functions to check state
</span>    bool valid() const noexcept;

    void wait() const;
    template &lt;class Rep, class Period&gt;
      future_status wait_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time) const;
    template &lt;class Clock, class Duration&gt;
      future_status wait_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) const;
  };
}
</pre></div><div class='para' id='futures.unique_future-4'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-4'>4</a></div><p >The implementation shall provide the template <span class='texttt'>future</span> and two specializations,
<span class='texttt'>future&lt;R&amp;&gt;</span> and <span class='texttt'>future&lt;<span class='discretionary'></span>void&gt;</span>. These differ only in the return type and return
value of the member function <span class='texttt'>get</span>, as set out in its description, below.</p><p ><span class='indexparent'><a class='index' id='future,constructor'></a></span><code class='itemdecl'>
future() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='futures.unique_future-5'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an <span class='indexparent'><a class='index' id='empty_future_object'></a></span><a class='hidden_link' href='#def:empty' id='def:empty'><i>empty</i></a>
<span class='texttt'>future</span> object that does not refer to a
shared state.</p></div></div><div class='para' id='futures.unique_future-6'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-6'>6</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>valid() == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='future,constructor'></a></span><code class='itemdecl'>
future(future&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.unique_future-7'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs a <span class='texttt'>future</span> object that refers to the shared
state that
was originally referred to by <span class='texttt'>rhs</span> (if any).</p></div></div><div class='para' id='futures.unique_future-8'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-8'>8</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul ><li ><p ><span class='texttt'>valid()</span> returns the same value as <span class='texttt'>rhs.valid()</span> prior to the
constructor invocation.
</p></li><li ><p ><span class='texttt'>rhs.valid() == false</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='future,constructor'></a></span><code class='itemdecl'>
~future();
</code></p><div class='itemdescr'></div><div class='para' id='futures.unique_future-9'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >Releases any shared state (<a href='futures.state'>[futures.state]</a>);
</p></li><li ><p >destroys <span class='texttt'>*this</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='operator=,future'></a></span><span class='indexparent'><a class='index' id='future,operator='></a></span><code class='itemdecl'>
future&amp; operator=(future&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.unique_future-10'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >Releases any shared state (<a href='futures.state'>[futures.state]</a>).
</p></li><li ><p >move assigns the contents of <span class='texttt'>rhs</span> to <span class='texttt'>*this</span>.
</p></li></ul></div></div><div class='para' id='futures.unique_future-11'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-11'>11</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul ><li ><p ><span class='texttt'>valid()</span> returns the same value as <span class='texttt'>rhs.valid()</span> prior to the
assignment.</p></li><li ><p ><span class='texttt'>rhs.valid() == false</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='share,future'></a></span><span class='indexparent'><a class='index' id='future,share'></a></span><code class='itemdecl'>
shared_future&lt;R&gt; share();
</code></p><div class='itemdescr'></div><div class='para' id='futures.unique_future-12'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>shared_future&lt;R&gt;(std::move(*this))</span>.</p></div></div><div class='para' id='futures.unique_future-13'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-13'>13</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>valid() == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get,future'></a></span><span class='indexparent'><a class='index' id='future,get'></a></span><code class='itemdecl'>
R future::get();
R&amp; future&lt;R&amp;&gt;::get();
void future&lt;void&gt;::get();
</code></p><div class='itemdescr'></div><div class='para' id='futures.unique_future-14'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-14'>14</a></div><div class='itemdescr'><p ><i>Note:</i> as described above, the template and its two required specializations differ only in
the return type and return value of the member function <span class='texttt'>get</span>.</p></div></div><div class='para' id='futures.unique_future-15'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>wait()</span>s until the shared state is ready, then retrieves the
value stored in the shared state.</p></div></div><div class='para' id='futures.unique_future-16'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><ul ><li ><p ><span class='texttt'>future::get()</span> returns the value <span class='texttt'>v</span> stored in the object's shared state as
<span class='texttt'>std::move(v)</span>.</p></li><li ><p ><span class='texttt'>future&lt;R&amp;&gt;::get()</span> returns the reference stored as value in the object's shared state.</p></li><li ><p ><span class='texttt'>future&lt;void&gt;::get()</span> returns nothing.
</p></li></ul></div></div><div class='para' id='futures.unique_future-17'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-17'>17</a></div><div class='itemdescr'><p ><i>Throws:</i> the stored exception, if an exception was stored in the shared state.</p></div></div><div class='para' id='futures.unique_future-18'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-18'>18</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>valid() == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='valid,future'></a></span><span class='indexparent'><a class='index' id='future,valid'></a></span><code class='itemdecl'>
bool valid() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.unique_future-19'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-19'>19</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> only if <span class='texttt'>*this</span> refers to a shared state.
</p></div></div><p ><span class='indexparent'><a class='index' id='wait,future'></a></span><span class='indexparent'><a class='index' id='future,wait'></a></span><code class='itemdecl'>
void wait() const;
</code></p><div class='itemdescr'></div><div class='para' id='futures.unique_future-20'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-20'>20</a></div><div class='itemdescr'><p ><i>Effects:</i>
Blocks until the shared state is ready.
</p></div></div><p ><span class='indexparent'><a class='index' id='wait_for,future'></a></span><span class='indexparent'><a class='index' id='future,wait_for'></a></span><code class='itemdecl'>
template &lt;class Rep, class Period&gt;
  future_status wait_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time) const;
</code></p><div class='itemdescr'></div><div class='para' id='futures.unique_future-21'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-21'>21</a></div><div class='itemdescr'><p ><i>Effects:</i>
None if the shared state contains a deferred function (<a href='futures.async'>[futures.async]</a>),
otherwise
blocks until the shared state is ready or until
the relative timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>rel_time</span> has expired.</p></div></div><div class='para' id='futures.unique_future-22'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-22'>22</a></div><div class='itemdescr'><p ><i>Returns:</i></p><ul ><li ><p ><span class='texttt'>future_status::deferred</span> if the shared state contains a deferred
function.</p></li><li ><p ><span class='texttt'>future_status::ready</span> if the shared state is ready.</p></li><li ><p ><span class='texttt'>future_status::timeout</span> if the function is returning because the
relative timeout (<a href='thread.req.timing'>[thread.req.timing]</a>)
specified by <span class='texttt'>rel_time</span> has expired.
</p></li></ul></div></div><div class='para' id='futures.unique_future-23'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-23'>23</a></div><div class='itemdescr'><p ><i>Throws:</i>
timeout-related exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='wait_until,future'></a></span><span class='indexparent'><a class='index' id='future,wait_until'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration&gt;
  future_status wait_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) const;
</code></p><div class='itemdescr'></div><div class='para' id='futures.unique_future-24'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-24'>24</a></div><div class='itemdescr'><p ><i>Effects:</i>
None if the shared state contains a deferred function (<a href='futures.async'>[futures.async]</a>),
otherwise
blocks until the shared state is ready or until
the absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by <span class='texttt'>abs_time</span> has expired.</p></div></div><div class='para' id='futures.unique_future-25'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-25'>25</a></div><div class='itemdescr'><p ><i>Returns:</i></p><ul ><li ><p ><span class='texttt'>future_status::deferred</span> if the shared state contains a deferred
function.</p></li><li ><p ><span class='texttt'>future_status::ready</span> if the shared state is ready.</p></li><li ><p ><span class='texttt'>future_status::timeout</span> if the function is returning because the
absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>)
specified by <span class='texttt'>abs_time</span> has expired.
</p></li></ul></div></div><div class='para' id='futures.unique_future-26'><div class='marginalizedparent'><a class='marginalized' href='#futures.unique_future-26'>26</a></div><div class='itemdescr'><p ><i>Throws:</i>
timeout-related exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).
</p></div></div></div><div id='futures.shared_future'><h3 ><a class='secnum' href='#futures.shared_future' style='min-width:103pt'>30.6.7</a> Class template <span class='texttt'>shared_future</span> <a class='abbr_ref' href='futures.shared_future'>[futures.shared_future]</a></h3><div class='para' id='futures.shared_future-1'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-1'>1</a></div><p >The class template <span class='texttt'>shared_future</span> defines a type for asynchronous return objects
which may share their shared state with other asynchronous return
objects. A default-constructed <span class='texttt'>shared_future</span>
object has no shared state. A <span class='texttt'>shared_future</span> object with
shared state can
be created
by conversion from a <span class='texttt'>future</span> object and shares its shared state with the
original asynchronous provider (<a href='futures.state'>[futures.state]</a>) of the shared state.
The result (value or exception) of a <span class='texttt'>shared_future</span> object
can be set by
calling a respective function on an
object that shares the same shared state.</p></div><div class='para' id='futures.shared_future-2'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Member functions of <span class='texttt'>shared_future</span> do not synchronize with themselves,
but they synchronize with the shared state. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='futures.shared_future-3'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-3'>3</a></div><p >The effect of calling any member function other than the destructor, the move-assignment
operator, or <span class='texttt'>valid()</span> on a <span class='texttt'>shared_future</span> object for which <span class='texttt'>valid() ==
false</span> is undefined.
[&nbsp;<i>Note:</i><span class='space'></span> Implementations are encouraged to detect this case and throw an object of type
<span class='texttt'>future_error</span> with an error condition of <span class='texttt'>future_errc::no_state</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='shared_future'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class R&gt;
  class shared_future {
  public:
    shared_future() noexcept;
    shared_future(const shared_future&amp; rhs);
    shared_future(future&lt;R&gt;&amp;&amp;) noexcept;
    shared_future(shared_future&amp;&amp; rhs) noexcept;
    ~shared_future();
    shared_future&amp; operator=(const shared_future&amp; rhs);
    shared_future&amp; operator=(shared_future&amp;&amp; rhs) noexcept;

    <span class='comment'>// retrieving the value
</span>    <i><span class='texttt'>see below</span></i> get() const;

    <span class='comment'>// functions to check state
</span>    bool valid() const noexcept;

    void wait() const;
    template &lt;class Rep, class Period&gt;
      future_status wait_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time) const;
    template &lt;class Clock, class Duration&gt;
      future_status wait_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) const;
  };
}
</pre></div><div class='para' id='futures.shared_future-4'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-4'>4</a></div><p >The implementation shall provide the template <span class='texttt'>shared_future</span> and two
specializations, <span class='texttt'>shared_future&lt;R&amp;&gt;</span> and <span class='texttt'>shared_future&lt;void&gt;</span>. These
differ only in the return type and return value of the member function <span class='texttt'>get</span>, as
set out in its description, below.</p><p ><span class='indexparent'><a class='index' id='shared_future,constructor'></a></span><code class='itemdecl'>
shared_future() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='futures.shared_future-5'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs an <span class='indexparent'><a class='index' id='empty_shared_future_object'></a></span><a class='hidden_link' href='#def:empty' id='def:empty'><i>empty</i></a> <span class='texttt'>shared_future</span> object that does not refer to a
shared state.</p></div></div><div class='para' id='futures.shared_future-6'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-6'>6</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>valid() == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_future,constructor'></a></span><code class='itemdecl'>
shared_future(const shared_future&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='futures.shared_future-7'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>shared_future</span> object that refers to the same
shared state as <span class='texttt'>rhs</span> (if any).</p></div></div><div class='para' id='futures.shared_future-8'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-8'>8</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>valid()</span> returns the same value as <span class='texttt'>rhs.valid()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shared_future,constructor'></a></span><code class='itemdecl'>
shared_future(future&lt;R&gt;&amp;&amp; rhs) noexcept;
shared_future(shared_future&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.shared_future-9'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs a <span class='texttt'>shared_future</span> object that refers to the
shared state that was originally referred to by <span class='texttt'>rhs</span> (if any).</p></div></div><div class='para' id='futures.shared_future-10'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-10'>10</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul ><li ><p ><span class='texttt'>valid()</span> returns the same value as <span class='texttt'>rhs.valid()</span> returned prior to
the constructor invocation.
</p></li><li ><p ><span class='texttt'>rhs.valid() == false</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='shared_future,destructor'></a></span><code class='itemdecl'>
~shared_future();
</code></p><div class='itemdescr'></div><div class='para' id='futures.shared_future-11'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >Releases any shared state (<a href='futures.state'>[futures.state]</a>);
</p></li><li ><p >destroys <span class='texttt'>*this</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='operator=,shared_future'></a></span><span class='indexparent'><a class='index' id='shared_future,operator='></a></span><code class='itemdecl'>
shared_future&amp; operator=(shared_future&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.shared_future-12'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >Releases any shared state (<a href='futures.state'>[futures.state]</a>);
</p></li><li ><p >move assigns the contents of <span class='texttt'>rhs</span> to <span class='texttt'>*this</span>.
</p></li></ul></div></div><div class='para' id='futures.shared_future-13'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-13'>13</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
</p><ul ><li ><p ><span class='texttt'>valid()</span> returns the same value as <span class='texttt'>rhs.valid()</span> returned prior to
the assignment.</p></li><li ><p ><span class='texttt'>rhs.valid() == false</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='operator=,shared_future'></a></span><span class='indexparent'><a class='index' id='shared_future,operator='></a></span><code class='itemdecl'>
shared_future&amp; operator=(const shared_future&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='futures.shared_future-14'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >Releases any shared state (<a href='futures.state'>[futures.state]</a>);
</p></li><li ><p >assigns the contents of <span class='texttt'>rhs</span> to <span class='texttt'>*this</span>. [&nbsp;<i>Note:</i><span class='space'></span> As a result,
<span class='texttt'>*this</span> refers to the same shared state as <span class='texttt'>rhs</span>
(if any). <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div></div><div class='para' id='futures.shared_future-15'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-15'>15</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>valid() == rhs.valid()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get,shared_future'></a></span><span class='indexparent'><a class='index' id='shared_future,get'></a></span><code class='itemdecl'>
const R&amp; shared_future::get() const;
R&amp; shared_future&lt;R&amp;&gt;::get() const;
void shared_future&lt;void&gt;::get() const;
</code></p><div class='itemdescr'></div><div class='para' id='futures.shared_future-16'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-16'>16</a></div><div class='itemdescr'><p ><i>Note:</i> as described above, the template and its two required specializations differ only in
the return type and return value of the member function <span class='texttt'>get</span>.</p></div></div><div class='para' id='futures.shared_future-17'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-17'>17</a></div><div class='itemdescr'><p ><i>Note:</i> access to a value object stored in the shared state is
unsynchronized, so programmers should apply only those operations on <span class='texttt'>R</span> that do not
introduce a data race (<a href='intro.multithread'>[intro.multithread]</a>).</p></div></div><div class='para' id='futures.shared_future-18'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-18'>18</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>wait()</span>s until the shared state is ready, then retrieves the
value stored in the shared state.</p></div></div><div class='para' id='futures.shared_future-19'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-19'>19</a></div><div class='itemdescr'><p ><i>Returns:</i>
</p><ul ><li ><p ><span class='texttt'>shared_future::get()</span> returns a const reference to the value stored in the object's
shared state.
[&nbsp;<i>Note:</i><span class='space'></span> Access through that reference after the shared state has been
destroyed produces undefined behavior; this can be avoided by not storing the reference in any
storage with a greater lifetime than the <span class='texttt'>shared_future</span> object that returned the
reference. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li ><p ><span class='texttt'>shared_future&lt;R&amp;&gt;::get()</span> returns the reference stored as value in the object's
shared state.</p></li><li ><p ><span class='texttt'>shared_future&lt;void&gt;::get()</span> returns nothing.
</p></li></ul></div></div><div class='para' id='futures.shared_future-20'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-20'>20</a></div><div class='itemdescr'><p ><i>Throws:</i> the stored exception, if an exception was stored in the shared state.
</p></div></div><p ><span class='indexparent'><a class='index' id='valid,shared_future'></a></span><span class='indexparent'><a class='index' id='shared_future,valid'></a></span><code class='itemdecl'>
bool valid() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.shared_future-21'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-21'>21</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> only if <span class='texttt'>*this</span> refers to a shared state.
</p></div></div><p ><span class='indexparent'><a class='index' id='wait,shared_future'></a></span><span class='indexparent'><a class='index' id='shared_future,wait'></a></span><code class='itemdecl'>
void wait() const;
</code></p><div class='itemdescr'></div><div class='para' id='futures.shared_future-22'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i>
Blocks until the shared state is ready.
</p></div></div><p ><span class='indexparent'><a class='index' id='wait_for,shared_future'></a></span><span class='indexparent'><a class='index' id='shared_future,wait_for'></a></span><code class='itemdecl'>
template &lt;class Rep, class Period&gt;
  future_status wait_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time) const;
</code></p><div class='itemdescr'></div><div class='para' id='futures.shared_future-23'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-23'>23</a></div><div class='itemdescr'><p ><i>Effects:</i>
None if the shared state contains a deferred function (<a href='futures.async'>[futures.async]</a>),
otherwise
blocks until the shared state is ready or until
the relative timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by
<span class='texttt'>rel_time</span> has expired.</p></div></div><div class='para' id='futures.shared_future-24'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-24'>24</a></div><div class='itemdescr'><p ><i>Returns:</i></p><ul ><li ><p ><span class='texttt'>future_status::deferred</span> if the shared state contains a deferred
function.</p></li><li ><p ><span class='texttt'>future_status::ready</span> if the shared state is ready.</p></li><li ><p ><span class='texttt'>future_status::timeout</span> if the function is returning because the
relative timeout (<a href='thread.req.timing'>[thread.req.timing]</a>)
specified by <span class='texttt'>rel_time</span> has expired.
</p></li></ul></div></div><div class='para' id='futures.shared_future-25'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-25'>25</a></div><div class='itemdescr'><p ><i>Throws:</i>
timeout-related exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='wait_until,shared_future'></a></span><span class='indexparent'><a class='index' id='shared_future,wait_until'></a></span><code class='itemdecl'>
template &lt;class Clock, class Duration&gt;
  future_status wait_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) const;
</code></p><div class='itemdescr'></div><div class='para' id='futures.shared_future-26'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-26'>26</a></div><div class='itemdescr'><p ><i>Effects:</i>
None if the shared state contains a deferred function (<a href='futures.async'>[futures.async]</a>),
otherwise
blocks until the shared state is ready or until the
absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>) specified by
<span class='texttt'>abs_time</span> has expired.</p></div></div><div class='para' id='futures.shared_future-27'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-27'>27</a></div><div class='itemdescr'><p ><i>Returns:</i></p><ul ><li ><p ><span class='texttt'>future_status::deferred</span> if the shared state contains a deferred
function.</p></li><li ><p ><span class='texttt'>future_status::ready</span> if the shared state is ready.</p></li><li ><p ><span class='texttt'>future_status::timeout</span> if the function is returning because the
absolute timeout (<a href='thread.req.timing'>[thread.req.timing]</a>)
specified by <span class='texttt'>abs_time</span> has expired.
</p></li></ul></div></div><div class='para' id='futures.shared_future-28'><div class='marginalizedparent'><a class='marginalized' href='#futures.shared_future-28'>28</a></div><div class='itemdescr'><p ><i>Throws:</i>
timeout-related exceptions (<a href='thread.req.timing'>[thread.req.timing]</a>).
</p></div></div></div><div id='futures.async'><h3 ><a class='secnum' href='#futures.async' style='min-width:103pt'>30.6.8</a> Function template <span class='texttt'>async</span> <a class='abbr_ref' href='futures.async'>[futures.async]</a></h3><div class='para' id='futures.async-1'><div class='marginalizedparent'><a class='marginalized' href='#futures.async-1'>1</a></div><p >The function template <span class='texttt'>async</span> provides a mechanism to launch a function potentially
in a new thread and provides the result of the function in a <span class='texttt'>future</span> object with which
it shares a shared state.</p><p ><span class='indexparent'><a class='index' id='async'></a></span><code class='itemdecl'>
template &lt;class F, class... Args&gt;
  future&lt;result_of_t&lt;decay_t&lt;F&gt;(decay_t&lt;Args&gt;...)&gt;&gt; async(F&amp;&amp; f, Args&amp;&amp;... args);
template &lt;class F, class... Args&gt;
  future&lt;result_of_t&lt;decay_t&lt;F&gt;(decay_t&lt;Args&gt;...)&gt;&gt; async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args);
</code></p></div><div class='itemdescr'></div><div class='para' id='futures.async-2'><div class='marginalizedparent'><a class='marginalized' href='#futures.async-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>F</span> and each <span class='texttt'>Ti</span> in <span class='texttt'>Args</span> shall
satisfy the
<span class='texttt'>MoveConstructible</span> requirements.
<span class='texttt'><i>INVOKE</i>(<i>DECAY_COPY</i>(std::forward&lt;F&gt;(f)),
<i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...)</span>
(<a href='func.require'>[func.require]</a>, <a href='thread.thread.constr'>[thread.thread.constr]</a>) shall be a valid expression.</p></div></div><div class='para' id='futures.async-3'><div class='marginalizedparent'><a class='marginalized' href='#futures.async-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
The first function
behaves the same as a call to the second function with a <span class='texttt'>policy</span> argument of
<span class='texttt'>launch::async | launch::deferred</span>
and the same arguments for <span class='texttt'>F</span> and <span class='texttt'>Args</span>.
The second function creates a shared state that is associated with
the returned <span class='texttt'>future</span> object.
The further behavior
of the second function depends on the <span class='texttt'>policy</span> argument as follows (if
more than one of these conditions applies, the implementation may choose any of
the corresponding policies):</p><ul ><li ><p >If <span class='texttt'>policy &amp; launch::async</span> is non-zero — calls
<span class='texttt'><i>INVOKE</i>(<i>DECAY_COPY</i>(std::forward&lt;F&gt;(f)),</span><br/> 
<span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...)</span>
(<a href='func.require'>[func.require]</a>, <a href='thread.thread.constr'>[thread.thread.constr]</a>)
as if in a new thread of execution represented by a <span class='texttt'>thread</span> object
with the calls to <span class='texttt'><i>DECAY_COPY</i>()</span> being evaluated in the thread that called <span class='texttt'>async</span>.
Any return value
is stored as the result in the
shared state. Any exception propagated from
the execution of
<span class='texttt'><i>INVOKE</i>(<i>DECAY_COPY</i>(std::forward&lt;F&gt;(f)),
<i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...)</span>
is stored as the exceptional result in the shared state.
The <span class='texttt'>thread</span> object is
stored in the shared state
and affects the behavior of any asynchronous return objects that
reference that state.</p></li><li ><p >If <span class='texttt'>policy &amp; launch::deferred</span> is non-zero —
Stores <span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;F&gt;(f))</span> and<br/>
<span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...</span>
in the shared state. These copies of <span class='texttt'>f</span> and <span class='texttt'>args</span> constitute
a <a class='hidden_link' href='#def:deferred_function' id='def:deferred_function'><i>deferred function</i></a>. Invocation of the deferred function evaluates
<span class='texttt'><i>INVOKE</i>(std::move(g), std::move(xyz))</span> where <span class='texttt'>g</span> is the stored value of 
<span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;F&gt;(f))</span> and <span class='texttt'>xyz</span> is the stored copy of
<span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...</span>.
Any return value is stored
as the result in the shared state.
Any exception propagated
from the execution
of the deferred function
is stored as the exceptional result
in the shared state.
The shared state is not
made ready until the function has completed. The first call to a
non-timed waiting function (<a href='futures.state'>[futures.state]</a>)
on an asynchronous return object referring to
this shared state shall invoke the
deferred function in the thread that called the waiting function.
Once evaluation of <span class='texttt'><i>INVOKE</i>(std::move(g), std::move(xyz))</span> begins, the function is no longer
considered deferred.
[&nbsp;<i>Note:</i><span class='space'></span> If this policy is specified together with other policies, such as when using a
<span class='texttt'>policy</span> value of <span class='texttt'>launch::async | launch::deferred</span>, implementations should defer
invocation or the selection of the policy when no more concurrency can be effectively
exploited. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li ><p >If no value is set in the launch policy, or a value is set that is neither specified
in this International Standard nor by the implementation, the behavior is undefined.
</p></li></ul></div></div><div class='para' id='futures.async-4'><div class='marginalizedparent'><a class='marginalized' href='#futures.async-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> An object of type
<span class='texttt'>future&lt;result_of_t&lt;decay_t&lt;F&gt;(decay_t&lt;Args&gt;...)&gt;&gt;</span> that refers
to the shared state created by this call to <span class='texttt'>async</span>.
[&nbsp;<i>Note:</i><span class='space'></span> If a future obtained from <span class='texttt'>std::async</span> is moved outside the local scope,
other code that uses the future must be aware that the future's destructor may
block for the shared state to become ready. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='futures.async-5'><div class='marginalizedparent'><a class='marginalized' href='#futures.async-5'>5</a></div><div class='itemdescr'><p ><i>Synchronization:</i>
Regardless of the provided <span class='texttt'>policy</span> argument,
</p><ul ><li ><p >the invocation of <span class='texttt'>async</span>
synchronizes with (<a href='intro.multithread'>[intro.multithread]</a>) the invocation of <span class='texttt'>f</span>. [&nbsp;<i>Note:</i><span class='space'></span>
This statement applies even when the corresponding <span class='texttt'>future</span> object is moved to
another thread. <i>&nbsp;—&nbsp;end note</i>&nbsp;]; and</p></li><li ><p >the completion of the function <span class='texttt'>f</span> is sequenced before (<a href='intro.multithread'>[intro.multithread]</a>) the
shared state is made ready. [&nbsp;<i>Note:</i><span class='space'></span> <span class='texttt'>f</span> might not be called at all,
so its completion might never happen. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >If the implementation chooses the <span class='texttt'>launch::async</span> policy,</p><ul ><li ><p >a call to a waiting function on an asynchronous return
object that shares the shared state created by this <span class='texttt'>async</span> call shall
block until the associated thread has completed, as if joined, or else time
out (<a href='thread.thread.member'>[thread.thread.member]</a>);</p></li><li ><p >the associated thread completion
synchronizes with (<a href='intro.multithread'>[intro.multithread]</a>)
the return from
the first function
that successfully detects the ready status of the shared state or 
with the return from the last
function that releases the shared state, whichever
happens first.
</p></li></ul></div></div><div class='para' id='futures.async-6'><div class='marginalizedparent'><a class='marginalized' href='#futures.async-6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> if <span class='texttt'>policy == launch::async</span> and the
implementation is unable to start a new thread.</p></div></div><div class='para' id='futures.async-7'><div class='marginalizedparent'><a class='marginalized' href='#futures.async-7'>7</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>resource_unavailable_try_again</span> — if
<span class='texttt'>policy == launch::async</span> and the system is unable to start a new thread.
</p></li></ul></div></div><div class='para' id='futures.async-8'><div class='marginalizedparent'><a class='marginalized' href='#futures.async-8'>8</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
int work1(int value);
int work2(int value);
int work(int value) {
  auto handle = std::async([=]{ return work2(value); });
  int tmp = work1(value);
  return tmp + handle.get();    <span class='comment'>// #1
</span>}
</pre><p >[&nbsp;<i>Note:</i><span class='space'></span> Line #1 might not result in concurrency because
the <span class='texttt'>async</span> call uses the default policy, which may use
<span class='texttt'>launch::deferred</span>, in which case the lambda might not be invoked until the
<span class='texttt'>get()</span> call; in that case, <span class='texttt'>work1</span> and <span class='texttt'>work2</span> are called on the
same thread and there is no concurrency.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='futures.task'><h3 ><a class='secnum' href='#futures.task' style='min-width:103pt'>30.6.9</a> Class template <span class='texttt'>packaged_task</span> <a class='abbr_ref' href='futures.task'>[futures.task]</a></h3><div class='para' id='futures.task-1'><div class='marginalizedparent'><a class='marginalized' href='#futures.task-1'>1</a></div><p >The class template <span class='texttt'>packaged_task</span> defines a type for wrapping a function or
callable object so that the return value of the function or callable object is stored in
a future when it is invoked.</p></div><div class='para' id='futures.task-2'><div class='marginalizedparent'><a class='marginalized' href='#futures.task-2'>2</a></div><p >When the <span class='texttt'>packaged_task</span> object is invoked, its stored task is invoked and the
result (whether normal or exceptional) stored in the shared state. Any futures that
share the shared state will then be able to access the stored result.</p><p ><span class='indexparent'><a class='index' id='packaged_task'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class&gt; class packaged_task; <span class='comment'>// not defined
</span>
  template&lt;class R, class... ArgTypes&gt;
  class packaged_task&lt;R(ArgTypes...)&gt; {
  public:
    <span class='comment'>// construction and destruction
</span>    packaged_task() noexcept;
    template &lt;class F&gt;
      explicit packaged_task(F&amp;&amp; f);
    template &lt;class F, class Allocator&gt;
      packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
    ~packaged_task();

    <span class='comment'>// no copy
</span>    packaged_task(const packaged_task&amp;) = delete;
    packaged_task&amp; operator=(const packaged_task&amp;) = delete;

    <span class='comment'>// move support
</span>    packaged_task(packaged_task&amp;&amp; rhs) noexcept;
    packaged_task&amp; operator=(packaged_task&amp;&amp; rhs) noexcept;
    void swap(packaged_task&amp; other) noexcept;

    bool valid() const noexcept;

    <span class='comment'>// result retrieval
</span>    future&lt;R&gt; get_future();        

    <span class='comment'>// execution
</span>    void operator()(ArgTypes... );
    void make_ready_at_thread_exit(ArgTypes...);

    void reset();
  };
  template &lt;class R, class... ArgTypes&gt;
    void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp; x, packaged_task&lt;R(ArgTypes...)&gt;&amp; y) noexcept;
  template &lt;class R, class Alloc&gt;
    struct uses_allocator&lt;packaged_task&lt;R&gt;, Alloc&gt;;
}
</pre></div><div id='futures.task.members'><h4 ><a class='secnum' href='#futures.task.members' style='min-width:118pt'>30.6.9.1</a> <span class='texttt'>packaged_task</span> member functions <a class='abbr_ref' href='futures.task.members'>[futures.task.members]</a></h4><p ><span class='indexparent'><a class='index' id='packaged_task,constructor'></a></span><code class='itemdecl'>
packaged_task() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.task.members-1'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>packaged_task</span> object with no shared state and no stored task.
</p></div></div><p ><span class='indexparent'><a class='index' id='packaged_task,constructor'></a></span><code class='itemdecl'>
template &lt;class F&gt;
  packaged_task(F&amp;&amp; f);
template &lt;class F, class Allocator&gt;
  packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
</code></p><div class='itemdescr'></div><div class='para' id='futures.task.members-2'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN, R)</span>, where <span class='texttt'>t1, t2, ..., tN</span> are values
of the corresponding types in <span class='texttt'>ArgTypes...</span>, shall be a valid expression. Invoking
a copy of <span class='texttt'>f</span> shall behave the same as invoking <span class='texttt'>f</span>.</p></div></div><div class='para' id='futures.task.members-3'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i>
These constructors shall not participate in overload resolution if <span class='texttt'>decay_t&lt;F&gt;</span>
is the same type as <span class='texttt'>std::packaged_task&lt;R(ArgTypes...)&gt;</span>.</p></div></div><div class='para' id='futures.task.members-4'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a new <span class='texttt'>packaged_task</span> object with a shared state and
initializes the object's stored task with <span class='texttt'>std::forward&lt;F&gt;(f)</span>. The constructors that
take an <span class='texttt'>Allocator</span> argument use it to allocate memory needed to store the
internal data structures.</p></div></div><div class='para' id='futures.task.members-5'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i> any exceptions thrown by the copy or move constructor of <span class='texttt'>f</span>, or
<span class='texttt'>std::bad_alloc</span> if memory for the internal data structures could not be
allocated.
</p></div></div><p ><span class='indexparent'><a class='index' id='packaged_task,constructor'></a></span><code class='itemdecl'>
packaged_task(packaged_task&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.task.members-6'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a new <span class='texttt'>packaged_task</span> object and transfers ownership of
<span class='texttt'>rhs</span>'s shared state to <span class='texttt'>*this</span>, leaving <span class='texttt'>rhs</span> with no
shared state. Moves the stored task from <span class='texttt'>rhs</span> to <span class='texttt'>*this</span>.</p></div></div><div class='para' id='futures.task.members-7'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-7'>7</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>rhs</span> has no shared state.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,packaged_task'></a></span><span class='indexparent'><a class='index' id='packaged_task,operator='></a></span><code class='itemdecl'>
packaged_task&amp; operator=(packaged_task&amp;&amp; rhs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.task.members-8'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >Releases any shared state (<a href='futures.state'>[futures.state]</a>);
</p></li><li ><p >calls <span class='texttt'>packaged_task(std::move(rhs)).swap(*this)</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='packaged_task,destructor'></a></span><code class='itemdecl'>
~packaged_task();
</code></p><div class='itemdescr'></div><div class='para' id='futures.task.members-9'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
Abandons any shared state (<a href='futures.state'>[futures.state]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,packaged_task'></a></span><span class='indexparent'><a class='index' id='packaged_task,swap'></a></span><code class='itemdecl'>
void swap(packaged_task&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.task.members-10'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Exchanges the shared states and stored tasks of <span class='texttt'>*this</span> and <span class='texttt'>other</span>.</p></div></div><div class='para' id='futures.task.members-11'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-11'>11</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> has the same shared state
and stored task (if any) as <span class='texttt'>other</span>
prior to the call to <span class='texttt'>swap</span>. <span class='texttt'>other</span> has the same shared state
and stored task (if any)
as <span class='texttt'>*this</span> prior to the call to <span class='texttt'>swap</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='valid,packaged_task'></a></span><span class='indexparent'><a class='index' id='packaged_task,valid'></a></span><code class='itemdecl'>
bool valid() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.task.members-12'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> only if <span class='texttt'>*this</span> has a shared state.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_future,packaged_task'></a></span><span class='indexparent'><a class='index' id='packaged_task,get_future'></a></span><code class='itemdecl'>
future&lt;R&gt; get_future();
</code></p><div class='itemdescr'></div><div class='para' id='futures.task.members-13'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> A <span class='texttt'>future</span> object that shares the same shared state as <span class='texttt'>*this</span>.</p></div></div><div class='para' id='futures.task.members-14'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-14'>14</a></div><div class='itemdescr'><p ><i>Throws:</i> a <span class='texttt'>future_error</span> object if an error occurs.</p></div></div><div class='para' id='futures.task.members-15'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-15'>15</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>future_already_retrieved</span> if <span class='texttt'>get_future</span> has already been called on
a <span class='texttt'>packaged_task</span> object with the same shared state as <span class='texttt'>*this</span>.
</p></li><li ><p ><span class='texttt'>no_state</span> if <span class='texttt'>*this</span> has no shared state.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='operator(),packaged_task'></a></span><span class='indexparent'><a class='index' id='packaged_task,operator()'></a></span><code class='itemdecl'>
void operator()(ArgTypes... args);
</code></p><div class='itemdescr'></div><div class='para' id='futures.task.members-16'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN, R)</span>,
where <span class='texttt'>f</span> is the
stored task of <span class='texttt'>*this</span> and
<span class='texttt'>t1, t2, ..., tN</span> are the values in <span class='texttt'>args...</span>. If the task returns normally,
the return value is stored as the asynchronous result in the shared state of
<span class='texttt'>*this</span>, otherwise the exception thrown by the task is stored. The
shared state of <span class='texttt'>*this</span> is made ready, and any threads blocked in a
function waiting for
the shared state of <span class='texttt'>*this</span> to become ready are unblocked.</p></div></div><div class='para' id='futures.task.members-17'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-17'>17</a></div><div class='itemdescr'><p ><i>Throws:</i> a <span class='texttt'>future_error</span> exception object if there is no shared
state or the stored task has already been invoked.</p></div></div><div class='para' id='futures.task.members-18'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-18'>18</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>promise_already_satisfied</span> if
the stored task has already been invoked.
</p></li><li ><p ><span class='texttt'>no_state</span> if <span class='texttt'>*this</span> has no shared state.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='make_ready_at_thread_exit,packaged_task'></a></span><span class='indexparent'><a class='index' id='packaged_task,make_ready_at_thread_exit'></a></span><code class='itemdecl'>
void make_ready_at_thread_exit(ArgTypes... args);
</code></p><div class='itemdescr'></div><div class='para' id='futures.task.members-19'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN, R)</span>,
where <span class='texttt'>f</span> is the stored task and
<span class='texttt'>t1, t2, ..., tN</span> are the values in <span class='texttt'>args...</span>. If the task returns normally,
the return value is stored as the asynchronous result in the shared state of
<span class='texttt'>*this</span>, otherwise the exception thrown by the task is stored. In either
case, this shall be done without making that state ready (<a href='futures.state'>[futures.state]</a>) immediately. Schedules
the shared state to be made ready when the current thread exits,
after all objects of thread storage duration associated with the current thread
have been destroyed.</p></div></div><div class='para' id='futures.task.members-20'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-20'>20</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>future_error</span> if an error condition occurs.</p></div></div><div class='para' id='futures.task.members-21'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-21'>21</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>promise_already_satisfied</span> if the
stored task has already been invoked.
</p></li><li ><p ><span class='texttt'>no_state</span> if <span class='texttt'>*this</span> has no shared state.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='reset,packaged_task'></a></span><span class='indexparent'><a class='index' id='packaged_task,reset'></a></span><code class='itemdecl'>
void reset();
</code></p><div class='itemdescr'></div><div class='para' id='futures.task.members-22'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i> As if <span class='texttt'>*this = packaged_task(std::move(f))</span>, where
<span class='texttt'>f</span> is the task stored in
<span class='texttt'>*this</span>. [&nbsp;<i>Note:</i><span class='space'></span> This constructs a new shared state for <span class='texttt'>*this</span>. The
old state is abandoned (<a href='futures.state'>[futures.state]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='futures.task.members-23'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.members-23'>23</a></div><div class='itemdescr'><p ><i>Throws:</i>
</p><ul ><li ><p ><span class='texttt'>bad_alloc</span> if memory for the new shared state could not be allocated.
</p></li><li ><p >any exception thrown by the move constructor of the task stored in the shared
state.
</p></li><li ><p ><span class='texttt'>future_error</span> with an error condition of <span class='texttt'>no_state</span> if <span class='texttt'>*this</span>
has no shared state.
</p></li></ul></div></div></div><div id='futures.task.nonmembers'><h4 ><a class='secnum' href='#futures.task.nonmembers' style='min-width:118pt'>30.6.9.2</a> <span class='texttt'>packaged_task</span> globals <a class='abbr_ref' href='futures.task.nonmembers'>[futures.task.nonmembers]</a></h4><p ><span class='indexparent'><a class='index' id='swap,packaged_task'></a></span><span class='indexparent'><a class='index' id='packaged_task,swap'></a></span><code class='itemdecl'>
template &lt;class R, class... ArgTypes&gt;
  void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp; x, packaged_task&lt;R(ArgTypes...)&gt;&amp; y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='futures.task.nonmembers-1'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.nonmembers-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>x.swap(y)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='uses_allocator,packaged_task'></a></span><code class='itemdecl'>
template &lt;class R, class Alloc&gt;
  struct uses_allocator&lt;packaged_task&lt;R&gt;, Alloc&gt;
    : true_type { };
</code></p><div class='itemdescr'></div><div class='para' id='futures.task.nonmembers-2'><div class='marginalizedparent'><a class='marginalized' href='#futures.task.nonmembers-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>Alloc</span> shall be an Allocator (<a href='allocator.requirements'>[allocator.requirements]</a>).
</p></div></div></div></div></div></div></div></body></html>