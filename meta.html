<!DOCTYPE html><html lang='en'><head><title>[meta]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><div id='meta'><h2 ><a class='secnum' style='min-width:88pt'>20.15</a> Metaprogramming and type traits <a class='abbr_ref'>[meta]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >This subclause describes components used by C++ programs, particularly in
templates, to support the widest possible range of types, optimise
template code usage, detect type related user errors, and perform
type inference and transformation at compile time. It includes type
classification traits, type property inspection traits, and type
transformations. The type classification traits describe a complete taxonomy
of all possible C++ types, and state where in that taxonomy a given
type belongs. The type property inspection traits allow important
characteristics of types or of combinations of types to be inspected. The
type transformations allow certain properties of types to be manipulated.</p></div><div id='rqmts'><h3 ><a class='secnum' href='#rqmts' style='min-width:103pt'>20.15.1</a> Requirements <a class='abbr_ref' href='meta.rqmts'>[meta.rqmts]</a></h3><div class='para' id='rqmts-1'><div class='marginalizedparent'><a class='marginalized' href='#rqmts-1'>1</a></div><p >A <a class='hidden_link' href='#def:UnaryTypeTrait' id='def:UnaryTypeTrait'><i>UnaryTypeTrait</i></a> describes a property
of a type. It shall be a class template that takes one template type
argument and, optionally, additional arguments that help define the
property being described. It shall be <span class='texttt'>DefaultConstructible</span>,
<span class='texttt'>CopyConstructible</span>,
and publicly and unambiguously derived, directly or indirectly, from
its <a class='hidden_link' href='#def:base_characteristic' id='def:base_characteristic'><i>base characteristic</i></a>, which is
a specialization of the template
<span class='texttt'>integral_constant</span> (<a href='meta.help'>[meta.help]</a>), with
the arguments to the template <span class='texttt'>integral_constant</span> determined by the
requirements for the particular property being described.
The member names of the base characteristic shall not be hidden and shall be
unambiguously available in the <span class='texttt'>UnaryTypeTrait</span>.</p></div><div class='para' id='rqmts-2'><div class='marginalizedparent'><a class='marginalized' href='#rqmts-2'>2</a></div><p >A <a class='hidden_link' href='#def:BinaryTypeTrait' id='def:BinaryTypeTrait'><i>BinaryTypeTrait</i></a> describes a
relationship between two types. It shall be a class template that
takes two template type arguments and, optionally, additional
arguments that help define the relationship being described. It shall
be <span class='texttt'>DefaultConstructible</span>, <span class='texttt'>CopyConstructible</span>,
and publicly and unambiguously derived, directly or
indirectly, from
its <a class='hidden_link' href='#def:base_characteristic' id='def:base_characteristic'><i>base characteristic</i></a>, which is a specialization
of the template
<span class='texttt'>integral_constant</span> (<a href='meta.help'>[meta.help]</a>), with
the arguments to the template <span class='texttt'>integral_constant</span> determined by the
requirements for the particular relationship being described.
The member names of the base characteristic shall not be hidden and shall be
unambiguously available in the <span class='texttt'>BinaryTypeTrait</span>.</p></div><div class='para' id='rqmts-3'><div class='marginalizedparent'><a class='marginalized' href='#rqmts-3'>3</a></div><p >A <a class='hidden_link' href='#def:TransformationTrait' id='def:TransformationTrait'><i>TransformationTrait</i></a>
modifies a property
of a type. It shall be a class template that takes one
template type argument and, optionally, additional arguments that help
define the modification. It shall define a publicly accessible nested type
named <span class='texttt'>type</span>, which shall be a synonym for the modified type.</p></div></div><div id='type.synop'><h3 ><a class='secnum' href='#type.synop' style='min-width:103pt'>20.15.2</a> Header <span class='texttt'>&lt;type_traits&gt;</span> synopsis <a class='abbr_ref' href='meta.type.synop'>[meta.type.synop]</a></h3><p ><span class='indexparent'><a class='index' id='type_traits'></a></span><span class='indexparent'><a class='index' id='type_traits'></a></span></p><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='meta.help'>[meta.help]</a>, helper class
</span>  template &lt;class T, T v&gt; struct integral_constant;

  template &lt;bool B&gt;
    using bool_constant = integral_constant&lt;bool, B&gt;;
  using true_type  = bool_constant&lt;true&gt;;
  using false_type = bool_constant&lt;false&gt;;

  <span class='comment'>// <a href='meta.unary.cat'>[meta.unary.cat]</a>, primary type categories
</span>  template &lt;class T&gt; struct is_void;
  template &lt;class T&gt; struct is_null_pointer;
  template &lt;class T&gt; struct is_integral;
  template &lt;class T&gt; struct is_floating_point;
  template &lt;class T&gt; struct is_array;
  template &lt;class T&gt; struct is_pointer;
  template &lt;class T&gt; struct is_lvalue_reference;
  template &lt;class T&gt; struct is_rvalue_reference;
  template &lt;class T&gt; struct is_member_object_pointer;
  template &lt;class T&gt; struct is_member_function_pointer;
  template &lt;class T&gt; struct is_enum;
  template &lt;class T&gt; struct is_union;
  template &lt;class T&gt; struct is_class;
  template &lt;class T&gt; struct is_function;

  <span class='comment'>// <a href='meta.unary.comp'>[meta.unary.comp]</a>, composite type categories
</span>  template &lt;class T&gt; struct is_reference;
  template &lt;class T&gt; struct is_arithmetic;
  template &lt;class T&gt; struct is_fundamental;
  template &lt;class T&gt; struct is_object;
  template &lt;class T&gt; struct is_scalar;
  template &lt;class T&gt; struct is_compound;
  template &lt;class T&gt; struct is_member_pointer;

  <span class='comment'>// <a href='meta.unary.prop'>[meta.unary.prop]</a>, type properties
</span>  template &lt;class T&gt; struct is_const;
  template &lt;class T&gt; struct is_volatile;
  template &lt;class T&gt; struct is_trivial;
  template &lt;class T&gt; struct is_trivially_copyable;
  template &lt;class T&gt; struct is_standard_layout;
  template &lt;class T&gt; struct is_pod;
  template &lt;class T&gt; struct is_empty;
  template &lt;class T&gt; struct is_polymorphic;
  template &lt;class T&gt; struct is_abstract;
  template &lt;class T&gt; struct is_final;

  template &lt;class T&gt; struct is_signed;
  template &lt;class T&gt; struct is_unsigned;

  template &lt;class T, class... Args&gt; struct is_constructible;
  template &lt;class T&gt; struct is_default_constructible;
  template &lt;class T&gt; struct is_copy_constructible;
  template &lt;class T&gt; struct is_move_constructible;

  template &lt;class T, class U&gt; struct is_assignable;
  template &lt;class T&gt; struct is_copy_assignable;
  template &lt;class T&gt; struct is_move_assignable;

  template &lt;class T, class U&gt; struct is_swappable_with;
  template &lt;class T&gt; struct is_swappable;

  template &lt;class T&gt; struct is_destructible;

  template &lt;class T, class... Args&gt; struct is_trivially_constructible;
  template &lt;class T&gt; struct is_trivially_default_constructible;
  template &lt;class T&gt; struct is_trivially_copy_constructible;
  template &lt;class T&gt; struct is_trivially_move_constructible;

  template &lt;class T, class U&gt; struct is_trivially_assignable;
  template &lt;class T&gt; struct is_trivially_copy_assignable;
  template &lt;class T&gt; struct is_trivially_move_assignable;
  template &lt;class T&gt; struct is_trivially_destructible;

  template &lt;class T, class... Args&gt; struct is_nothrow_constructible;
  template &lt;class T&gt; struct is_nothrow_default_constructible;
  template &lt;class T&gt; struct is_nothrow_copy_constructible;
  template &lt;class T&gt; struct is_nothrow_move_constructible;

  template &lt;class T, class U&gt; struct is_nothrow_assignable;
  template &lt;class T&gt; struct is_nothrow_copy_assignable;
  template &lt;class T&gt; struct is_nothrow_move_assignable;

  template &lt;class T, class U&gt; struct is_nothrow_swappable_with;
  template &lt;class T&gt; struct is_nothrow_swappable;

  template &lt;class T&gt; struct is_nothrow_destructible;

  template &lt;class T&gt; struct has_virtual_destructor;

  template &lt;class T&gt; struct has_unique_object_representations;

  <span class='comment'>// <a href='meta.unary.prop.query'>[meta.unary.prop.query]</a>, type property queries
</span>  template &lt;class T&gt; struct alignment_of;
  template &lt;class T&gt; struct rank;
  template &lt;class T, unsigned I = 0&gt; struct extent;

  <span class='comment'>// <a href='meta.rel'>[meta.rel]</a>, type relations
</span>  template &lt;class T, class U&gt; struct is_same;
  template &lt;class Base, class Derived&gt; struct is_base_of;
  template &lt;class From, class To&gt; struct is_convertible;

  template &lt;class, class R = void&gt; struct is_callable; <span class='comment'>// not defined
</span>  template &lt;class Fn, class... ArgTypes, class R&gt;
    struct is_callable&lt;Fn(ArgTypes...), R&gt;;
     
  template &lt;class, class R = void&gt; struct is_nothrow_callable; <span class='comment'>// not defined
</span>  template &lt;class Fn, class... ArgTypes, class R&gt;
    struct is_nothrow_callable&lt;Fn(ArgTypes...), R&gt;;

  <span class='comment'>// <a href='meta.trans.cv'>[meta.trans.cv]</a>, const-volatile modifications
</span>  template &lt;class T&gt; struct remove_const;
  template &lt;class T&gt; struct remove_volatile;
  template &lt;class T&gt; struct remove_cv;
  template &lt;class T&gt; struct add_const;
  template &lt;class T&gt; struct add_volatile;
  template &lt;class T&gt; struct add_cv;

  template &lt;class T&gt;
    using remove_const_t    = typename remove_const&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_volatile_t = typename remove_volatile&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_cv_t       = typename remove_cv&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_const_t       = typename add_const&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_volatile_t    = typename add_volatile&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_cv_t          = typename add_cv&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.ref'>[meta.trans.ref]</a>, reference modifications
</span>  template &lt;class T&gt; struct remove_reference;
  template &lt;class T&gt; struct add_lvalue_reference;
  template &lt;class T&gt; struct add_rvalue_reference;

  template &lt;class T&gt;
    using remove_reference_t     = typename remove_reference&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_lvalue_reference_t = typename add_lvalue_reference&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_rvalue_reference_t = typename add_rvalue_reference&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.sign'>[meta.trans.sign]</a>, sign modifications
</span>  template &lt;class T&gt; struct make_signed;
  template &lt;class T&gt; struct make_unsigned;

  template &lt;class T&gt;
    using make_signed_t   = typename make_signed&lt;T&gt;::type;
  template &lt;class T&gt;
    using make_unsigned_t = typename make_unsigned&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.arr'>[meta.trans.arr]</a>, array modifications
</span>  template &lt;class T&gt; struct remove_extent;
  template &lt;class T&gt; struct remove_all_extents;

  template &lt;class T&gt;
    using remove_extent_t      = typename remove_extent&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_all_extents_t = typename remove_all_extents&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.ptr'>[meta.trans.ptr]</a>, pointer modifications
</span>  template &lt;class T&gt; struct remove_pointer;
  template &lt;class T&gt; struct add_pointer;

  template &lt;class T&gt;
    using remove_pointer_t = typename remove_pointer&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_pointer_t    = typename add_pointer&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.other'>[meta.trans.other]</a>, other transformations
</span>  template &lt;size_t Len,
            size_t Align = <i>default-alignment</i>&gt; <span class='comment'>// see <a href='meta.trans.other'>[meta.trans.other]</a>
</span>    struct aligned_storage;      
  template &lt;size_t Len, class... Types&gt; struct aligned_union;
  template &lt;class T&gt; struct decay;
  template &lt;bool, class T = void&gt; struct enable_if;
  template &lt;bool, class T, class F&gt; struct conditional;
  template &lt;class... T&gt; struct common_type;
  template &lt;class T&gt; struct underlying_type;
  template &lt;class&gt; class result_of;   <span class='comment'>// not defined
</span>  template &lt;class F, class... ArgTypes&gt; class result_of&lt;F(ArgTypes...)&gt;;

  template &lt;size_t Len,
            size_t Align = <i>default-alignment</i>&gt; <span class='comment'>// see <a href='meta.trans.other'>[meta.trans.other]</a>
</span>    using aligned_storage_t = typename aligned_storage&lt;Len, Align&gt;::type;
  template &lt;size_t Len, class... Types&gt;
    using aligned_union_t   = typename aligned_union&lt;Len, Types...&gt;::type;
  template &lt;class T&gt;
    using decay_t           = typename decay&lt;T&gt;::type;
  template &lt;bool b, class T = void&gt;
    using enable_if_t       = typename enable_if&lt;b, T&gt;::type;
  template &lt;bool b, class T, class F&gt;
    using conditional_t     = typename conditional&lt;b, T, F&gt;::type;
  template &lt;class... T&gt;
    using common_type_t     = typename common_type&lt;T...&gt;::type;
  template &lt;class T&gt;
    using underlying_type_t = typename underlying_type&lt;T&gt;::type;
  template &lt;class T&gt;
    using result_of_t       = typename result_of&lt;T&gt;::type;  
  template &lt;class...&gt;
    using void_t            = void;

  <span class='comment'>// <a href='meta.logical'>[meta.logical]</a>, logical operator traits
</span>  template&lt;class... B&gt; struct conjunction;
  template&lt;class... B&gt; struct disjunction;
  template&lt;class B&gt; struct negation;

  <span class='comment'>// <a href='meta.unary.cat'>[meta.unary.cat]</a>, primary type categories
</span>  template &lt;class T&gt; constexpr bool is_void_v
    = is_void&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_null_pointer_v
    = is_null_pointer&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_integral_v
    = is_integral&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_floating_point_v
    = is_floating_point&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_array_v
    = is_array&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_pointer_v
    = is_pointer&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_lvalue_reference_v
    = is_lvalue_reference&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_rvalue_reference_v
    = is_rvalue_reference&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_member_object_pointer_v
    = is_member_object_pointer&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_member_function_pointer_v
    = is_member_function_pointer&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_enum_v
    = is_enum&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_union_v
    = is_union&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_class_v
    = is_class&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_function_v
    = is_function&lt;T&gt;::value;

  <span class='comment'>// <a href='meta.unary.comp'>[meta.unary.comp]</a>, composite type categories
</span>  template &lt;class T&gt; constexpr bool is_reference_v
    = is_reference&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_arithmetic_v
    = is_arithmetic&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_fundamental_v
    = is_fundamental&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_object_v
    = is_object&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_scalar_v
    = is_scalar&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_compound_v
    = is_compound&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_member_pointer_v
    = is_member_pointer&lt;T&gt;::value;

  <span class='comment'>// <a href='meta.unary.prop'>[meta.unary.prop]</a>, type properties
</span>  template &lt;class T&gt; constexpr bool is_const_v
    = is_const&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_volatile_v
    = is_volatile&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivial_v
    = is_trivial&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivially_copyable_v
    = is_trivially_copyable&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_standard_layout_v
    = is_standard_layout&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_pod_v
    = is_pod&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_empty_v
    = is_empty&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_polymorphic_v
    = is_polymorphic&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_abstract_v
    = is_abstract&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_final_v
    = is_final&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_signed_v
    = is_signed&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_unsigned_v
    = is_unsigned&lt;T&gt;::value;
  template &lt;class T, class... Args&gt; constexpr bool is_constructible_v
    = is_constructible&lt;T, Args...&gt;::value;
  template &lt;class T&gt; constexpr bool is_default_constructible_v
    = is_default_constructible&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_copy_constructible_v
    = is_copy_constructible&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_move_constructible_v
    = is_move_constructible&lt;T&gt;::value;
  template &lt;class T, class U&gt; constexpr bool is_assignable_v
    = is_assignable&lt;T, U&gt;::value;
  template &lt;class T&gt; constexpr bool is_copy_assignable_v
    = is_copy_assignable&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_move_assignable_v
    = is_move_assignable&lt;T&gt;::value;
  template &lt;class T, class U&gt; constexpr bool is_swappable_with_v
    = is_swappable_with&lt;T, U&gt;::value;
  template &lt;class T&gt; constexpr bool is_swappable_v
    = is_swappable&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_destructible_v
    = is_destructible&lt;T&gt;::value;
  template &lt;class T, class... Args&gt; constexpr bool is_trivially_constructible_v
    = is_trivially_constructible&lt;T, Args...&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivially_default_constructible_v
    = is_trivially_default_constructible&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivially_copy_constructible_v
    = is_trivially_copy_constructible&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivially_move_constructible_v
    = is_trivially_move_constructible&lt;T&gt;::value;
  template &lt;class T, class U&gt; constexpr bool is_trivially_assignable_v
    = is_trivially_assignable&lt;T, U&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivially_copy_assignable_v
    = is_trivially_copy_assignable&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivially_move_assignable_v
    = is_trivially_move_assignable&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_trivially_destructible_v
    = is_trivially_destructible&lt;T&gt;::value;
  template &lt;class T, class... Args&gt; constexpr bool is_nothrow_constructible_v
    = is_nothrow_constructible&lt;T, Args...&gt;::value;
  template &lt;class T&gt; constexpr bool is_nothrow_default_constructible_v
    = is_nothrow_default_constructible&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_nothrow_copy_constructible_v
    = is_nothrow_copy_constructible&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_nothrow_move_constructible_v
    = is_nothrow_move_constructible&lt;T&gt;::value;
  template &lt;class T, class U&gt; constexpr bool is_nothrow_assignable_v
    = is_nothrow_assignable&lt;T, U&gt;::value;
  template &lt;class T&gt; constexpr bool is_nothrow_copy_assignable_v
    = is_nothrow_copy_assignable&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_nothrow_move_assignable_v
    = is_nothrow_move_assignable&lt;T&gt;::value;
  template &lt;class T, class U&gt; constexpr bool is_nothrow_swappable_with_v
    = is_nothrow_swappable_with&lt;T, U&gt;::value;
  template &lt;class T&gt; constexpr bool is_nothrow_swappable_v
    = is_nothrow_swappable&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool is_nothrow_destructible_v
    = is_nothrow_destructible&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool has_virtual_destructor_v
    = has_virtual_destructor&lt;T&gt;::value;
  template &lt;class T&gt; constexpr bool has_unique_object_representations_v
    = has_unique_object_representations&lt;T&gt;::value;

  <span class='comment'>// <a href='meta.unary.prop.query'>[meta.unary.prop.query]</a>, type property queries
</span>  template &lt;class T&gt; constexpr size_t alignment_of_v
    = alignment_of&lt;T&gt;::value;
  template &lt;class T&gt; constexpr size_t rank_v
    = rank&lt;T&gt;::value;
  template &lt;class T, unsigned I = 0&gt; constexpr size_t extent_v
    = extent&lt;T, I&gt;::value;

  <span class='comment'>// <a href='meta.rel'>[meta.rel]</a>, type relations
</span>  template &lt;class T, class U&gt; constexpr bool is_same_v
    = is_same&lt;T, U&gt;::value;
  template &lt;class Base, class Derived&gt; constexpr bool is_base_of_v
    = is_base_of&lt;Base, Derived&gt;::value;
  template &lt;class From, class To&gt; constexpr bool is_convertible_v
    = is_convertible&lt;From, To&gt;::value;
  template &lt;class T, class R = void&gt; constexpr bool is_callable_v
    = is_callable&lt;T, R&gt;::value;
  template &lt;class T, class R = void&gt; constexpr bool is_nothrow_callable_v
    = is_nothrow_callable&lt;T, R&gt;::value;

  <span class='comment'>// <a href='meta.logical'>[meta.logical]</a>, logical operator traits
</span>  template&lt;class... B&gt; constexpr bool conjunction_v = conjunction&lt;B...&gt;::value;
  template&lt;class... B&gt; constexpr bool disjunction_v = disjunction&lt;B...&gt;::value;
  template&lt;class B&gt; constexpr bool negation_v = negation&lt;B&gt;::value;
}
</pre><div class='para' id='type.synop-1'><div class='marginalizedparent'><a class='marginalized' href='#type.synop-1'>1</a></div><p >The behavior of a program that adds specializations for any of
the templates defined in this subclause is undefined unless otherwise specified.</p></div><div class='para' id='type.synop-2'><div class='marginalizedparent'><a class='marginalized' href='#type.synop-2'>2</a></div><p >Unless otherwise specified, an incomplete type may be used
to instantiate a template in this subclause.</p></div></div><div id='help'><h3 ><a class='secnum' href='#help' style='min-width:103pt'>20.15.3</a> Helper classes <a class='abbr_ref' href='meta.help'>[meta.help]</a></h3><pre class='codeblock'>
namespace std {
  template &lt;class T, T v&gt;
  struct integral_constant {
    static constexpr T value = v;
    using value_type = T;
    using type       = integral_constant&lt;T, v&gt;;
    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
  };
}
</pre><p ><span class='indexparent'><a class='index' id='integral_constant'></a></span><span class='indexparent'><a class='index' id='bool_constant'></a></span><span class='indexparent'><a class='index' id='true_type'></a></span><span class='indexparent'><a class='index' id='false_type'></a></span></p><div class='para' id='help-1'><div class='marginalizedparent'><a class='marginalized' href='#help-1'>1</a></div><p >The class template <span class='texttt'>integral_constant</span>,
alias template <span class='texttt'>bool_constant</span>, and
its associated <i ><a href='dcl.typedef#nt:typedef-name'>typedef-names</a></i>
<span class='texttt'>true_type</span> and <span class='texttt'>false_type</span>
are used as base classes to define
the interface for various type traits.</p></div></div><div id='unary'><h3 ><a class='secnum' href='#unary' style='min-width:103pt'>20.15.4</a> Unary type traits <a class='abbr_ref' href='meta.unary'>[meta.unary]</a></h3><div class='para' id='unary-1'><div class='marginalizedparent'><a class='marginalized' href='#unary-1'>1</a></div><p >This subclause contains templates that may be used to query the
properties of a type at compile time.</p></div><div class='para' id='unary-2'><div class='marginalizedparent'><a class='marginalized' href='#unary-2'>2</a></div><p >Each of these templates shall be a
<span class='texttt'>UnaryTypeTrait</span> (<a href='meta.rqmts'>[meta.rqmts]</a>)
with a base characteristic of
<span class='texttt'>true_type</span> if the corresponding condition is <span class='texttt'>true</span>, otherwise
<span class='texttt'>false_type</span>.</p></div><div id='unary.cat'><h4 ><a class='secnum' href='#unary.cat' style='min-width:118pt'>20.15.4.1</a> Primary type categories <a class='abbr_ref' href='meta.unary.cat'>[meta.unary.cat]</a></h4><div class='para' id='unary.cat-1'><div class='marginalizedparent'><a class='marginalized' href='#unary.cat-1'>1</a></div><p >The primary type categories correspond to the descriptions given in
section <a href='basic.types'>[basic.types]</a> of the C++ standard.</p></div><div class='para' id='unary.cat-2'><div class='marginalizedparent'><a class='marginalized' href='#unary.cat-2'>2</a></div><p >For any given type <span class='texttt'>T</span>, the result of applying one of these templates to
<span class='texttt'>T</span> and to <i>cv</i> <span class='texttt'>T</span> shall yield the same result.</p></div><div class='para' id='unary.cat-3'><div class='marginalizedparent'><a class='marginalized' href='#unary.cat-3'>3</a></div><p >[&nbsp;<i>Note:</i>
For any given type <span class='texttt'>T</span>, exactly one of the primary type categories
has a <span class='texttt'>value</span> member that evaluates to <span class='texttt'>true</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><div class='numberedTable' id='tab:type-traits.primary'>Table <a href='#tab:type-traits.primary'>40</a> — Primary type category predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 

<span class='indexparent'><a class='index' id='is_void'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_void;</span>                </td><td class='left'>
<span class='texttt'>T</span> is <span class='texttt'>void</span>       </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_null_pointer'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_null_pointer;</span>                </td><td class='left'>
<span class='texttt'>T</span> is <span class='texttt'>nullptr_t</span> (<a href='basic.fundamental'>[basic.fundamental]</a>)       </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_integral'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_integral;</span>        </td><td class='left'>
<span class='texttt'>T</span> is an integral type (<a href='basic.fundamental'>[basic.fundamental]</a>)                 </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_floating_point'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_floating_point;</span>  </td><td class='left'>
<span class='texttt'>T</span> is a floating-point type (<a href='basic.fundamental'>[basic.fundamental]</a>)            </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_array'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_array;</span>           </td><td class='left'>
<span class='texttt'>T</span> is an array type (<a href='basic.compound'>[basic.compound]</a>) of known or unknown extent    </td><td class='left'>
Class template <span class='texttt'>array</span> (<a href='array'>[array]</a>)
is not an array type.                   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_pointer'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_pointer;</span>         </td><td class='left'>
<span class='texttt'>T</span> is a pointer type (<a href='basic.compound'>[basic.compound]</a>)                      </td><td class='left'>
Includes pointers to functions
but not pointers to non-static members.                        </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_lvalue_reference'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_lvalue_reference;</span>    </td><td class='left'>
 <span class='texttt'>T</span> is an lvalue reference type (<a href='dcl.ref'>[dcl.ref]</a>)   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_rvalue_reference'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_rvalue_reference;</span>    </td><td class='left'>
 <span class='texttt'>T</span> is an rvalue reference type (<a href='dcl.ref'>[dcl.ref]</a>)   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_member_object_pointer'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_member_object_pointer;</span></td><td class='left'>
 <span class='texttt'>T</span> is a pointer to non-static data member                              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_member_function_pointer'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_member_function_pointer;</span></td><td class='left'>
<span class='texttt'>T</span> is a pointer to non-static member function                           </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_enum'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_enum;</span>            </td><td class='left'>
<span class='texttt'>T</span> is an enumeration type (<a href='basic.compound'>[basic.compound]</a>)                 </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_union'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_union;</span>           </td><td class='left'>
<span class='texttt'>T</span> is a union type (<a href='basic.compound'>[basic.compound]</a>)                        </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_class'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_class;</span>           </td><td class='left'>
<span class='texttt'>T</span> is a non-union class type (<a href='basic.compound'>[basic.compound]</a>) </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_function'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_function;</span>        </td><td class='left'>
<span class='texttt'>T</span> is a function type (<a href='basic.compound'>[basic.compound]</a>)                     </td><td class='left'>   </td></tr></table></div></div></div><div id='unary.comp'><h4 ><a class='secnum' href='#unary.comp' style='min-width:118pt'>20.15.4.2</a> Composite type traits <a class='abbr_ref' href='meta.unary.comp'>[meta.unary.comp]</a></h4><div class='para' id='unary.comp-1'><div class='marginalizedparent'><a class='marginalized' href='#unary.comp-1'>1</a></div><p >These templates provide convenient compositions of the primary type
categories, corresponding to the descriptions given in section <a href='basic.types'>[basic.types]</a>.</p></div><div class='para' id='unary.comp-2'><div class='marginalizedparent'><a class='marginalized' href='#unary.comp-2'>2</a></div><p >For any given type <span class='texttt'>T</span>, the result of applying one of these templates to
<span class='texttt'>T</span> and to <i>cv</i> <span class='texttt'>T</span> shall yield the same result.</p><div class='numberedTable' id='tab:type-traits.composite'>Table <a href='#tab:type-traits.composite'>41</a> — Composite type category predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 

<span class='indexparent'><a class='index' id='is_reference'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_reference;</span>   </td><td class='left'>
 <span class='texttt'>T</span> is an lvalue reference or an rvalue reference </td><td class='left'>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_arithmetic'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_arithmetic;</span>          </td><td class='left'>
 <span class='texttt'>T</span> is an arithmetic type (<a href='basic.fundamental'>[basic.fundamental]</a>)              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_fundamental'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_fundamental;</span>         </td><td class='left'>
 <span class='texttt'>T</span> is a fundamental type (<a href='basic.fundamental'>[basic.fundamental]</a>)              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_object'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_object;</span>              </td><td class='left'>
 <span class='texttt'>T</span> is an object type (<a href='basic.types'>[basic.types]</a>)                            </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_scalar'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_scalar;</span>              </td><td class='left'>
 <span class='texttt'>T</span> is a scalar type (<a href='basic.types'>[basic.types]</a>)                         </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_compound'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_compound;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is a compound type (<a href='basic.compound'>[basic.compound]</a>)                        </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_member_pointer'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_member_pointer;</span>      </td><td class='left'>
 <span class='texttt'>T</span> is a pointer to non-static data member
 or non-static member function             </td><td class='left'>   </td></tr></table></div></div></div><div id='unary.prop'><h4 ><a class='secnum' href='#unary.prop' style='min-width:118pt'>20.15.4.3</a> Type properties <a class='abbr_ref' href='meta.unary.prop'>[meta.unary.prop]</a></h4><div class='para' id='unary.prop-1'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-1'>1</a></div><p >These templates provide access to some of the more important
properties of types.</p></div><div class='para' id='unary.prop-2'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-2'>2</a></div><p >It is unspecified whether the library defines any full or partial
specializations of any of these templates.</p></div><div class='para' id='unary.prop-3'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-3'>3</a></div><p >For all of the class templates <span class='texttt'>X</span> declared in this subclause,
instantiating that template with a template-argument that is a class
template specialization may result in the implicit instantiation of
the template argument if and only if the semantics of <span class='texttt'>X</span> require that
the argument must be a complete type.</p></div><div class='para' id='unary.prop-4'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-4'>4</a></div><p >For the purpose of defining the templates in this subclause,
a function call expression <span class='texttt'>declval&lt;T&gt;()</span> for any type <span class='texttt'>T</span>
is considered to be a trivial (<a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>) function call
that is not an odr-use (<a href='basic.def.odr'>[basic.def.odr]</a>) of <span class='texttt'>declval</span>
in the context of the corresponding definition
notwithstanding the restrictions of <a href='declval'>[declval]</a>.</p><div class='numberedTable' id='tab:type-traits.properties'>Table <a href='#tab:type-traits.properties'>42</a> — Type property predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Preconditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_const'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_const;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is const-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>)                  </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_volatile'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_volatile;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is volatile-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>)                   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='is_trivial'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivial;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a trivial type (<a href='basic.types'>[basic.types]</a>)     </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete
 type or <i>cv</i> <span class='texttt'>void</span>.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_copyable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_copyable;</span>      </td><td class='left'>
 <span class='texttt'>T</span> is a trivially copyable type (<a href='basic.types'>[basic.types]</a>) </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete type or
 <i>cv</i> <span class='texttt'>void</span>.                               </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_standard_layout'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_standard_layout;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a standard-layout type (<a href='basic.types'>[basic.types]</a>)   </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete
 type or <i>cv</i> <span class='texttt'>void</span>.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_pod'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_pod;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a POD type (<a href='basic.types'>[basic.types]</a>)                                </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete
 type or <i>cv</i> <span class='texttt'>void</span>.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_empty,class'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_empty;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is a class type, but not a union type, with no non-static data
 members other than bit-fields of length 0, no virtual member functions,
 no virtual base classes, and no base class <span class='texttt'>B</span> for
 which <span class='texttt'>is_empty_v&lt;B&gt;</span> is <span class='texttt'>false</span>. </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                               </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_polymorphic'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_polymorphic;</span>         </td><td class='left'>
 <span class='texttt'>T</span> is a polymorphic class (<a href='class.virtual'>[class.virtual]</a>)                             </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_abstract'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_abstract;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is an abstract class (<a href='class.abstract'>[class.abstract]</a>)                              </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_final'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_final;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is a class type marked with the <span class='grammarterm'>class-virt-specifier</span>
 <span class='texttt'>final</span> (Clause <a href='class'>[class]</a>). [&nbsp;<i>Note:</i> A union is a class type that
 can be marked with <span class='texttt'>final</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]                                        </td><td class='left'>
 If <span class='texttt'>T</span> is a class type, <span class='texttt'>T</span> shall be a complete type.                          </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_signed,class'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_signed;</span>              </td><td class='left'>
  If <span class='texttt'>is_arithmetic_v&lt;T&gt;</span> is <span class='texttt'>true</span>, the same result as
  <span class='texttt'>T(-1) &lt; T(0)</span>;
  otherwise, <span class='texttt'>false</span>   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'>  <span class='indexparent'><a class='index' id='is_unsigned'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_unsigned;</span>            </td><td class='left'>
  If <span class='texttt'>is_arithmetic_v&lt;T&gt;</span> is <span class='texttt'>true</span>, the same result as
  <span class='texttt'>T(0) &lt; T(-1)</span>;
  otherwise, <span class='texttt'>false</span>   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'>  <span class='indexparent'><a class='index' id='is_constructible'></a></span><span class='texttt'>template &lt;class T, class... Args&gt;</span><br/>
 <span class='texttt'>struct is_constructible;</span>   </td><td class='left'>
 For a function type <span class='texttt'>T</span> or
 for a <i>cv</i> <span class='texttt'>void</span> type <span class='texttt'>T</span>,
 <span class='texttt'>is_constructible_v&lt;T, Args...&gt;</span> is <span class='texttt'>false</span>,
 otherwise <i><span class='texttt'>see below</span></i>                </td><td class='left'>
 <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span>
 shall be complete types, <i>cv</i> <span class='texttt'>void</span>,
 or arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_default_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_default_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible_v&lt;T&gt;</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, <i>cv</i> <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_copy_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_copy_constructible;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span> (<a href='defns.referenceable'>[defns.referenceable]</a>), the same result as
  <span class='texttt'>is_constructible_v&lt;T, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, <i>cv</i> <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_move_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_move_constructible;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_constructible_v&lt;T, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, <i>cv</i> <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_assignable'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_assignable;</span> </td><td class='left'>
  The expression <span class='texttt'>declval&lt;T&gt;() =</span> <span class='texttt'>declval&lt;U&gt;()</span> is well-formed
  when treated as an unevaluated
  operand (Clause <a href='expr'>[expr]</a>). Access checking is performed as if in a context
  unrelated to <span class='texttt'>T</span> and <span class='texttt'>U</span>. Only the validity of the immediate context
  of the assignment expression is considered. [&nbsp;<i>Note:</i> The compilation of the
  expression can result in side effects such as the instantiation of class template
  specializations and function template specializations, the generation of
  implicitly-defined functions, and so on. Such side effects are not in the “immediate
  context” and can result in the program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, <i>cv</i> <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_copy_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_copy_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_assignable_v&lt;T&amp;, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, <i>cv</i> <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_move_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_move_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_assignable_v&lt;T&amp;, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, <i>cv</i> <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_swappable_with'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_swappable_with;</span> </td><td class='left'>
  The expressions <span class='texttt'>swap(declval&lt;T&gt;(), declval&lt;U&gt;())</span> and
  <span class='texttt'>swap(declval&lt;U&gt;(), declval&lt;T&gt;())</span> are each well-formed
  when treated as an unevaluated operand (Clause <a href='expr'>[expr]</a>)
  in an overload-resolution context
  for swappable values (<a href='swappable.requirements'>[swappable.requirements]</a>).
  Access checking is performed as if in a context
  unrelated to <span class='texttt'>T</span> and <span class='texttt'>U</span>.
  Only the validity of the immediate context
  of the <span class='texttt'>swap</span> expressions is considered.
  [&nbsp;<i>Note:</i>
  The compilation of the expressions can result in side effects
  such as the instantiation of class template specializations and
  function template specializations,
  the generation of implicitly-defined functions, and so on.
  Such side effects are not in the “immediate context” and
  can result in the program being ill-formed.
  <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types,
  <i>cv</i> <span class='texttt'>void</span>, or
  arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_swappable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_swappable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>,
  the same result as <span class='texttt'>is_swappable_with_v&lt;T&amp;, T&amp;&gt;</span>,
  otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  <i>cv</i> <span class='texttt'>void</span>, or
  an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_destructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_destructible;</span> </td><td class='left'>
  Either <span class='texttt'>T</span> is a reference type,
  or <span class='texttt'>T</span> is a complete object type
  for which the expression
  <span class='texttt'>declval&lt;U&amp;&gt;().~U()</span>
  is well-formed
  when treated as an unevaluated operand (Clause <a href='expr'>[expr]</a>),
  where <span class='texttt'>U</span> is
  <span class='texttt'>remove_all_extents&lt;T&gt;</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, <i>cv</i> <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_constructible'></a></span><span class='texttt'>template &lt;class T, class... Args&gt;</span><br/>
  <span class='texttt'>struct</span><br/>
  <span class='texttt'>is_trivially_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible_v&lt;T,</span><br/>
  <span class='texttt'>Args...&gt;</span> is <span class='texttt'>true</span> and the variable
  definition for <span class='texttt'>is_constructible</span>, as defined below, is known to call
  no operation that is not trivial ( <a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span> shall be complete types,
  <i>cv</i> <span class='texttt'>void</span>, or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_default_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_default_constructible;</span> </td><td class='left'>
 <span class='texttt'>is_trivially_constructible_v&lt;T&gt;</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <i>cv</i> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_copy_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_copy_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_constructible_v&lt;T, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
 <i>cv</i> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_move_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_move_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_constructible_v&lt;T, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
 <i>cv</i> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_assignable'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_trivially_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable_v&lt;T, U&gt;</span> is <span class='texttt'>true</span> and the assignment, as defined by
  <span class='texttt'>is_assignable</span>, is known to call no operation that is not trivial
  (<a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, <i>cv</i> <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_copy_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_copy_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_assignable_v&lt;T&amp;, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <i>cv</i> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_move_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_move_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_assignable_v&lt;T&amp;, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <i>cv</i> <span class='texttt'>void</span>, or an array of unknown bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_trivially_destructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_destructible;</span> </td><td class='left'>
 <span class='texttt'>is_destructible_v&lt;T&gt;</span> is <span class='texttt'>true</span> and the indicated destructor is known
 to be trivial. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <i>cv</i> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_constructible'></a></span><span class='texttt'>template &lt;class T, class... Args&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_constructible;</span>   </td><td class='left'>
 <span class='texttt'>is_constructible_v&lt;T,</span> <span class='texttt'> Args...&gt;</span> is <span class='texttt'>true</span>
 and the
 variable definition for <span class='texttt'>is_constructible</span>, as defined below, is known not to
 throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>).
 </td><td class='left'>
 <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span>
 shall be complete types, <i>cv</i> <span class='texttt'>void</span>,
 or arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_default_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_default_constructible;</span> </td><td class='left'>
 <span class='texttt'>is_nothrow_constructible_v&lt;T&gt;</span> is <span class='texttt'>true</span>.  </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <i>cv</i> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_copy_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_copy_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_nothrow_constructible_v&lt;T, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <i>cv</i> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_move_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_move_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_nothrow_constructible_v&lt;T, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <i>cv</i> <span class='texttt'>void</span>, or an array of unknown bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_assignable'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_nothrow_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable_v&lt;T, U&gt;</span> is <span class='texttt'>true</span> and the assignment is known not to
  throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, <i>cv</i> <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_copy_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_copy_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_nothrow_assignable_v&lt;T&amp;, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <i>cv</i> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_move_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_nothrow_move_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_nothrow_assignable_v&lt;T&amp;, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <i>cv</i> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_swappable_with'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_nothrow_swappable_with;</span> </td><td class='left'>
  <span class='texttt'>is_swappable_with_v&lt;T, U&gt;</span> is <span class='texttt'>true</span> and
  each <span class='texttt'>swap</span> expression of the definition of
  <span class='texttt'>is_swappable_with&lt;T, U&gt;</span> is known not to throw
  any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types,
  <i>cv</i> <span class='texttt'>void</span>, or
  arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_swappable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_nothrow_swappable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>,
  the same result as <span class='texttt'>is_nothrow_swappable_with_v&lt;T&amp;, T&amp;&gt;</span>,
  otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  <i>cv</i> <span class='texttt'>void</span>, or
  an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_destructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_nothrow_destructible;</span> </td><td class='left'>
  <span class='texttt'>is_destructible_v&lt;T&gt;</span> is <span class='texttt'>true</span> and the indicated destructor is known
  not to throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  <i>cv</i> <span class='texttt'>void</span>, or an array of unknown
  bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='has_virtual_destructor'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct has_virtual_destructor;</span> </td><td class='left'>
 <span class='texttt'>T</span> has a virtual destructor (<a href='class.dtor'>[class.dtor]</a>) </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='has_unique_object_representations'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct has_unique_object_representations;</span> </td><td class='left'>
  For an array type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>has_unique_object_representations_v&lt;remove_all_extents_t&lt;T&gt;&gt;</span>,
  otherwise <i><span class='texttt'>see below</span></i>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, <i>cv</i> <span class='texttt'>void</span>, or
  an array of unknown bound. </td></tr></table></div></div><div class='para' id='unary.prop-5'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-5'>5</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
is_const_v&lt;const volatile int&gt;     <span class='comment'>// <span class='texttt'>true</span>
</span>is_const_v&lt;const int*&gt;             <span class='comment'>// <span class='texttt'>false</span>
</span>is_const_v&lt;const int&amp;&gt;             <span class='comment'>// <span class='texttt'>false</span>
</span>is_const_v&lt;int[3]&gt;                 <span class='comment'>// <span class='texttt'>false</span>
</span>is_const_v&lt;const int[3]&gt;           <span class='comment'>// <span class='texttt'>true</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='unary.prop-6'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-6'>6</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
remove_const_t&lt;const volatile int&gt;  <span class='comment'>// <span class='texttt'>volatile int</span>
</span>remove_const_t&lt;const int* const&gt;    <span class='comment'>// <span class='texttt'>const int*</span>
</span>remove_const_t&lt;const int&amp;&gt;          <span class='comment'>// <span class='texttt'>const int&amp;</span>
</span>remove_const_t&lt;const int[3]&gt;        <span class='comment'>// <span class='texttt'>int[3]</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='unary.prop-7'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-7'>7</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// Given:
</span>struct P final { };
union U1 { };
union U2 final { };

<span class='comment'>// the following assertions hold:
</span>static_assert(!is_final_v&lt;int&gt;, "Error!");
static_assert( is_final_v&lt;P&gt;,  "Error!");
static_assert(!is_final_v&lt;U1&gt;, "Error!");
static_assert( is_final_v&lt;U2&gt;, "Error!");
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='is_constructible'></a></span></p></div><div class='para' id='unary.prop-8'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-8'>8</a></div><p >The predicate condition for a template specialization
<span class='texttt'>is_constructible&lt;T, Args...&gt;</span> shall be satisfied if and only if the
following variable definition would be well-formed for some invented variable <span class='texttt'>t</span>:</p><pre class='codeblock'>
T t(declval&lt;Args&gt;()...);
</pre><p >[&nbsp;<i>Note:</i> These tokens are never interpreted as a function declaration.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] Access checking is performed as if in a context unrelated to <span class='texttt'>T</span>
and any of the <span class='texttt'>Args</span>. Only the validity of the immediate context of the
variable initialization is considered. [&nbsp;<i>Note:</i> The evaluation of the
initialization can result in side effects such as the instantiation of class
template specializations and function template specializations, the generation
of implicitly-defined functions, and so on. Such side effects are not in the
“immediate context” and can result in the program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='has_unique_object_representations'></a></span></p></div><div class='para' id='unary.prop-9'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-9'>9</a></div><p >The predicate condition for a template specialization
<span class='texttt'>has_unique_object_representations&lt;T&gt;</span>
shall be satisfied if and only if:
</p><ul class='itemize'><li id='unary.prop-9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unary.prop-9.1'>(9.1)</a></div><p ><span class='texttt'>T</span> is trivially copyable, and
</p></li><li id='unary.prop-9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unary.prop-9.2'>(9.2)</a></div><p >any two objects of type <span class='texttt'>T</span> with the same value
have the same object representation, where
two objects of array or non-union class type are considered to have the same value
if their respective sequences of direct subobjects have the same values, and
two objects of union type are considered to have the same value
if they have the same active member and the corresponding members have the same value.
</p></li></ul><p >The set of scalar types for which this condition holds is
<span class='indexparent'><a class='index' id='which_scalar_types_have_unique_object_representations'></a></span>implementation-defined.
[&nbsp;<i>Note:</i> If a type has padding bits, the condition does not hold;
otherwise, the condition holds true for unsigned integral types. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='unary.prop.query'><h3 ><a class='secnum' href='#unary.prop.query' style='min-width:103pt'>20.15.5</a> Type property queries <a class='abbr_ref' href='meta.unary.prop.query'>[meta.unary.prop.query]</a></h3><div class='para' id='unary.prop.query-1'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop.query-1'>1</a></div><p >This subclause contains templates that may be used to query
properties of types at compile time.</p><div class='numberedTable' id='tab:type-traits.properties.queries'>Table <a href='#tab:type-traits.properties.queries'>43</a> — Type property queries<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 
<span class='indexparent'><a class='index' id='alignment_of'></a></span><span class='texttt'>template &lt;class T&gt;<br/>
 struct alignment_of;</span>      </td><td class='left'>
 <span class='texttt'>alignof(T)</span>.<br/>
 <i>Requires:</i>
 <span class='texttt'>alignof(T)</span> shall be a valid expression (<a href='expr.alignof'>[expr.alignof]</a>)  </td></tr><tr class='rowsep'><td class='left'>  <span class='indexparent'><a class='index' id='rank'></a></span><span class='texttt'>template &lt;class T&gt;<br/>
 struct rank;</span>      </td><td class='left'>
 If <span class='texttt'>T</span> names an array type, an integer value representing
 the number of dimensions of <span class='texttt'>T</span>; otherwise, 0. </td></tr><tr class='rowsep'><td class='left'>    <span class='indexparent'><a class='index' id='extent'></a></span><span class='texttt'>template &lt;class T,<br/>
 unsigned I = 0&gt;<br/>
 struct extent;</span>        </td><td class='left'>
 If <span class='texttt'>T</span> is not an array type, or if it has rank less
 than or equal to <span class='texttt'>I</span>, or if <span class='texttt'>I</span> is 0 and <span class='texttt'>T</span>
 has type “array of unknown bound of <span class='texttt'>U</span>”, then
 0; otherwise, the bound (<a href='dcl.array'>[dcl.array]</a>) of the <span class='texttt'>I</span>'th dimension of
<span class='texttt'>T</span>, where indexing of <span class='texttt'>I</span> is zero-based </td></tr></table></div></div><div class='para' id='unary.prop.query-2'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop.query-2'>2</a></div><p >Each of these templates shall be a <span class='texttt'>UnaryTypeTrait</span> (<a href='meta.rqmts'>[meta.rqmts]</a>) with a
base characteristic of <span class='texttt'>integral_constant&lt;size_t, Value&gt;</span>.</p></div><div class='para' id='unary.prop.query-3'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop.query-3'>3</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// the following assertions hold:
</span>assert(rank_v&lt;int&gt; == 0);
assert(rank_v&lt;int[2]&gt; == 1);
assert(rank_v&lt;int[][4]&gt; == 2);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='unary.prop.query-4'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop.query-4'>4</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// the following assertions hold:
</span>assert(extent_v&lt;int&gt; == 0);
assert(extent_v&lt;int[2]&gt; == 2);
assert(extent_v&lt;int[2][4]&gt; == 2);
assert(extent_v&lt;int[][4]&gt; == 0);
assert((extent_v&lt;int, 1&gt;) == 0);
assert((extent_v&lt;int[2], 1&gt;) == 0);
assert((extent_v&lt;int[2][4], 1&gt;) == 4);
assert((extent_v&lt;int[][4], 1&gt;) == 4);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='rel'><h3 ><a class='secnum' href='#rel' style='min-width:103pt'>20.15.6</a> Relationships between types <a class='abbr_ref' href='meta.rel'>[meta.rel]</a></h3><div class='para' id='rel-1'><div class='marginalizedparent'><a class='marginalized' href='#rel-1'>1</a></div><p >This subclause contains templates that may be used to query
relationships between types at compile time.</p></div><div class='para' id='rel-2'><div class='marginalizedparent'><a class='marginalized' href='#rel-2'>2</a></div><p >Each of these templates shall be a
<span class='texttt'>BinaryTypeTrait</span> (<a href='meta.rqmts'>[meta.rqmts]</a>)
with a base characteristic of
<span class='texttt'>true_type</span> if the corresponding condition is true, otherwise
<span class='texttt'>false_type</span>.</p><div class='numberedTable' id='tab:type-traits.relationship'>Table <a href='#tab:type-traits.relationship'>44</a> — Type relationship predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 

<span class='texttt'>template &lt;class T, class U&gt;</span><br/>
 <span class='texttt'>struct is_same;</span>                    </td><td class='left'>
 <span class='texttt'>T</span> and <span class='texttt'>U</span> name the same type with the same cv-qualifications                            </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_base_of'></a></span><span class='texttt'>template &lt;class Base, class Derived&gt;</span><br/>
 <span class='texttt'>struct is_base_of;</span>                 </td><td class='left'>
 <span class='texttt'>Base</span> is a base class of <span class='texttt'>Derived</span> (Clause <a href='class.derived'>[class.derived]</a>)
 without regard to cv-qualifiers
 or <span class='texttt'>Base</span> and <span class='texttt'>Derived</span> are not unions and
 name the same class type
 without regard to cv-qualifiers            </td><td class='left'>
 If <span class='texttt'>Base</span> and
 <span class='texttt'>Derived</span> are non-union class types and are
not possibly cv-qualified versions of the same type,
 <span class='texttt'>Derived</span> shall be a complete
 type.
 [&nbsp;<i>Note:</i> Base classes that are private, protected, or ambiguous
 are, nonetheless, base classes. <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_convertible'></a></span><span class='texttt'>template &lt;class From, class To&gt;</span><br/>
 <span class='texttt'>struct is_convertible;</span>             </td><td class='left'>
 <i><span class='texttt'>see below</span></i>                                  </td><td class='left'>
 <span class='texttt'>From</span> and <span class='texttt'>To</span> shall be complete
 types, arrays of unknown
 bound, or <i>cv</i> <span class='texttt'>void</span> types.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_callable'></a></span><span class='texttt'>template &lt;class Fn, class... ArgTypes, class R&gt;</span><br/>
 <span class='texttt'>struct is_callable&lt;</span><br/>
 <span class='texttt'>Fn(ArgTypes...), R&gt;;</span>                      </td><td class='left'>
 The expression <span class='texttt'><i>INVOKE</i>(declval&lt;Fn&gt;(), declval&lt;ArgTypes&gt;()..., R)</span>
 is well formed when treated as an unevaluated operand                </td><td class='left'>
 <span class='texttt'>Fn</span>, <span class='texttt'>R</span>, and all types in the parameter pack <span class='texttt'>ArgTypes</span>
 shall be complete types, <i>cv</i> <span class='texttt'>void</span>, or
 arrays of unknown bound.                                             </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='is_nothrow_callable'></a></span><span class='texttt'>template &lt;class Fn, class... ArgTypes, class R&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_callable&lt;</span><br/>
 <span class='texttt'>Fn(ArgTypes...), R&gt;;</span>              </td><td class='left'>
 <span class='texttt'>is_callable_v&lt;</span><br/><span class='texttt'>Fn(ArgTypes...), R&gt;</span> is <span class='texttt'>true</span> and
 the expression <span class='texttt'><i>INVOKE</i>(declval&lt;Fn&gt;(), declval&lt;ArgTypes&gt;()..., R)</span>
 is known not to throw any exceptions                                 </td><td class='left'>
 <span class='texttt'>Fn</span>, <span class='texttt'>R</span>, and all types in the parameter pack <span class='texttt'>ArgTypes</span>
 shall be complete types, <i>cv</i> <span class='texttt'>void</span>, or
 arrays of unknown bound.                                             </td></tr></table></div></div><div class='para' id='rel-3'><div class='marginalizedparent'><a class='marginalized' href='#rel-3'>3</a></div><p >For the purpose of defining the templates in this subclause,
a function call expression <span class='texttt'>declval&lt;T&gt;()</span> for any type <span class='texttt'>T</span>
is considered to be a trivial (<a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>) function call
that is not an odr-use (<a href='basic.def.odr'>[basic.def.odr]</a>) of <span class='texttt'>declval</span>
in the context of the corresponding definition
notwithstanding the restrictions of <a href='declval'>[declval]</a>.</p></div><div class='para' id='rel-4'><div class='marginalizedparent'><a class='marginalized' href='#rel-4'>4</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct B {};
struct B1 : B {};
struct B2 : B {};
struct D : private B1, private B2 {};

is_base_of_v&lt;B, D&gt;         <span class='comment'>// <span class='texttt'>true</span>
</span>is_base_of_v&lt;const B, D&gt;   <span class='comment'>// <span class='texttt'>true</span>
</span>is_base_of_v&lt;B, const D&gt;   <span class='comment'>// <span class='texttt'>true</span>
</span>is_base_of_v&lt;B, const B&gt;   <span class='comment'>// <span class='texttt'>true</span>
</span>is_base_of_v&lt;D, B&gt;         <span class='comment'>// <span class='texttt'>false</span>
</span>is_base_of_v&lt;B&amp;, D&amp;&gt;       <span class='comment'>// <span class='texttt'>false</span>
</span>is_base_of_v&lt;B[3], D[3]&gt;   <span class='comment'>// <span class='texttt'>false</span>
</span>is_base_of_v&lt;int, int&gt;     <span class='comment'>// <span class='texttt'>false</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='is_convertible'></a></span></p></div><div class='para' id='rel-5'><div class='marginalizedparent'><a class='marginalized' href='#rel-5'>5</a></div><p >The predicate condition for a template specialization <span class='texttt'>is_convertible&lt;From, To&gt;</span>
shall be satisfied if and only if the return expression in the following code would be
well-formed, including any implicit conversions to the return type of the function:</p><pre class='codeblock'>
To test() {
  return declval&lt;From&gt;();
}
</pre><p >[&nbsp;<i>Note:</i> This requirement gives well defined results for reference types, void
types, array types, and function types.<i>&nbsp;—&nbsp;end note</i>&nbsp;] Access checking is performed as
if in a context unrelated to <span class='texttt'>To</span> and <span class='texttt'>From</span>. Only the validity of
the immediate context of the expression of the <span class='grammarterm'>return-statement</span>
(including conversions to the return type) is considered. [&nbsp;<i>Note:</i> The
evaluation of the conversion can result in side effects such as the
instantiation of class template specializations and function template
specializations, the generation of implicitly-defined functions, and so on. Such
side effects are not in the “immediate context” and can result in the program
being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='trans'><h3 ><a class='secnum' href='#trans' style='min-width:103pt'>20.15.7</a> Transformations between types <a class='abbr_ref' href='meta.trans'>[meta.trans]</a></h3><div class='para' id='trans-1'><div class='marginalizedparent'><a class='marginalized' href='#trans-1'>1</a></div><p >This subclause contains templates that may be used to transform one
type to another following some predefined rule.</p></div><div class='para' id='trans-2'><div class='marginalizedparent'><a class='marginalized' href='#trans-2'>2</a></div><p >Each of the templates in this subclause shall be a
<span class='texttt'>TransformationTrait</span> (<a href='meta.rqmts'>[meta.rqmts]</a>).</p></div><div id='trans.cv'><h4 ><a class='secnum' href='#trans.cv' style='min-width:118pt'>20.15.7.1</a> Const-volatile modifications <a class='abbr_ref' href='meta.trans.cv'>[meta.trans.cv]</a></h4><div class='numberedTable' id='tab:type-traits.const-volatile'>Table <a href='#tab:type-traits.const-volatile'>45</a> — Const-volatile modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='indexparent'><a class='index' id='remove_const'></a></span><span class='texttt'>template &lt;class T&gt;<br/>
 struct remove_const;</span>                  </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall name
 the same type as <span class='texttt'>T</span>
 except that any top-level const-qualifier has been removed.
 [&nbsp;<i>Example:</i> <span class='texttt'>remove_const_t&lt;const volatile int&gt;</span> evaluates
 to <span class='texttt'>volatile int</span>, whereas <span class='texttt'>remove_const_t&lt;const int*&gt;</span> evaluates to
 <span class='texttt'>const int*</span>. <i>&nbsp;—&nbsp;end example</i>&nbsp;]                          </td></tr><tr class='rowsep'><td class='left'>  <span class='indexparent'><a class='index' id='remove_volatile'></a></span><span class='texttt'>template &lt;class T&gt;<br/>
 struct remove_volatile;</span>               </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall name
 the same type as <span class='texttt'>T</span>
 except that any top-level volatile-qualifier has been removed.
 [&nbsp;<i>Example:</i> <span class='texttt'>remove_volatile_t&lt;const volatile int&gt;</span>
 evaluates to <span class='texttt'>const int</span>,
 whereas <span class='texttt'>remove_volatile_t&lt;volatile int*&gt;</span> evaluates to <span class='texttt'>volatile int*</span>.
 <i>&nbsp;—&nbsp;end example</i>&nbsp;]                                              </td></tr><tr class='rowsep'><td class='left'>  <span class='indexparent'><a class='index' id='remove_cv'></a></span><span class='texttt'>template &lt;class T&gt;<br/>
 struct remove_cv;</span>                 </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall be the same as <span class='texttt'>T</span>
 except that any top-level cv-qualifier has been removed.
 [&nbsp;<i>Example:</i> <span class='texttt'>remove_cv_t&lt;const volatile int&gt;</span>
 evaluates to <span class='texttt'>int</span>, whereas <span class='texttt'>remove_cv_t&lt;const volatile int*&gt;</span>
 evaluates to <span class='texttt'>const volatile int*</span>. <i>&nbsp;—&nbsp;end example</i>&nbsp;]  </td></tr><tr class='rowsep'><td class='left'>  <span class='indexparent'><a class='index' id='add_const'></a></span><span class='texttt'>template &lt;class T&gt;<br/>
 struct add_const;</span>                 </td><td class='left'>
 If <span class='texttt'>T</span> is a reference, function, or top-level const-qualified
 type, then <span class='texttt'>type</span> shall name
 the same type as <span class='texttt'>T</span>, otherwise
 <span class='texttt'>T const</span>.                                                           </td></tr><tr class='rowsep'><td class='left'>  <span class='indexparent'><a class='index' id='add_volatile'></a></span><span class='texttt'>template &lt;class T&gt;<br/>
 struct add_volatile;</span>                  </td><td class='left'>
 If <span class='texttt'>T</span> is a reference, function, or top-level volatile-qualified
 type, then <span class='texttt'>type</span> shall name
 the same type as <span class='texttt'>T</span>, otherwise
 <span class='texttt'>T volatile</span>.                                                            </td></tr><tr class='rowsep'><td class='left'>  <span class='indexparent'><a class='index' id='add_cv'></a></span><span class='texttt'>template &lt;class T&gt;<br/>
 struct add_cv;</span>                    </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall name
 the same type as
 <span class='texttt'>add_const_t&lt;add_volatile_t&lt;T&gt;&gt;</span>.                               </td></tr></table></div></div><div id='trans.ref'><h4 ><a class='secnum' href='#trans.ref' style='min-width:118pt'>20.15.7.2</a> Reference modifications <a class='abbr_ref' href='meta.trans.ref'>[meta.trans.ref]</a></h4><div class='numberedTable' id='tab:type-traits.reference'>Table <a href='#tab:type-traits.reference'>46</a> — Reference modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='indexparent'><a class='index' id='remove_reference'></a></span><span class='texttt'>template &lt;class T&gt;<br/>
 struct remove_reference;</span>                  </td><td class='left'>
 If <span class='texttt'>T</span> has type “reference to <span class='texttt'>T1</span>” then the
 member typedef <span class='texttt'>type</span> shall name <span class='texttt'>T1</span>;
 otherwise, <span class='texttt'>type</span> shall name <span class='texttt'>T</span>.</td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='add_lvalue_reference'></a></span><span class='texttt'>template &lt;class T&gt;<br/>
 struct add_lvalue_reference;</span>                     </td><td class='left'>
 If <span class='texttt'>T</span> names a referenceable type (<a href='defns.referenceable'>[defns.referenceable]</a>) then
 the member typedef <span class='texttt'>type</span> shall name <span class='texttt'>T&amp;</span>;
 otherwise, <span class='texttt'>type</span> shall name <span class='texttt'>T</span>.
 [&nbsp;<i>Note:</i>
 This rule reflects the semantics of reference collapsing (<a href='dcl.ref'>[dcl.ref]</a>).
 <i>&nbsp;—&nbsp;end note</i>&nbsp;]</td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='add_rvalue_reference'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct add_rvalue_reference;</span>    </td><td class='left'>
 If <span class='texttt'>T</span> names a referenceable type then
 the member typedef <span class='texttt'>type</span> shall name <span class='texttt'>T&amp;&amp;</span>;
 otherwise, <span class='texttt'>type</span> shall name <span class='texttt'>T</span>.
 [&nbsp;<i>Note:</i> This rule reflects the semantics of reference collapsing (<a href='dcl.ref'>[dcl.ref]</a>).
 For example, when a type <span class='texttt'>T</span> names a type <span class='texttt'>T1&amp;</span>, the type
 <span class='texttt'>add_rvalue_reference_t&lt;T&gt;</span> is not an rvalue reference.
 <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td></tr></table></div></div><div id='trans.sign'><h4 ><a class='secnum' href='#trans.sign' style='min-width:118pt'>20.15.7.3</a> Sign modifications <a class='abbr_ref' href='meta.trans.sign'>[meta.trans.sign]</a></h4><div class='numberedTable' id='tab:type-traits.sign'>Table <a href='#tab:type-traits.sign'>47</a> — Sign modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='indexparent'><a class='index' id='make_signed'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct make_signed;</span> </td><td class='left'>
 If <span class='texttt'>T</span> names a (possibly cv-qualified) signed integer
 type (<a href='basic.fundamental'>[basic.fundamental]</a>) then the member typedef
 <span class='texttt'>type</span> shall name the type <span class='texttt'>T</span>; otherwise,
 if <span class='texttt'>T</span> names a (possibly cv-qualified) unsigned integer
 type then <span class='texttt'>type</span> shall name the corresponding
 signed integer type, with the same cv-qualifiers as <span class='texttt'>T</span>;
 otherwise, <span class='texttt'>type</span> shall name the signed integer type with smallest
 rank (<a href='conv.rank'>[conv.rank]</a>) for which
 <span class='texttt'>sizeof(T) == sizeof(type)</span>, with the same
 cv-qualifiers as <span class='texttt'>T</span>.<br/>
 <i>Requires:</i> <span class='texttt'>T</span> shall be a (possibly cv-qualified)
 integral type or enumeration
 but not a <span class='texttt'>bool</span> type.</td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='make_unsigned'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct make_unsigned;</span> </td><td class='left'>
 If <span class='texttt'>T</span> names a (possibly cv-qualified) unsigned integer
 type (<a href='basic.fundamental'>[basic.fundamental]</a>) then the member typedef
 <span class='texttt'>type</span> shall name the type <span class='texttt'>T</span>; otherwise,
 if <span class='texttt'>T</span> names a (possibly cv-qualified) signed integer
 type then <span class='texttt'>type</span> shall name the corresponding
 unsigned integer type, with the same cv-qualifiers as <span class='texttt'>T</span>;
 otherwise, <span class='texttt'>type</span> shall name the unsigned integer type with smallest
 rank (<a href='conv.rank'>[conv.rank]</a>) for which
 <span class='texttt'>sizeof(T) == sizeof(type)</span>, with the same
 cv-qualifiers as <span class='texttt'>T</span>.<br/>
 <i>Requires:</i> <span class='texttt'>T</span> shall be a (possibly cv-qualified)
 integral type or enumeration
 but not a <span class='texttt'>bool</span> type.</td></tr></table></div></div><div id='trans.arr'><h4 ><a class='secnum' href='#trans.arr' style='min-width:118pt'>20.15.7.4</a> Array modifications <a class='abbr_ref' href='meta.trans.arr'>[meta.trans.arr]</a></h4><div class='numberedTable' id='tab:type-traits.array'>Table <a href='#tab:type-traits.array'>48</a> — Array modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='indexparent'><a class='index' id='remove_extent'></a></span><span class='texttt'>template &lt;class T&gt;<br/>
 struct remove_extent;</span>                 </td><td class='left'>
 If <span class='texttt'>T</span> names a type “array of <span class='texttt'>U</span>”,
 the member typedef <span class='texttt'>type</span> shall
 be <span class='texttt'>U</span>, otherwise <span class='texttt'>T</span>.
 [&nbsp;<i>Note:</i> For multidimensional arrays, only the first array dimension is
 removed. For a type “array of <span class='texttt'>const U</span>”, the resulting type is
 <span class='texttt'>const U</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]                                 </td></tr><tr class='rowsep'><td class='left'>  <span class='indexparent'><a class='index' id='remove_all_extents'></a></span><span class='texttt'>template &lt;class T&gt;<br/>
 struct remove_all_extents;</span>                </td><td class='left'>
 If <span class='texttt'>T</span> is “multi-dimensional array of <span class='texttt'>U</span>”, the resulting member
 typedef <span class='texttt'>type</span> is <span class='texttt'>U</span>, otherwise <span class='texttt'>T</span>.                                       </td></tr></table></div><div class='para' id='trans.arr-1'><div class='marginalizedparent'><a class='marginalized' href='#trans.arr-1'>1</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// the following assertions hold:
</span>assert((is_same_v&lt;remove_extent_t&lt;int&gt;, int&gt;));
assert((is_same_v&lt;remove_extent_t&lt;int[2]&gt;, int&gt;));
assert((is_same_v&lt;remove_extent_t&lt;int[2][3]&gt;, int[3]&gt;));
assert((is_same_v&lt;remove_extent_t&lt;int[][3]&gt;, int[3]&gt;));
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='trans.arr-2'><div class='marginalizedparent'><a class='marginalized' href='#trans.arr-2'>2</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// the following assertions hold:
</span>assert((is_same_v&lt;remove_all_extents_t&lt;int&gt;, int&gt;));
assert((is_same_v&lt;remove_all_extents_t&lt;int[2]&gt;, int&gt;));
assert((is_same_v&lt;remove_all_extents_t&lt;int[2][3]&gt;, int&gt;));
assert((is_same_v&lt;remove_all_extents_t&lt;int[][3]&gt;, int&gt;));
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='trans.ptr'><h4 ><a class='secnum' href='#trans.ptr' style='min-width:118pt'>20.15.7.5</a> Pointer modifications <a class='abbr_ref' href='meta.trans.ptr'>[meta.trans.ptr]</a></h4><div class='numberedTable' id='tab:type-traits.pointer'>Table <a href='#tab:type-traits.pointer'>49</a> — Pointer modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='indexparent'><a class='index' id='remove_pointer'></a></span><span class='texttt'>template &lt;class T&gt;<br/>
 struct remove_pointer;</span>                    </td><td class='left'>
 If <span class='texttt'>T</span> has type “(possibly cv-qualified) pointer
 to <span class='texttt'>T1</span>” then the member typedef <span class='texttt'>type</span>
 shall name <span class='texttt'>T1</span>; otherwise, it shall name <span class='texttt'>T</span>.</td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='add_pointer'></a></span><span class='texttt'>template &lt;class T&gt;<br/>
 struct add_pointer;</span>                       </td><td class='left'>
 If <span class='texttt'>T</span> names a referenceable type (<a href='defns.referenceable'>[defns.referenceable]</a>) or a
 <i>cv</i> <span class='texttt'>void</span> type then
 the member typedef <span class='texttt'>type</span> shall name the same type as
 <span class='texttt'>remove_reference_t&lt;T&gt;*</span>;
 otherwise, <span class='texttt'>type</span> shall name <span class='texttt'>T</span>.             </td></tr></table></div></div><div id='trans.other'><h4 ><a class='secnum' href='#trans.other' style='min-width:118pt'>20.15.7.6</a> Other transformations <a class='abbr_ref' href='meta.trans.other'>[meta.trans.other]</a></h4><div class='numberedTable' id='tab:type-traits.other'>Table <a href='#tab:type-traits.other'>50</a> — Other transformations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='indexparent'><a class='index' id='aligned_storage'></a></span><span class='texttt'>template &lt;size_t Len,<br/>
 size_t Align<br/>
 = <i>default-alignment</i>&gt;<br/>
 struct aligned_storage;</span>
 </td><td class='left'>
 The value of <i>default-alignment</i> shall be the most
 stringent alignment requirement for any C++ object type whose size
 is no greater than <span class='texttt'>Len</span> (<a href='basic.types'>[basic.types]</a>).
 The member typedef <span class='texttt'>type</span> shall be a POD type
 suitable for use as uninitialized storage for any object whose size
 is at most <i>Len</i> and whose alignment is a divisor of <i>Align</i>.<br/>
 <i>Requires:</i> <span class='texttt'>Len</span> shall not be zero. <span class='texttt'>Align</span> shall be equal to
 <span class='texttt'>alignof(T)</span> for some type <span class='texttt'>T</span> or to <i>default-alignment</i>.</td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='aligned_union'></a></span><span class='texttt'>template &lt;size_t Len,<br/>
  class... Types&gt;<br/>
  struct aligned_union;</span>
  </td><td class='left'>
  The member typedef <span class='texttt'>type</span> shall be a POD type suitable for use as
  uninitialized storage for any object whose type is listed in <span class='texttt'>Types</span>;
  its size shall be at least <span class='texttt'>Len</span>. The static member <span class='texttt'>alignment_value</span>
  shall be an integral constant of type <span class='texttt'>size_t</span> whose value is the
  strictest alignment of all types listed in <span class='texttt'>Types</span>.<br/>
 <i>Requires:</i> At least one type is provided.
  </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='decay'></a></span><span class='texttt'>template &lt;class T&gt;<br/> struct decay;</span>
 </td><td class='left'>
 Let <span class='texttt'>U</span> be <span class='texttt'>remove_reference_t&lt;T&gt;</span>. If <span class='texttt'>is_array_v&lt;U&gt;</span> is
 <span class='texttt'>true</span>, the member typedef <span class='texttt'>type</span> shall equal
 <span class='texttt'>remove_extent_t&lt;U&gt;*</span>. If <span class='texttt'>is_function_v&lt;U&gt;</span> is <span class='texttt'>true</span>,
 the member typedef <span class='texttt'>type</span> shall equal <span class='texttt'>add_pointer_t&lt;U&gt;</span>. Otherwise
 the member typedef <span class='texttt'>type</span> equals <span class='texttt'>remove_cv_t&lt;U&gt;</span>.
 [&nbsp;<i>Note:</i> This behavior is similar to the lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>),
 array-to-pointer (<a href='conv.array'>[conv.array]</a>), and function-to-pointer (<a href='conv.func'>[conv.func]</a>)
 conversions applied when an lvalue expression is used as an rvalue, but also
 strips <i>cv</i>-qualifiers from class types in order to more closely model by-value
 argument passing. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
 </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='enable_if'></a></span><span class='texttt'>template &lt;bool B, class T = void&gt;</span> <span class='texttt'>struct enable_if;</span>
 </td><td class='left'>
 If <span class='texttt'>B</span> is <span class='texttt'>true</span>, the member typedef <span class='texttt'>type</span>
 shall equal <span class='texttt'>T</span>; otherwise, there shall be no member
 <span class='texttt'>type</span>. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;bool B, class T,</span>
 <span class='texttt'>class F&gt;</span><br/>
 <span class='texttt'>struct conditional;</span>
 </td><td class='left'>
 If <span class='texttt'>B</span> is <span class='texttt'>true</span>,  the member typedef <span class='texttt'>type</span> shall equal <span class='texttt'>T</span>.
 If <span class='texttt'>B</span> is <span class='texttt'>false</span>, the member typedef <span class='texttt'>type</span> shall equal <span class='texttt'>F</span>. </td></tr><tr class='rowsep'><td class='left'>  <span class='texttt'>template &lt;class... T&gt;</span> <span class='texttt'>struct common_type;</span>
 </td><td class='left'>
 Unless this trait is specialized (as specified in Note B, below),
 the member <span class='texttt'>type</span> shall be defined or omitted as specified in Note A, below.
 If it is omitted, there shall be no member <span class='texttt'>type</span>.
 Each type in the parameter pack <span class='texttt'>T</span> shall be
 complete, <span class='texttt'>void</span>, or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='underlying_type'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct underlying_type;</span>
 </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall name the underlying type
 of <span class='texttt'>T</span>.<br/>
 <i>Requires:</i> <span class='texttt'>T</span> shall be a complete enumeration type (<a href='dcl.enum'>[dcl.enum]</a>) </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class Fn,</span><br/>
 <span class='texttt'>class... ArgTypes&gt;</span><br/>
 <span class='texttt'>struct result_of&lt;</span><br/>
 <span class='texttt'>Fn(ArgTypes...)&gt;;</span>
 </td><td class='left'>
 If the expression <span class='texttt'><i>INVOKE</i>(declval&lt;Fn&gt;(), declval&lt;ArgTypes&gt;()...)</span>
 is well formed when treated as an unevaluated operand (Clause <a href='expr'>[expr]</a>),
 the member typedef <span class='texttt'>type</span> shall name the type
 <span class='texttt'>decltype(<i>INVOKE</i>(declval&lt;Fn&gt;(), declval&lt;ArgTypes&gt;()...))</span>;
 otherwise, there shall be no member <span class='texttt'>type</span>. Access checking is
 performed as if in a context unrelated to <span class='texttt'>Fn</span> and
 <span class='texttt'>ArgTypes</span>. Only the validity of the immediate context of the
 expression is considered.
 [&nbsp;<i>Note:</i>
 The compilation of the expression can result in side effects such as
 the instantiation of class template specializations and function
 template specializations, the generation of implicitly-defined
 functions, and so on. Such side effects are not in the “immediate
 context” and can result in the program being ill-formed.
 <i>&nbsp;—&nbsp;end note</i>&nbsp;] <br/>
 <i>Requires:</i> <span class='texttt'>Fn</span> and all types in the parameter pack <span class='texttt'>ArgTypes</span> shall
 be complete types, <i>cv</i> <span class='texttt'>void</span>, or arrays of
 unknown bound.</td></tr></table></div><p ><span class='indexparent'><a class='index' id='aligned_storage'></a></span></p><div class='para' id='trans.other-1'><div class='marginalizedparent'><a class='marginalized' href='#trans.other-1'>1</a></div><p >[&nbsp;<i>Note:</i> A typical implementation would define <span class='texttt'>aligned_storage</span> as:</p><pre class='codeblock'>
template &lt;size_t Len, size_t Alignment&gt;
struct aligned_storage {
  typedef struct {
    alignas(Alignment) unsigned char __data[Len];
  } type;
};
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='trans.other-2'><div class='marginalizedparent'><a class='marginalized' href='#trans.other-2'>2</a></div><p >It is <span class='indexparent'><a class='index' id='support_for_extended_alignment'></a></span>implementation-defined whether any extended alignment is
supported (<a href='basic.align'>[basic.align]</a>).</p><p ><span class='indexparent'><a class='index' id='common_type'></a></span></p></div><div class='para' id='trans.other-3'><div class='marginalizedparent'><a class='marginalized' href='#trans.other-3'>3</a></div><p >Note A:
For the <span class='texttt'>common_type</span> trait applied to a parameter pack <span class='texttt'>T</span> of types,
the member <span class='texttt'>type</span> shall be either defined or not present as follows:</p><ul class='itemize'><li id='trans.other-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-3.1'>(3.1)</a></div><p >If <span class='texttt'>sizeof...(T)</span> is zero, there shall be no member <span class='texttt'>type</span>.</p></li><li id='trans.other-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-3.2'>(3.2)</a></div><p >If <span class='texttt'>sizeof...(T)</span> is one, let <span class='texttt'>T0</span> denote the sole type
constituting the pack <span class='texttt'>T</span>.
The member <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> <span class='texttt'>type</span> shall denote the same
type as <span class='texttt'>decay_t&lt;T0&gt;</span>.</p></li><li id='trans.other-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-3.3'>(3.3)</a></div><p >If <span class='texttt'>sizeof...(T)</span> is two,
let the first and second types constituting <span class='texttt'>T</span> be denoted
by <span class='texttt'>T1</span> and <span class='texttt'>T2</span>, respectively, and
let <span class='texttt'>D1</span> and <span class='texttt'>D2</span> denote
the same types as <span class='texttt'>decay_t&lt;T1&gt;</span> and <span class='texttt'>decay_t&lt;T2&gt;</span>, respectively.
  </p><ul class='itemize'><li id='trans.other-3.3.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#trans.other-3.3.1'>(3.3.1)</a></div><p >If <span class='texttt'>is_same_v&lt;T1, D1&gt;</span> is <span class='texttt'>false</span> or
     <span class='texttt'>is_same_v&lt;T2, D2&gt;</span> is <span class='texttt'>false</span>,
     let <span class='texttt'>C</span> denote the same type, if any, as <span class='texttt'>common_type_t&lt;D1, D2&gt;</span>.
  </p></li><li id='trans.other-3.3.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#trans.other-3.3.2'>(3.3.2)</a></div><p >Otherwise, let <span class='texttt'>C</span> denote the same type, if any, as
</p><pre class='codeblock'>
decay_t&lt;decltype(false ? declval&lt;D1&gt;() : declval&lt;D2&gt;())&gt;
</pre><p >[&nbsp;<i>Note:</i>
     This will not apply if there is a specialization <span class='texttt'>common_type&lt;D1, D2&gt;</span>.
     <i>&nbsp;—&nbsp;end note</i>&nbsp;]
  </p></li></ul><p >In either case, the member <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> <span class='texttt'>type</span> shall denote
the same type, if any, as <span class='texttt'>C</span>.
Otherwise, there shall be no member <span class='texttt'>type</span>.
[&nbsp;<i>Note:</i>
When <span class='texttt'>is_same_v&lt;T1, T2&gt;</span> is <span class='texttt'>true</span>,
the effect is equivalent to that of <span class='texttt'>common_type&lt;T1&gt;</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li id='trans.other-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#trans.other-3.4'>(3.4)</a></div><p >If <span class='texttt'>sizeof...(T)</span> is greater than two,
let <span class='texttt'>T1</span>, <span class='texttt'>T2</span>, and <span class='texttt'>R</span>, respectively,
denote the first, second, and (pack of) remaining types constituting <span class='texttt'>T</span>.
Let <span class='texttt'>C</span> denote the same type, if any, as <span class='texttt'>common_type_t&lt;T1, T2&gt;</span>.
If there is such a type <span class='texttt'>C</span>, the member <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i> <span class='texttt'>type</span>
shall denote the same type, if any, as <span class='texttt'>common_type_t&lt;C, R...&gt;</span>.
Otherwise, there shall be no member <span class='texttt'>type</span>.
</p></li></ul></div><div class='para' id='trans.other-4'><div class='marginalizedparent'><a class='marginalized' href='#trans.other-4'>4</a></div><p >Note B: Notwithstanding the provisions of <a href='meta.type.synop'>[meta.type.synop]</a>, and
pursuant to <a href='namespace.std'>[namespace.std]</a>,
a program may specialize <span class='texttt'>common_type&lt;T1, T2&gt;</span>
for distinct types <span class='texttt'>T1</span> and <span class='texttt'>T2</span> such that
<span class='texttt'>is_same_v&lt;T1, decay_t&lt;T1&gt;&gt;</span> and
<span class='texttt'>is_same_v&lt;T2, decay_t&lt;T2&gt;&gt;</span> are each <span class='texttt'>true</span>.
[&nbsp;<i>Note:</i>
Such specializations are needed when only explicit conversions
are desired between the template arguments.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
Such a specialization need not have a member named <span class='texttt'>type</span>,
but if it does, that member shall be a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>
for an accessible and unambiguous cv-unqualified non-reference type <span class='texttt'>C</span>
to which each of the types <span class='texttt'>T1</span> and <span class='texttt'>T2</span> is explicitly convertible.
Moreover, <span class='texttt'>common_type_t&lt;T1, T2&gt;</span> shall denote
the same type, if any, as does <span class='texttt'>common_type_t&lt;T2, T1&gt;</span>.
No diagnostic is required for a violation of this Note's rules.</p></div><div class='para' id='trans.other-5'><div class='marginalizedparent'><a class='marginalized' href='#trans.other-5'>5</a></div><p >[&nbsp;<i>Example:</i>
Given these definitions:
</p><pre class='codeblock'>
using PF1 = bool  (&amp;)();
using PF2 = short (*)(long);

struct S {
  operator PF2() const;
  double operator()(char, int&amp;);
  void fn(long) const;
  char data;
};

using PMF = void (S::*)(long) const;
using PMD = char  S::*;
</pre><p >the following assertions will hold:</p><pre class='codeblock'>
static_assert(is_same_v&lt;result_of_t&lt;S(int)&gt;, short&gt;, "Error!");
static_assert(is_same_v&lt;result_of_t&lt;S&amp;(unsigned char, int&amp;)&gt;, double&gt;, "Error!");
static_assert(is_same_v&lt;result_of_t&lt;PF1()&gt;, bool&gt;, "Error!");
static_assert(is_same_v&lt;result_of_t&lt;PMF(unique_ptr&lt;S&gt;, int)&gt;, void&gt;, "Error!");
static_assert(is_same_v&lt;result_of_t&lt;PMD(S)&gt;, char&amp;&amp;&gt;, "Error!");
static_assert(is_same_v&lt;result_of_t&lt;PMD(const S*)&gt;, const char&amp;&gt;, "Error!");
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div><div id='logical'><h3 ><a class='secnum' href='#logical' style='min-width:103pt'>20.15.8</a> Logical operator traits <a class='abbr_ref' href='meta.logical'>[meta.logical]</a></h3><div class='para' id='logical-1'><div class='marginalizedparent'><a class='marginalized' href='#logical-1'>1</a></div><p >This subclause describes type traits for applying logical operators
to other type traits.</p><p ><span class='indexparent'><a class='index' id='conjunction'></a></span><code class='itemdecl'>
template&lt;class... B&gt; struct conjunction : <i><span class='texttt'>see below</span></i> { };
</code></p></div><div class='itemdescr'></div><div class='para' id='logical-2'><div class='marginalizedparent'><a class='marginalized' href='#logical-2'>2</a></div><div class='itemdescr'><p >The class template <span class='texttt'>conjunction</span>
forms the logical conjunction of its template type arguments.</p></div></div><div class='para' id='logical-3'><div class='marginalizedparent'><a class='marginalized' href='#logical-3'>3</a></div><div class='itemdescr'><p >For a specialization <span class='texttt'>conjunction&lt;B1, ..., BN&gt;</span>,
if there is a template type argument <span class='texttt'>Bi</span> for which <span class='texttt'>bool(Bi::value)</span> is <span class='texttt'>false</span>,
then instantiating <span class='texttt'>conjunction&lt;B1, ..., BN&gt;::value</span>
does not require the instantiation of <span class='texttt'>Bj::value</span> for <span class='texttt'>j &gt; i</span>.
[&nbsp;<i>Note:</i> This is analogous to the short-circuiting behavior of
the built-in operator <span class='texttt'>&amp;&amp;</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='logical-4'><div class='marginalizedparent'><a class='marginalized' href='#logical-4'>4</a></div><div class='itemdescr'><p >Every template type argument
for which <span class='texttt'>Bi::value</span> is instantiated
shall be usable as a base class and
shall have a member <span class='texttt'>value</span> which
is convertible to <span class='texttt'>bool</span>,
is not hidden, and
is unambiguously available in the type.</p></div></div><div class='para' id='logical-5'><div class='marginalizedparent'><a class='marginalized' href='#logical-5'>5</a></div><div class='itemdescr'><p >The specialization <span class='texttt'>conjunction&lt;B1, ..., BN&gt;</span>
has a public and unambiguous base that is either
</p><ul class='itemize'><li id='logical-5.1'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#logical-5.1'>(5.1)</a></div><p >the first type <span class='texttt'>Bi</span> in the list <span class='texttt'>true_type, B1, ..., BN</span>
for which <span class='texttt'>bool(Bi::value)</span> is <span class='texttt'>false</span>, or
</p></li><li id='logical-5.2'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#logical-5.2'>(5.2)</a></div><p >if there is no such <span class='texttt'>Bi</span>, the last type in the list.
</p></li></ul><p >[&nbsp;<i>Note:</i> This means a specialization of <span class='texttt'>conjunction</span>
does not necessarily inherit from
either <span class='texttt'>true_type</span> or <span class='texttt'>false_type</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='logical-6'><div class='marginalizedparent'><a class='marginalized' href='#logical-6'>6</a></div><div class='itemdescr'><p >The member names of the base class, other than <span class='texttt'>conjunction</span> and
<span class='texttt'>operator=</span>, shall not be hidden and shall be unambiguously available
in <span class='texttt'>conjunction</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='disjunction'></a></span><code class='itemdecl'>
template&lt;class... B&gt; struct disjunction : <i><span class='texttt'>see below</span></i> { };
</code></p><div class='itemdescr'></div><div class='para' id='logical-7'><div class='marginalizedparent'><a class='marginalized' href='#logical-7'>7</a></div><div class='itemdescr'><p >The class template <span class='texttt'>disjunction</span>
forms the logical disjunction of its template type arguments.</p></div></div><div class='para' id='logical-8'><div class='marginalizedparent'><a class='marginalized' href='#logical-8'>8</a></div><div class='itemdescr'><p >For a specialization <span class='texttt'>disjunction&lt;B1, ..., BN&gt;</span>,
if there is a template type argument <span class='texttt'>Bi</span> for which <span class='texttt'>bool(Bi::value)</span> is <span class='texttt'>true</span>,
then instantiating <span class='texttt'>disjunction&lt;B1, ..., BN&gt;::value</span>
does not require the instantiation of <span class='texttt'>Bj::value</span> for <span class='texttt'>j &gt; i</span>.
[&nbsp;<i>Note:</i> This is analogous to the short-circuiting behavior of
the built-in operator <span class='texttt'>||</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='logical-9'><div class='marginalizedparent'><a class='marginalized' href='#logical-9'>9</a></div><div class='itemdescr'><p >Every template type argument
for which <span class='texttt'>Bi::value</span> is instantiated
shall be usable as a base class and
shall have a member <span class='texttt'>value</span> which
is convertible to <span class='texttt'>bool</span>,
is not hidden, and
is unambiguously available in the type.</p></div></div><div class='para' id='logical-10'><div class='marginalizedparent'><a class='marginalized' href='#logical-10'>10</a></div><div class='itemdescr'><p >The specialization <span class='texttt'>disjunction&lt;B1, ..., BN&gt;</span>
has a public and unambiguous base that is either
</p><ul class='itemize'><li id='logical-10.1'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#logical-10.1'>(10.1)</a></div><p >the first type <span class='texttt'>Bi</span> in the list <span class='texttt'>false_type, B1, ..., BN</span>
for which <span class='texttt'>bool(Bi::value)</span> is <span class='texttt'>true</span>, or
</p></li><li id='logical-10.2'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#logical-10.2'>(10.2)</a></div><p >if there is no such <span class='texttt'>Bi</span>, the last type in the list.
</p></li></ul><p >[&nbsp;<i>Note:</i> This means a specialization of <span class='texttt'>disjunction</span>
does not necessarily inherit from
either <span class='texttt'>true_type</span> or <span class='texttt'>false_type</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='logical-11'><div class='marginalizedparent'><a class='marginalized' href='#logical-11'>11</a></div><div class='itemdescr'><p >The member names of the base class,
other than <span class='texttt'>disjunction</span> and <span class='texttt'>operator=</span>,
shall not be hidden and shall be unambiguously available in <span class='texttt'>disjunction</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='negation'></a></span><code class='itemdecl'>
template&lt;class B&gt; struct negation : <i><span class='texttt'>see below</span></i> { };
</code></p><div class='itemdescr'></div><div class='para' id='logical-12'><div class='marginalizedparent'><a class='marginalized' href='#logical-12'>12</a></div><div class='itemdescr'><p >The class template <span class='texttt'>negation</span>
forms the logical negation of its template type argument.
The type <span class='texttt'>negation&lt;B&gt;</span>
is a <span class='texttt'>UnaryTypeTrait</span> with a base characteristic of <span class='texttt'>bool_constant&lt;!bool(B::value)&gt;</span>.
</p></div></div></div></div></div></body></html>