<!DOCTYPE html><html lang='en'><head><title>[diff.class]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='annexnum' style='min-width:73pt'>Annex C&emsp;(informative)</a> Compatibility <a class='abbr_ref' href='./#diff'>[diff]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>C.1</a> C++ and ISO C <a class='abbr_ref' href='diff.iso#diff.class'>[diff.iso]</a></h2><div id='diff.class'><h3 ><a class='secnum' style='min-width:103pt'>C.1.8</a> Clause <a href='class'>[class]</a>: classes <a class='abbr_ref'>[diff.class]</a></h3><p ><a href='class.name'>[class.name]</a> [see also <a href='dcl.typedef'>[dcl.typedef]</a>]
<br/><b>Change:</b> In C++, a class declaration introduces the class name into the scope where it is
declared and hides any object, function or other declaration of that name in an enclosing
scope. In C, an inner scope declaration of a struct tag name never hides the name of an
object or function in an outer scope.</p><p >Example:</p><pre class='codeblock'>
int x[99];
void f() {
  struct x { int a; };
  sizeof(x);  <span class='comment'>/* <i><span class='textrm'>size of the array in C</span></i> */</span>
  <span class='comment'>/* <i><span class='textrm'>size of the struct in C++</span></i> */</span>
}
</pre><p ><br/><b>Rationale:</b>
This is one of the few incompatibilities between C and C++ that
can be attributed to the new C++ name space definition where a
name can be declared as a type and as a non-type in a single scope
causing the non-type name to hide the type name and requiring that
the keywords <span class='texttt'>class</span>, <span class='texttt'>struct</span>, <span class='texttt'>union</span> or <span class='texttt'>enum</span> be used to refer to the type name.
This new name space definition provides important notational
conveniences to C++ programmers and helps making the use of the
user-defined types as similar as possible to the use of fundamental
types.
The advantages of the new name space definition were judged to
outweigh by far the incompatibility with C described above.
<br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
If the hidden name that needs to be accessed is at global scope,
the <span class='texttt'>::</span> C++ operator can be used.
If the hidden name is at block scope, either the type or the struct
tag has to be renamed.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='class.bit'>[class.bit]</a>
<br/><b>Change:</b>
<span class='indexparent'><a class='index' id='bit-field,implementation-defined_sign_of'></a></span>Bit-fields of type plain <span class='texttt'>int</span> are signed.
<br/><b>Rationale:</b>
Leaving the choice of signedness to implementations could lead to
inconsistent definitions of template specializations. For consistency,
the implementation freedom was eliminated for non-dependent types,
too.
<br/><b>Effect on original feature:</b>
The choice is implementation-defined in C, but not so in C++.
<br/><b>Difficulty of converting:</b>
Syntactic transformation.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='class.nest'>[class.nest]</a>
<br/><b>Change:</b> In C++, the name of a nested class is local to its enclosing class. In C
the name of the nested class belongs to the same scope as the name of the outermost enclosing class.</p><p >Example:</p><pre class='codeblock'>
struct X {
  struct Y { <span class='comment'>/* ... */</span> } y;
};
struct Y yy;                    <span class='comment'>// valid C, invalid C++
</span></pre><p ><br/><b>Rationale:</b>
C++ classes have member functions which require that classes
establish scopes.
The C rule would leave classes as an incomplete scope mechanism
which would prevent C++ programmers from maintaining locality
within a class.
A coherent set of scope rules for C++ based on the C rule would
be very complicated and C++ programmers would be unable to predict
reliably the meanings of nontrivial examples involving nested or
local functions.
<br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
To make the struct type name visible in the scope of the enclosing
struct, the struct tag could be declared in the scope of the
enclosing struct, before the enclosing struct is defined.
Example:</p><pre class='codeblock'>
struct Y;                       <span class='comment'>// <span class='texttt'>struct Y</span> and <span class='texttt'>struct X</span> are at the same scope
</span>struct X {
  struct Y { <span class='comment'>/* ... */</span> } y;
};
</pre><p >All the definitions of C struct types enclosed in other struct
definitions and accessed outside the scope of the enclosing
struct could be exported to the scope of the enclosing struct.
Note: this is a consequence of the difference in scope rules,
which is documented in <a href='basic.scope'>[basic.scope]</a>.
<br/><b>How widely used:</b>
Seldom.</p><p ><a href='class.nested.type'>[class.nested.type]</a>
<br/><b>Change:</b> In C++, a typedef name may not be redeclared in a class definition after being used in that definition.</p><p >Example:</p><pre class='codeblock'>
typedef int I;
struct S {
  I i;
  int I;                  <span class='comment'>// valid C, invalid C++
</span>};
</pre><p ><br/><b>Rationale:</b>
When classes become complicated, allowing such a redefinition
after the type has been used can create confusion for C++
programmers as to what the meaning of 'I' really is.
<br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<br/><b>Difficulty of converting:</b>
Semantic transformation.
Either the type or the struct member has to be renamed.
<br/><b>How widely used:</b>
Seldom.</p></div></div></body></html>