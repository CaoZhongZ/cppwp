<!DOCTYPE html><html lang='en'><head><title>[diff.class]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='annexnum' style='min-width:73pt'>Annex C&emsp;(informative)</a> Compatibility <a class='abbr_ref' href='./#diff'>[diff]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>C.1</a> C++ and ISO C <a class='abbr_ref' href='diff.iso#diff.class'>[diff.iso]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>C.1.8</a> <a href='class'>[class]</a>: classes <a class='abbr_ref'>[diff.class]</a></h3><div id='sentence-1' class='sentence'><a href='class.name'>[class.name]</a> [see also <a href='dcl.typedef'>[dcl.typedef]</a>]
<br/><b>Change:</b> In C++, a class declaration introduces the class name into the scope where it is
declared and hides any object, function or other declaration of that name in an enclosing
scope<a class='hidden_link' href='#sentence-1'>.</a></div> <div id='sentence-2' class='sentence'>In C, an inner scope declaration of a struct tag name never hides the name of an
object or function in an outer scope<a class='hidden_link' href='#sentence-2'>.</a></div><div style='height:0.6em;display:block'></div><div id='sentence-3' class='sentence'>Example:</div><pre class='codeblock'>
int x[99];
void f() {
  struct x { int a; };
  sizeof(x);  /* size of the array in C */
  /* size of the struct in <span class='textit'><span class='textrm'>C++</span></span> */
}</pre> <div id='sentence-4' class='sentence'><br/><b>Rationale:</b> 
This is one of the few incompatibilities between C and C++ that
can be attributed to the new C++ name space definition where a
name can be declared as a type and as a non-type in a single scope
causing the non-type name to hide the type name and requiring that
the keywords <span class='texttt'>class</span>, <span class='texttt'>struct</span>, <span class='texttt'>union</span> or <span class='texttt'>enum</span> be used to refer to the type name<a class='hidden_link' href='#sentence-4'>.</a></div> <div id='sentence-5' class='sentence'>This new name space definition provides important notational
conveniences to C++ programmers and helps making the use of the
user-defined types as similar as possible to the use of fundamental
types<a class='hidden_link' href='#sentence-5'>.</a></div> <div id='sentence-6' class='sentence'>The advantages of the new name space definition were judged to
outweigh by far the incompatibility with C described above<a class='hidden_link' href='#sentence-6'>.</a></div> <div id='sentence-7' class='sentence'><br/><b>Effect on original feature:</b> 
Change to semantics of well-defined feature<a class='hidden_link' href='#sentence-7'>.</a></div> <div id='sentence-8' class='sentence'><br/><b>Difficulty of converting:</b> 
Semantic transformation<a class='hidden_link' href='#sentence-8'>.</a></div> <div id='sentence-9' class='sentence'>If the hidden name that needs to be accessed is at global scope,
the <span class='texttt'>&#x200b;::&#x200b;</span> C++ operator can be used<a class='hidden_link' href='#sentence-9'>.</a></div> <div id='sentence-10' class='sentence'>If the hidden name is at block scope, either the type or the struct
tag has to be renamed<a class='hidden_link' href='#sentence-10'>.</a></div> <div id='sentence-11' class='sentence'><br/><b>How widely used:</b> 
Seldom<a class='hidden_link' href='#sentence-11'>.</a></div><div style='height:0.6em;display:block'></div><div id='sentence-12' class='sentence'><a href='class.bit'>[class.bit]</a>
<br/><b>Change:</b> 
<span class='indexparent'><a class='index' id=':bit-field,implementation-defined_sign_of'></a></span>Bit-fields of type plain <span class='texttt'>int</span> are signed<a class='hidden_link' href='#sentence-12'>.</a></div> <div id='sentence-13' class='sentence'><br/><b>Rationale:</b> 
Leaving the choice of signedness to implementations could lead to
inconsistent definitions of template specializations<a class='hidden_link' href='#sentence-13'>.</a></div> <div id='sentence-14' class='sentence'>For consistency,
the implementation freedom was eliminated for non-dependent types,
too<a class='hidden_link' href='#sentence-14'>.</a></div> <div id='sentence-15' class='sentence'><br/><b>Effect on original feature:</b> 
The choice is implementation-defined in C, but not so in C++<a class='hidden_link' href='#sentence-15'>.</a></div> <div id='sentence-16' class='sentence'><br/><b>Difficulty of converting:</b> 
Syntactic transformation<a class='hidden_link' href='#sentence-16'>.</a></div> <div id='sentence-17' class='sentence'><br/><b>How widely used:</b> 
Seldom<a class='hidden_link' href='#sentence-17'>.</a></div><div style='height:0.6em;display:block'></div><div id='sentence-18' class='sentence'><a href='class.nest'>[class.nest]</a>
<br/><b>Change:</b> In C++, the name of a nested class is local to its enclosing class<a class='hidden_link' href='#sentence-18'>.</a></div> <div id='sentence-19' class='sentence'>In C
the name of the nested class belongs to the same scope as the name of the outermost enclosing class<a class='hidden_link' href='#sentence-19'>.</a></div><div style='height:0.6em;display:block'></div><div id='sentence-20' class='sentence'>Example:</div><pre class='codeblock'>
struct X {
  struct Y { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> } y;
};
struct Y yy;                    <span class='comment'>// valid C, invalid C++
</span></pre> <div id='sentence-21' class='sentence'><br/><b>Rationale:</b> 
C++ classes have member functions which require that classes
establish scopes<a class='hidden_link' href='#sentence-21'>.</a></div> <div id='sentence-22' class='sentence'>The C rule would leave classes as an incomplete scope mechanism
which would prevent C++ programmers from maintaining locality
within a class<a class='hidden_link' href='#sentence-22'>.</a></div> <div id='sentence-23' class='sentence'>A coherent set of scope rules for C++ based on the C rule would
be very complicated and C++ programmers would be unable to predict
reliably the meanings of nontrivial examples involving nested or
local functions<a class='hidden_link' href='#sentence-23'>.</a></div> <div id='sentence-24' class='sentence'><br/><b>Effect on original feature:</b> 
Change to semantics of well-defined feature<a class='hidden_link' href='#sentence-24'>.</a></div> <div id='sentence-25' class='sentence'><br/><b>Difficulty of converting:</b> 
Semantic transformation<a class='hidden_link' href='#sentence-25'>.</a></div> <div id='sentence-26' class='sentence'>To make the struct type name visible in the scope of the enclosing
struct, the struct tag could be declared in the scope of the
enclosing struct, before the enclosing struct is defined<a class='hidden_link' href='#sentence-26'>.</a></div> <div id='sentence-27' class='sentence'>Example:</div><pre class='codeblock'>
struct Y;                       <span class='comment'>// <span class='tcode_in_codeblock'>struct Y</span> and <span class='tcode_in_codeblock'>struct X</span> are at the same scope
</span>struct X {
  struct Y { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> } y;
};</pre><div id='sentence-28' class='sentence'>All the definitions of C struct types enclosed in other struct
definitions and accessed outside the scope of the enclosing
struct could be exported to the scope of the enclosing struct<a class='hidden_link' href='#sentence-28'>.</a></div> <div id='sentence-29' class='sentence'>Note: this is a consequence of the difference in scope rules,
which is documented in <a href='basic.scope'>[basic.scope]</a><a class='hidden_link' href='#sentence-29'>.</a></div> <div id='sentence-30' class='sentence'><br/><b>How widely used:</b> 
Seldom<a class='hidden_link' href='#sentence-30'>.</a></div><div style='height:0.6em;display:block'></div><div id='sentence-31' class='sentence'><a href='class.nested.type'>[class.nested.type]</a>
<br/><b>Change:</b> In C++, a typedef name may not be redeclared in a class definition after being used in that definition<a class='hidden_link' href='#sentence-31'>.</a></div><div style='height:0.6em;display:block'></div><div id='sentence-32' class='sentence'>Example:</div><pre class='codeblock'>
typedef int I;
struct S {
  I i;
  int I;                  <span class='comment'>// valid C, invalid C++
</span>};</pre> <div id='sentence-33' class='sentence'><br/><b>Rationale:</b> 
When classes become complicated, allowing such a redefinition
after the type has been used can create confusion for C++
programmers as to what the meaning of <span class='texttt'>I</span> really is<a class='hidden_link' href='#sentence-33'>.</a></div> <div id='sentence-34' class='sentence'><br/><b>Effect on original feature:</b> 
Deletion of semantically well-defined feature<a class='hidden_link' href='#sentence-34'>.</a></div> <div id='sentence-35' class='sentence'><br/><b>Difficulty of converting:</b> 
Semantic transformation<a class='hidden_link' href='#sentence-35'>.</a></div> <div id='sentence-36' class='sentence'>Either the type or the struct member has to be renamed<a class='hidden_link' href='#sentence-36'>.</a></div> <div id='sentence-37' class='sentence'><br/><b>How widely used:</b> 
Seldom<a class='hidden_link' href='#sentence-37'>.</a></div></div></body></html>