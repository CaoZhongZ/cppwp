<!DOCTYPE html><html lang='en'><head><title>[dcl.stc]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Declarations <a class='abbr_ref' href='./#dcl.dcl'>[dcl.dcl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>7.1</a> Specifiers <a class='abbr_ref' href='dcl.spec#dcl.stc'>[dcl.spec]</a></h2><div id='dcl.stc'><h3 ><a class='secnum' style='min-width:103pt'>7.1.1</a> Storage class specifiers <a class='abbr_ref'>[dcl.stc]</a></h3><p ><span class='indexparent'><a class='index' id='specifier!storage~class'></a></span><span class='indexparent'><a class='index' id='declaration!storage~class'></a></span><span class='indexparent'><a class='index' id='static'></a></span><span class='indexparent'><a class='index' id='thread_local'></a></span><span class='indexparent'><a class='index' id='extern'></a></span><span class='indexparent'><a class='index' id='mutable'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The storage class specifiers are</p><pre class='bnf'><a id='storage-class-specifier'>storage-class-specifier:</a>
    <span class='terminal'>static</span>
    <span class='terminal'>thread_local</span>
    <span class='terminal'>extern</span>
    <span class='terminal'>mutable</span></pre><p >At most one <i ><a href='dcl.stc#storage-class-specifier'>storage-class-specifier</a></i> shall appear in a given
<i ><a href='dcl.spec#decl-specifier-seq'>decl-specifier-seq</a></i>, except that <span class='texttt'>thread_local</span> may appear with <span class='texttt'>static</span> or 
<span class='texttt'>extern</span>. If <span class='texttt'>thread_local</span> appears in any declaration of
a variable it shall be present in all declarations of that entity. If a 
<i ><a href='dcl.stc#storage-class-specifier'>storage-class-specifier</a></i>
appears in a <i ><a href='dcl.spec#decl-specifier-seq'>decl-specifier-seq</a></i>, there can be no
<span class='texttt'>typedef</span> specifier in the same <i ><a href='dcl.spec#decl-specifier-seq'>decl-specifier-seq</a></i> and
the <i ><a href='dcl.decl#init-declarator-list'>init-declarator-list</a></i> or <i ><a href='class.mem#member-declarator-list'>member-declarator-list</a></i>
of the declaration shall not be
empty (except for an anonymous union declared in a named namespace or in the
global namespace, which shall be declared
<span class='indexparent'><a class='index' id='specifier!static'></a></span><span class='texttt'>static</span> (<a href='class.union.anon'>[class.union.anon]</a>)). The
<i ><a href='dcl.stc#storage-class-specifier'>storage-class-specifier</a></i> applies to the name declared by each
<i ><a href='dcl.decl#init-declarator'>init-declarator</a></i> in the list and not to any names declared by
other specifiers. A <i ><a href='dcl.stc#storage-class-specifier'>storage-class-specifier</a></i>
other than <span class='texttt'>thread_local</span>
shall not be
specified in an explicit specialization (<a href='temp.expl.spec'>[temp.expl.spec]</a>) or an
explicit instantiation (<a href='temp.explicit'>[temp.explicit]</a>) directive.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
A variable declared without a <i ><a href='dcl.stc#storage-class-specifier'>storage-class-specifier</a></i>
at block scope or declared as a function parameter
has automatic storage duration by default (<a href='basic.stc.auto'>[basic.stc.auto]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The <span class='texttt'>thread_local</span> specifier
indicates that the named entity has thread storage duration (<a href='basic.stc.thread'>[basic.stc.thread]</a>). It
shall be applied only
to the names of variables of namespace
or block scope and to the names of static data members.
When <span class='texttt'>thread_local</span> is applied to a variable of block scope the
<i ><a href='dcl.stc#storage-class-specifier'>storage-class-specifier</a></i> <span class='texttt'>static</span> is implied if no other
<i ><a href='dcl.stc#storage-class-specifier'>storage-class-specifier</a></i> appears in the
<i ><a href='dcl.spec#decl-specifier-seq'>decl-specifier-seq</a></i>.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='restriction!static'></a></span>The <span class='texttt'>static</span> specifier can be applied only to names of variables and
functions and to anonymous unions (<a href='class.union.anon'>[class.union.anon]</a>). There can be no
<span class='texttt'>static</span> function declarations within a block, nor any
<span class='texttt'>static</span> function parameters. A <span class='texttt'>static</span> specifier used in
the declaration of a variable declares the variable to have static storage
duration (<a href='basic.stc.static'>[basic.stc.static]</a>), unless accompanied by the
<span class='texttt'>thread_local</span> specifier, which declares the variable to have thread
storage duration (<a href='basic.stc.thread'>[basic.stc.thread]</a>). A <span class='texttt'>static</span> specifier can be
used in declarations of class members; <a href='class.static'>[class.static]</a> describes its
effect.
<span class='indexparent'><a class='index' id='static!linkage~of'></a></span>For the linkage of a name declared with a <span class='texttt'>static</span> specifier,
see <a href='basic.link'>[basic.link]</a>.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='restriction!extern'></a></span>The <span class='texttt'>extern</span> specifier can be applied only to the names of variables
and functions. The <span class='texttt'>extern</span> specifier cannot be used in the
declaration of class members or function parameters.
<span class='indexparent'><a class='index' id='extern!linkage~of'></a></span><span class='indexparent'><a class='index' id='consistency!linkage'></a></span>For the linkage of a name declared with an <span class='texttt'>extern</span> specifier,
see <a href='basic.link'>[basic.link]</a>.
[&nbsp;<i>Note:</i><span class='space'></span>
The <span class='texttt'>extern</span> keyword can also be used in
<span class='small'></span><span class='rmfamily'></span><i> explicit-instantiation</i>s and
<span class='small'></span><span class='rmfamily'></span><i> linkage-specification</i>s, but it is not a
<span class='small'></span><span class='rmfamily'></span><i> storage-class-specifier</i> in such contexts.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >The linkages implied by successive declarations for a given entity shall
agree. That is, within a given scope, each declaration declaring the
same variable name or the same overloading of a function name shall imply
the same linkage. Each function in a given set of overloaded functions
can have a different linkage, however.
[&nbsp;<i>Example:</i><span class='space'></span>
<span class='indexparent'><a class='index' id='example!linkage consistency'></a></span>
</p><pre class='codeblock'>
static char* f();               <span class='comment'>// <span class='texttt'>f()</span> has internal linkage
</span>char* f()                       <span class='comment'>// <span class='texttt'>f()</span> still has internal linkage
</span>  { <span class='comment'>/* ... */</span> }

char* g();                      <span class='comment'>// <span class='texttt'>g()</span> has external linkage
</span>static char* g()                <span class='comment'>// error: inconsistent linkage
</span>  { <span class='comment'>/* ... */</span> }

void h();
inline void h();                <span class='comment'>// external linkage
</span>
inline void l();
void l();                       <span class='comment'>// external linkage
</span>
inline void m();
extern void m();                <span class='comment'>// external linkage
</span>
static void n();
inline void n();                <span class='comment'>// internal linkage
</span>
static int a;                   <span class='comment'>// <span class='texttt'>a</span> has internal linkage
</span>int a;                          <span class='comment'>// error: two definitions
</span>
static int b;                   <span class='comment'>// <span class='texttt'>b</span> has internal linkage
</span>extern int b;                   <span class='comment'>// <span class='texttt'>b</span> still has internal linkage
</span>
int c;                          <span class='comment'>// <span class='texttt'>c</span> has external linkage
</span>static int c;                   <span class='comment'>// error: inconsistent linkage
</span>
extern int d;                   <span class='comment'>// <span class='texttt'>d</span> has external linkage
</span>static int d;                   <span class='comment'>// error: inconsistent linkage
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p ><span class='indexparent'><a class='index' id='declaration!forward'></a></span>The name of a declared but undefined class can be used in an
<span class='texttt'>extern</span> declaration. Such a declaration can only be used in ways
that do not require a complete class type.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct S;
extern S a;
extern S f();
extern void g(S);

void h() {
  g(a);                         <span class='comment'>// error: <span class='texttt'>S</span> is incomplete
</span>  f();                          <span class='comment'>// error: <span class='texttt'>S</span> is incomplete
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >The <span class='texttt'>mutable</span> specifier shall appear only in the declaration of
a non-static data member (<a href='class.mem'>[class.mem]</a>)
whose type is neither const-qualified nor a reference type.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class X {
  mutable const int* p;         <span class='comment'>// OK
</span>  mutable int* const q;         <span class='comment'>// ill-formed
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >The <span class='texttt'>mutable</span> specifier on a class data member nullifies a
<span class='texttt'>const</span> specifier applied to the containing class object and
permits modification of the mutable class member even though the rest of
the object is <span class='texttt'>const</span> (<a href='dcl.type.cv'>[dcl.type.cv]</a>).</p></div></div></div></body></html>