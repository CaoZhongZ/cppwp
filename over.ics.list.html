<!DOCTYPE html><html lang='en'><head><title>[over.ics.list]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>16</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>16.3</a> Overload resolution <a class='abbr_ref' href='over.match#over.ics.list'>[over.match]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>16.3.3</a> Best viable function <a class='abbr_ref' href='over.match.best#over.ics.list'>[over.match.best]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>16.3.3.1</a> Implicit conversion sequences <a class='abbr_ref' href='over.best.ics#over.ics.list'>[over.best.ics]</a></h4><h4 ><a class='secnum' style='min-width:133pt'>16.3.3.1.5</a> List-initialization sequence <a class='abbr_ref'>[over.ics.list]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/06013de0d00e66204253d2f682b4b879f7686540/source/overloading.tex#L2274'>#</a></div><div id='1.sentence-1' class='sentence'>When an argument is an initializer list (<a href='dcl.init.list'>[dcl.init.list]</a>), it is not an expression and special rules apply for converting it to a parameter type<a class='hidden_link' href='#1.sentence-1'>.</a></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/06013de0d00e66204253d2f682b4b879f7686540/source/overloading.tex#L2278'>#</a></div><div id='2.sentence-1' class='sentence'>If the initializer list is a <i ><a href='dcl.init#nt:designated-initializer-list'>designated-initializer-list</a></i>,
a conversion is only possible if
the parameter has an aggregate type
that can be initialized from the initializer list
according to the rules for aggregate initialization (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>),
in which case the implicit conversion sequence is
a user-defined conversion sequence
whose second standard conversion sequence
is an identity conversion<a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#2.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='2.sentence-2' class='sentence'>Aggregate initialization does not require that
the members are declared in designation order<a class='hidden_link' href='#2.sentence-2'>.</a></div> <div id='2.sentence-3' class='sentence'>If, after overload resolution, the order does not match
for the selected overload,
the initialization of the parameter will be ill-formed (<a href='dcl.init.list'>[dcl.init.list]</a>)<a class='hidden_link' href='#2.sentence-3'>.</a></div> <div id='2.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A { int x, y; };
struct B { int y, x; };
void f(A a, int);               <span class='comment'>// #1
</span>void f(B b, ...);               <span class='comment'>// #2
</span>void g(A a);                    <span class='comment'>// #3
</span>void g(B b);                    <span class='comment'>// #4
</span>void h() {
  f({.x = 1, .y = 2}, 0);       <span class='comment'>// OK; calls #1
</span>  f({.y = 2, .x = 1}, 0);       <span class='comment'>// error: selects #1, initialization of <span class='tcode_in_codeblock'>a</span> fails
</span>                                <span class='comment'>// due to non-matching member order (<a href='dcl.init.list'>[dcl.init.list]</a>)
</span>  g({.x = 1, .y = 2});          <span class='comment'>// error: ambiguous between #3 and #4
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/06013de0d00e66204253d2f682b4b879f7686540/source/overloading.tex#L2312'>#</a></div><div id='3.sentence-1' class='sentence'>Otherwise,
if the parameter type is an aggregate class <span class='texttt'>X</span> and the initializer list has a
single element of type <span class='mathit'>cv</span> <span class='texttt'>U</span>, where <span class='texttt'>U</span> is <span class='texttt'>X</span>
or a class derived from <span class='texttt'>X</span>, the implicit conversion sequence is the one
required to convert the element to the parameter type<a class='hidden_link' href='#3.sentence-1'>.</a></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/06013de0d00e66204253d2f682b4b879f7686540/source/overloading.tex#L2319'>#</a></div><div id='4.sentence-1' class='sentence'>Otherwise, if the parameter type is a character array<a class='footnotenum' href='#footnote-133'>133</a>
and the initializer list has a single element that is an appropriately-typed
string literal (<a href='dcl.init.string'>[dcl.init.string]</a>), the implicit conversion
sequence is the identity conversion<a class='hidden_link' href='#4.sentence-1'>.</a></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/06013de0d00e66204253d2f682b4b879f7686540/source/overloading.tex#L2327'>#</a></div><div id='5.sentence-1' class='sentence'>Otherwise, if the parameter type is <span class='texttt'>std&#x200b;::&#x200b;initializer_&shy;list&lt;X&gt;</span>
and all the elements
of the initializer list can be implicitly converted to <span class='texttt'>X</span>, the implicit
conversion sequence is the worst conversion necessary to convert an element of
the list to <span class='texttt'>X</span>, or if the initializer list has no elements, the identity
conversion<a class='hidden_link' href='#5.sentence-1'>.</a></div> <div id='5.sentence-2' class='sentence'>This conversion can be a user-defined conversion even in
the context of a call to an initializer-list constructor<a class='hidden_link' href='#5.sentence-2'>.</a></div> <div id='5.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#5.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
void f(std::initializer_list&lt;int&gt;);
f( {} );                        <span class='comment'>// OK: <span class='tcode_in_codeblock'>f(initializer_&shy;list&lt;int&gt;)</span> identity conversion
</span>f( {1,2,3} );                   <span class='comment'>// OK: <span class='tcode_in_codeblock'>f(initializer_&shy;list&lt;int&gt;)</span> identity conversion
</span>f( {'a','b'} );                 <span class='comment'>// OK: <span class='tcode_in_codeblock'>f(initializer_&shy;list&lt;int&gt;)</span> integral promotion
</span>f( {1.0} );                     <span class='comment'>// error: narrowing
</span>
struct A {
  A(std::initializer_list&lt;double&gt;);             <span class='comment'>// #1
</span>  A(std::initializer_list&lt;complex&lt;double&gt;&gt;);    <span class='comment'>// #2
</span>  A(std::initializer_list&lt;std::string&gt;);        <span class='comment'>// #3
</span>};
A a{ 1.0,2.0 };                 <span class='comment'>// OK, uses #1
</span>
void g(A);
g({ "foo", "bar" });            <span class='comment'>// OK, uses #3
</span>
typedef int IA[3];
void h(const IA&amp;);
h({ 1, 2, 3 });                 <span class='comment'>// OK: identity conversion
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/06013de0d00e66204253d2f682b4b879f7686540/source/overloading.tex#L2358'>#</a></div><div id='6.sentence-1' class='sentence'>Otherwise, if the parameter type is “array of <span class='texttt'>N</span> <span class='texttt'>X</span>”,
if there exists an implicit conversion sequence for each element of the array
from the corresponding element of the initializer list (or from <span class='texttt'>{}</span>
if there is no such element), the implicit conversion sequence is
the worst such implicit conversion sequence<a class='hidden_link' href='#6.sentence-1'>.</a></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/06013de0d00e66204253d2f682b4b879f7686540/source/overloading.tex#L2365'>#</a></div><div id='7.sentence-1' class='sentence'>Otherwise, if the parameter is a non-aggregate class <span class='texttt'>X</span> and overload
resolution per <a href='over.match.list'>[over.match.list]</a> chooses a single best constructor <span class='texttt'>C</span> of
<span class='texttt'>X</span> to perform the initialization of an object of type <span class='texttt'>X</span> from the
argument initializer list:
<ul class='itemize'><li id='7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.1'>(7.1)</a></div><div id='7.1.sentence-1' class='sentence'>If <span class='texttt'>C</span> is not an initializer-list constructor
and the initializer list has a single element of type <span class='mathit'>cv</span> <span class='texttt'>U</span>,
where <span class='texttt'>U</span> is <span class='texttt'>X</span> or a class derived from <span class='texttt'>X</span>,
the implicit conversion sequence has Exact Match rank if <span class='texttt'>U</span> is <span class='texttt'>X</span>,
or Conversion rank if <span class='texttt'>U</span> is derived from <span class='texttt'>X</span><a class='hidden_link' href='#7.1.sentence-1'>.</a></div></li><li id='7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.2'>(7.2)</a></div><div id='7.2.sentence-1' class='sentence'>Otherwise, the implicit conversion sequence is a user-defined
conversion sequence with the second standard conversion sequence an
identity conversion<a class='hidden_link' href='#7.2.sentence-1'>.</a></div></li></ul></div> <div id='7.sentence-2' class='sentence'>
If multiple constructors are viable but none is better than
the others, the implicit conversion sequence is the ambiguous conversion
sequence<a class='hidden_link' href='#7.sentence-2'>.</a></div> <div id='7.sentence-3' class='sentence'>User-defined conversions are allowed for conversion of the initializer
list elements to the constructor parameter types except as noted
in <a href='over.best.ics'>[over.best.ics]</a><a class='hidden_link' href='#7.sentence-3'>.</a></div> <div id='7.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#7.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A {
  A(std::initializer_list&lt;int&gt;);
};
void f(A);
f( {'a', 'b'} );        <span class='comment'>// OK: <span class='tcode_in_codeblock'>f(A(std&#x200b;::&#x200b;initializer_&shy;list&lt;int&gt;))</span> user-defined conversion
</span>
struct B {
  B(int, double);
};
void g(B);
g( {'a', 'b'} );        <span class='comment'>// OK: <span class='tcode_in_codeblock'>g(B(int, double))</span> user-defined conversion
</span>g( {1.0, 1.0} );        <span class='comment'>// error: narrowing
</span>
void f(B);
f( {'a', 'b'} );        <span class='comment'>// error: ambiguous <span class='tcode_in_codeblock'>f(A)</span> or <span class='tcode_in_codeblock'>f(B)</span>
</span>
struct C {
  C(std::string);
};
void h(C);
h({"foo"});             <span class='comment'>// OK: <span class='tcode_in_codeblock'>h(C(std&#x200b;::&#x200b;string("foo")))</span>
</span>
struct D {
  D(A, C);
};
void i(D);
i({ {1,2}, {"bar"} });  <span class='comment'>// OK: <span class='tcode_in_codeblock'>i(D(A(std&#x200b;::&#x200b;initializer_&shy;list&lt;int&gt;{1,2}), C(std&#x200b;::&#x200b;string("bar"))))</span>
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/06013de0d00e66204253d2f682b4b879f7686540/source/overloading.tex#L2419'>#</a></div><div id='8.sentence-1' class='sentence'>Otherwise, if the parameter has an aggregate type which can be initialized from
the initializer list according to the rules for <a href='dcl.init.aggr'>aggregate
initialization</a>, the implicit conversion sequence is a
user-defined conversion sequence with the second standard conversion
sequence an identity conversion<a class='hidden_link' href='#8.sentence-1'>.</a></div> <div id='8.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#8.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A {
  int m1;
  double m2;
};

void f(A);
f( {'a', 'b'} );        <span class='comment'>// OK: <span class='tcode_in_codeblock'>f(A(int,double))</span> user-defined conversion
</span>f( {1.0} );             <span class='comment'>// error: narrowing
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/06013de0d00e66204253d2f682b4b879f7686540/source/overloading.tex#L2437'>#</a></div><div id='9.sentence-1' class='sentence'>Otherwise, if the parameter is a reference, see <a href='over.ics.ref'>[over.ics.ref]</a><a class='hidden_link' href='#9.sentence-1'>.</a></div> <div id='9.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#9.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='9.sentence-2' class='sentence'>The rules in this subclause will apply for initializing the underlying temporary
for the reference<a class='hidden_link' href='#9.sentence-2'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>   <div id='9.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#9.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A {
  int m1;
  double m2;
};

void f(const A&amp;);
f( {'a', 'b'} );        <span class='comment'>// OK: <span class='tcode_in_codeblock'>f(A(int,double))</span> user-defined conversion
</span>f( {1.0} );             <span class='comment'>// error: narrowing
</span>
void g(const double &amp;);
g({1});                 <span class='comment'>// same conversion as <span class='tcode_in_codeblock'>int</span> to <span class='tcode_in_codeblock'>double</span>
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/06013de0d00e66204253d2f682b4b879f7686540/source/overloading.tex#L2456'>#</a></div><div id='10.sentence-1' class='sentence'>Otherwise, if the parameter type is not a class:</div><div id='10.sentence-2' class='sentence'><ul class='itemize'><li id='10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.1'>(10.1)</a></div><div id='10.1.sentence-1' class='sentence'>if the initializer list has one element that is not itself an initializer list,
the implicit conversion sequence is the one required to convert the element to
the parameter type; <div id='10.1.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#10.1.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
void f(int);
f( {'a'} );             <span class='comment'>// OK: same conversion as <span class='tcode_in_codeblock'>char</span> to <span class='tcode_in_codeblock'>int</span>
</span>f( {1.0} );             <span class='comment'>// error: narrowing
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div></li><li id='10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#10.2'>(10.2)</a></div><div id='10.2.sentence-1' class='sentence'>if the initializer list has no elements, the implicit conversion sequence
is the identity conversion<a class='hidden_link' href='#10.2.sentence-1'>.</a></div> <div id='10.2.example-2' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#10.2.example-2'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
void f(int);
f( { } );               <span class='comment'>// OK: identity conversion
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </li></ul></div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/06013de0d00e66204253d2f682b4b879f7686540/source/overloading.tex#L2479'>#</a></div><div id='11.sentence-1' class='sentence'>In all cases other than those enumerated above, no conversion is possible<a class='hidden_link' href='#11.sentence-1'>.</a></div></div><div class='footnote' id='footnote-133'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-133'>133)</a></div><div id='footnote-133.sentence-1' class='sentence'>Since there are no parameters of array type,
this will only occur as the referenced type of a reference parameter<a class='hidden_link' href='#footnote-133.sentence-1'>.</a></div></div></div></body></html>