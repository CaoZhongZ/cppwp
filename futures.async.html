<!DOCTYPE html><html lang='en'><head><title>[futures.async]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>30</a> Thread support library <a class='abbr_ref' href='./#thread'>[thread]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>30.6</a> Futures <a class='abbr_ref' href='futures#async'>[futures]</a></h2><div id='futures.async'><h3 ><a class='secnum' style='min-width:103pt'>30.6.8</a> Function template <span class='texttt'>async</span> <a class='abbr_ref'>[futures.async]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The function template <span class='texttt'>async</span> provides a mechanism to launch a function potentially
in a new thread and provides the result of the function in a <span class='texttt'>future</span> object with which
it shares a shared state.</p><p ><span class='indexparent'><a class='index' id='async'></a></span><code class='itemdecl'>
template &lt;class F, class... Args&gt;
  future&lt;result_of_t&lt;decay_t&lt;F&gt;(decay_t&lt;Args&gt;...)&gt;&gt; async(F&amp;&amp; f, Args&amp;&amp;... args);
template &lt;class F, class... Args&gt;
  future&lt;result_of_t&lt;decay_t&lt;F&gt;(decay_t&lt;Args&gt;...)&gt;&gt; async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args);
</code></p></div><div class='itemdescr'></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>F</span> and each <span class='texttt'>Ti</span> in <span class='texttt'>Args</span> shall
satisfy the
<span class='texttt'>MoveConstructible</span> requirements.
<span class='texttt'><i>INVOKE</i>(<i>DECAY_COPY</i>(std::forward&lt;F&gt;(f)),
<i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...)</span>
(<a href='func.require'>[func.require]</a>, <a href='thread.thread.constr'>[thread.thread.constr]</a>) shall be a valid expression.</p></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
The first function
behaves the same as a call to the second function with a <span class='texttt'>policy</span> argument of
<span class='texttt'>launch::async | launch::deferred</span>
and the same arguments for <span class='texttt'>F</span> and <span class='texttt'>Args</span>.
The second function creates a shared state that is associated with
the returned <span class='texttt'>future</span> object.
The further behavior
of the second function depends on the <span class='texttt'>policy</span> argument as follows (if
more than one of these conditions applies, the implementation may choose any of
the corresponding policies):</p><ul ><li ><p >if <span class='texttt'>policy &amp; launch::async</span> is non-zero — calls
<span class='texttt'><i>INVOKE</i>(<i>DECAY_COPY</i>(std::forward&lt;F&gt;(f)),</span><br/> 
<span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...)</span>
(<a href='func.require'>[func.require]</a>, <a href='thread.thread.constr'>[thread.thread.constr]</a>)
as if in a new thread of execution represented by a <span class='texttt'>thread</span> object
with the calls to <span class='texttt'><i>DECAY_COPY</i>()</span> being evaluated in the thread that called <span class='texttt'>async</span>.
Any return value
is stored as the result in the
shared state. Any exception propagated from
the execution of
<span class='texttt'><i>INVOKE</i>(<i>DECAY_COPY</i>(std::forward&lt;F&gt;(f)),
<i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...)</span>
is stored as the exceptional result in the shared state.
The <span class='texttt'>thread</span> object is
stored in the shared state
and affects the behavior of any asynchronous return objects that
reference that state.</p></li><li ><p >if <span class='texttt'>policy &amp; launch::deferred</span> is non-zero —
Stores <span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;F&gt;(f))</span> and<br/>
<span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...</span>
in the shared state. These copies of <span class='texttt'>f</span> and <span class='texttt'>args</span> constitute
a <a id='deferred function'><i>deferred function</i></a>. Invocation of the deferred function evaluates
<span class='texttt'><i>INVOKE</i>(std::move(g), std::move(xyz))</span> where <span class='texttt'>g</span> is the stored value of 
<span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;F&gt;(f))</span> and <span class='texttt'>xyz</span> is the stored copy of
<span class='texttt'><i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...</span>.
Any return value is stored
as the result in the shared state.
Any exception propagated
from the execution
of the deferred function
is stored as the exceptional result
in the shared state.
The shared state is not
made ready until the function has completed. The first call to a
non-timed waiting function (<a href='futures.state'>[futures.state]</a>)
on an asynchronous return object referring to
this shared state shall invoke the
deferred function in the thread that called the waiting function.
Once evaluation of <span class='texttt'><i>INVOKE</i>(std::move(g), std::move(xyz))</span> begins, the function is no longer
considered deferred.
[&nbsp;<i>Note:</i><span class='space'></span> If this policy is specified together with other policies, such as when using a
<span class='texttt'>policy</span> value of <span class='texttt'>launch::async | launch::deferred</span>, implementations should defer
invocation or the selection of the policy when no more concurrency can be effectively
exploited. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li ><p >If no value is set in the launch policy, or a value is set that is neither specified
in this International Standard or by the implementation, the behavior is undefined.
</p></li></ul></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> An object of type
<span class='texttt'>future&lt;result_of_t&lt;decay_t&lt;F&gt;(decay_t&lt;Args&gt;...)&gt;&gt;</span> that refers
to the shared state created by this call to <span class='texttt'>async</span>.
[&nbsp;<i>Note:</i><span class='space'></span> If a future obtained from <span class='texttt'>std::async</span> is moved outside the local scope,
other code that uses the future must be aware that the future's destructor may
block for the shared state to become ready. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><p ><i>Synchronization:</i>
Regardless of the provided <span class='texttt'>policy</span> argument,
</p><ul ><li ><p >the invocation of <span class='texttt'>async</span>
synchronizes with (<a href='intro.multithread'>[intro.multithread]</a>) the invocation of <span class='texttt'>f</span>. [&nbsp;<i>Note:</i><span class='space'></span>
This statement applies even when the corresponding <span class='texttt'>future</span> object is moved to
another thread. <i>&nbsp;—&nbsp;end note</i>&nbsp;]; and</p></li><li ><p >the completion of the function <span class='texttt'>f</span> is sequenced before (<a href='intro.multithread'>[intro.multithread]</a>) the
shared state is made ready. [&nbsp;<i>Note:</i><span class='space'></span> <span class='texttt'>f</span> might not be called at all,
so its completion might never happen. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >If the implementation chooses the <span class='texttt'>launch::async</span> policy,</p><ul ><li ><p >a call to a waiting function on an asynchronous return
object that shares the shared state created by this <span class='texttt'>async</span> call shall
block until the associated thread has completed, as if joined, or else time
out (<a href='thread.thread.member'>[thread.thread.member]</a>);</p></li><li ><p >the associated thread completion
synchronizes with (<a href='intro.multithread'>[intro.multithread]</a>)
the return from
the first function
that successfully detects the ready status of the shared state or 
with the return from the last
function that releases the shared state, whichever
happens first.
</p></li></ul></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i> <span class='texttt'>system_error</span> if <span class='texttt'>policy == launch::async</span> and the
implementation is unable to start a new thread.</p></div></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><p ><i>Error conditions:</i>
</p><ul ><li ><p ><span class='texttt'>resource_unavailable_try_again</span> — if
<span class='texttt'>policy == launch::async</span> and the system is unable to start a new thread.
</p></li></ul></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
int work1(int value);
int work2(int value);
int work(int value) {
  auto handle = std::async([=]{ return work2(value); });
  int tmp = work1(value);
  return tmp + handle.get();    <span class='comment'>// #1
</span>}
</pre><p >[&nbsp;<i>Note:</i><span class='space'></span> Line #1 might not result in concurrency because
the <span class='texttt'>async</span> call uses the default policy, which may use
<span class='texttt'>launch::deferred</span>, in which case the lambda might not be invoked until the
<span class='texttt'>get()</span> call; in that case, <span class='texttt'>work1</span> and <span class='texttt'>work2</span> are called on the
same thread and there is no concurrency.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></body></html>