<!DOCTYPE html><html lang='en'><head><title>[variant]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><div id='variant'><h2 ><a class='secnum' style='min-width:88pt'>20.7</a> Variants <a class='abbr_ref'>[variant]</a></h2><div id='general'><h3 ><a class='secnum' href='#general' style='min-width:103pt'>20.7.1</a> In general <a class='abbr_ref' href='variant.general'>[variant.general]</a></h3><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p >A variant object holds and manages the lifetime of a value.
If the <span class='texttt'>variant</span> holds a value, that value's type has to be one
of the template argument types given to variant.
These template arguments are called alternatives.</p><p ><span class='indexparent'><a class='index' id='variant'></a></span><b>Header <span class='texttt'>&lt;variant&gt;</span> synopsis</b></p><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='variant.variant'>[variant.variant]</a>, variant
</span>  template &lt;class... Types&gt; class variant;

  <span class='comment'>// <a href='variant.helper'>[variant.helper]</a>, variant helper classes
</span>  template &lt;class T&gt; struct variant_size; <span class='comment'>// undefined
</span>  template &lt;class T&gt; struct variant_size&lt;const T&gt;;
  template &lt;class T&gt; struct variant_size&lt;volatile T&gt;;
  template &lt;class T&gt; struct variant_size&lt;const volatile T&gt;;
  template &lt;class T&gt; constexpr size_t variant_size_v
    = variant_size&lt;T&gt;::value;

  template &lt;class... Types&gt;
    struct variant_size&lt;variant&lt;Types...&gt;&gt;;

  template &lt;size_t I, class T&gt; struct variant_alternative; <span class='comment'>// undefined
</span>  template &lt;size_t I, class T&gt; struct variant_alternative&lt;I, const T&gt;;
  template &lt;size_t I, class T&gt; struct variant_alternative&lt;I, volatile T&gt;;
  template &lt;size_t I, class T&gt; struct variant_alternative&lt;I, const volatile T&gt;;
  template &lt;size_t I, class T&gt;
    using variant_alternative_t = typename variant_alternative&lt;I, T&gt;::type;

  template &lt;size_t I, class... Types&gt;
    struct variant_alternative&lt;I, variant&lt;Types...&gt;&gt;;

  constexpr size_t variant_npos = -1;

  <span class='comment'>// <a href='variant.get'>[variant.get]</a>, value access
</span>  template &lt;class T, class... Types&gt;
    constexpr bool holds_alternative(const variant&lt;Types...&gt;&amp;) noexcept;

  template &lt;size_t I, class... Types&gt;
    constexpr variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp;
    get(variant&lt;Types...&gt;&amp;);
  template &lt;size_t I, class... Types&gt;
    constexpr variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp;&amp;
    get(variant&lt;Types...&gt;&amp;&amp;);
  template &lt;size_t I, class... Types&gt;
    constexpr variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt; const&amp;
    get(const variant&lt;Types...&gt;&amp;);
  template &lt;size_t I, class... Types&gt;
    constexpr variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt; const&amp;&amp;
    get(const variant&lt;Types...&gt;&amp;&amp;);

  template &lt;class T, class... Types&gt;
    constexpr T&amp; get(variant&lt;Types...&gt;&amp;);
  template &lt;class T, class... Types&gt;
    constexpr T&amp;&amp; get(variant&lt;Types...&gt;&amp;&amp;);
  template &lt;class T, class... Types&gt;
    constexpr const T&amp; get(const variant&lt;Types...&gt;&amp;);
  template &lt;class T, class... Types&gt;
    constexpr const T&amp;&amp; get(const variant&lt;Types...&gt;&amp;&amp;);

  template &lt;size_t I, class... Types&gt;
    constexpr add_pointer_t&lt;variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&gt;
    get_if(variant&lt;Types...&gt;*) noexcept;
  template &lt;size_t I, class... Types&gt;
    constexpr add_pointer_t&lt;const variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&gt;
    get_if(const variant&lt;Types...&gt;*) noexcept;

  template &lt;class T, class... Types&gt;
    constexpr add_pointer_t&lt;T&gt; get_if(variant&lt;Types...&gt;*) noexcept;
  template &lt;class T, class... Types&gt;
    constexpr add_pointer_t&lt;const T&gt; get_if(const variant&lt;Types...&gt;*) noexcept;

  <span class='comment'>// <a href='variant.relops'>[variant.relops]</a>, relational operators
</span>  template &lt;class... Types&gt;
    constexpr bool operator==(const variant&lt;Types...&gt;&amp;,
                              const variant&lt;Types...&gt;&amp;);
  template &lt;class... Types&gt;
    constexpr bool operator!=(const variant&lt;Types...&gt;&amp;,
                              const variant&lt;Types...&gt;&amp;);
  template &lt;class... Types&gt;
    constexpr bool operator&lt;(const variant&lt;Types...&gt;&amp;,
                             const variant&lt;Types...&gt;&amp;);
  template &lt;class... Types&gt;
    constexpr bool operator&gt;(const variant&lt;Types...&gt;&amp;,
                             const variant&lt;Types...&gt;&amp;);
  template &lt;class... Types&gt;
    constexpr bool operator&lt;=(const variant&lt;Types...&gt;&amp;,
                              const variant&lt;Types...&gt;&amp;);
  template &lt;class... Types&gt;
    constexpr bool operator&gt;=(const variant&lt;Types...&gt;&amp;,
                              const variant&lt;Types...&gt;&amp;);

  <span class='comment'>// <a href='variant.visit'>[variant.visit]</a>, visitation
</span>  template &lt;class Visitor, class... Variants&gt;
  constexpr <i><span class='texttt'>see below</span></i> visit(Visitor&amp;&amp;, Variants&amp;&amp;...);

  <span class='comment'>// <a href='variant.monostate'>[variant.monostate]</a>, class <span class='texttt'>monostate</span>
</span>  struct monostate;

  <span class='comment'>// <a href='variant.monostate.relops'>[variant.monostate.relops]</a>, <span class='texttt'>monostate</span> relational operators
</span>  constexpr bool operator&lt;(monostate, monostate) noexcept;
  constexpr bool operator&gt;(monostate, monostate) noexcept;
  constexpr bool operator&lt;=(monostate, monostate) noexcept;
  constexpr bool operator&gt;=(monostate, monostate) noexcept;
  constexpr bool operator==(monostate, monostate) noexcept;
  constexpr bool operator!=(monostate, monostate) noexcept;

  <span class='comment'>// <a href='variant.specalg'>[variant.specalg]</a>, specialized algorithms
</span>  template &lt;class... Types&gt;
  void swap(variant&lt;Types...&gt;&amp;, variant&lt;Types...&gt;&amp;) noexcept(<i><span class='texttt'>see below</span></i>);

  <span class='comment'>// <a href='variant.bad.access'>[variant.bad.access]</a>, class <span class='texttt'>bad_variant_access</span>
</span>  class bad_variant_access;

  <span class='comment'>// <a href='variant.hash'>[variant.hash]</a>, hash support
</span>  template &lt;class T&gt; struct hash;
  template &lt;class... Types&gt; struct hash&lt;variant&lt;Types...&gt;&gt;;
  template &lt;&gt; struct hash&lt;monostate&gt;;

  <span class='comment'>// <a href='variant.traits'>[variant.traits]</a>, allocator-related traits
</span>  template &lt;class T, class Alloc&gt; struct uses_allocator;
  template &lt;class... Types, class Alloc&gt;
  struct uses_allocator&lt;variant&lt;Types...&gt;, Alloc&gt;;
} <span class='comment'>// namespace std
</span></pre><p ><span class='indexparent'><a class='index' id='variant'></a></span></p></div></div><div id='variant'><h3 ><a class='secnum' href='#variant' style='min-width:103pt'>20.7.2</a> Class template <span class='texttt'>variant</span> <a class='abbr_ref' href='variant.variant'>[variant.variant]</a></h3><pre class='codeblock'>
namespace std {
  template &lt;class... Types&gt;
  class variant {
  public:
    <span class='comment'>// <a href='variant.ctor'>[variant.ctor]</a>, constructors
</span>    constexpr variant() noexcept(<i><span class='texttt'>see below</span></i>);
    variant(const variant&amp;);
    variant(variant&amp;&amp;) noexcept(<i><span class='texttt'>see below</span></i>);

    template &lt;class T&gt; constexpr variant(T&amp;&amp;) noexcept(<i><span class='texttt'>see below</span></i>);

    template &lt;class T, class... Args&gt;
      constexpr explicit variant(in_place_type_t&lt;T&gt;, Args&amp;&amp;...);
    template &lt;class T, class U, class... Args&gt;
      constexpr explicit variant(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt;, Args&amp;&amp;...);

    template &lt;size_t I, class... Args&gt;
      constexpr explicit variant(in_place_index_t&lt;I&gt;, Args&amp;&amp;...);
    template &lt;size_t I, class U, class... Args&gt;
      constexpr explicit variant(in_place_index_t&lt;I&gt;, initializer_list&lt;U&gt;, Args&amp;&amp;...);

    <span class='comment'>// allocator-extended constructors
</span>    template &lt;class Alloc&gt;
      variant(allocator_arg_t, const Alloc&amp;);
    template &lt;class Alloc&gt;
      variant(allocator_arg_t, const Alloc&amp;, const variant&amp;);
    template &lt;class Alloc&gt;
      variant(allocator_arg_t, const Alloc&amp;, variant&amp;&amp;);
    template &lt;class Alloc, class T&gt;
      variant(allocator_arg_t, const Alloc&amp;, T&amp;&amp;);
    template &lt;class Alloc, class T, class... Args&gt;
      variant(allocator_arg_t, const Alloc&amp;, in_place_type_t&lt;T&gt;, Args&amp;&amp;...);
    template &lt;class Alloc, class T, class U, class... Args&gt;
      variant(allocator_arg_t, const Alloc&amp;, in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt;, Args&amp;&amp;...);
    template &lt;class Alloc, size_t I, class... Args&gt;
      variant(allocator_arg_t, const Alloc&amp;, in_place_index_t&lt;I&gt;, Args&amp;&amp;...);
    template &lt;class Alloc, size_t I, class U, class... Args&gt;
      variant(allocator_arg_t, const Alloc&amp;, in_place_index_t&lt;I&gt;, initializer_list&lt;U&gt;, Args&amp;&amp;...);

    <span class='comment'>// <a href='variant.dtor'>[variant.dtor]</a>, destructor
</span>    ~variant();

    <span class='comment'>// <a href='variant.assign'>[variant.assign]</a>, assignment
</span>    variant&amp; operator=(const variant&amp;);
    variant&amp; operator=(variant&amp;&amp;) noexcept(<i><span class='texttt'>see below</span></i>);

    template &lt;class T&gt; variant&amp; operator=(T&amp;&amp;) noexcept(<i><span class='texttt'>see below</span></i>);

    <span class='comment'>// <a href='variant.mod'>[variant.mod]</a>, modifiers
</span>    template &lt;class T, class... Args&gt; void emplace(Args&amp;&amp;...);
    template &lt;class T, class U, class... Args&gt;
      void emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
    template &lt;size_t I, class... Args&gt; void emplace(Args&amp;&amp;...);
    template &lt;size_t I, class U, class... Args&gt;
      void emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);

    <span class='comment'>// <a href='variant.status'>[variant.status]</a>, value status
</span>    constexpr bool valueless_by_exception() const noexcept;
    constexpr size_t index() const noexcept;

    <span class='comment'>// <a href='variant.swap'>[variant.swap]</a>, swap
</span>    void swap(variant&amp;) noexcept(<i><span class='texttt'>see below</span></i>);
  };
} <span class='comment'>// namespace std
</span></pre><div class='para' id='variant-1'><div class='marginalizedparent'><a class='marginalized' href='#variant-1'>1</a></div><p >Any instance of <span class='texttt'>variant</span> at any given time either holds a value
of one of its alternative types, or it holds no value.
When an instance of <span class='texttt'>variant</span> holds a value of alternative type <span class='texttt'>T</span>,
it means that a value of type <span class='texttt'>T</span>, referred to as the <span class='texttt'>variant</span>
object's contained value, is allocated within the storage of the
<span class='texttt'>variant</span> object.
Implementations are not permitted to use additional storage, such as dynamic
memory, to allocate the contained value.
The contained value shall be allocated in a region of the <span class='texttt'>variant</span>
storage suitably aligned for all types in <span class='texttt'>Types...</span>.
It is <span class='indexparent'><a class='index' id='whether_variant_supports_over-aligned_types'></a></span>implementation-defined
whether over-aligned types are supported.</p></div><div class='para' id='variant-2'><div class='marginalizedparent'><a class='marginalized' href='#variant-2'>2</a></div><p >All types in <span class='texttt'>Types...</span> shall be (possibly cv-qualified)
object types, (possibly cv-qualified) <span class='texttt'>void</span>, or references.
[&nbsp;<i>Note:</i><span class='space'></span>
Implementations could decide to store references in a wrapper.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='ctor'><h4 ><a class='secnum' href='#ctor' style='min-width:118pt'>20.7.2.1</a> Constructors <a class='abbr_ref' href='variant.ctor'>[variant.ctor]</a></h4><div class='para' id='ctor-1'><div class='marginalizedparent'><a class='marginalized' href='#ctor-1'>1</a></div><p >In the descriptions that follow, let <span class='math'><span class='mathalpha'>i</span></span> be in the range <span class='texttt'>[0, <span class='discretionary'></span>sizeof...(Types))</span>,
and <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> be the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> type in <span class='texttt'>Types...</span>.</p><p ><span class='indexparent'><a class='index' id='variant,constructor'></a></span><code class='itemdecl'>
constexpr variant() noexcept(<i><span class='texttt'>see below</span></i>);
</code></p></div><div class='itemdescr'></div><div class='para' id='ctor-2'><div class='marginalizedparent'><a class='marginalized' href='#ctor-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a <span class='texttt'>variant</span> holding a value-initialized value of type <span class='math'><span class='mathalpha'>T</span><sub >0</sub></span>.</p></div></div><div class='para' id='ctor-3'><div class='marginalizedparent'><a class='marginalized' href='#ctor-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>valueless_by_exception()</span> is <span class='texttt'>false</span> and <span class='texttt'>index()</span> is <span class='texttt'>0</span>.</p></div></div><div class='para' id='ctor-4'><div class='marginalizedparent'><a class='marginalized' href='#ctor-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i>
Any exception thrown by the value initialization of <span class='math'><span class='mathalpha'>T</span><sub >0</sub></span>.</p></div></div><div class='para' id='ctor-5'><div class='marginalizedparent'><a class='marginalized' href='#ctor-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall be <span class='texttt'>constexpr</span> if and only if the
value-initialization of the alternative type <span class='math'><span class='mathalpha'>T</span><sub >0</sub></span> would satisfy the
requirements for a <span class='texttt'>constexpr</span> function.
The expression inside <span class='texttt'>noexcept</span> is equivalent to
<span class='texttt'>is_nothrow_default_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub >0</sub></span>&gt;</span>.
This function shall not participate in overload resolution unless
<span class='texttt'>is_default_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub >0</sub></span>&gt;</span> is <span class='texttt'>true</span>.
[&nbsp;<i>Note:</i><span class='space'></span> See also class <span class='texttt'>monostate</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='variant,constructor'></a></span><code class='itemdecl'>
variant(const variant&amp; w);
</code></p><div class='itemdescr'></div><div class='para' id='ctor-6'><div class='marginalizedparent'><a class='marginalized' href='#ctor-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
If <span class='texttt'>w</span> holds a value, initializes the <span class='texttt'>variant</span> to hold the same
alternative as <span class='texttt'>w</span> and direct-initializes the contained value
with <span class='texttt'>get&lt;j&gt;(w)</span>, where <span class='texttt'>j</span> is <span class='texttt'>w.index()</span>.
Otherwise, initializes the <span class='texttt'>variant</span> to not hold a value.</p></div></div><div class='para' id='ctor-7'><div class='marginalizedparent'><a class='marginalized' href='#ctor-7'>7</a></div><div class='itemdescr'><p ><i>Throws:</i>
Any exception thrown by direct-initializing any <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='ctor-8'><div class='marginalizedparent'><a class='marginalized' href='#ctor-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution unless
<span class='texttt'>is_copy_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;</span> is <span class='texttt'>true</span> for all <span class='math'><span class='mathalpha'>i</span></span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='variant,constructor'></a></span><code class='itemdecl'>
variant(variant&amp;&amp; w) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='ctor-9'><div class='marginalizedparent'><a class='marginalized' href='#ctor-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
If <span class='texttt'>w</span> holds a value, initializes the <span class='texttt'>variant</span> to hold the same
alternative as <span class='texttt'>w</span> and direct-initializes the contained value with
<span class='texttt'>get&lt;j&gt;(std::move(w))</span>, where <span class='texttt'>j</span> is <span class='texttt'>w.index()</span>.
Otherwise, initializes the <span class='texttt'>variant</span> to not hold a value.</p></div></div><div class='para' id='ctor-10'><div class='marginalizedparent'><a class='marginalized' href='#ctor-10'>10</a></div><div class='itemdescr'><p ><i>Throws:</i>
Any exception thrown by move-constructing any <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='ctor-11'><div class='marginalizedparent'><a class='marginalized' href='#ctor-11'>11</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The expression inside <span class='texttt'>noexcept</span> is equivalent to the logical AND of
<span class='texttt'>is_nothrow_move_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;</span> for all <span class='math'><span class='mathalpha'>i</span></span>.
This function shall not participate in overload resolution unless
<span class='texttt'>is_move_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;</span> is <span class='texttt'>true</span> for all <span class='math'><span class='mathalpha'>i</span></span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='variant,constructor'></a></span><code class='itemdecl'>
template &lt;class T&gt; constexpr variant(T&amp;&amp; t) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='ctor-12'><div class='marginalizedparent'><a class='marginalized' href='#ctor-12'>12</a></div><div class='itemdescr'><p >Let <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span> be a type that is determined as follows:
build an imaginary function <span class='texttt'><i>FUN</i>(<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>)</span> for each alternative type <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>. The overload <span class='texttt'><i>FUN</i>(<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>)</span> selected by overload
resolution for the expression <span class='texttt'><i>FUN</i>(std::forward&lt;T&gt;(<span class='discretionary'></span>t))</span> defines
the alternative <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span> which is the type of the contained value after
construction.</p></div></div><div class='para' id='ctor-13'><div class='marginalizedparent'><a class='marginalized' href='#ctor-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes <span class='texttt'>*this</span> to hold the alternative type <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span> and
direct-initializes the contained value as if direct-non-list-initializing it
with <span class='texttt'>std::forward&lt;T&gt;(t)</span>.</p></div></div><div class='para' id='ctor-14'><div class='marginalizedparent'><a class='marginalized' href='#ctor-14'>14</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>holds_alternative&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>&gt;(*this)</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='ctor-15'><div class='marginalizedparent'><a class='marginalized' href='#ctor-15'>15</a></div><div class='itemdescr'><p ><i>Throws:</i>
Any exception thrown by the initialization of the selected alternative <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>.</p></div></div><div class='para' id='ctor-16'><div class='marginalizedparent'><a class='marginalized' href='#ctor-16'>16</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution unless
<span class='texttt'>is_same_v&lt;decay_t&lt;T&gt;, variant&gt;</span> is <span class='texttt'>false</span>, unless <span class='texttt'>is_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>, T&gt;</span> is <span class='texttt'>true</span>, and unless the expression
<span class='texttt'><i>FUN</i>(</span><span class='discretionary'></span><span class='texttt'>std::forward&lt;T&gt;(t))</span> (with <span class='texttt'><i>FUN</i></span>
being the above-mentioned set of imaginary functions) is well formed.</p></div></div><div class='para' id='ctor-17'><div class='marginalizedparent'><a class='marginalized' href='#ctor-17'>17</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span>
</p><pre class='codeblock'>
variant&lt;string, string&gt; v("abc");
</pre><p >is ill-formed, as both alternative types have an equally viable constructor
for the argument. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='ctor-18'><div class='marginalizedparent'><a class='marginalized' href='#ctor-18'>18</a></div><div class='itemdescr'><p >The expression inside <span class='texttt'>noexcept</span> is equivalent to
<span class='texttt'>is_nothrow_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>, T&gt;</span>.
If <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>'s selected constructor is a constexpr constructor,
this constructor shall be a constexpr constructor.
</p></div></div><p ><span class='indexparent'><a class='index' id='variant,constructor'></a></span><code class='itemdecl'>
template &lt;class T, class... Args&gt; constexpr explicit variant(in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='ctor-19'><div class='marginalizedparent'><a class='marginalized' href='#ctor-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes the contained value of type <span class='texttt'>T</span> with the arguments <span class='texttt'>std::forward&lt;Args&gt;(args)...</span>.</p></div></div><div class='para' id='ctor-20'><div class='marginalizedparent'><a class='marginalized' href='#ctor-20'>20</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>holds_alternative&lt;T&gt;(*this)</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='ctor-21'><div class='marginalizedparent'><a class='marginalized' href='#ctor-21'>21</a></div><div class='itemdescr'><p ><i>Throws:</i>
Any exception thrown by calling the selected constructor of <span class='texttt'>T</span>.</p></div></div><div class='para' id='ctor-22'><div class='marginalizedparent'><a class='marginalized' href='#ctor-22'>22</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution unless there is
exactly one occurrence of <span class='texttt'>T</span> in <span class='texttt'>Types...</span> and
<span class='texttt'>is_constructible_v&lt;T, Args...&gt;</span> is <span class='texttt'>true</span>.
If <span class='texttt'>T</span>'s selected constructor is a constexpr constructor, this
constructor shall be a constexpr constructor.
</p></div></div><p ><span class='indexparent'><a class='index' id='variant,constructor'></a></span><code class='itemdecl'>
template &lt;class T, class U, class... Args&gt;
  constexpr explicit variant(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='ctor-23'><div class='marginalizedparent'><a class='marginalized' href='#ctor-23'>23</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes the contained value as if constructing an object of type <span class='texttt'>T</span>
with the arguments <span class='texttt'>il, std::forward&lt;Args&gt;(args)...</span>.</p></div></div><div class='para' id='ctor-24'><div class='marginalizedparent'><a class='marginalized' href='#ctor-24'>24</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>holds_alternative&lt;T&gt;(*this)</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='ctor-25'><div class='marginalizedparent'><a class='marginalized' href='#ctor-25'>25</a></div><div class='itemdescr'><p ><i>Throws:</i>
Any exception thrown by calling the selected constructor of <span class='texttt'>T</span>.</p></div></div><div class='para' id='ctor-26'><div class='marginalizedparent'><a class='marginalized' href='#ctor-26'>26</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution unless there is
exactly one occurrence of <span class='texttt'>T</span> in <span class='texttt'>Types...</span> and
<span class='texttt'>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</span> is <span class='texttt'>true</span>.
If <span class='texttt'>T</span>'s selected constructor is a constexpr constructor, this
constructor shall be a constexpr constructor.
</p></div></div><p ><span class='indexparent'><a class='index' id='variant,constructor'></a></span><code class='itemdecl'>
template &lt;size_t I, class... Args&gt; constexpr explicit variant(in_place_index_t&lt;I&gt;, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='ctor-27'><div class='marginalizedparent'><a class='marginalized' href='#ctor-27'>27</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes the contained value as if constructing an object of type <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>I</span></sub></span>
with the arguments <span class='texttt'>std::forward&lt;Args&gt;(args)...</span>.</p></div></div><div class='para' id='ctor-28'><div class='marginalizedparent'><a class='marginalized' href='#ctor-28'>28</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>index()</span> is <span class='texttt'>I</span>.</p></div></div><div class='para' id='ctor-29'><div class='marginalizedparent'><a class='marginalized' href='#ctor-29'>29</a></div><div class='itemdescr'><p ><i>Throws:</i>
Any exception thrown by calling the selected constructor of <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>I</span></sub></span>.</p></div></div><div class='para' id='ctor-30'><div class='marginalizedparent'><a class='marginalized' href='#ctor-30'>30</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution unless <span class='texttt'>I</span> is
less than <span class='texttt'>sizeof...(Types)</span> and <span class='texttt'>is_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>I</span></sub></span>, Args...&gt;</span> is <span class='texttt'>true</span>.
If <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>I</span></sub></span>'s selected constructor is a <span class='texttt'>constexpr</span> constructor, this
constructor shall be a constexpr constructor.
</p></div></div><p ><span class='indexparent'><a class='index' id='variant,constructor'></a></span><code class='itemdecl'>
template &lt;size_t I, class U, class... Args&gt;
  constexpr explicit variant(in_place_index_t&lt;I&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='ctor-31'><div class='marginalizedparent'><a class='marginalized' href='#ctor-31'>31</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes the contained value as if constructing an object of type
<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>I</span></sub></span> with the arguments <span class='texttt'>il, std::forward&lt;Args&gt;(args)...</span>.</p></div></div><div class='para' id='ctor-32'><div class='marginalizedparent'><a class='marginalized' href='#ctor-32'>32</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>index()</span> is <span class='texttt'>I</span>.</p></div></div><div class='para' id='ctor-33'><div class='marginalizedparent'><a class='marginalized' href='#ctor-33'>33</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution unless <span class='texttt'>I</span> is
less than <span class='texttt'>sizeof...(Types)</span> and
<span class='texttt'>is_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>I</span></sub></span>, initializer_list&lt;U&gt;&amp;, Args...&gt;</span> is <span class='texttt'>true</span>.
If <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>I</span></sub></span>'s selected constructor is a <span class='texttt'>constexpr</span> constructor, this
constructor shall be a constexpr constructor.
</p></div></div><p ><span class='indexparent'><a class='index' id='variant,constructor'></a></span><code class='itemdecl'>
<span class='comment'>// allocator-extended constructors
</span>template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp; a);
template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp; a, const variant&amp; v);
template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp; a, variant&amp;&amp; v);
template &lt;class Alloc, class T&gt;
  variant(allocator_arg_t, const Alloc&amp; a, T&amp;&amp; t);
template &lt;class Alloc, class T, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp; a, in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);
template &lt;class Alloc, class T, class U, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp; a, in_place_type_t&lt;T&gt;,
          initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
template &lt;class Alloc, size_t I, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp; a, in_place_index_t&lt;I&gt;, Args&amp;&amp;... args);
template &lt;class Alloc, size_t I, class U, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp; a, in_place_index_t&lt;I&gt;,
          initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='ctor-34'><div class='marginalizedparent'><a class='marginalized' href='#ctor-34'>34</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>Alloc</span> shall meet the requirements for an Allocator (<a href='allocator.requirements'>[allocator.requirements]</a>).</p></div></div><div class='para' id='ctor-35'><div class='marginalizedparent'><a class='marginalized' href='#ctor-35'>35</a></div><div class='itemdescr'><p ><i>Effects:</i>
Equivalent to the preceding constructors except that the contained value is
constructed with uses-allocator construction (<a href='allocator.uses.construction'>[allocator.uses.construction]</a>).
</p></div></div></div><div id='dtor'><h4 ><a class='secnum' href='#dtor' style='min-width:118pt'>20.7.2.2</a> Destructor <a class='abbr_ref' href='variant.dtor'>[variant.dtor]</a></h4><p ><span class='indexparent'><a class='index' id='variant,destructor'></a></span><code class='itemdecl'>
~variant();
</code></p><div class='itemdescr'></div><div class='para' id='dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
If <span class='texttt'>valueless_by_exception()</span> is <span class='texttt'>false</span>,
destroys the currently contained value.</p></div></div><div class='para' id='dtor-2'><div class='marginalizedparent'><a class='marginalized' href='#dtor-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If <span class='texttt'>is_trivially_destructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt; == true</span> for all <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>
then this destructor shall be a trivial destructor.
</p></div></div></div><div id='assign'><h4 ><a class='secnum' href='#assign' style='min-width:118pt'>20.7.2.3</a> Assignment <a class='abbr_ref' href='variant.assign'>[variant.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,variant'></a></span><span class='indexparent'><a class='index' id='variant,operator='></a></span><code class='itemdecl'>
variant&amp; operator=(const variant&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='assign-1'><div class='marginalizedparent'><a class='marginalized' href='#assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >If neither <span class='texttt'>*this</span> nor <span class='texttt'>rhs</span> holds a value, there is no effect.  Otherwise,
</p></li><li ><p >if <span class='texttt'>*this</span> holds a value but <span class='texttt'>rhs</span> does not, destroys the value
contained in <span class='texttt'>*this</span> and sets <span class='texttt'>*this</span> to not hold a value.  Otherwise,
</p></li><li ><p >if <span class='texttt'>index() == rhs.index()</span>, assigns the value contained in <span class='texttt'>rhs</span>
to the value contained in <span class='texttt'>*this</span>. Otherwise,
</p></li><li ><p >copies the value contained in <span class='texttt'>rhs</span> to a temporary, then destroys any
value contained in <span class='texttt'>*this</span>. Sets <span class='texttt'>*this</span> to hold the same
alternative index as <span class='texttt'>rhs</span> and initializes the value contained in
<span class='texttt'>*this</span> as if direct-non-list-initializing an object of type <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>
with <span class='texttt'>std::forward&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>&gt;(TMP),</span> with <span class='texttt'>TMP</span> being the temporary and
<span class='math'><span class='mathalpha'>j</span></span> being <span class='texttt'>rhs.index()</span>.
</p></li></ul></div></div><div class='para' id='assign-2'><div class='marginalizedparent'><a class='marginalized' href='#assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.</p></div></div><div class='para' id='assign-3'><div class='marginalizedparent'><a class='marginalized' href='#assign-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>index() == rhs.index()</span>.</p></div></div><div class='para' id='assign-4'><div class='marginalizedparent'><a class='marginalized' href='#assign-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution unless
<span class='texttt'>is_copy_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt; &amp;&amp; is_move_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt; &amp;&amp; is_copy_assignable_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;</span>
is <span class='texttt'>true</span> for all <span class='math'><span class='mathalpha'>i</span></span>.
If an exception is thrown during the call to <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>'s copy assignment,
the state of the contained value is as defined by the exception safety
guarantee of <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>'s copy assignment; <span class='texttt'>index()</span> will be <span class='math'><span class='mathalpha'>j</span></span>.
If an exception is thrown during the call to <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>'s copy construction
(with <span class='math'><span class='mathalpha'>j</span></span> being <span class='texttt'>rhs.index()</span>), <span class='texttt'>*this</span> will remain unchanged.
If an exception is thrown during the call to <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>'s move construction,
the <span class='texttt'>variant</span> will hold no value.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,variant'></a></span><span class='indexparent'><a class='index' id='variant,operator='></a></span><code class='itemdecl'>
variant&amp; operator=(variant&amp;&amp; rhs) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='assign-5'><div class='marginalizedparent'><a class='marginalized' href='#assign-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >If neither <span class='texttt'>*this</span> nor <span class='texttt'>rhs</span> holds a value, there is no effect. Otherwise,
</p></li><li ><p >if <span class='texttt'>*this</span> holds a value but <span class='texttt'>rhs</span> does not, destroys the value
contained in <span class='texttt'>*this</span> and sets <span class='texttt'>*this</span> to not hold a value. Otherwise,
</p></li><li ><p >if <span class='texttt'>index() == rhs.index()</span>, assigns <span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>j</span></span>&gt;(std::move(rhs))</span> to
the value contained in <span class='texttt'>*this</span>, with <span class='math'><span class='mathalpha'>j</span></span> being <span class='texttt'>index()</span>. Otherwise,
</p></li><li ><p >destroys any value contained in <span class='texttt'>*this</span>. Sets <span class='texttt'>*this</span> to hold the
same alternative index as <span class='texttt'>rhs</span> and initializes the value contained in
<span class='texttt'>*this</span> as if direct-non-list-initializing an object of type <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>
with <span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>j</span></span>&gt;(std::move(rhs))</span> with <span class='math'><span class='mathalpha'>j</span></span> being <span class='texttt'>rhs.index()</span>.
</p></li></ul></div></div><div class='para' id='assign-6'><div class='marginalizedparent'><a class='marginalized' href='#assign-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.</p></div></div><div class='para' id='assign-7'><div class='marginalizedparent'><a class='marginalized' href='#assign-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution unless
<span class='texttt'>is_move_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt; &amp;&amp; is_move_assignable_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;</span> is
<span class='texttt'>true</span> for all <span class='math'><span class='mathalpha'>i</span></span>.
The expression inside <span class='texttt'>noexcept</span> is equivalent to:
<span class='texttt'>is_nothrow_move_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt; &amp;&amp; is_nothrow_move_assignable_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;</span> for all <span class='math'><span class='mathalpha'>i</span></span>.
If an exception is thrown during the call to <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>'s move construction
(with <span class='math'><span class='mathalpha'>j</span></span> being <span class='texttt'>rhs.index())</span>, the <span class='texttt'>variant</span> will hold no value.
If an exception is thrown during the call to <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>'s move assignment,
the state of the contained value is as defined by the exception safety
guarantee of <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>'s move assignment; <span class='texttt'>index()</span> will be <span class='math'><span class='mathalpha'>j</span></span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,variant'></a></span><span class='indexparent'><a class='index' id='variant,operator='></a></span><code class='itemdecl'>
template &lt;class T&gt; variant&amp; operator=(T&amp;&amp; t) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='assign-8'><div class='marginalizedparent'><a class='marginalized' href='#assign-8'>8</a></div><div class='itemdescr'><p >Let <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span> be a type that is determined as follows:
build an imaginary function <span class='texttt'><i>FUN</i>(<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>)</span> for each alternative type
<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>. The overload <span class='texttt'><i>FUN</i>(<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>)</span> selected by overload
resolution for the expression <span class='texttt'><i>FUN</i>(std::forward&lt;T&gt;(<span class='discretionary'></span>t))</span> defines
the alternative <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span> which is the type of the contained value after
assignment.</p></div></div><div class='para' id='assign-9'><div class='marginalizedparent'><a class='marginalized' href='#assign-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i>
If <span class='texttt'>*this</span> holds a <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>, assigns <span class='texttt'>std::forward&lt;T&gt;(t)</span> to
the value contained in <span class='texttt'>*this</span>. Otherwise, destroys any value contained
in <span class='texttt'>*this</span>, sets <span class='texttt'>*this</span> to hold the alternative type <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>
as selected by the imaginary function overload resolution described above,
and direct-initializes the contained value as if direct-non-list-initializing
it with <span class='texttt'>std::forward&lt;T&gt;(t)</span>.</p></div></div><div class='para' id='assign-10'><div class='marginalizedparent'><a class='marginalized' href='#assign-10'>10</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>holds_alternative&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>&gt;(*this)</span> is <span class='texttt'>true</span>, with <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>
selected by the imaginary function overload resolution described above.</p></div></div><div class='para' id='assign-11'><div class='marginalizedparent'><a class='marginalized' href='#assign-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.</p></div></div><div class='para' id='assign-12'><div class='marginalizedparent'><a class='marginalized' href='#assign-12'>12</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution unless
<span class='texttt'>is_same_v&lt;decay_t&lt;T&gt;, variant&gt;</span> is <span class='texttt'>false</span>, unless
<span class='texttt'>is_assignable_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>&amp;, T&gt; &amp;&amp; is_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>, T&gt;</span> is <span class='texttt'>true</span>,
and unless the expression <span class='texttt'><i>FUN</i>(std::forward&lt;T&gt;(t))</span> (with
<span class='texttt'><i>FUN</i></span> being the above-mentioned set of imaginary functions)
is well formed.</p></div></div><div class='para' id='assign-13'><div class='marginalizedparent'><a class='marginalized' href='#assign-13'>13</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span>
</p><pre class='codeblock'>
variant&lt;string, string&gt; v;
v = "abc";
</pre><p >is ill-formed, as both alternative types have an equally viable constructor
for the argument. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='assign-14'><div class='marginalizedparent'><a class='marginalized' href='#assign-14'>14</a></div><div class='itemdescr'><p >The expression inside <span class='texttt'>noexcept</span> is equivalent to:
<span class='texttt'>is_nothrow_assignable_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>&amp;, T&gt; &amp;&amp; is_nothrow_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>j</span></sub></span>, T&gt;</span>.
If an exception is thrown during the assignment of <span class='texttt'>std::forward&lt;T&gt;(t)</span>
to the value contained in <span class='texttt'>*this</span>, the state of the contained value and
<span class='texttt'>t</span> are as defined by the exception safety guarantee of the assignment
expression; <span class='texttt'>valueless_by_exception()</span> will be <span class='texttt'>false</span>.
If an exception is thrown during the initialization of the contained value,
the <span class='texttt'>variant</span> object might not hold a value.
</p></div></div></div><div id='mod'><h4 ><a class='secnum' href='#mod' style='min-width:118pt'>20.7.2.4</a> Modifiers <a class='abbr_ref' href='variant.mod'>[variant.mod]</a></h4><p ><span class='indexparent'><a class='index' id='emplace,variant'></a></span><span class='indexparent'><a class='index' id='variant,emplace'></a></span><code class='itemdecl'>
template &lt;class T, class... Args&gt; void emplace(Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='mod-1'><div class='marginalizedparent'><a class='marginalized' href='#mod-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Equivalent to <span class='texttt'>emplace&lt;<span class='math'><span class='mathalpha'>I</span></span>&gt;(std::forward&lt;Args&gt;(args)...)</span> where <span class='math'><span class='mathalpha'>I</span></span>
is the zero-based index of <span class='texttt'>T</span> in <span class='texttt'>Types...</span>.</p></div></div><div class='para' id='mod-2'><div class='marginalizedparent'><a class='marginalized' href='#mod-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution unless
<span class='texttt'>is_constructible_v&lt;T, Args...&gt;</span> is <span class='texttt'>true</span>, and <span class='texttt'>T</span> occurs
exactly once in <span class='texttt'>Types...</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='emplace,variant'></a></span><span class='indexparent'><a class='index' id='variant,emplace'></a></span><code class='itemdecl'>
template &lt;class T, class U, class... Args&gt; void emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='mod-3'><div class='marginalizedparent'><a class='marginalized' href='#mod-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Equivalent to <span class='texttt'>emplace&lt;<span class='math'><span class='mathalpha'>I</span></span>&gt;(il, std::forward&lt;Args&gt;(args)...)</span> where
<span class='math'><span class='mathalpha'>I</span></span> is the zero-based index of <span class='texttt'>T</span> in <span class='texttt'>Types...</span>.</p></div></div><div class='para' id='mod-4'><div class='marginalizedparent'><a class='marginalized' href='#mod-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution unless
<span class='texttt'>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</span> is <span class='texttt'>true</span>,
and <span class='texttt'>T</span> occurs exactly once in <span class='texttt'>Types...</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='emplace,variant'></a></span><span class='indexparent'><a class='index' id='variant,emplace'></a></span><code class='itemdecl'>
template &lt;size_t I, class... Args&gt; void emplace(Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='mod-5'><div class='marginalizedparent'><a class='marginalized' href='#mod-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>I &lt; sizeof...(Types)</span>.</p></div></div><div class='para' id='mod-6'><div class='marginalizedparent'><a class='marginalized' href='#mod-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
Destroys the currently contained value if <span class='texttt'>valueless_by_exception()</span>
is <span class='texttt'>false</span>. Then direct-initializes the contained value as if
constructing a value of type <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>I</span></sub></span> with the arguments
<span class='texttt'>std::forward&lt;Args&gt;(args)...</span>.</p></div></div><div class='para' id='mod-7'><div class='marginalizedparent'><a class='marginalized' href='#mod-7'>7</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>index()</span> is <span class='texttt'>I</span>.</p></div></div><div class='para' id='mod-8'><div class='marginalizedparent'><a class='marginalized' href='#mod-8'>8</a></div><div class='itemdescr'><p ><i>Throws:</i>
Any exception thrown during the initialization of the contained value.</p></div></div><div class='para' id='mod-9'><div class='marginalizedparent'><a class='marginalized' href='#mod-9'>9</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution unless
<span class='texttt'>is_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>I</span></sub></span>, Args...&gt;</span> is <span class='texttt'>true</span>.
If an exception is thrown during the initialization of the contained value,
the <span class='texttt'>variant</span> might not hold a value.
</p></div></div><p ><span class='indexparent'><a class='index' id='emplace,variant'></a></span><span class='indexparent'><a class='index' id='variant,emplace'></a></span><code class='itemdecl'>
template &lt;size_t I, class U, class... Args&gt; void emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='mod-10'><div class='marginalizedparent'><a class='marginalized' href='#mod-10'>10</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>I &lt; sizeof...(Types)</span>.</p></div></div><div class='para' id='mod-11'><div class='marginalizedparent'><a class='marginalized' href='#mod-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>
Destroys the currently contained value if <span class='texttt'>valueless_by_exception()</span>
is <span class='texttt'>false</span>. Then direct-initializes the contained value as if
constructing a value of type <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>I</span></sub></span> with the arguments
<span class='texttt'>il, std::forward&lt;Args&gt;(args)...</span>.</p></div></div><div class='para' id='mod-12'><div class='marginalizedparent'><a class='marginalized' href='#mod-12'>12</a></div><div class='itemdescr'><p ><i>Postconditions:</i>
<span class='texttt'>index()</span> is <span class='texttt'>I</span>.</p></div></div><div class='para' id='mod-13'><div class='marginalizedparent'><a class='marginalized' href='#mod-13'>13</a></div><div class='itemdescr'><p ><i>Throws:</i>
Any exception thrown during the initialization of the contained value.</p></div></div><div class='para' id='mod-14'><div class='marginalizedparent'><a class='marginalized' href='#mod-14'>14</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution unless
<span class='texttt'>is_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>I</span></sub></span>, initializer_list&lt;U&gt;&amp;, Args...&gt;</span> is <span class='texttt'>true</span>.
If an exception is thrown during the initialization of the contained value,
the <span class='texttt'>variant</span> might not hold a value.
</p></div></div></div><div id='status'><h4 ><a class='secnum' href='#status' style='min-width:118pt'>20.7.2.5</a> Value status <a class='abbr_ref' href='variant.status'>[variant.status]</a></h4><p ><span class='indexparent'><a class='index' id='valueless_by_exception,variant'></a></span><span class='indexparent'><a class='index' id='variant,valueless_by_exception'></a></span><code class='itemdecl'>
constexpr bool valueless_by_exception() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='status-1'><div class='marginalizedparent'><a class='marginalized' href='#status-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Returns <span class='texttt'>false</span> if and only if the <span class='texttt'>variant</span> holds a value.</p></div></div><div class='para' id='status-2'><div class='marginalizedparent'><a class='marginalized' href='#status-2'>2</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span>
A <span class='texttt'>variant</span> might not hold a value if an exception is thrown during a
type-changing assignment or emplacement. The latter means that even a
<span class='texttt'>variant&lt;float, int&gt;</span> can become <span class='texttt'>valueless_by_exception()</span>, for
instance by
</p><pre class='codeblock'>
struct S { operator int() { throw 42; }};
variant&lt;float, int&gt; v{12.f};
v.emplace&lt;1&gt;(S());
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='index,variant'></a></span><span class='indexparent'><a class='index' id='variant,index'></a></span><code class='itemdecl'>
constexpr size_t index() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='status-3'><div class='marginalizedparent'><a class='marginalized' href='#status-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
If <span class='texttt'>valueless_by_exception()</span> is <span class='texttt'>true</span>, returns <span class='texttt'>variant_npos</span>.
Otherwise, returns the zero-based index of the alternative of the contained value.
</p></div></div></div><div id='swap'><h4 ><a class='secnum' href='#swap' style='min-width:118pt'>20.7.2.6</a> Swap <a class='abbr_ref' href='variant.swap'>[variant.swap]</a></h4><p ><span class='indexparent'><a class='index' id='swap,variant'></a></span><span class='indexparent'><a class='index' id='variant,swap'></a></span><code class='itemdecl'>
void swap(variant&amp; rhs) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='swap-1'><div class='marginalizedparent'><a class='marginalized' href='#swap-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul ><li ><p >if <span class='texttt'>valueless_by_exception() &amp;&amp; rhs.valueless_by_exception()</span> no effect. Otherwise,
</p></li><li ><p >if <span class='texttt'>index() == rhs.index()</span>, calls <span class='texttt'>swap(get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(*this), get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(rhs))</span> where <span class='math'><span class='mathalpha'>i</span></span> is <span class='texttt'>index()</span>. Otherwise,
</p></li><li ><p >exchanges values of <span class='texttt'>rhs</span> and <span class='texttt'>*this</span>.
</p></li></ul></div></div><div class='para' id='swap-2'><div class='marginalizedparent'><a class='marginalized' href='#swap-2'>2</a></div><div class='itemdescr'><p ><i>Throws:</i>
Any exception thrown by <span class='texttt'>swap(get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(*this), get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(rhs))</span> with <span class='math'><span class='mathalpha'>i</span></span>
being <span class='texttt'>index()</span> and <span class='texttt'>variant</span>'s move constructor and move assignment operator.</p></div></div><div class='para' id='swap-3'><div class='marginalizedparent'><a class='marginalized' href='#swap-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution unless
<span class='texttt'>is_swappable_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;</span> is <span class='texttt'>true</span> for all <span class='math'><span class='mathalpha'>i</span></span>.
If an exception is thrown during the call to function <span class='texttt'>swap(get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(*this), get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(rhs))</span>,
the states of the contained values of <span class='texttt'>*this</span> and of <span class='texttt'>rhs</span> are
determined by the exception safety guarantee of <span class='texttt'>swap</span> for lvalues of
<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span> with <span class='math'><span class='mathalpha'>i</span></span> being <span class='texttt'>index()</span>.
If an exception is thrown during the exchange of the values of <span class='texttt'>*this</span>
and <span class='texttt'>rhs</span>, the states of the values of <span class='texttt'>*this</span> and of <span class='texttt'>rhs</span>
are determined by the exception safety guarantee of <span class='texttt'>variant</span>'s move
constructor and move assignment operator.
The expression inside <span class='texttt'>noexcept</span> is equivalent to the logical AND of
<span class='texttt'>is_nothrow_move_constructible_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt; &amp;&amp; is_nothrow_swappable_v&lt;<span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>i</span></sub></span>&gt;</span> for all <span class='math'><span class='mathalpha'>i</span></span>.
</p></div></div></div></div><div id='helper'><h3 ><a class='secnum' href='#helper' style='min-width:103pt'>20.7.3</a> <span class='texttt'>variant</span> helper classes <a class='abbr_ref' href='variant.helper'>[variant.helper]</a></h3><p ><span class='indexparent'><a class='index' id='variant_size'></a></span><code class='itemdecl'>
template &lt;class T&gt; struct variant_size;
</code></p><div class='itemdescr'></div><div class='para' id='helper-1'><div class='marginalizedparent'><a class='marginalized' href='#helper-1'>1</a></div><div class='itemdescr'><p ><i>Remarks:</i>
All specializations of <span class='texttt'>variant_size&lt;T&gt;</span> shall meet the
<span class='texttt'>UnaryTypeTrait</span> requirements (<a href='meta.rqmts'>[meta.rqmts]</a>) with a <span class='texttt'>BaseCharacteristic</span> of <span class='texttt'>integral_constant&lt;size_t, N&gt;</span> for some <span class='texttt'>N</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='variant_size'></a></span><code class='itemdecl'>
template &lt;class T&gt; class variant_size&lt;const T&gt;;
template &lt;class T&gt; class variant_size&lt;volatile T&gt;;
template &lt;class T&gt; class variant_size&lt;const volatile T&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='helper-2'><div class='marginalizedparent'><a class='marginalized' href='#helper-2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'>VS</span> denote <span class='texttt'>variant_size&lt;T&gt;</span> of the cv-unqualified
type <span class='texttt'>T</span>. Then each of the three templates shall meet the
<span class='texttt'>UnaryTypeTrait</span> requirements (<a href='meta.rqmts'>[meta.rqmts]</a>) with a
<span class='texttt'>BaseCharacteristic</span> of <span class='texttt'>integral_constant&lt;size_t, VS::value&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='variant_size'></a></span><code class='itemdecl'>
template &lt;class... Types&gt;
struct variant_size&lt;variant&lt;Types...&gt;&gt;
  : integral_constant&lt;size_t, sizeof...(Types)&gt; { };
</code>

<span class='indexparent'><a class='index' id='variant_alternative'></a></span><code class='itemdecl'>
template &lt;size_t I, class T&gt; class variant_alternative&lt;I, const T&gt;;
template &lt;size_t I, class T&gt; class variant_alternative&lt;I, volatile T&gt;;
template &lt;size_t I, class T&gt; class variant_alternative&lt;I, const volatile T&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='helper-3'><div class='marginalizedparent'><a class='marginalized' href='#helper-3'>3</a></div><div class='itemdescr'><p >Let <span class='texttt'>VA</span> denote <span class='texttt'>variant_alternative&lt;I, T&gt;</span> of the
cv-unqualified type <span class='texttt'>T</span>. Then each of the three templates shall
meet the <span class='texttt'>TransformationTrait</span> requirements (<a href='meta.rqmts'>[meta.rqmts]</a>) with a
member typedef <span class='texttt'>type</span> that names the following type:
</p><ul ><li ><p >for the first specialization, <span class='texttt'>add_const_t&lt;VA::type&gt;</span>,
</p></li><li ><p >for the second specialization, <span class='texttt'>add_volatile_t&lt;VA::type&gt;</span>, and
</p></li><li ><p >for the third specialization, <span class='texttt'>add_cv_t&lt;VA::type&gt;</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='variant_alternative'></a></span><code class='itemdecl'>
variant_alternative&lt;I, variant&lt;Types...&gt;&gt;::type
</code></p><div class='itemdescr'></div><div class='para' id='helper-4'><div class='marginalizedparent'><a class='marginalized' href='#helper-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>I &lt; sizeof...(Types)</span>.</p></div></div><div class='para' id='helper-5'><div class='marginalizedparent'><a class='marginalized' href='#helper-5'>5</a></div><div class='itemdescr'><p ><i>Value:</i> The type <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>I</span></sub></span>.
</p></div></div></div><div id='get'><h3 ><a class='secnum' href='#get' style='min-width:103pt'>20.7.4</a> Value access <a class='abbr_ref' href='variant.get'>[variant.get]</a></h3><p ><span class='indexparent'><a class='index' id='holds_alternative'></a></span>
<span class='indexparent'><a class='index' id='variant,holds_alternative'></a></span>
<code class='itemdecl'>
template &lt;class T, class... Types&gt;
  constexpr bool holds_alternative(const variant&lt;Types...&gt;&amp; v) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='get-1'><div class='marginalizedparent'><a class='marginalized' href='#get-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
The type <span class='texttt'>T</span> occurs exactly once in <span class='texttt'>Types...</span>.
Otherwise, the program is ill-formed.</p></div></div><div class='para' id='get-2'><div class='marginalizedparent'><a class='marginalized' href='#get-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span> if <span class='texttt'>index()</span> is equal to the zero-based index of <span class='texttt'>T</span> in <span class='texttt'>Types...</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get,variant'></a></span><span class='indexparent'><a class='index' id='variant,get'></a></span><code class='itemdecl'>
template &lt;size_t I, class... Types&gt;
  constexpr variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp; get(variant&lt;Types...&gt;&amp; v);
template &lt;size_t I, class... Types&gt;
  constexpr variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp;&amp; get(variant&lt;Types...&gt;&amp;&amp; v);
template &lt;size_t I, class... Types&gt;
  constexpr variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt; const&amp; get(const variant&lt;Types...&gt;&amp; v);
template &lt;size_t I, class... Types&gt;
  constexpr variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt; const&amp;&amp; get(const variant&lt;Types...&gt;&amp;&amp; v);
</code></p><div class='itemdescr'></div><div class='para' id='get-3'><div class='marginalizedparent'><a class='marginalized' href='#get-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>I &lt; sizeof...(Types)</span>.
Otherwise the program is ill-formed.</p></div></div><div class='para' id='get-4'><div class='marginalizedparent'><a class='marginalized' href='#get-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
If <span class='texttt'>v.index()</span> is <span class='texttt'>I</span>, returns a reference to the object stored in
the <span class='texttt'>variant</span>. Otherwise, throws an exception of type <span class='texttt'>bad_variant_access</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get,variant'></a></span><span class='indexparent'><a class='index' id='variant,get'></a></span><code class='itemdecl'>
template &lt;class T, class... Types&gt; constexpr T&amp; get(variant&lt;Types...&gt;&amp; v);
template &lt;class T, class... Types&gt; constexpr T&amp;&amp; get(variant&lt;Types...&gt;&amp;&amp; v);
template &lt;class T, class... Types&gt; constexpr const T&amp; get(const variant&lt;Types...&gt;&amp; v);
template &lt;class T, class... Types&gt; constexpr const T&amp;&amp; get(const variant&lt;Types...&gt;&amp;&amp; v);
</code></p><div class='itemdescr'></div><div class='para' id='get-5'><div class='marginalizedparent'><a class='marginalized' href='#get-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i>
The type <span class='texttt'>T</span> occurs exactly once in <span class='texttt'>Types...</span>.
Otherwise, the program is ill-formed.</p></div></div><div class='para' id='get-6'><div class='marginalizedparent'><a class='marginalized' href='#get-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
If <span class='texttt'>v</span> holds a value of type <span class='texttt'>T</span>, returns a reference to that value.
Otherwise, throws an exception of type <span class='texttt'>bad_variant_access</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_if'></a></span><span class='indexparent'><a class='index' id='variant,get_if'></a></span><code class='itemdecl'>
template &lt;size_t I, class... Types&gt;
  constexpr add_pointer_t&lt;variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&gt;
  get_if(variant&lt;Types...&gt;* v) noexcept;
template &lt;size_t I, class... Types&gt;
  constexpr add_pointer_t&lt;const variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&gt;
  get_if(const variant&lt;Types...&gt;* v) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='get-7'><div class='marginalizedparent'><a class='marginalized' href='#get-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>I &lt; sizeof...(Types)</span>, and <span class='math'><span class='mathalpha'>T</span><sub ><span class='mathalpha'>I</span></sub></span> is not (possibly cv-qualified) <span class='texttt'>void</span>.
Otherwise the program is ill-formed.</p></div></div><div class='para' id='get-8'><div class='marginalizedparent'><a class='marginalized' href='#get-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
A pointer to the value stored in the <span class='texttt'>variant</span>, if <span class='texttt'>v != nullptr</span>
and <span class='texttt'>v-&gt;index() == I</span>. Otherwise, returns <span class='texttt'>nullptr</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_if'></a></span><span class='indexparent'><a class='index' id='variant,get_if'></a></span><code class='itemdecl'>
template &lt;class T, class... Types&gt;
  constexpr add_pointer_t&lt;T&gt; get_if(variant&lt;Types...&gt;* v) noexcept;
template &lt;class T, class... Types&gt;
  constexpr add_pointer_t&lt;const T&gt; get_if(const variant&lt;Types...&gt;* v) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='get-9'><div class='marginalizedparent'><a class='marginalized' href='#get-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i>
The type <span class='texttt'>T</span> occurs exactly once in <span class='texttt'>Types...</span>, and <span class='texttt'>T</span> is
not (possibly cv-qualified) <span class='texttt'>void</span>. Otherwise, the program is ill-formed.</p></div></div><div class='para' id='get-10'><div class='marginalizedparent'><a class='marginalized' href='#get-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
Equivalent to: <span class='texttt'>return get_if&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(v);</span> with <span class='math'><span class='mathalpha'>i</span></span> being the zero-based
index of <span class='texttt'>T</span> in <span class='texttt'>Types...</span>.
</p></div></div></div><div id='relops'><h3 ><a class='secnum' href='#relops' style='min-width:103pt'>20.7.5</a> Relational operators <a class='abbr_ref' href='variant.relops'>[variant.relops]</a></h3><p ><span class='indexparent'><a class='index' id='operator==,variant'></a></span><span class='indexparent'><a class='index' id='variant,operator=='></a></span><code class='itemdecl'>
template &lt;class... Types&gt;
  constexpr bool operator==(const variant&lt;Types...&gt;&amp; v, const variant&lt;Types...&gt;&amp; w);
</code></p><div class='itemdescr'></div><div class='para' id='relops-1'><div class='marginalizedparent'><a class='marginalized' href='#relops-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(v) == get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(w)</span> is a valid expression returning a type that is
convertible to <span class='texttt'>bool</span>, for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='relops-2'><div class='marginalizedparent'><a class='marginalized' href='#relops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
If <span class='texttt'>v.index() != w.index()</span>, <span class='texttt'>false</span>;
otherwise if <span class='texttt'>v.valueless_by_exception()</span>, <span class='texttt'>true</span>;
otherwise <span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(v) == get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(w)</span> with <span class='math'><span class='mathalpha'>i</span></span> being <span class='texttt'>v.index()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,variant'></a></span><span class='indexparent'><a class='index' id='variant,operator!='></a></span><code class='itemdecl'>
template &lt;class... Types&gt;
  constexpr bool operator!=(const variant&lt;Types...&gt;&amp; v, const variant&lt;Types...&gt;&amp; w);
</code></p><div class='itemdescr'></div><div class='para' id='relops-3'><div class='marginalizedparent'><a class='marginalized' href='#relops-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(v) != get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(w)</span> is a valid expression returning a type that is
convertible to <span class='texttt'>bool</span>, for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='relops-4'><div class='marginalizedparent'><a class='marginalized' href='#relops-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
If <span class='texttt'>v.index() != w.index()</span>, <span class='texttt'>true</span>;
otherwise if <span class='texttt'>v.valueless_by_exception()</span>, <span class='texttt'>false</span>;
otherwise <span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(v) != get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(w)</span> with <span class='math'><span class='mathalpha'>i</span></span> being <span class='texttt'>v.index()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,variant'></a></span><span class='indexparent'><a class='index' id='variant,operator<'></a></span><code class='itemdecl'>
template &lt;class... Types&gt;
  constexpr bool operator&lt;(const variant&lt;Types...&gt;&amp; v, const variant&lt;Types...&gt;&amp; w);
</code></p><div class='itemdescr'></div><div class='para' id='relops-5'><div class='marginalizedparent'><a class='marginalized' href='#relops-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(v) &lt; get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(w)</span> is a valid expression returning a type that is
convertible to <span class='texttt'>bool</span>, for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='relops-6'><div class='marginalizedparent'><a class='marginalized' href='#relops-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
If <span class='texttt'>w.valueless_by_exception()</span>, <span class='texttt'>false</span>;
otherwise if <span class='texttt'>v.valueless_by_exception()</span>, <span class='texttt'>true</span>;
otherwise, if <span class='texttt'>v.index() &lt; w.index()</span>, <span class='texttt'>true</span>;
otherwise if <span class='texttt'>v.index() &gt; w.index()</span>, <span class='texttt'>false</span>;
otherwise <span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(v) &lt; get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(w)</span> with <span class='math'><span class='mathalpha'>i</span></span> being <span class='texttt'>v.index()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,variant'></a></span><span class='indexparent'><a class='index' id='variant,operator>'></a></span><code class='itemdecl'>
template &lt;class... Types&gt;
  constexpr bool operator&gt;(const variant&lt;Types...&gt;&amp; v, const variant&lt;Types...&gt;&amp; w);
</code></p><div class='itemdescr'></div><div class='para' id='relops-7'><div class='marginalizedparent'><a class='marginalized' href='#relops-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(v) &gt; get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(w)</span> is a valid expression returning a type that is
convertible to <span class='texttt'>bool</span>, for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='relops-8'><div class='marginalizedparent'><a class='marginalized' href='#relops-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
If <span class='texttt'>v.valueless_by_exception()</span>, <span class='texttt'>false</span>;
otherwise if <span class='texttt'>w.valueless_by_exception()</span>, <span class='texttt'>true</span>;
otherwise, if <span class='texttt'>v.index() &gt; w.index()</span>, <span class='texttt'>true</span>;
otherwise if <span class='texttt'>v.index() &lt; w.index()</span>, <span class='texttt'>false</span>;
otherwise <span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(v) &gt; get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(w)</span> with <span class='math'><span class='mathalpha'>i</span></span> being <span class='texttt'>v.index()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,variant'></a></span><span class='indexparent'><a class='index' id='variant,operator<='></a></span><code class='itemdecl'>
template &lt;class... Types&gt;
  constexpr bool operator&lt;=(const variant&lt;Types...&gt;&amp; v, const variant&lt;Types...&gt;&amp; w);
</code></p><div class='itemdescr'></div><div class='para' id='relops-9'><div class='marginalizedparent'><a class='marginalized' href='#relops-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(v) &lt;= get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(w)</span> is a valid expression returning a type that is
convertible to <span class='texttt'>bool</span>, for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='relops-10'><div class='marginalizedparent'><a class='marginalized' href='#relops-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
If <span class='texttt'>v.valueless_by_exception()</span>, <span class='texttt'>true</span>;
otherwise if <span class='texttt'>w.valueless_by_exception()</span>, <span class='texttt'>false</span>;
otherwise, if <span class='texttt'>v.index() &lt; w.index()</span>, <span class='texttt'>true</span>;
otherwise if <span class='texttt'>v.index() &gt; w.index()</span>, <span class='texttt'>false</span>;
otherwise <span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(v) &lt;= get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(w)</span> with <span class='math'><span class='mathalpha'>i</span></span> being <span class='texttt'>v.index()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,variant'></a></span><span class='indexparent'><a class='index' id='variant,operator>='></a></span><code class='itemdecl'>
template &lt;class... Types&gt;
  constexpr bool operator&gt;=(const variant&lt;Types...&gt;&amp; v, const variant&lt;Types...&gt;&amp; w);
</code></p><div class='itemdescr'></div><div class='para' id='relops-11'><div class='marginalizedparent'><a class='marginalized' href='#relops-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(v) &gt;= get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(w)</span> is a valid expression returning a type that is
convertible to <span class='texttt'>bool</span>, for all <span class='math'><span class='mathalpha'>i</span></span>.</p></div></div><div class='para' id='relops-12'><div class='marginalizedparent'><a class='marginalized' href='#relops-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i>
If <span class='texttt'>w.valueless_by_exception()</span>, <span class='texttt'>true</span>;
otherwise if <span class='texttt'>v.valueless_by_exception()</span>, <span class='texttt'>false</span>;
otherwise, if <span class='texttt'>v.index() &gt; w.index()</span>, <span class='texttt'>true</span>;
otherwise if <span class='texttt'>v.index() &lt; w.index()</span>, <span class='texttt'>false</span>;
otherwise <span class='texttt'>get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(v) &gt;= get&lt;<span class='math'><span class='mathalpha'>i</span></span>&gt;(w)</span> with <span class='math'><span class='mathalpha'>i</span></span> being <span class='texttt'>v.index()</span>.
</p></div></div></div><div id='visit'><h3 ><a class='secnum' href='#visit' style='min-width:103pt'>20.7.6</a> Visitation <a class='abbr_ref' href='variant.visit'>[variant.visit]</a></h3><p ><span class='indexparent'><a class='index' id='visit'></a></span><span class='indexparent'><a class='index' id='variant,visit'></a></span><code class='itemdecl'>
template &lt;class Visitor, class... Variants&gt;
  constexpr <i><span class='texttt'>see below</span></i> visit(Visitor&amp;&amp; vis, Variants&amp;&amp;... vars);
</code></p><div class='itemdescr'></div><div class='para' id='visit-1'><div class='marginalizedparent'><a class='marginalized' href='#visit-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i>
The expression in the <i>Effects:</i> element shall be a valid expression of the same
 type and value category, for all combinations of alternative types of all
 variants. Otherwise, the program is ill-formed.</p><p ><i>Effects:</i>
Let <span class='texttt'>is...</span> be <span class='texttt'>vars.index()...</span>. Returns <span class='texttt'><i>INVOKE</i>(forward&lt;Visitor&gt;(vis), get&lt;is&gt;(</span><span class='discretionary'></span>
<span class='texttt'>forward&lt;Variants&gt;(vars))...);</span>.</p></div></div><div class='para' id='visit-2'><div class='marginalizedparent'><a class='marginalized' href='#visit-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The return type is the common type of all possible <span class='texttt'><i>INVOKE</i></span>
expressions of the <i>Effects:</i> element.</p></div></div><div class='para' id='visit-3'><div class='marginalizedparent'><a class='marginalized' href='#visit-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>bad_variant_access</span> if any <span class='texttt'>variant</span> in <span class='texttt'>vars</span> is <span class='texttt'>valueless_by_exception()</span>.</p><p ><i>Complexity:</i>
For <span class='texttt'>sizeof...(Variants) &lt;= 1</span>, the invocation of the callable object is
implemented in constant time, i.e. it does not depend on <span class='texttt'>sizeof...(Types).</span>
For <span class='texttt'>sizeof...(Variants) &gt; 1</span>, the invocation of the callable object has
no complexity requirements.
</p></div></div><p ><span class='indexparent'><a class='index' id='monostate'></a></span></p></div><div id='monostate'><h3 ><a class='secnum' href='#monostate' style='min-width:103pt'>20.7.7</a> Class <span class='texttt'>monostate</span> <a class='abbr_ref' href='variant.monostate'>[variant.monostate]</a></h3><p ><code class='itemdecl'>
struct monostate{};
</code></p><div class='itemdescr'><p >The class <span class='texttt'>monostate</span> can serve as a first alternative type for
a <span class='texttt'>variant</span> to make the <span class='texttt'>variant</span> type default constructible.
</p></div></div><div id='monostate.relops'><h3 ><a class='secnum' href='#monostate.relops' style='min-width:103pt'>20.7.8</a> <span class='texttt'>monostate</span> relational operators <a class='abbr_ref' href='variant.monostate.relops'>[variant.monostate.relops]</a></h3><p ><span class='indexparent'><a class='index' id='operator<,monostate'></a></span><span class='indexparent'><a class='index' id='operator>,monostate'></a></span><span class='indexparent'><a class='index' id='operator<=,monostate'></a></span><span class='indexparent'><a class='index' id='operator>=,monostate'></a></span><span class='indexparent'><a class='index' id='operator==,monostate'></a></span><span class='indexparent'><a class='index' id='operator!=,monostate'></a></span><code class='itemdecl'>
constexpr bool operator&lt;(monostate, monostate) noexcept { return false; }
constexpr bool operator&gt;(monostate, monostate) noexcept { return false; }
constexpr bool operator&lt;=(monostate, monostate) noexcept { return true; }
constexpr bool operator&gt;=(monostate, monostate) noexcept { return true; }
constexpr bool operator==(monostate, monostate) noexcept { return true; }
constexpr bool operator!=(monostate, monostate) noexcept { return false; }
</code></p><div class='itemdescr'></div><div class='para' id='monostate.relops-1'><div class='marginalizedparent'><a class='marginalized' href='#monostate.relops-1'>1</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span> <span class='texttt'>monostate</span> objects have only a single state; they thus always compare equal.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='specalg'><h3 ><a class='secnum' href='#specalg' style='min-width:103pt'>20.7.9</a> Specialized algorithms <a class='abbr_ref' href='variant.specalg'>[variant.specalg]</a></h3><p ><span class='indexparent'><a class='index' id='swap,variant'></a></span><code class='itemdecl'>
template &lt;class... Types&gt; void swap(variant&lt;Types...&gt;&amp; v, variant&lt;Types...&gt;&amp; w) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='specalg-1'><div class='marginalizedparent'><a class='marginalized' href='#specalg-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>v.swap(w)</span>.</p></div></div><div class='para' id='specalg-2'><div class='marginalizedparent'><a class='marginalized' href='#specalg-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> The expression inside <span class='texttt'>noexcept</span> is equivalent to <span class='texttt'>noexcept(v.swap(w))</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bad_variant_access'></a></span></p></div><div id='bad.access'><h3 ><a class='secnum' href='#bad.access' style='min-width:103pt'>20.7.10</a> Class <span class='texttt'>bad_variant_access</span> <a class='abbr_ref' href='variant.bad.access'>[variant.bad.access]</a></h3><pre class='codeblock'>
class bad_variant_access : public exception {
public:
  bad_variant_access() noexcept;
  virtual const char* what() const noexcept;
};
</pre><div class='para' id='bad.access-1'><div class='marginalizedparent'><a class='marginalized' href='#bad.access-1'>1</a></div><p >Objects of type <span class='texttt'>bad_variant_access</span> are thrown to report invalid
accesses to the value of a <span class='texttt'>variant</span> object.</p><p ><span class='indexparent'><a class='index' id='bad_variant_access,constructor'></a></span><code class='itemdecl'>
bad_variant_access() noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='bad.access-2'><div class='marginalizedparent'><a class='marginalized' href='#bad.access-2'>2</a></div><div class='itemdescr'><p >Constructs a <span class='texttt'>bad_variant_access</span> object.
</p></div></div><p ><span class='indexparent'><a class='index' id='what,bad_variant_access'></a></span><span class='indexparent'><a class='index' id='bad_variant_access,what'></a></span><code class='itemdecl'>
const char* what() const noexcept override;
</code></p><div class='itemdescr'></div><div class='para' id='bad.access-3'><div class='marginalizedparent'><a class='marginalized' href='#bad.access-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> An <span class='indexparent'><a class='index' id='return_value_of_bad_variant_access::what'></a></span>implementation-defined <span class='textsc'>ntbs</span>.
</p></div></div></div><div id='hash'><h3 ><a class='secnum' href='#hash' style='min-width:103pt'>20.7.11</a> Hash support <a class='abbr_ref' href='variant.hash'>[variant.hash]</a></h3><p ><span class='indexparent'><a class='index' id='hash,variant'></a></span><code class='itemdecl'>
template &lt;class... Types&gt; struct hash&lt;variant&lt;Types...&gt;&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='hash-1'><div class='marginalizedparent'><a class='marginalized' href='#hash-1'>1</a></div><div class='itemdescr'><p >The template specialization <span class='texttt'>hash&lt;T&gt;</span> shall meet the requirements
of class template <span class='texttt'>hash</span> (<a href='unord.hash'>[unord.hash]</a>) for all <span class='texttt'>T</span> in <span class='texttt'>Types...</span>.
The template specialization <span class='texttt'>hash&lt;variant&lt;Types...&gt;&gt;</span> shall meet
the requirements of class template <span class='texttt'>hash</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='hash,monostate'></a></span><code class='itemdecl'>
template &lt;&gt; struct hash&lt;monostate&gt;;
</code></p><div class='itemdescr'></div><div class='para' id='hash-2'><div class='marginalizedparent'><a class='marginalized' href='#hash-2'>2</a></div><div class='itemdescr'><p >The template specialization hash&lt;monostate&gt; shall meet the requirements of class template hash.
</p></div></div></div><div id='traits'><h3 ><a class='secnum' href='#traits' style='min-width:103pt'>20.7.12</a> Allocator-related traits <a class='abbr_ref' href='variant.traits'>[variant.traits]</a></h3><p ><span class='indexparent'><a class='index' id='uses_allocator,variant'></a></span><code class='itemdecl'>
template &lt;class... Types, class Alloc&gt;
  struct uses_allocator&lt;variant&lt;Types...&gt;, Alloc&gt; : true_type { };
</code></p><div class='itemdescr'></div><div class='para' id='traits-1'><div class='marginalizedparent'><a class='marginalized' href='#traits-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>Alloc</span> shall be an Allocator (<a href='allocator.requirements'>[allocator.requirements]</a>).</p></div></div><div class='para' id='traits-2'><div class='marginalizedparent'><a class='marginalized' href='#traits-2'>2</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i><span class='space'></span>
Specialization of this trait informs other library components
that variant can be constructed with an allocator,
even though it does not have a nested <span class='texttt'>allocator_type</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div></div></div></body></html>