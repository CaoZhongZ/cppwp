<!DOCTYPE html><html lang='en'><head><title>[class.copy.elision]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>11</a> Classes <a class='abbr_ref' href='./#class'>[class]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>11.9</a> Initialization <a class='abbr_ref' href='class.init#class.copy.elision'>[class.init]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>11.9.5</a> Copy/move elision <a class='abbr_ref'>[class.copy.elision]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/871b9e1d91ad939afe46b66e6139a527e773200e/source/classes.tex#L6421'>#</a></div><div id='1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':temporary,elimination_of'></a></span><span class='indexparent'><a class='index' id=':constructor,copy,elision'></a></span><span class='indexparent'><a class='index' id=':constructor,move,elision'></a></span>When certain criteria are met, an implementation is
allowed to omit the copy/move construction of a class object,
even if the constructor selected for the copy/move operation and/or the
destructor for the object have
<span class='indexparent'><a class='index' id=':side_effects'></a></span>side effects<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>In such cases, the
implementation treats the source and target of the
omitted copy/move operation as simply two different ways of
referring to the same object<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.sentence-3' class='sentence'>If the first parameter of the
selected constructor is an rvalue reference to the object's type,
the destruction of that object occurs when the target would have been destroyed;
otherwise, the destruction occurs at the later of the times when the
two objects would have been destroyed without the
optimization<a class='hidden_link' href='#1.sentence-3'>.</a><a class='footnotenum' href='#footnote-118' id='footnoteref-118'>118</a></div> <div id='1.sentence-4' class='sentence'>
This elision of copy/move operations, called
<span class='indexparent'><a class='index' id=':constructor,copy,elision_'></a></span><span class='indexparent'><a class='index' id=':constructor,move,elision_'></a></span><a class='hidden_link' href='#def:copy_elision' id='def:copy_elision'><i>copy elision</i></a>,
is permitted in the
following circumstances (which may be combined to
eliminate multiple copies):</div><div id='1.sentence-5' class='sentence'><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div>in a <span class='texttt'><span class='keyword'>return</span></span> statement in a function with a class return type,
when the <i ><a href='expr.comma#nt:expression'>expression</a></i> is the name of a non-volatile
automatic object (other than a function parameter or a variable
introduced by the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> of a
<i ><a href='except#nt:handler'>handler</a></i> (<a href='except.handle'>[except.handle]</a>))
with the same type (ignoring cv-qualification) as
the function return type, the copy/move operation can be
omitted by constructing the automatic object directly
into the function call's return object</li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div>in a <i ><a href='expr.throw#nt:throw-expression'>throw-expression</a></i> (<a href='expr.throw'>[expr.throw]</a>), when the operand
is the name of a non-volatile automatic object
(other than a function or catch-clause parameter)
whose scope does not extend beyond the end of the innermost enclosing
<i ><a href='except#nt:try-block'>try-block</a></i> (if there is one), the copy/move operation from the
operand to the exception object (<a href='except.throw'>[except.throw]</a>) can be omitted by
constructing the automatic object directly into the exception object</li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div>in a coroutine (<a href='dcl.fct.def.coroutine'>[dcl.fct.def.coroutine]</a>), a copy of a coroutine parameter
can be omitted and references to that copy replaced with references to the
corresponding parameter if the meaning of the program will be unchanged except for
the execution of a constructor and destructor for the parameter copy object</li><li id='1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.4'>(1.4)</a></div>when the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> of an
exception handler (<a href='except'>[except]</a>) declares an object of the same
type (except for cv-qualification) as the exception
object (<a href='except.throw'>[except.throw]</a>), the copy operation can be omitted by treating
the <i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> as an alias for the exception
object if the meaning of the program will be unchanged except for the execution
of constructors and destructors for the object declared by the
<i ><a href='except#nt:exception-declaration'>exception-declaration</a></i>. <div id='1.4.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#1.4.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> There cannot be a move from the exception object because it is
always an lvalue. —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </li></ul>
Copy elision is not permitted
where an expression is evaluated in a context
requiring a constant expression (<a href='expr.const'>[expr.const]</a>)
and in constant initialization (<a href='basic.start.static'>[basic.start.static]</a>)<a class='hidden_link' href='#1.sentence-5'>.</a></div> <div id='1.note-2' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#1.note-2'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='1.sentence-6' class='sentence'>Copy elision might be performed
if the same expression
is evaluated in another context<a class='hidden_link' href='#1.sentence-6'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/871b9e1d91ad939afe46b66e6139a527e773200e/source/classes.tex#L6496'>#</a></div><div id='2.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>class</span> Thing <span class='curlybracket'>{</span>
<span class='keyword'>public</span><span class='operator'>:</span>
  Thing<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
  <span class='operator'>~</span>Thing<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
  Thing<span class='parenthesis'>(</span><span class='keyword'>const</span> Thing<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span>;

Thing f<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  Thing t;
  <span class='keyword'>return</span> t;
<span class='curlybracket'>}</span>

Thing t2 <span class='operator'>=</span> f<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;

<span class='keyword'>struct</span> A <span class='curlybracket'>{</span>
  <span class='keyword'>void</span> <span class='operator'>*</span>p;
  <span class='keyword'>constexpr</span> A<span class='parenthesis'>(</span><span class='parenthesis'>)</span><span class='operator'>:</span> p<span class='parenthesis'>(</span><span class='keyword'>this</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span><span class='curlybracket'>}</span>
<span class='curlybracket'>}</span>;

<span class='keyword'>constexpr</span> A g<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  A a;
  <span class='keyword'>return</span> a;
<span class='curlybracket'>}</span>

<span class='keyword'>constexpr</span> A a;          <span class='comment'>// well-formed, <span class='tcode_in_codeblock'>a.p</span> points to <span class='tcode_in_codeblock'>a</span></span>
<span class='keyword'>constexpr</span> A b <span class='operator'>=</span> g<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;    <span class='comment'>// well-formed, <span class='tcode_in_codeblock'>b.p</span> points to <span class='tcode_in_codeblock'>b</span></span>

<span class='keyword'>void</span> h<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  A c <span class='operator'>=</span> g<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;            <span class='comment'>// well-formed, <span class='tcode_in_codeblock'>c.p</span> may point to <span class='tcode_in_codeblock'>c</span> or to an ephemeral temporary</span>
<span class='curlybracket'>}</span>
</pre> <div id='2.sentence-1' class='sentence'>
Here the criteria for elision can
eliminate
the copying of the local automatic object
<span class='texttt'>t</span>
into the result object for the function call
<span class='texttt'>f<span class='parenthesis'>(</span><span class='parenthesis'>)</span></span>,
which is the global object
<span class='texttt'>t2</span><a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>Effectively, the construction of the local object
<span class='texttt'>t</span>
can be viewed as directly initializing the global
object
<span class='texttt'>t2</span>,
and that object's destruction will occur at program
exit<a class='hidden_link' href='#2.sentence-2'>.</a></div> <div id='2.sentence-3' class='sentence'>Adding a move constructor to <span class='texttt'>Thing</span> has the same effect, but it is the
move construction from the local automatic object to <span class='texttt'>t2</span> that is elided<a class='hidden_link' href='#2.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/871b9e1d91ad939afe46b66e6139a527e773200e/source/classes.tex#L6549'>#</a></div><div id='3.sentence-1' class='sentence'>In the following copy-initialization contexts, a move operation might be used instead of a copy operation:
<ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div>If the <i ><a href='expr.comma#nt:expression'>expression</a></i> in a <span class='texttt'><span class='keyword'>return</span></span> or <span class='texttt'>co_&shy;return</span> statement (<a href='stmt.return'>[stmt.return]</a>)
is a (possibly parenthesized) <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
that names an object with automatic storage duration declared in the body
or <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> of the innermost enclosing
function or <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>, or</li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div>if the operand of a <i ><a href='expr.throw#nt:throw-expression'>throw-expression</a></i> (<a href='expr.throw'>[expr.throw]</a>)
is the name of a non-volatile automatic object
(other than a function or catch-clause parameter)
whose scope does not extend beyond the end of the innermost enclosing
<i ><a href='except#nt:try-block'>try-block</a></i> (if there is one),</li></ul>
overload resolution to select the constructor
for the copy or the <span class='texttt'>return_&shy;value</span> overload to call
is first performed as if the object were designated by an
rvalue<a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.sentence-2' class='sentence'>If the first overload resolution fails or was not performed,
or if the type of the first parameter of the selected
constructor or the <span class='texttt'>return_&shy;value</span> overload
is not an rvalue reference to the object's type (possibly cv-qualified),
overload resolution is performed again, considering the object as an lvalue<a class='hidden_link' href='#3.sentence-2'>.</a></div> <div id='3.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='3.sentence-3' class='sentence'>This two-stage overload resolution must be performed regardless
of whether copy elision will occur<a class='hidden_link' href='#3.sentence-3'>.</a></div> <div id='3.sentence-4' class='sentence'>It determines the constructor
or the <span class='texttt'>return_&shy;value</span> overload to be called if
elision is not performed, and the selected constructor
or the <span class='texttt'>return_&shy;value</span> overload must be accessible even if
the call is elided<a class='hidden_link' href='#3.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/871b9e1d91ad939afe46b66e6139a527e773200e/source/classes.tex#L6582'>#</a></div><div id='4.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
<span class='keyword'>class</span> Thing <span class='curlybracket'>{</span>
<span class='keyword'>public</span><span class='operator'>:</span>
  Thing<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
  <span class='operator'>~</span>Thing<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
  Thing<span class='parenthesis'>(</span>Thing<span class='operator'>&amp;</span><span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='keyword'>private</span><span class='operator'>:</span>
  Thing<span class='parenthesis'>(</span><span class='keyword'>const</span> Thing<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span>;

Thing f<span class='parenthesis'>(</span><span class='keyword'>bool</span> b<span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  Thing t;
  <span class='keyword'>if</span> <span class='parenthesis'>(</span>b<span class='parenthesis'>)</span>
    <span class='keyword'>throw</span> t;            <span class='comment'>// OK: <span class='tcode_in_codeblock'>Thing(Thing&amp;&amp;)</span> used (or elided) to throw <span class='tcode_in_codeblock'>t</span></span>
  <span class='keyword'>return</span> t;             <span class='comment'>// OK: <span class='tcode_in_codeblock'>Thing(Thing&amp;&amp;)</span> used (or elided) to return <span class='tcode_in_codeblock'>t</span></span>
<span class='curlybracket'>}</span>

Thing t2 <span class='operator'>=</span> f<span class='parenthesis'>(</span><span class='literal'>false</span><span class='parenthesis'>)</span>;    <span class='comment'>// OK: no extra copy/move performed, <span class='tcode_in_codeblock'>t2</span> constructed by call to <span class='tcode_in_codeblock'>f</span></span>

<span class='keyword'>struct</span> Weird <span class='curlybracket'>{</span>
  Weird<span class='parenthesis'>(</span><span class='parenthesis'>)</span>;
  Weird<span class='parenthesis'>(</span>Weird<span class='operator'>&amp;</span><span class='parenthesis'>)</span>;
<span class='curlybracket'>}</span>;

Weird g<span class='parenthesis'>(</span><span class='parenthesis'>)</span> <span class='curlybracket'>{</span>
  Weird w;
  <span class='keyword'>return</span> w;             <span class='comment'>// OK: first overload resolution fails, second overload resolution selects <span class='tcode_in_codeblock'>Weird(Weird&amp;)</span></span>
<span class='curlybracket'>}</span>
</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='footnote' id='footnote-118'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-118'>118)</a></div><div id='footnote-118.sentence-1' class='sentence'>Because only one object is destroyed instead of two,
and one copy/move constructor
is not executed, there is still one object destroyed for each one constructed<a class='hidden_link' href='#footnote-118.sentence-1'>.</a></div> <a href='#footnoteref-118'>⮥</a></div></div></body></html>