<!DOCTYPE html><html lang='en'><head><title>[dcl.decomp]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Declarators <a class='abbr_ref' href='./#dcl.decl'>[dcl.decl]</a></h1><div id='dcl.decomp'><h2 ><a class='secnum' style='min-width:88pt'>8.5</a> Decomposition declarations <a class='abbr_ref'>[dcl.decomp]</a></h2><p ><span class='indexparent'><a class='index' id='decomposition_declaration'></a></span><span class='indexparent'><a class='index' id='declaration,decomposition'></a></span>
</p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A decomposition declaration introduces the <i ><a href='lex.name#nt:identifier'>identifiers</a></i>
<span class='texttt'>v</span><span class='math'><sub >0</sub></span>, <span class='texttt'>v</span><span class='math'><sub >1</sub></span>, <span class='texttt'>v</span><span class='math'><sub >2</sub></span>, ...
of the
<i ><a href='cpp#nt:identifier-list'>identifier-list</a></i> as names (<a href='basic.scope.declarative'>[basic.scope.declarative]</a>).
Let <i>cv</i> denote the
<i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifiers</a></i> in the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>. First, a
variable with a unique name <span class='texttt'>e</span> is introduced. If the
<i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i> in the <i ><a href='dcl.init#nt:initializer'>initializer</a></i>
has array type <span class='texttt'>A</span> and no <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> is present, <span class='texttt'>e</span>
has type <i>cv</i> <span class='texttt'>A</span> and each element is copy-initialized or direct-initialized
from the corresponding element of the <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i> as specified
by the form of the <i ><a href='dcl.init#nt:initializer'>initializer</a></i>.
Otherwise, <span class='texttt'>e</span>
is defined as-if by</p><pre class='bnf'><i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='texttt'>e</span> <i ><a href='dcl.init#nt:initializer'>initializer</a></i> <span class='terminal'>;</span></pre><p >where
the declaration is never interpreted as a function declaration and
the parts of the declaration other than the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> are taken
from the corresponding decomposition declaration. The type of the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
<span class='texttt'>e</span> is called <span class='texttt'>E</span>.
[&nbsp;<i>Note:</i>
<span class='texttt'>E</span> is never a reference type (Clause <a href='expr'>[expr]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >If <span class='texttt'>E</span> is an array type with element type <span class='texttt'>T</span>, the number
of elements in the <i ><a href='cpp#nt:identifier-list'>identifier-list</a></i> shall be equal to the
number of elements of <span class='texttt'>E</span>. Each <span class='texttt'>v</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> is the name of an
lvalue that refers to the element <span class='math'><span class='mathalpha'>i</span></span> of the array and whose type
is <span class='texttt'>T</span>; the referenced type is <span class='texttt'>T</span>.
[&nbsp;<i>Note:</i>
The top-level cv-qualifiers of <span class='texttt'>T</span> are <i>cv</i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
  auto f() -&gt; int(&amp;)[2];
  auto [ x, y ] = f();     <span class='comment'>// <span class='texttt'>x</span> and <span class='texttt'>y</span> refer to elements in a copy of the array return value
</span>  auto&amp; [ xr, yr ] = f();  <span class='comment'>// <span class='texttt'>xr</span> and <span class='texttt'>yr</span> refer to elements in the array referred to by <span class='texttt'>f</span>'s return value
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >Otherwise, if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>std::tuple_size&lt;E&gt;</span>
names a complete type,
the expression <span class='texttt'>std::tuple_size&lt;E&gt;::value</span>
shall be a well-formed integral constant expression
and
the number of elements in
the <i ><a href='cpp#nt:identifier-list'>identifier-list</a></i> shall be equal to the value of that
expression. The <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> <span class='texttt'>get</span> is looked up
in the scope of <span class='texttt'>E</span> by class member access lookup (<a href='basic.lookup.classref'>[basic.lookup.classref]</a>),
and if that finds at least one declaration, the initializer is
<span class='texttt'>e.get&lt;i&gt;()</span>. Otherwise, the initializer is <span class='texttt'>get&lt;i&gt;(e)</span>,
where <span class='texttt'>get</span> is looked up in the associated namespaces (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>).
In either case, <span class='texttt'>get&lt;i&gt;</span> is interpreted as a <i ><a href='temp.names#nt:template-id'>template-id</a></i>.
[&nbsp;<i>Note:</i>
Ordinary unqualified lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>) is not performed.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
In either case, <span class='texttt'>e</span> is an lvalue if the type of the entity <span class='texttt'>e</span>
is an lvalue reference and an xvalue otherwise. Given the type <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>
designated by <span class='texttt'>std::tuple_element&lt;i, E&gt;::type</span>, each <span class='texttt'>v</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>
is a variable of type “reference to <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>” initialized with the
initializer, where the reference is an lvalue reference if the initializer is
an lvalue and an rvalue reference otherwise; the referenced type is <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >Otherwise, all of <span class='texttt'>E</span>'s non-static data members shall be public direct
members of <span class='texttt'>E</span> or of the same unambiguous public base class of <span class='texttt'>E</span>,
<span class='texttt'>E</span> shall not have an anonymous union member, and the number of elements
in the <i ><a href='cpp#nt:identifier-list'>identifier-list</a></i> shall be equal to the number of non-static
data members of <span class='texttt'>E</span>.
Designating the non-static data members of <span class='texttt'>E</span> as 
<span class='texttt'>m</span><span class='math'><sub >0</sub></span>, <span class='texttt'>m</span><span class='math'><sub >1</sub></span>, <span class='texttt'>m</span><span class='math'><sub >2</sub></span>, ...
(in declaration order),
each <span class='texttt'>v</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> is the
name of an lvalue that refers to the member <span class='texttt'>m</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> of <span class='texttt'>e</span> and
whose type is <i>cv</i> <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>, where <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> is the declared type of
that member; the referenced type is <i>cv</i> <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>. The lvalue is a
bit-field if that member is a bit-field.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct S { int x1 : 2; volatile double y1; };
S f();
const auto [ x, y ] = f();
</pre><p >The type of the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> <span class='texttt'>x</span> is “<span class='texttt'>const int</span>”,
the type of the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> <span class='texttt'>y</span> is “<span class='texttt'>const volatile double</span>”.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></body></html>