<!DOCTYPE html><html lang='en'><head><title>[dcl.decomp]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Declarators <a class='abbr_ref' href='./#dcl.decl'>[dcl.decl]</a></h1><div id='dcl.decomp'><h2 ><a class='secnum' style='min-width:88pt'>8.5</a> Decomposition declarations <a class='abbr_ref'>[dcl.decomp]</a></h2><p ><span class='indexparent'><a class='index' id='decomposition declaration'></a></span><span class='indexparent'><a class='index' id='declaration!decomposition'></a></span>
</p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A decomposition declaration introduces the <i ><a href='lex.name#identifier'>identifiers</a></i> of the
<i ><a href='cpp#identifier-list'>identifier-list</a></i> as names in the order of appearance, where <span class='texttt'>v</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>
denotes the <span class='math'><span class='mathalpha'>i</span></span>th identifier, with numbering starting at 1. Let <i>cv</i> denote the
<i ><a href='dcl.decl#cv-qualifier'>cv-qualifiers</a></i> in the <i ><a href='dcl.spec#decl-specifier-seq'>decl-specifier-seq</a></i>. First, a
variable with a unique name <span class='texttt'>e</span> is introduced. If the
<i ><a href='expr.ass#assignment-expression'>assignment-expression</a></i> in the <i ><a href='dcl.init#brace-or-equal-initializer'>brace-or-equal-initializer</a></i>
has array type <span class='texttt'>A</span> and no <i ><a href='dcl.decl#ref-qualifier'>ref-qualifier</a></i> is present, <span class='texttt'>e</span>
has type <i>cv</i> <span class='texttt'>A</span> and each element is copy-initialized or direct-initialized
from the corresponding element of the <i ><a href='expr.ass#assignment-expression'>assignment-expression</a></i> as specified
by the form of the <i ><a href='dcl.init#brace-or-equal-initializer'>brace-or-equal-initializer</a></i>. Otherwise, <span class='texttt'>e</span>
is defined as-if by</p><pre class='bnf'><i ><a href='dcl.attr.grammar#attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.spec#decl-specifier-seq'>decl-specifier-seq</a></i> <i ><a href='dcl.decl#ref-qualifier'>ref-qualifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='texttt'>e</span> <i ><a href='dcl.init#brace-or-equal-initializer'>brace-or-equal-initializer</a></i> <span class='terminal'>;</span></pre><p >where the parts of the declaration other than the <i ><a href='dcl.decl#declarator-id'>declarator-id</a></i> are taken
from the corresponding decomposition declaration. The type of the <i ><a href='expr.prim.id#id-expression'>id-expression</a></i>
<span class='texttt'>e</span> is called <span class='texttt'>E</span>.
[&nbsp;<i>Note:</i><span class='space'></span>
<span class='texttt'>E</span> is never a reference type (Clause <a href='expr'>[expr]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >If <span class='texttt'>E</span> is an array type with element type <span class='texttt'>T</span>, the number
of elements in the <i ><a href='cpp#identifier-list'>identifier-list</a></i> shall be equal to the
number of elements of <span class='texttt'>E</span>. Each <span class='texttt'>v</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> is the name of an
lvalue that refers to the element <span class='math'><span class='mathalpha'>i</span> - 1</span> of the array and whose type
is <span class='texttt'>T</span>; the referenced type is <span class='texttt'>T</span>.
[&nbsp;<i>Note:</i><span class='space'></span>
The top-level cv-qualifiers of <span class='texttt'>T</span> are <i>cv</i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
  auto f() -&gt; int(&amp;)[2];
  auto [ x, y ] = f();     <span class='comment'>// <span class='texttt'>x</span> and <span class='texttt'>y</span> refer to elements in a copy of the array return value
</span>  auto&amp; [ xr, yr ] = f();  <span class='comment'>// <span class='texttt'>xr</span> and <span class='texttt'>yr</span> refer to elements in the array referred to by <span class='texttt'>f</span>'s return value
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >Otherwise, if the expression <span class='texttt'>std::tuple_size&lt;E&gt;::value</span> is a
well-formed integral constant expression, the number of elements in
the <i ><a href='cpp#identifier-list'>identifier-list</a></i> shall be equal to the value of that
expression. The <i ><a href='expr.prim.id.unqual#unqualified-id'>unqualified-id</a></i> <span class='texttt'>get</span> is looked up
in the scope of <span class='texttt'>E</span> by class member access lookup (<a href='basic.lookup.classref'>[basic.lookup.classref]</a>),
and if that finds at least one declaration, the initializer is
<span class='texttt'>e.get&lt;i - 1&gt;()</span>. Otherwise, the initializer is <span class='texttt'>get&lt;i - 1&gt;(e)</span>,
where <span class='texttt'>get</span> is looked up in the associated namespaces (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>).
In either case, <span class='texttt'>get&lt;i - 1&gt;</span> is interpreted as a <i ><a href='temp.names#template-id'>template-id</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span>
Ordinary unqualified lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>) is not performed.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
In either case, <span class='texttt'>e</span> is an lvalue if the type of the entity <span class='texttt'>e</span>
is an lvalue reference and an xvalue otherwise. Given the type <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>
designated by <span class='texttt'>std::tuple_element&lt;i - 1, E&gt;::type</span>, each <span class='texttt'>v</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>
is a variable of type “reference to <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>” initialized with the
initializer, where the reference is an lvalue reference if the initializer is
an lvalue and an rvalue reference otherwise; the referenced type is <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >Otherwise, all of <span class='texttt'>E</span>'s non-static data members shall be public direct
members of <span class='texttt'>E</span> or of the same unambiguous public base class of <span class='texttt'>E</span>,
<span class='texttt'>E</span> shall not have an anonymous union member, and the number of elements
in the <i ><a href='cpp#identifier-list'>identifier-list</a></i> shall be equal to the number of non-static
data members of <span class='texttt'>E</span>. The <span class='math'><span class='mathalpha'>i</span></span>th non-static data member of <span class='texttt'>E</span> in
declaration order is designated by <span class='texttt'>m</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>. Each <span class='texttt'>v</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> is the
name of an lvalue that refers to the member <span class='texttt'>m</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> of <span class='texttt'>e</span> and
whose type is <i>cv</i> <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>, where <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span> is the declared type of
that member; the referenced type is <i>cv</i> <span class='texttt'>T</span><span class='math'><sub ><span class='mathalpha'>i</span></sub></span>. The lvalue is a
bit-field if that member is a bit-field.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct S { int x1 : 2; volatile double y1; };
S f();
const auto [ x, y ] = f();
</pre><p >The type of the <i ><a href='expr.prim.id#id-expression'>id-expression</a></i> <span class='texttt'>x</span> is “<span class='texttt'>const int</span>”,
the type of the <i ><a href='expr.prim.id#id-expression'>id-expression</a></i> <span class='texttt'>y</span> is “<span class='texttt'>const volatile double</span>”.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></body></html>