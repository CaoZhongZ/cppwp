<!DOCTYPE html><html lang='en'><head><title>[dcl.link]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Declarations <a class='abbr_ref' href='./#dcl.dcl'>[dcl.dcl]</a></h1><div id='dcl.link'><h2 ><a class='secnum' style='min-width:88pt'>7.5</a> Linkage specifications <a class='abbr_ref'>[dcl.link]</a></h2><p ><span class='indexparent'><a class='index' id='specification!linkage'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >All function types, function names with external linkage, and variable
names with external linkage have a <i>language linkage</i>.
[&nbsp;<i>Note:</i><span class='space'></span>
Some of the properties associated with an entity with language linkage
are specific to each implementation and are not described here. For
example, a particular language linkage may be associated with a
particular form of representing names of objects and functions with
external linkage, or with a particular calling convention, etc.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The default language linkage of all function types, function names, and
variable names is C++ language linkage. Two function types with
different language linkages are distinct types even if they are
otherwise identical.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Linkage (<a href='basic.link'>[basic.link]</a>) between C++ and  non-C++ code fragments can
be achieved using a <i ><a href='dcl.link#linkage-specification'>linkage-specification</a></i>:</p><p ><span class='indexparent'><a class='index' id='linkage-specification'></a></span><span class='indexparent'><a class='index' id='specification!linkage!extern'></a></span></p><pre class='bnf'><a id='linkage-specification'>linkage-specification:</a>
    <span class='terminal'>extern</span> <i ><a href='lex.string#string-literal'>string-literal</a></i> <span class='terminal'>{</span> <i ><a href='dcl.dcl#declaration-seq'>declaration-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>}</span>
    <span class='terminal'>extern</span> <i ><a href='lex.string#string-literal'>string-literal</a></i> <i ><a href='dcl.dcl#declaration'>declaration</a></i></pre><p >The <i ><a href='lex.string#string-literal'>string-literal</a></i> indicates the required language linkage.
This International Standard specifies the semantics for the
<i ><a href='lex.string#string-literal'>string-literals</a></i> <span class='texttt'>"C"</span> and <span class='texttt'>"C++"</span>. Use of a
<i ><a href='lex.string#string-literal'>string-literal</a></i> other than <span class='texttt'>"C"</span> or <span class='texttt'>"C++"</span> is
conditionally-supported, with <span class='indexparent'><a class='index' id='semantics of linkage specifiers'></a></span>implementation-defined semantics.
[&nbsp;<i>Note:</i><span class='space'></span>
Therefore, a linkage-specification with a <i ><a href='lex.string#string-literal'>string-literal</a></i> that
is unknown to the implementation requires a diagnostic.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
It is recommended that the spelling of the <i ><a href='lex.string#string-literal'>string-literal</a></i> be
taken from the document defining that language. For example, <span class='texttt'>Ada</span>
(not <span class='texttt'>ADA</span>) and <span class='texttt'>Fortran</span> or <span class='texttt'>FORTRAN</span>, depending on
the vintage.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='specification!linkage!implementation-defined'></a></span>Every implementation shall provide for linkage to functions written in
the C programming language,
<span class='indexparent'><a class='index' id='C!linkage~to'></a></span><span class='texttt'>"C"</span>, and linkage to C++ functions, <span class='texttt'>"C++"</span>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
complex sqrt(complex);          <span class='comment'>// C++ linkage by default
</span>extern "C" {
  double sqrt(double);          <span class='comment'>// C linkage
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='specification!linkage!nesting'></a></span>Linkage specifications nest. When linkage specifications nest, the
innermost one determines the language linkage. A linkage specification
does not establish a scope. A <i ><a href='dcl.link#linkage-specification'>linkage-specification</a></i> shall
occur only in namespace scope (<a href='basic.scope'>[basic.scope]</a>). In a
<i ><a href='dcl.link#linkage-specification'>linkage-specification</a></i>, the specified language linkage applies
to the function types of all function declarators, function names with
external linkage, and variable names with external linkage declared
within the <i ><a href='dcl.link#linkage-specification'>linkage-specification</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
extern "C" void f1(void(*pf)(int));
                                <span class='comment'>// the name <span class='texttt'>f1</span> and its function type have C language
</span>                                <span class='comment'>// linkage; <span class='texttt'>pf</span> is a pointer to a C function
</span>extern "C" typedef void FUNC();
FUNC f2;                        <span class='comment'>// the name <span class='texttt'>f2</span> has C++ language linkage and the
</span>                                <span class='comment'>// function's type has C language linkage
</span>extern "C" FUNC f3;             <span class='comment'>// the name of function <span class='texttt'>f3</span> and the function's type
</span>                                <span class='comment'>// have C language linkage
</span>void (*pf2)(FUNC*);             <span class='comment'>// the name of the variable <span class='texttt'>pf2</span> has C++ linkage and
</span>                                <span class='comment'>// the type of <span class='texttt'>pf2</span> is pointer to C++ function that
</span>                                <span class='comment'>// takes one parameter of type pointer to C function
</span>extern "C" {
  static void f4();             <span class='comment'>// the name of the function f4 has
</span>                                <span class='comment'>// internal linkage (not C language
</span>                                <span class='comment'>// linkage) and the function's type
</span>                                <span class='comment'>// has C language linkage.
</span>}

extern "C" void f5() {
  extern void f4();             <span class='comment'>// OK: Name linkage (internal)
</span>                                <span class='comment'>// and function type linkage (C
</span>                                <span class='comment'>// language linkage) obtained from
</span>                                <span class='comment'>// previous declaration.
</span>}

extern void f4();               <span class='comment'>// OK: Name linkage (internal)
</span>                                <span class='comment'>// and function type linkage (C
</span>                                <span class='comment'>// language linkage) obtained from
</span>                                <span class='comment'>// previous declaration.
</span>
void f6() {
  extern void f4();             <span class='comment'>// OK: Name linkage (internal)
</span>                                <span class='comment'>// and function type linkage (C
</span>                                <span class='comment'>// language linkage) obtained from
</span>                                <span class='comment'>// previous declaration.
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<span class='indexparent'><a class='index' id='class!linkage~specification'></a></span>A C language linkage is ignored
in determining the language linkage of
the names of class members and the
function type of class member functions.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
extern "C" typedef void FUNC_c();
class C {
  void mf1(FUNC_c*);            <span class='comment'>// the name of the function <span class='texttt'>mf1</span> and the member
</span>                                <span class='comment'>// function's type have C++ language linkage; the
</span>                                <span class='comment'>// parameter has type pointer to C function
</span>  FUNC_c mf2;                   <span class='comment'>// the name of the function <span class='texttt'>mf2</span> and the member
</span>                                <span class='comment'>// function's type have C++ language linkage
</span>  static FUNC_c* q;             <span class='comment'>// the name of the data member <span class='texttt'>q</span> has C++ language
</span>                                <span class='comment'>// linkage and the data member's type is pointer to
</span>                                <span class='comment'>// C function
</span>};

extern "C" {
  class X {
    void mf();                  <span class='comment'>// the name of the function <span class='texttt'>mf</span> and the member
</span>                                <span class='comment'>// function's type have C++ language linkage
</span>    void mf2(void(*)());        <span class='comment'>// the name of the function <span class='texttt'>mf2</span> has C++ language
</span>                                <span class='comment'>// linkage; the parameter has type pointer to
</span>                                <span class='comment'>// C function
</span>  };
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >If two declarations declare functions with the same name and
parameter-type-list (<a href='dcl.fct'>[dcl.fct]</a>) to be members of the same
namespace or declare objects with the same name to be members of the same
namespace and the declarations give the names different language linkages, the
program is ill-formed; no diagnostic is required if the declarations appear in
different translation units.
<span class='indexparent'><a class='index' id='consistency!linkage~specification'></a></span>Except for functions with C++ linkage, a function declaration without a
linkage specification shall not precede the first linkage specification
for that function. A function can be declared without a linkage
specification after an explicit linkage specification has been seen; the
linkage explicitly specified in the earlier declaration is not affected
by such a function declaration.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='function!linkage~specification overloaded'></a></span>At most one function with a particular name can have C language linkage.
Two declarations for a function with C language linkage with the same
function name (ignoring the namespace names that qualify it) that appear
in different namespace scopes refer to the same function. Two
declarations for a variable with C language linkage with the same name
(ignoring the namespace names that qualify it) that appear in different
namespace scopes refer to the same variable.
An entity with C language linkage shall not be declared with the same name
as a variable in global scope, unless both declarations denote the same entity;
no diagnostic is required if the declarations appear in different translation units.
A variable with C language linkage shall not be declared with the same name as a
function with C language linkage (ignoring the namespace names that qualify the
respective names); no diagnostic is required if the declarations appear in
different translation units.
[&nbsp;<i>Note:</i><span class='space'></span>
Only
one definition for an entity with a given name
with C language linkage may appear in the
program (see <a href='basic.def.odr'>[basic.def.odr]</a>);
this implies that such an entity
must not be defined in more
than one namespace scope.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int x;
namespace A {
  extern "C" int f();
  extern "C" int g() { return 1; }
  extern "C" int h();
  extern "C" int x();               <span class='comment'>// ill-formed: same name as global-space object <span class='texttt'>x</span>
</span>}

namespace B {
  extern "C" int f();               <span class='comment'>// <span class='texttt'>A::f</span> and <span class='texttt'>B::f</span> refer to the same function
</span>  extern "C" int g() { return 1; }  <span class='comment'>// ill-formed, the function <span class='texttt'>g</span>
</span>                                    <span class='comment'>// with C language linkage has two definitions
</span>}

int A::f() { return 98; }           <span class='comment'>//definition for the function <span class='texttt'>f</span> with C language linkage
</span>extern "C" int h() { return 97; }   <span class='comment'>// definition for the function <span class='texttt'>h</span> with C language linkage
</span>                                    <span class='comment'>// <span class='texttt'>A::h</span> and <span class='texttt'>::h</span> refer to the same function
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >A declaration directly contained in a
<i ><a href='dcl.link#linkage-specification'>linkage-specification</a></i>
is treated as if it contains the
<span class='texttt'>extern</span>
specifier (<a href='dcl.stc'>[dcl.stc]</a>) for the purpose of determining the linkage of the
declared name and whether it is a definition. Such a declaration shall
not specify a storage class.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
extern "C" double f();
static double f();                  <span class='comment'>// error
</span>extern "C" int i;                   <span class='comment'>// declaration
</span>extern "C" {
  int i;                            <span class='comment'>// definition
</span>}
extern "C" static void g();         <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Because the language linkage is part of a function type, when
indirecting through a pointer to C function, the function to
which the resulting lvalue refers is considered a C function.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p ><span class='indexparent'><a class='index' id='object!linkage~specification'></a></span><span class='indexparent'><a class='index' id='linkage!implementation-defined object'></a></span>Linkage from C++ to objects defined in other languages and to objects
defined in C++ from other languages is implementation-defined and
language-dependent. Only where the object layout strategies of two
language implementations are similar enough can such linkage be
achieved.<span class='indexparent'><a class='index' id='specification!linkage'></a></span></p></div></div></div></body></html>