<!DOCTYPE html><html lang='en'><head><title>[atomics.syn]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>33</a> Atomic operations library <a class='abbr_ref' href='./#atomics'>[atomics]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>33.2</a> Header <span class='texttt'>&lt;atomic&gt;</span> synopsis <a class='abbr_ref'>[atomics.syn]</a></h2><span class='indexparent'><a class='index' id=':<atomic>'></a></span><span class='indexparent'><a class='index' id=':<atomic>'></a></span><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='atomics.order'>[atomics.order]</a>, order and consistency
</span>  enum class memory_order : <span class='textit'><span class='texttt'>unspecified</span></span>;
  template&lt;class T&gt;
    T kill_dependency(T y) noexcept;

  <span class='comment'>// <a href='atomics.lockfree'>[atomics.lockfree]</a>, lock-free property
</span>  #define ATOMIC_BOOL_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_CHAR_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_CHAR16_T_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_CHAR32_T_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_WCHAR_T_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_SHORT_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_INT_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_LONG_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_LLONG_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_POINTER_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>

  <span class='comment'>// <a href='atomics.ref.generic'>[atomics.ref.generic]</a>, class template <span class='tcode_in_codeblock'>atomic_&shy;ref</span>
</span>  template&lt;class T&gt; struct atomic_ref;
  <span class='comment'>// <a href='atomics.ref.pointer'>[atomics.ref.pointer]</a>, partial specialization for pointers
</span>  template&lt;class T&gt; struct atomic_ref&lt;T*&gt;;

  <span class='comment'>// <a href='atomics.types.generic'>[atomics.types.generic]</a>, class template <span class='tcode_in_codeblock'>atomic</span>
</span>  template&lt;class T&gt; struct atomic;
  <span class='comment'>// <a href='atomics.types.pointer'>[atomics.types.pointer]</a>, partial specialization for pointers
</span>  template&lt;class T&gt; struct atomic&lt;T*&gt;;

  <span class='comment'>// <a href='atomics.nonmembers'>[atomics.nonmembers]</a>, non-member functions
</span>  template&lt;class T&gt;
    bool atomic_is_lock_free(const volatile atomic&lt;T&gt;*) noexcept;
  template&lt;class T&gt;
    bool atomic_is_lock_free(const atomic&lt;T&gt;*) noexcept;
  template&lt;class T&gt;
    void atomic_init(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    void atomic_init(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    void atomic_store(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    void atomic_store(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    void atomic_store_explicit(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
                               memory_order) noexcept;
  template&lt;class T&gt;
    void atomic_store_explicit(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
                               memory_order) noexcept;
  template&lt;class T&gt;
    T atomic_load(const volatile atomic&lt;T&gt;*) noexcept;
  template&lt;class T&gt;
    T atomic_load(const atomic&lt;T&gt;*) noexcept;
  template&lt;class T&gt;
    T atomic_load_explicit(const volatile atomic&lt;T&gt;*, memory_order) noexcept;
  template&lt;class T&gt;
    T atomic_load_explicit(const atomic&lt;T&gt;*, memory_order) noexcept;
  template&lt;class T&gt;
    T atomic_exchange(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    T atomic_exchange(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    T atomic_exchange_explicit(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
                               memory_order) noexcept;
  template&lt;class T&gt;
    T atomic_exchange_explicit(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
                               memory_order) noexcept;
  template&lt;class T&gt;
    bool atomic_compare_exchange_weak(volatile atomic&lt;T&gt;*,
                                      typename atomic&lt;T&gt;::value_type*,
                                      typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    bool atomic_compare_exchange_weak(atomic&lt;T&gt;*,
                                      typename atomic&lt;T&gt;::value_type*,
                                      typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    bool atomic_compare_exchange_strong(volatile atomic&lt;T&gt;*,
                                        typename atomic&lt;T&gt;::value_type*,
                                        typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    bool atomic_compare_exchange_strong(atomic&lt;T&gt;*,
                                        typename atomic&lt;T&gt;::value_type*,
                                        typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    bool atomic_compare_exchange_weak_explicit(volatile atomic&lt;T&gt;*,
                                               typename atomic&lt;T&gt;::value_type*,
                                               typename atomic&lt;T&gt;::value_type,
                                               memory_order, memory_order) noexcept;
  template&lt;class T&gt;
    bool atomic_compare_exchange_weak_explicit(atomic&lt;T&gt;*,
                                               typename atomic&lt;T&gt;::value_type*,
                                               typename atomic&lt;T&gt;::value_type,
                                               memory_order, memory_order) noexcept;
  template&lt;class T&gt;
    bool atomic_compare_exchange_strong_explicit(volatile atomic&lt;T&gt;*,
                                                 typename atomic&lt;T&gt;::value_type*,
                                                 typename atomic&lt;T&gt;::value_type,
                                                 memory_order, memory_order) noexcept;
  template&lt;class T&gt;
    bool atomic_compare_exchange_strong_explicit(atomic&lt;T&gt;*,
                                                 typename atomic&lt;T&gt;::value_type*,
                                                 typename atomic&lt;T&gt;::value_type,
                                                 memory_order, memory_order) noexcept;

  template&lt;class T&gt;
    T atomic_fetch_add(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::difference_type) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_add(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::difference_type) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_add_explicit(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::difference_type,
                                memory_order) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_add_explicit(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::difference_type,
                                memory_order) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_sub(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::difference_type) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_sub(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::difference_type) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_sub_explicit(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::difference_type,
                                memory_order) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_sub_explicit(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::difference_type,
                                memory_order) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_and(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_and(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_and_explicit(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
                                memory_order) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_and_explicit(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
                                memory_order) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_or(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_or(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_or_explicit(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
                               memory_order) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_or_explicit(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
                               memory_order) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_xor(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_xor(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_xor_explicit(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
                                memory_order) noexcept;
  template&lt;class T&gt;
    T atomic_fetch_xor_explicit(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
                                memory_order) noexcept;

  <span class='comment'>// <a href='atomics.types.operations'>[atomics.types.operations]</a>, initialization
</span>  #define ATOMIC_VAR_INIT(value) <span class='textit'><span class='texttt'>see below</span></span>

  <span class='comment'>// <a href='atomics.alias'>[atomics.alias]</a>, type aliases
</span>  using atomic_bool           = atomic&lt;bool&gt;;
  using atomic_char           = atomic&lt;char&gt;;
  using atomic_schar          = atomic&lt;signed char&gt;;
  using atomic_uchar          = atomic&lt;unsigned char&gt;;
  using atomic_short          = atomic&lt;short&gt;;
  using atomic_ushort         = atomic&lt;unsigned short&gt;;
  using atomic_int            = atomic&lt;int&gt;;
  using atomic_uint           = atomic&lt;unsigned int&gt;;
  using atomic_long           = atomic&lt;long&gt;;
  using atomic_ulong          = atomic&lt;unsigned long&gt;;
  using atomic_llong          = atomic&lt;long long&gt;;
  using atomic_ullong         = atomic&lt;unsigned long long&gt;;
  using atomic_char16_t       = atomic&lt;char16_t&gt;;
  using atomic_char32_t       = atomic&lt;char32_t&gt;;
  using atomic_wchar_t        = atomic&lt;wchar_t&gt;;

  using atomic_int8_t         = atomic&lt;int8_t&gt;;
  using atomic_uint8_t        = atomic&lt;uint8_t&gt;;
  using atomic_int16_t        = atomic&lt;int16_t&gt;;
  using atomic_uint16_t       = atomic&lt;uint16_t&gt;;
  using atomic_int32_t        = atomic&lt;int32_t&gt;;
  using atomic_uint32_t       = atomic&lt;uint32_t&gt;;
  using atomic_int64_t        = atomic&lt;int64_t&gt;;
  using atomic_uint64_t       = atomic&lt;uint64_t&gt;;

  using atomic_int_least8_t   = atomic&lt;int_least8_t&gt;;
  using atomic_uint_least8_t  = atomic&lt;uint_least8_t&gt;;
  using atomic_int_least16_t  = atomic&lt;int_least16_t&gt;;
  using atomic_uint_least16_t = atomic&lt;uint_least16_t&gt;;
  using atomic_int_least32_t  = atomic&lt;int_least32_t&gt;;
  using atomic_uint_least32_t = atomic&lt;uint_least32_t&gt;;
  using atomic_int_least64_t  = atomic&lt;int_least64_t&gt;;
  using atomic_uint_least64_t = atomic&lt;uint_least64_t&gt;;

  using atomic_int_fast8_t    = atomic&lt;int_fast8_t&gt;;
  using atomic_uint_fast8_t   = atomic&lt;uint_fast8_t&gt;;
  using atomic_int_fast16_t   = atomic&lt;int_fast16_t&gt;;
  using atomic_uint_fast16_t  = atomic&lt;uint_fast16_t&gt;;
  using atomic_int_fast32_t   = atomic&lt;int_fast32_t&gt;;
  using atomic_uint_fast32_t  = atomic&lt;uint_fast32_t&gt;;
  using atomic_int_fast64_t   = atomic&lt;int_fast64_t&gt;;
  using atomic_uint_fast64_t  = atomic&lt;uint_fast64_t&gt;;

  using atomic_intptr_t       = atomic&lt;intptr_t&gt;;
  using atomic_uintptr_t      = atomic&lt;uintptr_t&gt;;
  using atomic_size_t         = atomic&lt;size_t&gt;;
  using atomic_ptrdiff_t      = atomic&lt;ptrdiff_t&gt;;
  using atomic_intmax_t       = atomic&lt;intmax_t&gt;;
  using atomic_uintmax_t      = atomic&lt;uintmax_t&gt;;

  <span class='comment'>// <a href='atomics.flag'>[atomics.flag]</a>, flag type and operations
</span>  struct atomic_flag;
  bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
  bool atomic_flag_test_and_set(atomic_flag*) noexcept;
  bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear(volatile atomic_flag*) noexcept;
  void atomic_flag_clear(atomic_flag*) noexcept;
  void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;
  #define ATOMIC_FLAG_INIT <span class='textit'><span class='texttt'>see below</span></span>

  <span class='comment'>// <a href='atomics.fences'>[atomics.fences]</a>, fences
</span>  extern "C" void atomic_thread_fence(memory_order) noexcept;
  extern "C" void atomic_signal_fence(memory_order) noexcept;
}</pre></div></body></html>