<!DOCTYPE html><html lang='en'><head><title>[atomics.syn]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>29</a> Atomic operations library <a class='abbr_ref' href='./#atomics'>[atomics]</a></h1><div id='atomics.syn'><h2 ><a class='secnum' style='min-width:88pt'>29.2</a> Header <span class='texttt'>&lt;atomic&gt;</span> synopsis <a class='abbr_ref'>[atomics.syn]</a></h2><p ><span class='indexparent'><a class='index' id='atomic'></a></span></p><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='atomics.order'>[atomics.order]</a>, order and consistency
</span>  enum memory_order;
  template &lt;class T&gt;
    T kill_dependency(T y) noexcept;

  <span class='comment'>// <a href='atomics.lockfree'>[atomics.lockfree]</a>, lock-free property
</span>  #define ATOMIC_BOOL_LOCK_FREE <i><span class='texttt'>unspecified</span></i>
  #define ATOMIC_CHAR_LOCK_FREE <i><span class='texttt'>unspecified</span></i>
  #define ATOMIC_CHAR16_T_LOCK_FREE <i><span class='texttt'>unspecified</span></i>
  #define ATOMIC_CHAR32_T_LOCK_FREE <i><span class='texttt'>unspecified</span></i>
  #define ATOMIC_WCHAR_T_LOCK_FREE <i><span class='texttt'>unspecified</span></i>
  #define ATOMIC_SHORT_LOCK_FREE <i><span class='texttt'>unspecified</span></i>
  #define ATOMIC_INT_LOCK_FREE <i><span class='texttt'>unspecified</span></i>
  #define ATOMIC_LONG_LOCK_FREE <i><span class='texttt'>unspecified</span></i>
  #define ATOMIC_LLONG_LOCK_FREE <i><span class='texttt'>unspecified</span></i>
  #define ATOMIC_POINTER_LOCK_FREE <i><span class='texttt'>unspecified</span></i>

  <span class='comment'>// <a href='atomics.types.generic'>[atomics.types.generic]</a>, generic types
</span>  template&lt;class T&gt; struct atomic;
  template&lt;&gt; struct atomic&lt;<i>integral</i>&gt;;
  template&lt;class T&gt; struct atomic&lt;T*&gt;;

  <span class='comment'>// <a href='atomics.types.operations.general'>[atomics.types.operations.general]</a>, general operations on atomic types
</span>  <span class='comment'>// In the following declarations, <span class='texttt'><i>atomic-type</i></span> is either <span class='texttt'>atomic&lt;T&gt;</span> or a named base class
</span>  <span class='comment'>// for <span class='texttt'>T</span> from Table <a href='atomics.types.generic#tab:atomics.integral'>[tab:atomics.integral]</a> or inferred from Table <a href='atomics.types.generic#tab:atomics.typedefs'>[tab:atomics.typedefs]</a> or from <span class='texttt'>bool</span>. If it is <span class='texttt'>atomic&lt;T&gt;</span>,
</span>  <span class='comment'>// then the declaration is a template declaration prefixed with <span class='texttt'>template &lt;class T&gt;</span>.
</span>  bool atomic_is_lock_free(const volatile <i>atomic-type</i>*) noexcept;
  bool atomic_is_lock_free(const <i>atomic-type</i>*) noexcept;
  void atomic_init(volatile <i>atomic-type</i>*, T) noexcept;
  void atomic_init(<i>atomic-type</i>*, T) noexcept;
  void atomic_store(volatile <i>atomic-type</i>*, T) noexcept;
  void atomic_store(<i>atomic-type</i>*, T) noexcept;
  void atomic_store_explicit(volatile <i>atomic-type</i>*, T, memory_order) noexcept;
  void atomic_store_explicit(<i>atomic-type</i>*, T, memory_order) noexcept;
  T atomic_load(const volatile <i>atomic-type</i>*) noexcept;
  T atomic_load(const <i>atomic-type</i>*) noexcept;
  T atomic_load_explicit(const volatile <i>atomic-type</i>*, memory_order) noexcept;
  T atomic_load_explicit(const <i>atomic-type</i>*, memory_order) noexcept;
  T atomic_exchange(volatile <i>atomic-type</i>*, T) noexcept;
  T atomic_exchange(<i>atomic-type</i>*, T) noexcept;
  T atomic_exchange_explicit(volatile <i>atomic-type</i>*, T, memory_order) noexcept;
  T atomic_exchange_explicit(<i>atomic-type</i>*, T, memory_order) noexcept;
  bool atomic_compare_exchange_weak(volatile <i>atomic-type</i>*, T*, T) noexcept;
  bool atomic_compare_exchange_weak(<i>atomic-type</i>*, T*, T) noexcept;
  bool atomic_compare_exchange_strong(volatile <i>atomic-type</i>*, T*, T) noexcept;
  bool atomic_compare_exchange_strong(<i>atomic-type</i>*, T*, T) noexcept;
  bool atomic_compare_exchange_weak_explicit(volatile <i>atomic-type</i>*, T*, T, 
    memory_order, memory_order) noexcept;
  bool atomic_compare_exchange_weak_explicit(<i>atomic-type</i>*, T*, T,
    memory_order, memory_order) noexcept;
  bool atomic_compare_exchange_strong_explicit(volatile <i>atomic-type</i>*, T*, T,
    memory_order, memory_order) noexcept;
  bool atomic_compare_exchange_strong_explicit(<i>atomic-type</i>*, T*, T,
    memory_order, memory_order) noexcept;

  <span class='comment'>// <a href='atomics.types.operations.templ'>[atomics.types.operations.templ]</a>, templated operations on atomic types
</span>  template &lt;class T&gt;
    T atomic_fetch_add(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_add(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_add_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_add_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_sub(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_sub(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_sub_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_sub_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_and(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_and(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_and_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_and_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_or(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_or(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_or_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_or_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_xor(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_xor(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_xor_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_xor_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;

  <span class='comment'>// <a href='atomics.types.operations.arith'>[atomics.types.operations.arith]</a>, arithmetic operations on atomic types
</span>  <span class='comment'>// In the following declarations, <span class='texttt'><i>atomic-integral</i></span> is either <span class='texttt'>atomic&lt;T&gt;</span> or a named base class
</span>  <span class='comment'>// for <span class='texttt'>T</span> from Table <a href='atomics.types.generic#tab:atomics.integral'>[tab:atomics.integral]</a> or inferred from Table <a href='atomics.types.generic#tab:atomics.typedefs'>[tab:atomics.typedefs]</a>. If it is <span class='texttt'>atomic&lt;T&gt;</span>, then the declaration
</span>  <span class='comment'>// is a template specialization declaration prefixed with <span class='texttt'>template &lt;&gt;</span>.
</span>  <i>integral</i> atomic_fetch_add(volatile <i>atomic-integral</i>*, <i>integral</i>) noexcept;
  <i>integral</i> atomic_fetch_add(<i>atomic-integral</i>*, <i>integral</i>) noexcept;
  <i>integral</i> atomic_fetch_add_explicit(volatile <i>atomic-integral</i>*, <i>integral</i>, memory_order) noexcept;
  <i>integral</i> atomic_fetch_add_explicit(<i>atomic-integral</i>*, <i>integral</i>, memory_order) noexcept;
  <i>integral</i> atomic_fetch_sub(volatile <i>atomic-integral</i>*, <i>integral</i>) noexcept;
  <i>integral</i> atomic_fetch_sub(<i>atomic-integral</i>*, <i>integral</i>) noexcept;
  <i>integral</i> atomic_fetch_sub_explicit(volatile <i>atomic-integral</i>*, <i>integral</i>, memory_order) noexcept;
  <i>integral</i> atomic_fetch_sub_explicit(<i>atomic-integral</i>*, <i>integral</i>, memory_order) noexcept;
  <i>integral</i> atomic_fetch_and(volatile <i>atomic-integral</i>*, <i>integral</i>) noexcept;
  <i>integral</i> atomic_fetch_and(<i>atomic-integral</i>*, <i>integral</i>) noexcept;
  <i>integral</i> atomic_fetch_and_explicit(volatile <i>atomic-integral</i>*, <i>integral</i>, memory_order) noexcept;
  <i>integral</i> atomic_fetch_and_explicit(<i>atomic-integral</i>*, <i>integral</i>, memory_order) noexcept;
  <i>integral</i> atomic_fetch_or(volatile <i>atomic-integral</i>*, <i>integral</i>) noexcept;
  <i>integral</i> atomic_fetch_or(<i>atomic-integral</i>*, <i>integral</i>) noexcept;
  <i>integral</i> atomic_fetch_or_explicit(volatile <i>atomic-integral</i>*, <i>integral</i>, memory_order) noexcept;
  <i>integral</i> atomic_fetch_or_explicit(<i>atomic-integral</i>*, <i>integral</i>, memory_order) noexcept;
  <i>integral</i> atomic_fetch_xor(volatile <i>atomic-integral</i>*, <i>integral</i>) noexcept;
  <i>integral</i> atomic_fetch_xor(<i>atomic-integral</i>*, <i>integral</i>) noexcept;
  <i>integral</i> atomic_fetch_xor_explicit(volatile <i>atomic-integral</i>*, <i>integral</i>, memory_order) noexcept;
  <i>integral</i> atomic_fetch_xor_explicit(<i>atomic-integral</i>*, <i>integral</i>, memory_order) noexcept;

  <span class='comment'>// <a href='atomics.types.operations.pointer'>[atomics.types.operations.pointer]</a>, partial specializations for pointers
</span>  template &lt;class T&gt;
    T* atomic_fetch_add(volatile atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_add(atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_add_explicit(volatile atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_add_explicit(atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_sub(volatile atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_sub(atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_sub_explicit(volatile atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_sub_explicit(atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;

  <span class='comment'>// <a href='atomics.types.operations.req'>[atomics.types.operations.req]</a>, initialization
</span>  #define ATOMIC_VAR_INIT(value) <i><span class='texttt'>see below</span></i>

  <span class='comment'>// <a href='atomics.flag'>[atomics.flag]</a>, flag type and operations
</span>  struct atomic_flag;
  bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
  bool atomic_flag_test_and_set(atomic_flag*) noexcept;
  bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear(volatile atomic_flag*) noexcept;
  void atomic_flag_clear(atomic_flag*) noexcept;
  void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;
  #define ATOMIC_FLAG_INIT <i><span class='texttt'>see below</span></i>

  <span class='comment'>// <a href='atomics.fences'>[atomics.fences]</a>, fences
</span>  extern "C" void atomic_thread_fence(memory_order) noexcept;
  extern "C" void atomic_signal_fence(memory_order) noexcept;
}
</pre></div></div></body></html>