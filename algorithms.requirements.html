<!DOCTYPE html><html lang='en'><head><title>[algorithms.requirements]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>25</a> Algorithms library <a class='abbr_ref' href='./#algorithms'>[algorithms]</a></h1><div id='algorithms.requirements'><h2 ><a class='secnum' style='min-width:88pt'>25.3</a> Algorithms requirements <a class='abbr_ref'>[algorithms.requirements]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5d1e1019ffa0d7f52dd420e5a189e8fc70b023e4/source/algorithms.tex#L1028'>#</a></div><p >All of the algorithms are separated from the particular implementations of data structures and are
parameterized by iterator types.
Because of this, they can work with program-defined data structures, as long
as these data structures have iterator types satisfying the assumptions on the algorithms.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5d1e1019ffa0d7f52dd420e5a189e8fc70b023e4/source/algorithms.tex#L1034'>#</a></div><p >For purposes of determining the existence of data races, algorithms shall
not modify objects referenced through an iterator argument unless the
specification requires such modification.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5d1e1019ffa0d7f52dd420e5a189e8fc70b023e4/source/algorithms.tex#L1039'>#</a></div><p >Throughout this Clause, the names of template parameters
are used to express type requirements.
</p><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >If an algorithm's template parameter is named
<span class='texttt'>InputIterator</span>,
<span class='texttt'>InputIterator1</span>,
or
<span class='texttt'>InputIterator2</span>,
the template argument shall satisfy the
requirements of an input iterator (<a href='input.iterators'>[input.iterators]</a>).
</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p >If an algorithm's template parameter is named
<span class='texttt'>OutputIterator</span>,
<span class='texttt'>OutputIterator1</span>,
or
<span class='texttt'>OutputIterator2</span>,
the template argument shall satisfy the requirements
of an output iterator (<a href='output.iterators'>[output.iterators]</a>).
</p></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><p >If an algorithm's template parameter is named
<span class='texttt'>ForwardIterator</span>,
<span class='texttt'>ForwardIterator1</span>,
or
<span class='texttt'>ForwardIterator2</span>,
the template argument shall satisfy the requirements
of a forward iterator (<a href='forward.iterators'>[forward.iterators]</a>).
</p></li><li id='3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.4'>(3.4)</a></div><p >If an algorithm's template parameter is named
<span class='texttt'>BidirectionalIterator</span>,
<span class='texttt'>BidirectionalIterator1</span>,
or
<span class='texttt'>BidirectionalIterator2</span>,
the template argument shall satisfy the requirements
of a bidirectional iterator (<a href='bidirectional.iterators'>[bidirectional.iterators]</a>).
</p></li><li id='3.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.5'>(3.5)</a></div><p >If an algorithm's template parameter is named
<span class='texttt'>RandomAccessIterator</span>,
<span class='texttt'>RandomAccessIterator1</span>,
or
<span class='texttt'>RandomAccessIterator2</span>,
the template argument shall satisfy the requirements
of a random-access iterator (<a href='random.access.iterators'>[random.access.iterators]</a>).
</p></li></ul></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5d1e1019ffa0d7f52dd420e5a189e8fc70b023e4/source/algorithms.tex#L1085'>#</a></div><p >If an algorithm's
<span class='textit'>Effects:</span>
section says that a value pointed to by any iterator passed
as an argument is modified, then that algorithm has an additional
type requirement:
The type of that argument shall satisfy the requirements
of a mutable iterator (<a href='iterator.requirements'>[iterator.requirements]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
This requirement does not affect arguments that are named
<span class='texttt'>OutputIterator</span>,
<span class='texttt'>OutputIterator1</span>,
or
<span class='texttt'>OutputIterator2</span>,
because output iterators must always be mutable.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5d1e1019ffa0d7f52dd420e5a189e8fc70b023e4/source/algorithms.tex#L1102'>#</a></div><p >Both in-place and copying versions are provided for certain
algorithms.<a class='footnotenum' href='#footnote-262'>262</a>
When such a version is provided for <span class='textit'>algorithm</span> it is called
<span class='textit'>algorithm<span class='texttt'>_&shy;copy</span></span>. Algorithms that take predicates end with the
suffix <span class='texttt'>_&shy;if</span> (which follows the suffix <span class='texttt'>_&shy;copy</span>).</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5d1e1019ffa0d7f52dd420e5a189e8fc70b023e4/source/algorithms.tex#L1113'>#</a></div><p >The
<span class='texttt'>Predicate</span>
parameter is used whenever an algorithm expects a function object (<a href='function.objects'>[function.objects]</a>)
that, when applied to the result
of dereferencing the corresponding iterator, returns a value testable as
<span class='texttt'>true</span>.
In other words, if an algorithm
takes
<span class='texttt'>Predicate pred</span>
as its argument and <span class='texttt'>first</span>
as its iterator argument, it should work correctly in the
construct
<span class='texttt'>pred(*first)</span> contextually converted to <span class='texttt'>bool</span> (Clause <a href='conv'>[conv]</a>).
The function object
<span class='texttt'>pred</span>
shall not apply any non-constant
function through the dereferenced iterator.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5d1e1019ffa0d7f52dd420e5a189e8fc70b023e4/source/algorithms.tex#L1132'>#</a></div><p >The
<span class='texttt'>BinaryPredicate</span>
parameter is used whenever an algorithm expects a function object that when applied to
the result of dereferencing two corresponding iterators or to dereferencing an
iterator and type
<span class='texttt'>T</span>
when
<span class='texttt'>T</span>
is part of the signature returns a value testable as
<span class='texttt'>true</span>.
In other words, if an algorithm takes
<span class='texttt'>BinaryPredicate binary_&shy;pred</span>
as its argument and <span class='texttt'>first1</span> and <span class='texttt'>first2</span> as
its iterator arguments, it should work correctly in
the construct
<span class='texttt'>binary_&shy;pred(*first1, *first2)</span> contextually converted to <span class='texttt'>bool</span> (Clause <a href='conv'>[conv]</a>).
<span class='texttt'>BinaryPredicate</span>
always takes the first
iterator's <span class='texttt'>value_&shy;type</span>
as its first argument, that is, in those cases when
<span class='texttt'>T value</span>
is part of the signature, it should work
correctly in the
construct <span class='texttt'>binary_&shy;pred(*first1, value)</span> contextually converted to <span class='texttt'>bool</span> (Clause <a href='conv'>[conv]</a>).
<span class='texttt'>binary_&shy;pred</span> shall not
apply any non-constant function through the dereferenced iterators.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5d1e1019ffa0d7f52dd420e5a189e8fc70b023e4/source/algorithms.tex#L1160'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
Unless otherwise specified, algorithms that take function objects as arguments
are permitted to copy those function objects freely. Programmers for whom object
identity is important should consider using a wrapper class that points to a
noncopied implementation object such as <span class='texttt'>reference_&shy;wrapper&lt;T&gt;</span> (<a href='refwrap'>[refwrap]</a>), or some equivalent solution.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5d1e1019ffa0d7f52dd420e5a189e8fc70b023e4/source/algorithms.tex#L1168'>#</a></div><p >When the description of an algorithm gives an expression such as
<span class='texttt'>*first == value</span>
for a condition, the expression shall evaluate to
either <span class='texttt'>true</span> or <span class='texttt'>false</span> in boolean contexts.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/5d1e1019ffa0d7f52dd420e5a189e8fc70b023e4/source/algorithms.tex#L1174'>#</a></div><p >In the description of the algorithms operators
<span class='texttt'>+</span>
and
<span class='texttt'>-</span>
are used for some of the iterator categories for which
they do not have to be defined.
In these cases the semantics of
<span class='texttt'>a+n</span>
is the same as that of</p><pre class='codeblock'>
X tmp = a;
advance(tmp, n);
return tmp;</pre><p >and that of
<span class='texttt'>b-a</span>
is the same as of</p><pre class='codeblock'>
return distance(a, b);</pre></div><div class='footnote' id='footnote-262'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-262'>262)</a></div><p >The decision whether to include a copying version was
usually based on complexity considerations. When the cost of doing the operation
dominates the cost of copy, the copying version is not included. For example,
<span class='texttt'>sort_&shy;copy</span> is not included because the cost of sorting is much more
significant, and users might as well do <span class='texttt'>copy</span> followed by <span class='texttt'>sort</span>.</p></div></div></div></body></html>