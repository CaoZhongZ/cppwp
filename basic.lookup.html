<!DOCTYPE html><html lang='en'><head><title>[basic.lookup]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><div id='basic.lookup'><h2 ><a class='secnum' style='min-width:88pt'>3.4</a> Name lookup <a class='abbr_ref'>[basic.lookup]</a></h2><p ><span class='indexparent'><a class='index' id='scope,name_lookup_and'></a></span><span class='indexparent'><a class='index' id='lookup,name'></a></span>
</p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The name lookup rules apply uniformly to all names (including
<i ><a href='dcl.typedef#nt:typedef-name'>typedef-names</a></i> (<a href='dcl.typedef'>[dcl.typedef]</a>),
<i ><a href='namespace.def#nt:namespace-name'>namespace-names</a></i> (<a href='basic.namespace'>[basic.namespace]</a>), and
<i ><a href='class#nt:class-name'>class-names</a></i> (<a href='class.name'>[class.name]</a>)) wherever the grammar allows
such names in the context discussed by a particular rule. Name lookup
associates the use of a name with a declaration (<a href='basic.def'>[basic.def]</a>) of
that name. Name lookup shall find an unambiguous declaration for the
name (see <a href='class.member.lookup'>[class.member.lookup]</a>). Name lookup may associate more
than one declaration with a name if it finds the name to be a function
name; the declarations are said to form a set of overloaded
functions (<a href='over.load'>[over.load]</a>). Overload resolution (<a href='over.match'>[over.match]</a>)
takes place after name lookup has succeeded. The access rules
(Clause <a href='class.access'>[class.access]</a>) are considered only once name lookup and
function overload resolution (if applicable) have succeeded. Only after
name lookup, function overload resolution (if applicable) and access
checking have succeeded are the attributes introduced by the name's
declaration used further in expression processing (Clause <a href='expr'>[expr]</a>).</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A name “looked up in the context of an expression” is looked up as an
unqualified name in the scope where the expression is found.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The injected-class-name of a class (Clause <a href='class'>[class]</a>) is also
considered to be a member of that class for the purposes of name hiding
and lookup.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> <a href='basic.link'>[basic.link]</a> discusses linkage issues. The notions of
scope, point of declaration and name hiding are discussed
in <a href='basic.scope'>[basic.scope]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='unqual'><h3 ><a class='secnum' href='#unqual' style='min-width:103pt'>3.4.1</a> Unqualified name lookup <a class='abbr_ref' href='basic.lookup.unqual'>[basic.lookup.unqual]</a></h3><div class='para' id='unqual-1'><div class='marginalizedparent'><a class='marginalized' href='#unqual-1'>1</a></div><p ><span class='indexparent'><a class='index' id='lookup,unqualified_name'></a></span><span class='indexparent'><a class='index' id='name,unqualified'></a></span>In all the cases listed in <a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>, the scopes are
searched for a declaration in the order listed in each of the respective
categories; name lookup ends as soon as a declaration is found for the
name. If no declaration is found, the program is ill-formed.</p></div><div class='para' id='unqual-2'><div class='marginalizedparent'><a class='marginalized' href='#unqual-2'>2</a></div><p >The declarations from the namespace nominated by a
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> become visible in a namespace enclosing the
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i>; see <a href='namespace.udir'>[namespace.udir]</a>. For the purpose of
the unqualified name lookup rules described
in <a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>, the declarations from the namespace
nominated by the <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> are considered members of
that enclosing namespace.</p></div><div class='para' id='unqual-3'><div class='marginalizedparent'><a class='marginalized' href='#unqual-3'>3</a></div><p >The lookup for an unqualified name used as the
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> of a function call is described
in <a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>. [&nbsp;<i>Note:</i><span class='space'></span> For purposes of determining
(during parsing) whether an expression is a
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> for a function call, the usual name lookup
rules apply. The rules in <a href='basic.lookup.argdep'>[basic.lookup.argdep]</a> have no effect on
the syntactic interpretation of an expression. For example,</p><pre class='codeblock'>
typedef int f;
namespace N {
  struct A {
    friend void f(A &amp;);
    operator int();
    void g(A a) {
      int i = f(a);         <span class='comment'>// <span class='texttt'>f</span> is the typedef, not the friend
</span>                            <span class='comment'>// function: equivalent to <span class='texttt'>int(a)</span>
</span>    }
  };
}
</pre><p >Because the expression is not a function call, the argument-dependent
name lookup (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>) does not apply and the friend
function <span class='texttt'>f</span> is not found. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='unqual-4'><div class='marginalizedparent'><a class='marginalized' href='#unqual-4'>4</a></div><p >A name used in global scope, outside of any function, class or
user-declared namespace, shall be declared before its use in global
scope.</p></div><div class='para' id='unqual-5'><div class='marginalizedparent'><a class='marginalized' href='#unqual-5'>5</a></div><p >A name used in a user-declared namespace outside of the definition of
any function or class shall be declared before its use in that namespace
or before its use in a namespace enclosing its namespace.</p></div><div class='para' id='unqual-6'><div class='marginalizedparent'><a class='marginalized' href='#unqual-6'>6</a></div><p >A name used in the definition of a function following the function's
<i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i><a class='footnotenum' href='#footnote-28'>28</a>
that is a member of namespace <span class='texttt'>N</span> (where, only for the purpose of
exposition, <span class='texttt'>N</span> could represent the global scope) shall be
declared before its use in the block in which it is used or in one of
its enclosing blocks (<a href='stmt.block'>[stmt.block]</a>) or shall be declared before its
use in namespace <span class='texttt'>N</span> or, if <span class='texttt'>N</span> is a nested namespace, shall
be declared before its use in one of <span class='texttt'>N</span>'s enclosing namespaces.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace A {
  namespace N {
    void f();
  }
}
void A::N::f() {
  i = 5;
  <span class='comment'>// The following scopes are searched for a declaration of <span class='texttt'>i</span>:
</span>  <span class='comment'>// 1) outermost block scope of <span class='texttt'>A::N::f</span>, before the use of <span class='texttt'>i</span>
</span>  <span class='comment'>// 2) scope of namespace <span class='texttt'>N</span>
</span>  <span class='comment'>// 3) scope of namespace <span class='texttt'>A</span>
</span>  <span class='comment'>// 4) global scope, before the definition of <span class='texttt'>A::N::f</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='unqual-7'><div class='marginalizedparent'><a class='marginalized' href='#unqual-7'>7</a></div><p >A name used in the definition of a class <span class='texttt'>X</span> outside of a member
function body, default argument, <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>,
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> of a non-static data member,
or nested class definition<a class='footnotenum' href='#footnote-29'>29</a>
shall be declared in one of the following ways:</p><ul ><li ><p >before its use in class <span class='texttt'>X</span> or be a member of a base class
of <span class='texttt'>X</span> (<a href='class.member.lookup'>[class.member.lookup]</a>), or
</p></li><li ><p >if <span class='texttt'>X</span> is a nested class of class
<span class='texttt'>Y</span> (<a href='class.nest'>[class.nest]</a>), before the definition of <span class='texttt'>X</span> in
<span class='texttt'>Y</span>, or shall be a member of a base class of <span class='texttt'>Y</span> (this
lookup applies in turn to <span class='texttt'>Y</span> 's enclosing classes, starting with
the innermost enclosing class),<a class='footnotenum' href='#footnote-30'>30</a>
or
</p></li><li ><p >if <span class='texttt'>X</span> is a local class (<a href='class.local'>[class.local]</a>) or is a nested
class of a local class, before the definition of class <span class='texttt'>X</span> in a
block enclosing the definition of class <span class='texttt'>X</span>, or
</p></li><li ><p >if <span class='texttt'>X</span> is a member of namespace <span class='texttt'>N</span>, or is a nested
class of a class that is a member of <span class='texttt'>N</span>, or is a local class or a
nested class within a local class of a function that is a member of
<span class='texttt'>N</span>, before the definition of class <span class='texttt'>X</span> in namespace
<span class='texttt'>N</span> or in one of <span class='texttt'>N</span> 's enclosing namespaces.
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace M {
  class B { };
}

</pre><pre class='codeblock'>
namespace N {
  class Y : public M::B {
    class X {
      int a[i];
    };
  };
}

<span class='comment'>// The following scopes are searched for a declaration of <span class='texttt'>i</span>:
</span><span class='comment'>// 1) scope of class <span class='texttt'>N::Y::X</span>, before the use of <span class='texttt'>i</span>
</span><span class='comment'>// 2) scope of class <span class='texttt'>N::Y</span>, before the definition of <span class='texttt'>N::Y::X</span>
</span><span class='comment'>// 3) scope of <span class='texttt'>N::Y</span>'s base class <span class='texttt'>M::B</span>
</span><span class='comment'>// 4) scope of namespace <span class='texttt'>N</span>, before the definition of <span class='texttt'>N::Y</span>
</span><span class='comment'>// 5) global scope, before the definition of <span class='texttt'>N</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;] [&nbsp;<i>Note:</i><span class='space'></span> When looking for a prior declaration of a class
or function introduced by a <span class='texttt'>friend</span> declaration, scopes outside
of the innermost enclosing namespace scope are not considered;
see <a href='namespace.memdef'>[namespace.memdef]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] [&nbsp;<i>Note:</i><span class='space'></span> <a href='basic.scope.class'>[basic.scope.class]</a>
further describes the restrictions on the use of names in a class
definition. <a href='class.nest'>[class.nest]</a> further describes the restrictions on the
use of names in nested class definitions. <a href='class.local'>[class.local]</a> further
describes the restrictions on the use of names in local class
definitions. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='unqual-8'><div class='marginalizedparent'><a class='marginalized' href='#unqual-8'>8</a></div><p >For the members of a class <span class='texttt'>X</span>, a name used in a member function
body, in a default argument, in an <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>, in the
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> of a non-static data
member (<a href='class.mem'>[class.mem]</a>), or in the definition of a class member
outside of the definition of <span class='texttt'>X</span>, following the
member's
<i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i><a class='footnotenum' href='#footnote-31'>31</a>, shall be declared in one of the
following ways:</p><ul ><li ><p >before its use in the block in which it is used or in an enclosing
block (<a href='stmt.block'>[stmt.block]</a>), or</p></li><li ><p >shall be a member of class <span class='texttt'>X</span> or be a member of a base
class of <span class='texttt'>X</span> (<a href='class.member.lookup'>[class.member.lookup]</a>), or</p></li><li ><p >if <span class='texttt'>X</span>
is a nested class of class <span class='texttt'>Y</span> (<a href='class.nest'>[class.nest]</a>), shall be a
member of <span class='texttt'>Y</span>, or shall be a member of a base class of <span class='texttt'>Y</span>
(this lookup applies in turn to <span class='texttt'>Y</span>'s enclosing classes, starting
with the innermost enclosing class),<a class='footnotenum' href='#footnote-32'>32</a>
or</p></li><li ><p >if <span class='texttt'>X</span> is a local class (<a href='class.local'>[class.local]</a>) or is a nested
class of a local class, before the definition of class <span class='texttt'>X</span> in a
block enclosing the definition of class <span class='texttt'>X</span>, or</p></li><li ><p >if <span class='texttt'>X</span> is a member of namespace <span class='texttt'>N</span>, or is a nested
class of a class that is a member of <span class='texttt'>N</span>, or is a local class or a
nested class within a local class of a function that is a member of
<span class='texttt'>N</span>, before the use of the name, in namespace <span class='texttt'>N</span>
or in one of <span class='texttt'>N</span> 's enclosing namespaces.
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
class B { };
namespace M {
  namespace N {
    class X : public B {
      void f();
    };
  }
}
void M::N::X::f() {
  i = 16;
}

<span class='comment'>// The following scopes are searched for a declaration of <span class='texttt'>i</span>:
</span><span class='comment'>// 1) outermost block scope of <span class='texttt'>M::N::X::f</span>, before the use of <span class='texttt'>i</span>
</span><span class='comment'>// 2) scope of class <span class='texttt'>M::N::X</span>
</span><span class='comment'>// 3) scope of <span class='texttt'>M::N::X</span>'s base class <span class='texttt'>B</span>
</span><span class='comment'>// 4) scope of namespace <span class='texttt'>M::N</span>
</span><span class='comment'>// 5) scope of namespace <span class='texttt'>M</span>
</span><span class='comment'>// 6) global scope, before the definition of <span class='texttt'>M::N::X::f</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;] [&nbsp;<i>Note:</i><span class='space'></span> <a href='class.mfct'>[class.mfct]</a> and <a href='class.static'>[class.static]</a> further
describe the restrictions on the use of names in member function
definitions. <a href='class.nest'>[class.nest]</a> further describes the restrictions on the
use of names in the scope of nested classes. <a href='class.local'>[class.local]</a> further
describes the restrictions on the use of names in local class
definitions. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='unqual-9'><div class='marginalizedparent'><a class='marginalized' href='#unqual-9'>9</a></div><p >Name lookup for a name used in the definition of a <span class='texttt'>friend</span>
function (<a href='class.friend'>[class.friend]</a>) defined inline in the class granting
friendship shall proceed as described for lookup in member function
definitions. If the <span class='texttt'>friend</span> function is not defined in the class
granting friendship, name lookup in the <span class='texttt'>friend</span> function
definition shall proceed as described for lookup in namespace member
function definitions.</p></div><div class='para' id='unqual-10'><div class='marginalizedparent'><a class='marginalized' href='#unqual-10'>10</a></div><p >In a <span class='texttt'>friend</span> declaration naming a member function, a name used in
the function declarator and not part of a <i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
in the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> is first looked up in the scope of the
member function's class (<a href='class.member.lookup'>[class.member.lookup]</a>). If it is not found,
or if the name is part of a
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i> in
the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i>, the look up is
as described for unqualified names in the definition of the class
granting friendship. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A {
  typedef int AT;
  void f1(AT);
  void f2(float);
  template &lt;class T&gt; void f3();
};
struct B {
  typedef char AT;
  typedef float BT;
  friend void A::f1(AT);      <span class='comment'>// parameter type is <span class='texttt'>A::AT</span>
</span>  friend void A::f2(BT);      <span class='comment'>// parameter type is <span class='texttt'>B::BT</span>
</span>  friend void A::f3&lt;AT&gt;();    <span class='comment'>// template argument is <span class='texttt'>B::AT</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='unqual-11'><div class='marginalizedparent'><a class='marginalized' href='#unqual-11'>11</a></div><p >During the lookup for a name used as a default
argument (<a href='dcl.fct.default'>[dcl.fct.default]</a>) in a function
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> or used in the
<i ><a href='expr.comma#nt:expression'>expression</a></i> of a <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> for a
constructor (<a href='class.base.init'>[class.base.init]</a>), the function parameter names are
visible and hide the names of entities declared in the block, class or
namespace scopes containing the function declaration. [&nbsp;<i>Note:</i><span class='space'></span>
<a href='dcl.fct.default'>[dcl.fct.default]</a> further describes the restrictions on the use of
names in default arguments. <a href='class.base.init'>[class.base.init]</a> further describes the
restrictions on the use of names in a <i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='unqual-12'><div class='marginalizedparent'><a class='marginalized' href='#unqual-12'>12</a></div><p >During the lookup of a name used in the
<i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> of an <i ><a href='dcl.enum#nt:enumerator-definition'>enumerator-definition</a></i>,
previously declared <i ><a href='dcl.enum#nt:enumerator'>enumerators</a></i> of the enumeration are visible
and hide the names of entities declared in the block, class, or namespace
scopes containing the <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i>.</p></div><div class='para' id='unqual-13'><div class='marginalizedparent'><a class='marginalized' href='#unqual-13'>13</a></div><p >A name used in the definition of a <span class='texttt'>static</span> data member of class
<span class='texttt'>X</span> (<a href='class.static.data'>[class.static.data]</a>) (after the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
of the static member) is looked up as if the name was used in a member
function of <span class='texttt'>X</span>. [&nbsp;<i>Note:</i><span class='space'></span> <a href='class.static.data'>[class.static.data]</a> further
describes the restrictions on the use of names in the definition of a
<span class='texttt'>static</span> data member. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='unqual-14'><div class='marginalizedparent'><a class='marginalized' href='#unqual-14'>14</a></div><p >If a variable member of a namespace is defined outside of the scope of
its namespace then any name that appears in the definition of the
member (after the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i>) is looked up as if the
definition of the member occurred in its namespace.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace N {
  int i = 4;
  extern int j;
}

int i = 2;

int N::j = i;                   <span class='comment'>// <span class='texttt'>N::j == 4</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='unqual-15'><div class='marginalizedparent'><a class='marginalized' href='#unqual-15'>15</a></div><p >A name used in the handler for a <i ><a href='except#nt:function-try-block'>function-try-block</a></i>
(Clause <a href='except'>[except]</a>) is looked up as if the name was used in the
outermost block of the function definition. In particular, the function
parameter names shall not be redeclared in the
<i ><a href='except#nt:exception-declaration'>exception-declaration</a></i> nor in the outermost block of a handler
for the <i ><a href='except#nt:function-try-block'>function-try-block</a></i>. Names declared in the outermost
block of the function definition are not found when looked up in the
scope of a handler for the <i ><a href='except#nt:function-try-block'>function-try-block</a></i>. [&nbsp;<i>Note:</i><span class='space'></span> But
function parameter names are found. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='unqual-16'><div class='marginalizedparent'><a class='marginalized' href='#unqual-16'>16</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> The rules for name lookup in template definitions are
described in <a href='temp.res'>[temp.res]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-28'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-28'>28)</a></div><p >This refers to unqualified names
that occur, for instance, in
a type or default argument in the
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> or used in the function body.</p></div><div class='footnote' id='footnote-29'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-29'>29)</a></div><p >This refers to unqualified names
following the class name; such a name may be used in the
<i ><a href='class.derived#nt:base-clause'>base-clause</a></i> or may be used in the class definition.</p></div><div class='footnote' id='footnote-30'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-30'>30)</a></div><p >This lookup applies whether the
definition of <span class='texttt'>X</span> is
nested within <span class='texttt'>Y</span>'s definition or whether <span class='texttt'>X</span>'s definition
appears in a namespace scope enclosing <span class='texttt'>Y</span> 's
definition (<a href='class.nest'>[class.nest]</a>).</p></div><div class='footnote' id='footnote-31'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-31'>31)</a></div><p >That is, an unqualified name that occurs,
for instance, in a
type in the
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> or in the
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>.</p></div><div class='footnote' id='footnote-32'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-32'>32)</a></div><p >This lookup applies whether
the member function is defined
within the definition of class <span class='texttt'>X</span> or whether the member function
is defined in a namespace scope enclosing <span class='texttt'>X</span>'s definition.</p></div></div><div id='argdep'><h3 ><a class='secnum' href='#argdep' style='min-width:103pt'>3.4.2</a> Argument-dependent name lookup <a class='abbr_ref' href='basic.lookup.argdep'>[basic.lookup.argdep]</a></h3><p ><span class='indexparent'><a class='index' id='lookup,argument-dependent'></a></span></p><div class='para' id='argdep-1'><div class='marginalizedparent'><a class='marginalized' href='#argdep-1'>1</a></div><p >When the <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> in
a function call (<a href='expr.call'>[expr.call]</a>) is an <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i>, other namespaces not considered
during the usual unqualified lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>) may be
searched, and in those namespaces, namespace-scope friend function or
function template declarations (<a href='class.friend'>[class.friend]</a>) not otherwise
visible may be found.
These modifications to the search depend on the types of the arguments
(and for template template arguments, the namespace of the template
argument).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace N {
  struct S { };
  void f(S);
}

void g() {
  N::S s;
  f(s);                         <span class='comment'>// OK: calls <span class='texttt'>N::f</span>
</span>  (f)(s);                       <span class='comment'>// error: <span class='texttt'>N::f</span> not considered; parentheses
</span>                                <span class='comment'>// prevent argument-dependent lookup
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='argdep-2'><div class='marginalizedparent'><a class='marginalized' href='#argdep-2'>2</a></div><p >For each argument type <span class='texttt'>T</span> in the function call, there is a set of
zero or more associated namespaces and a set of zero or more associated
classes to be considered. The sets of namespaces and classes are
determined entirely by the types of the function arguments (and the
namespace of any template template argument). Typedef names and
<i ><a href='namespace.udecl#nt:using-declaration'>using-declarations</a></i> used to specify the types do not
contribute to this set. The sets of namespaces and classes are
determined in the following way:</p><ul ><li ><p >If <span class='texttt'>T</span> is a fundamental type, its associated sets of
namespaces and classes are both empty.</p></li><li ><p >If <span class='texttt'>T</span> is a class type (including unions), its associated
classes are: the class itself; the class of which it is a member, if
any; and its direct and indirect base classes. Its associated namespaces
are the innermost enclosing namespaces of its associated classes.
Furthermore, if <span class='texttt'>T</span> is a class template specialization, its
associated namespaces and classes also include: the namespaces and
classes associated with the types of the template arguments provided for
template type parameters (excluding template template parameters); the
namespaces of which any template template arguments are members; and the
classes of which any member templates used as template template
arguments are members. [&nbsp;<i>Note:</i><span class='space'></span> Non-type template arguments do not
contribute to the set of associated namespaces.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li ><p >If <span class='texttt'>T</span> is an enumeration type, its associated namespace is
the innermost enclosing namespace of its declaration. If it is a class member, its
associated class is the member's class; else it has no associated class.</p></li><li ><p >If <span class='texttt'>T</span> is a pointer to <span class='texttt'>U</span> or an array of <span class='texttt'>U</span>,
its associated namespaces and classes are those associated with
<span class='texttt'>U</span>.</p></li><li ><p >If <span class='texttt'>T</span> is a function type, its associated namespaces and
classes are those associated with the function parameter types and those
associated with the return type.</p></li><li ><p >If <span class='texttt'>T</span> is a pointer to a member function of a class
<span class='texttt'>X</span>, its associated namespaces and classes are those associated
with the function parameter types and return type, together with those
associated with <span class='texttt'>X</span>.</p></li><li ><p >If <span class='texttt'>T</span> is a pointer to a data member of class <span class='texttt'>X</span>, its
associated namespaces and classes are those associated with the member
type together with those associated with <span class='texttt'>X</span>.</p></li></ul><p >If an associated namespace is an inline namespace (<a href='namespace.def'>[namespace.def]</a>), its
enclosing namespace is also included in the set. If an associated namespace
directly contains inline namespaces, those inline namespaces are also included
in the set.
In addition, if the argument is the name or address of a set of
overloaded functions and/or function templates, its associated classes
and namespaces are the union of those associated with each of the
members of the set, i.e., the classes and namespaces associated with its
parameter types and return type.
Additionally, if the aforementioned set of overloaded functions is named with
a <i ><a href='temp.names#nt:template-id'>template-id</a></i>, its associated classes and namespaces also include
those of its type <i ><a href='temp.names#nt:template-argument'>template-arguments</a></i> and its template
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>.</p></div><div class='para' id='argdep-3'><div class='marginalizedparent'><a class='marginalized' href='#argdep-3'>3</a></div><p >Let <i>X</i> be the lookup set produced by unqualified
lookup (<a href='basic.lookup.unqual'>[basic.lookup.unqual]</a>) and let <i>Y</i> be the lookup set produced
by argument dependent lookup (defined as follows). If <i>X</i> contains
</p><ul ><li ><p >a declaration of a class member, or</p></li><li ><p >a block-scope function declaration that is not a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>, or</p></li><li ><p >a declaration that is neither a function nor a function template</p></li></ul><p >then <i>Y</i> is empty. Otherwise <i>Y</i> is the set of declarations
found in the namespaces associated with the argument types as described
below. The set of declarations found by the lookup of the name is the
union of <i>X</i> and <i>Y</i>. [&nbsp;<i>Note:</i><span class='space'></span> The namespaces and classes
associated with the argument types can include namespaces and classes
already considered by the ordinary unqualified lookup. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace NS {
  class T { };
  void f(T);
  void g(T, int);
}
NS::T parm;
void g(NS::T, float);
int main() {
  f(parm);                      <span class='comment'>// OK: calls <span class='texttt'>NS::f</span>
</span>  extern void g(NS::T, float);
  g(parm, 1);                   <span class='comment'>// OK: calls <span class='texttt'>g(NS::T, float)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='argdep-4'><div class='marginalizedparent'><a class='marginalized' href='#argdep-4'>4</a></div><p >When considering an associated namespace, the lookup is the same as the
lookup performed when the associated namespace is used as a
qualifier (<a href='namespace.qual'>[namespace.qual]</a>) except that:</p><ul ><li ><p >Any <i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i> in the associated namespace are
ignored.</p></li><li ><p >Any namespace-scope friend functions or friend function templates
declared in associated classes are visible within their respective
namespaces even if they are not visible during an ordinary
lookup (<a href='class.friend'>[class.friend]</a>).</p></li><li ><p >All names except those of (possibly overloaded) functions and
function templates are ignored.</p></li></ul></div></div><div id='qual'><h3 ><a class='secnum' href='#qual' style='min-width:103pt'>3.4.3</a> Qualified name lookup <a class='abbr_ref' href='basic.lookup.qual'>[basic.lookup.qual]</a></h3><div class='para' id='qual-1'><div class='marginalizedparent'><a class='marginalized' href='#qual-1'>1</a></div><p ><span class='indexparent'><a class='index' id='lookup,qualified_name'></a></span><span class='indexparent'><a class='index' id='name,qualified'></a></span><span class='indexparent'><a class='index' id='qualification,explicit'></a></span>The name of a class or namespace member
or enumerator can be referred to after the
<span class='texttt'>::</span> scope resolution operator (<a href='expr.prim'>[expr.prim]</a>) applied to a
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> that denotes its class,
namespace, or enumeration.
If a
<span class='texttt'>::</span> scope resolution
operator
in a <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> is not preceded by a <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i>,
lookup of the name preceding that <span class='texttt'>::</span> considers only namespaces, types, and
templates whose specializations are types. If the
name found does not designate a namespace or a class, enumeration, or dependent type,
the program is ill-formed.[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class A {
public:
  static int n;
};
int main() {
  int A;
  A::n = 42;        <span class='comment'>// OK
</span>  A b;              <span class='comment'>// ill-formed: <span class='texttt'>A</span> does not name a type
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='qual-2'><div class='marginalizedparent'><a class='marginalized' href='#qual-2'>2</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> Multiply qualified names, such as <span class='texttt'>N1::N2::N3::n</span>, can
be used to refer to members of nested classes (<a href='class.nest'>[class.nest]</a>) or
members of nested namespaces. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='qual-3'><div class='marginalizedparent'><a class='marginalized' href='#qual-3'>3</a></div><p >In a declaration in which the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> is a
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>, names used before the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
being declared are looked up in the defining namespace scope; names
following the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> are looked up in the scope of the
member's class or namespace. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class X { };
class C {
  class X { };
  static const int number = 50;
  static X arr[number];
};
X C::arr[number];   <span class='comment'>// ill-formed:
</span>                    <span class='comment'>// equivalent to: <span class='texttt'>::X</span> <span class='texttt'>C::arr[C::number];</span>
</span>                    <span class='comment'>// not to: <span class='texttt'>C::X</span> <span class='texttt'>C::arr[C::number];</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='qual-4'><div class='marginalizedparent'><a class='marginalized' href='#qual-4'>4</a></div><p ><span class='indexparent'><a class='index' id='scope_resolution_operator'></a></span>A name prefixed by the unary scope operator <span class='texttt'>::</span> (<a href='expr.prim'>[expr.prim]</a>)
is looked up in global scope, in the translation unit where it is used.
The name shall be declared in global namespace scope or shall be a name
whose declaration is visible in global scope because of a
<i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> (<a href='namespace.qual'>[namespace.qual]</a>). The use of <span class='texttt'>::</span>
allows a global name to be referred to even if its identifier has been
hidden (<a href='basic.scope.hiding'>[basic.scope.hiding]</a>).</p></div><div class='para' id='qual-5'><div class='marginalizedparent'><a class='marginalized' href='#qual-5'>5</a></div><p >A name prefixed by a <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> that
nominates an enumeration type shall represent an <i ><a href='dcl.enum#nt:enumerator'>enumerator</a></i>
of that enumeration.</p></div><div class='para' id='qual-6'><div class='marginalizedparent'><a class='marginalized' href='#qual-6'>6</a></div><p >If a <i ><a href='expr.post#nt:pseudo-destructor-name'>pseudo-destructor-name</a></i> (<a href='expr.pseudo'>[expr.pseudo]</a>) contains a
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>, the <i ><a href='dcl.type.simple#nt:type-name'>type-names</a></i> are looked
up as types in the scope designated by the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>. Similarly, in a
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> of the form:</p><pre class='bnf'><i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class#nt:class-name'>class-name</a></i> <span class='terminal'>::</span> <span class='terminal'>~</span> <i ><a href='class#nt:class-name'>class-name</a></i></pre><p >the second <i ><a href='class#nt:class-name'>class-name</a></i> is looked up in the same scope as the
first. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct C {
  typedef int I;
};
typedef int I1, I2;
extern int* p;
extern int* q;
p-&gt;C::I::~I();      <span class='comment'>// <span class='texttt'>I</span> is looked up in the scope of <span class='texttt'>C</span>
</span>q-&gt;I1::~I2();       <span class='comment'>// <span class='texttt'>I2</span> is looked up in the scope of
</span>                    <span class='comment'>// the postfix-expression
</span>
struct A {
  ~A();
};
typedef A AB;
int main() {
  AB* p;
  p-&gt;AB::~AB();     <span class='comment'>// explicitly calls the destructor for <span class='texttt'>A</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;] [&nbsp;<i>Note:</i><span class='space'></span> <a href='basic.lookup.classref'>[basic.lookup.classref]</a> describes how name
lookup proceeds after the <span class='texttt'>.</span> and <span class='texttt'>-&gt;</span> operators. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='class.qual'><h4 ><a class='secnum' href='#class.qual' style='min-width:118pt'>3.4.3.1</a> Class members <a class='abbr_ref' href='class.qual'>[class.qual]</a></h4><div class='para' id='class.qual-1'><div class='marginalizedparent'><a class='marginalized' href='#class.qual-1'>1</a></div><p ><span class='indexparent'><a class='index' id='lookup,class_member'></a></span>If the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> of a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
nominates a class, the name specified after the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> is looked up in the scope of the
class (<a href='class.member.lookup'>[class.member.lookup]</a>), except for the cases listed below.
The name shall represent one or more members of that class or of one of
its base classes (Clause <a href='class.derived'>[class.derived]</a>). [&nbsp;<i>Note:</i><span class='space'></span> A class member
can be referred to using a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> at any point in its
potential scope (<a href='basic.scope.class'>[basic.scope.class]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;] The exceptions to
the name lookup rule above are the following:</p><ul ><li ><p >the lookup for a destructor is as specified
in <a href='basic.lookup.qual'>[basic.lookup.qual]</a>;</p></li><li ><p >a <i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i> of a
<i ><a href='class.conv.fct#nt:conversion-function-id'>conversion-function-id</a></i> is looked up
in the same manner as a <i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i> in a class member
access (see <a href='basic.lookup.classref'>[basic.lookup.classref]</a>);</p></li><li ><p >the names in a <i ><a href='temp.names#nt:template-argument'>template-argument</a></i> of a
<i ><a href='temp.names#nt:template-id'>template-id</a></i> are looked up in the context in which the entire
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> occurs.</p></li><li ><p >the lookup for a name specified in a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> (<a href='namespace.udecl'>[namespace.udecl]</a>) also finds class or
enumeration names hidden within the same
scope (<a href='basic.scope.hiding'>[basic.scope.hiding]</a>).</p></li></ul></div><div class='para' id='class.qual-2'><div class='marginalizedparent'><a class='marginalized' href='#class.qual-2'>2</a></div><p >In a lookup in which function names are not ignored<a class='footnotenum' href='#footnote-33'>33</a>
and the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> nominates a class <span class='texttt'>C</span>:</p><ul ><li ><p >if the name specified after the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>,
when looked up in <span class='texttt'>C</span>, is the injected-class-name of <span class='texttt'>C</span> (Clause <a href='class'>[class]</a>), or
</p></li><li ><p >in a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> (<a href='namespace.udecl'>[namespace.udecl]</a>) that is a <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>,
if the name specified after the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> is the same as the
<i ><a href='lex.name#nt:identifier'>identifier</a></i> or the <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>'s
<i ><a href='temp.names#nt:template-name'>template-name</a></i> in the last component of the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>,
</p></li></ul><p >the name is instead considered to name the
constructor of class <span class='texttt'>C</span>. [&nbsp;<i>Note:</i><span class='space'></span> For example, the constructor
is not an acceptable lookup result in an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> so the constructor would not be
used in place of the injected-class-name. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Such a constructor
name shall be used only in the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> of a declaration
that names a constructor or in a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A { A(); };
struct B: public A { B(); };

A::A() { }
B::B() { }

B::A ba;            <span class='comment'>// object of type <span class='texttt'>A</span>
</span>A::A a;             <span class='comment'>// error, <span class='texttt'>A::A</span> is not a type name
</span>struct A::A a2;     <span class='comment'>// object of type <span class='texttt'>A</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.qual-3'><div class='marginalizedparent'><a class='marginalized' href='#class.qual-3'>3</a></div><p >A class member name hidden by a name in a nested declarative region or
by the name of a derived class member can still be found if qualified by
the name of its class followed by the <span class='texttt'>::</span> operator.</p></div><div class='footnote' id='footnote-33'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-33'>33)</a></div><p >Lookups in which
function names are ignored include names appearing in a
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>, an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>, or a <i ><a href='class.derived#nt:base-specifier'>base-specifier</a></i>.</p></div></div><div id='namespace.qual'><h4 ><a class='secnum' href='#namespace.qual' style='min-width:118pt'>3.4.3.2</a> Namespace members <a class='abbr_ref' href='namespace.qual'>[namespace.qual]</a></h4><div class='para' id='namespace.qual-1'><div class='marginalizedparent'><a class='marginalized' href='#namespace.qual-1'>1</a></div><p ><span class='indexparent'><a class='index' id='lookup,namespace_member'></a></span>If the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> of a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>
nominates a namespace (including the case where the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> is <span class='texttt'>::</span>, i.e., nominating
the global namespace), the name specified after the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> is looked up in the scope of the
namespace.
The names in a <i ><a href='temp.names#nt:template-argument'>template-argument</a></i> of a
<i ><a href='temp.names#nt:template-id'>template-id</a></i> are looked up in the context in which the
entire <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> occurs.</p></div><div class='para' id='namespace.qual-2'><div class='marginalizedparent'><a class='marginalized' href='#namespace.qual-2'>2</a></div><p >For a namespace <span class='texttt'>X</span> and name <span class='texttt'>m</span>, the namespace-qualified lookup set
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> is defined as follows: Let <span class='math'><span class='mathalpha'>S</span>'(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> be the set of all
declarations of <span class='texttt'>m</span> in <span class='texttt'>X</span> and the inline namespace set of
<span class='texttt'>X</span> (<a href='namespace.def'>[namespace.def]</a>). If <span class='math'><span class='mathalpha'>S</span>'(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> is not empty, <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span>
is <span class='math'><span class='mathalpha'>S</span>'(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span>; otherwise, <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> is the union of <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>N</span><sub ><span class='mathalpha'>i</span></sub>, <span class='mathalpha'>m</span>)</span> for
all namespaces <span class='math'><span class='mathalpha'>N</span><sub ><span class='mathalpha'>i</span></sub></span> nominated by <span class='grammarterm'>using-directives</span> in
<span class='texttt'>X</span> and its inline namespace set.</p></div><div class='para' id='namespace.qual-3'><div class='marginalizedparent'><a class='marginalized' href='#namespace.qual-3'>3</a></div><p >Given <span class='texttt'>X::m</span> (where <span class='texttt'>X</span> is a user-declared namespace), or
given <span class='texttt'>::m</span> (where X is the global namespace), if
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> is the empty set, the program is ill-formed. Otherwise, if
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span> has exactly one member, or if the context of the reference is
a <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> (<a href='namespace.udecl'>[namespace.udecl]</a>), <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span>
is the
required set of declarations of <span class='texttt'>m</span>. Otherwise if the use of
<span class='texttt'>m</span> is not one that allows a unique declaration to be chosen from
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>X</span>, <span class='mathalpha'>m</span>)</span>, the program is ill-formed. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
int x;
namespace Y {
  void f(float);
  void h(int);
}

namespace Z {
  void h(double);
}

namespace A {
  using namespace Y;
  void f(int);
  void g(int);
  int i;
}

namespace B {
  using namespace Z;
  void f(char);
  int i;
}

namespace AB {
  using namespace A;
  using namespace B;
  void g();
}

void h(){
  AB::g();          <span class='comment'>// <span class='texttt'>g</span> is declared directly in <span class='texttt'>AB,</span>
</span>                    <span class='comment'>// therefore <span class='texttt'>S</span> is { <span class='texttt'>AB::g()</span> } and <span class='texttt'>AB::g()</span> is chosen
</span>  AB::f(1);         <span class='comment'>// <span class='texttt'>f</span> is not declared directly in <span class='texttt'>AB</span> so the rules are
</span>                    <span class='comment'>// applied recursively to <span class='texttt'>A</span> and <span class='texttt'>B;</span>
</span>                    <span class='comment'>// namespace <span class='texttt'>Y</span> is not searched and <span class='texttt'>Y::f(float)</span>
</span>                    <span class='comment'>// is not considered;
</span>                    <span class='comment'>// <span class='texttt'>S</span> is { <span class='texttt'>A::f(int)</span>, <span class='texttt'>B::f(char)</span> } and overload
</span>                    <span class='comment'>// resolution chooses <span class='texttt'>A::f(int)</span>
</span>  AB::f('c');       <span class='comment'>// as above but resolution chooses <span class='texttt'>B::f(char)</span>
</span>
  AB::x++;          <span class='comment'>// <span class='texttt'>x</span> is not declared directly in <span class='texttt'>AB</span>, and
</span>                    <span class='comment'>// is not declared in <span class='texttt'>A</span> or <span class='texttt'>B</span> , so the rules are
</span>                    <span class='comment'>// applied recursively to <span class='texttt'>Y</span> and <span class='texttt'>Z</span>,
</span>                    <span class='comment'>// <span class='texttt'>S</span> is { } so the program is ill-formed
</span>  AB::i++;          <span class='comment'>// <span class='texttt'>i</span> is not declared directly in <span class='texttt'>AB</span> so the rules are
</span>                    <span class='comment'>// applied recursively to <span class='texttt'>A</span> and <span class='texttt'>B</span>,
</span>                    <span class='comment'>// <span class='texttt'>S</span> is { <span class='texttt'>A::i</span> , <span class='texttt'>B::i</span> } so the use is ambiguous
</span>                    <span class='comment'>// and the program is ill-formed
</span>  AB::h(16.8);      <span class='comment'>// <span class='texttt'>h</span> is not declared directly in <span class='texttt'>AB</span> and
</span>                    <span class='comment'>// not declared directly in <span class='texttt'>A</span> or <span class='texttt'>B</span> so the rules are
</span>                    <span class='comment'>// applied recursively to <span class='texttt'>Y</span> and <span class='texttt'>Z</span>,
</span>                    <span class='comment'>// <span class='texttt'>S</span> is { <span class='texttt'>Y::h(int)</span>, <span class='texttt'>Z::h(double)</span> } and overload
</span>                    <span class='comment'>// resolution chooses <span class='texttt'>Z::h(double)</span>
</span>}
</pre></div><div class='para' id='namespace.qual-4'><div class='marginalizedparent'><a class='marginalized' href='#namespace.qual-4'>4</a></div><p >The same declaration found more than once is not an ambiguity (because
it is still a unique declaration). For example:</p><pre class='codeblock'>
namespace A {
  int a;
}

namespace B {
  using namespace A;
}

namespace C {
  using namespace A;
}

namespace BC {
  using namespace B;
  using namespace C;
}

void f(){
  BC::a++;          <span class='comment'>// OK: <span class='texttt'>S</span> is { <span class='texttt'>A::a</span>, <span class='texttt'>A::a</span> }
</span>}

namespace D {
  using A::a;
}

namespace BD {
  using namespace B;
  using namespace D;
}

void g(){
  BD::a++;          <span class='comment'>// OK: S is { <span class='texttt'> A::a</span>, <span class='texttt'> A::a</span> }
</span>}
</pre></div><div class='para' id='namespace.qual-5'><div class='marginalizedparent'><a class='marginalized' href='#namespace.qual-5'>5</a></div><p >Because each referenced namespace is searched at most once, the
following is well-defined:</p><pre class='codeblock'>
namespace B {
  int b;
}

namespace A {
  using namespace B;
  int a;
}

namespace B {
  using namespace A;
}

void f(){
  A::a++;           <span class='comment'>// OK: <span class='texttt'>a</span> declared directly in <span class='texttt'>A</span>, <span class='texttt'>S</span> is {<span class='texttt'>A::a</span>}
</span>  B::a++;           <span class='comment'>// OK: both <span class='texttt'>A</span> and <span class='texttt'>B</span> searched (once), <span class='texttt'>S</span> is {<span class='texttt'>A::a</span>}
</span>  A::b++;           <span class='comment'>// OK: both <span class='texttt'>A</span> and <span class='texttt'>B</span> searched (once), <span class='texttt'>S</span> is {<span class='texttt'>B::b</span>}
</span>  B::b++;           <span class='comment'>// OK: <span class='texttt'>b</span> declared directly in <span class='texttt'>B</span>, <span class='texttt'>S</span> is {<span class='texttt'>B::b</span>}
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.qual-6'><div class='marginalizedparent'><a class='marginalized' href='#namespace.qual-6'>6</a></div><p >During the lookup of a qualified namespace member name, if the lookup
finds more than one declaration of the member, and if one declaration
introduces a class name or enumeration name and the other declarations
either introduce the same variable, the same enumerator or a set of
functions, the non-type name hides the class or enumeration name if and
only if the declarations are from the same namespace; otherwise (the
declarations are from different namespaces), the program is ill-formed.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace A {
  struct x { };
  int x;
  int y;
}

namespace B {
  struct y { };
}

namespace C {
  using namespace A;
  using namespace B;
  int i = C::x;     <span class='comment'>// OK, <span class='texttt'>A::x</span> (of type <span class='texttt'>int</span> )
</span>  int j = C::y;     <span class='comment'>// ambiguous, <span class='texttt'>A::y</span> or <span class='texttt'>B::y</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='namespace.qual-7'><div class='marginalizedparent'><a class='marginalized' href='#namespace.qual-7'>7</a></div><p >In a declaration for a namespace member in which the
<i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i> is a <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>, given that the
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> for the namespace member has the form</p><pre class='bnf'><i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i></pre><p >the
<i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> shall name a member of the namespace
designated by the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
or of an element of the inline namespace set (<a href='namespace.def'>[namespace.def]</a>) of that namespace.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace A {
  namespace B {
    void f1(int);
  }
  using namespace B;
}
void A::f1(int){ }  <span class='comment'>// ill-formed, <span class='texttt'>f1</span> is not a member of <span class='texttt'>A</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;] However, in such namespace member declarations, the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> may rely on <i ><a href='namespace.udir#nt:using-directive'>using-directives</a></i>
to implicitly provide the initial part of the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace A {
  namespace B {
    void f1(int);
  }
}

namespace C {
  namespace D {
    void f1(int);
  }
}

using namespace A;
using namespace C::D;
void B::f1(int){ }  <span class='comment'>// OK, defines <span class='texttt'>A::B::f1(int)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<span class='indexparent'><a class='index' id='lookup,qualified_name'></a></span>
</p></div></div></div><div id='elab'><h3 ><a class='secnum' href='#elab' style='min-width:103pt'>3.4.4</a> Elaborated type specifiers <a class='abbr_ref' href='basic.lookup.elab'>[basic.lookup.elab]</a></h3><p ><span class='indexparent'><a class='index' id='lookup,elaborated_type_specifier'></a></span><span class='indexparent'><a class='index' id='type_specifier,elaborated'></a></span></p><div class='para' id='elab-1'><div class='marginalizedparent'><a class='marginalized' href='#elab-1'>1</a></div><p >An <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> (<a href='dcl.type.elab'>[dcl.type.elab]</a>) may be
used to refer to a previously declared <i ><a href='class#nt:class-name'>class-name</a></i> or
<i ><a href='dcl.enum#nt:enum-name'>enum-name</a></i> even though the name has been hidden by a non-type
declaration (<a href='basic.scope.hiding'>[basic.scope.hiding]</a>).</p></div><div class='para' id='elab-2'><div class='marginalizedparent'><a class='marginalized' href='#elab-2'>2</a></div><p >If the <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> has no
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>, and unless the
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> appears in a declaration with the
following form:</p><pre class='bnf'><i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span></pre><p >the <i ><a href='lex.name#nt:identifier'>identifier</a></i> is looked up according
to <a href='basic.lookup.unqual'>[basic.lookup.unqual]</a> but ignoring any non-type names that have
been declared. If the <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> is introduced
by the <span class='texttt'>enum</span> keyword and this lookup does not find a previously
declared <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>, the <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>
is ill-formed. If the <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> is introduced
by the <i ><a href='class#nt:class-key'>class-key</a></i> and this lookup does not find a previously
declared <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>, or if the
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> appears in a declaration with the
form:</p><pre class='bnf'><i ><a href='class#nt:class-key'>class-key</a></i> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span></pre><p >the <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> is a declaration that
introduces the <i ><a href='class#nt:class-name'>class-name</a></i> as described
in <a href='basic.scope.pdecl'>[basic.scope.pdecl]</a>.</p></div><div class='para' id='elab-3'><div class='marginalizedparent'><a class='marginalized' href='#elab-3'>3</a></div><p >If the <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> has a
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>, qualified name lookup is performed, as
described in <a href='basic.lookup.qual'>[basic.lookup.qual]</a>, but ignoring any non-type names
that have been declared. If the name lookup does not find a previously
declared <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>, the <i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i>
is ill-formed. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct Node {
  struct Node* Next;            <span class='comment'>// OK: Refers to <span class='texttt'>Node</span> at global scope
</span>  struct Data* Data;            <span class='comment'>// OK: Declares type <span class='texttt'>Data</span>
</span>                                <span class='comment'>// at global scope and member <span class='texttt'>Data</span>
</span>};

struct Data {
  struct Node* Node;            <span class='comment'>// OK: Refers to <span class='texttt'>Node</span> at global scope
</span>  friend struct ::Glob;         <span class='comment'>// error: <span class='texttt'>Glob</span> is not declared
</span>                                <span class='comment'>// cannot introduce a qualified type (<a href='dcl.type.elab'>[dcl.type.elab]</a>)
</span>  friend struct Glob;           <span class='comment'>// OK: Refers to (as yet) undeclared <span class='texttt'>Glob</span>
</span>                                <span class='comment'>// at global scope.
</span>  <span class='comment'>/* ... */</span>
};

struct Base {
  struct Data;                  <span class='comment'>// OK: Declares nested <span class='texttt'>Data</span>
</span>  struct ::Data*     thatData;  <span class='comment'>// OK: Refers to <span class='texttt'>::Data</span>
</span>  struct Base::Data* thisData;  <span class='comment'>// OK: Refers to nested <span class='texttt'>Data</span>
</span>  friend class ::Data;          <span class='comment'>// OK: global <span class='texttt'>Data</span> is a friend
</span>  friend class Data;            <span class='comment'>// OK: nested <span class='texttt'>Data</span> is a friend
</span>  struct Data <span class='texttt'>{ /* ... */ };</span>   <span class='comment'>// Defines nested <span class='texttt'>Data</span>
</span>};

struct Data;                    <span class='comment'>// OK: Redeclares <span class='texttt'>Data</span> at global scope
</span>struct ::Data;                  <span class='comment'>// error: cannot introduce a qualified type (<a href='dcl.type.elab'>[dcl.type.elab]</a>)
</span>struct Base::Data;              <span class='comment'>// error: cannot introduce a qualified type (<a href='dcl.type.elab'>[dcl.type.elab]</a>)
</span>struct Base::Datum;             <span class='comment'>// error: <span class='texttt'>Datum</span> undefined
</span>struct Base::Data* pBase;       <span class='comment'>// OK: refers to nested <span class='texttt'>Data</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;] <span class='indexparent'><a class='index' id='lookup,elaborated_type_specifier'></a></span>
</p></div></div><div id='classref'><h3 ><a class='secnum' href='#classref' style='min-width:103pt'>3.4.5</a> Class member access <a class='abbr_ref' href='basic.lookup.classref'>[basic.lookup.classref]</a></h3><div class='para' id='classref-1'><div class='marginalizedparent'><a class='marginalized' href='#classref-1'>1</a></div><p ><span class='indexparent'><a class='index' id='lookup,class_member'></a></span>In a class member access expression (<a href='expr.ref'>[expr.ref]</a>), if the <span class='texttt'>.</span>
or <span class='texttt'>-&gt;</span> token is immediately followed by an <i ><a href='lex.name#nt:identifier'>identifier</a></i>
followed by a <span class='texttt'>&lt;</span>, the identifier must be looked up to determine
whether the <span class='texttt'>&lt;</span> is the beginning of a template argument
list (<a href='temp.names'>[temp.names]</a>) or a less-than operator. The identifier is first
looked up in the class of the object expression. If the identifier is
not found, it is then looked up in the context of the entire
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> and shall name a class template.</p></div><div class='para' id='classref-2'><div class='marginalizedparent'><a class='marginalized' href='#classref-2'>2</a></div><p >If the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> in a class member
access (<a href='expr.ref'>[expr.ref]</a>) is an <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i>, and the type of
the object expression is of a class type <span class='texttt'>C</span>, the
<i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> is looked up in the scope of class <span class='texttt'>C</span>.
For a pseudo-destructor call (<a href='expr.pseudo'>[expr.pseudo]</a>),
the <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> is looked up in the context of the complete
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>.</p></div><div class='para' id='classref-3'><div class='marginalizedparent'><a class='marginalized' href='#classref-3'>3</a></div><p >If the <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> is <span class='texttt'>~</span><i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>, the
<i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i> is looked up in the context of the entire
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>. If the type <span class='texttt'>T</span> of the object
expression is of a class type <span class='texttt'>C</span>, the <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i> is
also looked up in the scope of class <span class='texttt'>C</span>. At least one of the
lookups shall find a name that refers to (possibly cv-qualified)
<span class='texttt'>T</span>. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A { };

struct B {
  struct A { };
  void f(::A* a);
};

void B::f(::A* a) {
  a-&gt;~A();                      <span class='comment'>// OK: lookup in <span class='texttt'>*a</span> finds the injected-class-name
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='classref-4'><div class='marginalizedparent'><a class='marginalized' href='#classref-4'>4</a></div><p >If the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> in a class member access is a
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> of the form</p><p ><span class='list'></span><span class='item'></span><span class='relax'></span>
<span class='texttt'>class-name-or-namespace-name::...</span>
</p><p >the <span class='grammarterm'>class-name-or-namespace-name</span> following the <span class='texttt'>.</span> or
<span class='texttt'>-&gt;</span> operator is
first looked up in the class of the object expression and the name, if found,
is used. Otherwise it is looked up in the context of the entire
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>. [&nbsp;<i>Note:</i><span class='space'></span> See <a href='basic.lookup.qual'>[basic.lookup.qual]</a>, which
describes the lookup of a name before <span class='texttt'>::</span>, which will only find a type
or namespace name. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='classref-5'><div class='marginalizedparent'><a class='marginalized' href='#classref-5'>5</a></div><p >If the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> has the form</p><p ><span class='list'></span><span class='item'></span><span class='relax'></span>
<span class='texttt'>::class-name-or-namespace-name::...</span>
</p><p >the <span class='grammarterm'>class-name-or-namespace-name</span> is looked up in global scope
as a <i ><a href='class#nt:class-name'>class-name</a></i> or <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i>.</p></div><div class='para' id='classref-6'><div class='marginalizedparent'><a class='marginalized' href='#classref-6'>6</a></div><p >If the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> contains a
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> (<a href='temp.names'>[temp.names]</a>), the names in its
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i> are looked up in the context in which the
entire <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> occurs.</p></div><div class='para' id='classref-7'><div class='marginalizedparent'><a class='marginalized' href='#classref-7'>7</a></div><p >If the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> is a <i ><a href='class.conv.fct#nt:conversion-function-id'>conversion-function-id</a></i>,
its <i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>
is first looked up in the class of the object expression and the name, if
found, is used. Otherwise it is looked up in the context
of the entire <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>.
In each of these lookups, only names that denote types or templates whose
specializations are types are considered.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A { };
namespace N {
  struct A {
    void g() { }
    template &lt;class T&gt; operator T();
  };
}

int main() {
  N::A a;
  a.operator A();               <span class='comment'>// calls <span class='texttt'>N::A::operator N::A</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='udir'><h3 ><a class='secnum' href='#udir' style='min-width:103pt'>3.4.6</a> Using-directives and namespace aliases <a class='abbr_ref' href='basic.lookup.udir'>[basic.lookup.udir]</a></h3><div class='para' id='udir-1'><div class='marginalizedparent'><a class='marginalized' href='#udir-1'>1</a></div><p ><span class='indexparent'><a class='index' id='lookup,using-directives_and'></a></span><span class='indexparent'><a class='index' id='lookup,namespace_aliases_and'></a></span>In a <i ><a href='namespace.udir#nt:using-directive'>using-directive</a></i> or <i ><a href='namespace.alias#nt:namespace-alias-definition'>namespace-alias-definition</a></i>,
during the lookup for a <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i> or for a name in a
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>
only namespace names are considered.<span class='indexparent'><a class='index' id='lookup,name'></a></span><span class='indexparent'><a class='index' id='scope,name_lookup_and'></a></span></p></div></div></div></div></body></html>