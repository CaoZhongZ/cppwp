<!DOCTYPE html><html lang='en'><head><title>[over.load]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>16</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>16.1</a> Overloadable declarations <a class='abbr_ref'>[over.load]</a></h2><span class='indexparent'><a class='index' id=':overloading,declarations'></a></span><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/be5c14cf44a6e6ea7348e65dbf99e3a8152c28ac/source/overloading.tex#L44'>#</a></div><div id='1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':overloading,prohibited'></a></span>Not all function declarations can be overloaded<a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>Those that cannot be
overloaded are specified here<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.sentence-3' class='sentence'>A program is ill-formed if it contains
two such non-overloadable declarations in the same scope<a class='hidden_link' href='#1.sentence-3'>.</a></div> <div id='1.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#1.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='1.sentence-4' class='sentence'>This restriction applies to explicit declarations in a scope, and between
such declarations and
declarations made through a
<span class='grammarterm'>using-declaration</span> (<a href='namespace.udecl'>[namespace.udecl]</a>)<a class='hidden_link' href='#1.sentence-4'>.</a></div> <div id='1.sentence-5' class='sentence'>It does not apply to sets of functions fabricated as a result of
name lookup (e.g., because of
<span class='grammarterm'>using-directive</span><span class='textit'>s</span>)
or overload resolution
(e.g., for operator functions)<a class='hidden_link' href='#1.sentence-5'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/be5c14cf44a6e6ea7348e65dbf99e3a8152c28ac/source/overloading.tex#L63'>#</a></div><div id='2.sentence-1' class='sentence'>Certain function declarations cannot be overloaded:</div><div id='2.sentence-2' class='sentence'><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><div id='2.1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':return_type,overloading_and'></a></span>Function declarations that differ only in the return type,
the <a href='except.spec'>exception specification</a>, or both
cannot be overloaded<a class='hidden_link' href='#2.1.sentence-1'>.</a></div></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><div id='2.2.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':static,overloading_and'></a></span>Member function declarations with the same name and the same
<a href='dcl.fct#def:parameter-type-list'>parameter-type-list</a> cannot be overloaded if any of them is a
<span class='texttt'>static</span>
member function declaration (<a href='class.static'>[class.static]</a>)<a class='hidden_link' href='#2.2.sentence-1'>.</a></div> <div id='2.2.sentence-2' class='sentence'>Likewise, member function template declarations with the same name,
the same parameter-type-list, and the same template parameter lists cannot be
overloaded if any of them is a
<span class='texttt'>static</span>
member function template declaration<a class='hidden_link' href='#2.2.sentence-2'>.</a></div> <div id='2.2.sentence-3' class='sentence'>The types of the implicit object parameters constructed for the member
functions for the purpose of overload resolution (<a href='over.match.funcs'>[over.match.funcs]</a>)
are not considered when comparing parameter-type-lists for enforcement of
this rule<a class='hidden_link' href='#2.2.sentence-3'>.</a></div> <div id='2.2.sentence-4' class='sentence'>In contrast, if there is no
<span class='texttt'>static</span>
member function declaration among a set of member function
declarations with the same name and the same parameter-type-list, then
these member function declarations can be overloaded if they differ in
the type of their implicit object parameter<a class='hidden_link' href='#2.2.sentence-4'>.</a></div> <div id='2.2.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#2.2.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='2.2.sentence-5' class='sentence'>The following illustrates this distinction:</div><pre class='codeblock'>
class X {
  static void f();
  void f();                     <span class='comment'>// ill-formed
</span>  void f() const;               <span class='comment'>// ill-formed
</span>  void f() const volatile;      <span class='comment'>// ill-formed
</span>  void g();
  void g() const;               <span class='comment'>// OK: no static <span class='tcode_in_codeblock'>g</span>
</span>  void g() const volatile;      <span class='comment'>// OK: no static <span class='tcode_in_codeblock'>g</span>
</span>};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </li><li id='2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.3'>(2.3)</a></div><div id='2.3.sentence-1' class='sentence'>Member function declarations with the same name and the same
<a href='dcl.fct#def:parameter-type-list'>parameter-type-list</a> as well as member function template
declarations with the same name, the same parameter-type-list, and
the same template parameter lists cannot be overloaded if any of them, but not
all, have a <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i> (<a href='dcl.fct'>[dcl.fct]</a>)<a class='hidden_link' href='#2.3.sentence-1'>.</a></div> <div id='2.3.example-2' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#2.3.example-2'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
class Y {
  void h() &amp;;
  void h() const &amp;;             <span class='comment'>// OK
</span>  void h() &amp;&amp;;                  <span class='comment'>// OK, all declarations have a ref-qualifier
</span>  void i() &amp;;
  void i() const;               <span class='comment'>// ill-formed, prior declaration of <span class='tcode_in_codeblock'>i</span>
</span>                                <span class='comment'>// has a ref-qualifier
</span>};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </li></ul></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/be5c14cf44a6e6ea7348e65dbf99e3a8152c28ac/source/overloading.tex#L129'>#</a></div><span class='indexparent'><a class='index' id=':equivalent_parameter_declarations'></a></span><span class='indexparent'><a class='index' id=':equivalent_parameter_declarations,overloading_and'></a></span><div id='3.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='3.sentence-1' class='sentence'>As specified in <a href='dcl.fct'>[dcl.fct]</a>,
function declarations that have equivalent parameter declarations
and <span class='grammarterm'>requires-clause</span><span class='textit'>s</span>, if any (<a href='temp.constr.decl'>[temp.constr.decl]</a>),
declare
the same function and therefore cannot
be overloaded:</div><div id='3.sentence-2' class='sentence'><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><div id='3.1.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':typedef,overloading_and'></a></span>Parameter declarations that differ only in the use of equivalent typedef
“types” are equivalent<a class='hidden_link' href='#3.1.sentence-1'>.</a></div> <div id='3.1.sentence-2' class='sentence'>A
<span class='texttt'>typedef</span>
is not a separate type, but only a synonym for another type (<a href='dcl.typedef'>[dcl.typedef]</a>)<a class='hidden_link' href='#3.1.sentence-2'>.</a></div> <div id='3.1.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#3.1.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
typedef int Int;

void f(int i);
void f(Int i);                  <span class='comment'>// OK: redeclaration of <span class='tcode_in_codeblock'>f(int)</span>
</span>void f(int i) { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> }
void f(Int i) { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> }     <span class='comment'>// error: redefinition of <span class='tcode_in_codeblock'>f(int)</span>
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> <div id='3.1.sentence-3' class='sentence'><span class='indexparent'><a class='index' id=':enum,overloading_and'></a></span>Enumerations, on the other hand, are distinct types and can be used to
distinguish
overloaded function declarations<a class='hidden_link' href='#3.1.sentence-3'>.</a></div> <div id='3.1.example-2' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#3.1.example-2'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
enum E { a };

void f(int i) { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> }
void f(E i)   { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> }</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><div id='3.2.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':overloading,array_versus_pointer'></a></span><span class='indexparent'><a class='index' id=':array,overloading_and_pointer_versus'></a></span>Parameter declarations that differ only in a pointer
<span class='texttt'>*</span>
versus an array
<span class='texttt'>[]</span>
are equivalent<a class='hidden_link' href='#3.2.sentence-1'>.</a></div> <div id='3.2.sentence-2' class='sentence'>That is, the array declaration is adjusted to become a pointer
declaration (<a href='dcl.fct'>[dcl.fct]</a>)<a class='hidden_link' href='#3.2.sentence-2'>.</a></div> <div id='3.2.sentence-3' class='sentence'>Only the second and subsequent array dimensions are significant in
parameter types (<a href='dcl.array'>[dcl.array]</a>)<a class='hidden_link' href='#3.2.sentence-3'>.</a></div> <div id='3.2.example-3' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#3.2.example-3'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
int f(char*);
int f(char[]);                  <span class='comment'>// same as <span class='tcode_in_codeblock'>f(char*);</span>
</span>int f(char[7]);                 <span class='comment'>// same as <span class='tcode_in_codeblock'>f(char*);</span>
</span>int f(char[9]);                 <span class='comment'>// same as <span class='tcode_in_codeblock'>f(char*);</span>
</span>
int g(char(*)[10]);
int g(char[5][10]);             <span class='comment'>// same as <span class='tcode_in_codeblock'>g(char(*)[10]);</span>
</span>int g(char[7][10]);             <span class='comment'>// same as <span class='tcode_in_codeblock'>g(char(*)[10]);</span>
</span>int g(char(*)[20]);             <span class='comment'>// different from <span class='tcode_in_codeblock'>g(char(*)[10]);</span>
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><div id='3.3.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':overloading,function_versus_pointer'></a></span><span class='indexparent'><a class='index' id=':function,overloading_and_pointer_versus'></a></span>Parameter declarations that differ only in that one is a function type
and the other is a pointer to the same function type are equivalent<a class='hidden_link' href='#3.3.sentence-1'>.</a></div> <div id='3.3.sentence-2' class='sentence'>That is, the function type is adjusted to become a pointer to function type (<a href='dcl.fct'>[dcl.fct]</a>)<a class='hidden_link' href='#3.3.sentence-2'>.</a></div> <div id='3.3.example-4' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#3.3.example-4'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
void h(int());
void h(int (*)());              <span class='comment'>// redeclaration of <span class='tcode_in_codeblock'>h(int())</span>
</span>void h(int x()) { }             <span class='comment'>// definition of <span class='tcode_in_codeblock'>h(int())</span>
</span>void h(int (*x)()) { }          <span class='comment'>// ill-formed: redefinition of <span class='tcode_in_codeblock'>h(int())</span>
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </li><li id='3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.4'>(3.4)</a></div><div id='3.4.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':const,overloading_and'></a></span><span class='indexparent'><a class='index' id=':volatile,overloading_and'></a></span>Parameter declarations that differ only in the presence or absence of
<span class='texttt'>const</span>
and/or
<span class='texttt'>volatile</span>
are equivalent<a class='hidden_link' href='#3.4.sentence-1'>.</a></div> <div id='3.4.sentence-2' class='sentence'>That is, the
<span class='texttt'>const</span>
and
<span class='texttt'>volatile</span>
type-specifiers for
each parameter type are ignored when determining which function is being
declared,
defined, or called<a class='hidden_link' href='#3.4.sentence-2'>.</a></div> <div id='3.4.example-5' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#3.4.example-5'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
typedef const int cInt;

int f (int);
int f (const int);              <span class='comment'>// redeclaration of <span class='tcode_in_codeblock'>f(int)</span>
</span>int f (int) { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> }       <span class='comment'>// definition of <span class='tcode_in_codeblock'>f(int)</span>
</span>int f (cInt) { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> }      <span class='comment'>// error: redefinition of <span class='tcode_in_codeblock'>f(int)</span>
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> <div id='3.4.sentence-3' class='sentence'>Only the
<span class='texttt'>const</span>
and
<span class='texttt'>volatile</span>
type-specifiers at the outermost level of the
parameter type specification are ignored in this fashion;
<span class='texttt'>const</span>
and
<span class='texttt'>volatile</span>
type-specifiers buried within a parameter type specification are significant
and can be used to distinguish overloaded function
declarations<a class='hidden_link' href='#3.4.sentence-3'>.</a><a class='footnotenum' href='#footnote-123'>123</a></div> <div id='3.4.sentence-4' class='sentence'>
In particular, for any type
<span class='texttt'>T</span>,
“pointer to
<span class='texttt'>T</span>”,
“pointer to
<span class='texttt'>const</span>
<span class='texttt'>T</span>”,
and
“pointer to
<span class='texttt'>volatile</span>
<span class='texttt'>T</span>”
are considered distinct parameter types, as are
“reference to
<span class='texttt'>T</span>”,
“reference to
<span class='texttt'>const</span>
<span class='texttt'>T</span>”,
and
“reference to
<span class='texttt'>volatile</span>
<span class='texttt'>T</span>”<a class='hidden_link' href='#3.4.sentence-4'>.</a></div></li><li id='3.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.5'>(3.5)</a></div><div id='3.5.sentence-1' class='sentence'><span class='indexparent'><a class='index' id=':default_initializers,overloading_and'></a></span>Two parameter declarations that differ only in their default arguments
are equivalent<a class='hidden_link' href='#3.5.sentence-1'>.</a></div> <div id='3.5.example-6' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#3.5.example-6'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <div id='3.5.sentence-2' class='sentence'>Consider the following:</div><pre class='codeblock'>
void f (int i, int j);
void f (int i, int j = 99);     <span class='comment'>// OK: redeclaration of <span class='tcode_in_codeblock'>f(int, int)</span>
</span>void f (int i = 88, int j);     <span class='comment'>// OK: redeclaration of <span class='tcode_in_codeblock'>f(int, int)</span>
</span>void f ();                      <span class='comment'>// OK: overloaded declaration of <span class='tcode_in_codeblock'>f</span>
</span>
void prog () {
    f (1, 2);                   <span class='comment'>// OK: call <span class='tcode_in_codeblock'>f(int, int)</span>
</span>    f (1);                      <span class='comment'>// OK: call <span class='tcode_in_codeblock'>f(int, int)</span>
</span>    f ();                       <span class='comment'>// Error: <span class='tcode_in_codeblock'>f(int, int)</span> or <span class='tcode_in_codeblock'>f()</span>?
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </li></ul></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='footnote' id='footnote-123'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-123'>123)</a></div><div id='footnote-123.sentence-1' class='sentence'>When a parameter type includes a function type,
such as in the case of a parameter type that is a pointer to function, the
<span class='texttt'>const</span>
and
<span class='texttt'>volatile</span>
type-specifiers at the outermost level of the parameter type
specifications for the inner function type are also ignored<a class='hidden_link' href='#footnote-123.sentence-1'>.</a></div></div></div></body></html>