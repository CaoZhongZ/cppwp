<!DOCTYPE html><html lang='en'><head><title>[depr.func.adaptor.typedefs]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='annexnum' style='min-width:73pt'>Annex D&emsp;(normative)</a> Compatibility features <a class='abbr_ref' href='./#depr'>[depr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>D.7</a> Old adaptable function bindings <a class='abbr_ref' href='depr.func.adaptor.binding#depr.func.adaptor.typedefs'>[depr.func.adaptor.binding]</a></h2><div id='depr.func.adaptor.typedefs'><h3 ><a class='secnum' style='min-width:103pt'>D.7.2</a> Typedefs to support function binders <a class='abbr_ref'>[depr.func.adaptor.typedefs]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/future.tex#L1236'>#</a></div><p >To enable old function adaptors to manipulate function objects
that take one or two arguments,
many of the function objects in this International Standard
correspondingly provide <i ><a href='dcl.typedef#nt:typedef-name'>typedef-names</a></i>
<span class='texttt'>argument_&shy;type</span> and <span class='texttt'>result_&shy;type</span>
for function objects that take one argument and
<span class='texttt'>first_&shy;argument_&shy;type</span>, <span class='texttt'>second_&shy;argument_&shy;type</span>, and <span class='texttt'>result_&shy;type</span>
for function objects that take two arguments.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/future.tex#L1246'>#</a></div><p >The following member names are defined in addition to names specified in Clause <a href='function.objects'>[function.objects]</a>:</p><p ><span class='indexparent'><a class='index' id='result_type,owner_less'></a></span><span class='indexparent'><a class='index' id='owner_less,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,owner_less'></a></span><span class='indexparent'><a class='index' id='owner_less,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,owner_less'></a></span><span class='indexparent'><a class='index' id='owner_less,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,owner_less'></a></span><span class='indexparent'><a class='index' id='owner_less,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,owner_less'></a></span><span class='indexparent'><a class='index' id='owner_less,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,owner_less'></a></span><span class='indexparent'><a class='index' id='owner_less,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,plus'></a></span><span class='indexparent'><a class='index' id='plus,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,plus'></a></span><span class='indexparent'><a class='index' id='plus,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,plus'></a></span><span class='indexparent'><a class='index' id='plus,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,minus'></a></span><span class='indexparent'><a class='index' id='minus,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,minus'></a></span><span class='indexparent'><a class='index' id='minus,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,minus'></a></span><span class='indexparent'><a class='index' id='minus,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,multiplies'></a></span><span class='indexparent'><a class='index' id='multiplies,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,multiplies'></a></span><span class='indexparent'><a class='index' id='multiplies,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,multiplies'></a></span><span class='indexparent'><a class='index' id='multiplies,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,divides'></a></span><span class='indexparent'><a class='index' id='divides,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,divides'></a></span><span class='indexparent'><a class='index' id='divides,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,divides'></a></span><span class='indexparent'><a class='index' id='divides,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,modulus'></a></span><span class='indexparent'><a class='index' id='modulus,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,modulus'></a></span><span class='indexparent'><a class='index' id='modulus,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,modulus'></a></span><span class='indexparent'><a class='index' id='modulus,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,negate'></a></span><span class='indexparent'><a class='index' id='negate,result_type'></a></span><span class='indexparent'><a class='index' id='argument_type,negate'></a></span><span class='indexparent'><a class='index' id='negate,argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,equal_to'></a></span><span class='indexparent'><a class='index' id='equal_to,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,equal_to'></a></span><span class='indexparent'><a class='index' id='equal_to,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,equal_to'></a></span><span class='indexparent'><a class='index' id='equal_to,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,not_equal_to'></a></span><span class='indexparent'><a class='index' id='not_equal_to,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,not_equal_to'></a></span><span class='indexparent'><a class='index' id='not_equal_to,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,not_equal_to'></a></span><span class='indexparent'><a class='index' id='not_equal_to,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,greater'></a></span><span class='indexparent'><a class='index' id='greater,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,greater'></a></span><span class='indexparent'><a class='index' id='greater,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,greater'></a></span><span class='indexparent'><a class='index' id='greater,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,less'></a></span><span class='indexparent'><a class='index' id='less,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,less'></a></span><span class='indexparent'><a class='index' id='less,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,less'></a></span><span class='indexparent'><a class='index' id='less,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,greater_equal'></a></span><span class='indexparent'><a class='index' id='greater_equal,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,greater_equal'></a></span><span class='indexparent'><a class='index' id='greater_equal,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,greater_equal'></a></span><span class='indexparent'><a class='index' id='greater_equal,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,less_equal'></a></span><span class='indexparent'><a class='index' id='less_equal,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,less_equal'></a></span><span class='indexparent'><a class='index' id='less_equal,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,less_equal'></a></span><span class='indexparent'><a class='index' id='less_equal,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,logical_and'></a></span><span class='indexparent'><a class='index' id='logical_and,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,logical_and'></a></span><span class='indexparent'><a class='index' id='logical_and,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,logical_and'></a></span><span class='indexparent'><a class='index' id='logical_and,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,logical_or'></a></span><span class='indexparent'><a class='index' id='logical_or,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,logical_or'></a></span><span class='indexparent'><a class='index' id='logical_or,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,logical_or'></a></span><span class='indexparent'><a class='index' id='logical_or,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,logical_not'></a></span><span class='indexparent'><a class='index' id='logical_not,result_type'></a></span><span class='indexparent'><a class='index' id='argument_type,logical_not'></a></span><span class='indexparent'><a class='index' id='logical_not,argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,bit_and'></a></span><span class='indexparent'><a class='index' id='bit_and,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,bit_and'></a></span><span class='indexparent'><a class='index' id='bit_and,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,bit_and'></a></span><span class='indexparent'><a class='index' id='bit_and,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,bit_or'></a></span><span class='indexparent'><a class='index' id='bit_or,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,bit_or'></a></span><span class='indexparent'><a class='index' id='bit_or,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,bit_or'></a></span><span class='indexparent'><a class='index' id='bit_or,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,bit_xor'></a></span><span class='indexparent'><a class='index' id='bit_xor,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,bit_xor'></a></span><span class='indexparent'><a class='index' id='bit_xor,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,bit_xor'></a></span><span class='indexparent'><a class='index' id='bit_xor,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,bit_not'></a></span><span class='indexparent'><a class='index' id='bit_not,result_type'></a></span><span class='indexparent'><a class='index' id='argument_type,bit_not'></a></span><span class='indexparent'><a class='index' id='bit_not,argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,function'></a></span><span class='indexparent'><a class='index' id='function,result_type'></a></span><span class='indexparent'><a class='index' id='argument_type,function'></a></span><span class='indexparent'><a class='index' id='function,argument_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,function'></a></span><span class='indexparent'><a class='index' id='function,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,function'></a></span><span class='indexparent'><a class='index' id='function,second_argument_type'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; struct owner_less&lt;shared_ptr&lt;T&gt;&gt; {
    using result_type          = bool;
    using first_argument_type  = shared_ptr&lt;T&gt;;
    using second_argument_type = shared_ptr&lt;T&gt;;
  };

  template&lt;class T&gt; struct owner_less&lt;weak_ptr&lt;T&gt;&gt; {
    using result_type          = bool;
    using first_argument_type  = weak_ptr&lt;T&gt;;
    using second_argument_type = weak_ptr&lt;T&gt;;
  };

  template &lt;class T&gt; class reference_wrapper {
  public :
    using result_type          = <i><span class='texttt'>see below</span></i>; <span class='comment'>// not always defined
</span>    using argument_type        = <i><span class='texttt'>see below</span></i>; <span class='comment'>// not always defined
</span>    using first_argument_type  = <i><span class='texttt'>see below</span></i>; <span class='comment'>// not always defined
</span>    using second_argument_type = <i><span class='texttt'>see below</span></i>; <span class='comment'>// not always defined
</span>  };

  template &lt;class T&gt; struct plus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct minus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct multiplies {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct divides {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct modulus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct negate {
    using argument_type = T;
    using result_type   = T;
  };

  template &lt;class T&gt; struct equal_to {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct not_equal_to {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct greater {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct less {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct greater_equal {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct less_equal {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct logical_and {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct logical_or {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct logical_not {
    using argument_type = T;
    using result_type   = bool;
  };

  template &lt;class T&gt; struct bit_and {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct bit_or {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct bit_xor {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct bit_not {
    using argument_type = T;
    using result_type   = T;
  };

  template&lt;class R, class T1&gt;
  class function&lt;R(T1)&gt; {
  public:
    using argument_type = T1;
  };

  template&lt;class R, class T1, class T2&gt;
  class function&lt;R(T1, T2)&gt; {
  public:
    using first_argument_type  = T1;
    using second_argument_type = T2;
  };
}</pre><p ><span class='indexparent'><a class='index' id='reference_wrapper,weak_result_type'></a></span></p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/future.tex#L1462'>#</a></div><p ><span class='texttt'>reference_&shy;wrapper&lt;T&gt;</span> has a weak result type (<a href='depr.weak.result_type'>[depr.weak.result_type]</a>).
If <span class='texttt'>T</span> is a function type,
<span class='texttt'>result_&shy;type</span> shall be a synonym for the return type of <span class='texttt'>T</span>.</p><p ><span class='indexparent'><a class='index' id='argument_type,reference_wrapper'></a></span><span class='indexparent'><a class='index' id='reference_wrapper,argument_type'></a></span></p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/future.tex#L1468'>#</a></div><p >The template specialization <span class='texttt'>reference_&shy;wrapper&lt;T&gt;</span>
shall define a nested type named <span class='texttt'>argument_&shy;type</span>
as a synonym for <span class='texttt'>T1</span>
only if the type <span class='texttt'>T</span> is any of the following:
</p><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><p >a function type or a pointer to function type taking one argument of type <span class='texttt'>T1</span>
</p></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><p >a pointer to member function <span class='texttt'>R T0&#x200b;::&#x200b;f</span> <i>cv</i> (where <i>cv</i> represents the member function's cv-qualifiers); the type <span class='texttt'>T1</span> is <i>cv</i> <span class='texttt'>T0*</span>
</p></li><li id='4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.3'>(4.3)</a></div><p >a class type where the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>T&#x200b;::&#x200b;argument_&shy;type</span>
is valid and denotes a type (<a href='temp.deduct'>[temp.deduct]</a>);
the type <span class='texttt'>T1</span> is <span class='texttt'>T&#x200b;::&#x200b;argument_&shy;type</span>.
</p></li></ul><p ><span class='indexparent'><a class='index' id='first_argument_type,reference_wrapper'></a></span><span class='indexparent'><a class='index' id='reference_wrapper,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,reference_wrapper'></a></span><span class='indexparent'><a class='index' id='reference_wrapper,second_argument_type'></a></span></p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/future.tex#L1484'>#</a></div><p >The template instantiation <span class='texttt'>reference_&shy;wrapper&lt;T&gt;</span>
shall define two nested types
named <span class='texttt'>first_&shy;argument_&shy;type</span> and <span class='texttt'>second_&shy;argument_&shy;type</span>
as synonyms for <span class='texttt'>T1</span> and <span class='texttt'>T2</span>, respectively,
only if the type <span class='texttt'>T</span> is any of the following:
</p><ul class='itemize'><li id='5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.1'>(5.1)</a></div><p >a function type or a pointer to function type taking two arguments of types <span class='texttt'>T1</span> and <span class='texttt'>T2</span>
</p></li><li id='5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.2'>(5.2)</a></div><p >a pointer to member function <span class='texttt'>R T0&#x200b;::&#x200b;f(T2)</span> <i>cv</i> (where <i>cv</i> represents the member function's cv-qualifiers); the type <span class='texttt'>T1</span> is <i>cv</i> <span class='texttt'>T0*</span>
</p></li><li id='5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.3'>(5.3)</a></div><p >a class type where the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-ids</a></i>
<span class='texttt'>T&#x200b;::&#x200b;first_&shy;argument_&shy;type</span> and <span class='texttt'>T&#x200b;::&#x200b;second_&shy;argument_&shy;type</span>
are both valid and both denote types (<a href='temp.deduct'>[temp.deduct]</a>);
the type <span class='texttt'>T1</span> is <span class='texttt'>T&#x200b;::&#x200b;first_&shy;argument_&shy;type</span> and
the type <span class='texttt'>T2</span> is <span class='texttt'>T&#x200b;::&#x200b;second_&shy;argument_&shy;type</span>.
</p></li></ul><p ><span class='indexparent'><a class='index' id='result_type,hash'></a></span><span class='indexparent'><a class='index' id='hash,result_type'></a></span><span class='indexparent'><a class='index' id='argument_type,hash'></a></span><span class='indexparent'><a class='index' id='hash,argument_type'></a></span></p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/future.tex#L1502'>#</a></div><p >All enabled specializations <span class='texttt'>hash&lt;Key&gt;</span> of <span class='texttt'>hash</span> (<a href='unord.hash'>[unord.hash]</a>)
provide two nested types, <span class='texttt'>result_&shy;type</span> and <span class='texttt'>argument_&shy;type</span>,
which shall be synonyms for <span class='texttt'>size_&shy;t</span> and <span class='texttt'>Key</span>, respectively.</p><p ><span class='indexparent'><a class='index' id='bind,weak_result_type'></a></span></p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/future.tex#L1508'>#</a></div><p >The forwarding call wrapper <span class='texttt'>g</span>
returned by a call to <span class='texttt'>bind(f, bound_&shy;args...)</span> (<a href='func.bind.bind'>[func.bind.bind]</a>)
shall have a weak result type (<a href='depr.weak.result_type'>[depr.weak.result_type]</a>).</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/future.tex#L1513'>#</a></div><p >The forwarding call wrapper <span class='texttt'>g</span>
returned by a call to <span class='texttt'>bind&lt;R&gt;(f, bound_&shy;args...)</span> (<a href='func.bind.bind'>[func.bind.bind]</a>)
shall have a nested type <span class='texttt'>result_&shy;type</span> defined as a synonym for <span class='texttt'>R</span>.</p><p ><span class='indexparent'><a class='index' id='result_type,mem_fn'></a></span><span class='indexparent'><a class='index' id='mem_fn,result_type'></a></span></p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/future.tex#L1519'>#</a></div><p >The simple call wrapper
returned from a call to <span class='texttt'>mem_&shy;fn(pm)</span>
shall have a nested type <span class='texttt'>result_&shy;type</span>
that is a synonym for
the return type of <span class='texttt'>pm</span>
when <span class='texttt'>pm</span> is a pointer to member function.</p><p ><span class='indexparent'><a class='index' id='result_type,mem_fn'></a></span><span class='indexparent'><a class='index' id='mem_fn,result_type'></a></span><span class='indexparent'><a class='index' id='argument_type,mem_fn'></a></span><span class='indexparent'><a class='index' id='mem_fn,argument_type'></a></span></p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/future.tex#L1529'>#</a></div><p >The simple call wrapper
returned from a call to <span class='texttt'>mem_&shy;fn(pm)</span>
shall define two nested types
named <span class='texttt'>argument_&shy;type</span> and <span class='texttt'>result_&shy;type</span>
as synonyms for <i>cv</i> <span class='texttt'>T*</span> and <span class='texttt'>Ret</span>, respectively,
when <span class='texttt'>pm</span> is a pointer to member function
with cv-qualifier <i>cv</i>
and taking no arguments,
where <span class='texttt'>Ret</span> is <span class='texttt'>pm</span>'s return type.</p><p ><span class='indexparent'><a class='index' id='result_type,mem_fn'></a></span><span class='indexparent'><a class='index' id='mem_fn,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,mem_fn'></a></span><span class='indexparent'><a class='index' id='mem_fn,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,mem_fn'></a></span><span class='indexparent'><a class='index' id='mem_fn,second_argument_type'></a></span></p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/future.tex#L1543'>#</a></div><p >The simple call wrapper
returned from a call to <span class='texttt'>mem_&shy;fn(pm)</span>
shall define three nested types
named <span class='texttt'>first_&shy;argument_&shy;type</span>, <span class='texttt'>second_&shy;argument_&shy;type</span>, and <span class='texttt'>result_&shy;type</span>
as synonyms for <i>cv</i> <span class='texttt'>T*</span>, <span class='texttt'>T1</span>, and <span class='texttt'>Ret</span>, respectively,
when <span class='texttt'>pm</span> is a pointer to member function
with cv-qualifier <i>cv</i>
and taking one argument of type <span class='texttt'>T1</span>,
where <span class='texttt'>Ret</span> is <span class='texttt'>pm</span>'s return type.</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/future.tex#L1554'>#</a></div><p >The following member names are defined in addition to names specified in Clause <a href='containers'>[containers]</a>:</p><p ><span class='indexparent'><a class='index' id='result_type,map::value_compare'></a></span><span class='indexparent'><a class='index' id='map::value_compare,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,map::value_compare'></a></span><span class='indexparent'><a class='index' id='map::value_compare,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,map::value_compare'></a></span><span class='indexparent'><a class='index' id='map::value_compare,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,multimap::value_compare'></a></span><span class='indexparent'><a class='index' id='multimap::value_compare,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,multimap::value_compare'></a></span><span class='indexparent'><a class='index' id='multimap::value_compare,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,multimap::value_compare'></a></span><span class='indexparent'><a class='index' id='multimap::value_compare,second_argument_type'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class Key, class T, class Compare, class Allocator&gt;
  class map&lt;Key, T, Compare, Allocator&gt;::value_compare {
  public:
    using result_type          = bool;
    using first_argument_type  = value_type;
    using second_argument_type = value_type;
  };

  template &lt;class Key, class T, class Compare, class Allocator&gt;
  class multimap&lt;Key, T, Compare, Allocator&gt;::value_compare {
  public:
    using result_type          = bool;
    using first_argument_type  = value_type;
    using second_argument_type = value_type;
  };
}</pre></div></div></div></body></html>