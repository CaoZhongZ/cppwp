<!DOCTYPE html><html lang='en'><head><title>[over.ass]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>13.5</a> Overloaded operators <a class='abbr_ref' href='over.oper#over.ass'>[over.oper]</a></h2><div id='over.ass'><h3 ><a class='secnum' style='min-width:103pt'>13.5.3</a> Assignment <a class='abbr_ref'>[over.ass]</a></h3><p ><span class='indexparent'><a class='index' id='assignment_operator,overloaded'></a></span><span class='indexparent'><a class='index' id='overloading,assignment_operator'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >An assignment operator shall be implemented by a
non-static member function with
exactly one parameter.
Because a copy assignment operator
<span class='texttt'>operator=</span>
is implicitly declared for a class if not declared by the user (<a href='class.copy'>[class.copy]</a>),
a base class assignment operator is always hidden by the copy assignment
operator of the derived class.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Any assignment operator, even the copy and move assignment operators, can be virtual.
[&nbsp;<i>Note:</i><span class='space'></span>
For a derived class
<span class='texttt'>D</span>
with a base class
<span class='texttt'>B</span>
for which a virtual copy/move assignment has been declared,
the copy/move assignment operator in
<span class='texttt'>D</span>
does not override
<span class='texttt'>B</span>'s
virtual copy/move assignment operator.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct B {
  virtual int operator= (int);
  virtual B&amp; operator= (const B&amp;);
};
struct D : B {
  virtual int operator= (int);
  virtual D&amp; operator= (const B&amp;);
};

D dobj1;
D dobj2;
B* bptr = &amp;dobj1;
void f() {
  bptr-&gt;operator=(99);          <span class='comment'>// calls <span class='texttt'>D::operator=(int)</span>
</span>  *bptr = 99;                   <span class='comment'>// ditto
</span>  bptr-&gt;operator=(dobj2);       <span class='comment'>// calls <span class='texttt'>D::operator=(const B&amp;)</span>
</span>  *bptr = dobj2;                <span class='comment'>// ditto
</span>  dobj1 = dobj2;                <span class='comment'>// calls implicitly-declared
</span>                                <span class='comment'>// <span class='texttt'>D::operator=(const D&amp;)</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div></body></html>