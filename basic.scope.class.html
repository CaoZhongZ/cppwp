<!DOCTYPE html><html lang='en'><head><title>[basic.scope.class]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>3.3</a> Scope <a class='abbr_ref' href='basic.scope#class'>[basic.scope]</a></h2><div id='basic.scope.class'><h3 ><a class='secnum' style='min-width:103pt'>3.3.7</a> Class scope <a class='abbr_ref'>[basic.scope.class]</a></h3><p ><span class='indexparent'><a class='index' id='scope,class'></a></span>
</p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The potential scope of a name declared in a class consists not
only of the declarative region following the name's point of
declaration, but also of all function bodies, default arguments,
<i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifiers</a></i>, and
<span class='grammarterm'>brace-or-equal-initializers</span> of non-static data members
in that class (including such
things in nested classes).</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A name <span class='texttt'>N</span> used in a class <span class='texttt'>S</span> shall refer to the same
declaration in its context and when re-evaluated in the completed scope
of <span class='texttt'>S</span>. No diagnostic is required for a violation of this rule.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A name declared within a member function hides a declaration of
the same name whose scope extends to or past the end of the member
function's class.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The potential scope of a declaration that extends to or past the
end of a class definition also extends to the regions defined by its
member definitions, even if the members are defined lexically outside
the class (this includes static data member definitions, nested class
definitions, and member function definitions, including the member function
body and any portion of the
declarator part of such definitions which follows the <i ><a href='dcl.decl#nt:declarator-id'>declarator-id</a></i>,
including a <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> and any default
arguments (<a href='dcl.fct.default'>[dcl.fct.default]</a>)).</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
typedef int  c;
enum { i = 1 };

class X {
  char  v[i];                       <span class='comment'>// error: <span class='texttt'>i</span> refers to <span class='texttt'>::i</span> but when reevaluated is <span class='texttt'>X::i</span>
</span>  int  f() { return sizeof(c); }    <span class='comment'>// OK: <span class='texttt'>X::c</span>
</span>  char  c;
  enum { i = 2 };
};

typedef char*  T;
struct Y {
  T  a;                             <span class='comment'>// error: <span class='texttt'>T</span> refers to <span class='texttt'>::T</span> but when reevaluated is <span class='texttt'>Y::T</span>
</span>  typedef long  T;
  T  b;
};

typedef int I;
class D {
  typedef I I;                      <span class='comment'>// error, even though no reordering involved
</span>};
</pre><p ><i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >The name of a class member shall only be used as follows:
</p><ul class='itemize'><li id='6.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.1'>(6.1)</a></div><p >in the scope of its class (as described above) or a class derived
(Clause <a href='class.derived'>[class.derived]</a>) from its class,
</p></li><li id='6.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.2'>(6.2)</a></div><p >after the <span class='texttt'>.</span> operator applied to an expression of the type
of its class (<a href='expr.ref'>[expr.ref]</a>) or a class derived from its class,
</p></li><li id='6.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.3'>(6.3)</a></div><p >after the <span class='texttt'>-&gt;</span> operator applied to a pointer to an object of
its class (<a href='expr.ref'>[expr.ref]</a>) or a class derived from its class,
</p></li><li id='6.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#6.4'>(6.4)</a></div><p >after the <span class='texttt'>::</span> scope resolution operator (<a href='expr.prim'>[expr.prim]</a>)
applied to the name of its class or a class derived from its class.
</p></li></ul></div></div></div></body></html>