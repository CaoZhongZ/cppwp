<!DOCTYPE html><html lang='en'><head><title>[memory]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><div id='memory'><h2 ><a class='secnum' style='min-width:88pt'>20.10</a> Memory <a class='abbr_ref'>[memory]</a></h2><div id='general'><h3 ><a class='secnum' href='#general' style='min-width:103pt'>20.10.1</a> In general <a class='abbr_ref' href='memory.general'>[memory.general]</a></h3><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L6750'>#</a></div><p >This subclause describes the contents of the header
<span class='texttt'>&lt;memory&gt;</span> (<a href='memory.syn'>[memory.syn]</a>) and some
of the contents of the header <span class='texttt'>&lt;cstdlib&gt;</span> (<a href='cstdlib.syn'>[cstdlib.syn]</a>).</p></div></div><div id='syn'><h3 ><a class='secnum' href='#syn' style='min-width:103pt'>20.10.2</a> Header <span class='texttt'>&lt;memory&gt;</span> synopsis <a class='abbr_ref' href='memory.syn'>[memory.syn]</a></h3><div class='para' id='syn-1'><div class='marginalizedparent'><a class='marginalized' href='#syn-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L6757'>#</a></div><p >The header <span class='texttt'>&lt;memory&gt;</span> defines several types and function templates that
describe properties of pointers and pointer-like types, manage memory
for containers and other template types, destroy objects, and
construct multiple objects in
uninitialized memory
buffers (<a href='pointer.traits'>[pointer.traits]</a>â€“<a href='specialized.algorithms'>[specialized.algorithms]</a>).
The header also defines the templates
<span class='texttt'>unique_ptr</span>, <span class='texttt'>shared_ptr</span>, <span class='texttt'>weak_ptr</span>, and various function
templates that operate on objects of these types (<a href='smartptr'>[smartptr]</a>).</p><p ><span class='indexparent'><a class='index' id='memory'></a></span><span class='indexparent'><a class='index' id='memory'></a></span></p><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='pointer.traits'>[pointer.traits]</a>, pointer traits
</span>  template &lt;class Ptr&gt; struct pointer_traits;
  template &lt;class T&gt; struct pointer_traits&lt;T*&gt;;

  <span class='comment'>// <a href='util.dynamic.safety'>[util.dynamic.safety]</a>, pointer safety
</span>  enum class pointer_safety { relaxed, preferred, strict };
  void declare_reachable(void* p);
  template &lt;class T&gt; T* undeclare_reachable(T* p);
  void declare_no_pointers(char* p, size_t n);
  void undeclare_no_pointers(char* p, size_t n);
  pointer_safety get_pointer_safety() noexcept;

  <span class='comment'>// <a href='ptr.align'>[ptr.align]</a>, pointer alignment function
</span>  void* align(size_t alignment, size_t size, void*&amp; ptr, size_t&amp; space);

  <span class='comment'>// <a href='allocator.tag'>[allocator.tag]</a>, allocator argument tag
</span>  struct allocator_arg_t { explicit allocator_arg_t() = default; };
  constexpr allocator_arg_t allocator_arg{};

  <span class='comment'>// <a href='allocator.uses'>[allocator.uses]</a>, <span class='texttt'>uses_allocator</span>
</span>  template &lt;class T, class Alloc&gt; struct uses_allocator;

  <span class='comment'>// <a href='allocator.traits'>[allocator.traits]</a>, allocator traits
</span>  template &lt;class Alloc&gt; struct allocator_traits;

  <span class='comment'>// <a href='default.allocator'>[default.allocator]</a>, the default allocator
</span>  template &lt;class T&gt; class allocator;
  template &lt;class T, class U&gt;
    bool operator==(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;
  template &lt;class T, class U&gt;
    bool operator!=(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;

  <span class='comment'>// <a href='specialized.algorithms'>[specialized.algorithms]</a>, specialized algorithms
</span>  template &lt;class T&gt; constexpr T* addressof(T&amp; r) noexcept;
  template &lt;class T&gt; const T* addressof(const T&amp;&amp;) = delete;
  template &lt;class ForwardIterator&gt;
    void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
  template &lt;class ExecutionPolicy, class ForwardIterator&gt;
    void uninitialized_default_construct(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                         ForwardIterator first, ForwardIterator last);
  template &lt;class ForwardIterator, class Size&gt;
    ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);
  template &lt;class ExecutionPolicy, class ForwardIterator, class Size&gt;
    ForwardIterator uninitialized_default_construct_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                                      ForwardIterator first, Size n);
  template &lt;class ForwardIterator&gt;
    void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
  template &lt;class ExecutionPolicy, class ForwardIterator&gt;
    void uninitialized_value_construct(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                       ForwardIterator first, ForwardIterator last);
  template &lt;class ForwardIterator, class Size&gt;
    ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);
  template &lt;class ExecutionPolicy, class ForwardIterator, class Size&gt;
    ForwardIterator uninitialized_value_construct_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                                    ForwardIterator first, Size n);
  template &lt;class InputIterator, class ForwardIterator&gt;
    ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template &lt;class ExecutionPolicy, class InputIterator, class ForwardIterator&gt;
    ForwardIterator uninitialized_copy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                       InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template &lt;class InputIterator, class Size, class ForwardIterator&gt;
    ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                         ForwardIterator result);
  template &lt;class ExecutionPolicy, class InputIterator, class Size, class ForwardIterator&gt;
    ForwardIterator uninitialized_copy_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                         InputIterator first, Size n,
                                         ForwardIterator result);
  template &lt;class InputIterator, class ForwardIterator&gt;
    ForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template &lt;class ExecutionPolicy, class InputIterator, class ForwardIterator&gt;
    ForwardIterator uninitialized_move(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                       InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template &lt;class InputIterator, class Size, class ForwardIterator&gt;
    pair&lt;InputIterator, ForwardIterator&gt;
      uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);
  template &lt;class ExecutionPolicy, class InputIterator, class Size, class ForwardIterator&gt;
    pair&lt;InputIterator, ForwardIterator&gt;
      uninitialized_move_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                           InputIterator first, Size n, ForwardIterator result);
  template &lt;class ForwardIterator, class T&gt;
    void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                            const T&amp; x);
  template &lt;class ExecutionPolicy, class ForwardIterator, class T&gt;
    void uninitialized_fill(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                            ForwardIterator first, ForwardIterator last,
                            const T&amp; x);
  template &lt;class ForwardIterator, class Size, class T&gt;
    ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x);
  template &lt;class ExecutionPolicy, class ForwardIterator, class Size, class T&gt;
    ForwardIterator uninitialized_fill_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                                         ForwardIterator first, Size n, const T&amp; x);
  template &lt;class T&gt;
    void destroy_at(T* location);
  template &lt;class ForwardIterator&gt;
    void destroy(ForwardIterator first, ForwardIterator last);
  template &lt;class ExecutionPolicy, class ForwardIterator&gt;
    void destroy(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                 ForwardIterator first, ForwardIterator last);
  template &lt;class ForwardIterator, class Size&gt;
    ForwardIterator destroy_n(ForwardIterator first, Size n);
  template &lt;class ExecutionPolicy, class ForwardIterator, class Size&gt;
    ForwardIterator destroy_n(ExecutionPolicy&amp;&amp; exec, <span class='comment'>// see <a href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a>
</span>                              ForwardIterator first, Size n);

  <span class='comment'>// <a href='unique.ptr'>[unique.ptr]</a>, class template unique_ptr
</span>  template &lt;class T&gt; struct default_delete;
  template &lt;class T&gt; struct default_delete&lt;T[]&gt;;
  template &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr;
  template &lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt;;

  template &lt;class T, class... Args&gt; unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args);
  template &lt;class T&gt; unique_ptr&lt;T&gt; make_unique(size_t n);
  template &lt;class T, class... Args&gt; <i><span class='texttt'>unspecified</span></i> make_unique(Args&amp;&amp;...) = delete;

  template &lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y) noexcept;

  template &lt;class T1, class D1, class T2, class D2&gt;
    bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
    bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
    bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
    bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
    bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
    bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);

  template &lt;class T, class D&gt;
    bool operator==(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T, class D&gt;
    bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y) noexcept;
  template &lt;class T, class D&gt;
    bool operator!=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T, class D&gt;
    bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y) noexcept;
  template &lt;class T, class D&gt;
    bool operator&lt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template &lt;class T, class D&gt;
    bool operator&lt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template &lt;class T, class D&gt;
    bool operator&lt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template &lt;class T, class D&gt;
    bool operator&lt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template &lt;class T, class D&gt;
    bool operator&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template &lt;class T, class D&gt;
    bool operator&gt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template &lt;class T, class D&gt;
    bool operator&gt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template &lt;class T, class D&gt;
    bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);

  <span class='comment'>// <a href='util.smartptr.weak.bad'>[util.smartptr.weak.bad]</a>, class bad_weak_ptr
</span>  class bad_weak_ptr;

  <span class='comment'>// <a href='util.smartptr.shared'>[util.smartptr.shared]</a>, class template shared_ptr
</span>  template&lt;class T&gt; class shared_ptr;

  <span class='comment'>// <a href='util.smartptr.shared.create'>[util.smartptr.shared.create]</a>, shared_ptr creation
</span>  template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
  template&lt;class T, class A, class... Args&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);

  <span class='comment'>// <a href='util.smartptr.shared.cmp'>[util.smartptr.shared.cmp]</a>, shared_ptr comparisons
</span>  template&lt;class T, class U&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator!=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;

  template &lt;class T&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template &lt;class T&gt;
    bool operator!=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template &lt;class T&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template &lt;class T&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template &lt;class T&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template &lt;class T&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template &lt;class T&gt;
    bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;

  <span class='comment'>// <a href='util.smartptr.shared.spec'>[util.smartptr.shared.spec]</a>, shared_ptr specialized algorithms
</span>  template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b) noexcept;

  <span class='comment'>// <a href='util.smartptr.shared.cast'>[util.smartptr.shared.cast]</a>, shared_ptr casts
</span>  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; static_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; dynamic_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; const_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;

  <span class='comment'>// <a href='util.smartptr.getdeleter'>[util.smartptr.getdeleter]</a>, shared_ptr get_deleter
</span>  template&lt;class D, class T&gt; D* get_deleter(const shared_ptr&lt;T&gt;&amp; p) noexcept;

  <span class='comment'>// <a href='util.smartptr.shared.io'>[util.smartptr.shared.io]</a>, shared_ptr I/O
</span>  template&lt;class E, class T, class Y&gt;
    basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt; (basic_ostream&lt;E, T&gt;&amp; os, const shared_ptr&lt;Y&gt;&amp; p);

  <span class='comment'>// <a href='util.smartptr.weak'>[util.smartptr.weak]</a>, class template weak_ptr
</span>  template&lt;class T&gt; class weak_ptr;

  <span class='comment'>// <a href='util.smartptr.weak.spec'>[util.smartptr.weak.spec]</a>, weak_ptr specialized algorithms
</span>  template&lt;class T&gt; void swap(weak_ptr&lt;T&gt;&amp; a, weak_ptr&lt;T&gt;&amp; b) noexcept;

  <span class='comment'>// <a href='util.smartptr.ownerless'>[util.smartptr.ownerless]</a>, class template owner_less
</span>  template&lt;class T = void&gt; struct owner_less;

  <span class='comment'>// <a href='util.smartptr.enab'>[util.smartptr.enab]</a>, class template enable_shared_from_this
</span>  template&lt;class T&gt; class enable_shared_from_this;

  <span class='comment'>// <a href='util.smartptr.shared.atomic'>[util.smartptr.shared.atomic]</a>, shared_ptr atomic access
</span>  template&lt;class T&gt;
    bool atomic_is_lock_free(const shared_ptr&lt;T&gt;* p);

  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_load(const shared_ptr&lt;T&gt;* p);
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_load_explicit(const shared_ptr&lt;T&gt;* p, memory_order mo);

  template&lt;class T&gt;
    void atomic_store(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
  template&lt;class T&gt;
    void atomic_store_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r, memory_order mo);

  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_exchange(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; atomic_exchange_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r, memory_order mo);

  template&lt;class T&gt;
    bool atomic_compare_exchange_weak(
      shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);
  template&lt;class T&gt;
    bool atomic_compare_exchange_strong(
      shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);
  template&lt;class T&gt;
    bool atomic_compare_exchange_weak_explicit(
      shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
      memory_order success, memory_order failure);
  template&lt;class T&gt;
    bool atomic_compare_exchange_strong_explicit(
      shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
      memory_order success, memory_order failure);

  <span class='comment'>// <a href='util.smartptr.hash'>[util.smartptr.hash]</a>, hash support
</span>  template &lt;class T&gt; struct hash;
  template &lt;class T, class D&gt; struct hash&lt;unique_ptr&lt;T, D&gt;&gt;;
  template &lt;class T&gt; struct hash&lt;shared_ptr&lt;T&gt;&gt;;

  <span class='comment'>// <a href='allocator.uses.trait'>[allocator.uses.trait]</a>, uses_allocator
</span>  template &lt;class T, class Alloc&gt;
    constexpr bool uses_allocator_v = uses_allocator&lt;T, Alloc&gt;::value;
}</pre></div></div><div id='pointer.traits'><h3 ><a class='secnum' href='#pointer.traits' style='min-width:103pt'>20.10.3</a> Pointer traits <a class='abbr_ref' href='pointer.traits'>[pointer.traits]</a></h3><div class='para' id='pointer.traits-1'><div class='marginalizedparent'><a class='marginalized' href='#pointer.traits-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7057'>#</a></div><p >The class template <span class='texttt'>pointer_traits</span> supplies a uniform interface to certain
attributes of pointer-like types.</p><p ><span class='indexparent'><a class='index' id='pointer_traits'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class Ptr&gt; struct pointer_traits {
    using pointer         = Ptr;
    using element_type    = <i><span class='texttt'>see below</span></i>;
    using difference_type = <i><span class='texttt'>see below</span></i>;

    template &lt;class U&gt; using rebind = <i><span class='texttt'>see below</span></i>;

    static pointer pointer_to(<i><span class='texttt'>see below</span></i> r);
  };

  template &lt;class T&gt; struct pointer_traits&lt;T*&gt; {
    using pointer         = T*;
    using element_type    = T;
    using difference_type = ptrdiff_t;

    template &lt;class U&gt; using rebind = U*;

    static pointer pointer_to(<i><span class='texttt'>see below</span></i> r) noexcept;
  };
}</pre></div><div id='pointer.traits.types'><h4 ><a class='secnum' href='#pointer.traits.types' style='min-width:118pt'>20.10.3.1</a> Pointer traits member types <a class='abbr_ref' href='pointer.traits.types'>[pointer.traits.types]</a></h4><p ><span class='indexparent'><a class='index' id='element_type,pointer_traits'></a></span><span class='indexparent'><a class='index' id='pointer_traits,element_type'></a></span><code class='itemdecl'>
using element_type = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='pointer.traits.types-1'><div class='marginalizedparent'><a class='marginalized' href='#pointer.traits.types-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7094'>#</a></div><p ><i>Type:</i> <span class='texttt'>Ptr::element_type</span> if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Ptr::element_type</span> is valid and denotes a
type (<a href='temp.deduct'>[temp.deduct]</a>); otherwise, <span class='texttt'>T</span> if
<span class='texttt'>Ptr</span> is a class template instantiation of the form <span class='texttt'>SomePointer&lt;T, Args&gt;</span>,
where <span class='texttt'>Args</span> is zero or more type arguments; otherwise, the specialization is
ill-formed.
</p></div></div><p ><span class='indexparent'><a class='index' id='difference_type,pointer_traits'></a></span><span class='indexparent'><a class='index' id='pointer_traits,difference_type'></a></span><code class='itemdecl'>
using difference_type = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='pointer.traits.types-2'><div class='marginalizedparent'><a class='marginalized' href='#pointer.traits.types-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7109'>#</a></div><p ><i>Type:</i> <span class='texttt'>Ptr::difference_type</span> if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Ptr::difference_type</span> is valid and denotes a
type (<a href='temp.deduct'>[temp.deduct]</a>); otherwise,
<span class='texttt'>ptrdiff_t</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='rebind,pointer_traits'></a></span><span class='indexparent'><a class='index' id='pointer_traits,rebind'></a></span><code class='itemdecl'>
template &lt;class U&gt; using rebind = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='pointer.traits.types-3'><div class='marginalizedparent'><a class='marginalized' href='#pointer.traits.types-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7122'>#</a></div><p ><i>Alias template:</i> <span class='texttt'>Ptr::rebind&lt;U&gt;</span> if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Ptr::rebind&lt;U&gt;</span> is valid and denotes a
type (<a href='temp.deduct'>[temp.deduct]</a>); otherwise,
<span class='texttt'>SomePointer&lt;U, Args&gt;</span> if
<span class='texttt'>Ptr</span> is a class template instantiation of the form <span class='texttt'>SomePointer&lt;T, Args&gt;</span>,
where <span class='texttt'>Args</span> is zero or more type arguments; otherwise, the instantiation of
<span class='texttt'>rebind</span> is ill-formed.
</p></div></div></div><div id='pointer.traits.functions'><h4 ><a class='secnum' href='#pointer.traits.functions' style='min-width:118pt'>20.10.3.2</a> Pointer traits member functions <a class='abbr_ref' href='pointer.traits.functions'>[pointer.traits.functions]</a></h4><p ><span class='indexparent'><a class='index' id='pointer_to,pointer_traits'></a></span><span class='indexparent'><a class='index' id='pointer_traits,pointer_to'></a></span><code class='itemdecl'>
static pointer pointer_traits::pointer_to(<i><span class='texttt'>see below</span></i> r);
static pointer pointer_traits&lt;T*&gt;::pointer_to(<i><span class='texttt'>see below</span></i> r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='pointer.traits.functions-1'><div class='marginalizedparent'><a class='marginalized' href='#pointer.traits.functions-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7141'>#</a></div><p ><i>Remarks:</i> If <span class='texttt'>element_type</span> is <i>cv</i> <span class='texttt'>void</span>, the type of
<span class='texttt'>r</span> is unspecified; otherwise, it is <span class='texttt'>element_type&amp;</span>.</p></div></div><div class='para' id='pointer.traits.functions-2'><div class='marginalizedparent'><a class='marginalized' href='#pointer.traits.functions-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7145'>#</a></div><p ><i>Returns:</i> The first member function returns a pointer to <span class='texttt'>r</span>
obtained by calling <span class='texttt'>Ptr::pointer_to(r)</span> through which
indirection is valid; an instantiation of this function is
ill-formed if <span class='texttt'>Ptr</span> does not have a matching <span class='texttt'>pointer_to</span> static member
function. The second member function returns <span class='texttt'>addressof(r)</span>.
</p></div></div></div></div><div id='util.dynamic.safety'><h3 ><a class='secnum' href='#util.dynamic.safety' style='min-width:103pt'>20.10.4</a> Pointer safety <a class='abbr_ref' href='util.dynamic.safety'>[util.dynamic.safety]</a></h3><div class='para' id='util.dynamic.safety-1'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7155'>#</a></div><p >A complete object is <i>declared reachable</i> while the number of calls to
<span class='texttt'>declare_reachable</span> with an argument referencing the object exceeds the
number of calls to <span class='texttt'>undeclare_reachable</span> with an argument referencing the
object.</p><p ><span class='indexparent'><a class='index' id='declare_reachable'></a></span><code class='itemdecl'>
void declare_reachable(void* p);
</code></p></div><div class='itemdescr'></div><div class='para' id='util.dynamic.safety-2'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7167'>#</a></div><p ><i>Requires:</i> <span class='texttt'>p</span> shall be a safely-derived
pointer (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>) or a null pointer value.</p></div></div><div class='para' id='util.dynamic.safety-3'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7171'>#</a></div><p ><i>Effects:</i> If <span class='texttt'>p</span> is not null, the complete object referenced by <span class='texttt'>p</span>
is subsequently declared reachable (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>).</p></div></div><div class='para' id='util.dynamic.safety-4'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7175'>#</a></div><p ><i>Throws:</i> May throw <span class='texttt'>bad_alloc</span> if the system cannot allocate
additional memory that may be required to track objects declared reachable.
</p></div></div><p ><span class='indexparent'><a class='index' id='undeclare_reachable'></a></span><code class='itemdecl'>
template &lt;class T&gt; T* undeclare_reachable(T* p);
</code></p><div class='itemdescr'></div><div class='para' id='util.dynamic.safety-5'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7186'>#</a></div><p ><i>Requires:</i> If <span class='texttt'>p</span> is not null, the complete object referenced by <span class='texttt'>p</span>
shall have been previously declared reachable, and shall be
live (<a href='basic.life'>[basic.life]</a>) from the time of the call until the last
<span class='texttt'>undeclare_reachable(p)</span> call on the object.</p></div></div><div class='para' id='util.dynamic.safety-6'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7192'>#</a></div><p ><i>Returns:</i> A safely derived copy of <span class='texttt'>p</span> which shall compare equal to <span class='texttt'>p</span>.</p></div></div><div class='para' id='util.dynamic.safety-7'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7195'>#</a></div><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='util.dynamic.safety-8'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-8'>8</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7198'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> It is expected that calls to <span class='texttt'>declare_reachable(p)</span> will consume
a small amount of memory in addition to that occupied by the referenced object until the
matching call to <span class='texttt'>undeclare_reachable(p)</span> is encountered. Long running programs
should arrange that calls are matched. <i><span style='white-space:nowrap'>&thinsp;</span>â€”<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>] </p></div></div><p ><span class='indexparent'><a class='index' id='declare_no_pointers'></a></span><code class='itemdecl'>
void declare_no_pointers(char* p, size_t n);
</code></p><div class='itemdescr'></div><div class='para' id='util.dynamic.safety-9'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-9'>9</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7209'>#</a></div><p ><i>Requires:</i> No bytes in the specified range
are currently registered with
<span class='texttt'>declare_no_pointers()</span>. If the specified range is in an allocated object,
then it must be entirely within a single allocated object. The object must be
live until the corresponding <span class='texttt'>undeclare_no_pointers()</span> call. [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> In
a garbage-collecting implementation, the fact that a region in an object is
registered with <span class='texttt'>declare_no_pointers()</span> should not prevent the object from
being collected. <i><span style='white-space:nowrap'>&thinsp;</span>â€”<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div class='para' id='util.dynamic.safety-10'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-10'>10</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7219'>#</a></div><p ><i>Effects:</i> The <span class='texttt'>n</span> bytes starting at <span class='texttt'>p</span> no longer contain
traceable pointer locations, independent of their type. Hence
indirection through a pointer located there is undefined if the object
it points to was created by global <span class='texttt'>operator new</span> and not
previously declared reachable. [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> This may be used to inform a
garbage collector or leak detector that this region of memory need not
be traced. <i><span style='white-space:nowrap'>&thinsp;</span>â€”<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div class='para' id='util.dynamic.safety-11'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-11'>11</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7228'>#</a></div><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='util.dynamic.safety-12'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-12'>12</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7231'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> Under some conditions implementations may need to allocate memory.
However, the request can be ignored if memory allocation fails. <i><span style='white-space:nowrap'>&thinsp;</span>â€”<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
</p></div></div><p ><span class='indexparent'><a class='index' id='undeclare_no_pointers'></a></span><code class='itemdecl'>
void undeclare_no_pointers(char* p, size_t n);
</code></p><div class='itemdescr'></div><div class='para' id='util.dynamic.safety-13'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-13'>13</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7242'>#</a></div><p ><i>Requires:</i> The same range must previously have been passed to
<span class='texttt'>declare_no_pointers()</span>.</p></div></div><div class='para' id='util.dynamic.safety-14'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-14'>14</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7246'>#</a></div><p ><i>Effects:</i> Unregisters a range registered with <span class='texttt'>declare_no_pointers()</span> for
destruction. It must be called before the lifetime of the object ends.</p></div></div><div class='para' id='util.dynamic.safety-15'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-15'>15</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7250'>#</a></div><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='get_pointer_safety'></a></span><code class='itemdecl'>
pointer_safety get_pointer_safety() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='util.dynamic.safety-16'><div class='marginalizedparent'><a class='marginalized' href='#util.dynamic.safety-16'>16</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7260'>#</a></div><p ><i>Returns:</i> <span class='texttt'>pointer_safety::strict</span> if the implementation has strict pointer
safety (<a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>). It is
<span class='indexparent'><a class='index' id='whether_get_pointer_safety_returns_pointer_safety::relaxed_or_pointer_safety::preferred_if_the_implementation_has_relaxed_pointer_safety'></a></span>implementation-defined
whether
<span class='texttt'>get_pointer_safety</span> returns <span class='texttt'>pointer_safety::relaxed</span> or
<span class='texttt'>pointer_safety::preferred</span> if the implementation has relaxed pointer
safety.<a class='footnotenum' href='#footnote-221'>221</a>
</p></div></div><div class='footnote' id='footnote-221'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-221'>221)</a></div><p ><span class='texttt'>pointer_safety::preferred</span> might be returned to indicate
that a leak detector is running so that the program can avoid spurious leak
reports.</p></div></div><div id='ptr.align'><h3 ><a class='secnum' href='#ptr.align' style='min-width:103pt'>20.10.5</a> Align <a class='abbr_ref' href='ptr.align'>[ptr.align]</a></h3><p ><span class='indexparent'><a class='index' id='align'></a></span><code class='itemdecl'>
void* align(size_t alignment, size_t size, void*&amp; ptr, size_t&amp; space);
</code></p><div class='itemdescr'></div><div class='para' id='ptr.align-1'><div class='marginalizedparent'><a class='marginalized' href='#ptr.align-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7283'>#</a></div><p ><i>Effects:</i> If it is possible to fit <span class='texttt'>size</span> bytes
of storage aligned by <span class='texttt'>alignment</span> into the buffer pointed to by
<span class='texttt'>ptr</span> with length <span class='texttt'>space</span>, the function updates
<span class='texttt'>ptr</span> to represent the first possible address of such storage
and decreases <span class='texttt'>space</span> by the number of bytes used for alignment.
Otherwise, the function does nothing.</p></div></div><div class='para' id='ptr.align-2'><div class='marginalizedparent'><a class='marginalized' href='#ptr.align-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7291'>#</a></div><p ><i>Requires:</i></p><ul class='itemize'><li id='ptr.align-2.1'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#ptr.align-2.1'>(2.1)</a></div><p ><span class='texttt'>alignment</span> shall be a power of two</p></li><li id='ptr.align-2.2'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#ptr.align-2.2'>(2.2)</a></div><p ><span class='texttt'>ptr</span> shall represent the address of contiguous storage of at least
<span class='texttt'>space</span> bytes
</p></li></ul></div></div><div class='para' id='ptr.align-3'><div class='marginalizedparent'><a class='marginalized' href='#ptr.align-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7301'>#</a></div><p ><i>Returns:</i> A null pointer if the requested aligned buffer
would not fit into the available space, otherwise the adjusted value
of <span class='texttt'>ptr</span>.</p></div></div><div class='para' id='ptr.align-4'><div class='marginalizedparent'><a class='marginalized' href='#ptr.align-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7306'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> The function updates its <span class='texttt'>ptr</span>
and <span class='texttt'>space</span> arguments so that it can be called repeatedly
with possibly different <span class='texttt'>alignment</span> and <span class='texttt'>size</span>
arguments for the same buffer.  <i><span style='white-space:nowrap'>&thinsp;</span>â€”<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
</p></div></div></div><div id='allocator.tag'><h3 ><a class='secnum' href='#allocator.tag' style='min-width:103pt'>20.10.6</a> Allocator argument tag <a class='abbr_ref' href='allocator.tag'>[allocator.tag]</a></h3><p ><span class='indexparent'><a class='index' id='allocator_arg_t'></a></span><span class='indexparent'><a class='index' id='allocator_arg'></a></span><code class='itemdecl'>
namespace std {
  struct allocator_arg_t { explicit allocator_arg_t() = default; };
  constexpr allocator_arg_t allocator_arg{};
}
</code></p><div class='para' id='allocator.tag-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.tag-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7324'>#</a></div><p >The <span class='texttt'>allocator_arg_t</span> struct is an empty structure type used as a unique type to
disambiguate constructor and function overloading. Specifically, several types (see
<span class='texttt'>tuple</span> <a href='tuple'>[tuple]</a>) have constructors with <span class='texttt'>allocator_arg_t</span> as the first
argument, immediately followed by an argument of a type that satisfies the
<span class='texttt'>Allocator</span> requirements (<a href='allocator.requirements'>[allocator.requirements]</a>).</p></div></div><div id='allocator.uses'><h3 ><a class='secnum' href='#allocator.uses' style='min-width:103pt'>20.10.7</a> <span class='texttt'>uses_allocator</span> <a class='abbr_ref' href='allocator.uses'>[allocator.uses]</a></h3><div id='allocator.uses.trait'><h4 ><a class='secnum' href='#allocator.uses.trait' style='min-width:118pt'>20.10.7.1</a> <span class='texttt'>uses_allocator</span> trait <a class='abbr_ref' href='allocator.uses.trait'>[allocator.uses.trait]</a></h4><p ><span class='indexparent'><a class='index' id='uses_allocator'></a></span><code class='itemdecl'>
template &lt;class T, class Alloc&gt; struct uses_allocator;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.uses.trait-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.uses.trait-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7341'>#</a></div><p ><i>Remarks:</i> Automatically detects whether <span class='texttt'>T</span> has a nested <span class='texttt'>allocator_type</span> that
is convertible from <span class='texttt'>Alloc</span>. Meets the <span class='texttt'>BinaryTypeTrait</span>
requirements (<a href='meta.rqmts'>[meta.rqmts]</a>). The implementation shall provide a definition that is
derived from <span class='texttt'>true_type</span> if the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>T::allocator_type</span>
is valid and denotes a type (<a href='temp.deduct'>[temp.deduct]</a>) and
<span class='texttt'>is_convertible_v&lt;Alloc, T::allocator_type&gt; != false</span>, otherwise it shall be
derived from <span class='texttt'>false_type</span>. A program may specialize this template to derive from
<span class='texttt'>true_type</span> for a user-defined type <span class='texttt'>T</span> that does not have a nested
<span class='texttt'>allocator_type</span> but nonetheless can be constructed with an allocator where
either:</p><ul class='itemize'><li id='allocator.uses.trait-1.1'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#allocator.uses.trait-1.1'>(1.1)</a></div><p >the first argument of a constructor has type <span class='texttt'>allocator_arg_t</span> and the
second argument has type <span class='texttt'>Alloc</span> or</p></li><li id='allocator.uses.trait-1.2'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#allocator.uses.trait-1.2'>(1.2)</a></div><p >the last argument of a constructor has type <span class='texttt'>Alloc</span>.
</p></li></ul></div></div></div><div id='allocator.uses.construction'><h4 ><a class='secnum' href='#allocator.uses.construction' style='min-width:118pt'>20.10.7.2</a> Uses-allocator construction <a class='abbr_ref' href='allocator.uses.construction'>[allocator.uses.construction]</a></h4><div class='para' id='allocator.uses.construction-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.uses.construction-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7363'>#</a></div><p ><a class='hidden_link' href='#def:Uses-allocator_construction' id='def:Uses-allocator_construction'><i>Uses-allocator construction</i></a> with allocator <span class='texttt'>Alloc</span> refers to the
construction of an object <span class='texttt'>obj</span> of type <span class='texttt'>T</span>, using constructor arguments
<span class='texttt'>v1, v2, ..., vN</span> of types <span class='texttt'>V1, V2, ..., VN</span>, respectively, and an allocator
<span class='texttt'>alloc</span> of type <span class='texttt'>Alloc</span>, according to the following rules:</p><ul class='itemize'><li id='allocator.uses.construction-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.uses.construction-1.1'>(1.1)</a></div><p >if <span class='texttt'>uses_allocator_v&lt;T, Alloc&gt;</span> is <span class='texttt'>false</span> and
<span class='texttt'>is_constructible_v&lt;T, V1, V2, ..., VN&gt;</span> is <span class='texttt'>true</span>, then <span class='texttt'>obj</span> is
initialized as <span class='texttt'>obj(v1, v2, ..., vN)</span>;</p></li><li id='allocator.uses.construction-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.uses.construction-1.2'>(1.2)</a></div><p >otherwise, if <span class='texttt'>uses_allocator_v&lt;T, Alloc&gt;</span> is <span class='texttt'>true</span> and
<span class='texttt'>is_constructible_v&lt;T, allocator_arg_t, Alloc,</span> <span class='texttt'>V1, V2, ..., VN&gt;</span> is
<span class='texttt'>true</span>, then <span class='texttt'>obj</span> is initialized as <span class='texttt'>obj(allocator_arg, alloc, v1,
v2, ..., vN)</span>;</p></li><li id='allocator.uses.construction-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.uses.construction-1.3'>(1.3)</a></div><p >otherwise, if <span class='texttt'>uses_allocator_v&lt;T, Alloc&gt;</span> is <span class='texttt'>true</span> and
<span class='texttt'>is_constructible_v&lt;T, V1, V2, ..., VN, Alloc&gt;</span> is <span class='texttt'>true</span>, then
<span class='texttt'>obj</span> is initialized as <span class='texttt'>obj(v1, v2, ..., vN, alloc)</span>;</p></li><li id='allocator.uses.construction-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#allocator.uses.construction-1.4'>(1.4)</a></div><p >otherwise, the request for uses-allocator construction is ill-formed. [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
An error will result if <span class='texttt'>uses_allocator_v&lt;T, Alloc&gt;</span> is <span class='texttt'>true</span> but the
specific constructor does not take an allocator. This definition prevents a silent
failure to pass the allocator to an element. <i><span style='white-space:nowrap'>&thinsp;</span>â€”<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
</p></li></ul></div></div></div><div id='allocator.traits'><h3 ><a class='secnum' href='#allocator.traits' style='min-width:103pt'>20.10.8</a> Allocator traits <a class='abbr_ref' href='allocator.traits'>[allocator.traits]</a></h3><div class='para' id='allocator.traits-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7391'>#</a></div><p >The class template <span class='texttt'>allocator_traits</span> supplies a uniform interface to all
allocator types.
An allocator cannot be a non-class type, however, even if <span class='texttt'>allocator_traits</span>
supplies the entire required interface. [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> Thus, it is always possible to create
a derived class from an allocator. <i><span style='white-space:nowrap'>&thinsp;</span>â€”<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p><p ><span class='indexparent'><a class='index' id='allocator_traits'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class Alloc&gt; struct allocator_traits {
    using allocator_type     = Alloc;

    using value_type         = typename Alloc::value_type;

    using pointer            = <i><span class='texttt'>see below</span></i>;
    using const_pointer      = <i><span class='texttt'>see below</span></i>;
    using void_pointer       = <i><span class='texttt'>see below</span></i>;
    using const_void_pointer = <i><span class='texttt'>see below</span></i>;

    using difference_type    = <i><span class='texttt'>see below</span></i>;
    using size_type          = <i><span class='texttt'>see below</span></i>;

    using propagate_on_container_copy_assignment = <i><span class='texttt'>see below</span></i>;
    using propagate_on_container_move_assignment = <i><span class='texttt'>see below</span></i>;
    using propagate_on_container_swap            = <i><span class='texttt'>see below</span></i>;
    using is_always_equal                        = <i><span class='texttt'>see below</span></i>;

    template &lt;class T&gt; using rebind_alloc = <i><span class='texttt'>see below</span></i>;
    template &lt;class T&gt; using rebind_traits = allocator_traits&lt;rebind_alloc&lt;T&gt;&gt;;

    static pointer allocate(Alloc&amp; a, size_type n);
    static pointer allocate(Alloc&amp; a, size_type n, const_void_pointer hint);

    static void deallocate(Alloc&amp; a, pointer p, size_type n);

    template &lt;class T, class... Args&gt;
      static void construct(Alloc&amp; a, T* p, Args&amp;&amp;... args);

    template &lt;class T&gt;
      static void destroy(Alloc&amp; a, T* p);

    static size_type max_size(const Alloc&amp; a) noexcept;

    static Alloc select_on_container_copy_construction(const Alloc&amp; rhs);
  };
}</pre></div><div id='allocator.traits.types'><h4 ><a class='secnum' href='#allocator.traits.types' style='min-width:118pt'>20.10.8.1</a> Allocator traits member types <a class='abbr_ref' href='allocator.traits.types'>[allocator.traits.types]</a></h4><p ><span class='indexparent'><a class='index' id='pointer,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,pointer'></a></span><code class='itemdecl'>
using pointer = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7448'>#</a></div><p ><i>Type:</i> <span class='texttt'>Alloc::pointer</span> if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Alloc::pointer</span> is valid and denotes a
type (<a href='temp.deduct'>[temp.deduct]</a>); otherwise, <span class='texttt'>value_type*</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='const_pointer,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,const_pointer'></a></span><code class='itemdecl'>
using const_pointer = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-2'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7460'>#</a></div><p ><i>Type:</i> <span class='texttt'>Alloc::const_pointer</span> if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Alloc::const_pointer</span> is valid and denotes a
type (<a href='temp.deduct'>[temp.deduct]</a>); otherwise,
<span class='texttt'>pointer_traits&lt;pointer&gt;::rebind&lt;const value_type&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='void_pointer,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,void_pointer'></a></span><code class='itemdecl'>
using void_pointer = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-3'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7473'>#</a></div><p ><i>Type:</i> <span class='texttt'>Alloc::void_pointer</span> if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Alloc::void_pointer</span> is valid and denotes a
type (<a href='temp.deduct'>[temp.deduct]</a>); otherwise,
<span class='texttt'>pointer_traits&lt;pointer&gt;::rebind&lt;void&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='const_void_pointer,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,const_void_pointer'></a></span><code class='itemdecl'>
using const_void_pointer = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-4'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7486'>#</a></div><p ><i>Type:</i> <span class='texttt'>Alloc::const_void_pointer</span> if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Alloc::const_void_pointer</span> is valid and denotes a
type (<a href='temp.deduct'>[temp.deduct]</a>); otherwise,
<span class='texttt'>pointer_traits&lt;pointer&gt;::rebind&lt;const void&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='difference_type,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,difference_type'></a></span><code class='itemdecl'>
using difference_type = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-5'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7499'>#</a></div><p ><i>Type:</i> <span class='texttt'>Alloc::difference_type</span> if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Alloc::difference_type</span> is valid and denotes a
type (<a href='temp.deduct'>[temp.deduct]</a>); otherwise,
<span class='texttt'>pointer_traits&lt;pointer&gt;::difference_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='size_type,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,size_type'></a></span><code class='itemdecl'>
using size_type = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-6'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7512'>#</a></div><p ><i>Type:</i> <span class='texttt'>Alloc::size_type</span> if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Alloc::size_type</span> is valid and denotes a
type (<a href='temp.deduct'>[temp.deduct]</a>); otherwise,
<span class='texttt'>make_unsigned_t&lt;difference_type&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='propagate_on_container_copy_assignment,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,propagate_on_container_copy_assignment'></a></span><code class='itemdecl'>
using propagate_on_container_copy_assignment = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-7'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7525'>#</a></div><p ><i>Type:</i> <span class='texttt'>Alloc::propagate_on_container_copy_assignment</span> if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Alloc::propagate_on_container_copy_assignment</span> is valid and denotes a
type (<a href='temp.deduct'>[temp.deduct]</a>); otherwise
<span class='texttt'>false_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='propagate_on_container_move_assignment,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,propagate_on_container_move_assignment'></a></span><code class='itemdecl'>
using propagate_on_container_move_assignment = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-8'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-8'>8</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7538'>#</a></div><p ><i>Type:</i> <span class='texttt'>Alloc::propagate_on_container_move_assignment</span> if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Alloc::propagate_on_container_move_assignment</span> is valid and denotes a
type (<a href='temp.deduct'>[temp.deduct]</a>); otherwise
<span class='texttt'>false_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='propagate_on_container_swap,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,propagate_on_container_swap'></a></span><code class='itemdecl'>
using propagate_on_container_swap = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-9'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-9'>9</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7551'>#</a></div><p ><i>Type:</i> <span class='texttt'>Alloc::propagate_on_container_swap</span> if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Alloc::propagate_on_container_swap</span> is valid and denotes a
type (<a href='temp.deduct'>[temp.deduct]</a>); otherwise
<span class='texttt'>false_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_always_equal,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,is_always_equal'></a></span><code class='itemdecl'>
using is_always_equal = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-10'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-10'>10</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7564'>#</a></div><p ><i>Type:</i> <span class='texttt'>Alloc::is_always_equal</span> if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Alloc::is_always_equal</span>
is valid and denotes a type (<a href='temp.deduct'>[temp.deduct]</a>);
otherwise <span class='texttt'>is_empty&lt;Alloc&gt;::type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='rebind_alloc,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,rebind_alloc'></a></span><code class='itemdecl'>
template &lt;class T&gt; using rebind_alloc = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.types-11'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.types-11'>11</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7577'>#</a></div><p ><i>Alias template:</i> <span class='texttt'>Alloc::rebind&lt;T&gt;::other</span> if
the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>Alloc::rebind&lt;T&gt;::other</span> is valid and denotes a
type (<a href='temp.deduct'>[temp.deduct]</a>); otherwise,
<span class='texttt'>Alloc&lt;T, Args&gt;</span> if <span class='texttt'>Alloc</span> is a class template instantiation
of the form <span class='texttt'>Alloc&lt;U, Args&gt;</span>, where <span class='texttt'>Args</span> is zero or more type arguments;
otherwise, the instantiation of <span class='texttt'>rebind_alloc</span> is ill-formed.
</p></div></div></div><div id='allocator.traits.members'><h4 ><a class='secnum' href='#allocator.traits.members' style='min-width:118pt'>20.10.8.2</a> Allocator traits static member functions <a class='abbr_ref' href='allocator.traits.members'>[allocator.traits.members]</a></h4><p ><span class='indexparent'><a class='index' id='allocate,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,allocate'></a></span><code class='itemdecl'>
static pointer allocate(Alloc&amp; a, size_type n);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.members-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7594'>#</a></div><p ><i>Returns:</i> <span class='texttt'>a.allocate(n)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocate,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,allocate'></a></span><code class='itemdecl'>
static pointer allocate(Alloc&amp; a, size_type n, const_void_pointer hint);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.members-2'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7604'>#</a></div><p ><i>Returns:</i> <span class='texttt'>a.allocate(n, hint)</span> if that expression is well-formed; otherwise, <span class='texttt'>a.allocate(n)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='deallocate,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,deallocate'></a></span><code class='itemdecl'>
static void deallocate(Alloc&amp; a, pointer p, size_type n);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.members-3'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7614'>#</a></div><p ><i>Effects:</i> Calls <span class='texttt'>a.deallocate(p, n)</span>.</p></div></div><div class='para' id='allocator.traits.members-4'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7617'>#</a></div><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='construct,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,construct'></a></span><code class='itemdecl'>
template &lt;class T, class... Args&gt;
  static void construct(Alloc&amp; a, T* p, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.members-5'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7628'>#</a></div><p ><i>Effects:</i> Calls <span class='texttt'>a.construct(p, std::forward&lt;Args&gt;(args)...)</span>
if that call is well-formed;
otherwise, invokes <span class='texttt'>::new (static_cast&lt;void*&gt;(p)) T(std::forward&lt;Args&gt;(args)...)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='destroy,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,destroy'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  static void destroy(Alloc&amp; a, T* p);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.members-6'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7641'>#</a></div><p ><i>Effects:</i> Calls <span class='texttt'>a.destroy(p)</span> if that call is well-formed; otherwise, invokes
<span class='texttt'>p-&gt;~T()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='max_size,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,max_size'></a></span><code class='itemdecl'>
static size_type max_size(const Alloc&amp; a) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.members-7'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7652'>#</a></div><p ><i>Returns:</i> <span class='texttt'>a.max_size()</span> if that expression is well-formed; otherwise,
<span class='texttt'>numeric_limits&lt;size_type&gt;::max()/sizeof(value_type)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='select_on_container_copy_construction,allocator_traits'></a></span><span class='indexparent'><a class='index' id='allocator_traits,select_on_container_copy_construction'></a></span><code class='itemdecl'>
static Alloc select_on_container_copy_construction(const Alloc&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.traits.members-8'><div class='marginalizedparent'><a class='marginalized' href='#allocator.traits.members-8'>8</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7663'>#</a></div><p ><i>Returns:</i> <span class='texttt'>rhs.select_on_container_copy_construction()</span> if that expression is
well-formed; otherwise, <span class='texttt'>rhs</span>.
</p></div></div></div></div><div id='default.allocator'><h3 ><a class='secnum' href='#default.allocator' style='min-width:103pt'>20.10.9</a> The default allocator <a class='abbr_ref' href='default.allocator'>[default.allocator]</a></h3><div class='para' id='default.allocator-1'><div class='marginalizedparent'><a class='marginalized' href='#default.allocator-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7670'>#</a></div><p >All specializations of the default allocator satisfy the
allocator completeness requirements <a href='allocator.requirements.completeness'>[allocator.requirements.completeness]</a>.</p><p ><span class='indexparent'><a class='index' id='allocator'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; class allocator {
   public:
    using value_type      = T;
    using propagate_on_container_move_assignment = true_type;
    using is_always_equal = true_type;

    allocator() noexcept;
    allocator(const allocator&amp;) noexcept;
    template &lt;class U&gt; allocator(const allocator&lt;U&gt;&amp;) noexcept;
   ~allocator();

    T* allocate(size_t n);
    void deallocate(T* p, size_t n);
  };
}</pre></div><div id='allocator.members'><h4 ><a class='secnum' href='#allocator.members' style='min-width:118pt'>20.10.9.1</a> <span class='texttt'>allocator</span> members <a class='abbr_ref' href='allocator.members'>[allocator.members]</a></h4><div class='para' id='allocator.members-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7696'>#</a></div><p >Except for the destructor, member functions of the default allocator shall not introduce
data races (<a href='intro.multithread'>[intro.multithread]</a>) as a result of concurrent calls to those member
functions from different threads. Calls to these functions that allocate or deallocate a
particular unit of storage shall occur in a single total order, and each such
deallocation call shall happen before the next allocation (if any) in this order.</p><p ><span class='indexparent'><a class='index' id='allocate,allocator'></a></span><span class='indexparent'><a class='index' id='allocator,allocate'></a></span><code class='itemdecl'>
T* allocate(size_t n);
</code></p></div><div class='itemdescr'></div><div class='para' id='allocator.members-2'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7709'>#</a></div><p ><i>Returns:</i>
A pointer to the initial element of an array of storage of size <span class='texttt'>n</span>
<span class='texttt'>* sizeof(T)</span>, aligned appropriately for objects of type <span class='texttt'>T</span>.</p></div></div><div class='para' id='allocator.members-3'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7714'>#</a></div><p ><i>Remarks:</i>
the storage is obtained by calling <span class='texttt'>::operator new</span> (<a href='new.delete'>[new.delete]</a>),
but it is unspecified when or how often this
function is called.</p></div></div><div class='para' id='allocator.members-4'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7720'>#</a></div><p ><i>Throws:</i>
<span class='texttt'>bad_alloc</span> if the storage cannot be obtained.
</p></div></div><p ><span class='indexparent'><a class='index' id='deallocate,allocator'></a></span><span class='indexparent'><a class='index' id='allocator,deallocate'></a></span><code class='itemdecl'>
void deallocate(T* p, size_t n);
</code></p><div class='itemdescr'></div><div class='para' id='allocator.members-5'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7731'>#</a></div><p ><i>Requires:</i>
<span class='texttt'>p</span> shall be a pointer value obtained from <span class='texttt'>allocate()</span>.
<span class='texttt'>n</span> shall equal the value passed as the first argument
to the invocation of allocate which returned <span class='texttt'>p</span>.</p></div></div><div class='para' id='allocator.members-6'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7737'>#</a></div><p ><i>Effects:</i>
Deallocates the storage referenced by <span class='texttt'>p</span> .</p></div></div><div class='para' id='allocator.members-7'><div class='marginalizedparent'><a class='marginalized' href='#allocator.members-7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7741'>#</a></div><p ><i>Remarks:</i>
Uses
<span class='texttt'>::operator delete</span> (<a href='new.delete'>[new.delete]</a>),
but it is unspecified
when this function is called.
</p></div></div></div><div id='allocator.globals'><h4 ><a class='secnum' href='#allocator.globals' style='min-width:118pt'>20.10.9.2</a> <span class='texttt'>allocator</span> globals <a class='abbr_ref' href='allocator.globals'>[allocator.globals]</a></h4><p ><span class='indexparent'><a class='index' id='operator==,allocator'></a></span><span class='indexparent'><a class='index' id='allocator,operator=='></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
  bool operator==(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.globals-1'><div class='marginalizedparent'><a class='marginalized' href='#allocator.globals-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7758'>#</a></div><p ><i>Returns:</i>
<span class='texttt'>true</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,allocator'></a></span><span class='indexparent'><a class='index' id='allocator,operator!='></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
  bool operator!=(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='allocator.globals-2'><div class='marginalizedparent'><a class='marginalized' href='#allocator.globals-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7770'>#</a></div><p ><i>Returns:</i>
<span class='texttt'>false</span>.
</p></div></div></div></div><div id='specialized.algorithms'><h3 ><a class='secnum' href='#specialized.algorithms' style='min-width:103pt'>20.10.10</a> Specialized algorithms <a class='abbr_ref' href='specialized.algorithms'>[specialized.algorithms]</a></h3><div class='para' id='specialized.algorithms-1'><div class='marginalizedparent'><a class='marginalized' href='#specialized.algorithms-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7777'>#</a></div><p >Throughout this subclause,
the names of template parameters are used to express type requirements.
</p><ul class='itemize'><li id='specialized.algorithms-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#specialized.algorithms-1.1'>(1.1)</a></div><p >If an algorithm's template parameter is named <span class='texttt'>InputIterator</span>,
the template argument shall satisfy the requirements
of an input iterator (<a href='input.iterators'>[input.iterators]</a>).
</p></li><li id='specialized.algorithms-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#specialized.algorithms-1.2'>(1.2)</a></div><p >If an algorithm's template parameter is named <span class='texttt'>ForwardIterator</span>,
the template argument shall satisfy the requirements
of a forward iterator (<a href='forward.iterators'>[forward.iterators]</a>), and
is required to have the property that no exceptions are thrown
from increment, assignment, comparison, or indirection through valid iterators.
</p></li></ul><p >Unless otherwise specified,
if an exception is thrown in the following algorithms there are no effects.</p></div><div id='specialized.addressof'><h4 ><a class='secnum' href='#specialized.addressof' style='min-width:118pt'>20.10.10.1</a> <span class='texttt'>addressof</span> <a class='abbr_ref' href='specialized.addressof'>[specialized.addressof]</a></h4><p ><span class='indexparent'><a class='index' id='addressof'></a></span><code class='itemdecl'>
template &lt;class T&gt; constexpr T* addressof(T&amp; r) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='specialized.addressof-1'><div class='marginalizedparent'><a class='marginalized' href='#specialized.addressof-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7803'>#</a></div><p ><i>Returns:</i> The actual address of the object or function referenced by <span class='texttt'>r</span>, even in the
presence of an overloaded <span class='texttt'>operator&amp;</span>.</p></div></div><div class='para' id='specialized.addressof-2'><div class='marginalizedparent'><a class='marginalized' href='#specialized.addressof-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7807'>#</a></div><p ><i>Remarks:</i> An expression <span class='texttt'>addressof(E)</span>
is a constant subexpression (<a href='defns.const.subexpr'>[defns.const.subexpr]</a>)
if <span class='texttt'>E</span> is an lvalue constant subexpression.
</p></div></div></div><div id='uninitialized.construct.default'><h4 ><a class='secnum' href='#uninitialized.construct.default' style='min-width:118pt'>20.10.10.2</a> <span class='texttt'>uninitialized_default_construct</span> <a class='abbr_ref' href='uninitialized.construct.default'>[uninitialized.construct.default]</a></h4><p ><span class='indexparent'><a class='index' id='uninitialized_default_construct'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator&gt;
  void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
</code></p><div class='itemdescr'></div><div class='para' id='uninitialized.construct.default-1'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.construct.default-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7822'>#</a></div><p ><i>Effects:</i>
Equivalent to:
</p><pre class='codeblock'>
for (; first != last; ++first)
  ::new (static_cast&lt;void*&gt;(addressof(*first)))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type;</pre></div></div><p ><span class='indexparent'><a class='index' id='uninitialized_default_construct_n'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator, class Size&gt;
  ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);
</code></p><div class='itemdescr'></div><div class='para' id='uninitialized.construct.default-2'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.construct.default-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7839'>#</a></div><p ><i>Effects:</i>
Equivalent to:
</p><pre class='codeblock'>
for (; n&gt;0; (void)++first, --n)
  ::new (static_cast&lt;void*&gt;(addressof(*first)))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type;
return first;</pre></div></div></div><div id='uninitialized.construct.value'><h4 ><a class='secnum' href='#uninitialized.construct.value' style='min-width:118pt'>20.10.10.3</a> <span class='texttt'>uninitialized_value_construct</span> <a class='abbr_ref' href='uninitialized.construct.value'>[uninitialized.construct.value]</a></h4><p ><span class='indexparent'><a class='index' id='uninitialized_value_construct'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator&gt;
  void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
</code></p><div class='itemdescr'></div><div class='para' id='uninitialized.construct.value-1'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.construct.value-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7859'>#</a></div><p ><i>Effects:</i>
Equivalent to:
</p><pre class='codeblock'>
for (; first != last; ++first)
  ::new (static_cast&lt;void*&gt;(addressof(*first)))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type();</pre></div></div><p ><span class='indexparent'><a class='index' id='uninitialized_value_construct_n'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator, class Size&gt;
  ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);
</code></p><div class='itemdescr'></div><div class='para' id='uninitialized.construct.value-2'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.construct.value-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7876'>#</a></div><p ><i>Effects:</i>
Equivalent to:
</p><pre class='codeblock'>
for (; n&gt;0; (void)++first, --n)
  ::new (static_cast&lt;void*&gt;(addressof(*first)))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type();
return first;</pre></div></div></div><div id='uninitialized.copy'><h4 ><a class='secnum' href='#uninitialized.copy' style='min-width:118pt'>20.10.10.4</a> <span class='texttt'>uninitialized_copy</span> <a class='abbr_ref' href='uninitialized.copy'>[uninitialized.copy]</a></h4><p ><span class='indexparent'><a class='index' id='uninitialized_copy'></a></span><code class='itemdecl'>
template &lt;class InputIterator, class ForwardIterator&gt;
  ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                     ForwardIterator result);
</code></p><div class='itemdescr'></div><div class='para' id='uninitialized.copy-1'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.copy-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7897'>#</a></div><p ><i>Effects:</i>
As if by:
</p><pre class='codeblock'>
for (; first != last; ++result, (void) ++first)
  ::new (static_cast&lt;void*&gt;(addressof(*result)))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(*first);</pre></div></div><div class='para' id='uninitialized.copy-2'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.copy-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7906'>#</a></div><p ><i>Returns:</i>
<span class='texttt'>result</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='uninitialized_copy_n'></a></span><code class='itemdecl'>
template &lt;class InputIterator, class Size, class ForwardIterator&gt;
  ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                       ForwardIterator result);
</code></p><div class='itemdescr'></div><div class='para' id='uninitialized.copy-3'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.copy-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7919'>#</a></div><p ><i>Effects:</i>
As if by:
</p><pre class='codeblock'>
for ( ; n &gt; 0; ++result, (void) ++first, --n) {
  ::new (static_cast&lt;void*&gt;(addressof(*result)))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(*first);
}</pre></div></div><div class='para' id='uninitialized.copy-4'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.copy-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7929'>#</a></div><p ><i>Returns:</i> <span class='texttt'>result</span>.
</p></div></div></div><div id='uninitialized.move'><h4 ><a class='secnum' href='#uninitialized.move' style='min-width:118pt'>20.10.10.5</a> <span class='texttt'>uninitialized_move</span> <a class='abbr_ref' href='uninitialized.move'>[uninitialized.move]</a></h4><p ><span class='indexparent'><a class='index' id='uninitialized_move'></a></span><code class='itemdecl'>
template &lt;class InputIterator, class ForwardIterator&gt;
  ForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                     ForwardIterator result);
</code></p><div class='itemdescr'></div><div class='para' id='uninitialized.move-1'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.move-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7943'>#</a></div><p ><i>Effects:</i>
Equivalent to:
</p><pre class='codeblock'>
for (; first != last; (void)++result, ++first)
  ::new (static_cast&lt;void*&gt;(addressof(*result)))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(std::move(*first));
return result;</pre></div></div><div class='para' id='uninitialized.move-2'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.move-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7953'>#</a></div><p ><i>Remarks:</i>
If an exception is thrown, some objects in the range <span class='texttt'>[first, last)</span>
are left in a valid but unspecified state.
</p></div></div><p ><span class='indexparent'><a class='index' id='uninitialized_move_n'></a></span><code class='itemdecl'>
template &lt;class InputIterator, class Size, class ForwardIterator&gt;
  pair&lt;InputIterator, ForwardIterator&gt;
    uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);
</code></p><div class='itemdescr'></div><div class='para' id='uninitialized.move-3'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.move-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7967'>#</a></div><p ><i>Effects:</i>
Equivalent to:
</p><pre class='codeblock'>
for (; n &gt; 0; ++result, (void) ++first, --n)
  ::new (static_cast&lt;void*&gt;(addressof(*result)))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(std::move(*first));
return {first,result};</pre></div></div><div class='para' id='uninitialized.move-4'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.move-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7977'>#</a></div><p ><i>Remarks:</i>
If an exception is thrown, some objects in the range <span class='texttt'>[first, std::next(first,n))</span>
are left in a valid but unspecified state.
</p></div></div></div><div id='uninitialized.fill'><h4 ><a class='secnum' href='#uninitialized.fill' style='min-width:118pt'>20.10.10.6</a> <span class='texttt'>uninitialized_fill</span> <a class='abbr_ref' href='uninitialized.fill'>[uninitialized.fill]</a></h4><p ><span class='indexparent'><a class='index' id='uninitialized_fill'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator, class T&gt;
  void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                          const T&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='uninitialized.fill-1'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.fill-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L7993'>#</a></div><p ><i>Effects:</i>
As if by:
</p><pre class='codeblock'>
for (; first != last; ++first)
  ::new (static_cast&lt;void*&gt;(addressof(*first)))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(x);</pre></div></div><p ><span class='indexparent'><a class='index' id='uninitialized_fill_n'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator, class Size, class T&gt;
  ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='uninitialized.fill-2'><div class='marginalizedparent'><a class='marginalized' href='#uninitialized.fill-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L8010'>#</a></div><p ><i>Effects:</i>
As if by:
</p><pre class='codeblock'>
for (; n--; ++first)
  ::new (static_cast&lt;void*&gt;(addressof(*first)))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(x);
return first;</pre></div></div></div><div id='specialized.destroy'><h4 ><a class='secnum' href='#specialized.destroy' style='min-width:118pt'>20.10.10.7</a> <span class='texttt'>destroy</span> <a class='abbr_ref' href='specialized.destroy'>[specialized.destroy]</a></h4><p ><span class='indexparent'><a class='index' id='destroy_at'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  void destroy_at(T* location);
</code></p><div class='itemdescr'></div><div class='para' id='specialized.destroy-1'><div class='marginalizedparent'><a class='marginalized' href='#specialized.destroy-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L8030'>#</a></div><p ><i>Effects:</i>
Equivalent to:
</p><pre class='codeblock'>
location-&gt;~T();</pre></div></div><p ><span class='indexparent'><a class='index' id='destroy'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator&gt;
  void destroy(ForwardIterator first, ForwardIterator last);
</code></p><div class='itemdescr'></div><div class='para' id='specialized.destroy-2'><div class='marginalizedparent'><a class='marginalized' href='#specialized.destroy-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L8045'>#</a></div><p ><i>Effects:</i>
Equivalent to:
</p><pre class='codeblock'>
for (; first!=last; ++first)
  destroy_at(addressof(*first));</pre></div></div><p ><span class='indexparent'><a class='index' id='destroy_n'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator, class Size&gt;
  ForwardIterator destroy_n(ForwardIterator first, Size n);
</code></p><div class='itemdescr'></div><div class='para' id='specialized.destroy-3'><div class='marginalizedparent'><a class='marginalized' href='#specialized.destroy-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L8061'>#</a></div><p ><i>Effects:</i>
Equivalent to:
</p><pre class='codeblock'>
for (; n &gt; 0; (void)++first, --n)
  destroy_at(addressof(*first));
return first;</pre></div></div></div></div><div id='c.malloc'><h3 ><a class='secnum' href='#c.malloc' style='min-width:103pt'>20.10.11</a> C library memory allocation <a class='abbr_ref' href='c.malloc'>[c.malloc]</a></h3><div class='para' id='c.malloc-1'><div class='marginalizedparent'><a class='marginalized' href='#c.malloc-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L8073'>#</a></div><p ><span class='indexparent'><a class='index' id='cstdlib'></a></span>[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
The header <span class='texttt'>&lt;cstdlib&gt;</span> (<a href='cstdlib.syn'>[cstdlib.syn]</a>)
declares the functions described in this subclause.
<i><span style='white-space:nowrap'>&thinsp;</span>â€”<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p><p ><span class='indexparent'><a class='index' id='aligned_alloc'></a></span><span class='indexparent'><a class='index' id='calloc'></a></span><span class='indexparent'><a class='index' id='malloc'></a></span><span class='indexparent'><a class='index' id='realloc'></a></span><code class='itemdecl'>
void* aligned_alloc(size_t alignment, size_t size);
void* calloc(size_t nmemb, size_t size);
void* malloc(size_t size);
void* realloc(void* ptr, size_t size);
</code></p></div><div class='itemdescr'></div><div class='para' id='c.malloc-2'><div class='marginalizedparent'><a class='marginalized' href='#c.malloc-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L8092'>#</a></div><p ><i>Effects:</i>
These functions have the semantics specified in the C standard library.</p></div></div><div class='para' id='c.malloc-3'><div class='marginalizedparent'><a class='marginalized' href='#c.malloc-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L8096'>#</a></div><p ><i>Remarks:</i>
These functions do not attempt to allocate
storage by calling <span class='texttt'>::operator new()</span> (<a href='support.dynamic'>[support.dynamic]</a>).
<span class='indexparent'><a class='index' id='new,operator'></a></span>
</p></div></div><div class='para' id='c.malloc-4'><div class='marginalizedparent'><a class='marginalized' href='#c.malloc-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L8102'>#</a></div><p >Storage allocated directly with these functions
is implicitly declared reachable
(see <a href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a>) on allocation, ceases to be declared
reachable on deallocation, and need not cease to be declared reachable as the
result of an <span class='texttt'>undeclare_reachable()</span> call. [<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> This allows existing
C libraries to remain unaffected by restrictions on pointers that are not safely
derived, at the expense of providing far fewer garbage collection and leak
detection options for <span class='texttt'>malloc()</span>-allocated objects. It also allows
<span class='texttt'>malloc()</span> to be implemented with a separate allocation arena, bypassing
the normal <span class='texttt'>declare_reachable()</span> implementation. The above functions
should never intentionally be used as a replacement for
<span class='texttt'>declare_reachable()</span>, and newly written code is strongly encouraged to
treat memory allocated with these functions as though it were allocated with
<span class='texttt'>operator new</span>. <i><span style='white-space:nowrap'>&thinsp;</span>â€”<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
</p></div></div><p ><span class='indexparent'><a class='index' id='free'></a></span><code class='itemdecl'>
void free(void* ptr);
</code></p><div class='itemdescr'></div><div class='para' id='c.malloc-5'><div class='marginalizedparent'><a class='marginalized' href='#c.malloc-5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L8125'>#</a></div><p ><i>Effects:</i>
This function has the semantics specified in the C standard library.</p></div></div><div class='para' id='c.malloc-6'><div class='marginalizedparent'><a class='marginalized' href='#c.malloc-6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/utilities.tex#L8129'>#</a></div><p ><i>Remarks:</i>
This function does not attempt to
deallocate storage by calling
<span class='texttt'>::operator delete()</span><span class='indexparent'><a class='index' id='delete,operator'></a></span>.
</p></div></div><p ><span class='textsc'>See also:</span> ISO C 7.22.3.</p></div></div></div></body></html>