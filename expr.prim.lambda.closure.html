<!DOCTYPE html><html lang='en'><head><title>[expr.prim.lambda.closure]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>8.1</a> Primary expressions <a class='abbr_ref' href='expr.prim#lambda.closure'>[expr.prim]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>8.1.5</a> Lambda expressions <a class='abbr_ref' href='expr.prim.lambda#closure'>[expr.prim.lambda]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>8.1.5.1</a> Closure types <a class='abbr_ref'>[expr.prim.lambda.closure]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L662'>#</a></div><p >The type of a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> (which is also the type of the
closure object) is a unique, unnamed non-union class type,
called the <a class='hidden_link' href='#def:closure_type' id='def:closure_type'><i >closure type</i></a>,
whose properties are described below.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L668'>#</a></div><p >The closure type is declared in the smallest block
scope, class scope, or namespace scope that contains the corresponding
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  This determines the set of namespaces and
classes associated with the closure type (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>). The parameter
types of a <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i> do not affect these associated namespaces and
classes. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]  The closure type is not an aggregate type (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>).
An implementation may define the closure type differently from what
is described below provided this does not alter the observable behavior of the program
other than by changing:</p><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><p >the size and/or alignment of the closure type,</p></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><p >whether the closure type is <a href='class#def:trivially_copyable_class'>trivially copyable</a>,</p></li><li id='2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.3'>(2.3)</a></div><p >whether the closure type is a <a href='class#def:standard-layout_class'>standard-layout class</a>,
or</p></li><li id='2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.4'>(2.4)</a></div><p >whether the closure type is a <a href='class#def:POD_class'>POD class</a>.
</p></li></ul><p >An implementation shall not add members of rvalue reference type to the closure
type.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L693'>#</a></div><p >The closure type for a non-generic <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> has a public
inline <a href='over.call'>function call operator</a> whose parameters and return type
are described by the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> and <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i>
respectively.
For a generic lambda, the closure type has a public inline function call
operator <a href='temp.mem'>member template</a> whose
<i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i> consists of one invented type
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> for each occurrence of <span class='texttt'>auto</span> in the
lambda's <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i>, in order of appearance.
The invented type <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> is a parameter pack if
the corresponding <i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> declares a function
parameter pack (<a href='dcl.fct'>[dcl.fct]</a>). The return type and function parameters of the
function call operator template are derived from the
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> and
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> by replacing each occurrence of
<span class='texttt'>auto</span> in the <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i><span class='textit'>s</span> of the
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> with the name of the corresponding
invented <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
auto glambda = [](auto a, auto&amp;&amp; b) { return a &lt; b; };
bool b = glambda(3, 3.14);                             <span class='comment'>// OK
</span>
auto vglambda = [](auto printer) {
  return [=](auto&amp;&amp; ... ts) {                          <span class='comment'>// OK: <span class='tcode_in_codeblock'>ts</span> is a function parameter pack
</span>    printer(std::forward&lt;decltype(ts)&gt;(ts)...);

    return [=]() {
      printer(ts ...);
    };
  };
};
auto p = vglambda( [](auto v1, auto v2, auto v3)
                   { std::cout &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; v3; } );
auto q = p(1, 'a', 3.14);                              <span class='comment'>// OK: outputs <span class='tcode_in_codeblock'>1a3.14</span>
</span>q();                                                   <span class='comment'>// OK: outputs <span class='tcode_in_codeblock'>1a3.14</span>
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L734'>#</a></div><p >The function call operator or operator template is declared
<span class='texttt'>const</span> (<a href='class.mfct.non-static'>[class.mfct.non-static]</a>) if and only if the
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> is not
followed by <span class='texttt'>mutable</span>. It is neither virtual nor declared <span class='texttt'>volatile</span>. Any
<i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i> specified on a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>
applies to the corresponding function call operator or operator template.
An <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i> appertains
to the type of the corresponding function call operator or operator template.
The function call operator or any given operator template specialization
is a constexpr function if either
the corresponding <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> is followed by <span class='texttt'>constexpr</span>, or
it satisfies the requirements for a <a href='dcl.constexpr'>constexpr</a> function.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  Names referenced in
the <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i> are looked up in the context in which the
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> appears. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
auto ID = [](auto a) { return a; };
static_assert(ID(3) == 3); <span class='comment'>// OK
</span>
struct NonLiteral {
  NonLiteral(int n) : n(n) { }
  int n;
};
static_assert(ID(NonLiteral{3}).n == 3); <span class='comment'>// ill-formed
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L764'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
auto monoid = [](auto v) { return [=] { return v; }; };
auto add = [](auto m1) constexpr {
  auto ret = m1();
  return [=](auto m2) mutable {
    auto m1val = m1();
    auto plus = [=](auto m2val) mutable constexpr
                   { return m1val += m2val; };
    ret = plus(m2());
    return monoid(ret);
  };
};
constexpr auto zero = monoid(0);
constexpr auto one = monoid(1);
static_assert(add(one)(zero)() == one()); <span class='comment'>// OK
</span>
<span class='comment'>// Since <span class='tcode_in_codeblock'>two</span> below is not declared <span class='tcode_in_codeblock'>constexpr</span>, an evaluation of its <span class='tcode_in_codeblock'>constexpr</span> member function call operator
</span><span class='comment'>// cannot perform an lvalue-to-rvalue conversion on one of its subobjects (that represents its capture)
</span><span class='comment'>// in a constant expression.
</span>auto two = monoid(2);
assert(two() == 2); <span class='comment'>// OK, not a constant expression.
</span>static_assert(add(one)(one)() == two()); <span class='comment'>// ill-formed: <span class='tcode_in_codeblock'>two()</span> is not a constant expression
</span>static_assert(add(one)(one)() == monoid(2)()); <span class='comment'>// OK
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L792'>#</a></div><p >The closure type for a non-generic <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> with no
<i ><a href='expr.prim.lambda.capture#nt:lambda-capture'>lambda-capture</a></i>
has a conversion function to pointer to
function with C++ language <a href='dcl.link'>linkage</a> having
the same parameter and return types as the closure type's function call operator.
The conversion is to “pointer to <span class='texttt'>noexcept</span> function”
if the function call operator
has a non-throwing exception specification.
The value returned by this conversion function
is the address of a function <span class='texttt'>F</span> that, when invoked,
has the same effect as invoking the closure type's function call operator.
<span class='texttt'>F</span> is a constexpr function
if the function call operator is a constexpr function.
For a generic lambda with no <i ><a href='expr.prim.lambda.capture#nt:lambda-capture'>lambda-capture</a></i>, the closure type has a
conversion function template to
pointer to function. The conversion function template has the same invented
<i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i>, and the pointer to function has the same
parameter types, as the function call operator template.  The return type of
the pointer to function shall behave as if it were a
<i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> denoting the return type of the corresponding
function call operator template specialization.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L815'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
If the generic lambda has no <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> or
the <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> contains a placeholder type, return type
deduction of the corresponding function call operator template specialization
has to be done. The corresponding specialization is that instantiation of the
function call operator template with the same template arguments as those
deduced for the conversion function template.  Consider the following:
</p><pre class='codeblock'>
auto glambda = [](auto a) { return a; };
int (*fp)(int) = glambda;</pre><p >The behavior of the conversion function of <span class='texttt'>glambda</span> above is like
that of the following conversion function:
</p><pre class='codeblock'>
struct Closure {
  template&lt;class T&gt; auto operator()(T t) const { ... }
  template&lt;class T&gt; static auto lambda_call_operator_invoker(T a) {
    <span class='comment'>// forwards execution to <span class='tcode_in_codeblock'>operator()(a)</span> and therefore has
</span>    <span class='comment'>// the same return type deduced
</span>    ...
  }
  template&lt;class T&gt; using fptr_t =
     decltype(lambda_call_operator_invoker(declval&lt;T&gt;())) (*)(T);

  template&lt;class T&gt; operator fptr_t&lt;T&gt;() const
    { return &amp;lambda_call_operator_invoker; }
};</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
void f1(int (*)(int))   { }
void f2(char (*)(int))  { }

void g(int (*)(int))    { }  <span class='comment'>// #1
</span>void g(char (*)(char))  { }  <span class='comment'>// #2
</span>
void h(int (*)(int))    { }  <span class='comment'>// #3
</span>void h(char (*)(int))   { }  <span class='comment'>// #4
</span>
auto glambda = [](auto a) { return a; };
f1(glambda);  <span class='comment'>// OK
</span>f2(glambda);  <span class='comment'>// error: ID is not convertible
</span>g(glambda);   <span class='comment'>// error: ambiguous
</span>h(glambda);   <span class='comment'>// OK: calls #3 since it is convertible from ID
</span>int&amp; (*fpi)(int*) = [](auto* a) -&gt; auto&amp; { return *a; }; <span class='comment'>// OK
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L866'>#</a></div><p >The value returned by any given specialization of this conversion function
template is the address of a function <span class='texttt'>F</span> that, when invoked, has the same
effect as invoking the generic lambda's corresponding function call operator
template specialization.
<span class='texttt'>F</span> is a constexpr function
if the corresponding specialization is a constexpr function.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
This will result in the implicit instantiation of the generic lambda's body.
The instantiated generic lambda's return type and parameter types shall match
the return type and parameter types of the pointer to function.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
auto GL = [](auto a) { std::cout &lt;&lt; a; return a; };
int (*GL_int)(int) = GL;  <span class='comment'>// OK: through conversion function template
</span>GL_int(3);                <span class='comment'>// OK: same as <span class='tcode_in_codeblock'>GL(3)</span>
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L886'>#</a></div><p >The conversion function or conversion function template is public,
constexpr, non-virtual, non-explicit, const, and has a non-throwing <a href='except.spec'>exception
specification</a>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
auto Fwd = [](int (*fp)(int), auto a) { return fp(a); };
auto C = [](auto a) { return a; };

static_assert(Fwd(C,3) == 3); <span class='comment'>// OK
</span>
<span class='comment'>// No specialization of the function call operator template can be constexpr (due to the local static).
</span>auto NC = [](auto a) { static int s; return a; };
static_assert(Fwd(NC,3) == 3); <span class='comment'>// ill-formed
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L903'>#</a></div><p >The <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> yields the
<i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> (<a href='dcl.fct.def'>[dcl.fct.def]</a>) of the function call operator, but for
purposes of <a href='basic.lookup'>name lookup</a>, determining the type and value of
<a href='class.this'><span class='texttt'>this</span></a> and transforming <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i><span class='textit'>s</span>
referring to non-static class members into class member access expressions using
<span class='texttt'>(*this)</span> (<a href='class.mfct.non-static'>[class.mfct.non-static]</a>), the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> is
considered in the context of the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> </p><pre class='codeblock'>
struct S1 {
  int x, y;
  int operator()(int);
  void f() {
    [=]()-&gt;int {
      return operator()(this-&gt;x + y); <span class='comment'>// equivalent to <span class='tcode_in_codeblock'>S1&#x200b;::&#x200b;operator()(this-&gt;x + (*this).y)</span>
</span>                                      <span class='comment'>// <span class='tcode_in_codeblock'>this</span> has type <span class='tcode_in_codeblock'>S1*</span>
</span>    };
  }
};</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] 
Further, a variable <span class='texttt'>_&shy;_&shy;func_&shy;_&shy;</span> is implicitly defined at the beginning of
the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> of the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>,
with semantics as described in <a href='dcl.fct.def.general'>[dcl.fct.def.general]</a>.</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L929'>#</a></div><p >The closure type associated with a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> has no
default constructor and a deleted copy assignment operator. It has a
defaulted copy constructor and a defaulted move constructor (<a href='class.copy'>[class.copy]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  These special member functions are implicitly defined as
usual, and might therefore be defined as deleted. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L936'>#</a></div><p >The closure type associated with a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> has an
implicitly-declared destructor (<a href='class.dtor'>[class.dtor]</a>).</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/expressions.tex#L940'>#</a></div><p >A member of a closure type shall not be
explicitly instantiated (<a href='temp.explicit'>[temp.explicit]</a>),
explicitly specialized (<a href='temp.expl.spec'>[temp.expl.spec]</a>), or
named in a <span class='texttt'>friend</span> declaration (<a href='class.friend'>[class.friend]</a>).</p></div></div></body></html>