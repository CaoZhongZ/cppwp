<!DOCTYPE html><html lang='en'><head><title>[expr.prim.lambda.closure]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>8.4</a> Primary expressions <a class='abbr_ref' href='expr.prim#lambda.closure'>[expr.prim]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>8.4.5</a> Lambda expressions <a class='abbr_ref' href='expr.prim.lambda#closure'>[expr.prim.lambda]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>8.4.5.1</a> Closure types <a class='abbr_ref'>[expr.prim.lambda.closure]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/expressions.tex#L915'>#</a></div><div id='1.sentence-1' class='sentence'>The type of a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> (which is also the type of the
closure object) is a unique, unnamed non-union class type,
called the <a class='hidden_link' href='#def:closure_type' id='def:closure_type'><i >closure type</i></a>,
whose properties are described below<a class='hidden_link' href='#1.sentence-1'>.</a></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/expressions.tex#L921'>#</a></div><div id='2.sentence-1' class='sentence'>The closure type is declared in the smallest block
scope, class scope, or namespace scope that contains the corresponding
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i><a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#2.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='2.sentence-4' class='sentence'>This determines the set of namespaces and
classes associated with the closure type (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>)<a class='hidden_link' href='#2.sentence-4'>.</a></div> <div id='2.sentence-5' class='sentence'>The parameter
types of a <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i> do not affect these associated namespaces and
classes<a class='hidden_link' href='#2.sentence-5'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='2.sentence-2' class='sentence'> The closure type is not an <a href='dcl.init.aggr#def:aggregate'>aggregate</a> type<a class='hidden_link' href='#2.sentence-2'>.</a></div> <div id='2.sentence-3' class='sentence'>An implementation may define the closure type differently from what
is described below provided this does not alter the observable behavior of the program
other than by changing:</div><div id='2.sentence-6' class='sentence'><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><div id='2.1.sentence-1' class='sentence'>the size and/or alignment of the closure type,</div></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><div id='2.2.sentence-1' class='sentence'>whether the closure type is <a href='class#def:trivially_copyable'>trivially copyable</a>, or</div></li><li id='2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.3'>(2.3)</a></div><div id='2.3.sentence-1' class='sentence'>whether the closure type is a <a href='class#def:standard-layout_class'>standard-layout class</a><a class='hidden_link' href='#2.3.sentence-1'>.</a></div></li></ul></div><div id='2.sentence-7' class='sentence'>An implementation shall not add members of rvalue reference type to the closure
type<a class='hidden_link' href='#2.sentence-7'>.</a></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/expressions.tex#L943'>#</a></div><div id='3.sentence-1' class='sentence'>The closure type for a non-generic <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> has a public
inline <a href='over.call'>function call operator</a> whose parameters and return type
are described by the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> and <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i>
respectively<a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.sentence-2' class='sentence'>For a generic lambda, the closure type has a public inline function call
operator <a href='temp.mem'>member template</a> whose
<i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i> consists of
the specified <i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i>, if any,
to which is appended one invented type
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> for each occurrence of <span class='texttt'>auto</span> in the
lambda's <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i>, in order of appearance<a class='hidden_link' href='#3.sentence-2'>.</a></div> <div id='3.sentence-3' class='sentence'>The invented type <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> is a template parameter pack if
the corresponding <i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> declares a function
parameter pack (<a href='dcl.fct'>[dcl.fct]</a>)<a class='hidden_link' href='#3.sentence-3'>.</a></div> <div id='3.sentence-4' class='sentence'>The return type and function parameters of the
function call operator template are derived from the
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> and
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> by replacing each occurrence of
<span class='texttt'>auto</span> in the <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i><span class='textit'>s</span> of the
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> with the name of the corresponding
invented <i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i><a class='hidden_link' href='#3.sentence-4'>.</a></div> <div id='3.sentence-5' class='sentence'>The <i ><a href='temp#nt:requires-clause'>requires-clause</a></i> of the function call operator template
is the <i ><a href='temp#nt:requires-clause'>requires-clause</a></i> immediately following
<span class='texttt'>&lt;</span> <i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i> <span class='texttt'>&gt;</span>, if any<a class='hidden_link' href='#3.sentence-5'>.</a></div> <div id='3.sentence-6' class='sentence'>The trailing <i ><a href='temp#nt:requires-clause'>requires-clause</a></i> of the function call operator
or operator template is the <i ><a href='temp#nt:requires-clause'>requires-clause</a></i>
following the <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i>, if any<a class='hidden_link' href='#3.sentence-6'>.</a></div> <div id='3.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#3.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
auto glambda = [](auto a, auto&amp;&amp; b) { return a &lt; b; };
bool b = glambda(3, 3.14);                             <span class='comment'>// OK
</span>
auto vglambda = [](auto printer) {
  return [=](auto&amp;&amp; ... ts) {                          <span class='comment'>// OK: <span class='tcode_in_codeblock'>ts</span> is a function parameter pack
</span>    printer(std::forward&lt;decltype(ts)&gt;(ts)...);

    return [=]() {
      printer(ts ...);
    };
  };
};
auto p = vglambda( [](auto v1, auto v2, auto v3)
                   { std::cout &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; v3; } );
auto q = p(1, 'a', 3.14);                              <span class='comment'>// OK: outputs <span class='tcode_in_codeblock'>1a3.14</span>
</span>q();                                                   <span class='comment'>// OK: outputs <span class='tcode_in_codeblock'>1a3.14</span>
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/expressions.tex#L992'>#</a></div><div id='4.sentence-1' class='sentence'>The function call operator or operator template is declared
<span class='texttt'>const</span> (<a href='class.mfct.non-static'>[class.mfct.non-static]</a>) if and only if the
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s <i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> is not
followed by <span class='texttt'>mutable</span><a class='hidden_link' href='#4.sentence-1'>.</a></div> <div id='4.sentence-2' class='sentence'>It is neither virtual nor declared <span class='texttt'>volatile</span><a class='hidden_link' href='#4.sentence-2'>.</a></div> <div id='4.sentence-3' class='sentence'>Any
<i ><a href='except.spec#nt:noexcept-specifier'>noexcept-specifier</a></i> specified on a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>
applies to the corresponding function call operator or operator template<a class='hidden_link' href='#4.sentence-3'>.</a></div> <div id='4.sentence-4' class='sentence'>An <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i> appertains
to the type of the corresponding function call operator or operator template<a class='hidden_link' href='#4.sentence-4'>.</a></div> <div id='4.sentence-5' class='sentence'>The function call operator or any given operator template specialization
is a constexpr function if either
the corresponding <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s
<i ><a href='dcl.fct#nt:parameter-declaration-clause'>parameter-declaration-clause</a></i> is followed by <span class='texttt'>constexpr</span>, or
it satisfies the requirements for a <a href='dcl.constexpr'>constexpr</a> function<a class='hidden_link' href='#4.sentence-5'>.</a></div> <div id='4.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#4.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='4.sentence-6' class='sentence'>Names referenced in
the <i ><a href='expr.prim.lambda#nt:lambda-declarator'>lambda-declarator</a></i> are looked up in the context in which the
<i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> appears<a class='hidden_link' href='#4.sentence-6'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='4.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#4.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
auto ID = [](auto a) { return a; };
static_assert(ID(3) == 3); <span class='comment'>// OK
</span>
struct NonLiteral {
  NonLiteral(int n) : n(n) { }
  int n;
};
static_assert(ID(NonLiteral{3}).n == 3); <span class='comment'>// ill-formed
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/expressions.tex#L1022'>#</a></div><div id='5.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#5.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
auto monoid = [](auto v) { return [=] { return v; }; };
auto add = [](auto m1) constexpr {
  auto ret = m1();
  return [=](auto m2) mutable {
    auto m1val = m1();
    auto plus = [=](auto m2val) mutable constexpr
                   { return m1val += m2val; };
    ret = plus(m2());
    return monoid(ret);
  };
};
constexpr auto zero = monoid(0);
constexpr auto one = monoid(1);
static_assert(add(one)(zero)() == one()); <span class='comment'>// OK
</span>
<span class='comment'>// Since <span class='tcode_in_codeblock'>two</span> below is not declared <span class='tcode_in_codeblock'>constexpr</span>, an evaluation of its <span class='tcode_in_codeblock'>constexpr</span> member function call operator
</span><span class='comment'>// cannot perform an lvalue-to-rvalue conversion on one of its subobjects (that represents its capture)
</span><span class='comment'>// in a constant expression.
</span>auto two = monoid(2);
assert(two() == 2); <span class='comment'>// OK, not a constant expression.
</span>static_assert(add(one)(one)() == two()); <span class='comment'>// ill-formed: <span class='tcode_in_codeblock'>two()</span> is not a constant expression
</span>static_assert(add(one)(one)() == monoid(2)()); <span class='comment'>// OK
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/expressions.tex#L1050'>#</a></div><div id='6.sentence-1' class='sentence'>The function call operator or operator template may be <a href='temp.constr.decl'>constrained</a>
by a <i ><a href='temp.param#nt:constrained-parameter'>constrained-parameter</a></i>, a <i ><a href='temp#nt:requires-clause'>requires-clause</a></i>,
or a trailing <i ><a href='temp#nt:requires-clause'>requires-clause</a></i> (<a href='dcl.decl'>[dcl.decl]</a>)<a class='hidden_link' href='#6.sentence-1'>.</a></div> <div id='6.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#6.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
template &lt;typename T&gt; concept C1 = <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span>;
template &lt;std::size_t N&gt; concept C2 = <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span>;
template &lt;typename A, typename B&gt; concept C3 = <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span>;

auto f = []&lt;typename T1, C1 T2&gt; requires C2&lt;sizeof(T1) + sizeof(T2)&gt;
         (T1 a1, T1 b1, T2 a2, auto a3, auto a4) requires C3&lt;decltype(a4), T2&gt; {
  <span class='comment'>// <span class='tcode_in_codeblock'>T2</span> is a constrained parameter,
</span>  <span class='comment'>// <span class='tcode_in_codeblock'>T1</span> and <span class='tcode_in_codeblock'>T2</span> are constrained by a <span class='grammarterm'>requires-clause</span>, and
</span>  <span class='comment'>// <span class='tcode_in_codeblock'>T2</span> and the type of <span class='tcode_in_codeblock'>a4</span> are constrained by a trailing <span class='grammarterm'>requires-clause</span>.
</span>};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/expressions.tex#L1069'>#</a></div><div id='7.sentence-1' class='sentence'>The closure type for a non-generic <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> with no
<i ><a href='expr.prim.lambda.capture#nt:lambda-capture'>lambda-capture</a></i>
whose constraints (if any) are satisfied
has a conversion function to pointer to
function with C++ language <a href='dcl.link'>linkage</a> having
the same parameter and return types as the closure type's function call operator<a class='hidden_link' href='#7.sentence-1'>.</a></div> <div id='7.sentence-2' class='sentence'>The conversion is to “pointer to <span class='texttt'>noexcept</span> function”
if the function call operator
has a non-throwing exception specification<a class='hidden_link' href='#7.sentence-2'>.</a></div> <div id='7.sentence-3' class='sentence'>The value returned by this conversion function
is the address of a function <span class='texttt'>F</span> that, when invoked,
has the same effect as invoking the closure type's function call operator<a class='hidden_link' href='#7.sentence-3'>.</a></div> <div id='7.sentence-4' class='sentence'><span class='texttt'>F</span> is a constexpr function
if the function call operator is a constexpr function<a class='hidden_link' href='#7.sentence-4'>.</a></div> <div id='7.sentence-5' class='sentence'>For a generic lambda with no <i ><a href='expr.prim.lambda.capture#nt:lambda-capture'>lambda-capture</a></i>, the closure type has a
conversion function template to
pointer to function<a class='hidden_link' href='#7.sentence-5'>.</a></div> <div id='7.sentence-6' class='sentence'>The conversion function template has the same invented
template parameter list, and the pointer to function has the same
parameter types, as the function call operator template<a class='hidden_link' href='#7.sentence-6'>.</a></div> <div id='7.sentence-7' class='sentence'>The return type of
the pointer to function shall behave as if it were a
<i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> denoting the return type of the corresponding
function call operator template specialization<a class='hidden_link' href='#7.sentence-7'>.</a></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/expressions.tex#L1093'>#</a></div><div id='8.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#8.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='8.sentence-1' class='sentence'>If the generic lambda has no <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> or
the <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> contains a placeholder type, return type
deduction of the corresponding function call operator template specialization
has to be done<a class='hidden_link' href='#8.sentence-1'>.</a></div> <div id='8.sentence-2' class='sentence'>The corresponding specialization is that instantiation of the
function call operator template with the same template arguments as those
deduced for the conversion function template<a class='hidden_link' href='#8.sentence-2'>.</a></div> <div id='8.sentence-3' class='sentence'>Consider the following:
<pre class='codeblock'>
auto glambda = [](auto a) { return a; };
int (*fp)(int) = glambda;</pre>
The behavior of the conversion function of <span class='texttt'>glambda</span> above is like
that of the following conversion function:
<pre class='codeblock'>
struct Closure {
  template&lt;class T&gt; auto operator()(T t) const { <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span> }
  template&lt;class T&gt; static auto lambda_call_operator_invoker(T a) {
    <span class='comment'>// forwards execution to <span class='tcode_in_codeblock'>operator()(a)</span> and therefore has
</span>    <span class='comment'>// the same return type deduced
</span>    <span class='tcode_in_codeblock'>/* ...&nbsp;*/</span>
  }
  template&lt;class T&gt; using fptr_t =
     decltype(lambda_call_operator_invoker(declval&lt;T&gt;())) (*)(T);

  template&lt;class T&gt; operator fptr_t&lt;T&gt;() const
    { return &amp;lambda_call_operator_invoker; }
};</pre></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> <div id='8.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#8.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
void f1(int (*)(int))   { }
void f2(char (*)(int))  { }

void g(int (*)(int))    { }  <span class='comment'>// #1
</span>void g(char (*)(char))  { }  <span class='comment'>// #2
</span>
void h(int (*)(int))    { }  <span class='comment'>// #3
</span>void h(char (*)(int))   { }  <span class='comment'>// #4
</span>
auto glambda = [](auto a) { return a; };
f1(glambda);  <span class='comment'>// OK
</span>f2(glambda);  <span class='comment'>// error: ID is not convertible
</span>g(glambda);   <span class='comment'>// error: ambiguous
</span>h(glambda);   <span class='comment'>// OK: calls #3 since it is convertible from ID
</span>int&amp; (*fpi)(int*) = [](auto* a) -&gt; auto&amp; { return *a; }; <span class='comment'>// OK
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/expressions.tex#L1144'>#</a></div><div id='9.sentence-1' class='sentence'>The value returned by any given specialization of this conversion function
template is the address of a function <span class='texttt'>F</span> that, when invoked, has the same
effect as invoking the generic lambda's corresponding function call operator
template specialization<a class='hidden_link' href='#9.sentence-1'>.</a></div> <div id='9.sentence-2' class='sentence'><span class='texttt'>F</span> is a constexpr function
if the corresponding specialization is a constexpr function<a class='hidden_link' href='#9.sentence-2'>.</a></div> <div id='9.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#9.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='9.sentence-3' class='sentence'>This will result in the implicit instantiation of the generic lambda's body<a class='hidden_link' href='#9.sentence-3'>.</a></div> <div id='9.sentence-4' class='sentence'>The instantiated generic lambda's return type and parameter types shall match
the return type and parameter types of the pointer to function<a class='hidden_link' href='#9.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='9.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#9.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
auto GL = [](auto a) { std::cout &lt;&lt; a; return a; };
int (*GL_int)(int) = GL;  <span class='comment'>// OK: through conversion function template
</span>GL_int(3);                <span class='comment'>// OK: same as <span class='tcode_in_codeblock'>GL(3)</span>
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/expressions.tex#L1164'>#</a></div><div id='10.sentence-1' class='sentence'>The conversion function or conversion function template is public,
constexpr, non-virtual, non-explicit, const, and has a non-throwing <a href='except.spec'>exception
specification</a><a class='hidden_link' href='#10.sentence-1'>.</a></div> <div id='10.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#10.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
auto Fwd = [](int (*fp)(int), auto a) { return fp(a); };
auto C = [](auto a) { return a; };

static_assert(Fwd(C,3) == 3); <span class='comment'>// OK
</span>
<span class='comment'>// No specialization of the function call operator template can be constexpr (due to the local static).
</span>auto NC = [](auto a) { static int s; return a; };
static_assert(Fwd(NC,3) == 3); <span class='comment'>// ill-formed
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/expressions.tex#L1181'>#</a></div><div id='11.sentence-1' class='sentence'>The <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>'s <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> yields the
<i ><a href='dcl.fct.def.general#nt:function-body'>function-body</a></i> (<a href='dcl.fct.def'>[dcl.fct.def]</a>) of the function call operator, but for
purposes of <a href='basic.lookup'>name lookup</a>, determining the type and value of
<a href='class.this'><span class='texttt'>this</span></a> and transforming <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i><span class='textit'>s</span>
referring to non-static class members into class member access expressions using
<span class='texttt'>(*this)</span> (<a href='class.mfct.non-static'>[class.mfct.non-static]</a>), the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> is
considered in the context of the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i><a class='hidden_link' href='#11.sentence-1'>.</a></div> <div id='11.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#11.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct S1 {
  int x, y;
  int operator()(int);
  void f() {
    [=]()-&gt;int {
      return operator()(this-&gt;x + y); <span class='comment'>// equivalent to <span class='tcode_in_codeblock'>S1&#x200b;::&#x200b;operator()(this-&gt;x + (*this).y)</span>
</span>                                      <span class='comment'>// <span class='tcode_in_codeblock'>this</span> has type <span class='tcode_in_codeblock'>S1*</span>
</span>    };
  }
};</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='11.sentence-2' class='sentence'>
Further, a variable <span class='texttt'>_&shy;_&shy;func_&shy;_&shy;</span> is implicitly defined at the beginning of
the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> of the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>,
with semantics as described in <a href='dcl.fct.def.general'>[dcl.fct.def.general]</a><a class='hidden_link' href='#11.sentence-2'>.</a></div></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/expressions.tex#L1207'>#</a></div><div id='12.sentence-1' class='sentence'>The closure type associated with a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> has no
default constructor
if the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> has a <i ><a href='expr.prim.lambda.capture#nt:lambda-capture'>lambda-capture</a></i>
and a defaulted default constructor otherwise<a class='hidden_link' href='#12.sentence-1'>.</a></div> <div id='12.sentence-2' class='sentence'>It has a defaulted copy constructor and a defaulted move constructor (<a href='class.copy'>[class.copy]</a>)<a class='hidden_link' href='#12.sentence-2'>.</a></div> <div id='12.sentence-3' class='sentence'>It has a deleted copy assignment operator if the <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>
has a <i ><a href='expr.prim.lambda.capture#nt:lambda-capture'>lambda-capture</a></i> and defaulted copy and move assignment
operators otherwise<a class='hidden_link' href='#12.sentence-3'>.</a></div> <div id='12.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#12.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='12.sentence-4' class='sentence'>These special member functions are implicitly defined as
usual, and might therefore be defined as deleted<a class='hidden_link' href='#12.sentence-4'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/expressions.tex#L1219'>#</a></div><div id='13.sentence-1' class='sentence'>The closure type associated with a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> has an
implicitly-declared destructor (<a href='class.dtor'>[class.dtor]</a>)<a class='hidden_link' href='#13.sentence-1'>.</a></div></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/04eb7aa1d517df2712d1298ed7551ebb77523483/source/expressions.tex#L1223'>#</a></div><div id='14.sentence-1' class='sentence'>A member of a closure type shall not be
<a href='temp.explicit'>explicitly instantiated</a>,
<a href='temp.expl.spec'>explicitly specialized</a>, or
named in a <a href='class.friend'>friend declaration</a><a class='hidden_link' href='#14.sentence-1'>.</a></div></div></div></body></html>