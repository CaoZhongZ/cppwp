<!DOCTYPE html><html lang='en'><head><title>[except.spec]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>15</a> Exception handling <a class='abbr_ref' href='./#except'>[except]</a></h1><div id='except.spec'><h2 ><a class='secnum' style='min-width:88pt'>15.4</a> Exception specifications <a class='abbr_ref'>[except.spec]</a></h2><p ><span class='indexparent'><a class='index' id='exception_specification'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='exception_specification,non-throwing'></a></span>The <a class='hidden_link' href='#def:exception_specification' id='def:exception_specification'><i>exception specification</i></a> of a function
is a (possibly empty) set of types,
indicating that the function might exit
via an exception
that matches a handler of one of the types in the set;
the (conceptual) set of all types is used
to denote that the function might exit
via an exception
of arbitrary type.
If the set is empty,
the function is said to have
a <a class='hidden_link' href='#def:non-throwing_exception_specification' id='def:non-throwing_exception_specification'><i>non-throwing exception specification</i></a>.
The exception specification
is either defined explicitly
by using an <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>
as a suffix of a function declaration's declarator (<a href='dcl.fct'>[dcl.fct]</a>)
or implicitly.</p><pre class='bnf'><a id='nt:exception-specification'>exception-specification:</a>
    <i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specification</a></i>
    <i ><a href='except.spec#nt:noexcept-specification'>noexcept-specification</a></i></pre><pre class='bnf'><a id='nt:dynamic-exception-specification'>dynamic-exception-specification:</a>
    <span class='terminal'>throw (</span> <i ><a href='except.spec#nt:type-id-list'>type-id-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span></pre><pre class='bnf'><a id='nt:type-id-list'>type-id-list:</a>
    <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='except.spec#nt:type-id-list'>type-id-list</a></i> <span class='terminal'>,</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:noexcept-specification'>noexcept-specification:</a>
    <span class='terminal'>noexcept</span> <span class='terminal'>(</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> <span class='terminal'>)</span>
    <span class='terminal'>noexcept</span></pre><p ><span class='indexparent'><a class='index' id='exception_specification,noexcept,constant_expression_and'></a></span>In a <i ><a href='except.spec#nt:noexcept-specification'>noexcept-specification</a></i>, the <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i>,
if supplied, shall be a contextually converted constant expression
of type <span class='texttt'>bool</span> (<a href='expr.const'>[expr.const]</a>).
A <span class='texttt'>(</span> token that follows <span class='texttt'>noexcept</span> is part of the
<i ><a href='except.spec#nt:noexcept-specification'>noexcept-specification</a></i> and does not commence an
initializer (<a href='dcl.init'>[dcl.init]</a>).</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='exception_specification,incomplete_type_and'></a></span>A type denoted
in a <i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specification</a></i>
shall not denote an incomplete type or an rvalue reference type.
A type denoted
in a <i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specification</a></i>
shall not denote a pointer or reference to an incomplete type, other than
“pointer to <i>cv</i> <span class='texttt'>void</span>”.
A type
<i>cv</i> <span class='texttt'>T</span>
denoted in a <i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specification</a></i>
is adjusted to type <span class='texttt'>T</span>.
A type
“array of <span class='texttt'>T</span>”, or
function type <span class='texttt'>T</span>
denoted in a <i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specification</a></i>
is adjusted to type
“pointer to <span class='texttt'>T</span>”.
A <i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specification</a></i>
denotes an exception specification
that is the set of adjusted types specified thereby.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>
<span class='texttt'>noexcept</span> or <span class='texttt'>noexcept(</span><i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i><span class='texttt'>)</span>,
where the <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> yields <span class='texttt'>true</span>,
denotes an exception specification
that is the empty set.
The <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>
<span class='texttt'>noexcept(</span><i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i><span class='texttt'>)</span>,
where the <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i> yields <span class='texttt'>false</span>,
or the absence of an <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>
in a function declarator other than that
for a destructor (<a href='class.dtor'>[class.dtor]</a>)
or a deallocation function (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>)
denotes an exception specification
that is the set of all types.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='exception_specification,compatible'></a></span>Two <i ><a href='except.spec#nt:exception-specification'>exception-specifications</a></i> are
<a class='hidden_link' href='#def:compatible' id='def:compatible'><i>compatible</i></a> if
the sets of types they denote are the same.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >If any declaration of a function has an
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>
that is not a <i ><a href='except.spec#nt:noexcept-specification'>noexcept-specification</a></i> allowing all exceptions,
all declarations, including the definition and any explicit specialization,
of that function shall have a compatible
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>.
If any declaration of a pointer to function, reference to function,
or pointer to member function has an
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>,
all occurrences of that declaration shall have a compatible
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>.
If a declaration of a function has an implicit
exception specification,
other declarations of the function shall not specify an
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>.
In an explicit instantiation an
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>
may be specified, but is not required.
If an
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>
is specified in an explicit instantiation directive, it shall
be compatible with the <i ><a href='except.spec#nt:exception-specification'>exception-specifications</a></i> of
other declarations of that function.
A diagnostic is required only if the
<i ><a href='except.spec#nt:exception-specification'>exception-specifications</a></i> are not compatible
within a single translation unit.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='exception_specification,virtual_function_and'></a></span>If a virtual function has an
exception specification,
all declarations, including the definition, of any function
that overrides that virtual function in any derived class
shall only allow exceptions that are allowed by the
exception specification
of the base class virtual function,
unless the overriding function is defined as deleted.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct B {
  virtual void f() throw (int, double);
  virtual void g();
};

struct D: B {
  void f();                     <span class='comment'>// ill-formed
</span>  void g() throw (int);         <span class='comment'>// OK
</span>};
</pre><p >The declaration of
<span class='texttt'>D::f</span>
is ill-formed because it allows all exceptions, whereas
<span class='texttt'>B::f</span>
allows only
<span class='texttt'>int</span>
and
<span class='texttt'>double</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >An
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>
can include the same type more than once
and can include classes that are related by inheritance,
even though doing so is redundant.
[&nbsp;<i>Note:</i> An
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>
can also include the class
<span class='texttt'>std::bad_exception</span> (<a href='bad.exception'>[bad.exception]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p ><span class='indexparent'><a class='index' id='allowing_an_exception'></a></span>A function is said to
<a class='hidden_link' href='#def:exception_specification,allowing_an_exception' id='def:exception_specification,allowing_an_exception'><i>allow an exception</i></a>
of type
<span class='texttt'>E</span>
if
its exception specification
contains a type
<span class='texttt'>T</span>
for which a handler of type
<span class='texttt'>T</span>
would be a match (<a href='except.handle'>[except.handle]</a>) for an exception of type
<span class='texttt'>E</span>.
<span class='indexparent'><a class='index' id='allowing_all_exceptions'></a></span>A function is said to <a class='hidden_link' href='#def:exception_specification,allowing_all_exceptions' id='def:exception_specification,allowing_all_exceptions'><i>allow all exceptions</i></a>
if its exception specification
is the set of all types.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p ><span class='indexparent'><a class='index' id='exception_handling,unexpected_called'></a></span><span class='indexparent'><a class='index' id='unexpected,called'></a></span>Whenever an exception of type <span class='texttt'>E</span> is thrown
and the search for a handler (<a href='except.handle'>[except.handle]</a>)
encounters the outermost block of a function with an
exception specification that does not allow <span class='texttt'>E</span>, then,</p><ul class='itemize'><li id='9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.1'>(9.1)</a></div><p >if the function definition has a
<i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specification</a></i>, the function
<span class='texttt'>std::unexpected()</span> is called (<a href='except.unexpected'>[except.unexpected]</a>),</p><p ><span class='indexparent'><a class='index' id='exception_handling,terminate_called'></a></span><span class='indexparent'><a class='index' id='terminate,called'></a></span></p></li><li id='9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.2'>(9.2)</a></div><p >otherwise, the function <span class='texttt'>std::terminate()</span> is called (<a href='except.terminate'>[except.terminate]</a>).
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
class X { };
class Y { };
class Z: public X { };
class W { };

void f() throw (X, Y) {
  int n = 0;
  if (n) throw X();             <span class='comment'>// OK
</span>  if (n) throw Z();             <span class='comment'>// also OK
</span>  throw W();                    <span class='comment'>// will call <span class='texttt'>std::unexpected()</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Note:</i> A function can have multiple declarations with different non-throwing
<i ><a href='except.spec#nt:exception-specification'>exception-specifications</a></i>; for this purpose, the one on the
function definition is used. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >An implementation shall not reject an expression merely because when
executed it throws or might
throw an exception that the containing function does not allow.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
extern void f() throw(X, Y);

void g() throw(X) {
  f();                          <span class='comment'>// OK
</span>}

</pre><p >the call to
<span class='texttt'>f</span>
is well-formed even though when called,
<span class='texttt'>f</span>
might throw exception
<span class='texttt'>Y</span>
that
<span class='texttt'>g</span>
does not allow.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >[&nbsp;<i>Note:</i>
An
exception specification
is not considered part of a function's type;
see <a href='dcl.fct'>[dcl.fct]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >The <a class='hidden_link' href='#def:set_of_potential_exceptions' id='def:set_of_potential_exceptions'><i>set of potential exceptions</i></a> of a given context is
a set of types that might be thrown as an exception;
the (conceptual) set of all types is used to denote that an exception of
arbitrary type might be thrown.
A subexpression <span class='texttt'>e1</span> of an expression <span class='texttt'>e</span> is an
<a class='hidden_link' href='#def:immediate_subexpression' id='def:immediate_subexpression'><i>immediate subexpression</i></a> if there is no subexpression <span class='texttt'>e2</span> of <span class='texttt'>e</span>
such that <span class='texttt'>e1</span> is a subexpression of <span class='texttt'>e2</span>.</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p >The <a class='hidden_link' href='#def:set_of_potential_exceptions_of_an_expression' id='def:set_of_potential_exceptions_of_an_expression'><i>set of potential exceptions of an expression</i></a> <span class='texttt'>e</span> is empty
if <span class='texttt'>e</span> is a core constant expression (<a href='expr.const'>[expr.const]</a>).
Otherwise, it is the union of the sets of potential exceptions of
the immediate subexpressions of <span class='texttt'>e</span>,
including default argument expressions used in a function call,
combined with a set <i>S</i> defined by the form of <span class='texttt'>e</span>, as follows:</p><ul class='itemize'><li id='13.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#13.1'>(13.1)</a></div><p >If <span class='texttt'>e</span> is a function call (<a href='expr.call'>[expr.call]</a>):
</p><ul class='itemize'><li id='13.1.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#13.1.1'>(13.1.1)</a></div><p >If its <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> is a (possibly parenthesized)
<i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> (<a href='expr.prim.id'>[expr.prim.id]</a>), class member access
(<a href='expr.ref'>[expr.ref]</a>), or pointer-to-member operation (<a href='expr.mptr.oper'>[expr.mptr.oper]</a>)
whose <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i> is an <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>,
<i>S</i> is the set of types in the exception specification
of the entity selected by the
contained <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> (after overload resolution, if applicable).
</p></li><li id='13.1.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#13.1.2'>(13.1.2)</a></div><p >Otherwise, if the <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> has type
“<span class='texttt'>noexcept</span> function” or
“pointer to <span class='texttt'>noexcept</span> function”,
<i>S</i> is the empty set.
</p></li><li id='13.1.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#13.1.3'>(13.1.3)</a></div><p >Otherwise, <i>S</i> is the set of all types.
</p></li></ul></li><li id='13.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#13.2'>(13.2)</a></div><p >If <span class='texttt'>e</span> implicitly invokes one or more functions
(such as an overloaded operator,
an allocation function in a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>,
or a destructor if <span class='texttt'>e</span> is a full-expression (<a href='intro.execution'>[intro.execution]</a>)),
<i>S</i> is the union of:
</p><ul class='itemize'><li id='13.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#13.2.1'>(13.2.1)</a></div><p >the sets of types in the exception specifications of all such functions, and
</p></li><li id='13.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#13.2.2'>(13.2.2)</a></div><p >if <span class='texttt'>e</span> is a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>
with a non-constant <i ><a href='expr.comma#nt:expression'>expression</a></i>
in the <i ><a href='expr.new#nt:noptr-new-declarator'>noptr-new-declarator</a></i> (<a href='expr.new'>[expr.new]</a>)
and the allocation function selected for <span class='texttt'>e</span>
has a non-empty set of potential exceptions,
the set containing <span class='texttt'>std::bad_array_new_length</span>.
</p></li></ul></li><li id='13.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#13.3'>(13.3)</a></div><p >If <span class='texttt'>e</span> initializes an object of type <span class='texttt'>D</span> using an inherited
constructor for a class of type <span class='texttt'>B</span> (<a href='class.inhctor.init'>[class.inhctor.init]</a>),
<i>S</i> also contains the sets of potential exceptions
of the implied constructor invocations for subobjects of <span class='texttt'>D</span>
that are not subobjects of <span class='texttt'>B</span> (including default argument expressions
used in such invocations) as selected by overload resolution,
and the sets of potential exceptions of
the initialization of non-static data members from
<span class='grammarterm'>brace-or-equal-initializers</span> (<a href='class.base.init'>[class.base.init]</a>).
</p></li><li id='13.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#13.4'>(13.4)</a></div><p >If <span class='texttt'>e</span> is a <i ><a href='expr.throw#nt:throw-expression'>throw-expression</a></i> (<a href='expr.throw'>[expr.throw]</a>),
<i>S</i> consists of the type of the exception object that would be
initialized by the operand, if present, or is the set of all types otherwise.
</p></li><li id='13.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#13.5'>(13.5)</a></div><p >If <span class='texttt'>e</span> is a <span class='texttt'>dynamic_cast</span> expression that casts to a reference type and
requires a runtime check (<a href='expr.dynamic.cast'>[expr.dynamic.cast]</a>),
<i>S</i> consists of the type <span class='texttt'>std::bad_cast</span>.
</p></li><li id='13.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#13.6'>(13.6)</a></div><p >If <span class='texttt'>e</span> is a <span class='texttt'>typeid</span> expression applied to a glvalue expression whose
type is a polymorphic class type (<a href='expr.typeid'>[expr.typeid]</a>),
<i>S</i> consists of the type <span class='texttt'>std::bad_typeid</span>.
</p></li></ul><p >[&nbsp;<i>Example:</i>
Given the following declarations
</p><pre class='codeblock'>
  void f() throw(int); 
  void g();  
  struct A { A(); };
  struct B { B() noexcept; };
  struct D { D() throw (double); };
</pre><p >the set of potential exceptions for some sample expressions is:
</p><ul class='itemize'><li id='13.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#13.7'>(13.7)</a></div><p >for <span class='texttt'>f()</span>, the set consists of <span class='texttt'>int</span>;
</p></li><li id='13.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#13.8'>(13.8)</a></div><p >for <span class='texttt'>g()</span>, the set is the set of all types;
</p></li><li id='13.9'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#13.9'>(13.9)</a></div><p >for <span class='texttt'>new A</span>, the set is the set of all types;
</p></li><li id='13.10'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#13.10'>(13.10)</a></div><p >for <span class='texttt'>B()</span>, the set is empty;
</p></li><li id='13.11'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#13.11'>(13.11)</a></div><p >for <span class='texttt'>new D</span>, the set is the set of all types.
</p></li></ul><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><p >A function with an implied non-throwing exception specification,
where the function's type is declared to be <span class='texttt'>T</span>,
is instead considered to be of type “<span class='texttt'>noexcept</span> <span class='texttt'>T</span>”.</p></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><p >An implicitly-declared special member function <span class='texttt'>f</span> of some class <span class='texttt'>X</span>
is considered to have an implicit exception specification that
consists of all the members from the following sets:</p><ul class='itemize'><li id='15.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#15.1'>(15.1)</a></div><p >if <span class='texttt'>f</span> is a constructor,
</p><ul class='itemize'><li id='15.1.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#15.1.1'>(15.1.1)</a></div><p >the sets of potential exceptions of the constructor invocations
</p><ul class='itemize'><li id='15.1.1.1'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#15.1.1.1'>(15.1.1.1)</a></div><p >for <span class='texttt'>X</span>'s non-variant non-static data members,
</p></li><li id='15.1.1.2'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#15.1.1.2'>(15.1.1.2)</a></div><p >for <span class='texttt'>X</span>'s direct base classes, and
</p></li><li id='15.1.1.3'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#15.1.1.3'>(15.1.1.3)</a></div><p >if <span class='texttt'>X</span> is non-abstract (<a href='class.abstract'>[class.abstract]</a>), for <span class='texttt'>X</span>'s virtual base
classes,
</p></li></ul><p >(including default argument expressions used in such invocations) as selected
by overload resolution for the implicit definition of <span class='texttt'>f</span> (<a href='class.ctor'>[class.ctor]</a>).
[&nbsp;<i>Note:</i>
Even though destructors for fully-constructed subobjects are invoked
when an exception is thrown during the execution of a constructor (<a href='except.ctor'>[except.ctor]</a>),
their exception specifications do not contribute to the
exception specification of the constructor, because
an exception thrown from such a destructor could never escape the constructor
(<a href='except.throw'>[except.throw]</a>, <a href='except.terminate'>[except.terminate]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li><li id='15.1.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#15.1.2'>(15.1.2)</a></div><p >the sets of potential exceptions of the initialization of non-static data members
from <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializers</a></i> that are not ignored (<a href='class.base.init'>[class.base.init]</a>);
</p></li></ul></li><li id='15.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#15.2'>(15.2)</a></div><p >if <span class='texttt'>f</span> is an assignment operator, the sets of potential exceptions of
the assignment operator invocations for <span class='texttt'>X</span>'s non-variant non-static
data members and for <span class='texttt'>X</span>'s direct base classes (including default
argument expressions used in such invocations), as selected by overload resolution
for the implicit definition of <span class='texttt'>f</span> (<a href='class.copy'>[class.copy]</a>);</p></li><li id='15.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#15.3'>(15.3)</a></div><p >if <span class='texttt'>f</span> is a destructor, the sets of potential exceptions of the
destructor invocations for <span class='texttt'>X</span>'s non-variant non-static data members
and for <span class='texttt'>X</span>'s virtual and direct base classes.
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct A {
  A(int = (A(5), 0)) noexcept;
  A(const A&amp;) throw();
  A(A&amp;&amp;) throw();
  ~A() throw(X);
};
struct B {
  B() throw();
  B(const B&amp;) = default; <span class='comment'>// exception specification contains no types
</span>  B(B&amp;&amp;, int = (throw Y(), 0)) noexcept;
  ~B() throw(Y);
};
int n = 7;
struct D : public A, public B {
    int * p = new (std::nothrow) int[n];
    <span class='comment'>// exception specification of <span class='texttt'>D::D()</span> contains <span class='texttt'>X</span>
</span>    <span class='comment'>// exception specification of <span class='texttt'>D::D(const D&amp;)</span> contains no types
</span>    <span class='comment'>// exception specification of <span class='texttt'>D::D(D&amp;&amp;)</span> contains <span class='texttt'>Y</span>
</span>    <span class='comment'>// exception specification of <span class='texttt'>D::~D()</span> contains <span class='texttt'>X</span> and <span class='texttt'>Y</span>
</span>};
struct exp : std::bad_alloc {};
void *operator new[](size_t) throw(exp);
struct E : public A {
  int * p = new int[n];
  <span class='comment'>// exception specification of <span class='texttt'>E::E()</span> contains <span class='texttt'>X</span>, <span class='texttt'>exp</span>, and <span class='texttt'>std::bad_array_new_length</span>
</span>};
</pre><p >Furthermore, if
<span class='texttt'>A::~A()</span>
or
<span class='texttt'>B::~B()</span>
were virtual,
<span class='texttt'>D::~D()</span>
would not be as restrictive as that of
<span class='texttt'>A::~A</span>,
and the program would be ill-formed since a function that overrides a virtual
function from a base class shall have an <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>
 at least as restrictive as that in the base class.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><p >A deallocation function (<a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>)
with no explicit <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i>
has an exception specification that is the empty set.</p></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><p >An <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> is considered to be <a class='hidden_link' href='#def:needed' id='def:needed'><i>needed</i></a> when:</p><ul class='itemize'><li id='17.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#17.1'>(17.1)</a></div><p >in an expression, the function is the unique lookup result or the selected
member of a set of overloaded functions (<a href='basic.lookup'>[basic.lookup]</a>, <a href='over.match'>[over.match]</a>, <a href='over.over'>[over.over]</a>);</p></li><li id='17.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#17.2'>(17.2)</a></div><p >the function is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>) or, if it appears in an
unevaluated operand, would be odr-used if the expression were
potentially-evaluated;</p></li><li id='17.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#17.3'>(17.3)</a></div><p >the <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> is compared to that of another
declaration (e.g., an explicit specialization or an overriding virtual
function);</p></li><li id='17.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#17.4'>(17.4)</a></div><p >the function is defined; or</p></li><li id='17.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#17.5'>(17.5)</a></div><p >the <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> is needed for a defaulted
special member function that calls the function.
[&nbsp;<i>Note:</i> A defaulted declaration does not require the
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> of a base member function to be evaluated
until the implicit <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> of the derived
function is needed, but an explicit <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> needs
the implicit <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> to compare against.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul><p >The <i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> of a defaulted special member
function is evaluated as described above only when needed; similarly, the
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> of a specialization of a function
template or member function of a class template is instantiated only when
needed.</p></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><p >In a <i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specification</a></i>, a
<i ><a href='dcl.name#nt:type-id'>type-id</a></i> followed by an ellipsis is a
pack expansion (<a href='temp.variadic'>[temp.variadic]</a>).</p></div><div class='para' id='19'><div class='marginalizedparent'><a class='marginalized' href='#19'>19</a></div><p >[&nbsp;<i>Note:</i> The use of <i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specifications</a></i> is deprecated
(see Annex <a href='depr'>[depr]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]<span class='indexparent'><a class='index' id='exception_specification'></a></span></p></div></div></div></body></html>