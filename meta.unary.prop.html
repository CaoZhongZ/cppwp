<!DOCTYPE html><html lang='en'><head><title>[meta.unary.prop]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>23</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>23.15</a> Metaprogramming and type traits <a class='abbr_ref' href='meta#unary.prop'>[meta]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>23.15.4</a> Unary type traits <a class='abbr_ref' href='meta.unary#prop'>[meta.unary]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>23.15.4.3</a> Type properties <a class='abbr_ref'>[meta.unary.prop]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f118eb5c2d546aaf830f92b262039083e40576f/source/utilities.tex#L15849'>#</a></div><p >These templates provide access to some of the more important
properties of types.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f118eb5c2d546aaf830f92b262039083e40576f/source/utilities.tex#L15853'>#</a></div><p >It is unspecified whether the library defines any full or partial
specializations of any of these templates.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f118eb5c2d546aaf830f92b262039083e40576f/source/utilities.tex#L15857'>#</a></div><p >For all of the class templates <span class='texttt'>X</span> declared in this subclause,
instantiating that template with a template-argument that is a class
template specialization may result in the implicit instantiation of
the template argument if and only if the semantics of <span class='texttt'>X</span> require that
the argument must be a complete type.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f118eb5c2d546aaf830f92b262039083e40576f/source/utilities.tex#L15864'>#</a></div><p >For the purpose of defining the templates in this subclause,
a function call expression <span class='texttt'>declval&lt;T&gt;()</span> for any type <span class='texttt'>T</span>
is considered to be a trivial (<a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>) function call
that is not an <a href='basic.def.odr'>odr-use</a> of <span class='texttt'>declval</span>
in the context of the corresponding definition
notwithstanding the restrictions of <a href='declval'>[declval]</a>.</p><div class='numberedTable' id='tab:type-traits.properties'>Table <a href='#tab:type-traits.properties'>42</a> — Type property predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Preconditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='indexparent'><a class='index' id='lib:is_const'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;const;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is <a href='basic.type.qualifier#def:const-qualified'>const-qualified</a>                  </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_volatile'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;volatile;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is <a href='basic.type.qualifier#def:volatile-qualified'>volatile-qualified</a>                   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='indexparent'><a class='index' id='lib:is_trivial'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;trivial;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a <a href='basic.types#def:trivial_types'>trivial type</a>     </td><td class='left'>
 <span class='texttt'>remove_&shy;all_&shy;extents_&shy;t&lt;T&gt;</span> shall be a complete
 type or <span class='textit'>cv</span> <span class='texttt'>void</span>.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_trivially_copyable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;trivially_&shy;copyable;</span>      </td><td class='left'>
 <span class='texttt'>T</span> is a <a href='basic.types#def:trivially_copyable_types'>trivially copyable type</a> </td><td class='left'>
 <span class='texttt'>remove_&shy;all_&shy;extents_&shy;t&lt;T&gt;</span> shall be a complete type or
 <span class='textit'>cv</span> <span class='texttt'>void</span>.                               </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_standard_layout'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;standard_&shy;layout;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a <a href='basic.types#def:standard-layout_types'>standard-layout type</a>   </td><td class='left'>
 <span class='texttt'>remove_&shy;all_&shy;extents_&shy;t&lt;T&gt;</span> shall be a complete
 type or <span class='textit'>cv</span> <span class='texttt'>void</span>.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_pod'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;pod;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a <a href='basic.types#def:type,POD'>POD type</a>                                </td><td class='left'>
 <span class='texttt'>remove_&shy;all_&shy;extents_&shy;t&lt;T&gt;</span> shall be a complete
 type or <span class='textit'>cv</span> <span class='texttt'>void</span>.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_empty,class'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;empty;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is a class type, but not a union type, with no non-static data
 members other than bit-fields of length 0, no virtual member functions,
 no virtual base classes, and no base class <span class='texttt'>B</span> for
 which <span class='texttt'>is_&shy;empty_&shy;v&lt;B&gt;</span> is <span class='texttt'>false</span>. </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                               </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_polymorphic'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;polymorphic;</span>         </td><td class='left'>
 <span class='texttt'>T</span> is a <a href='class.virtual#def:class,polymorphic'>polymorphic class</a> </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_abstract'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;abstract;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is an <a href='class.abstract#def:class,abstract'>abstract class</a> </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_final'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;final;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is a class type marked with the <span class='grammarterm'>class-virt-specifier</span>
 <span class='texttt'>final</span> (Clause <a href='class'>[class]</a>). [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  A union is a class type that
 can be marked with <span class='texttt'>final</span>. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]                                         </td><td class='left'>
 If <span class='texttt'>T</span> is a class type, <span class='texttt'>T</span> shall be a complete type.                          </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_aggregate'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_&shy;aggregate;</span>           </td><td class='left'>
 <span class='texttt'>T</span> is an aggregate type (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>) </td><td class='left'>
 <span class='texttt'>remove_&shy;all_&shy;extents_&shy;t&lt;T&gt;</span> shall be a complete type or <span class='textit'>cv</span> <span class='texttt'>void</span>.              </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_signed,class'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_&shy;signed;</span>              </td><td class='left'>
  If <span class='texttt'>is_&shy;arithmetic_&shy;v&lt;T&gt;</span> is <span class='texttt'>true</span>, the same result as
  <span class='texttt'>T(-1) &lt; T(0)</span>;
  otherwise, <span class='texttt'>false</span>   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'>  <span class='indexparent'><a class='index' id='lib:is_unsigned'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_&shy;unsigned;</span>            </td><td class='left'>
  If <span class='texttt'>is_&shy;arithmetic_&shy;v&lt;T&gt;</span> is <span class='texttt'>true</span>, the same result as
  <span class='texttt'>T(0) &lt; T(-1)</span>;
  otherwise, <span class='texttt'>false</span>   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'>  <span class='indexparent'><a class='index' id='lib:is_constructible'></a></span><span class='texttt'>template &lt;class T, class... Args&gt;</span><br/>
 <span class='texttt'>struct is_&shy;constructible;</span>   </td><td class='left'>
 For a function type <span class='texttt'>T</span> or
 for a <span class='textit'>cv</span> <span class='texttt'>void</span> type <span class='texttt'>T</span>,
 <span class='texttt'>is_&shy;constructible_&shy;v&lt;T, Args...&gt;</span> is <span class='texttt'>false</span>,
 otherwise <span class='textit'><span class='texttt'>see below</span></span></td><td class='left'>
 <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span>
 shall be complete types, <span class='textit'>cv</span> <span class='texttt'>void</span>,
 or arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_default_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_&shy;default_&shy;constructible;</span> </td><td class='left'>
  <span class='texttt'>is_&shy;constructible_&shy;v&lt;T&gt;</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, <span class='textit'>cv</span> <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_copy_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_&shy;copy_&shy;constructible;</span> </td><td class='left'>
  For a <a href='defns.referenceable'>referenceable type</a> <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_&shy;constructible_&shy;v&lt;T, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, <span class='textit'>cv</span> <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_move_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_&shy;move_&shy;constructible;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_&shy;constructible_&shy;v&lt;T, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, <span class='textit'>cv</span> <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_assignable'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_&shy;assignable;</span> </td><td class='left'>
  The expression <span class='texttt'>declval&lt;T&gt;() =</span> <span class='texttt'>declval&lt;U&gt;()</span> is well-formed
  when treated as an <a href='expr#def:unevaluated_operand'>unevaluated operand</a>.
  Access checking is performed as if in a context
  unrelated to <span class='texttt'>T</span> and <span class='texttt'>U</span>. Only the validity of the immediate context
  of the assignment expression is considered. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  The compilation of the
  expression can result in side effects such as the instantiation of class template
  specializations and function template specializations, the generation of
  implicitly-defined functions, and so on. Such side effects are not in the “immediate
  context” and can result in the program being ill-formed. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]  </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, <span class='textit'>cv</span> <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_copy_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_&shy;copy_&shy;assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_&shy;assignable_&shy;v&lt;T&amp;, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, <span class='textit'>cv</span> <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_move_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_&shy;move_&shy;assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_&shy;assignable_&shy;v&lt;T&amp;, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, <span class='textit'>cv</span> <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_swappable_with'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_&shy;swappable_&shy;with;</span> </td><td class='left'>
  The expressions <span class='texttt'>swap(declval&lt;T&gt;(), declval&lt;U&gt;())</span> and
  <span class='texttt'>swap(declval&lt;U&gt;(), declval&lt;T&gt;())</span> are each well-formed
  when treated as an <a href='expr#def:unevaluated_operand'>unevaluated operand</a>
  in an overload-resolution context
  for swappable values (<a href='swappable.requirements'>[swappable.requirements]</a>).
  Access checking is performed as if in a context
  unrelated to <span class='texttt'>T</span> and <span class='texttt'>U</span>.
  Only the validity of the immediate context
  of the <span class='texttt'>swap</span> expressions is considered.
  [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
  The compilation of the expressions can result in side effects
  such as the instantiation of class template specializations and
  function template specializations,
  the generation of implicitly-defined functions, and so on.
  Such side effects are not in the “immediate context” and
  can result in the program being ill-formed.
  <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]  </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types,
  <span class='textit'>cv</span> <span class='texttt'>void</span>, or
  arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_swappable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_&shy;swappable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>,
  the same result as <span class='texttt'>is_&shy;swappable_&shy;with_&shy;v&lt;T&amp;, T&amp;&gt;</span>,
  otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  <span class='textit'>cv</span> <span class='texttt'>void</span>, or
  an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_destructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_&shy;destructible;</span> </td><td class='left'>
  Either <span class='texttt'>T</span> is a reference type,
  or <span class='texttt'>T</span> is a complete object type
  for which the expression
  <span class='texttt'>declval&lt;U&amp;&gt;().~U()</span>
  is well-formed
  when treated as an <a href='expr#def:unevaluated_operand'>unevaluated operand</a>,
  where <span class='texttt'>U</span> is
  <span class='texttt'>remove_&shy;all_&shy;extents&lt;T&gt;</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, <span class='textit'>cv</span> <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_trivially_constructible'></a></span><span class='texttt'>template &lt;class T, class... Args&gt;</span><br/>
  <span class='texttt'>struct</span><br/>
  <span class='texttt'>is_&shy;trivially_&shy;constructible;</span> </td><td class='left'>
  <span class='texttt'>is_&shy;constructible_&shy;v&lt;T,</span><br/>
  <span class='texttt'>Args...&gt;</span> is <span class='texttt'>true</span> and the variable
  definition for <span class='texttt'>is_&shy;constructible</span>, as defined below, is known to call
  no operation that is not trivial (<a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span> shall be complete types,
  <span class='textit'>cv</span> <span class='texttt'>void</span>, or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_trivially_default_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;trivially_&shy;default_&shy;constructible;</span> </td><td class='left'>
 <span class='texttt'>is_&shy;trivially_&shy;constructible_&shy;v&lt;T&gt;</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <span class='textit'>cv</span> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_trivially_copy_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;trivially_&shy;copy_&shy;constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_&shy;trivially_&shy;constructible_&shy;v&lt;T, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
 <span class='textit'>cv</span> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_trivially_move_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;trivially_&shy;move_&shy;constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_&shy;trivially_&shy;constructible_&shy;v&lt;T, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
 <span class='textit'>cv</span> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_trivially_assignable'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_&shy;trivially_&shy;assignable;</span> </td><td class='left'>
  <span class='texttt'>is_&shy;assignable_&shy;v&lt;T, U&gt;</span> is <span class='texttt'>true</span> and the assignment, as defined by
  <span class='texttt'>is_&shy;assignable</span>, is known to call no operation that is not trivial
  (<a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, <span class='textit'>cv</span> <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_trivially_copy_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;trivially_&shy;copy_&shy;assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_&shy;trivially_&shy;assignable_&shy;v&lt;T&amp;, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <span class='textit'>cv</span> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_trivially_move_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;trivially_&shy;move_&shy;assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_&shy;trivially_&shy;assignable_&shy;v&lt;T&amp;, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <span class='textit'>cv</span> <span class='texttt'>void</span>, or an array of unknown bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_trivially_destructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;trivially_&shy;destructible;</span> </td><td class='left'>
 <span class='texttt'>is_&shy;destructible_&shy;v&lt;T&gt;</span> is <span class='texttt'>true</span> and the indicated destructor is known
 to be trivial. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <span class='textit'>cv</span> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_nothrow_constructible'></a></span><span class='texttt'>template &lt;class T, class... Args&gt;</span><br/>
 <span class='texttt'>struct is_&shy;nothrow_&shy;constructible;</span>   </td><td class='left'>
 <span class='texttt'>is_&shy;constructible_&shy;v&lt;T,</span> <span class='texttt'> Args...&gt;</span> is <span class='texttt'>true</span>
 and the
 variable definition for <span class='texttt'>is_&shy;constructible</span>, as defined below, is known not to
 throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>).
 </td><td class='left'>
 <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span>
 shall be complete types, <span class='textit'>cv</span> <span class='texttt'>void</span>,
 or arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_nothrow_default_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;nothrow_&shy;default_&shy;constructible;</span> </td><td class='left'>
 <span class='texttt'>is_&shy;nothrow_&shy;constructible_&shy;v&lt;T&gt;</span> is <span class='texttt'>true</span>.  </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <span class='textit'>cv</span> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_nothrow_copy_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;nothrow_&shy;copy_&shy;constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_&shy;nothrow_&shy;constructible_&shy;v&lt;T, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <span class='textit'>cv</span> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_nothrow_move_constructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;nothrow_&shy;move_&shy;constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_&shy;nothrow_&shy;constructible_&shy;v&lt;T, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <span class='textit'>cv</span> <span class='texttt'>void</span>, or an array of unknown bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_nothrow_assignable'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_&shy;nothrow_&shy;assignable;</span> </td><td class='left'>
  <span class='texttt'>is_&shy;assignable_&shy;v&lt;T, U&gt;</span> is <span class='texttt'>true</span> and the assignment is known not to
  throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, <span class='textit'>cv</span> <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_nothrow_copy_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_&shy;nothrow_&shy;copy_&shy;assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_&shy;nothrow_&shy;assignable_&shy;v&lt;T&amp;, const T&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <span class='textit'>cv</span> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_nothrow_move_assignable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_&shy;nothrow_&shy;move_&shy;assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_&shy;nothrow_&shy;assignable_&shy;v&lt;T&amp;, T&amp;&amp;&gt;</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 <span class='textit'>cv</span> <span class='texttt'>void</span>, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_nothrow_swappable_with'></a></span><span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_&shy;nothrow_&shy;swappable_&shy;with;</span> </td><td class='left'>
  <span class='texttt'>is_&shy;swappable_&shy;with_&shy;v&lt;T, U&gt;</span> is <span class='texttt'>true</span> and
  each <span class='texttt'>swap</span> expression of the definition of
  <span class='texttt'>is_&shy;swappable_&shy;with&lt;T, U&gt;</span> is known not to throw
  any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types,
  <span class='textit'>cv</span> <span class='texttt'>void</span>, or
  arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_nothrow_swappable'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_&shy;nothrow_&shy;swappable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>,
  the same result as <span class='texttt'>is_&shy;nothrow_&shy;swappable_&shy;with_&shy;v&lt;T&amp;, T&amp;&gt;</span>,
  otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  <span class='textit'>cv</span> <span class='texttt'>void</span>, or
  an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:is_nothrow_destructible'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_&shy;nothrow_&shy;destructible;</span> </td><td class='left'>
  <span class='texttt'>is_&shy;destructible_&shy;v&lt;T&gt;</span> is <span class='texttt'>true</span> and the indicated destructor is known
  not to throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  <span class='textit'>cv</span> <span class='texttt'>void</span>, or an array of unknown
  bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:has_virtual_destructor'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct has_&shy;virtual_&shy;destructor;</span> </td><td class='left'>
 <span class='texttt'>T</span> has a virtual <a href='class.dtor'>destructor</a> </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr><tr class='rowsep'><td class='left'> <span class='indexparent'><a class='index' id='lib:has_unique_object_representations'></a></span><span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct has_&shy;unique_&shy;object_&shy;representations;</span> </td><td class='left'>
  For an array type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>has_&shy;unique_&shy;object_&shy;representations_&shy;v&lt;remove_&shy;all_&shy;extents_&shy;t&lt;T&gt;&gt;</span>,
  otherwise <span class='textit'><span class='texttt'>see below</span></span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, <span class='textit'>cv</span> <span class='texttt'>void</span>, or
  an array of unknown bound. </td></tr></table></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f118eb5c2d546aaf830f92b262039083e40576f/source/utilities.tex#L16264'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
is_const_v&lt;const volatile int&gt;     <span class='comment'>// <span class='tcode_in_codeblock'>true</span>
</span>is_const_v&lt;const int*&gt;             <span class='comment'>// <span class='tcode_in_codeblock'>false</span>
</span>is_const_v&lt;const int&amp;&gt;             <span class='comment'>// <span class='tcode_in_codeblock'>false</span>
</span>is_const_v&lt;int[3]&gt;                 <span class='comment'>// <span class='tcode_in_codeblock'>false</span>
</span>is_const_v&lt;const int[3]&gt;           <span class='comment'>// <span class='tcode_in_codeblock'>true</span>
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f118eb5c2d546aaf830f92b262039083e40576f/source/utilities.tex#L16275'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
remove_const_t&lt;const volatile int&gt;  <span class='comment'>// <span class='tcode_in_codeblock'>volatile int</span>
</span>remove_const_t&lt;const int* const&gt;    <span class='comment'>// <span class='tcode_in_codeblock'>const int*</span>
</span>remove_const_t&lt;const int&amp;&gt;          <span class='comment'>// <span class='tcode_in_codeblock'>const int&amp;</span>
</span>remove_const_t&lt;const int[3]&gt;        <span class='comment'>// <span class='tcode_in_codeblock'>int[3]</span>
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f118eb5c2d546aaf830f92b262039083e40576f/source/utilities.tex#L16285'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
<span class='comment'>// Given:
</span>struct P final { };
union U1 { };
union U2 final { };

<span class='comment'>// the following assertions hold:
</span>static_assert(!is_final_v&lt;int&gt;);
static_assert(is_final_v&lt;P&gt;);
static_assert(!is_final_v&lt;U1&gt;);
static_assert(is_final_v&lt;U2&gt;);</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p><p ><span class='indexparent'><a class='index' id='lib:is_constructible_'></a></span></p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f118eb5c2d546aaf830f92b262039083e40576f/source/utilities.tex#L16302'>#</a></div><p >The predicate condition for a template specialization
<span class='texttt'>is_&shy;constructible&lt;T, Args...&gt;</span> shall be satisfied if and only if the
following variable definition would be well-formed for some invented variable <span class='texttt'>t</span>:</p><pre class='codeblock'>
T t(declval&lt;Args&gt;()...);</pre><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  These tokens are never interpreted as a function declaration.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]  Access checking is performed as if in a context unrelated to <span class='texttt'>T</span>
and any of the <span class='texttt'>Args</span>. Only the validity of the immediate context of the
variable initialization is considered. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  The evaluation of the
initialization can result in side effects such as the instantiation of class
template specializations and function template specializations, the generation
of implicitly-defined functions, and so on. Such side effects are not in the
“immediate context” and can result in the program being ill-formed. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p><p ><span class='indexparent'><a class='index' id='lib:has_unique_object_representations_'></a></span></p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f118eb5c2d546aaf830f92b262039083e40576f/source/utilities.tex#L16321'>#</a></div><p >The predicate condition for a template specialization
<span class='texttt'>has_&shy;unique_&shy;object_&shy;representations&lt;T&gt;</span>
shall be satisfied if and only if:
</p><ul class='itemize'><li id='9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.1'>(9.1)</a></div><p ><span class='texttt'>T</span> is trivially copyable, and
</p></li><li id='9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.2'>(9.2)</a></div><p >any two objects of type <span class='texttt'>T</span> with the same value
have the same object representation, where
two objects of array or non-union class type are considered to have the same value
if their respective sequences of direct subobjects have the same values, and
two objects of union type are considered to have the same value
if they have the same active member and the corresponding members have the same value.
</p></li></ul><p >The set of scalar types for which this condition holds is
<span class='indexparent'><a class='index' id=':which_scalar_types_have_unique_object_representations'></a></span>implementation-defined.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  If a type has padding bits, the condition does not hold;
otherwise, the condition holds true for unsigned integral types. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div></div></body></html>