<!DOCTYPE html><html lang='en'><head><title>[dcl.init.ref]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Declarators <a class='abbr_ref' href='./#dcl.decl'>[dcl.decl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>8.6</a> Initializers <a class='abbr_ref' href='dcl.init#ref'>[dcl.init]</a></h2><div id='dcl.init.ref'><h3 ><a class='secnum' style='min-width:103pt'>8.6.3</a> References <a class='abbr_ref'>[dcl.init.ref]</a></h3><p ><span class='indexparent'><a class='index' id='initialization,reference'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/declarators.tex#L3407'>#</a></div><p >A variable whose declared type is
“reference to type <span class='texttt'>T</span>” (<a href='dcl.ref'>[dcl.ref]</a>)
shall be initialized.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span></p><pre class='codeblock'>
int g(int) noexcept;
void f() {
  int i;
  int&amp; r = i;                   <span class='comment'>// <span class='tcode_in_codeblock'>r</span> refers to <span class='tcode_in_codeblock'>i</span>
</span>  r = 1;                        <span class='comment'>// the value of <span class='tcode_in_codeblock'>i</span> becomes <span class='tcode_in_codeblock'>1</span>
</span>  int* p = &amp;r;                  <span class='comment'>// <span class='tcode_in_codeblock'>p</span> points to <span class='tcode_in_codeblock'>i</span>
</span>  int&amp; rr = r;                  <span class='comment'>// <span class='tcode_in_codeblock'>rr</span> refers to what <span class='tcode_in_codeblock'>r</span> refers to, that is, to <span class='tcode_in_codeblock'>i</span>
</span>  int (&amp;rg)(int) = g;           <span class='comment'>// <span class='tcode_in_codeblock'>rg</span> refers to the function <span class='tcode_in_codeblock'>g</span>
</span>  rg(i);                        <span class='comment'>// calls function <span class='tcode_in_codeblock'>g</span>
</span>  int a[3];
  int (&amp;ra)[3] = a;             <span class='comment'>// <span class='tcode_in_codeblock'>ra</span> refers to the array <span class='tcode_in_codeblock'>a</span>
</span>  ra[1] = i;                    <span class='comment'>// modifies <span class='tcode_in_codeblock'>a[1]</span>
</span>}</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/declarators.tex#L3430'>#</a></div><p >A reference cannot be changed to refer to another object after initialization.
<span class='indexparent'><a class='index' id='assignment,reference'></a></span>[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
Assignment to a reference assigns to the object referred to by the reference (<a href='expr.ass'>[expr.ass]</a>).
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
<span class='indexparent'><a class='index' id='argument_passing,reference_and'></a></span>Argument passing (<a href='expr.call'>[expr.call]</a>)
<span class='indexparent'><a class='index' id='return,reference_and'></a></span>and function value return (<a href='stmt.return'>[stmt.return]</a>) are initializations.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/declarators.tex#L3441'>#</a></div><p >The initializer can be omitted for a reference only in a parameter declaration
(<a href='dcl.fct'>[dcl.fct]</a>), in the declaration of a function return type, in the declaration of
a class member within its class definition (<a href='class.mem'>[class.mem]</a>), and where the
<span class='texttt'>extern</span>
specifier is explicitly used.
<span class='indexparent'><a class='index' id='declaration,extern'></a></span>[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span></p><pre class='codeblock'>
int&amp; r1;                        <span class='comment'>// error: initializer missing
</span>extern int&amp; r2;                 <span class='comment'>// OK
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/declarators.tex#L3456'>#</a></div><p >Given types “<span class='textit'>cv1</span> <span class='texttt'>T1</span>” and “<span class='textit'>cv2</span> <span class='texttt'>T2</span>”,
“<span class='textit'>cv1</span> <span class='texttt'>T1</span>” is <a class='hidden_link' href='#def:reference-related' id='def:reference-related'><i>reference-related</i></a> to
“<span class='textit'>cv2</span> <span class='texttt'>T2</span>” if
<span class='texttt'>T1</span> is the same type as <span class='texttt'>T2</span>, or
<span class='texttt'>T1</span> is a base class of <span class='texttt'>T2</span>.
“<span class='textit'>cv1</span> <span class='texttt'>T1</span>” is <a class='hidden_link' href='#def:reference-compatible' id='def:reference-compatible'><i>reference-compatible</i></a>
with “<span class='textit'>cv2</span> <span class='texttt'>T2</span>” if
</p><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><p ><span class='texttt'>T1</span> is reference-related to <span class='texttt'>T2</span>, or
</p></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><p ><span class='texttt'>T2</span> is “<span class='texttt'>noexcept</span> function” and <span class='texttt'>T1</span> is “function”,
where the function types are otherwise the same,
</p></li></ul><p >and
<span class='textit'>cv1</span>
is the same cv-qualification as, or greater cv-qualification than,
<span class='textit'>cv2</span>.
In all cases where the reference-related or reference-compatible relationship
of two types is used to establish the validity of a reference binding, and
<span class='texttt'>T1</span>
is a base class of
<span class='texttt'>T2</span>,
a program that necessitates such a binding is ill-formed if
<span class='texttt'>T1</span>
is an inaccessible (Clause <a href='class.access'>[class.access]</a>) or ambiguous (<a href='class.member.lookup'>[class.member.lookup]</a>)
base class of
<span class='texttt'>T2</span>.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/declarators.tex#L3484'>#</a></div><p >A reference to type “<span class='textit'>cv1</span> <span class='texttt'>T1</span>” is initialized by
an expression of type “<span class='textit'>cv2</span> <span class='texttt'>T2</span>” as follows:<span class='indexparent'><a class='index' id='binding,reference'></a></span></p><ul class='itemize'><li id='5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.1'>(5.1)</a></div><p >If the reference is an lvalue reference and the initializer expression</p><ul class='itemize'><li id='5.1.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#5.1.1'>(5.1.1)</a></div><p >is an lvalue (but is not a
bit-field), and
“<span class='textit'>cv1</span> <span class='texttt'>T1</span>” is reference-compatible with
“<span class='textit'>cv2</span> <span class='texttt'>T2</span>”, or
</p></li><li id='5.1.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#5.1.2'>(5.1.2)</a></div><p >has a class type (i.e.,
<span class='texttt'>T2</span>
is a class type), where <span class='texttt'>T1</span> is not reference-related to <span class='texttt'>T2</span>, and can be converted
to an lvalue of type “<span class='textit'>cv3</span> <span class='texttt'>T3</span>”, where
“<span class='textit'>cv1</span> <span class='texttt'>T1</span>” is reference-compatible with
“<span class='textit'>cv3</span> <span class='texttt'>T3</span>”<a class='footnotenum' href='#footnote-106'>106</a>
(this conversion is selected by enumerating the applicable conversion
functions (<a href='over.match.ref'>[over.match.ref]</a>) and choosing the best one through overload
resolution (<a href='over.match'>[over.match]</a>)),
</p></li></ul><p >then the reference is bound to the initializer expression lvalue in the
first case and to the lvalue result of the conversion
in the second case (or, in either case, to the appropriate base class subobject of the object).
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
The usual lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>), array-to-pointer
(<a href='conv.array'>[conv.array]</a>), and function-to-pointer (<a href='conv.func'>[conv.func]</a>) standard
conversions are not needed, and therefore are suppressed, when such
direct bindings to lvalues are done.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span></p><pre class='codeblock'>
double d = 2.0;
double&amp; rd = d;                 <span class='comment'>// <span class='tcode_in_codeblock'>rd</span> refers to <span class='tcode_in_codeblock'>d</span>
</span>const double&amp; rcd = d;          <span class='comment'>// <span class='tcode_in_codeblock'>rcd</span> refers to <span class='tcode_in_codeblock'>d</span>
</span>
struct A { };
struct B : A { operator int&amp;(); } b;
A&amp; ra = b;                      <span class='comment'>// <span class='tcode_in_codeblock'>ra</span> refers to <span class='tcode_in_codeblock'>A</span> subobject in <span class='tcode_in_codeblock'>b</span>
</span>const A&amp; rca = b;               <span class='comment'>// <span class='tcode_in_codeblock'>rca</span> refers to <span class='tcode_in_codeblock'>A</span> subobject in <span class='tcode_in_codeblock'>b</span>
</span>int&amp; ir = B();                  <span class='comment'>// <span class='tcode_in_codeblock'>ir</span> refers to the result of <span class='tcode_in_codeblock'>B&#x200b;::&#x200b;operator int&amp;</span>
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></li><li id='5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.2'>(5.2)</a></div><p >Otherwise, the reference shall be an lvalue reference to a non-volatile
const type (i.e.,
<span class='textit'>cv1</span>
shall be
<span class='texttt'>const</span>), or the reference shall be an rvalue reference.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span></p><pre class='codeblock'>
double&amp; rd2 = 2.0;              <span class='comment'>// error: not an lvalue and reference not <span class='tcode_in_codeblock'>const</span>
</span>int  i = 2;
double&amp; rd3 = i;                <span class='comment'>// error: type mismatch and reference not <span class='tcode_in_codeblock'>const</span>
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p><ul class='itemize'><li id='5.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#5.2.1'>(5.2.1)</a></div><p >If the initializer expression</p><ul class='itemize'><li id='5.2.1.1'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#5.2.1.1'>(5.2.1.1)</a></div><p >is an rvalue (but not a bit-field) or function lvalue and
“<span class='textit'>cv1</span> <span class='texttt'>T1</span>” is
reference-compatible with “<span class='textit'>cv2</span> <span class='texttt'>T2</span>”, or</p></li><li id='5.2.1.2'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#5.2.1.2'>(5.2.1.2)</a></div><p >has a class type (i.e., <span class='texttt'>T2</span> is a class type), where <span class='texttt'>T1</span>
is not reference-related to <span class='texttt'>T2</span>, and can be converted to
an rvalue or function lvalue of type “<span class='textit'>cv3</span> <span class='texttt'>T3</span>”,
where “<span class='textit'>cv1</span> <span class='texttt'>T1</span>” is
reference-compatible with “<span class='textit'>cv3</span> <span class='texttt'>T3</span>” (see <a href='over.match.ref'>[over.match.ref]</a>),</p></li></ul><p >then
the value of the initializer expression in the first case and
the result of the conversion in the second case
is called the converted initializer.
If the converted initializer is a prvalue,
its type <span class='texttt'>T4</span> is adjusted to type “<span class='textit'>cv1</span> <span class='texttt'>T4</span>” (<a href='conv.qual'>[conv.qual]</a>)
and the temporary materialization conversion (<a href='conv.rval'>[conv.rval]</a>) is applied.
In any case,
the reference is bound to the resulting glvalue
(or to an appropriate base class subobject).</p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span></p><pre class='codeblock'>
struct A { };
struct B : A { } b;
extern B f();
const A&amp; rca2 = f();                <span class='comment'>// bound to the <span class='tcode_in_codeblock'>A</span> subobject of the <span class='tcode_in_codeblock'>B</span> rvalue.
</span>A&amp;&amp; rra = f();                      <span class='comment'>// same as above
</span>struct X {
  operator B();
  operator int&amp;();
} x;
const A&amp; r = x;                     <span class='comment'>// bound to the <span class='tcode_in_codeblock'>A</span> subobject of the result of the conversion
</span>int i2 = 42;
int&amp;&amp; rri = static_cast&lt;int&amp;&amp;&gt;(i2); <span class='comment'>// bound directly to <span class='tcode_in_codeblock'>i2</span>
</span>B&amp;&amp; rrb = x;                        <span class='comment'>// bound directly to the result of <span class='tcode_in_codeblock'>operator B</span>
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></li><li id='5.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#5.2.2'>(5.2.2)</a></div><p >Otherwise:
</p><ul class='itemize'><li id='5.2.2.1'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#5.2.2.1'>(5.2.2.1)</a></div><p >If <span class='texttt'>T1</span> or <span class='texttt'>T2</span> is a class type and
<span class='texttt'>T1</span> is not reference-related to <span class='texttt'>T2</span>,
user-defined conversions are considered
using the rules for copy-initialization of an object of type 
“<span class='textit'>cv1</span> <span class='texttt'>T1</span>” by
user-defined conversion
(<a href='dcl.init'>[dcl.init]</a>, <a href='over.match.copy'>[over.match.copy]</a>, <a href='over.match.conv'>[over.match.conv]</a>);
the program is ill-formed if the corresponding non-reference
copy-initialization would be ill-formed. The result of the call to the
conversion function, as described for the non-reference
copy-initialization, is then used to direct-initialize the reference.
For this direct-initialization, user-defined conversions are not considered.
</p></li><li id='5.2.2.2'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#5.2.2.2'>(5.2.2.2)</a></div><p >Otherwise,
the initializer expression is implicitly converted to a prvalue
of type “<span class='textit'>cv1</span> <span class='texttt'>T1</span>”.
The temporary materialization conversion is applied and the reference is
bound to the result.
</p></li></ul><p >If
<span class='texttt'>T1</span>
is reference-related to
<span class='texttt'>T2</span>:
</p><ul class='itemize'><li id='5.2.2.3'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#5.2.2.3'>(5.2.2.3)</a></div><p ><span class='textit'>cv1</span>
shall be the same cv-qualification as, or greater cv-qualification than,
<span class='textit'>cv2</span>; and
</p></li><li id='5.2.2.4'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#5.2.2.4'>(5.2.2.4)</a></div><p >if the reference is an rvalue reference,
the initializer expression shall not be an lvalue.
</p></li></ul><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><pre class='codeblock'>
struct Banana { };
struct Enigma { operator const Banana(); };
struct Alaska { operator Banana&amp;(); };
void enigmatic() {
  typedef const Banana ConstBanana;
  Banana &amp;&amp;banana1 = ConstBanana(); <span class='comment'>// ill-formed
</span>  Banana &amp;&amp;banana2 = Enigma();      <span class='comment'>// ill-formed
</span>  Banana &amp;&amp;banana3 = Alaska();      <span class='comment'>// ill-formed
</span>}

const double&amp; rcd2 = 2;         <span class='comment'>// <span class='tcode_in_codeblock'>rcd2</span> refers to temporary with value <span class='tcode_in_codeblock'>2.0</span>
</span>double&amp;&amp; rrd = 2;               <span class='comment'>// <span class='tcode_in_codeblock'>rrd</span> refers to temporary with value <span class='tcode_in_codeblock'>2.0</span>
</span>const volatile int cvi = 1;
const int&amp; r2 = cvi;            <span class='comment'>// error: cv-qualifier dropped
</span>struct A { operator volatile int&amp;(); } a;
const int&amp; r3 = a;              <span class='comment'>// error: cv-qualifier dropped
</span>                                <span class='comment'>// from result of conversion function
</span>double d2 = 1.0;
double&amp;&amp; rrd2 = d2;             <span class='comment'>// error: initializer is lvalue of related type
</span>struct X { operator int&amp;(); };
int&amp;&amp; rri2 = X();               <span class='comment'>// error: result of conversion function is lvalue of related type
</span>int i3 = 2;
double&amp;&amp; rrd3 = i3;             <span class='comment'>// <span class='tcode_in_codeblock'>rrd3</span> refers to temporary with value <span class='tcode_in_codeblock'>2.0</span>
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]
</p></li></ul></li></ul><p >In all cases except the last
(i.e., implicitly converting the initializer expression
to the underlying type of the reference),
the reference is said to <a class='hidden_link' href='#def:bind_directly' id='def:bind_directly'><i>bind directly</i></a> to the
initializer expression.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/019585eb4da447ff6a41fa766056b4febff08c25/source/declarators.tex#L3671'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
<a href='class.temporary'>[class.temporary]</a> describes the lifetime of temporaries bound to references.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='footnote' id='footnote-106'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-106'>106)</a></div><p >This requires a conversion
function (<a href='class.conv.fct'>[class.conv.fct]</a>) returning a reference type.</p></div></div></div></body></html>