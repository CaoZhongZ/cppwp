<!DOCTYPE html><html lang='en'><head><title>[atomics]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><div id='atomics'><h1 ><a class='secnum' style='min-width:73pt'>29</a> Atomic operations library <a class='abbr_ref' href='./#atomics'>[atomics]</a></h1><div id='general'><h2 ><a class='secnum' href='#general' style='min-width:88pt'>29.1</a> General <a class='abbr_ref' href='atomics.general'>[atomics.general]</a></h2><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L6'>#</a></div><p >This Clause describes components for fine-grained atomic access. This access is
provided via operations on atomic objects.</p></div><div class='para' id='general-2'><div class='marginalizedparent'><a class='marginalized' href='#general-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L10'>#</a></div><p >The following subclauses describe atomics requirements and components for types
and operations, as summarized below.</p><div class='numberedTable' id='tab:atomics.lib.summary'>Table <a href='#tab:atomics.lib.summary'>137</a> — Atomics library summary<br><table ><tr class='rowsep'><td colspan='2' class='center'><b>Subclause</b></td><td class='left'>	<b>Header(s)</b>	</td></tr><tr class='capsep'><td class='left'> 
<a href='atomics.order'>[atomics.order]</a> </td><td class='left'> Order and Consistency   </td><td class='left'>
  </td></tr><tr ><td class='left'>
<a href='atomics.lockfree'>[atomics.lockfree]</a>  </td><td class='left'> Lock-free Property   </td><td class='left'>
  </td></tr><tr ><td class='left'>
<a href='atomics.types.generic'>[atomics.types.generic]</a> </td><td class='left'> Atomic Types   </td><td class='left'> <span class='texttt'>&lt;atomic&gt;</span>
  </td></tr><tr ><td class='left'>
<a href='atomics.types.operations'>[atomics.types.operations]</a>  </td><td class='left'> Operations on Atomic Types </td><td class='left'>
  </td></tr><tr ><td class='left'>
<a href='atomics.flag'>[atomics.flag]</a>  </td><td class='left'> Flag Type and Operations   </td><td class='left'>
  </td></tr><tr ><td class='left'>
<a href='atomics.fences'>[atomics.fences]</a>  </td><td class='left'> Fences   </td><td class='left'>
  </td></tr></table></div></div></div><div id='syn'><h2 ><a class='secnum' href='#syn' style='min-width:88pt'>29.2</a> Header <span class='texttt'>&lt;atomic&gt;</span> synopsis <a class='abbr_ref' href='atomics.syn'>[atomics.syn]</a></h2><p ><span class='indexparent'><a class='index' id='atomic'></a></span><span class='indexparent'><a class='index' id='atomic'></a></span></p><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='atomics.order'>[atomics.order]</a>, order and consistency
</span>  enum memory_order;
  template &lt;class T&gt;
    T kill_dependency(T y) noexcept;

  <span class='comment'>// <a href='atomics.lockfree'>[atomics.lockfree]</a>, lock-free property
</span>  #define ATOMIC_BOOL_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_CHAR_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_CHAR16_T_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_CHAR32_T_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_WCHAR_T_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_SHORT_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_INT_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_LONG_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_LLONG_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
  #define ATOMIC_POINTER_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>

  <span class='comment'>// <a href='atomics.types.generic'>[atomics.types.generic]</a>, generic types
</span>  template&lt;class T&gt; struct atomic;
  template&lt;&gt; struct atomic&lt;<span class='textit'>integral</span>&gt;;
  template&lt;class T&gt; struct atomic&lt;T*&gt;;

  <span class='comment'>// <a href='atomics.types.operations.general'>[atomics.types.operations.general]</a>, general operations on atomic types
</span>  <span class='comment'>// In the following declarations, <span class='tcode_in_codeblock'><span class='textit'>atomic-type</span></span> is either <span class='tcode_in_codeblock'>atomic&lt;T&gt;</span> or a named base class
</span>  <span class='comment'>// for <span class='tcode_in_codeblock'>T</span> from Table <a href='#tab:atomics.integral'>[tab:atomics.integral]</a> or inferred from Table <a href='#tab:atomics.typedefs'>[tab:atomics.typedefs]</a> or from <span class='tcode_in_codeblock'>bool</span>. If it is <span class='tcode_in_codeblock'>atomic&lt;T&gt;</span>,
</span>  <span class='comment'>// then the declaration is a template declaration prefixed with <span class='tcode_in_codeblock'>template &lt;class T&gt;</span>.
</span>  bool atomic_is_lock_free(const volatile <span class='textit'>atomic-type</span>*) noexcept;
  bool atomic_is_lock_free(const <span class='textit'>atomic-type</span>*) noexcept;
  void atomic_init(volatile <span class='textit'>atomic-type</span>*, T) noexcept;
  void atomic_init(<span class='textit'>atomic-type</span>*, T) noexcept;
  void atomic_store(volatile <span class='textit'>atomic-type</span>*, T) noexcept;
  void atomic_store(<span class='textit'>atomic-type</span>*, T) noexcept;
  void atomic_store_explicit(volatile <span class='textit'>atomic-type</span>*, T, memory_order) noexcept;
  void atomic_store_explicit(<span class='textit'>atomic-type</span>*, T, memory_order) noexcept;
  T atomic_load(const volatile <span class='textit'>atomic-type</span>*) noexcept;
  T atomic_load(const <span class='textit'>atomic-type</span>*) noexcept;
  T atomic_load_explicit(const volatile <span class='textit'>atomic-type</span>*, memory_order) noexcept;
  T atomic_load_explicit(const <span class='textit'>atomic-type</span>*, memory_order) noexcept;
  T atomic_exchange(volatile <span class='textit'>atomic-type</span>*, T) noexcept;
  T atomic_exchange(<span class='textit'>atomic-type</span>*, T) noexcept;
  T atomic_exchange_explicit(volatile <span class='textit'>atomic-type</span>*, T, memory_order) noexcept;
  T atomic_exchange_explicit(<span class='textit'>atomic-type</span>*, T, memory_order) noexcept;
  bool atomic_compare_exchange_weak(volatile <span class='textit'>atomic-type</span>*, T*, T) noexcept;
  bool atomic_compare_exchange_weak(<span class='textit'>atomic-type</span>*, T*, T) noexcept;
  bool atomic_compare_exchange_strong(volatile <span class='textit'>atomic-type</span>*, T*, T) noexcept;
  bool atomic_compare_exchange_strong(<span class='textit'>atomic-type</span>*, T*, T) noexcept;
  bool atomic_compare_exchange_weak_explicit(volatile <span class='textit'>atomic-type</span>*, T*, T, 
    memory_order, memory_order) noexcept;
  bool atomic_compare_exchange_weak_explicit(<span class='textit'>atomic-type</span>*, T*, T,
    memory_order, memory_order) noexcept;
  bool atomic_compare_exchange_strong_explicit(volatile <span class='textit'>atomic-type</span>*, T*, T,
    memory_order, memory_order) noexcept;
  bool atomic_compare_exchange_strong_explicit(<span class='textit'>atomic-type</span>*, T*, T,
    memory_order, memory_order) noexcept;

  <span class='comment'>// <a href='atomics.types.operations.templ'>[atomics.types.operations.templ]</a>, templated operations on atomic types
</span>  template &lt;class T&gt;
    T atomic_fetch_add(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_add(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_add_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_add_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_sub(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_sub(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_sub_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_sub_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_and(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_and(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_and_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_and_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_or(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_or(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_or_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_or_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_xor(volatile atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_xor(atomic&lt;T&gt;*, T) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_xor_explicit(volatile atomic&lt;T&gt;*, T, memory_order) noexcept;
  template &lt;class T&gt;
    T atomic_fetch_xor_explicit(atomic&lt;T&gt;*, T, memory_order) noexcept;

  <span class='comment'>// <a href='atomics.types.operations.arith'>[atomics.types.operations.arith]</a>, arithmetic operations on atomic types
</span>  <span class='comment'>// In the following declarations, <span class='tcode_in_codeblock'><span class='textit'>atomic-integral</span></span> is either <span class='tcode_in_codeblock'>atomic&lt;T&gt;</span> or a named base class
</span>  <span class='comment'>// for <span class='tcode_in_codeblock'>T</span> from Table <a href='#tab:atomics.integral'>[tab:atomics.integral]</a> or inferred from Table <a href='#tab:atomics.typedefs'>[tab:atomics.typedefs]</a>. If it is <span class='tcode_in_codeblock'>atomic&lt;T&gt;</span>, then the declaration
</span>  <span class='comment'>// is a template specialization declaration prefixed with <span class='tcode_in_codeblock'>template &lt;&gt;</span>.
</span>  <span class='textit'>integral</span> atomic_fetch_add(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_add(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_add_explicit(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_add_explicit(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_sub(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_sub(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_sub_explicit(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_sub_explicit(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_and(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_and(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_and_explicit(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_and_explicit(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_or(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_or(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_or_explicit(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_or_explicit(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_xor(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_xor(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>) noexcept;
  <span class='textit'>integral</span> atomic_fetch_xor_explicit(volatile <span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;
  <span class='textit'>integral</span> atomic_fetch_xor_explicit(<span class='textit'>atomic-integral</span>*, <span class='textit'>integral</span>, memory_order) noexcept;

  <span class='comment'>// <a href='atomics.types.operations.pointer'>[atomics.types.operations.pointer]</a>, non-member overloads for atomic&lt;T*&gt;
</span>  template &lt;class T&gt;
    T* atomic_fetch_add(volatile atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_add(atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_add_explicit(volatile atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_add_explicit(atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_sub(volatile atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_sub(atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_sub_explicit(volatile atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
  template &lt;class T&gt;
    T* atomic_fetch_sub_explicit(atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;

  <span class='comment'>// <a href='atomics.types.operations.req'>[atomics.types.operations.req]</a>, initialization
</span>  #define ATOMIC_VAR_INIT(value) <span class='textit'><span class='texttt'>see below</span></span>

  <span class='comment'>// <a href='atomics.flag'>[atomics.flag]</a>, flag type and operations
</span>  struct atomic_flag;
  bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
  bool atomic_flag_test_and_set(atomic_flag*) noexcept;
  bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear(volatile atomic_flag*) noexcept;
  void atomic_flag_clear(atomic_flag*) noexcept;
  void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;
  #define ATOMIC_FLAG_INIT <span class='textit'><span class='texttt'>see below</span></span>

  <span class='comment'>// <a href='atomics.fences'>[atomics.fences]</a>, fences
</span>  extern "C" void atomic_thread_fence(memory_order) noexcept;
  extern "C" void atomic_signal_fence(memory_order) noexcept;
}</pre></div><div id='order'><h2 ><a class='secnum' href='#order' style='min-width:88pt'>29.3</a> Order and consistency <a class='abbr_ref' href='atomics.order'>[atomics.order]</a></h2><pre class='codeblock'>
namespace std {
  enum memory_order {
    memory_order_relaxed, memory_order_consume, memory_order_acquire, 
    memory_order_release, memory_order_acq_rel, memory_order_seq_cst
  };
}</pre><div class='para' id='order-1'><div class='marginalizedparent'><a class='marginalized' href='#order-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L207'>#</a></div><p >The enumeration <span class='texttt'>memory_&shy;order</span> specifies the detailed regular
(non-atomic) memory synchronization order as defined in
<a href='intro.multithread'>[intro.multithread]</a> and may provide for operation ordering. Its
enumerated values and their meanings are as follows:</p><ul class='itemize'><li id='order-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#order-1.1'>(1.1)</a></div><p ><span class='texttt'>memory_&shy;order_&shy;relaxed</span>: no operation orders memory.</p></li><li id='order-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#order-1.2'>(1.2)</a></div><p ><span class='texttt'>memory_&shy;order_&shy;release</span>, <span class='texttt'>memory_&shy;order_&shy;acq_&shy;rel</span>, and
<span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span>: a store operation performs a release operation on the
affected memory location.</p></li><li id='order-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#order-1.3'>(1.3)</a></div><p ><span class='texttt'>memory_&shy;order_&shy;consume</span>: a load operation performs a consume operation on the
affected memory location.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> Prefer <span class='texttt'>memory_&shy;order_&shy;acquire</span>, which provides stronger guarantees
than <span class='texttt'>memory_&shy;order_&shy;consume</span>. Implementations have found it infeasible
to provide performance better than that of <span class='texttt'>memory_&shy;order_&shy;acquire</span>.
Specification revisions are under consideration. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></li><li id='order-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#order-1.4'>(1.4)</a></div><p ><span class='texttt'>memory_&shy;order_&shy;acquire</span>, <span class='texttt'>memory_&shy;order_&shy;acq_&shy;rel</span>, and
<span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span>: a load operation performs an acquire operation on the
affected memory location.
</p></li></ul><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> Atomic operations specifying <span class='texttt'>memory_&shy;order_&shy;relaxed</span> are relaxed
with respect to memory ordering. Implementations must still guarantee that any
given atomic access to a particular atomic object be indivisible with respect
to all other atomic accesses to that object. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='order-2'><div class='marginalizedparent'><a class='marginalized' href='#order-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L237'>#</a></div><p >An atomic operation <span class='textit'>A</span> that performs a release operation on an atomic
object <span class='textit'>M</span> synchronizes with an atomic operation <span class='textit'>B</span> that performs
an acquire operation on <span class='textit'>M</span> and takes its value from any side effect in the
release sequence headed by <span class='textit'>A</span>.</p></div><div class='para' id='order-3'><div class='marginalizedparent'><a class='marginalized' href='#order-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L243'>#</a></div><p >There shall be a single total order <span class='textit'>S</span> on all <span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span>
operations, consistent with the “happens before” order and modification orders for all
affected locations, such that each <span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span> operation
<span class='textit'>B</span> that loads a
value from an atomic object <span class='textit'>M</span>
observes one of the following values:</p><ul class='itemize'><li id='order-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#order-3.1'>(3.1)</a></div><p >the result of the last modification <span class='textit'>A</span> of <span class='textit'>M</span> that precedes
<span class='textit'>B</span> in <span class='textit'>S</span>, if it exists, or</p></li><li id='order-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#order-3.2'>(3.2)</a></div><p >if <span class='textit'>A</span> exists, the result of some modification of <span class='textit'>M</span>
that is not
<span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span> and that does not happen before <span class='textit'>A</span>, or</p></li><li id='order-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#order-3.3'>(3.3)</a></div><p >if <span class='textit'>A</span> does not exist, the result of some modification of <span class='textit'>M</span>
that is not
<span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span>.
</p></li></ul><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> Although it is not explicitly required that <span class='textit'>S</span> include locks, it can
always be extended to an order that does include lock and unlock operations, since the
ordering between those is already included in the “happens before” ordering. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='order-4'><div class='marginalizedparent'><a class='marginalized' href='#order-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L268'>#</a></div><p >For an atomic operation <span class='textit'>B</span> that reads the value of an atomic object <span class='textit'>M</span>,
if there is a <span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span> fence <span class='textit'>X</span> sequenced before <span class='textit'>B</span>,
then <span class='textit'>B</span> observes either the last <span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span> modification of
<span class='textit'>M</span> preceding <span class='textit'>X</span> in the total order <span class='textit'>S</span> or a later modification of
<span class='textit'>M</span> in its modification order.</p></div><div class='para' id='order-5'><div class='marginalizedparent'><a class='marginalized' href='#order-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L275'>#</a></div><p >For atomic operations <span class='textit'>A</span> and <span class='textit'>B</span> on an atomic object <span class='textit'>M</span>, where
<span class='textit'>A</span> modifies <span class='textit'>M</span> and <span class='textit'>B</span> takes its value, if there is a
<span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span> fence <span class='textit'>X</span> such that <span class='textit'>A</span> is sequenced before
<span class='textit'>X</span> and <span class='textit'>B</span> follows <span class='textit'>X</span> in <span class='textit'>S</span>, then <span class='textit'>B</span> observes
either the effects of <span class='textit'>A</span> or a later modification of <span class='textit'>M</span> in its
modification order.</p></div><div class='para' id='order-6'><div class='marginalizedparent'><a class='marginalized' href='#order-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L283'>#</a></div><p >For atomic operations <span class='textit'>A</span> and <span class='textit'>B</span> on an atomic object <span class='textit'>M</span>, where
<span class='textit'>A</span> modifies <span class='textit'>M</span> and <span class='textit'>B</span> takes its value, if there are
<span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span> fences <span class='textit'>X</span> and <span class='textit'>Y</span> such that <span class='textit'>A</span> is
sequenced before <span class='textit'>X</span>, <span class='textit'>Y</span> is sequenced before <span class='textit'>B</span>, and <span class='textit'>X</span>
precedes <span class='textit'>Y</span> in <span class='textit'>S</span>, then <span class='textit'>B</span> observes either the effects of
<span class='textit'>A</span> or a later modification of <span class='textit'>M</span> in its modification order.</p></div><div class='para' id='order-7'><div class='marginalizedparent'><a class='marginalized' href='#order-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L291'>#</a></div><p >For atomic modifications <span class='textit'>A</span> and <span class='textit'>B</span> of an atomic object <span class='textit'>M</span>,
<span class='textit'>B</span> occurs later than <span class='textit'>A</span> in the modification order of <span class='textit'>M</span> if:</p><ul class='itemize'><li id='order-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#order-7.1'>(7.1)</a></div><p >there is a <span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span> fence <span class='textit'>X</span> such that <span class='textit'>A</span>
is sequenced before <span class='textit'>X</span>, and <span class='textit'>X</span> precedes <span class='textit'>B</span> in <span class='textit'>S</span>, or
</p></li><li id='order-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#order-7.2'>(7.2)</a></div><p >there is a <span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span> fence <span class='textit'>Y</span> such that <span class='textit'>Y</span>
is sequenced before <span class='textit'>B</span>, and <span class='textit'>A</span> precedes <span class='textit'>Y</span> in <span class='textit'>S</span>, or
</p></li><li id='order-7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#order-7.3'>(7.3)</a></div><p >there are <span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span> fences <span class='textit'>X</span> and <span class='textit'>Y</span> such that <span class='textit'>A</span>
is sequenced before <span class='textit'>X</span>, <span class='textit'>Y</span> is sequenced before <span class='textit'>B</span>,
and <span class='textit'>X</span> precedes <span class='textit'>Y</span> in <span class='textit'>S</span>.
</p></li></ul></div><div class='para' id='order-8'><div class='marginalizedparent'><a class='marginalized' href='#order-8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L306'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> <span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span> ensures sequential consistency only for a
program that is free of data races and uses exclusively <span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span>
operations. Any use of weaker ordering will invalidate this guarantee unless extreme
care is used. In particular, <span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span> fences ensure a total order
only for the fences themselves. Fences cannot, in general, be used to restore sequential
consistency for atomic operations with weaker ordering specifications. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='order-9'><div class='marginalizedparent'><a class='marginalized' href='#order-9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L314'>#</a></div><p >Implementations should ensure that no “out-of-thin-air” values are computed that
circularly depend on their own computation.</p><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> For example, with <span class='texttt'>x</span> and <span class='texttt'>y</span> initially zero,</p><pre class='codeblock'>
<span class='comment'>// Thread 1:
</span>r1 = y.load(memory_order_relaxed);
x.store(r1, memory_order_relaxed);</pre><pre class='codeblock'>
<span class='comment'>// Thread 2:
</span>r2 = x.load(memory_order_relaxed);
y.store(r2, memory_order_relaxed);</pre><p >should not produce <span class='texttt'>r1 == r2 == 42</span>, since the store of 42 to <span class='texttt'>y</span> is only
possible if the store to <span class='texttt'>x</span> stores <span class='texttt'>42</span>, which circularly depends on the
store to <span class='texttt'>y</span> storing <span class='texttt'>42</span>. Note that without this restriction, such an
execution is possible.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='order-10'><div class='marginalizedparent'><a class='marginalized' href='#order-10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L338'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> The recommendation similarly disallows <span class='texttt'>r1 == r2 == 42</span> in the
following example, with <span class='texttt'>x</span> and <span class='texttt'>y</span> again initially zero:</p><pre class='codeblock'>
<span class='comment'>// Thread 1:
</span>r1 = x.load(memory_order_relaxed);
if (r1 == 42) y.store(42, memory_order_relaxed);</pre><pre class='codeblock'>
<span class='comment'>// Thread 2:
</span>r2 = y.load(memory_order_relaxed);
if (r2 == 42) x.store(42, memory_order_relaxed);</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='order-11'><div class='marginalizedparent'><a class='marginalized' href='#order-11'>11</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L356'>#</a></div><p >Atomic read-modify-write operations shall always read the last value
(in the modification order) written before the write associated with
the read-modify-write operation.</p></div><div class='para' id='order-12'><div class='marginalizedparent'><a class='marginalized' href='#order-12'>12</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L361'>#</a></div><p >Implementations should make atomic stores visible to atomic loads within a reasonable
amount of time.</p><p ><div id='kill_dependency'>
<code class='itemdecl'>template &lt;class T&gt;
  T kill_dependency(T y) noexcept;
</code>
</div></p></div><div class='itemdescr'></div><div class='para' id='order-13'><div class='marginalizedparent'><a class='marginalized' href='#order-13'>13</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L373'>#</a></div><p ><span class='textit'>Effects:</span> The argument does not
<a href='intro.multithread#def:carries_a_dependency'>carry a dependency</a>
to the return value.</p></div></div><div class='para' id='order-14'><div class='marginalizedparent'><a class='marginalized' href='#order-14'>14</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L378'>#</a></div><p ><span class='textit'>Returns:</span> <span class='texttt'>y</span>.
</p></div></div></div><div id='lockfree'><h2 ><a class='secnum' href='#lockfree' style='min-width:88pt'>29.4</a> Lock-free property <a class='abbr_ref' href='atomics.lockfree'>[atomics.lockfree]</a></h2><p ><span class='indexparent'><a class='index' id='ATOMIC_BOOL_LOCK_FREE'></a></span><span class='indexparent'><a class='index' id='ATOMIC_CHAR_LOCK_FREE'></a></span><span class='indexparent'><a class='index' id='ATOMIC_CHAR16_T_LOCK_FREE'></a></span><span class='indexparent'><a class='index' id='ATOMIC_CHAR32_T_LOCK_FREE'></a></span><span class='indexparent'><a class='index' id='ATOMIC_WCHAR_T_LOCK_FREE'></a></span><span class='indexparent'><a class='index' id='ATOMIC_SHORT_LOCK_FREE'></a></span><span class='indexparent'><a class='index' id='ATOMIC_INT_LOCK_FREE'></a></span><span class='indexparent'><a class='index' id='ATOMIC_LONG_LOCK_FREE'></a></span><span class='indexparent'><a class='index' id='ATOMIC_LLONG_LOCK_FREE'></a></span><span class='indexparent'><a class='index' id='ATOMIC_POINTER_LOCK_FREE'></a></span><span class='indexparent'><a class='index' id='values_of_various_ATOMIC_..._LOCK_FREE_macros'></a></span>
</p><pre class='codeblock'>
#define ATOMIC_BOOL_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
#define ATOMIC_CHAR_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
#define ATOMIC_CHAR16_T_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
#define ATOMIC_CHAR32_T_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
#define ATOMIC_WCHAR_T_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
#define ATOMIC_SHORT_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
#define ATOMIC_INT_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
#define ATOMIC_LONG_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
#define ATOMIC_LLONG_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span>
#define ATOMIC_POINTER_LOCK_FREE <span class='textit'><span class='texttt'>unspecified</span></span></pre><div class='para' id='lockfree-1'><div class='marginalizedparent'><a class='marginalized' href='#lockfree-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L409'>#</a></div><p >The <span class='texttt'>ATOMIC_&shy;..._&shy;LOCK_&shy;FREE</span> macros indicate the lock-free property of the
corresponding atomic types, with the signed and unsigned variants grouped
together. The properties also apply to the corresponding (partial) specializations of the
<span class='texttt'>atomic</span> template. A value of 0 indicates that the types are never
lock-free. A value of 1 indicates that the types are sometimes lock-free. A
value of 2 indicates that the types are always lock-free.</p></div><div class='para' id='lockfree-2'><div class='marginalizedparent'><a class='marginalized' href='#lockfree-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L417'>#</a></div><p >The function <span class='texttt'>atomic_&shy;is_&shy;lock_&shy;free</span> (<a href='atomics.types.operations'>[atomics.types.operations]</a>)
indicates whether the object is lock-free. In any given program execution, the
result of the lock-free query shall be consistent for all pointers of the same
type.</p></div><div class='para' id='lockfree-3'><div class='marginalizedparent'><a class='marginalized' href='#lockfree-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L423'>#</a></div><p >Atomic operations that are not lock-free are considered to potentially
block (<a href='intro.progress'>[intro.progress]</a>).</p></div><div class='para' id='lockfree-4'><div class='marginalizedparent'><a class='marginalized' href='#lockfree-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L427'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> Operations that are lock-free should also be address-free. That is,
atomic operations on the same memory location via two different addresses will
communicate atomically. The implementation should not depend on any
per-process state. This restriction enables communication  by memory that is
mapped into a process more than once and by memory that is shared between two
processes. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div id='types.generic'><h2 ><a class='secnum' href='#types.generic' style='min-width:88pt'>29.5</a> Atomic types <a class='abbr_ref' href='atomics.types.generic'>[atomics.types.generic]</a></h2><p ><span class='indexparent'><a class='index' id='atomic'></a></span><span class='indexparent'><a class='index' id='atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; struct atomic {
    static constexpr bool is_always_lock_free = <span class='indexparent'><a class='index' id='whether_a_given_atomic_type&#39;s_operations_are_always_lock_free'></a></span><span class='textit'>implementation-defined</span>;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(T, memory_order = memory_order_seq_cst) noexcept;
    T load(memory_order = memory_order_seq_cst) const volatile noexcept;
    T load(memory_order = memory_order_seq_cst) const noexcept;
    operator T() const volatile noexcept;
    operator T() const noexcept;
    T exchange(T, memory_order = memory_order_seq_cst) volatile noexcept;
    T exchange(T, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    T operator=(T) volatile noexcept;
    T operator=(T) noexcept;
  };

  template &lt;&gt; struct atomic&lt;<span class='textit'>integral</span>&gt; {
    static constexpr bool is_always_lock_free = <span class='indexparent'><a class='index' id='whether_a_given_atomic_type&#39;s_operations_are_always_lock_free'></a></span><span class='textit'>implementation-defined</span>;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> load(memory_order = memory_order_seq_cst) const volatile noexcept;
    <span class='textit'>integral</span> load(memory_order = memory_order_seq_cst) const noexcept;
    operator <span class='textit'>integral</span>() const volatile noexcept;
    operator <span class='textit'>integral</span>() const noexcept;
    <span class='textit'>integral</span> exchange(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> exchange(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order, memory_order) noexcept;
    bool compare_exchange_strong(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                                 memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                                 memory_order, memory_order) noexcept;
    bool compare_exchange_weak(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_add(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_add(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_sub(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_sub(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_and(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_and(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_or(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_or(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_xor(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_xor(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(<span class='textit'>integral</span>) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    <span class='textit'>integral</span> operator=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator=(<span class='textit'>integral</span>) noexcept;

    <span class='textit'>integral</span> operator++(int) volatile noexcept;
    <span class='textit'>integral</span> operator++(int) noexcept;
    <span class='textit'>integral</span> operator--(int) volatile noexcept;
    <span class='textit'>integral</span> operator--(int) noexcept;
    <span class='textit'>integral</span> operator++() volatile noexcept;
    <span class='textit'>integral</span> operator++() noexcept;
    <span class='textit'>integral</span> operator--() volatile noexcept;
    <span class='textit'>integral</span> operator--() noexcept;
    <span class='textit'>integral</span> operator+=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator+=(<span class='textit'>integral</span>) noexcept;
    <span class='textit'>integral</span> operator-=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator-=(<span class='textit'>integral</span>) noexcept;
    <span class='textit'>integral</span> operator&amp;=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator&amp;=(<span class='textit'>integral</span>) noexcept;
    <span class='textit'>integral</span> operator|=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator|=(<span class='textit'>integral</span>) noexcept;
    <span class='textit'>integral</span> operator^=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator^=(<span class='textit'>integral</span>) noexcept;
  };

  template &lt;class T&gt; struct atomic&lt;T*&gt; {
    static constexpr bool is_always_lock_free = <span class='indexparent'><a class='index' id='whether_a_given_atomic_type&#39;s_operations_are_always_lock_free'></a></span><span class='textit'>implementation-defined</span>;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T*, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(T*, memory_order = memory_order_seq_cst) noexcept;
    T* load(memory_order = memory_order_seq_cst) const volatile noexcept;
    T* load(memory_order = memory_order_seq_cst) const noexcept;
    operator T*() const volatile noexcept;
    operator T*() const noexcept;
    T* exchange(T*, memory_order = memory_order_seq_cst) volatile noexcept;
    T* exchange(T*, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order = memory_order_seq_cst) noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T*) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    T* operator=(T*) volatile noexcept;
    T* operator=(T*) noexcept;

    T* operator++(int) volatile noexcept;
    T* operator++(int) noexcept;
    T* operator--(int) volatile noexcept;
    T* operator--(int) noexcept;
    T* operator++() volatile noexcept;
    T* operator++() noexcept;
    T* operator--() volatile noexcept;
    T* operator--() noexcept;
    T* operator+=(ptrdiff_t) volatile noexcept;
    T* operator+=(ptrdiff_t) noexcept;
    T* operator-=(ptrdiff_t) volatile noexcept;
    T* operator-=(ptrdiff_t) noexcept;
  };
}</pre><p ><span class='indexparent'><a class='index' id='atomic'></a></span></p><div class='para' id='types.generic-1'><div class='marginalizedparent'><a class='marginalized' href='#types.generic-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L589'>#</a></div><p >There is a generic class template <span class='texttt'>atomic&lt;T&gt;</span>. The type of the template argument
<span class='texttt'>T</span> shall be trivially copyable (<a href='basic.types'>[basic.types]</a>). [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> Type arguments that are
not also statically initializable may be difficult to use. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='types.generic-2'><div class='marginalizedparent'><a class='marginalized' href='#types.generic-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L594'>#</a></div><p >The semantics of the operations on specializations of <span class='texttt'>atomic</span> are defined
in <a href='atomics.types.operations'>[atomics.types.operations]</a>.</p></div><div class='para' id='types.generic-3'><div class='marginalizedparent'><a class='marginalized' href='#types.generic-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L598'>#</a></div><p >Specializations and instantiations of the <span class='texttt'>atomic</span> template shall have a deleted copy constructor, a deleted
copy assignment operator, and a constexpr value constructor.</p><p ><span class='indexparent'><a class='index' id='atomic<integral>'></a></span></p></div><div class='para' id='types.generic-4'><div class='marginalizedparent'><a class='marginalized' href='#types.generic-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L603'>#</a></div><p >There shall be explicit specializations of the <span class='texttt'>atomic</span>
template for the integral types
<span class='texttt'>char</span>,
<span class='texttt'>signed char</span>,
<span class='texttt'>unsigned char</span>,
<span class='texttt'>short</span>,
<span class='texttt'>unsigned short</span>,
<span class='texttt'>int</span>,
<span class='texttt'>unsigned int</span>,
<span class='texttt'>long</span>,
<span class='texttt'>unsigned long</span>,
<span class='texttt'>long long</span>,
<span class='texttt'>unsigned long long</span>,
<span class='texttt'>char16_&shy;t</span>,
<span class='texttt'>char32_&shy;t</span>,
<span class='texttt'>wchar_&shy;t</span>,
and any other types needed by the typedefs in the header <span class='texttt'>&lt;cstdint&gt;</span>.
For each integral type <span class='texttt'><span class='textit'>integral</span></span>, the specialization
<span class='texttt'>atomic&lt;<span class='textit'>integral</span>&gt;</span> provides additional atomic operations appropriate to integral types.
There shall be a specialization <span class='texttt'>atomic&lt;bool&gt;</span> which provides the general
atomic operations as specified in <a href='atomics.types.operations.general'>[atomics.types.operations.general]</a>.</p></div><div class='para' id='types.generic-5'><div class='marginalizedparent'><a class='marginalized' href='#types.generic-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L626'>#</a></div><p >The atomic integral specializations and the specialization <span class='texttt'>atomic&lt;bool&gt;</span>
shall be standard-layout structs. They shall each have a trivial default constructor
and a trivial destructor. They shall each support aggregate initialization
syntax.</p><p ><span class='indexparent'><a class='index' id='atomic<T*>'></a></span></p></div><div class='para' id='types.generic-6'><div class='marginalizedparent'><a class='marginalized' href='#types.generic-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L633'>#</a></div><p >There shall be pointer partial specializations of the <span class='texttt'>atomic</span> class template.
These specializations shall be standard-layout structs.
They shall each have a trivial default constructor and a trivial destructor.
They shall each support aggregate initialization syntax.</p><p ><span class='indexparent'><a class='index' id='atomic_bool'></a></span></p></div><div class='para' id='types.generic-7'><div class='marginalizedparent'><a class='marginalized' href='#types.generic-7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L640'>#</a></div><p >There shall be named types corresponding to the integral specializations of
<span class='texttt'>atomic</span>, as specified in Table <a href='#tab:atomics.integral'>[tab:atomics.integral]</a>, and a named type
<span class='texttt'>atomic_&shy;bool</span> corresponding to the specified <span class='texttt'>atomic&lt;bool&gt;</span>. Each named
type is either a typedef to the corresponding specialization or a base class of the
corresponding specialization. If it is a base class, it shall support the same
member functions as the corresponding specialization.</p><p ><span class='indexparent'><a class='index' id='atomic_char'></a></span><span class='indexparent'><a class='index' id='atomic_schar'></a></span><span class='indexparent'><a class='index' id='atomic_uchar'></a></span><span class='indexparent'><a class='index' id='atomic_short'></a></span><span class='indexparent'><a class='index' id='atomic_ushort'></a></span><span class='indexparent'><a class='index' id='atomic_int'></a></span><span class='indexparent'><a class='index' id='atomic_uint'></a></span><span class='indexparent'><a class='index' id='atomic_long'></a></span><span class='indexparent'><a class='index' id='atomic_ulong'></a></span><span class='indexparent'><a class='index' id='atomic_llong'></a></span><span class='indexparent'><a class='index' id='atomic_ullong'></a></span><span class='indexparent'><a class='index' id='atomic_char16_t'></a></span><span class='indexparent'><a class='index' id='atomic_char32_t'></a></span><span class='indexparent'><a class='index' id='atomic_wchar_t'></a></span>
 </p><div class='numberedTable' id='tab:atomics.integral'>Table <a href='#tab:atomics.integral'>138</a> — Named atomic types<br><table ><tr class='rowsep'><td class='left'>
<b>Named atomic type</b> </td><td class='left'> <b>Corresponding non-atomic type</b> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>atomic_&shy;char</span>     </td><td class='left'> <span class='texttt'>char</span>                    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;schar</span>    </td><td class='left'> <span class='texttt'>signed char</span>             </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uchar</span>    </td><td class='left'> <span class='texttt'>unsigned char</span>           </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;short</span>    </td><td class='left'> <span class='texttt'>short</span>                   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;ushort</span>   </td><td class='left'> <span class='texttt'>unsigned short</span>          </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int</span>      </td><td class='left'> <span class='texttt'>int</span>                     </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint</span>     </td><td class='left'> <span class='texttt'>unsigned int</span>            </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;long</span>     </td><td class='left'> <span class='texttt'>long</span>                    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;ulong</span>    </td><td class='left'> <span class='texttt'>unsigned long</span>           </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;llong</span>    </td><td class='left'> <span class='texttt'>long long</span>               </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;ullong</span>   </td><td class='left'> <span class='texttt'>unsigned long long</span>      </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;char16_&shy;t</span> </td><td class='left'> <span class='texttt'>char16_&shy;t</span>                </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;char32_&shy;t</span> </td><td class='left'> <span class='texttt'>char32_&shy;t</span>                </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;wchar_&shy;t</span>  </td><td class='left'> <span class='texttt'>wchar_&shy;t</span>                 </td></tr></table></div></div><div class='para' id='types.generic-8'><div class='marginalizedparent'><a class='marginalized' href='#types.generic-8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L683'>#</a></div><p >There shall be atomic typedefs corresponding to non-atomic typedefs as
specified in Table <a href='#tab:atomics.typedefs'>[tab:atomics.typedefs]</a>.
<span class='texttt'>atomic_&shy;int<span class='math'><span class='mathalpha'>N</span></span>_&shy;t</span>, <span class='texttt'>atomic_&shy;uint<span class='math'><span class='mathalpha'>N</span></span>_&shy;t</span>,
<span class='texttt'>atomic_&shy;intptr_&shy;t</span>, and <span class='texttt'>atomic_&shy;uintptr_&shy;t</span>
shall be defined if and only if
<span class='texttt'>int<span class='math'><span class='mathalpha'>N</span></span>_&shy;t</span>, <span class='texttt'>uint<span class='math'><span class='mathalpha'>N</span></span>_&shy;t</span>,
<span class='texttt'>intptr_&shy;t</span>, and <span class='texttt'>uintptr_&shy;t</span>
are defined, respectively.</p><p ><span class='indexparent'><a class='index' id='atomic_int8_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint8_t'></a></span><span class='indexparent'><a class='index' id='atomic_int16_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint16_t'></a></span><span class='indexparent'><a class='index' id='atomic_int32_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint32_t'></a></span><span class='indexparent'><a class='index' id='atomic_int64_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint64_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_least8_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_least8_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_least16_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_least16_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_least32_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_least32_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_least64_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_least64_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_fast8_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_fast8_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_fast16_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_fast16_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_fast32_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_fast32_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_fast64_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_fast64_t'></a></span><span class='indexparent'><a class='index' id='atomic_intptr_t'></a></span><span class='indexparent'><a class='index' id='atomic_uintptr_t'></a></span><span class='indexparent'><a class='index' id='atomic_size_t'></a></span><span class='indexparent'><a class='index' id='atomic_ptrdiff_t'></a></span><span class='indexparent'><a class='index' id='atomic_intmax_t'></a></span><span class='indexparent'><a class='index' id='atomic_uintmax_t'></a></span>
 </p><div class='numberedTable' id='tab:atomics.typedefs'>Table <a href='#tab:atomics.typedefs'>139</a> — Atomic typedefs<br><table ><tr class='rowsep'><td class='left'>
<b>Atomic typedef</b> </td><td class='left'> <b>Corresponding non-atomic typedef</b> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>atomic_&shy;int8_&shy;t</span>         </td><td class='left'> <span class='texttt'>int8_&shy;t</span>          </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint8_&shy;t</span>        </td><td class='left'> <span class='texttt'>uint8_&shy;t</span>         </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int16_&shy;t</span>        </td><td class='left'> <span class='texttt'>int16_&shy;t</span>         </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint16_&shy;t</span>       </td><td class='left'> <span class='texttt'>uint16_&shy;t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int32_&shy;t</span>        </td><td class='left'> <span class='texttt'>int32_&shy;t</span>         </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint32_&shy;t</span>       </td><td class='left'> <span class='texttt'>uint32_&shy;t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int64_&shy;t</span>        </td><td class='left'> <span class='texttt'>int64_&shy;t</span>         </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint64_&shy;t</span>       </td><td class='left'> <span class='texttt'>uint64_&shy;t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;least8_&shy;t</span>   </td><td class='left'> <span class='texttt'>int_&shy;least8_&shy;t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;least8_&shy;t</span>  </td><td class='left'> <span class='texttt'>uint_&shy;least8_&shy;t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;least16_&shy;t</span>  </td><td class='left'> <span class='texttt'>int_&shy;least16_&shy;t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;least16_&shy;t</span> </td><td class='left'> <span class='texttt'>uint_&shy;least16_&shy;t</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;least32_&shy;t</span>  </td><td class='left'> <span class='texttt'>int_&shy;least32_&shy;t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;least32_&shy;t</span> </td><td class='left'> <span class='texttt'>uint_&shy;least32_&shy;t</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;least64_&shy;t</span>  </td><td class='left'> <span class='texttt'>int_&shy;least64_&shy;t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;least64_&shy;t</span> </td><td class='left'> <span class='texttt'>uint_&shy;least64_&shy;t</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;fast8_&shy;t</span>    </td><td class='left'> <span class='texttt'>int_&shy;fast8_&shy;t</span>     </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;fast8_&shy;t</span>   </td><td class='left'> <span class='texttt'>uint_&shy;fast8_&shy;t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;fast16_&shy;t</span>   </td><td class='left'> <span class='texttt'>int_&shy;fast16_&shy;t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;fast16_&shy;t</span>  </td><td class='left'> <span class='texttt'>uint_&shy;fast16_&shy;t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;fast32_&shy;t</span>   </td><td class='left'> <span class='texttt'>int_&shy;fast32_&shy;t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;fast32_&shy;t</span>  </td><td class='left'> <span class='texttt'>uint_&shy;fast32_&shy;t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;fast64_&shy;t</span>   </td><td class='left'> <span class='texttt'>int_&shy;fast64_&shy;t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;fast64_&shy;t</span>  </td><td class='left'> <span class='texttt'>uint_&shy;fast64_&shy;t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;intptr_&shy;t</span>       </td><td class='left'> <span class='texttt'>intptr_&shy;t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uintptr_&shy;t</span>      </td><td class='left'> <span class='texttt'>uintptr_&shy;t</span>       </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;size_&shy;t</span>         </td><td class='left'> <span class='texttt'>size_&shy;t</span>          </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;ptrdiff_&shy;t</span>      </td><td class='left'> <span class='texttt'>ptrdiff_&shy;t</span>       </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;intmax_&shy;t</span>       </td><td class='left'> <span class='texttt'>intmax_&shy;t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uintmax_&shy;t</span>      </td><td class='left'> <span class='texttt'>uintmax_&shy;t</span>       </td></tr></table></div></div><div class='para' id='types.generic-9'><div class='marginalizedparent'><a class='marginalized' href='#types.generic-9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L760'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> The representation of an atomic specialization need not have the same size as its
corresponding argument type. Specializations should have the same size whenever possible, as
this reduces the effort required to port existing code. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div id='types.operations'><h2 ><a class='secnum' href='#types.operations' style='min-width:88pt'>29.6</a> Operations on atomic types <a class='abbr_ref' href='atomics.types.operations'>[atomics.types.operations]</a></h2><div id='types.operations.general'><h3 ><a class='secnum' href='#types.operations.general' style='min-width:103pt'>29.6.1</a> General operations on atomic types <a class='abbr_ref' href='atomics.types.operations.general'>[atomics.types.operations.general]</a></h3><div class='para' id='types.operations.general-1'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.general-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L769'>#</a></div><p >The implementation shall provide the functions and function templates identified as “general operations
on atomic types” in <a href='atomics.syn'>[atomics.syn]</a>.</p></div><div class='para' id='types.operations.general-2'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.general-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L773'>#</a></div><p >In the declarations of these functions and function templates, the name
<span class='texttt'><span class='textit'>atomic-type</span></span> refers to either <span class='texttt'>atomic&lt;T&gt;</span> or to a named base class for <span class='texttt'>T</span>
from Table <a href='#tab:atomics.integral'>[tab:atomics.integral]</a> or inferred from Table <a href='#tab:atomics.typedefs'>[tab:atomics.typedefs]</a>.</p></div></div><div id='types.operations.templ'><h3 ><a class='secnum' href='#types.operations.templ' style='min-width:103pt'>29.6.2</a> Templated operations on atomic types <a class='abbr_ref' href='atomics.types.operations.templ'>[atomics.types.operations.templ]</a></h3><div class='para' id='types.operations.templ-1'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.templ-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L780'>#</a></div><p >The implementation shall declare but not define the
function templates identified as “templated operations on atomic types” in <a href='atomics.syn'>[atomics.syn]</a>.</p></div></div><div id='types.operations.arith'><h3 ><a class='secnum' href='#types.operations.arith' style='min-width:103pt'>29.6.3</a> Arithmetic operations on atomic types <a class='abbr_ref' href='atomics.types.operations.arith'>[atomics.types.operations.arith]</a></h3><div class='para' id='types.operations.arith-1'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.arith-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L786'>#</a></div><p >The implementation shall provide the functions and function template specializations identified as “arithmetic operations
on atomic types” in <a href='atomics.syn'>[atomics.syn]</a>.</p><p ><span class='indexparent'><a class='index' id='atomic<integral>'></a></span></p></div><div class='para' id='types.operations.arith-2'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.arith-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L791'>#</a></div><p >In the declarations of these functions and function template specializations,
the name <span class='texttt'><span class='textit'>integral</span></span> refers to an
integral type and the name <span class='texttt'><span class='textit'>atomic-integral</span></span> refers to either
<span class='texttt'>atomic&lt;<span class='textit'>integral</span>&gt;</span> or to a named base class for <span class='texttt'><span class='textit'>integral</span></span> from
Table <a href='#tab:atomics.integral'>[tab:atomics.integral]</a> or inferred from Table <a href='#tab:atomics.typedefs'>[tab:atomics.typedefs]</a>.</p></div></div><div id='types.operations.pointer'><h3 ><a class='secnum' href='#types.operations.pointer' style='min-width:103pt'>29.6.4</a> Operations on atomic pointer types <a class='abbr_ref' href='atomics.types.operations.pointer'>[atomics.types.operations.pointer]</a></h3><p ><span class='indexparent'><a class='index' id='atomic<T*>'></a></span>
</p><div class='para' id='types.operations.pointer-1'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.pointer-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L801'>#</a></div><p >The implementation shall provide the function templates identified as
“non-member overloads for atomic&lt;T*&gt;” in <a href='atomics.syn'>[atomics.syn]</a>.</p></div></div><div id='types.operations.req'><h3 ><a class='secnum' href='#types.operations.req' style='min-width:103pt'>29.6.5</a> Requirements for operations on atomic types <a class='abbr_ref' href='atomics.types.operations.req'>[atomics.types.operations.req]</a></h3><div class='para' id='types.operations.req-1'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L807'>#</a></div><p >There are only a few kinds of operations on atomic types, though there are many
instances on those kinds. This section specifies each general kind. The specific
instances are defined in 
<a href='atomics.types.generic'>[atomics.types.generic]</a>, <a href='atomics.types.operations.general'>[atomics.types.operations.general]</a>,
<a href='atomics.types.operations.arith'>[atomics.types.operations.arith]</a>, and <a href='atomics.types.operations.pointer'>[atomics.types.operations.pointer]</a>.</p></div><div class='para' id='types.operations.req-2'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L814'>#</a></div><p >In the following operation definitions:</p><ul class='itemize'><li id='types.operations.req-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#types.operations.req-2.1'>(2.1)</a></div><p >an <span class='textit'>A</span> refers to one of the atomic types.
</p></li><li id='types.operations.req-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#types.operations.req-2.2'>(2.2)</a></div><p >a <span class='textit'>C</span> refers to its corresponding non-atomic type.
</p></li><li id='types.operations.req-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#types.operations.req-2.3'>(2.3)</a></div><p >an <span class='textit'>M</span> refers to type of the other argument for arithmetic operations. For
integral atomic types, <span class='textit'>M</span> is <span class='textit'>C</span>. For atomic address types, <span class='textit'>M</span> is
<span class='texttt'>ptrdiff_&shy;t</span>.
</p></li><li id='types.operations.req-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#types.operations.req-2.4'>(2.4)</a></div><p >the non-member functions not ending in <span class='texttt'>_&shy;explicit</span> have the semantics of their
corresponding <span class='texttt'>_&shy;explicit</span> functions with <span class='texttt'>memory_&shy;order</span> arguments of
<span class='texttt'>memory_&shy;order_&shy;seq_&shy;cst</span>.
</p></li></ul></div><div class='para' id='types.operations.req-3'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L828'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> Many operations are volatile-qualified. The “volatile as device register”
semantics have not changed in the standard. This qualification means that volatility is
preserved when applying these operations to volatile objects. It does not mean that
operations on non-volatile objects become volatile. Thus, volatile qualified operations
on non-volatile objects may be merged under some conditions. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p><p ><span class='indexparent'><a class='index' id='atomic,constructor'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,constructor'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,constructor'></a></span></p></div><p ><code class='itemdecl'><span class='textit'>A</span>::<span class='textit'>A</span>() noexcept = default;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-4'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L843'>#</a></div><p ><span class='textit'>Effects:</span>
Leaves the atomic object in an uninitialized state.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
These semantics ensure compatibility with C.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic,constructor'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,constructor'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,constructor'></a></span></p><p ><code class='itemdecl'>constexpr <span class='textit'>A</span>::<span class='textit'>A</span>(<span class='textit'>C</span> desired) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-5'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L859'>#</a></div><p ><span class='textit'>Effects:</span> Initializes the object with the value <span class='texttt'>desired</span>.
Initialization is not an atomic operation (<a href='intro.multithread'>[intro.multithread]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> It is possible to have an access to an atomic object <span class='texttt'>A</span>
race with its construction, for example by communicating the address of the
just-constructed object <span class='texttt'>A</span> to another thread via
<span class='texttt'>memory_&shy;order_&shy;relaxed</span> operations on a suitable atomic pointer
variable, and then immediately accessing <span class='texttt'>A</span> in the receiving thread.
This results in undefined behavior. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
</p></div></div><p ><span class='indexparent'><a class='index' id='ATOMIC_VAR_INIT'></a></span></p><p ><code class='itemdecl'>#define ATOMIC_VAR_INIT(value) <span class='textit'><span class='texttt'>see below</span></span>
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-6'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L876'>#</a></div><p >The macro expands to a token sequence suitable for
constant initialization of
an atomic variable of static storage duration of a type that is
initialization-compatible with <span class='texttt'>value</span>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> This operation may need to initialize locks. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
Concurrent access to the variable being initialized, even via an atomic operation,
constitutes a data race. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>
</p><pre class='codeblock'>
atomic&lt;int&gt; v = ATOMIC_VAR_INIT(5);</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]
</p></div></div><p ><span class='indexparent'><a class='index' id='is_always_lock_free,atomic'></a></span><span class='indexparent'><a class='index' id='atomic,is_always_lock_free'></a></span><span class='indexparent'><a class='index' id='is_always_lock_free,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,is_always_lock_free'></a></span><span class='indexparent'><a class='index' id='is_always_lock_free,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,is_always_lock_free'></a></span></p><p ><code class='itemdecl'>static constexpr bool is_always_lock_free = <span class='indexparent'><a class='index' id='whether_a_given_atomic_type&#39;s_operations_are_always_lock_free'></a></span><span class='textit'>implementation-defined</span>;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-7'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L898'>#</a></div><p >The <span class='texttt'>static</span> data member <span class='texttt'>is_&shy;always_&shy;lock_&shy;free</span> is <span class='texttt'>true</span>
if the atomic type's operations are always lock-free, and <span class='texttt'>false</span> otherwise.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
The value of <span class='texttt'>is_&shy;always_&shy;lock_&shy;free</span> is consistent with the value of
the corresponding <span class='texttt'>ATOMIC_&shy;..._&shy;LOCK_&shy;FREE</span> macro, if defined.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_is_lock_free'></a></span><span class='indexparent'><a class='index' id='is_lock_free,atomic'></a></span><span class='indexparent'><a class='index' id='atomic,is_lock_free'></a></span><span class='indexparent'><a class='index' id='is_lock_free,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,is_lock_free'></a></span><span class='indexparent'><a class='index' id='is_lock_free,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,is_lock_free'></a></span></p><p ><code class='itemdecl'>bool atomic_is_lock_free(const volatile <span class='textit'>A</span>* object) noexcept;
bool atomic_is_lock_free(const <span class='textit'>A</span>* object) noexcept;
bool <span class='textit'>A</span>::is_lock_free() const volatile noexcept;
bool <span class='textit'>A</span>::is_lock_free() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-8'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-8'>8</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L919'>#</a></div><p ><span class='textit'>Returns:</span> <span class='texttt'>true</span> if the object's operations are lock-free, <span class='texttt'>false</span> otherwise.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
The return value of the <span class='texttt'>is_&shy;lock_&shy;free</span> member function
is consistent with the value of <span class='texttt'>is_&shy;always_&shy;lock_&shy;free</span> for the same type.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_init'></a></span></p><p ><code class='itemdecl'>void atomic_init(volatile <span class='textit'>A</span>* object, <span class='textit'>C</span> desired) noexcept;
void atomic_init(<span class='textit'>A</span>* object, <span class='textit'>C</span> desired) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-9'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-9'>9</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L934'>#</a></div><p ><span class='textit'>Effects:</span> Non-atomically
initializes <span class='texttt'>*object</span> with value <span class='texttt'>desired</span>. This function shall only be applied
to objects that have been default constructed, and then only once.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
These semantics ensure compatibility with C.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
Concurrent access from another thread, even via an atomic operation, constitutes
a data race.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_store'></a></span><span class='indexparent'><a class='index' id='atomic_store_explicit'></a></span><span class='indexparent'><a class='index' id='store,atomic'></a></span><span class='indexparent'><a class='index' id='atomic,store'></a></span><span class='indexparent'><a class='index' id='store,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,store'></a></span><span class='indexparent'><a class='index' id='store,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,store'></a></span></p><p ><code class='itemdecl'>void atomic_store(volatile <span class='textit'>A</span>* object, <span class='textit'>C</span> desired) noexcept;
void atomic_store(<span class='textit'>A</span>* object, <span class='textit'>C</span> desired) noexcept;
void atomic_store_explicit(volatile <span class='textit'>A</span>* object, <span class='textit'>C</span> desired, memory_order order) noexcept;
void atomic_store_explicit(<span class='textit'>A</span>* object, <span class='textit'>C</span> desired, memory_order order) noexcept;
void <span class='textit'>A</span>::store(<span class='textit'>C</span> desired, memory_order order = memory_order_seq_cst) volatile noexcept;
void <span class='textit'>A</span>::store(<span class='textit'>C</span> desired, memory_order order = memory_order_seq_cst) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-10'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-10'>10</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L963'>#</a></div><p ><span class='textit'>Requires:</span> The <span class='texttt'>order</span> argument shall not be <span class='texttt'>memory_&shy;order_&shy;consume</span>,
<span class='texttt'>memory_&shy;order_&shy;acquire</span>, nor <span class='texttt'>memory_&shy;order_&shy;acq_&shy;rel</span>.</p></div></div><div class='para' id='types.operations.req-11'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-11'>11</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L967'>#</a></div><p ><span class='textit'>Effects:</span> Atomically replaces the value pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span>
with the value of <span class='texttt'>desired</span>. Memory is affected according to the value of
<span class='texttt'>order</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,atomic'></a></span><span class='indexparent'><a class='index' id='atomic,operator='></a></span><span class='indexparent'><a class='index' id='operator=,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,operator='></a></span><span class='indexparent'><a class='index' id='operator=,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,operator='></a></span></p><p ><code class='itemdecl'><span class='textit'>C</span> <span class='textit'>A</span>::operator=(<span class='textit'>C</span> desired) volatile noexcept;
<span class='textit'>C</span> <span class='textit'>A</span>::operator=(<span class='textit'>C</span> desired) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-12'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-12'>12</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L982'>#</a></div><p ><span class='textit'>Effects:</span> As if by <span class='texttt'>store(desired)</span>.</p></div></div><div class='para' id='types.operations.req-13'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-13'>13</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L985'>#</a></div><p ><span class='textit'>Returns:</span> <span class='texttt'>desired</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_load'></a></span><span class='indexparent'><a class='index' id='atomic_load_explicit'></a></span><span class='indexparent'><a class='index' id='load,atomic'></a></span><span class='indexparent'><a class='index' id='atomic,load'></a></span><span class='indexparent'><a class='index' id='load,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,load'></a></span><span class='indexparent'><a class='index' id='load,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,load'></a></span></p><p ><code class='itemdecl'><span class='textit'>C</span> atomic_load(const volatile <span class='textit'>A</span>* object) noexcept;
<span class='textit'>C</span> atomic_load(const <span class='textit'>A</span>* object) noexcept;
<span class='textit'>C</span> atomic_load_explicit(const volatile <span class='textit'>A</span>* object, memory_order) noexcept;
<span class='textit'>C</span> atomic_load_explicit(const <span class='textit'>A</span>* object, memory_order) noexcept;
<span class='textit'>C</span> <span class='textit'>A</span>::load(memory_order order = memory_order_seq_cst) const volatile noexcept;
<span class='textit'>C</span> <span class='textit'>A</span>::load(memory_order order = memory_order_seq_cst) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-14'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-14'>14</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1004'>#</a></div><p ><span class='textit'>Requires:</span> The <span class='texttt'>order</span> argument shall not be <span class='texttt'>memory_&shy;order_&shy;release</span> nor <span class='texttt'>memory_&shy;order_&shy;acq_&shy;rel</span>.</p></div></div><div class='para' id='types.operations.req-15'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-15'>15</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1007'>#</a></div><p ><span class='textit'>Effects:</span> Memory is affected according to the value of <span class='texttt'>order</span>.</p></div></div><div class='para' id='types.operations.req-16'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-16'>16</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1010'>#</a></div><p ><span class='textit'>Returns:</span> Atomically returns the value pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator_type,atomic'></a></span><span class='indexparent'><a class='index' id='atomic,operator_type'></a></span><span class='indexparent'><a class='index' id='operator_T*,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,operator_T*'></a></span><span class='indexparent'><a class='index' id='operator_integral,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,operator_integral'></a></span></p><p ><code class='itemdecl'><span class='textit'>A</span>::operator <span class='textit'>C</span>() const volatile noexcept;
<span class='textit'>A</span>::operator <span class='textit'>C</span>() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-17'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-17'>17</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1023'>#</a></div><p ><span class='textit'>Effects:</span> As if by <span class='texttt'>load()</span>.</p></div></div><div class='para' id='types.operations.req-18'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-18'>18</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1026'>#</a></div><p ><span class='textit'>Returns:</span> The result of <span class='texttt'>load()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_exchange'></a></span><span class='indexparent'><a class='index' id='atomic_exchange_explicit'></a></span><span class='indexparent'><a class='index' id='exchange,atomic'></a></span><span class='indexparent'><a class='index' id='atomic,exchange'></a></span><span class='indexparent'><a class='index' id='exchange,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,exchange'></a></span><span class='indexparent'><a class='index' id='exchange,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,exchange'></a></span></p><p ><code class='itemdecl'><span class='textit'>C</span> atomic_exchange(volatile <span class='textit'>A</span>* object, <span class='textit'>C</span> desired) noexcept;
<span class='textit'>C</span> atomic_exchange(<span class='textit'>A</span>* object, <span class='textit'>C</span> desired) noexcept;
<span class='textit'>C</span> atomic_exchange_explicit(volatile <span class='textit'>A</span>* object, <span class='textit'>C</span> desired, memory_order) noexcept;
<span class='textit'>C</span> atomic_exchange_explicit(<span class='textit'>A</span>* object, <span class='textit'>C</span> desired, memory_order) noexcept;
<span class='textit'>C</span> <span class='textit'>A</span>::exchange(<span class='textit'>C</span> desired, memory_order order = memory_order_seq_cst) volatile noexcept;
<span class='textit'>C</span> <span class='textit'>A</span>::exchange(<span class='textit'>C</span> desired, memory_order order = memory_order_seq_cst) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-19'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-19'>19</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1046'>#</a></div><p ><span class='textit'>Effects:</span> Atomically replaces the value pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span>
with <span class='texttt'>desired</span>.
Memory is affected according to the value of <span class='texttt'>order</span>.
These operations are atomic read-modify-write operations (<a href='intro.multithread'>[intro.multithread]</a>).</p></div></div><div class='para' id='types.operations.req-20'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-20'>20</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1052'>#</a></div><p ><span class='textit'>Returns:</span> Atomically returns the value pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span> immediately before the effects.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_compare_exchange_weak'></a></span><span class='indexparent'><a class='index' id='atomic_compare_exchange_strong'></a></span><span class='indexparent'><a class='index' id='atomic_compare_exchange_weak_explicit'></a></span><span class='indexparent'><a class='index' id='atomic_compare_exchange_strong_explicit'></a></span><span class='indexparent'><a class='index' id='compare_exchange_weak,atomic'></a></span><span class='indexparent'><a class='index' id='atomic,compare_exchange_weak'></a></span><span class='indexparent'><a class='index' id='compare_exchange_weak,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,compare_exchange_weak'></a></span><span class='indexparent'><a class='index' id='compare_exchange_weak,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,compare_exchange_weak'></a></span><span class='indexparent'><a class='index' id='compare_exchange_strong,atomic'></a></span><span class='indexparent'><a class='index' id='atomic,compare_exchange_strong'></a></span><span class='indexparent'><a class='index' id='compare_exchange_strong,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,compare_exchange_strong'></a></span><span class='indexparent'><a class='index' id='compare_exchange_strong,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,compare_exchange_strong'></a></span></p><p ><code class='itemdecl'>bool atomic_compare_exchange_weak(volatile <span class='textit'>A</span>* object, <span class='textit'>C</span>* expected, <span class='textit'>C</span> desired) noexcept;
bool atomic_compare_exchange_weak(<span class='textit'>A</span>* object, <span class='textit'>C</span>* expected, <span class='textit'>C</span> desired) noexcept;
bool atomic_compare_exchange_strong(volatile <span class='textit'>A</span>* object, <span class='textit'>C</span>* expected, <span class='textit'>C</span> desired) noexcept;
bool atomic_compare_exchange_strong(<span class='textit'>A</span>* object, <span class='textit'>C</span>* expected, <span class='textit'>C</span> desired) noexcept;
bool atomic_compare_exchange_weak_explicit(volatile <span class='textit'>A</span>* object, <span class='textit'>C</span>* expected, <span class='textit'>C</span> desired,
    memory_order success, memory_order failure) noexcept;
bool atomic_compare_exchange_weak_explicit(<span class='textit'>A</span>* object, <span class='textit'>C</span>* expected, <span class='textit'>C</span> desired,
    memory_order success, memory_order failure) noexcept;
bool atomic_compare_exchange_strong_explicit(volatile <span class='textit'>A</span>* object, <span class='textit'>C</span>* expected, <span class='textit'>C</span> desired,
    memory_order success, memory_order failure) noexcept;
bool atomic_compare_exchange_strong_explicit(<span class='textit'>A</span>* object, <span class='textit'>C</span>* expected, <span class='textit'>C</span> desired,
    memory_order success, memory_order failure) noexcept;
bool <span class='textit'>A</span>::compare_exchange_weak(<span class='textit'>C</span>&amp; expected, <span class='textit'>C</span> desired,
    memory_order success, memory_order failure) volatile noexcept;
bool <span class='textit'>A</span>::compare_exchange_weak(<span class='textit'>C</span>&amp; expected, <span class='textit'>C</span> desired,
    memory_order success, memory_order failure) noexcept;
bool <span class='textit'>A</span>::compare_exchange_strong(<span class='textit'>C</span>&amp; expected, <span class='textit'>C</span> desired,
    memory_order success, memory_order failure) volatile noexcept;
bool <span class='textit'>A</span>::compare_exchange_strong(<span class='textit'>C</span>&amp; expected, <span class='textit'>C</span> desired,
    memory_order success, memory_order failure) noexcept;
bool <span class='textit'>A</span>::compare_exchange_weak(<span class='textit'>C</span>&amp; expected, <span class='textit'>C</span> desired,
    memory_order order = memory_order_seq_cst) volatile noexcept;
bool <span class='textit'>A</span>::compare_exchange_weak(<span class='textit'>C</span>&amp; expected, <span class='textit'>C</span> desired,
    memory_order order = memory_order_seq_cst) noexcept;
bool <span class='textit'>A</span>::compare_exchange_strong(<span class='textit'>C</span>&amp; expected, <span class='textit'>C</span> desired,
    memory_order order = memory_order_seq_cst) volatile noexcept;
bool <span class='textit'>A</span>::compare_exchange_strong(<span class='textit'>C</span>&amp; expected, <span class='textit'>C</span> desired,
    memory_order order = memory_order_seq_cst) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-21'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-21'>21</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1098'>#</a></div><p ><span class='textit'>Requires:</span> The <span class='texttt'>failure</span> argument shall not be <span class='texttt'>memory_&shy;order_&shy;release</span> nor
<span class='texttt'>memory_&shy;order_&shy;acq_&shy;rel</span>.</p></div></div><div class='para' id='types.operations.req-22'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-22'>22</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1102'>#</a></div><p ><span class='textit'>Effects:</span> Retrieves the value in <span class='texttt'>expected</span>. It then atomically
compares the contents of the memory pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span>
for equality with that previously retrieved from <span class='texttt'>expected</span>,
and if true, replaces the contents of the memory pointed to
by <span class='texttt'>object</span> or by <span class='texttt'>this</span> with that in <span class='texttt'>desired</span>.
If and only if the comparison is true, memory is affected according to the
value of <span class='texttt'>success</span>, and if the comparison is false, memory is affected according
to the value of <span class='texttt'>failure</span>. When only one <span class='texttt'>memory_&shy;order</span> argument is
supplied, the value of <span class='texttt'>success</span> is <span class='texttt'>order</span>, and the value of
<span class='texttt'>failure</span> is <span class='texttt'>order</span> except that a value of <span class='texttt'>memory_&shy;order_&shy;acq_&shy;rel</span>
shall be replaced by the value <span class='texttt'>memory_&shy;order_&shy;acquire</span> and a value of
<span class='texttt'>memory_&shy;order_&shy;release</span> shall be replaced by the value
<span class='texttt'>memory_&shy;order_&shy;relaxed</span>.
If and only if the comparison is false then, after the atomic operation,
the contents of the memory in <span class='texttt'>expected</span> are replaced by the value
read from <span class='texttt'>object</span> or by <span class='texttt'>this</span> during the atomic comparison.
If the operation returns <span class='texttt'>true</span>, these
operations are atomic read-modify-write
operations (<a href='intro.multithread'>[intro.multithread]</a>) on the memory
pointed to by <span class='texttt'>this</span> or <span class='texttt'>object</span>.
Otherwise, these operations are atomic load operations on that memory.</p></div></div><div class='para' id='types.operations.req-23'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-23'>23</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1125'>#</a></div><p ><span class='textit'>Returns:</span> The result of the comparison.</p></div></div><div class='para' id='types.operations.req-24'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-24'>24</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1128'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> For example, the effect of
<span class='texttt'>atomic_&shy;compare_&shy;exchange_&shy;strong</span> is
</p><pre class='codeblock'>
if (memcmp(object, expected, sizeof(*object)) == 0)
  memcpy(object, &amp;desired, sizeof(*object));
else
  memcpy(expected, object, sizeof(*object));</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> The expected use of the compare-and-exchange operations is as follows. The
compare-and-exchange operations will update <span class='texttt'>expected</span> when another iteration of
the loop is needed.
</p><pre class='codeblock'>
expected = current.load();
do {
  desired = function(expected);
} while (!current.compare_exchange_weak(expected, desired));</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> Because the expected value is updated only on failure,
code releasing the memory containing the <span class='texttt'>expected</span> value on success will work.
E.g. list head insertion will act atomically and would not introduce a
data race in the following code:
</p><pre class='codeblock'>
do {
  p-&gt;next = head; <span class='comment'>// make new list node point to the current head
</span>} while (!head.compare_exchange_weak(p-&gt;next, p)); <span class='comment'>// try to insert
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div class='para' id='types.operations.req-25'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-25'>25</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1159'>#</a></div><p >Implementations should ensure that weak compare-and-exchange operations do not
consistently return <span class='texttt'>false</span> unless either the atomic object has value
different from <span class='texttt'>expected</span> or there are concurrent modifications to the
atomic object.</p></div></div><div class='para' id='types.operations.req-26'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-26'>26</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1165'>#</a></div><p ><span class='textit'>Remarks:</span>
A weak compare-and-exchange operation may fail spuriously. That is, even when
the contents of memory referred to by <span class='texttt'>expected</span> and <span class='texttt'>object</span> are
equal, it may return <span class='texttt'>false</span> and store back to <span class='texttt'>expected</span> the same memory
contents that were originally there.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> This
spurious failure enables implementation of compare-and-exchange on a broader class of
machines, e.g., load-locked store-conditional machines. A
consequence of spurious failure is that nearly all uses of weak compare-and-exchange
will be in a loop.</p><p >When a compare-and-exchange is in a loop, the weak version will yield better performance
on some platforms. When a weak compare-and-exchange would require a loop and a strong one
would not, the strong one is preferable.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div class='para' id='types.operations.req-27'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-27'>27</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1182'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> The <span class='texttt'>memcpy</span> and <span class='texttt'>memcmp</span> semantics of the compare-and-exchange
operations may result in failed comparisons for values that compare equal with
<span class='texttt'>operator==</span> if the underlying type has padding bits, trap bits, or alternate
representations of the same value. Thus, <span class='texttt'>compare_&shy;exchange_&shy;strong</span> should be used
with extreme care. On the other hand, <span class='texttt'>compare_&shy;exchange_&shy;weak</span> should converge
rapidly. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
</p></div></div><div class='para' id='types.operations.req-28'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-28'>28</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1191'>#</a></div><p >The following operations perform arithmetic computations. The key, operator, and computation correspondence is:</p><div class='numberedTable' id='tab:atomic.arithmetic.computations'>Table <a href='#tab:atomic.arithmetic.computations'>140</a> — Atomic arithmetic computations<br><table ><tr class='rowsep'><td class='left'>

<span class='texttt'>Key</span>       </td><td class='left'>
  Op          </td><td class='left'>
  Computation     </td><td class='border left'>
<span class='texttt'>Key</span>       </td><td class='left'>
  Op          </td><td class='left'>
  Computation     </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>add</span>       </td><td class='left'>
  <span class='texttt'>+</span>       </td><td class='left'>
  addition        </td><td class='border left'>
<span class='texttt'>sub</span>       </td><td class='left'>
  <span class='texttt'>-</span>       </td><td class='left'>
  subtraction     </td></tr><tr ><td class='left'>
<span class='texttt'>or</span>        </td><td class='left'>
  <span class='texttt'>|</span>       </td><td class='left'>
  bitwise inclusive or  </td><td class='border left'>
<span class='texttt'>xor</span>       </td><td class='left'>
  <span class='texttt'>^</span>        </td><td class='left'>
  bitwise exclusive or  </td></tr><tr ><td class='left'>
<span class='texttt'>and</span>       </td><td class='left'>
  <span class='texttt'>&amp;</span>      </td><td class='left'>
  bitwise and     </td><td class='border left'></td><td class='left'></td><td class='left'></td></tr></table></div><p ><span class='indexparent'><a class='index' id='atomic_fetch_add'></a></span><span class='indexparent'><a class='index' id='atomic_fetch_and'></a></span><span class='indexparent'><a class='index' id='atomic_fetch_or'></a></span><span class='indexparent'><a class='index' id='atomic_fetch_sub'></a></span><span class='indexparent'><a class='index' id='atomic_fetch_xor'></a></span><span class='indexparent'><a class='index' id='atomic_fetch_add_explicit'></a></span><span class='indexparent'><a class='index' id='atomic_fetch_and_explicit'></a></span><span class='indexparent'><a class='index' id='atomic_fetch_or_explicit'></a></span><span class='indexparent'><a class='index' id='atomic_fetch_sub_explicit'></a></span><span class='indexparent'><a class='index' id='atomic_fetch_xor_explicit'></a></span><span class='indexparent'><a class='index' id='fetch_add,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,fetch_add'></a></span><span class='indexparent'><a class='index' id='fetch_sub,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,fetch_sub'></a></span><span class='indexparent'><a class='index' id='fetch_add,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,fetch_add'></a></span><span class='indexparent'><a class='index' id='fetch_and,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,fetch_and'></a></span><span class='indexparent'><a class='index' id='fetch_or,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,fetch_or'></a></span><span class='indexparent'><a class='index' id='fetch_sub,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,fetch_sub'></a></span><span class='indexparent'><a class='index' id='fetch_xor,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,fetch_xor'></a></span></p></div><p ><code class='itemdecl'><span class='textit'>C</span> atomic_fetch_<span class='textit'>key</span>(volatile <span class='textit'>A</span>* object, <span class='textit'>M</span> operand) noexcept;
<span class='textit'>C</span> atomic_fetch_<span class='textit'>key</span>(<span class='textit'>A</span>* object, <span class='textit'>M</span> operand) noexcept;
<span class='textit'>C</span> atomic_fetch_<span class='textit'>key</span>_explicit(volatile <span class='textit'>A</span>* object, <span class='textit'>M</span> operand, memory_order order) noexcept;
<span class='textit'>C</span> atomic_fetch_<span class='textit'>key</span>_explicit(<span class='textit'>A</span>* object, <span class='textit'>M</span> operand, memory_order order) noexcept;
<span class='textit'>C</span> <span class='textit'>A</span>::fetch_<span class='textit'>key</span>(<span class='textit'>M</span> operand, memory_order order = memory_order_seq_cst) volatile noexcept;
<span class='textit'>C</span> <span class='textit'>A</span>::fetch_<span class='textit'>key</span>(<span class='textit'>M</span> operand, memory_order order = memory_order_seq_cst) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-29'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-29'>29</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1247'>#</a></div><p ><span class='textit'>Effects:</span> Atomically replaces the value pointed to by <span class='texttt'>object</span> or by
<span class='texttt'>this</span> with the result of the computation applied to the
value pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span> and the given <span class='texttt'>operand</span>.
Memory is affected according to the value of <span class='texttt'>order</span>.
These operations are atomic read-modify-write operations (<a href='intro.multithread'>[intro.multithread]</a>).</p></div></div><div class='para' id='types.operations.req-30'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-30'>30</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1254'>#</a></div><p ><span class='textit'>Returns:</span> Atomically, the value pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span> immediately before the effects.</p></div></div><div class='para' id='types.operations.req-31'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-31'>31</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1257'>#</a></div><p ><span class='indexparent'><a class='index' id='signed_integer_representation,two&#39;s_complement'></a></span><span class='textit'>Remarks:</span> For signed integer types, arithmetic is defined to use two's complement
representation. There are no undefined results. For address types, the result may be an
undefined address, but the operations otherwise have no undefined behavior.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator+=,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,operator+='></a></span><span class='indexparent'><a class='index' id='operator-=,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,operator-='></a></span><span class='indexparent'><a class='index' id='operator+=,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,operator+='></a></span><span class='indexparent'><a class='index' id='operator-=,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,operator-='></a></span><span class='indexparent'><a class='index' id='operator&=,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,operator&='></a></span><span class='indexparent'><a class='index' id='operator|=,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,operator|='></a></span><span class='indexparent'><a class='index' id='operator^=,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,operator^='></a></span></p><p ><code class='itemdecl'><span class='textit'>C</span> <span class='textit'>A</span>::operator <span class='textit'>op</span>=(<span class='textit'>M</span> operand) volatile noexcept;
<span class='textit'>C</span> <span class='textit'>A</span>::operator <span class='textit'>op</span>=(<span class='textit'>M</span> operand) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-32'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-32'>32</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1277'>#</a></div><p ><span class='textit'>Effects:</span> As if by <span class='texttt'>fetch_&shy;<span class='textit'>key</span>(operand)</span>.</p></div></div><div class='para' id='types.operations.req-33'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-33'>33</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1280'>#</a></div><p ><span class='textit'>Returns:</span> <span class='texttt'>fetch_&shy;<span class='textit'>key</span>(operand) op operand</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,operator++'></a></span><span class='indexparent'><a class='index' id='operator++,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,operator++'></a></span></p><p ><code class='itemdecl'><span class='textit'>C</span> <span class='textit'>A</span>::operator++(int) volatile noexcept;
<span class='textit'>C</span> <span class='textit'>A</span>::operator++(int) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-34'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-34'>34</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1292'>#</a></div><p ><span class='textit'>Returns:</span> <span class='texttt'>fetch_&shy;add(1)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator--,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,operator--'></a></span><span class='indexparent'><a class='index' id='operator--,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,operator--'></a></span></p><p ><code class='itemdecl'><span class='textit'>C</span> <span class='textit'>A</span>::operator--(int) volatile noexcept;
<span class='textit'>C</span> <span class='textit'>A</span>::operator--(int) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-35'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-35'>35</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1304'>#</a></div><p ><span class='textit'>Returns:</span> <span class='texttt'>fetch_&shy;sub(1)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,operator++'></a></span><span class='indexparent'><a class='index' id='operator++,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,operator++'></a></span></p><p ><code class='itemdecl'><span class='textit'>C</span> <span class='textit'>A</span>::operator++() volatile noexcept;
<span class='textit'>C</span> <span class='textit'>A</span>::operator++() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-36'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-36'>36</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1316'>#</a></div><p ><span class='textit'>Effects:</span> As if by <span class='texttt'>fetch_&shy;add(1)</span>.</p></div></div><div class='para' id='types.operations.req-37'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-37'>37</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1319'>#</a></div><p ><span class='textit'>Returns:</span> <span class='texttt'>fetch_&shy;add(1) + 1</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator--,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<T*>,operator--'></a></span><span class='indexparent'><a class='index' id='operator--,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>,operator--'></a></span></p><p ><code class='itemdecl'><span class='textit'>C</span> <span class='textit'>A</span>::operator--() volatile noexcept;
<span class='textit'>C</span> <span class='textit'>A</span>::operator--() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='types.operations.req-38'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-38'>38</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1331'>#</a></div><p ><span class='textit'>Effects:</span> As if by <span class='texttt'>fetch_&shy;sub(1)</span>.</p></div></div><div class='para' id='types.operations.req-39'><div class='marginalizedparent'><a class='marginalized' href='#types.operations.req-39'>39</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1334'>#</a></div><p ><span class='textit'>Returns:</span> <span class='texttt'>fetch_&shy;sub(1) - 1</span>.
</p></div></div></div></div><div id='flag'><h2 ><a class='secnum' href='#flag' style='min-width:88pt'>29.7</a> Flag type and operations <a class='abbr_ref' href='atomics.flag'>[atomics.flag]</a></h2><pre class='codeblock'>
namespace std {
  struct atomic_flag {
    bool test_and_set(memory_order = memory_order_seq_cst) volatile noexcept;
    bool test_and_set(memory_order = memory_order_seq_cst) noexcept;
    void clear(memory_order = memory_order_seq_cst) volatile noexcept;
    void clear(memory_order = memory_order_seq_cst) noexcept;

    atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&amp;) = delete;
    atomic_flag&amp; operator=(const atomic_flag&amp;) = delete;
    atomic_flag&amp; operator=(const atomic_flag&amp;) volatile = delete;
  };

  bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
  bool atomic_flag_test_and_set(atomic_flag*) noexcept;
  bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
  bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear(volatile atomic_flag*) noexcept;
  void atomic_flag_clear(atomic_flag*) noexcept;
  void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
  void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;

  #define ATOMIC_FLAG_INIT <span class='textit'><span class='texttt'>see below</span></span>
}</pre><div class='para' id='flag-1'><div class='marginalizedparent'><a class='marginalized' href='#flag-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1367'>#</a></div><p >The <span class='texttt'>atomic_&shy;flag</span> type provides the classic test-and-set functionality. It has two states, set and clear.</p></div><div class='para' id='flag-2'><div class='marginalizedparent'><a class='marginalized' href='#flag-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1370'>#</a></div><p >Operations on an object of type <span class='texttt'>atomic_&shy;flag</span> shall be lock-free. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> Hence
the operations should also be address-free. No other type requires lock-free operations,
so the <span class='texttt'>atomic_&shy;flag</span> type is the minimum hardware-implemented type needed to
conform to this International Standard. The remaining types can be emulated with
<span class='texttt'>atomic_&shy;flag</span>, though with less than ideal properties. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='flag-3'><div class='marginalizedparent'><a class='marginalized' href='#flag-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1377'>#</a></div><p >The <span class='texttt'>atomic_&shy;flag</span> type shall be a standard-layout struct.
It shall have a trivial default constructor, a deleted copy constructor, a deleted copy assignment operator, and a trivial destructor.</p></div><div class='para' id='flag-4'><div class='marginalizedparent'><a class='marginalized' href='#flag-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1381'>#</a></div><p >The macro <span class='texttt'>ATOMIC_&shy;FLAG_&shy;INIT</span> shall be defined in such a way that it can be used to initialize an object of type <span class='texttt'>atomic_&shy;flag</span> to the
clear state. The macro can be used in the form:
</p><pre class='codeblock'>
atomic_flag guard = ATOMIC_FLAG_INIT;</pre><p >It is unspecified whether the macro can be used in other initialization contexts.
For a complete static-duration object, that initialization shall be static.
Unless initialized with <span class='texttt'>ATOMIC_&shy;FLAG_&shy;INIT</span>, it is unspecified whether an
<span class='texttt'>atomic_&shy;flag</span> object has an initial state of set or clear.</p><p ><span class='indexparent'><a class='index' id='atomic_flag_test_and_set'></a></span><span class='indexparent'><a class='index' id='atomic_flag_test_and_set_explicit'></a></span><span class='indexparent'><a class='index' id='test_and_set,atomic_flag'></a></span><span class='indexparent'><a class='index' id='atomic_flag,test_and_set'></a></span></p></div><p ><code class='itemdecl'>bool atomic_flag_test_and_set(volatile atomic_flag* object) noexcept;
bool atomic_flag_test_and_set(atomic_flag* object) noexcept;
bool atomic_flag_test_and_set_explicit(volatile atomic_flag* object, memory_order order) noexcept;
bool atomic_flag_test_and_set_explicit(atomic_flag* object, memory_order order) noexcept;
bool atomic_flag::test_and_set(memory_order order = memory_order_seq_cst) volatile noexcept;
bool atomic_flag::test_and_set(memory_order order = memory_order_seq_cst) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='flag-5'><div class='marginalizedparent'><a class='marginalized' href='#flag-5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1405'>#</a></div><p ><span class='textit'>Effects:</span> Atomically sets the value pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span> to <span class='texttt'>true</span>. Memory is affected according to the value of
<span class='texttt'>order</span>. These operations are atomic read-modify-write operations (<a href='intro.multithread'>[intro.multithread]</a>).</p></div></div><div class='para' id='flag-6'><div class='marginalizedparent'><a class='marginalized' href='#flag-6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1409'>#</a></div><p ><span class='textit'>Returns:</span> Atomically, the value of the object immediately before the effects.
</p></div></div><p ><span class='indexparent'><a class='index' id='atomic_flag_clear'></a></span><span class='indexparent'><a class='index' id='atomic_flag_clear_explicit'></a></span><span class='indexparent'><a class='index' id='clear,atomic_flag'></a></span><span class='indexparent'><a class='index' id='atomic_flag,clear'></a></span></p><p ><code class='itemdecl'>void atomic_flag_clear(volatile atomic_flag* object) noexcept;
void atomic_flag_clear(atomic_flag* object) noexcept;
void atomic_flag_clear_explicit(volatile atomic_flag* object, memory_order order) noexcept;
void atomic_flag_clear_explicit(atomic_flag* object, memory_order order) noexcept;
void atomic_flag::clear(memory_order order = memory_order_seq_cst) volatile noexcept;
void atomic_flag::clear(memory_order order = memory_order_seq_cst) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='flag-7'><div class='marginalizedparent'><a class='marginalized' href='#flag-7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1426'>#</a></div><p ><span class='textit'>Requires:</span> The <span class='texttt'>order</span> argument shall not be <span class='texttt'>memory_&shy;order_&shy;consume</span>,
<span class='texttt'>memory_&shy;order_&shy;acquire</span>, nor <span class='texttt'>memory_&shy;order_&shy;acq_&shy;rel</span>.</p></div></div><div class='para' id='flag-8'><div class='marginalizedparent'><a class='marginalized' href='#flag-8'>8</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1430'>#</a></div><p ><span class='textit'>Effects:</span> Atomically sets the value pointed to by <span class='texttt'>object</span> or by <span class='texttt'>this</span> to
<span class='texttt'>false</span>. Memory is affected according to the value of <span class='texttt'>order</span>.
</p></div></div></div><div id='fences'><h2 ><a class='secnum' href='#fences' style='min-width:88pt'>29.8</a> Fences <a class='abbr_ref' href='atomics.fences'>[atomics.fences]</a></h2><div class='para' id='fences-1'><div class='marginalizedparent'><a class='marginalized' href='#fences-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1437'>#</a></div><p >This section introduces synchronization primitives called <a class='hidden_link' href='#def:fences' id='def:fences'><i>fences</i></a>. Fences can have
acquire semantics, release semantics, or both. A fence with acquire semantics is called
an <a class='hidden_link' href='#def:acquire_fence' id='def:acquire_fence'><i>acquire fence</i></a>. A fence with release semantics is called a <a class='hidden_link' href='#def:release
fence' id='def:release
fence'><i>release
fence</i></a>.</p></div><div class='para' id='fences-2'><div class='marginalizedparent'><a class='marginalized' href='#fences-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1443'>#</a></div><p >A release fence <span class='textit'>A</span> synchronizes with an acquire fence <span class='textit'>B</span> if there exist
atomic operations <span class='textit'>X</span> and <span class='textit'>Y</span>, both operating on some atomic object
<span class='textit'>M</span>, such that <span class='textit'>A</span> is sequenced before <span class='textit'>X</span>, <span class='textit'>X</span> modifies
<span class='textit'>M</span>, <span class='textit'>Y</span> is sequenced before <span class='textit'>B</span>, and <span class='textit'>Y</span> reads the value
written by <span class='textit'>X</span> or a value written by any side effect in the hypothetical release
sequence <span class='textit'>X</span> would head if it were a release operation.</p></div><div class='para' id='fences-3'><div class='marginalizedparent'><a class='marginalized' href='#fences-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1451'>#</a></div><p >A release fence <span class='textit'>A</span> synchronizes with an atomic operation <span class='textit'>B</span> that
performs an acquire operation on an atomic object <span class='textit'>M</span> if there exists an atomic
operation <span class='textit'>X</span> such that <span class='textit'>A</span> is sequenced before <span class='textit'>X</span>, <span class='textit'>X</span>
modifies <span class='textit'>M</span>, and <span class='textit'>B</span> reads the value written by <span class='textit'>X</span> or a value
written by any side effect in the hypothetical release sequence <span class='textit'>X</span> would head if
it were a release operation.</p></div><div class='para' id='fences-4'><div class='marginalizedparent'><a class='marginalized' href='#fences-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1459'>#</a></div><p >An atomic operation <span class='textit'>A</span> that is a release operation on an atomic object
<span class='textit'>M</span> synchronizes with an acquire fence <span class='textit'>B</span> if there exists some atomic
operation <span class='textit'>X</span> on <span class='textit'>M</span> such that <span class='textit'>X</span> is sequenced before <span class='textit'>B</span>
and reads the value written by <span class='textit'>A</span> or a value written by any side effect in the
release sequence headed by <span class='textit'>A</span>.</p><p ><span class='indexparent'><a class='index' id='atomic_thread_fence'></a></span></p></div><p ><code class='itemdecl'>extern "C" void atomic_thread_fence(memory_order order) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='fences-5'><div class='marginalizedparent'><a class='marginalized' href='#fences-5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1472'>#</a></div><p ><span class='textit'>Effects:</span> Depending on the value of <span class='texttt'>order</span>, this operation:</p><ul class='itemize'><li id='fences-5.1'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#fences-5.1'>(5.1)</a></div><p >has no effects, if <span class='texttt'>order == memory_&shy;order_&shy;relaxed</span>;</p></li><li id='fences-5.2'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#fences-5.2'>(5.2)</a></div><p >is an acquire fence, if <span class='texttt'>order == memory_&shy;order_&shy;acquire || order ==
memory_&shy;order_&shy;consume</span>;</p></li><li id='fences-5.3'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#fences-5.3'>(5.3)</a></div><p >is a release fence, if <span class='texttt'>order == memory_&shy;order_&shy;release</span>;</p></li><li id='fences-5.4'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#fences-5.4'>(5.4)</a></div><p >is both an acquire fence and a release fence, if <span class='texttt'>order ==
memory_&shy;order_&shy;acq_&shy;rel</span>;</p></li><li id='fences-5.5'><div class='marginalizedparent' style='left:-10em'><a class='marginalized' href='#fences-5.5'>(5.5)</a></div><p >is a sequentially consistent acquire and release fence, if <span class='texttt'>order == memory_&shy;order_&shy;seq_&shy;cst</span>.
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='atomic_signal_fence'></a></span></p><p ><code class='itemdecl'>extern "C" void atomic_signal_fence(memory_order order) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='fences-6'><div class='marginalizedparent'><a class='marginalized' href='#fences-6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1496'>#</a></div><p ><span class='textit'>Effects:</span> Equivalent to <span class='texttt'>atomic_&shy;thread_&shy;fence(order)</span>, except that
the resulting ordering constraints are established only between a thread and a
signal handler executed in the same thread.</p></div></div><div class='para' id='fences-7'><div class='marginalizedparent'><a class='marginalized' href='#fences-7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L1501'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>
<span class='texttt'>atomic_&shy;signal_&shy;fence</span> can be used to specify the order in which actions
performed by the thread become visible to the signal handler.
Compiler optimizations and reorderings of loads and stores are inhibited in
the same way as with <span class='texttt'>atomic_&shy;thread_&shy;fence</span>, but the hardware fence instructions
that <span class='texttt'>atomic_&shy;thread_&shy;fence</span> would have inserted are not emitted.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]
</p></div></div></div></div></div></body></html>