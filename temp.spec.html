<!DOCTYPE html><html lang='en'><head><title>[temp.spec]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><div id='temp.spec'><h2 ><a class='secnum' style='min-width:88pt'>14.7</a> Template instantiation and specialization <a class='abbr_ref'>[temp.spec]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='specialization!template'></a></span>The act of instantiating a function, a class, a member of a class template or
a member template is referred to as
<i>template instantiation</i>.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A function instantiated from a function template is called an instantiated
function.
A class instantiated from a class template is called an instantiated class.
A member function, a member class, a member enumeration, or a static data member of a class template
instantiated from the member definition of the class template is called,
respectively, an instantiated member function, member class, member enumeration, or static data
member.
A member function instantiated from a member function template is called an
instantiated member function.
A member class instantiated from a member class template is called an
instantiated member class.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >An explicit specialization may be declared for a function template,
a class template, a member of a class template or a member template.
An explicit specialization declaration is introduced by
<span class='texttt'>template&lt;&gt;</span>.
In an explicit specialization declaration for a class template,
a member of a class template or a class member template,
the name of the class that is explicitly specialized shall be a
<i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>.
In the explicit specialization declaration for a function template or
a member function template,
the name of the function or member function explicitly specialized may be a
<i ><a href='temp.names#template-id'>template-id</a></i>.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T = int&gt; struct A {
  static int x;
};
template&lt;class U&gt; void g(U) { }

template&lt;&gt; struct A&lt;double&gt; { };        <span class='comment'>// specialize for <span class='texttt'>T == double</span>
</span>template&lt;&gt; struct A&lt;&gt; { };              <span class='comment'>// specialize for <span class='texttt'>T == int</span>
</span>template&lt;&gt; void g(char) { }             <span class='comment'>// specialize for <span class='texttt'>U == char</span>
</span>                                        <span class='comment'>// <span class='texttt'>U</span> is deduced from the parameter type
</span>template&lt;&gt; void g&lt;int&gt;(int) { }         <span class='comment'>// specialize for <span class='texttt'>U == int</span>
</span>template&lt;&gt; int A&lt;char&gt;::x = 0;          <span class='comment'>// specialize for <span class='texttt'>T == char</span>
</span>
template&lt;class T = int&gt; struct B {
  static int x;
};
template&lt;&gt; int B&lt;&gt;::x = 1;              <span class='comment'>// specialize for <span class='texttt'>T == int</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >An instantiated template specialization can be either implicitly
instantiated (<a href='temp.inst'>[temp.inst]</a>) for a given argument list or be explicitly
instantiated (<a href='temp.explicit'>[temp.explicit]</a>).
A specialization is a class, function, or class member that is either
instantiated or explicitly specialized (<a href='temp.expl.spec'>[temp.expl.spec]</a>).</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >For a given template and a given set of
<i ><a href='temp.names#template-argument'>template-arguments</a></i>,
</p><ul ><li ><p >an explicit instantiation definition shall appear at most once in a program,
</p></li><li ><p >an explicit specialization shall be defined at most once
in a program (according to <a href='basic.def.odr'>[basic.def.odr]</a>), and
</p></li><li ><p >both an explicit instantiation and a declaration of an
explicit specialization shall not appear in a program unless
the explicit instantiation follows a declaration of the explicit
specialization.
</p></li></ul><p >An implementation is not required to diagnose a violation of this rule.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >Each class template specialization instantiated from a template has its own
copy of any static members.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class X {
  static T s;
};
template&lt;class T&gt; T X&lt;T&gt;::s = 0;
X&lt;int&gt; aa;
X&lt;char*&gt; bb;
</pre><p ><span class='texttt'>X&lt;int&gt;</span>
has a static member
<span class='texttt'>s</span>
of type
<span class='texttt'>int</span>
and
<span class='texttt'>X&lt;char*&gt;</span>
has a static member
<span class='texttt'>s</span>
of type
<span class='texttt'>char*</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >If a function declaration acquired its function type through
a dependent type (<a href='temp.dep.type'>[temp.dep.type]</a>) without using the syntactic form of
a function declarator, the program is ill-formed.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  static T t;
};
typedef int function();
A&lt;function&gt; a;                  <span class='comment'>// ill-formed: would declare <span class='texttt'>A&lt;function&gt;::t</span>
</span>                                <span class='comment'>// as a static member function
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div id='temp.inst'><h3 ><a class='secnum' href='#temp.inst' style='min-width:103pt'>14.7.1</a> Implicit instantiation <a class='abbr_ref' href='temp.inst'>[temp.inst]</a></h3><div class='para' id='temp.inst-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.inst-1'>1</a></div><p ><span class='indexparent'><a class='index' id='instantiation!template implicit'></a></span>Unless a class template specialization has been explicitly
instantiated (<a href='temp.explicit'>[temp.explicit]</a>) or explicitly
specialized (<a href='temp.expl.spec'>[temp.expl.spec]</a>),
the class template specialization is implicitly instantiated when the
specialization is referenced in a context that requires a completely-defined
object type or when the completeness of the class type affects the semantics
of the program.
[&nbsp;<i>Note:</i><span class='space'></span>
In particular, if the semantics of an expression depend on the member or
base class lists of a class template specialization, the class template
specialization is implicitly generated. For instance, deleting a pointer
to class type depends on whether or not the class declares a destructor,
and a conversion between pointers to class type depends on the
inheritance relationship between the two classes involved.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; class B { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; class D : public B&lt;T&gt; { <span class='comment'>/* ... */</span> };

void f(void*);
void f(B&lt;int&gt;*);

void g(D&lt;int&gt;* p, D&lt;char&gt;* pp, D&lt;double&gt;* ppp) {
  f(p);            <span class='comment'>// instantiation of <span class='texttt'>D&lt;int&gt;</span> required: call <span class='texttt'>f(B&lt;int&gt;*)</span>
</span>  B&lt;char&gt;* q = pp; <span class='comment'>// instantiation of <span class='texttt'>D&lt;char&gt;</span> required:
</span>                   <span class='comment'>// convert <span class='texttt'>D&lt;char&gt;*</span> to <span class='texttt'>B&lt;char&gt;*</span>
</span>  delete ppp;      <span class='comment'>// instantiation of <span class='texttt'>D&lt;double&gt;</span> required
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
If a class template has been declared, but not defined,
at the point of instantiation (<a href='temp.point'>[temp.point]</a>),
the instantiation yields an incomplete class type (<a href='basic.types'>[basic.types]</a>).
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; class X;

X&lt;char&gt; ch;      <span class='comment'>// error: incomplete type <span class='texttt'>X&lt;char&gt;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i><span class='space'></span>
Within a template declaration,
a local class (<a href='class.local'>[class.local]</a>) or enumeration and the members of
a local class are never considered to be entities that can be separately
instantiated (this includes their default arguments,
<i ><a href='except.spec#exception-specification'>exception-specifications</a></i>, and non-static data member
initializers, if any). As a result, the dependent names are looked up, the
semantic constraints are checked, and any templates used are instantiated as
part of the instantiation of the entity within which the local class or
enumeration is declared.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The implicit instantiation of a class template specialization causes
the implicit instantiation of the declarations, but not of the definitions,
default arguments, or <i ><a href='except.spec#exception-specification'>exception-specifications</a></i> of the class member functions,
member classes, scoped member enumerations, static data members and member templates; and it causes the
implicit instantiation of the definitions of unscoped member enumerations and member anonymous unions.
However, for the purpose of determining whether an instantiated redeclaration
of a member is valid according to <a href='class.mem'>[class.mem]</a>, a declaration that
corresponds to a definition in the template is considered to be a
definition.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T, class U&gt;
struct Outer {
  template&lt;class X, class Y&gt; struct Inner;
  template&lt;class Y&gt; struct Inner&lt;T, Y&gt;;         <span class='comment'>// #1a
</span>  template&lt;class Y&gt; struct Inner&lt;T, Y&gt; { };     <span class='comment'>// #1b; OK: valid redeclaration of #1a
</span>  template&lt;class Y&gt; struct Inner&lt;U, Y&gt; { };     <span class='comment'>// #2
</span>};

Outer&lt;int, int&gt; outer;                          <span class='comment'>// error at #2
</span></pre><p ><span class='texttt'>Outer&lt;int, int&gt;::Inner&lt;int, Y&gt;</span> is redeclared at #1b. (It is not defined
but noted as being associated with a definition in <span class='texttt'>Outer&lt;T, U&gt;</span>.) #2
is also a redeclaration of #1a. It is noted as associated with a definition,
so it is an invalid redeclaration of the same partial specialization.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.inst-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.inst-2'>2</a></div><p >Unless a member of a class template or a member template has been explicitly
instantiated or explicitly specialized,
the specialization of the member is implicitly instantiated when the
specialization is referenced in a context that requires the member definition
to exist;
in particular, the initialization (and any associated side effects) of a
static data member does not occur unless the static data member is itself used
in a way that requires the definition of the static data member to exist.</p></div><div class='para' id='temp.inst-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.inst-3'>3</a></div><p >Unless a function template specialization has been explicitly instantiated or
explicitly specialized,
the function template specialization is implicitly instantiated when the
specialization is referenced in a context that requires a function definition
to exist.
Unless a call is to a function template explicit specialization or
to a member function of an explicitly specialized class template,
a default argument for a function template or a member function of a
class template is implicitly instantiated when the function is
called in a context that requires the value of the default argument.</p></div><div class='para' id='temp.inst-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.inst-4'>4</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; struct Z {
  void f();
  void g();
};

void h() {
  Z&lt;int&gt; a;         <span class='comment'>// instantiation of class <span class='texttt'>Z&lt;int&gt;</span> required
</span>  Z&lt;char&gt;* p;       <span class='comment'>// instantiation of class <span class='texttt'>Z&lt;char&gt;</span> not required
</span>  Z&lt;double&gt;* q;     <span class='comment'>// instantiation of class <span class='texttt'>Z&lt;double&gt;</span> not required
</span>
  a.f();            <span class='comment'>// instantiation of <span class='texttt'>Z&lt;int&gt;::f()</span> required
</span>  p-&gt;g();           <span class='comment'>// instantiation of class <span class='texttt'>Z&lt;char&gt;</span> required, and
</span>                    <span class='comment'>// instantiation of <span class='texttt'>Z&lt;char&gt;::g()</span> required
</span>}
</pre><p >Nothing in this example requires
<span class='texttt'>class</span>
<span class='texttt'>Z&lt;double&gt;</span>,
<span class='texttt'>Z&lt;int&gt;::g()</span>,
or
<span class='texttt'>Z&lt;char&gt;::f()</span>
to be implicitly instantiated.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.inst-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.inst-5'>5</a></div><p >Unless a variable template specialization has been explicitly instantiated or
explicitly specialized, the variable template specialization is implicitly
instantiated when the specialization is used. A default template argument for a
variable template is implicitly instantiated when the variable template is
referenced in a context that requires the value of the default argument.</p></div><div class='para' id='temp.inst-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.inst-6'>6</a></div><p >If the function selected by overload resolution (<a href='over.match'>[over.match]</a>)
can be determined without instantiating a class template definition,
it is unspecified whether that instantiation actually takes place.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T&gt; struct S {
  operator int();
};

void f(int);
void f(S&lt;int&gt;&amp;);
void f(S&lt;float&gt;);

void g(S&lt;int&gt;&amp; sr) {
  f(sr);            <span class='comment'>// instantiation of <span class='texttt'>S&lt;int&gt;</span> allowed but not required
</span>                    <span class='comment'>// instantiation of <span class='texttt'>S&lt;float&gt;</span> allowed but not required
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.inst-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.inst-7'>7</a></div><p >If a function template or a member function template specialization is used in
a way that involves overload resolution,
a declaration of the specialization is implicitly instantiated (<a href='temp.over'>[temp.over]</a>).</p></div><div class='para' id='temp.inst-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.inst-8'>8</a></div><p >An implementation shall not implicitly instantiate a function template,
a variable template,
a member template, a non-virtual member function, a member class, a
static data member of a class template, or a substatement of a constexpr if
statement (<a href='stmt.if'>[stmt.if]</a>), unless such instantiation is required.
It is unspecified whether or not an implementation implicitly instantiates a
virtual member function of a class template if the virtual member function would
not otherwise be instantiated.
The use of a template specialization in a default argument
shall not cause the template to be implicitly instantiated except that a
class template may be instantiated where its complete type is needed to determine
the correctness of the default argument.
The use of a default argument in a
function call causes specializations in the default argument to be implicitly
instantiated.</p></div><div class='para' id='temp.inst-9'><div class='marginalizedparent'><a class='marginalized' href='#temp.inst-9'>9</a></div><p >Implicitly instantiated class, function, and variable template specializations
are placed in the namespace where the template is defined.
Implicitly instantiated specializations for members of a class template are
placed in the namespace where the enclosing class template is defined.
Implicitly instantiated member templates are placed in the namespace where the
enclosing class or class template is defined.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace N {
  template&lt;class T&gt; class List {
  public:
    T* get();
  };
}

template&lt;class K, class V&gt; class Map {
public:
  N::List&lt;V&gt; lt;
  V get(K);
};

void g(Map&lt;const char*,int&gt;&amp; m) {
  int i = m.get("Nicholas");
}
</pre><p >a call of
<span class='texttt'>lt.get()</span>
from
<span class='texttt'>Map&lt;const char*,int&gt;::get()</span>
would place
<span class='texttt'>List&lt;int&gt;::get()</span>
in the namespace
<span class='texttt'>N</span>
rather than in the global namespace.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.inst-10'><div class='marginalizedparent'><a class='marginalized' href='#temp.inst-10'>10</a></div><p >If a function template
<span class='texttt'>f</span>
is called in a way that requires a default argument to be used,
the dependent names are looked up, the semantics constraints are checked,
and the instantiation of any template used in the default argument
is done as if the default argument had been
an initializer used in a function template specialization with the same scope,
the same template parameters and the same access as that of the function template
<span class='texttt'>f</span>
used at that point, except that the scope in which a closure type is
declared (<a href='expr.prim.lambda'>[expr.prim.lambda]</a>) – and therefore its associated namespaces –
remain as determined from the context of the definition for the default
argument.
This analysis is called
<i>default argument instantiation</i>.
The instantiated default argument is then used as the argument of
<span class='texttt'>f</span>.</p></div><div class='para' id='temp.inst-11'><div class='marginalizedparent'><a class='marginalized' href='#temp.inst-11'>11</a></div><p >Each default argument is instantiated independently.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; void f(T x, T y = ydef(T()), T z = zdef(T()));

class  A { };

A zdef(A);

void g(A a, A b, A c) {
  f(a, b, c);       <span class='comment'>// no default argument instantiation
</span>  f(a, b);          <span class='comment'>// default argument <span class='texttt'>z = zdef(T())</span> instantiated
</span>  f(a);             <span class='comment'>// ill-formed; <span class='texttt'>ydef</span> is not declared
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.inst-12'><div class='marginalizedparent'><a class='marginalized' href='#temp.inst-12'>12</a></div><p >The <i ><a href='except.spec#exception-specification'>exception-specification</a></i> of a function template specialization
is not instantiated along with the function declaration; it is instantiated
when needed (<a href='except.spec'>[except.spec]</a>). If such an
<i ><a href='except.spec#exception-specification'>exception-specification</a></i> is needed but has not yet been
instantiated, the dependent names are looked up, the semantics constraints are
checked, and the instantiation of any template used in the
<i ><a href='except.spec#exception-specification'>exception-specification</a></i> is done as if it were being done as part
of instantiating the declaration of the specialization at that point.</p></div><div class='para' id='temp.inst-13'><div class='marginalizedparent'><a class='marginalized' href='#temp.inst-13'>13</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
<a href='temp.point'>[temp.point]</a> defines the point of instantiation of a template specialization.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.inst-14'><div class='marginalizedparent'><a class='marginalized' href='#temp.inst-14'>14</a></div><p >There is an <span class='indexparent'><a class='index' id='maximum depth of recursive template instantiations'></a></span>implementation-defined quantity
that specifies the limit on the total depth of recursive instantiations (<a href='implimits'>[implimits]</a>),
which could involve more than one template.
The result of an infinite recursion in instantiation is undefined.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class X {
  X&lt;T&gt;* p;          <span class='comment'>// OK
</span>  X&lt;T*&gt; a;          <span class='comment'>// implicit generation of <span class='texttt'>X&lt;T&gt;</span> requires
</span>                    <span class='comment'>// the implicit instantiation of <span class='texttt'>X&lt;T*&gt;</span> which requires
</span>                    <span class='comment'>// the implicit instantiation of <span class='texttt'>X&lt;T**&gt;</span> which ...
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='temp.explicit'><h3 ><a class='secnum' href='#temp.explicit' style='min-width:103pt'>14.7.2</a> Explicit instantiation <a class='abbr_ref' href='temp.explicit'>[temp.explicit]</a></h3><div class='para' id='temp.explicit-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.explicit-1'>1</a></div><p ><span class='indexparent'><a class='index' id='instantiation!explicit'></a></span>A class, function, variable, or member template specialization can be explicitly
instantiated from its template.
A member function, member class or static data member of a class template can
be explicitly instantiated from the member definition associated with its class
template. An explicit instantiation of a function template
or member function of a class template
shall not
use the <span class='texttt'>inline</span> or <span class='texttt'>constexpr</span> specifiers.</p></div><div class='para' id='temp.explicit-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.explicit-2'>2</a></div><p >The syntax for explicit instantiation is:</p><pre class='bnf'><a id='explicit-instantiation'>explicit-instantiation:</a>
  <span class='terminal'>extern<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <span class='terminal'>template</span> <i ><a href='dcl.dcl#declaration'>declaration</a></i></pre><p >There are two forms of explicit instantiation: an explicit instantiation
definition and an explicit instantiation declaration. An explicit instantiation
declaration begins with the <span class='texttt'>extern</span> keyword.</p></div><div class='para' id='temp.explicit-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.explicit-3'>3</a></div><p >If the explicit instantiation is for a class or member class, the
<i ><a href='dcl.type.elab#elaborated-type-specifier'>elaborated-type-specifier</a></i> in the <i ><a href='dcl.dcl#declaration'>declaration</a></i> shall
include a <i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>. If the explicit instantiation is for
a function or member function,
the
<i ><a href='expr.prim.id.unqual#unqualified-id'>unqualified-id</a></i>
in the
<i ><a href='dcl.dcl#declaration'>declaration</a></i>
shall be either a
<i ><a href='temp.names#template-id'>template-id</a></i>
or, where all template arguments can be deduced, a
<i ><a href='temp.names#template-name'>template-name</a></i> or <i ><a href='over.oper#operator-function-id'>operator-function-id</a></i>.
[&nbsp;<i>Note:</i><span class='space'></span>
The declaration may declare a
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>,
in which case the
<i ><a href='expr.prim.id.unqual#unqualified-id'>unqualified-id</a></i>
of the
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>
must be a
<i ><a href='temp.names#template-id'>template-id</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If the explicit instantiation is for a member function, a member class or
a static data member of a class template specialization,
the name of the class template specialization in the
<i ><a href='expr.prim.id.qual#qualified-id'>qualified-id</a></i>
for the member name shall be a <i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>.
If the explicit instantiation is for a variable, the
<i ><a href='expr.prim.id.unqual#unqualified-id'>unqualified-id</a></i> in the declaration shall be a
<i ><a href='temp.names#template-id'>template-id</a></i>.
An explicit instantiation shall appear in an enclosing namespace
of its template. If the name declared in the explicit
instantiation is an unqualified name, the explicit instantiation
shall appear in the namespace where its template is declared or, if that
namespace is inline (<a href='namespace.def'>[namespace.def]</a>), any namespace from its enclosing
namespace set.
[&nbsp;<i>Note:</i><span class='space'></span>
Regarding qualified names in declarators, see <a href='dcl.meaning'>[dcl.meaning]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class Array { void mf(); };
template class Array&lt;char&gt;;
template void Array&lt;int&gt;::mf();

template&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v) { <span class='comment'>/* ... */</span> }
template void sort(Array&lt;char&gt;&amp;);       <span class='comment'>// argument is deduced here
</span>
namespace N {
  template&lt;class T&gt; void f(T&amp;) { }
}
template void N::f&lt;int&gt;(int&amp;);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.explicit-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.explicit-4'>4</a></div><p >A declaration of a function template, a variable template, a member function
or static data member
of a class template, or a member function template of a class or class
template shall precede an explicit instantiation of that entity. A definition
of a class template, a member class of a class template, or a member class
template of a class or class template shall precede an explicit instantiation
of that entity unless the explicit instantiation is preceded by an explicit
specialization of the entity with the same template arguments.
If the
<i ><a href='dcl.dcl#declaration'>declaration</a></i>
of the explicit instantiation names an implicitly-declared special member
function (Clause <a href='special'>[special]</a>), the program is ill-formed.</p></div><div class='para' id='temp.explicit-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.explicit-5'>5</a></div><p >For a given set of template arguments, if an explicit
instantiation of a template appears after a declaration of
an explicit specialization for that template, the explicit
instantiation has no effect. Otherwise, for an explicit instantiation
definition the definition of a
function template, a variable template, a member
function template, or a member function or static
data member of a class template shall be present in every
translation unit in which it is explicitly instantiated.</p></div><div class='para' id='temp.explicit-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.explicit-6'>6</a></div><p >An explicit instantiation of a class, function template, or variable template
specialization is
placed in the namespace in which the template is defined.
An explicit instantiation for a member of a class template is placed in
the namespace where the enclosing class template is defined.
An explicit instantiation for a member template is placed in the namespace
where the enclosing class or class template is defined.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace N {
  template&lt;class T&gt; class Y { void mf() { } };
}

template class Y&lt;int&gt;;                  <span class='comment'>// error: class template <span class='texttt'>Y</span> not visible
</span>                                        <span class='comment'>// in the global namespace
</span>
using N::Y;
template class Y&lt;int&gt;;                  <span class='comment'>// error: explicit instantiation outside of the
</span>                                        <span class='comment'>// namespace of the template
</span>
template class N::Y&lt;char*&gt;;             <span class='comment'>// OK: explicit instantiation in namespace <span class='texttt'>N</span>
</span>template void N::Y&lt;double&gt;::mf();       <span class='comment'>// OK: explicit instantiation
</span>                                        <span class='comment'>// in namespace <span class='texttt'>N</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.explicit-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.explicit-7'>7</a></div><p >A trailing
<i ><a href='temp.names#template-argument'>template-argument</a></i>
can be left unspecified in an explicit instantiation of a function template
specialization or of a member function template specialization provided
it can be deduced from the type of a function parameter (<a href='temp.deduct'>[temp.deduct]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class Array { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v) { <span class='comment'>/* ... */</span> }

<span class='comment'>// instantiate <span class='texttt'>sort(Array&lt;int&gt;&amp;)</span> - template-argument deduced
</span>template void sort&lt;&gt;(Array&lt;int&gt;&amp;);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.explicit-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.explicit-8'>8</a></div><p >An explicit instantiation that names a class
template specialization is also an explicit
instantiation of the same kind (declaration or definition) of each
of its members (not including members inherited from base classes and members
that are templates) that has not been previously explicitly specialized in
the translation unit containing the explicit instantiation,
except as described below.
[&nbsp;<i>Note:</i><span class='space'></span> In addition, it will typically be an explicit instantiation of certain
implementation-dependent data about the class. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.explicit-9'><div class='marginalizedparent'><a class='marginalized' href='#temp.explicit-9'>9</a></div><p >An explicit instantiation definition that names a class template
specialization explicitly instantiates the class template specialization
and is an explicit instantiation definition of only those
members that have been defined at the point of instantiation.</p></div><div class='para' id='temp.explicit-10'><div class='marginalizedparent'><a class='marginalized' href='#temp.explicit-10'>10</a></div><p >Except for inline functions and variables, declarations with types deduced from their
initializer or return value (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>), <span class='texttt'>const</span> variables of
literal types,
variables of reference types, and class template specializations,
explicit instantiation declarations have the
effect of suppressing the implicit instantiation of the entity to which they
refer. [&nbsp;<i>Note:</i><span class='space'></span> The intent is that an inline function that is the
subject of an explicit instantiation declaration will still be implicitly
instantiated when odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>) so that the body can be considered for inlining, but
that no out-of-line copy of the inline function would be generated in the
translation unit.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.explicit-11'><div class='marginalizedparent'><a class='marginalized' href='#temp.explicit-11'>11</a></div><p >If an entity is the subject of both an explicit instantiation declaration
and an explicit instantiation definition in the same translation unit, the
definition shall follow the declaration. An entity that is the subject of an
explicit instantiation declaration and that is also used
in a way that would otherwise cause an implicit instantiation (<a href='temp.inst'>[temp.inst]</a>)
in the translation unit
shall be the subject of an explicit instantiation definition somewhere in the
program; otherwise the program is ill-formed, no diagnostic required.
[&nbsp;<i>Note:</i><span class='space'></span> This rule does apply to inline functions even though an
explicit instantiation declaration of such an entity has no other normative
effect. This is needed to ensure that if the address of an inline function is
taken in a translation unit in which the implementation chose to suppress the
out-of-line body, another translation unit will supply the body.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
An explicit instantiation declaration shall not name a specialization of a
template with internal linkage.</p></div><div class='para' id='temp.explicit-12'><div class='marginalizedparent'><a class='marginalized' href='#temp.explicit-12'>12</a></div><p >The usual access checking rules do not apply to names used to specify
explicit instantiations.
[&nbsp;<i>Note:</i><span class='space'></span>
In particular, the template arguments and names used in the function
declarator (including parameter types, return types and exception
specifications) may be private types or objects which would normally
not be accessible and the template may be a member template or member
function which would not normally be accessible.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.explicit-13'><div class='marginalizedparent'><a class='marginalized' href='#temp.explicit-13'>13</a></div><p >An explicit instantiation does not constitute a use of a default argument,
so default argument instantiation is not done.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
char* p = 0;
template&lt;class T&gt; T g(T x = &amp;p) { return x; }
template int g&lt;int&gt;(int);       <span class='comment'>// OK even though <span class='texttt'>&amp;p</span> isn't an <span class='texttt'>int</span>.
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='temp.expl.spec'><h3 ><a class='secnum' href='#temp.expl.spec' style='min-width:103pt'>14.7.3</a> Explicit specialization <a class='abbr_ref' href='temp.expl.spec'>[temp.expl.spec]</a></h3><div class='para' id='temp.expl.spec-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-1'>1</a></div><p ><span class='indexparent'><a class='index' id='specialization!template explicit'></a></span>An explicit specialization of any of the following:</p><ul ><li ><p >function template
</p></li><li ><p >class template
</p></li><li ><p >variable template
</p></li><li ><p >member function of a class template
</p></li><li ><p >static data member of a class template
</p></li><li ><p >member class of a class template
</p></li><li ><p >member enumeration of a class template
</p></li><li ><p >member class template of a class or class template
</p></li><li ><p >member function template of a class or class template
</p></li></ul><p >can be declared by a declaration introduced by
<span class='texttt'>template&lt;&gt;</span>;
that is:
<span class='indexparent'><a class='index' id='explicit-specialization'></a></span>
</p><pre class='bnf'><a id='explicit-specialization'>explicit-specialization:</a>
  <span class='terminal'>template &lt; &gt;</span> <i ><a href='dcl.dcl#declaration'>declaration</a></i></pre><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class T&gt; class stream;

template&lt;&gt; class stream&lt;char&gt; { <span class='comment'>/* ... */</span> };

template&lt;class T&gt; class Array { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v) { <span class='comment'>/* ... */</span> }

template&lt;&gt; void sort&lt;char*&gt;(Array&lt;char*&gt;&amp;);
</pre><p >Given these declarations,
<span class='texttt'>stream&lt;char&gt;</span>
will be used as the definition of streams of
<span class='texttt'>char</span>s;
other streams will be handled by class template specializations instantiated
from the class template.
Similarly,
<span class='texttt'>sort&lt;char*&gt;</span>
will be used as the sort function for arguments
of type
<span class='texttt'>Array&lt;char*&gt;</span>;
other
<span class='texttt'>Array</span>
types will be sorted by functions generated from the template.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.expl.spec-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-2'>2</a></div><p >An explicit specialization shall be declared in a namespace enclosing the specialized template.
An explicit specialization
whose <i ><a href='dcl.decl#declarator-id'>declarator-id</a></i> or <i ><a href='class#class-head-name'>class-head-name</a></i> is not qualified
shall be declared in the nearest enclosing namespace of the template,
or, if the namespace is inline (<a href='namespace.def'>[namespace.def]</a>), any namespace from its enclosing namespace set.
Such a declaration may also be a definition.
If the declaration is not a definition, the specialization may be
defined later (<a href='namespace.memdef'>[namespace.memdef]</a>).</p></div><div class='para' id='temp.expl.spec-3'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-3'>3</a></div><p >A declaration of a function template, class template, or variable template being explicitly
specialized shall precede the declaration of
the explicit
specialization.
[&nbsp;<i>Note:</i><span class='space'></span>
A declaration, but not a definition of the template is required.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
The definition of a class or class template shall precede the
declaration of an explicit specialization for a member template of the class
or class template.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;&gt; class X&lt;int&gt; { <span class='comment'>/* ... */</span> };          <span class='comment'>// error: <span class='texttt'>X</span> not a template
</span>
template&lt;class T&gt; class X;

template&lt;&gt; class X&lt;char*&gt; { <span class='comment'>/* ... */</span> };        <span class='comment'>// OK: <span class='texttt'>X</span> is a template
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.expl.spec-4'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-4'>4</a></div><p >A member function, a member function template, a member class,
a member enumeration, a
member class template,
a static data member, or a static data member template of a class template
may be explicitly specialized for a class specialization that is implicitly
instantiated;
in this case, the definition of the class template shall
precede the explicit specialization for the member of the class
template.
If such an explicit specialization for the member of a class template names an
implicitly-declared special member function (Clause <a href='special'>[special]</a>),
the program is ill-formed.</p></div><div class='para' id='temp.expl.spec-5'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-5'>5</a></div><p >A member of an explicitly specialized class is not implicitly
instantiated from the member declaration of the class template;
instead, the member of the class template specialization shall itself be
explicitly defined if its definition is required.
In this case, the definition of the class template explicit specialization
shall be in scope at the point at which the member is defined.
The definition of an explicitly specialized class is unrelated to the
definition of a generated specialization.
That is, its members need
not have the same names, types, etc. as the members of a generated
specialization.
Members of an explicitly specialized
class template are defined in the same manner as members of normal classes, and
not using the <span class='texttt'>template&lt;&gt;</span> syntax.
The same is true when defining a member of an explicitly specialized member
class. However, <span class='texttt'>template&lt;&gt;</span> is used in defining a member of an explicitly
specialized member class template that is specialized as a class template.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  struct B { };
  template&lt;class U&gt; struct C { };
};

template&lt;&gt; struct A&lt;int&gt; {
  void f(int);
};

void h() {
  A&lt;int&gt; a;
  a.f(16);          <span class='comment'>// <span class='texttt'>A&lt;int&gt;::f</span> must be defined somewhere
</span>}

<span class='comment'>// <span class='texttt'>template&lt;&gt;</span> not used for a member of an
</span><span class='comment'>// explicitly specialized class template
</span>void A&lt;int&gt;::f(int) { <span class='comment'>/* ... */</span> }

template&lt;&gt; struct A&lt;char&gt;::B {
  void f();
};
<span class='comment'>// <span class='texttt'>template&lt;&gt;</span> also not used when defining a member of
</span><span class='comment'>// an explicitly specialized member class
</span>void A&lt;char&gt;::B::f() { <span class='comment'>/* ... */</span> }

template&lt;&gt; template&lt;class U&gt; struct A&lt;char&gt;::C {
  void f();
};
<span class='comment'>// <span class='texttt'>template&lt;&gt;</span> is used when defining a member of an explicitly
</span><span class='comment'>// specialized member class template specialized as a class template
</span>template&lt;&gt;
template&lt;class U&gt; void A&lt;char&gt;::C&lt;U&gt;::f() { <span class='comment'>/* ... */</span> }

template&lt;&gt; struct A&lt;short&gt;::B {
  void f();
};
template&lt;&gt; void A&lt;short&gt;::B::f() { <span class='comment'>/* ... */</span> }  <span class='comment'>// error: <span class='texttt'>template&lt;&gt;</span> not permitted
</span>
template&lt;&gt; template&lt;class U&gt; struct A&lt;short&gt;::C {
  void f();
};
template&lt;class U&gt; void A&lt;short&gt;::C&lt;U&gt;::f() { <span class='comment'>/* ... */</span> }  <span class='comment'>// error: <span class='texttt'>template&lt;&gt;</span> required
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.expl.spec-6'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-6'>6</a></div><p >If a template, a member template or a member of a class template is explicitly
specialized then that specialization shall be declared before the first use of
that specialization that would cause an implicit instantiation to take place,
in every translation unit in which such a use occurs;
no diagnostic is required.
If the program does not provide a definition for an explicit specialization and
either the specialization is used in a way that would cause an implicit
instantiation to take place or the member is a virtual member function,
the program is ill-formed, no diagnostic required.
An implicit instantiation is never generated for an explicit specialization
that is declared but not defined.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
class String { };
template&lt;class T&gt; class Array { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v) { <span class='comment'>/* ... */</span> }

void f(Array&lt;String&gt;&amp; v) {
  sort(v);          <span class='comment'>// use primary template
</span>                    <span class='comment'>// <span class='texttt'>sort(Array&lt;T&gt;&amp;)</span>, <span class='texttt'>T</span> is <span class='texttt'>String</span>
</span>}

template&lt;&gt; void sort&lt;String&gt;(Array&lt;String&gt;&amp; v); <span class='comment'>// error: specialization
</span>                                                <span class='comment'>// after use of primary template
</span>template&lt;&gt; void sort&lt;&gt;(Array&lt;char*&gt;&amp; v);        <span class='comment'>// OK: <span class='texttt'>sort&lt;char*&gt;</span> not yet used
</span>template&lt;class T&gt; struct A {
  enum E : T;
  enum class S : T;
};
template&lt;&gt; enum A&lt;int&gt;::E : int { eint };         <span class='comment'>// OK
</span>template&lt;&gt; enum class A&lt;int&gt;::S : int { sint };   <span class='comment'>// OK
</span>template&lt;class T&gt; enum A&lt;T&gt;::E : T { eT };
template&lt;class T&gt; enum class A&lt;T&gt;::S : T { sT };
template&lt;&gt; enum A&lt;char&gt;::E : char { echar };       <span class='comment'>// ill-formed, <span class='texttt'>A&lt;char&gt;::E</span> was instantiated
</span>                                                   <span class='comment'>// when <span class='texttt'>A&lt;char&gt;</span> was instantiated
</span>template&lt;&gt; enum class A&lt;char&gt;::S : char { schar }; <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.expl.spec-7'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-7'>7</a></div><p >The placement of explicit specialization declarations for function templates, class
templates, variable templates,
member functions of class templates, static data members of class
templates, member classes of class templates, member enumerations of class
templates, member class templates of class
templates, member function templates of class templates,
static data member templates of class templates,
member functions of
member templates of class templates, member functions of member templates of
non-template classes,
static data member templates of non-template classes,
member function templates of member classes of class
templates, etc., and the placement of partial specialization declarations
of class templates, variable templates,
member class templates of non-template classes,
static data member templates of non-template classes, member
class templates of class templates, etc., can affect whether a program is
well-formed according to the relative positioning of the explicit specialization
declarations and their points of instantiation in the translation unit as
specified above and below.
<span class='indexparent'><a class='index' id='immolation!self'></a></span>When writing a specialization, be careful about its location;
or to make it compile will be such a trial as to kindle its self-immolation.</p></div><div class='para' id='temp.expl.spec-8'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-8'>8</a></div><p >A template explicit specialization is in the scope of the namespace in which
the template was defined.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
namespace N {
  template&lt;class T&gt; class X { <span class='comment'>/* ... */</span> };
  template&lt;class T&gt; class Y { <span class='comment'>/* ... */</span> };

  template&lt;&gt; class X&lt;int&gt; { <span class='comment'>/* ... */</span> };          <span class='comment'>// OK: specialization
</span>                                                <span class='comment'>// in same namespace
</span>  template&lt;&gt; class Y&lt;double&gt;;                   <span class='comment'>// forward declare intent to
</span>                                                <span class='comment'>// specialize for <span class='texttt'>double</span>
</span>}

template&lt;&gt; class N::Y&lt;double&gt; { <span class='comment'>/* ... */</span> };      <span class='comment'>// OK: specialization
</span>                                                <span class='comment'>// in enclosing namespace
</span>template&lt;&gt; class N::Y&lt;short&gt; { <span class='comment'>/* ... */</span> };       <span class='comment'>// OK: specialization
</span>                                                <span class='comment'>// in enclosing namespace
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.expl.spec-9'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-9'>9</a></div><p >A
<i ><a href='temp.names#simple-template-id'>simple-template-id</a></i>
that names a class template explicit specialization that has been declared but
not defined can be used exactly like the names of other incompletely-defined
classes (<a href='basic.types'>[basic.types]</a>).
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class X;      <span class='comment'>// <span class='texttt'>X</span> is a class template
</span>template&lt;&gt; class X&lt;int&gt;;

X&lt;int&gt;* p;                      <span class='comment'>// OK: pointer to declared class <span class='texttt'>X&lt;int&gt;</span>
</span>X&lt;int&gt; x;                       <span class='comment'>// error: object of incomplete class <span class='texttt'>X&lt;int&gt;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.expl.spec-10'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-10'>10</a></div><p >A trailing
<i ><a href='temp.names#template-argument'>template-argument</a></i>
can be left unspecified in the
<i ><a href='temp.names#template-id'>template-id</a></i>
naming an explicit function template specialization
provided it can be deduced from the function argument type.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; class Array { <span class='comment'>/* ... */</span> };
template&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v);

<span class='comment'>// explicit specialization for <span class='texttt'>sort(Array&lt;int&gt;&amp;)</span>
</span><span class='comment'>// with deduced template-argument of type <span class='texttt'>int</span>
</span>template&lt;&gt; void sort(Array&lt;int&gt;&amp;);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.expl.spec-11'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-11'>11</a></div><p >A function with the same name as a template and a type that exactly matches that
of a template specialization is not an explicit specialization (<a href='temp.fct'>[temp.fct]</a>).</p></div><div class='para' id='temp.expl.spec-12'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-12'>12</a></div><p >An explicit specialization of a function or variable template is inline
only if it is declared with the <span class='texttt'>inline</span>
specifier or defined as deleted, and independently of whether its
function or variable template is inline.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; void f(T) { <span class='comment'>/* ... */</span> }
template&lt;class T&gt; inline T g(T) { <span class='comment'>/* ... */</span> }

template&lt;&gt; inline void f&lt;&gt;(int) { <span class='comment'>/* ... */</span> }   <span class='comment'>// OK: inline
</span>template&lt;&gt; int g&lt;&gt;(int) { <span class='comment'>/* ... */</span> }           <span class='comment'>// OK: not inline
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.expl.spec-13'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-13'>13</a></div><p >An explicit specialization of a static data member of a template
or an explicit specialization of a static data member template is a
definition if the declaration includes an initializer;
otherwise, it is a declaration.
[&nbsp;<i>Note:</i><span class='space'></span>
The definition of a static data member of a template
that requires default-initialization must use a <i ><a href='dcl.init#braced-init-list'>braced-init-list</a></i>:</p><pre class='codeblock'>
template&lt;&gt; X Q&lt;int&gt;::x;         <span class='comment'>// declaration
</span>template&lt;&gt; X Q&lt;int&gt;::x ();      <span class='comment'>// error: declares a function
</span>template&lt;&gt; X Q&lt;int&gt;::x { };     <span class='comment'>// definition
</span></pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='temp.expl.spec-14'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-14'>14</a></div><p >A member or a member template of a class template may be explicitly specialized
for a given implicit instantiation of the class template, even if the member
or member template is defined in the class template definition.
An explicit specialization of a member or member template is specified using the
syntax for explicit specialization.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  void f(T);
  template&lt;class X1&gt; void g1(T, X1);
  template&lt;class X2&gt; void g2(T, X2);
  void h(T) { }
};

<span class='comment'>// specialization
</span>template&lt;&gt; void A&lt;int&gt;::f(int);

<span class='comment'>// out of class member template definition
</span>template&lt;class T&gt; template&lt;class X1&gt; void A&lt;T&gt;::g1(T, X1) { }

<span class='comment'>// member template specialization
</span>template&lt;&gt; template&lt;class X1&gt; void A&lt;int&gt;::g1(int, X1);

<span class='comment'>//member template specialization
</span>template&lt;&gt; template&lt;&gt;
  void A&lt;int&gt;::g1(int, char);           <span class='comment'>// <span class='texttt'>X1</span> deduced as <span class='texttt'>char</span>
</span>template&lt;&gt; template&lt;&gt;
  void A&lt;int&gt;::g2&lt;char&gt;(int, char);     <span class='comment'>// <span class='texttt'>X2</span> specified as <span class='texttt'>char</span>
</span>
<span class='comment'>// member specialization even if defined in class definition
</span>template&lt;&gt; void A&lt;int&gt;::h(int) { }
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.expl.spec-15'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-15'>15</a></div><p >A member or a member template may be nested within many enclosing class
templates.
In an explicit specialization for such a member,
the member declaration shall be preceded by a
<span class='texttt'>template&lt;&gt;</span>
for each enclosing class template that is explicitly specialized.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class T1&gt; class A {
  template&lt;class T2&gt; class B {
    void mf();
  };
};
template&lt;&gt; template&lt;&gt; class A&lt;int&gt;::B&lt;double&gt;;
template&lt;&gt; template&lt;&gt; void A&lt;char&gt;::B&lt;char&gt;::mf();
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.expl.spec-16'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-16'>16</a></div><p >In an explicit specialization declaration for a member of a class template or
a member template that appears in namespace scope,
the member template and some of its enclosing class templates may remain
unspecialized,
except that the declaration shall not explicitly specialize a class member
template if its enclosing class templates are not explicitly specialized
as well.
In such explicit specialization declaration, the keyword
<span class='texttt'>template</span>
followed by a
<i ><a href='temp#template-parameter-list'>template-parameter-list</a></i>
shall be provided instead of the
<span class='texttt'>template&lt;&gt;</span>
preceding the explicit specialization declaration of the member.
The types of the
<i ><a href='temp.param#template-parameter'>template-parameters</a></i>
in the
<i ><a href='temp#template-parameter-list'>template-parameter-list</a></i>
shall be the same as those specified in the primary template definition.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template &lt;class T1&gt; class A {
  template&lt;class T2&gt; class B {
    template&lt;class T3&gt; void mf1(T3);
    void mf2();
  };
};
template &lt;&gt; template &lt;class X&gt;
  class A&lt;int&gt;::B {
      template &lt;class T&gt; void mf1(T);
  };
template &lt;&gt; template &lt;&gt; template&lt;class T&gt;
  void A&lt;int&gt;::B&lt;double&gt;::mf1(T t) { }
template &lt;class Y&gt; template &lt;&gt;
  void A&lt;Y&gt;::B&lt;double&gt;::mf2() { }       <span class='comment'>// ill-formed; <span class='texttt'>B&lt;double&gt;</span> is specialized but
</span>                                        <span class='comment'>// its enclosing class template <span class='texttt'>A</span> is not
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='temp.expl.spec-17'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-17'>17</a></div><p >A specialization of a member function template, member class template,
or static data member template of
a non-specialized class template is itself a template.</p></div><div class='para' id='temp.expl.spec-18'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-18'>18</a></div><p >An explicit specialization declaration shall not be a friend declaration.</p></div><div class='para' id='temp.expl.spec-19'><div class='marginalizedparent'><a class='marginalized' href='#temp.expl.spec-19'>19</a></div><p >Default function arguments shall not be specified in a declaration or
a definition for one of the following explicit specializations:</p><ul ><li ><p >the explicit specialization of a function template;
</p></li><li ><p >the explicit specialization of a member function template;
</p></li><li ><p >the explicit specialization of a member function of a class template where
the class template specialization to which the member function specialization
belongs is implicitly instantiated.
[&nbsp;<i>Note:</i><span class='space'></span>
Default function arguments may be specified in the declaration or
definition of a member function of a class template specialization that is
explicitly specialized.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div></div></div></div></body></html>