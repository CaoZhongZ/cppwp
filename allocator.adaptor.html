<!DOCTYPE html><html lang='en'><head><title>[allocator.adaptor]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><div id='allocator.adaptor'><h2 ><a class='secnum' style='min-width:88pt'>20.13</a> Class template <span class='texttt'>scoped_allocator_adaptor</span> <a class='abbr_ref'>[allocator.adaptor]</a></h2><div id='syn'><h3 ><a class='secnum' href='#syn' style='min-width:103pt'>20.13.1</a> Header <span class='texttt'>&lt;scoped_allocator&gt;</span> synopsis <a class='abbr_ref' href='allocator.adaptor.syn'>[allocator.adaptor.syn]</a></h3><p ><span class='indexparent'><a class='index' id='scoped_allocator'></a></span></p><pre class='codeblock'>
  <span class='comment'>// scoped allocator adaptor
</span>  template &lt;class OuterAlloc, class... InnerAlloc&gt;
    class scoped_allocator_adaptor;
  template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
    bool operator==(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                    const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;
  template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
    bool operator!=(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                    const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;
</pre><div class='para' id='syn-1'><div class='marginalizedparent'><a class='marginalized' href='#syn-1'>1</a></div><p >The class template <span class='texttt'>scoped_allocator_adaptor</span> is an allocator template that
specifies the memory resource (the outer allocator) to be used by a container (as any
other allocator does) and also specifies an inner allocator resource to be passed to the
constructor of every element within the container. This adaptor is instantiated with one
outer and zero or more inner allocator types. If instantiated with only one allocator
type, the inner allocator becomes the <span class='texttt'>scoped_allocator_adaptor</span> itself, thus
using the same allocator resource for the container and every element within the
container and, if the elements themselves are containers, each of their elements
recursively. If instantiated with more than one allocator, the first allocator is the
outer allocator for use by the container, the second allocator is passed to the
constructors of the container's elements, and, if the elements themselves are
containers, the third allocator is passed to the elements' elements, and so on. If
containers are nested to a depth greater than the number of allocators, the last
allocator is used repeatedly, as in the single-allocator case, for any remaining
recursions. [&nbsp;<i>Note:</i><span class='space'></span> The <span class='texttt'>scoped_allocator_adaptor</span> is derived from the outer
allocator type so it can be substituted for the outer allocator type in most
expressions. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class OuterAlloc, class... InnerAllocs&gt;
    class scoped_allocator_adaptor : public OuterAlloc {
  private:
    using OuterTraits = allocator_traits&lt;OuterAlloc&gt;; <span class='comment'>// <i>exposition only</i>
</span>    scoped_allocator_adaptor&lt;InnerAllocs...&gt; inner;   <span class='comment'>// <i>exposition only</i>
</span>  public:
    using outer_allocator_type = OuterAlloc;
    using inner_allocator_type = <i><span class='texttt'>see below</span></i>;

    using value_type           = typename OuterTraits::value_type;
    using size_type            = typename OuterTraits::size_type;
    using difference_type      = typename OuterTraits::difference_type;
    using pointer              = typename OuterTraits::pointer;
    using const_pointer        = typename OuterTraits::const_pointer;
    using void_pointer         = typename OuterTraits::void_pointer;
    using const_void_pointer   = typename OuterTraits::const_void_pointer;

    using propagate_on_container_copy_assignment = <i><span class='texttt'>see below</span></i>;
    using propagate_on_container_move_assignment = <i><span class='texttt'>see below</span></i>;
    using propagate_on_container_swap            = <i><span class='texttt'>see below</span></i>;
    using is_always_equal                        = <i><span class='texttt'>see below</span></i>;

    template &lt;class Tp&gt;
      struct rebind {
        using other = scoped_allocator_adaptor&lt;
          OuterTraits::template rebind_alloc&lt;Tp&gt;, InnerAllocs...&gt;;
      };

    scoped_allocator_adaptor();
    template &lt;class OuterA2&gt;
      scoped_allocator_adaptor(OuterA2&amp;&amp; outerAlloc,
                               const InnerAllocs&amp;... innerAllocs) noexcept;

    scoped_allocator_adaptor(const scoped_allocator_adaptor&amp; other) noexcept;
    scoped_allocator_adaptor(scoped_allocator_adaptor&amp;&amp; other) noexcept;

    template &lt;class OuterA2&gt;
      scoped_allocator_adaptor(
        const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; other) noexcept;
    template &lt;class OuterA2&gt;
      scoped_allocator_adaptor(
        scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp;&amp; other) noexcept;

    scoped_allocator_adaptor&amp; operator=(const scoped_allocator_adaptor&amp;) = default;
    scoped_allocator_adaptor&amp; operator=(scoped_allocator_adaptor&amp;&amp;) = default;

    ~scoped_allocator_adaptor();

    inner_allocator_type&amp; inner_allocator() noexcept;
    const inner_allocator_type&amp; inner_allocator() const noexcept;
    outer_allocator_type&amp; outer_allocator() noexcept;
    const outer_allocator_type&amp; outer_allocator() const noexcept;

    pointer allocate(size_type n);
    pointer allocate(size_type n, const_void_pointer hint);
    void deallocate(pointer p, size_type n);
    size_type max_size() const;

    template &lt;class T, class... Args&gt;
      void construct(T* p, Args&amp;&amp;... args);
    template &lt;class T1, class T2, class... Args1, class... Args2&gt;
      void construct(pair&lt;T1, T2&gt;* p, piecewise_construct_t,
                     tuple&lt;Args1...&gt; x, tuple&lt;Args2...&gt; y);
    template &lt;class T1, class T2&gt;
      void construct(pair&lt;T1, T2&gt;* p);
    template &lt;class T1, class T2, class U, class V&gt;
      void construct(pair&lt;T1, T2&gt;* p, U&amp;&amp; x, V&amp;&amp; y);
    template &lt;class T1, class T2, class U, class V&gt;
      void construct(pair&lt;T1, T2&gt;* p, const pair&lt;U, V&gt;&amp; x);
    template &lt;class T1, class T2, class U, class V&gt;
      void construct(pair&lt;T1, T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; x);

    template &lt;class T&gt;
      void destroy(T* p);

    scoped_allocator_adaptor select_on_container_copy_construction() const;
  };

  template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
    bool operator==(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                    const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;
  template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
    bool operator!=(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                    const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;
}
</pre></div></div><div id='types'><h3 ><a class='secnum' href='#types' style='min-width:103pt'>20.13.2</a> Scoped allocator adaptor member types <a class='abbr_ref' href='allocator.adaptor.types'>[allocator.adaptor.types]</a></h3><p ><span class='indexparent'><a class='index' id='inner_allocator_type!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!inner_allocator_type'></a></span><code class='itemdecl'>
using inner_allocator_type = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='types-1'><div class='marginalizedparent'><a class='marginalized' href='#types-1'>1</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>scoped_allocator_adaptor&lt;OuterAlloc&gt;</span> if <span class='texttt'>sizeof...(InnerAllocs)</span> is
zero; otherwise,<br/> <span class='texttt'>scoped_allocator_adaptor&lt;InnerAllocs...&gt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='propagate_on_container_copy_assignment!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!propagate_on_container_copy_assignment'></a></span><code class='itemdecl'>
using propagate_on_container_copy_assignment = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='types-2'><div class='marginalizedparent'><a class='marginalized' href='#types-2'>2</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>true_type</span> if
<span class='texttt'>allocator_traits&lt;A&gt;::propagate_on_container_copy_assignment::value</span> is
<span class='texttt'>true</span> for any <span class='texttt'>A</span> in the set of <span class='texttt'>OuterAlloc</span> and
<span class='texttt'>InnerAllocs...</span>; otherwise, <span class='texttt'>false_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='propagate_on_container_move_assignment!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!propagate_on_container_move_assignment'></a></span><code class='itemdecl'>
using propagate_on_container_move_assignment = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='types-3'><div class='marginalizedparent'><a class='marginalized' href='#types-3'>3</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>true_type</span> if
<span class='texttt'>allocator_traits&lt;A&gt;::propagate_on_container_move_assignment::value</span> is
<span class='texttt'>true</span> for any <span class='texttt'>A</span> in the set of <span class='texttt'>OuterAlloc</span> and
<span class='texttt'>InnerAllocs...</span>; otherwise, <span class='texttt'>false_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='propagate_on_container_swap!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!propagate_on_container_swap'></a></span><code class='itemdecl'>
using propagate_on_container_swap = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='types-4'><div class='marginalizedparent'><a class='marginalized' href='#types-4'>4</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>true_type</span> if
<span class='texttt'>allocator_traits&lt;A&gt;::propagate_on_container_swap::value</span> is
<span class='texttt'>true</span> for any <span class='texttt'>A</span> in the set of <span class='texttt'>OuterAlloc</span> and
<span class='texttt'>InnerAllocs...</span>; otherwise, <span class='texttt'>false_type</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_always_equal!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!is_always_equal'></a></span><code class='itemdecl'>
using is_always_equal = <i><span class='texttt'>see below</span></i>;
</code></p><div class='itemdescr'></div><div class='para' id='types-5'><div class='marginalizedparent'><a class='marginalized' href='#types-5'>5</a></div><div class='itemdescr'><p ><i>Type:</i> <span class='texttt'>true_type</span> if
<span class='texttt'>allocator_traits&lt;A&gt;::is_always_equal::value</span> is
<span class='texttt'>true</span> for every <span class='texttt'>A</span> in the set of <span class='texttt'>OuterAlloc</span> and
<span class='texttt'>InnerAllocs...</span>; otherwise, <span class='texttt'>false_type</span>.
</p></div></div></div><div id='cnstr'><h3 ><a class='secnum' href='#cnstr' style='min-width:103pt'>20.13.3</a> Scoped allocator adaptor constructors <a class='abbr_ref' href='allocator.adaptor.cnstr'>[allocator.adaptor.cnstr]</a></h3><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!constructor'></a></span><code class='itemdecl'>
scoped_allocator_adaptor();
</code></p><div class='itemdescr'></div><div class='para' id='cnstr-1'><div class='marginalizedparent'><a class='marginalized' href='#cnstr-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Value-initializes the <span class='texttt'>OuterAlloc</span> base class and the <span class='texttt'>inner</span> allocator
object.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!constructor'></a></span><code class='itemdecl'>
template &lt;class OuterA2&gt;
  scoped_allocator_adaptor(OuterA2&amp;&amp; outerAlloc,
                           const InnerAllocs&amp;... innerAllocs) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cnstr-2'><div class='marginalizedparent'><a class='marginalized' href='#cnstr-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OuterAlloc</span> shall be constructible from <span class='texttt'>OuterA2</span>.</p></div></div><div class='para' id='cnstr-3'><div class='marginalizedparent'><a class='marginalized' href='#cnstr-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes the <span class='texttt'>OuterAlloc</span> base class with
<span class='texttt'>std::forward&lt;OuterA2&gt;(outerAlloc)</span> and <span class='texttt'>inner</span> with <span class='texttt'>innerAllocs...</span>
(hence recursively initializing each allocator within the adaptor with the corresponding
allocator from the argument list).
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!constructor'></a></span><code class='itemdecl'>
scoped_allocator_adaptor(const scoped_allocator_adaptor&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cnstr-4'><div class='marginalizedparent'><a class='marginalized' href='#cnstr-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes each allocator within the adaptor with the corresponding allocator
from <span class='texttt'>other</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!constructor'></a></span><code class='itemdecl'>
scoped_allocator_adaptor(scoped_allocator_adaptor&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cnstr-5'><div class='marginalizedparent'><a class='marginalized' href='#cnstr-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs each allocator within the adaptor with the corresponding allocator
from <span class='texttt'>other</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!constructor'></a></span><code class='itemdecl'>
template &lt;class OuterA2&gt;
  scoped_allocator_adaptor(const scoped_allocator_adaptor&lt;OuterA2,
                                                          InnerAllocs...&gt;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cnstr-6'><div class='marginalizedparent'><a class='marginalized' href='#cnstr-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OuterAlloc</span> shall be constructible from <span class='texttt'>OuterA2</span>.</p></div></div><div class='para' id='cnstr-7'><div class='marginalizedparent'><a class='marginalized' href='#cnstr-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes each allocator within the adaptor with the corresponding allocator
from <span class='texttt'>other</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!constructor'></a></span><code class='itemdecl'>
template &lt;class OuterA2&gt;
  scoped_allocator_adaptor(scoped_allocator_adaptor&lt;OuterA2,
                                                    InnerAllocs...&gt;&amp;&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='cnstr-8'><div class='marginalizedparent'><a class='marginalized' href='#cnstr-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>OuterAlloc</span> shall be constructible from <span class='texttt'>OuterA2</span>.</p></div></div><div class='para' id='cnstr-9'><div class='marginalizedparent'><a class='marginalized' href='#cnstr-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i> Initializes each allocator within the adaptor with the corresponding allocator rvalue
from <span class='texttt'>other</span>.
</p></div></div></div><div id='members'><h3 ><a class='secnum' href='#members' style='min-width:103pt'>20.13.4</a> Scoped allocator adaptor members <a class='abbr_ref' href='allocator.adaptor.members'>[allocator.adaptor.members]</a></h3><div class='para' id='members-1'><div class='marginalizedparent'><a class='marginalized' href='#members-1'>1</a></div><p >In the <span class='texttt'>construct</span> member functions,
<i>OUTERMOST(x)</i> is <span class='texttt'>x</span> if <span class='texttt'>x</span> does not have an
<span class='texttt'>outer_allocator()</span> member function and <br/>
<i>OUTERMOST(x.outer_allocator())</i>
otherwise;
<i>OUTERMOST_ALLOC_TRAITS(x)</i> is <br/>
<span class='texttt'>allocator_traits&lt;decltype(<i>OUTERMOST</i>(x))&gt;</span>.
[&nbsp;<i>Note:</i><span class='space'></span> <i>OUTERMOST</i>(x) and <br/>
<i>OUTERMOST_ALLOC_TRAITS</i>(x) are recursive operations. It
is incumbent upon the definition of <span class='texttt'>outer_allocator()</span> to ensure that the
recursion terminates. It will terminate for all instantiations of <br/>
<span class='texttt'>scoped_allocator_adaptor</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='inner_allocator!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!inner_allocator'></a></span><code class='itemdecl'>
inner_allocator_type&amp; inner_allocator() noexcept;
const inner_allocator_type&amp; inner_allocator() const noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='members-2'><div class='marginalizedparent'><a class='marginalized' href='#members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span> if <span class='texttt'>sizeof...(InnerAllocs)</span> is zero; otherwise,
<span class='texttt'>inner</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='outer_allocator!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!outer_allocator'></a></span><code class='itemdecl'>
outer_allocator_type&amp; outer_allocator() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='members-3'><div class='marginalizedparent'><a class='marginalized' href='#members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>static_cast&lt;OuterAlloc&amp;&gt;(*this)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='outer_allocator!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!outer_allocator'></a></span><code class='itemdecl'>
const outer_allocator_type&amp; outer_allocator() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='members-4'><div class='marginalizedparent'><a class='marginalized' href='#members-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>static_cast&lt;const OuterAlloc&amp;&gt;(*this)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocate!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!allocate'></a></span><code class='itemdecl'>
pointer allocate(size_type n);
</code></p><div class='itemdescr'></div><div class='para' id='members-5'><div class='marginalizedparent'><a class='marginalized' href='#members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>allocator_traits&lt;OuterAlloc&gt;::allocate(outer_allocator(), n)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='allocate!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!allocate'></a></span><code class='itemdecl'>
pointer allocate(size_type n, const_void_pointer hint);
</code></p><div class='itemdescr'></div><div class='para' id='members-6'><div class='marginalizedparent'><a class='marginalized' href='#members-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>allocator_traits&lt;OuterAlloc&gt;::allocate(outer_allocator(), n, hint)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='deallocate!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!deallocate'></a></span><code class='itemdecl'>
void deallocate(pointer p, size_type n) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='members-7'><div class='marginalizedparent'><a class='marginalized' href='#members-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by:
<span class='texttt'>allocator_traits&lt;OuterAlloc&gt;::deallocate(outer_allocator(), p, n);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='max_size!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!max_size'></a></span><code class='itemdecl'>
size_type max_size() const;
</code></p><div class='itemdescr'></div><div class='para' id='members-8'><div class='marginalizedparent'><a class='marginalized' href='#members-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>allocator_traits&lt;OuterAlloc&gt;::max_size(outer_allocator())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='construct!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!construct'></a></span><code class='itemdecl'>
template &lt;class T, class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='members-9'><div class='marginalizedparent'><a class='marginalized' href='#members-9'>9</a></div><div class='itemdescr'><p ><i>Effects:</i></p><ul ><li ><p >If <span class='texttt'>uses_allocator_v&lt;T, inner_allocator_type&gt;</span> is <span class='texttt'>false</span> and
<span class='texttt'>is_constructible_v&lt;T, Args...&gt;</span> is <span class='texttt'>true</span>, calls
<i>OUTERMOST_ALLOC_TRAITS</i>(<span class='texttt'>*this</span>)<span class='texttt'>::construct(<br/>
<i>OUTERMOST</i>(*this), p, std::forward&lt;Args&gt;(args)...)</span>.</p></li><li ><p >Otherwise, if <span class='texttt'>uses_allocator_v&lt;T, inner_allocator_type&gt;</span> is <span class='texttt'>true</span> and
<span class='texttt'>is_constructible_v&lt;T, allocator_arg_t, inner_allocator_type&amp;, Args...&gt;</span> is <span class='texttt'>true</span>, calls
<i>OUTERMOST_ALLOC_TRAITS</i>(<span class='texttt'>*this</span>)<span class='texttt'>::construct(<i>OUTERMOST</i>(*this),
p, allocator_arg,<br/>inner_allocator(), std::forward&lt;Args&gt;(args)...)</span>.</p></li><li ><p >Otherwise, if <span class='texttt'>uses_allocator_v&lt;T, inner_allocator_type&gt;</span> is <span class='texttt'>true</span> and
<span class='texttt'>is_constructible_v&lt;T, Args..., inner_allocator_type&amp;&gt;</span> is <span class='texttt'>true</span>, calls
<i>OUTERMOST_ALLOC_TRAITS</i>(*this)::
<span class='texttt'>construct(<i>OUTERMOST</i>(*this), p, std::forward&lt;Args&gt;(args)...,<br/>inner_allocator())</span>.</p></li><li ><p >Otherwise, the program is ill-formed. [&nbsp;<i>Note:</i><span class='space'></span> An error will result if
<span class='texttt'>uses_allocator</span> evaluates to true but the specific constructor does not take an
allocator. This definition prevents a silent failure to pass an inner allocator to a
contained element. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='construct!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!construct'></a></span><code class='itemdecl'>
template &lt;class T1, class T2, class... Args1, class... Args2&gt;
  void construct(pair&lt;T1, T2&gt;* p, piecewise_construct_t,
                 tuple&lt;Args1...&gt; x, tuple&lt;Args2...&gt; y);
</code></p><div class='itemdescr'></div><div class='para' id='members-10'><div class='marginalizedparent'><a class='marginalized' href='#members-10'>10</a></div><div class='itemdescr'><p ><i>Requires:</i> all of the types in <span class='texttt'>Args1</span> and <span class='texttt'>Args2</span> shall be
<span class='texttt'>CopyConstructible</span> (Table <a href='utility.arg.requirements#tab:copyconstructible'>[tab:copyconstructible]</a>).</p></div></div><div class='para' id='members-11'><div class='marginalizedparent'><a class='marginalized' href='#members-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>tuple</span> object <span class='texttt'>xprime</span> from <span class='texttt'>x</span> by the
following rules:</p><ul ><li ><p >If <span class='texttt'>uses_allocator_v&lt;T1, inner_allocator_type&gt;</span> is <span class='texttt'>false</span> and
<span class='texttt'>is_constructible_v&lt;T1, Args1...&gt;</span> is <span class='texttt'>true</span>,
then <span class='texttt'>xprime</span> is <span class='texttt'>x</span>.</p></li><li ><p >Otherwise, if <span class='texttt'>uses_allocator_v&lt;T1, inner_allocator_type&gt;</span> is <span class='texttt'>true</span>
and
<span class='texttt'>is_constructible_v&lt;T1, allocator_arg_t, inner_allocator_type&amp;, Args1...&gt;</span>
is
<span class='texttt'>true</span>, then <span class='texttt'>xprime</span> is
<span class='texttt'>tuple_cat(tuple&lt;allocator_arg_t, inner_allocator_type&amp;&gt;(
allocator_arg, inner_allocator()), std::move(x))</span>.</p></li><li ><p >Otherwise, if <span class='texttt'>uses_allocator_v&lt;T1, inner_allocator_type&gt;</span> is
<span class='texttt'>true</span> and
<span class='texttt'>is_constructible_v&lt;T1, Args1..., inner_allocator_type&amp;&gt;</span> is <span class='texttt'>true</span>,
then <span class='texttt'>xprime</span> is
<span class='texttt'>tuple_cat(std::move(x), tuple&lt;inner_allocator_type&amp;&gt;(inner_allocator()))</span>.</p></li><li ><p >Otherwise, the program is ill-formed.
</p></li></ul><p >and constructs a <span class='texttt'>tuple</span> object <span class='texttt'>yprime</span> from <span class='texttt'>y</span> by the following rules:</p><ul ><li ><p >If <span class='texttt'>uses_allocator_v&lt;T2, inner_allocator_type&gt;</span> is <span class='texttt'>false</span> and
<span class='texttt'>is_constructible_v&lt;T2,
Args2...&gt;</span> is <span class='texttt'>true</span>, then <span class='texttt'>yprime</span> is <span class='texttt'>y</span>.</p></li><li ><p >Otherwise, if <span class='texttt'>uses_allocator_v&lt;T2, inner_allocator_type&gt;</span> is <span class='texttt'>true</span>
and
<span class='texttt'>is_constructible_v&lt;T2, allocator_arg_t, inner_allocator_type&amp;, Args2...&gt;</span>
is
<span class='texttt'>true</span>, then <span class='texttt'>yprime</span> is
<span class='texttt'>tuple_cat(tuple&lt;allocator_arg_t, inner_allocator_type&amp;&gt;(
allocator_arg, inner_allocator()), std::move(y))</span>.</p></li><li ><p >Otherwise, if <span class='texttt'>uses_allocator_v&lt;T2, inner_allocator_type&gt;</span> is
<span class='texttt'>true</span> and
<span class='texttt'>is_constructible_v&lt;T2, Args2..., inner_allocator_type&amp;&gt;</span> is <span class='texttt'>true</span>,
then <span class='texttt'>yprime</span> is
<span class='texttt'>tuple_cat(std::move(y), tuple&lt;inner_allocator_type&amp;&gt;(inner_allocator()))</span>.</p></li><li ><p >Otherwise, the program is ill-formed.
</p></li></ul><p >then calls <span class='texttt'><i>OUTERMOST_ALLOC_TRAITS</i>(*this)::construct(<i>OUTERMOST</i>(*this), p,<br/>
piecewise_construct, std::move(xprime), std::move(yprime))</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='construct!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!construct'></a></span><code class='itemdecl'>
template &lt;class T1, class T2&gt;
  void construct(pair&lt;T1, T2&gt;* p);
</code></p><div class='itemdescr'></div><div class='para' id='members-12'><div class='marginalizedparent'><a class='marginalized' href='#members-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
construct(p, piecewise_construct, tuple&lt;&gt;(), tuple&lt;&gt;());
</pre></div></div><p ><span class='indexparent'><a class='index' id='construct!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!construct'></a></span><code class='itemdecl'>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, U&amp;&amp; x, V&amp;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='members-13'><div class='marginalizedparent'><a class='marginalized' href='#members-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
construct(p, piecewise_construct,
          forward_as_tuple(std::forward&lt;U&gt;(x)),
          forward_as_tuple(std::forward&lt;V&gt;(y)));
</pre></div></div><p ><span class='indexparent'><a class='index' id='construct!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!construct'></a></span><code class='itemdecl'>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, const pair&lt;U, V&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='members-14'><div class='marginalizedparent'><a class='marginalized' href='#members-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
construct(p, piecewise_construct,
          forward_as_tuple(x.first),
          forward_as_tuple(x.second));
</pre></div></div><p ><span class='indexparent'><a class='index' id='construct!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!construct'></a></span><code class='itemdecl'>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='members-15'><div class='marginalizedparent'><a class='marginalized' href='#members-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
construct(p, piecewise_construct,
          forward_as_tuple(std::forward&lt;U&gt;(x.first)),
          forward_as_tuple(std::forward&lt;V&gt;(x.second)));
</pre></div></div><p ><span class='indexparent'><a class='index' id='destroy!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!destroy'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  void destroy(T* p);
</code></p><div class='itemdescr'></div><div class='para' id='members-16'><div class='marginalizedparent'><a class='marginalized' href='#members-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> Calls <span class='texttt'><i>OUTERMOST_ALLOC_TRAITS</i>(*this)::destroy(<i>OUTERMOST</i>(*this), p)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='select_on_container_copy_construction!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!select_on_container_copy_construction'></a></span><code class='itemdecl'>
scoped_allocator_adaptor select_on_container_copy_construction() const;
</code></p><div class='itemdescr'></div><div class='para' id='members-17'><div class='marginalizedparent'><a class='marginalized' href='#members-17'>17</a></div><div class='itemdescr'><p ><i>Returns:</i> A new <span class='texttt'>scoped_allocator_adaptor</span> object where each allocator <span class='texttt'>A</span> in the
adaptor is initialized from the result of calling
<span class='texttt'>allocator_traits&lt;A&gt;::select_on_container_copy_construction()</span> on the
corresponding allocator in <span class='texttt'>*this</span>.
</p></div></div></div><div id='scoped.adaptor.operators'><h3 ><a class='secnum' href='#scoped.adaptor.operators' style='min-width:103pt'>20.13.5</a> Scoped allocator operators <a class='abbr_ref' href='scoped.adaptor.operators'>[scoped.adaptor.operators]</a></h3><p ><span class='indexparent'><a class='index' id='operator==!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!operator=='></a></span><code class='itemdecl'>
template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
  bool operator==(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                  const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='scoped.adaptor.operators-1'><div class='marginalizedparent'><a class='marginalized' href='#scoped.adaptor.operators-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>a.outer_allocator() == b.outer_allocator()</span> if
<span class='texttt'>sizeof...(InnerAllocs)</span> is zero;
otherwise, <span class='texttt'>a.outer_allocator() == b.outer_allocator()</span>
<span class='texttt'>&amp;&amp;</span> <span class='texttt'>a.inner_allocator() == b.inner_allocator()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=!scoped_allocator_adaptor'></a></span><span class='indexparent'><a class='index' id='scoped_allocator_adaptor!operator!='></a></span><code class='itemdecl'>
template &lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
  bool operator!=(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                  const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='scoped.adaptor.operators-2'><div class='marginalizedparent'><a class='marginalized' href='#scoped.adaptor.operators-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!(a == b)</span>.
</p></div></div></div></div></div></body></html>