<!DOCTYPE html><html lang='en'><head><title>[dcl.type.simple]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Declarations <a class='abbr_ref' href='./#dcl.dcl'>[dcl.dcl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>7.1</a> Specifiers <a class='abbr_ref' href='dcl.spec#dcl.type.simple'>[dcl.spec]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>7.1.7</a> Type specifiers <a class='abbr_ref' href='dcl.type#simple'>[dcl.type]</a></h3><div id='dcl.type.simple'><h4 ><a class='secnum' style='min-width:118pt'>7.1.7.2</a> Simple type specifiers <a class='abbr_ref'>[dcl.type.simple]</a></h4><p ><span class='indexparent'><a class='index' id='type_specifier,simple'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/declarations.tex#L1231'>#</a></div><p >The simple type specifiers are</p><pre class='bnf'><a id='nt:simple-type-specifier'>simple-type-specifier:</a>
    <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>
    <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> <span class='terminal'>template</span> <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
    <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='temp.names#nt:template-name'>template-name</a></i>
    <span class='terminal'>char</span>
    <span class='terminal'>char16_t</span>
    <span class='terminal'>char32_t</span>
    <span class='terminal'>wchar_t</span>
    <span class='terminal'>bool</span>
    <span class='terminal'>short</span>
    <span class='terminal'>int</span>
    <span class='terminal'>long</span>
    <span class='terminal'>signed</span>
    <span class='terminal'>unsigned</span>
    <span class='terminal'>float</span>
    <span class='terminal'>double</span>
    <span class='terminal'>void</span>
    <span class='terminal'>auto</span>
    <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i></pre><pre class='bnf'><a id='nt:type-name'>type-name:</a>
    <i ><a href='class#nt:class-name'>class-name</a></i>
    <i ><a href='dcl.enum#nt:enum-name'>enum-name</a></i>
    <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>
    <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i></pre><pre class='bnf'><a id='nt:decltype-specifier'>decltype-specifier:</a>
  <span class='terminal'>decltype</span> <span class='terminal'>(</span> <i ><a href='expr.comma#nt:expression'>expression</a></i> <span class='terminal'>)</span>
  <span class='terminal'>decltype</span> <span class='terminal'>(</span> <span class='terminal'>auto</span> <span class='terminal'>)</span></pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/declarations.tex#L1270'>#</a></div><p ><span class='indexparent'><a class='index' id='type_specifier,char'></a></span><span class='indexparent'><a class='index' id='type_specifier,char16_t'></a></span><span class='indexparent'><a class='index' id='type_specifier,char32_t'></a></span><span class='indexparent'><a class='index' id='type_specifier,wchar_t'></a></span><span class='indexparent'><a class='index' id='type_specifier,bool'></a></span><span class='indexparent'><a class='index' id='type_specifier,short'></a></span><span class='indexparent'><a class='index' id='type_specifier,int'></a></span><span class='indexparent'><a class='index' id='type_specifier,long'></a></span><span class='indexparent'><a class='index' id='type_specifier,signed'></a></span><span class='indexparent'><a class='index' id='type_specifier,unsigned'></a></span><span class='indexparent'><a class='index' id='type_specifier,float'></a></span><span class='indexparent'><a class='index' id='type_specifier,double'></a></span><span class='indexparent'><a class='index' id='type_specifier,void'></a></span><span class='indexparent'><a class='index' id='type_specifier,auto'></a></span><span class='indexparent'><a class='index' id='type_specifier,decltype'></a></span><span class='indexparent'><a class='index' id='type-name'></a></span><span class='indexparent'><a class='index' id='lambda-introducer'></a></span>The <i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i> <span class='texttt'>auto</span> is a placeholder for a type to be
deduced (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>).
<span class='indexparent'><a class='index' id='deduction,class_template_arguments'></a></span>A <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> of the form
<span class='texttt'>typename</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='temp.names#nt:template-name'>template-name</a></i>
is a placeholder for a deduced class type
and shall appear only as a <i ><a href='dcl.spec#nt:decl-specifier'>decl-specifier</a></i>
in the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
of a <i ><a href='dcl.dcl#nt:simple-declaration'>simple-declaration</a></i> (<a href='dcl.type.class.deduct'>[dcl.type.class.deduct]</a>)
or as the <i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifier</a></i>
in an explicit type conversion (functional notation) (<a href='expr.type.conv'>[expr.type.conv]</a>).
The <i ><a href='temp.names#nt:template-name'>template-name</a></i> shall name a class template
that is not an injected-class-name.
The other
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifiers</a></i>
specify either a previously-declared type, a type determined from an
expression, or one of the
fundamental types (<a href='basic.fundamental'>[basic.fundamental]</a>).
Table <a href='#tab:simple.type.specifiers'>[tab:simple.type.specifiers]</a>
 summarizes the valid combinations of
<i ><a href='dcl.type.simple#nt:simple-type-specifier'>simple-type-specifiers</a></i>
and the types they specify.</p><div class='numberedTable' id='tab:simple.type.specifiers'>Table <a href='#tab:simple.type.specifiers'>11</a> — <span class='grammarterm'>simple-type-specifiers</span> and the types they specify<br><table ><tr class='rowsep'><td class='left'>


Specifier(s)                    </td><td class='left'>   Type                 </td></tr><tr class='capsep'><td class='left'> 
<span class='grammarterm'>type-name</span>         </td><td class='left'>   the type named          </td></tr><tr ><td class='left'>
<span class='grammarterm'>simple-template-id</span>    </td><td class='left'>   the type as defined in <a href='temp.names'>[temp.names]</a>   </td></tr><tr ><td class='left'>
<span class='grammarterm'>template-name</span>     </td><td class='left'> placeholder for a type to be deduced</td></tr><tr ><td class='left'>
char                            </td><td class='left'>   “char”                </td></tr><tr ><td class='left'>
unsigned char                   </td><td class='left'>   “unsigned char”       </td></tr><tr ><td class='left'>
signed char                     </td><td class='left'>   “signed char”         </td></tr><tr ><td class='left'>
char16_t                        </td><td class='left'>   “char16_t”            </td></tr><tr ><td class='left'>
char32_t                        </td><td class='left'>   “char32_t”            </td></tr><tr ><td class='left'>
bool                            </td><td class='left'>   “bool”                </td></tr><tr ><td class='left'>
unsigned                        </td><td class='left'>   “unsigned int”        </td></tr><tr ><td class='left'>
unsigned int                    </td><td class='left'>   “unsigned int”        </td></tr><tr ><td class='left'>
signed                          </td><td class='left'>   “int”                 </td></tr><tr ><td class='left'>
signed int                      </td><td class='left'>   “int”                 </td></tr><tr ><td class='left'>
int                             </td><td class='left'>   “int”                 </td></tr><tr ><td class='left'>
unsigned short int              </td><td class='left'>   “unsigned short int”  </td></tr><tr ><td class='left'>
unsigned short                  </td><td class='left'>   “unsigned short int”  </td></tr><tr ><td class='left'>
unsigned long int               </td><td class='left'>   “unsigned long int”   </td></tr><tr ><td class='left'>
unsigned long                   </td><td class='left'>   “unsigned long int”   </td></tr><tr ><td class='left'>
unsigned long long int          </td><td class='left'> “unsigned long long int”</td></tr><tr ><td class='left'>
unsigned long long              </td><td class='left'> “unsigned long long int”</td></tr><tr ><td class='left'>
signed long int                 </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
signed long                     </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
signed long long int            </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
signed long long                </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
long long int                   </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
long long                       </td><td class='left'>   “long long int”       </td></tr><tr ><td class='left'>
long int                        </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
long                            </td><td class='left'>   “long int”            </td></tr><tr ><td class='left'>
signed short int                </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
signed short                    </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
short int                       </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
short                           </td><td class='left'>   “short int”           </td></tr><tr ><td class='left'>
wchar_t                         </td><td class='left'>   “wchar_t”             </td></tr><tr ><td class='left'>
float                           </td><td class='left'>   “float”               </td></tr><tr ><td class='left'>
double                          </td><td class='left'>   “double”              </td></tr><tr ><td class='left'>
long double                     </td><td class='left'>   “long double”         </td></tr><tr ><td class='left'>
void                            </td><td class='left'>   “void”                </td></tr><tr ><td class='left'>
auto                            </td><td class='left'> placeholder for a type to be deduced</td></tr><tr ><td class='left'>
decltype(auto)                  </td><td class='left'> placeholder for a type to be deduced</td></tr><tr ><td class='left'>
decltype(<span class='grammarterm'>expression</span>) </td><td class='left'>   the type as defined below</td></tr></table></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/declarations.tex#L1359'>#</a></div><p >When multiple <span class='grammarterm'>simple-type-specifiers</span> are allowed, they can be
freely intermixed with other <span class='grammarterm'>decl-specifiers</span> in any order.
[ <i>Note:</i>
It is <span class='indexparent'><a class='index' id='signedness_of_char'></a></span>implementation-defined whether objects of <span class='texttt'>char</span> type are
represented as signed or unsigned quantities. The <span class='texttt'>signed</span> specifier
forces <span class='texttt'>char</span> objects to be signed; it is redundant in other contexts.
<i> — end note</i> ]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/declarations.tex#L1368'>#</a></div><p ><span class='indexparent'><a class='index' id='type_specifier,decltype'></a></span>For an expression <span class='texttt'>e</span>, the type denoted by <span class='texttt'>decltype(e)</span> is defined as follows:</p><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><p >if <span class='texttt'>e</span> is an unparenthesized <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> naming an lvalue or
reference introduced from the <i ><a href='cpp#nt:identifier-list'>identifier-list</a></i> of a decomposition declaration,
<span class='texttt'>decltype(e)</span> is the referenced type as given in the specification of the decomposition
declaration (<a href='dcl.decomp'>[dcl.decomp]</a>);</p></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><p >otherwise, if <span class='texttt'>e</span> is an unparenthesized <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> or
an unparenthesized
class
member access (<a href='expr.ref'>[expr.ref]</a>), <span class='texttt'>decltype(e)</span> is the
type of the entity named by <span class='texttt'>e</span>. If there is no such entity, or
if <span class='texttt'>e</span> names a set of overloaded functions, the program is
ill-formed;</p></li><li id='4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.3'>(4.3)</a></div><p >otherwise, if <span class='texttt'>e</span> is
an xvalue, <span class='texttt'>decltype(e)</span> is <span class='texttt'>T&amp;&amp;</span>, where <span class='texttt'>T</span> is the type
of <span class='texttt'>e</span>;</p></li><li id='4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.4'>(4.4)</a></div><p >otherwise, if <span class='texttt'>e</span> is an lvalue, <span class='texttt'>decltype(e)</span>
is <span class='texttt'>T&amp;</span>, where <span class='texttt'>T</span> is the type of <span class='texttt'>e</span>;</p></li><li id='4.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.5'>(4.5)</a></div><p >otherwise, <span class='texttt'>decltype(e)</span> is the type of <span class='texttt'>e</span>.
</p></li></ul><p >The operand of the <span class='texttt'>decltype</span> specifier is an unevaluated
operand (Clause <a href='expr'>[expr]</a>).</p><p >[ <i>Example:</i>
</p><pre class='codeblock'>
const int&amp;&amp; foo();
int i;
struct A { double x; };
const A* a = new A();
decltype(foo()) x1 = 17;        <span class='comment'>// type is <span class='texttt'>const int&amp;&amp;</span>
</span>decltype(i) x2;                 <span class='comment'>// type is <span class='texttt'>int</span>
</span>decltype(a-&gt;x) x3;              <span class='comment'>// type is <span class='texttt'>double</span>
</span>decltype((a-&gt;x)) x4 = x3;       <span class='comment'>// type is <span class='texttt'>const double&amp;</span>
</span></pre><p ><i> — end example</i> ]
[ <i>Note:</i>
The rules for determining types involving <span class='texttt'>decltype(auto)</span> are specified
in <a href='dcl.spec.auto'>[dcl.spec.auto]</a>.
<i> — end note</i> ]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/declarations.tex#L1416'>#</a></div><p >If the operand of a <i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> is a prvalue,
the temporary materialization conversion is not applied (<a href='conv.rval'>[conv.rval]</a>)
and no result object is provided for the prvalue.
The type of the prvalue may be incomplete.
[ <i>Note:</i>
As a result, storage is not allocated for the prvalue and it is not destroyed.
Thus, a class type is not instantiated
as a result of being the type of a function call in this context. 
In this context, the common purpose of
writing the expression is merely to refer to its type. In that sense, a
<i ><a href='dcl.type.simple#nt:decltype-specifier'>decltype-specifier</a></i> is analogous to a use of a <i ><a href='dcl.typedef#nt:typedef-name'>typedef-name</a></i>,
so the usual reasons for requiring a complete type do not apply. In particular,
it is not necessary to allocate storage for a temporary object or to enforce the
semantic constraints associated with invoking the type's destructor.
<i> — end note</i> ]
[ <i>Note:</i>
Unlike the preceding rule, parentheses have no special meaning in this context.
<i> — end note</i> ]
[ <i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; struct A { ~A() = delete; };
template&lt;class T&gt; auto h()
  -&gt; A&lt;T&gt;;
template&lt;class T&gt; auto i(T)     <span class='comment'>// identity
</span>  -&gt; T;
template&lt;class T&gt; auto f(T)     <span class='comment'>// #1
</span>  -&gt; decltype(i(h&lt;T&gt;()));       <span class='comment'>// forces completion of <span class='texttt'>A&lt;T&gt;</span> and implicitly uses <span class='texttt'>A&lt;T&gt;::~A()</span>
</span>                                <span class='comment'>// for the temporary introduced by the use of <span class='texttt'>h()</span>.
</span>                                <span class='comment'>// (A temporary is not introduced as a result of the use of <span class='texttt'>i()</span>.)
</span>template&lt;class T&gt; auto f(T)     <span class='comment'>// #2
</span>  -&gt; void;
auto g() -&gt; void {
  f(42);                        <span class='comment'>// OK: calls #2. (#1 is not a viable candidate: type deduction
</span>                                <span class='comment'>// fails (<a href='temp.deduct'>[temp.deduct]</a>) because <span class='texttt'>A&lt;int&gt;::~A()</span> is implicitly used in its
</span>                                <span class='comment'>// <span class='grammarterm'>decltype-specifier</span>)
</span>}
template&lt;class T&gt; auto q(T)
  -&gt; decltype((h&lt;T&gt;()));        <span class='comment'>// does not force completion of <span class='texttt'>A&lt;T&gt;</span>; <span class='texttt'>A&lt;T&gt;::~A()</span> is not implicitly
</span>                                <span class='comment'>// used within the context of this <span class='grammarterm'>decltype-specifier</span>
</span>void r() {
  q(42);                        <span class='comment'>// Error: deduction against <span class='texttt'>q</span> succeeds, so overload resolution selects
</span>                                <span class='comment'>// the specialization “<span class='texttt'>q(T) -&gt; decltype((h&lt;T&gt;())) [with T=int]</span>”.
</span>                                <span class='comment'>// The return type is <span class='texttt'>A&lt;int&gt;</span>, so a temporary is introduced and its
</span>                                <span class='comment'>// destructor is used, so the program is ill-formed.
</span>}</pre><p ><i> — end example</i> ]</p></div></div></div></body></html>