<!DOCTYPE html><html lang='en'><head><title>[temp.variadic]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.5</a> Template declarations <a class='abbr_ref' href='temp.decls#temp.variadic'>[temp.decls]</a></h2><div id='temp.variadic'><h3 ><a class='secnum' style='min-width:103pt'>14.5.3</a> Variadic templates <a class='abbr_ref'>[temp.variadic]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A <a class='hidden_link' href='#def:template_parameter_pack' id='def:template_parameter_pack'><i>template parameter pack</i></a> is a template parameter
that accepts zero or more template arguments. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class ... Types&gt; struct Tuple { };

Tuple&lt;&gt; t0;                     <span class='comment'>// <span class='texttt'>Types</span> contains no arguments
</span>Tuple&lt;int&gt; t1;                  <span class='comment'>// <span class='texttt'>Types</span> contains one argument: <span class='texttt'>int</span>
</span>Tuple&lt;int, float&gt; t2;           <span class='comment'>// <span class='texttt'>Types</span> contains two arguments: <span class='texttt'>int</span> and <span class='texttt'>float</span>
</span>Tuple&lt;0&gt; error;                 <span class='comment'>// error: 0 is not a type
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A <a class='hidden_link' href='#def:function_parameter_pack' id='def:function_parameter_pack'><i>function parameter pack</i></a> is a function parameter
that accepts zero or more function arguments. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class ... Types&gt; void f(Types ... args);

f();                <span class='comment'>// OK: <span class='texttt'>args</span> contains no arguments
</span>f(1);               <span class='comment'>// OK: <span class='texttt'>args</span> contains one argument: <span class='texttt'>int</span>
</span>f(2, 1.0);          <span class='comment'>// OK: <span class='texttt'>args</span> contains two arguments: <span class='texttt'>int</span> and <span class='texttt'>double</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A <a class='hidden_link' href='#def:parameter_pack' id='def:parameter_pack'><i>parameter pack</i></a> is either a template parameter
pack or a function parameter pack.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >A <a class='hidden_link' href='#def:pack_expansion' id='def:pack_expansion'><i>pack expansion</i></a>
consists of a <a class='hidden_link' href='#def:pattern' id='def:pattern'><i>pattern</i></a> and an ellipsis, the instantiation of which
produces zero or more instantiations of the pattern in a list (described below).
The form of the pattern
depends on the context in which the expansion occurs. Pack
expansions can occur in the following contexts:</p><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><p >In a function parameter pack (<a href='dcl.fct'>[dcl.fct]</a>); the pattern is the
<i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> without the ellipsis.</p></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><p >In a template parameter pack that is a pack expansion (<a href='temp.param'>[temp.param]</a>):</p><ul class='itemize'><li id='4.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#4.2.1'>(4.2.1)</a></div><p >if the template parameter pack is a <i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i>;
the pattern is the <i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> without the ellipsis;</p></li><li id='4.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#4.2.2'>(4.2.2)</a></div><p >if the template parameter pack is a <i ><a href='temp.param#nt:type-parameter'>type-parameter</a></i> with a
<i ><a href='temp#nt:template-parameter-list'>template-parameter-list</a></i>; the pattern is the corresponding
<i ><a href='temp.param#nt:type-parameter'>type-parameter</a></i> without the ellipsis.
</p></li></ul></li><li id='4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.3'>(4.3)</a></div><p >In an <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> (<a href='dcl.init'>[dcl.init]</a>);
the pattern is an <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>.</p></li><li id='4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.4'>(4.4)</a></div><p >In a <i ><a href='class.derived#nt:base-specifier-list'>base-specifier-list</a></i> (Clause <a href='class.derived'>[class.derived]</a>);
the pattern is a <i ><a href='class.derived#nt:base-specifier'>base-specifier</a></i>.</p></li><li id='4.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.5'>(4.5)</a></div><p >In a <i ><a href='class.base.init#nt:mem-initializer-list'>mem-initializer-list</a></i> (<a href='class.base.init'>[class.base.init]</a>) for a
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> whose <i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i> denotes a
base class; the pattern is the <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>.</p></li><li id='4.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.6'>(4.6)</a></div><p >In a <i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i> (<a href='temp.arg'>[temp.arg]</a>);
the pattern is a <i ><a href='temp.names#nt:template-argument'>template-argument</a></i>.</p></li><li id='4.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.7'>(4.7)</a></div><p >In a <i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specification</a></i> (<a href='except.spec'>[except.spec]</a>);
the pattern is a <i ><a href='dcl.name#nt:type-id'>type-id</a></i>.</p></li><li id='4.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.8'>(4.8)</a></div><p >In an <i ><a href='dcl.attr.grammar#nt:attribute-list'>attribute-list</a></i> (<a href='dcl.attr.grammar'>[dcl.attr.grammar]</a>); the pattern is
an <i ><a href='dcl.attr.grammar#nt:attribute'>attribute</a></i>.</p></li><li id='4.9'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.9'>(4.9)</a></div><p >In an <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i> (<a href='dcl.align'>[dcl.align]</a>); the pattern is
the <i ><a href='dcl.attr.grammar#nt:alignment-specifier'>alignment-specifier</a></i> without the ellipsis.</p></li><li id='4.10'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.10'>(4.10)</a></div><p >In a <i ><a href='expr.prim.lambda#nt:capture-list'>capture-list</a></i> (<a href='expr.prim.lambda'>[expr.prim.lambda]</a>); the pattern is
a <i ><a href='expr.prim.lambda#nt:capture'>capture</a></i>.</p></li><li id='4.11'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.11'>(4.11)</a></div><p >In a <span class='texttt'>sizeof...</span> expression (<a href='expr.sizeof'>[expr.sizeof]</a>); the pattern is an
<i ><a href='lex.name#nt:identifier'>identifier</a></i>.</p></li><li id='4.12'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.12'>(4.12)</a></div><p >In a <i ><a href='expr.prim.fold#nt:fold-expression'>fold-expression</a></i> (<a href='expr.prim.fold'>[expr.prim.fold]</a>);
the pattern is the <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
that contains an unexpanded parameter pack.
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;class ... Types&gt; void f(Types ... rest);
template&lt;class ... Types&gt; void g(Types ... rest) {
  f(&amp;rest ...);     <span class='comment'>// “<span class='texttt'>&amp;rest ...</span>” is a pack expansion; “<span class='texttt'>&amp;rest</span>” is its pattern
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >For the purpose of determining whether a parameter pack satisfies a rule
regarding entities other than parameter packs, the parameter pack is
considered to be the entity that would result from an instantiation of
the pattern in which it appears.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >A parameter pack whose name appears within the pattern of a pack
expansion is expanded by that pack expansion. An appearance of the name of
a parameter pack is only expanded by the innermost enclosing pack expansion.
The pattern of a pack expansion shall name one or more parameter packs that
are not expanded by a nested pack expansion; such parameter packs are called
<a class='hidden_link' href='#def:unexpanded' id='def:unexpanded'><i>unexpanded</i></a> parameter packs in the pattern. All of the parameter packs expanded
by a pack expansion shall have the same number of arguments specified. An
appearance of a name of a parameter pack that is not expanded is
ill-formed. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
template&lt;typename...&gt; struct Tuple {};
template&lt;typename T1, typename T2&gt; struct Pair {};

template&lt;class ... Args1&gt; struct zip {
  template&lt;class ... Args2&gt; struct with {
    typedef Tuple&lt;Pair&lt;Args1, Args2&gt; ... &gt; type;
  };
};

typedef zip&lt;short, int&gt;::with&lt;unsigned short, unsigned&gt;::type T1;
    <span class='comment'>// <span class='texttt'>T1</span> is <span class='texttt'>Tuple&lt;Pair&lt;short, unsigned short&gt;, Pair&lt;int, unsigned&gt;&gt;</span>
</span>typedef zip&lt;short&gt;::with&lt;unsigned short, unsigned&gt;::type T2;
    <span class='comment'>// error: different number of arguments specified for <span class='texttt'>Args1</span> and <span class='texttt'>Args2</span>
</span>
template&lt;class ... Args&gt;
  void g(Args ... args) {               <span class='comment'>// OK: <span class='texttt'>Args</span> is expanded by the function parameter pack <span class='texttt'>args</span>
</span>    f(const_cast&lt;const Args*&gt;(&amp;args)...); <span class='comment'>// OK: “<span class='texttt'>Args</span>” and “<span class='texttt'>args</span>” are expanded
</span>    f(5 ...);                             <span class='comment'>// error: pattern does not contain any parameter packs
</span>    f(args);                              <span class='comment'>// error: parameter pack “<span class='texttt'>args</span>” is not expanded
</span>    f(h(args ...) + args ...);            <span class='comment'>// OK: first “<span class='texttt'>args</span>” expanded within <span class='texttt'>h</span>, second
</span>                                          <span class='comment'>// “<span class='texttt'>args</span>” expanded within <span class='texttt'>f</span>
</span>  }
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >The instantiation of a pack expansion
that is neither a <span class='texttt'>sizeof...</span> expression
nor a <i ><a href='expr.prim.fold#nt:fold-expression'>fold-expression</a></i>
produces a
list
<span class='math'><span class='mathtt'>E</span><sub >1</sub>, <span class='mathtt'>E</span><sub >2</sub>, ..., <span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span></sub></span>,
where
<span class='math'><span class='mathalpha'>N</span></span> is the number of elements in the pack expansion parameters. Each
<span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>i</span></sub></span> is generated by instantiating the pattern and
replacing each pack expansion parameter with its <span class='math'><span class='mathalpha'>i</span></span>th element.
Such an element, in the context of the instantiation, is interpreted as
follows:</p><ul class='itemize'><li id='7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.1'>(7.1)</a></div><p >if the pack is a template parameter pack, the element is a template
parameter (<a href='temp.param'>[temp.param]</a>) of the corresponding kind (type or
non-type) designating the type or value from the template
argument; otherwise,</p></li><li id='7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#7.2'>(7.2)</a></div><p >if the pack is a function parameter pack, the element is an
<i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>
designating the function parameter that resulted from
the instantiation of the pattern where the pack is declared.
</p></li></ul><p >All of the <span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>i</span></sub></span> become elements in the enclosing list.
[&nbsp;<i>Note:</i><span class='space'></span> The variety of list varies with the context:
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>,
<i ><a href='class.derived#nt:base-specifier-list'>base-specifier-list</a></i>,
<i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i>, etc.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
When <span class='math'><span class='mathalpha'>N</span></span> is zero, the instantiation of the expansion produces an empty list.
Such an instantiation does not alter the syntactic interpretation of the
enclosing construct, even in cases where omitting the list entirely would
otherwise be ill-formed or would result in an ambiguity in the grammar.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;class... T&gt; struct X : T... { };
template&lt;class... T&gt; void f(T... values) {
  X&lt;T...&gt; x(values...);
}

template void f&lt;&gt;();  <span class='comment'>// OK: <span class='texttt'>X&lt;&gt;</span> has no base classes
</span>                      <span class='comment'>// <span class='texttt'>x</span> is a variable of type <span class='texttt'>X&lt;&gt;</span> that is value-initialized
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >The instantiation of a <span class='texttt'>sizeof...</span> expression (<a href='expr.sizeof'>[expr.sizeof]</a>) produces
an integral constant containing the number of elements in the parameter pack
it expands.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >The instantiation of a <i ><a href='expr.prim.fold#nt:fold-expression'>fold-expression</a></i> produces:</p><ul class='itemize'><li id='9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.1'>(9.1)</a></div><p ><span class='texttt'>((</span><span class='math'><span class='mathtt'>E</span><sub >1</sub></span>
           <i>op</i> <span class='math'><span class='mathtt'>E</span><sub >2</sub></span><span class='texttt'>)</span>
           <i>op</i> <span class='math'>⋯</span><span class='texttt'>)</span>
           <i>op</i> <span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span></sub></span>
for a unary left fold,
</p></li><li id='9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.2'>(9.2)</a></div><p ><span class='math'><span class='mathtt'>E</span><sub >1</sub></span>     <i>op</i>
<span class='texttt'>(</span><span class='math'>⋯</span>           <i>op</i>
<span class='texttt'>(</span><span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span>-1</sub></span> <i>op</i>
         <span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span></sub></span><span class='texttt'>))</span>
for a unary right fold,
</p></li><li id='9.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.3'>(9.3)</a></div><p ><span class='texttt'>(((</span><span class='math'><span class='mathtt'>E</span></span>
            <i>op</i> <span class='math'><span class='mathtt'>E</span><sub >1</sub></span><span class='texttt'>)</span>
            <i>op</i> <span class='math'><span class='mathtt'>E</span><sub >2</sub></span><span class='texttt'>)</span>
            <i>op</i> <span class='math'>⋯</span><span class='texttt'>)</span>
            <i>op</i> <span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span></sub></span>
for a binary left fold, and
</p></li><li id='9.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#9.4'>(9.4)</a></div><p ><span class='math'><span class='mathtt'>E</span><sub >1</sub></span>     <i>op</i>
<span class='texttt'>(</span><span class='math'>⋯</span>           <i>op</i>
<span class='texttt'>(</span><span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span>-1</sub></span> <i>op</i>
<span class='texttt'>(</span><span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>N</span></sub></span>   <i>op</i>
         <span class='math'><span class='mathtt'>E</span></span><span class='texttt'>)))</span>
for a binary right fold.
</p></li></ul><p >In each case,
<i>op</i> is the <i ><a href='expr.prim.fold#nt:fold-operator'>fold-operator</a></i>,
<span class='math'><span class='mathalpha'>N</span></span> is the number of elements in the pack expansion parameters,
and each <span class='math'><span class='mathtt'>E</span><sub ><span class='mathalpha'>i</span></sub></span> is generated by instantiating the pattern
and replacing each pack expansion parameter with its <span class='math'><span class='mathalpha'>i</span></span>th element.
For a binary fold-expression,
<span class='math'><span class='mathtt'>E</span></span> is generated
by instantiating the <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i>
that did not contain an unexpanded parameter pack.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
template&lt;typename ...Args&gt;
  bool all(Args ...args) { return (... &amp;&amp; args); }

bool b = all(true, true, true, false);
</pre><p >Within the instantiation of <span class='texttt'>all</span>,
the returned expression expands to
<span class='texttt'>((true &amp;&amp; true) &amp;&amp; true) &amp;&amp; false</span>,
which evaluates to <span class='texttt'>false</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
If <span class='math'><span class='mathalpha'>N</span></span> is zero for a unary fold-expression,
the value of the expression is shown in Table <a href='#tab:fold.empty'>[tab:fold.empty]</a>;
if the operator is not listed in Table <a href='#tab:fold.empty'>[tab:fold.empty]</a>,
the instantiation is ill-formed.</p><div class='numberedTable' id='tab:fold.empty'>Table <a href='#tab:fold.empty'>14</a> — Value of folding empty sequences<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Operator</b></td><td colspan='1' class='center'><b>Value when parameter pack is empty</b></td></tr><tr class='capsep'><td class='left'>

<span class='texttt'>&amp;&amp;</span>    </td><td class='left'> <span class='texttt'>true</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>||</span>      </td><td class='left'> <span class='texttt'>false</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>,</span>       </td><td class='left'> <span class='texttt'>void()</span> </td></tr></table></div></div></div></div></body></html>