<!DOCTYPE html><html lang='en'><head><title>[lex.pptoken]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>2</a> Lexical conventions <a class='abbr_ref' href='./#lex'>[lex]</a></h1><div id='lex.pptoken'><h2 ><a class='secnum' style='min-width:88pt'>2.4</a> Preprocessing tokens <a class='abbr_ref'>[lex.pptoken]</a></h2><p ><span class='indexparent'><a class='index' id='token,preprocessing'></a></span></p><pre class='bnf'><a id='nt:preprocessing-token'>preprocessing-token:</a>
    <i ><a href='lex.header#nt:header-name'>header-name</a></i>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i>
    <i ><a href='lex.ppnumber#nt:pp-number'>pp-number</a></i>
    <i ><a href='lex.ccon#nt:character-literal'>character-literal</a></i>
    <i ><a href='lex.ext#nt:user-defined-character-literal'>user-defined-character-literal</a></i>
    <i ><a href='lex.string#nt:string-literal'>string-literal</a></i>
    <i ><a href='lex.ext#nt:user-defined-string-literal'>user-defined-string-literal</a></i>
    <i ><a href='lex.operators#nt:preprocessing-op-or-punc'>preprocessing-op-or-punc</a></i>
    <span class='textnormal'>each non-white-space character that cannot be one of the above</span></pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Each preprocessing token that is converted to a token (<a href='lex.token'>[lex.token]</a>)
shall have the lexical form of a keyword, an identifier, a literal, an
operator, or a punctuator.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A preprocessing token is the minimal lexical element of the language in translation
phases 3 through 6. The categories of preprocessing token are: header names,
identifiers, preprocessing numbers, character literals (including user-defined character
literals), string literals (including user-defined string literals), preprocessing
operators and punctuators, and single non-white-space characters that do not lexically
match the other preprocessing token categories. If a <span class='texttt'>'</span> or a <span class='texttt'>"</span> character
matches the last category, the behavior is undefined. Preprocessing tokens can be
separated by
<span class='indexparent'><a class='index' id='space,white'></a></span>white space;
<span class='indexparent'><a class='index' id='comment'></a></span>this consists of comments (<a href='lex.comment'>[lex.comment]</a>), or white-space
characters (space, horizontal tab, new-line, vertical tab, and
form-feed), or both. As described in Clause <a href='cpp'>[cpp]</a>, in certain
circumstances during translation phase 4, white space (or the absence
thereof) serves as more than preprocessing token separation. White space
can appear within a preprocessing token only as part of a header name or
between the quotation characters in a character literal or string
literal.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >If the input stream has been parsed into preprocessing tokens up to a
given character:</p><ul ><li ><p ><span class='indexparent'><a class='index' id='literal,string,raw'></a></span></p><p >If the next character begins a sequence of characters that could be the prefix
and initial double quote of a raw string literal, such as <span class='texttt'>R"</span>, the next preprocessing
token shall be a raw string literal. Between the initial and final
double quote characters of the raw string, any transformations performed in phases
1 and 2 (<i ><a href='lex.charset#nt:universal-character-name'>universal-character-names</a></i> and line splicing) are reverted; this reversion
shall apply before any <i ><a href='lex.string#nt:d-char'>d-char</a></i>, <i ><a href='lex.string#nt:r-char'>r-char</a></i>, or delimiting
parenthesis is identified. The raw string literal is defined as the shortest sequence
of characters that matches the raw-string pattern</p><pre class='bnf'><i ><a href='lex.ccon#nt:encoding-prefix'>encoding-prefix</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>R</span> <i ><a href='lex.string#nt:raw-string'>raw-string</a></i></pre></li><li ><p >Otherwise, if the next three characters are <span class='texttt'>&lt;::</span> and the subsequent character
is neither <span class='texttt'>:</span> nor <span class='texttt'>&gt;</span>, the <span class='texttt'>&lt;</span> is treated as a preprocessing token by
itself and not as the first character of the alternative token <span class='texttt'>&lt;:</span>.</p></li><li ><p >Otherwise,
the next preprocessing token is the longest sequence of
characters that could constitute a preprocessing token, even if that
would cause further lexical analysis to fail,
except that a <i ><a href='lex.header#nt:header-name'>header-name</a></i> (<a href='lex.header'>[lex.header]</a>) is only formed
within a <span class='texttt'>#include</span> directive (<a href='cpp.include'>[cpp.include]</a>).
</p></li></ul><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
#define R "x"
const char* s = R"y";           <span class='comment'>// ill-formed raw string, not <span class='texttt'>"x" "y"</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span> The program fragment <span class='texttt'>0xe+foo</span> is parsed as a
preprocessing number token (one that is not a valid floating or integer
literal token), even though a parse as three preprocessing tokens
<span class='texttt'>0xe</span>, <span class='texttt'>+</span>, and <span class='texttt'>foo</span> might produce a valid expression (for example,
if <span class='texttt'>foo</span> were a macro defined as <span class='texttt'>1</span>). Similarly, the
program fragment <span class='texttt'>1E1</span> is parsed as a preprocessing number (one
that is a valid floating literal token), whether or not <span class='texttt'>E</span> is a
macro name. <i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span> The program fragment <span class='texttt'>x+++++y</span> is parsed as <span class='texttt'>x
++ ++ + y</span>, which, if <span class='texttt'>x</span> and <span class='texttt'>y</span> have integral types,
violates a constraint on increment operators, even though the parse
<span class='texttt'>x ++ + ++ y</span> might yield a correct expression. <i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='token,preprocessing'></a></span></p></div></div></div></body></html>