<!DOCTYPE html><html lang='en'><head><title>[meta.type.synop]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>20.10</a> Metaprogramming and type traits <a class='abbr_ref' href='meta#type.synop'>[meta]</a></h2><div id='meta.type.synop'><h3 ><a class='secnum' style='min-width:103pt'>20.10.2</a> Header <span class='texttt'>&lt;type_traits&gt;</span> synopsis <a class='abbr_ref'>[meta.type.synop]</a></h3><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='meta.help'>[meta.help]</a>, helper class:
</span>  template &lt;class T, T v&gt; struct integral_constant;
  typedef integral_constant&lt;bool, true&gt;  true_type;
  typedef integral_constant&lt;bool, false&gt; false_type;

  <span class='comment'>// <a href='meta.unary.cat'>[meta.unary.cat]</a>, primary type categories:
</span>  template &lt;class T&gt; struct is_void;
  template &lt;class T&gt; struct is_null_pointer;
  template &lt;class T&gt; struct is_integral;
  template &lt;class T&gt; struct is_floating_point;
  template &lt;class T&gt; struct is_array;
  template &lt;class T&gt; struct is_pointer;
  template &lt;class T&gt; struct is_lvalue_reference;
  template &lt;class T&gt; struct is_rvalue_reference;
  template &lt;class T&gt; struct is_member_object_pointer;
  template &lt;class T&gt; struct is_member_function_pointer;
  template &lt;class T&gt; struct is_enum;
  template &lt;class T&gt; struct is_union;
  template &lt;class T&gt; struct is_class;
  template &lt;class T&gt; struct is_function;

  <span class='comment'>// <a href='meta.unary.comp'>[meta.unary.comp]</a>, composite type categories:
</span>  template &lt;class T&gt; struct is_reference;
  template &lt;class T&gt; struct is_arithmetic;
  template &lt;class T&gt; struct is_fundamental;
  template &lt;class T&gt; struct is_object;
  template &lt;class T&gt; struct is_scalar;
  template &lt;class T&gt; struct is_compound;
  template &lt;class T&gt; struct is_member_pointer;

  <span class='comment'>// <a href='meta.unary.prop'>[meta.unary.prop]</a>, type properties:
</span>  template &lt;class T&gt; struct is_const;
  template &lt;class T&gt; struct is_volatile;
  template &lt;class T&gt; struct is_trivial;
  template &lt;class T&gt; struct is_trivially_copyable;
  template &lt;class T&gt; struct is_standard_layout;
  template &lt;class T&gt; struct is_pod;
  template &lt;class T&gt; struct is_literal_type;
  template &lt;class T&gt; struct is_empty;
  template &lt;class T&gt; struct is_polymorphic;
  template &lt;class T&gt; struct is_abstract;
  template &lt;class T&gt; struct is_final;

  template &lt;class T&gt; struct is_signed;
  template &lt;class T&gt; struct is_unsigned;

  template &lt;class T, class... Args&gt; struct is_constructible;
  template &lt;class T&gt; struct is_default_constructible;
  template &lt;class T&gt; struct is_copy_constructible;
  template &lt;class T&gt; struct is_move_constructible;

  template &lt;class T, class U&gt; struct is_assignable;
  template &lt;class T&gt; struct is_copy_assignable;
  template &lt;class T&gt; struct is_move_assignable;

  template &lt;class T&gt; struct is_destructible;

  template &lt;class T, class... Args&gt; struct is_trivially_constructible;
  template &lt;class T&gt; struct is_trivially_default_constructible;
  template &lt;class T&gt; struct is_trivially_copy_constructible;
  template &lt;class T&gt; struct is_trivially_move_constructible;

  template &lt;class T, class U&gt; struct is_trivially_assignable;
  template &lt;class T&gt; struct is_trivially_copy_assignable;
  template &lt;class T&gt; struct is_trivially_move_assignable;
  template &lt;class T&gt; struct is_trivially_destructible;

  template &lt;class T, class... Args&gt; struct is_nothrow_constructible;
  template &lt;class T&gt; struct is_nothrow_default_constructible;
  template &lt;class T&gt; struct is_nothrow_copy_constructible;
  template &lt;class T&gt; struct is_nothrow_move_constructible;

  template &lt;class T, class U&gt; struct is_nothrow_assignable;
  template &lt;class T&gt; struct  is_nothrow_copy_assignable;
  template &lt;class T&gt; struct is_nothrow_move_assignable;

  template &lt;class T&gt; struct is_nothrow_destructible;
  template &lt;class T&gt; struct has_virtual_destructor;

  <span class='comment'>// <a href='meta.unary.prop.query'>[meta.unary.prop.query]</a>, type property queries:
</span>  template &lt;class T&gt; struct alignment_of;
  template &lt;class T&gt; struct rank;
  template &lt;class T, unsigned I = 0&gt; struct extent;

  <span class='comment'>// <a href='meta.rel'>[meta.rel]</a>, type relations:
</span>  template &lt;class T, class U&gt; struct is_same;
  template &lt;class Base, class Derived&gt; struct is_base_of;
  template &lt;class From, class To&gt; struct is_convertible;

  <span class='comment'>// <a href='meta.trans.cv'>[meta.trans.cv]</a>, const-volatile modifications:
</span>  template &lt;class T&gt; struct remove_const;
  template &lt;class T&gt; struct remove_volatile;
  template &lt;class T&gt; struct remove_cv;
  template &lt;class T&gt; struct add_const;
  template &lt;class T&gt; struct add_volatile;
  template &lt;class T&gt; struct add_cv;

  template &lt;class T&gt;
    using remove_const_t    = typename remove_const&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_volatile_t = typename remove_volatile&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_cv_t       = typename remove_cv&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_const_t       = typename add_const&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_volatile_t    = typename add_volatile&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_cv_t          = typename add_cv&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.ref'>[meta.trans.ref]</a>, reference modifications:
</span>  template &lt;class T&gt; struct remove_reference;
  template &lt;class T&gt; struct add_lvalue_reference;
  template &lt;class T&gt; struct add_rvalue_reference;

  template &lt;class T&gt;
    using remove_reference_t     = typename remove_reference&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_lvalue_reference_t = typename add_lvalue_reference&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_rvalue_reference_t = typename add_rvalue_reference&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.sign'>[meta.trans.sign]</a>, sign modifications:
</span>  template &lt;class T&gt; struct make_signed;
  template &lt;class T&gt; struct make_unsigned;

  template &lt;class T&gt;
    using make_signed_t   = typename make_signed&lt;T&gt;::type;
  template &lt;class T&gt;
    using make_unsigned_t = typename make_unsigned&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.arr'>[meta.trans.arr]</a>, array modifications:
</span>  template &lt;class T&gt; struct remove_extent;
  template &lt;class T&gt; struct remove_all_extents;

  template &lt;class T&gt;
    using remove_extent_t      = typename remove_extent&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_all_extents_t = typename remove_all_extents&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.ptr'>[meta.trans.ptr]</a>, pointer modifications:
</span>  template &lt;class T&gt; struct remove_pointer;
  template &lt;class T&gt; struct add_pointer;

  template &lt;class T&gt;
    using remove_pointer_t = typename remove_pointer&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_pointer_t    = typename add_pointer&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.other'>[meta.trans.other]</a>, other transformations:
</span>  template &lt;std::size_t Len,
            std::size_t Align = default-alignment&gt;   <span class='comment'>// see <a href='meta.trans.other'>[meta.trans.other]</a>
</span>    struct aligned_storage;      
  template &lt;std::size_t Len, class... Types&gt; struct aligned_union;
  template &lt;class T&gt; struct decay;
  template &lt;bool, class T = void&gt; struct enable_if;
  template &lt;bool, class T, class F&gt; struct conditional;
  template &lt;class... T&gt; struct common_type;
  template &lt;class T&gt; struct underlying_type;
  template &lt;class&gt; class result_of;   <span class='comment'>// not defined
</span>  template &lt;class F, class... ArgTypes&gt; class result_of&lt;F(ArgTypes...)&gt;;

  template &lt;std::size_t Len,
            std::size_t Align = default-alignment &gt; <span class='comment'>// see <a href='meta.trans.other'>[meta.trans.other]</a>
</span>    using aligned_storage_t = typename aligned_storage&lt;Len,Align&gt;::type;
  template &lt;std::size_t Len, class... Types&gt;
    using aligned_union_t   = typename aligned_union&lt;Len,Types...&gt;::type;
  template &lt;class T&gt;
    using decay_t           = typename decay&lt;T&gt;::type;
  template &lt;bool b, class T = void&gt;
    using enable_if_t       = typename enable_if&lt;b,T&gt;::type;
  template &lt;bool b, class T, class F&gt;
    using conditional_t     = typename conditional&lt;b,T,F&gt;::type;
  template &lt;class... T&gt;
    using common_type_t     = typename common_type&lt;T...&gt;::type;
  template &lt;class T&gt;
    using underlying_type_t = typename underlying_type&lt;T&gt;::type;
  template &lt;class T&gt;
    using result_of_t       = typename result_of&lt;T&gt;::type;  
} <span class='comment'>// namespace std
</span></pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The behavior of a program that adds specializations for any of
the class templates defined in this subclause is undefined unless otherwise specified.</p></div></div></div></body></html>