<!DOCTYPE html><html lang='en'><head><title>[except.special]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>15</a> Exception handling <a class='abbr_ref' href='./#except'>[except]</a></h1><div id='except.special'><h2 ><a class='secnum' style='min-width:88pt'>15.5</a> Special functions <a class='abbr_ref'>[except.special]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The functions <span class='texttt'>std::terminate()</span> (<a href='except.terminate'>[except.terminate]</a>) and
<span class='texttt'>std::unexpected()</span> (<a href='except.unexpected'>[except.unexpected]</a>) are used by the exception
handling mechanism for coping with errors related to the exception handling
mechanism itself. The function
<span class='texttt'>std::current_exception()</span> (<a href='propagation'>[propagation]</a>) and the class
<span class='texttt'>std::nested_exception</span> (<a href='except.nested'>[except.nested]</a>) can be used by a program to
capture the currently handled exception.</p></div><div id='except.terminate'><h3 ><a class='secnum' href='#except.terminate' style='min-width:103pt'>15.5.1</a> The <span class='texttt'>std::terminate()</span> function <a class='abbr_ref' href='except.terminate'>[except.terminate]</a></h3><div class='para' id='except.terminate-1'><div class='marginalizedparent'><a class='marginalized' href='#except.terminate-1'>1</a></div><p ><span class='indexparent'><a class='index' id='terminate()'></a></span>In some situations exception handling must be abandoned
for less subtle error handling techniques. [&nbsp;<i>Note:</i> These situations are:</p><p ><span class='indexparent'><a class='index' id='terminate(),called'></a></span></p><ul class='itemize'><li id='except.terminate-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#except.terminate-1.1'>(1.1)</a></div><p >when the exception handling mechanism, after completing
the initialization of the exception object
but before
activation of a handler for the exception (<a href='except.throw'>[except.throw]</a>),
calls a function that exits
via an exception, or</p></li><li id='except.terminate-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#except.terminate-1.2'>(1.2)</a></div><p >when the exception handling mechanism cannot find a handler for a thrown exception (<a href='except.handle'>[except.handle]</a>), or</p></li><li id='except.terminate-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#except.terminate-1.3'>(1.3)</a></div><p >when the search for a handler (<a href='except.handle'>[except.handle]</a>) encounters the
outermost block of a function with a <i ><a href='except.spec#nt:noexcept-specification'>noexcept-specification</a></i>
that does not allow the exception (<a href='except.spec'>[except.spec]</a>), or</p></li><li id='except.terminate-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#except.terminate-1.4'>(1.4)</a></div><p >when the destruction of an object during stack unwinding (<a href='except.ctor'>[except.ctor]</a>)
terminates by throwing an exception, or</p></li><li id='except.terminate-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#except.terminate-1.5'>(1.5)</a></div><p >when initialization of a non-local
variable with static or thread storage duration (<a href='basic.start.init'>[basic.start.init]</a>)
exits via an exception, or</p></li><li id='except.terminate-1.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#except.terminate-1.6'>(1.6)</a></div><p >when destruction of an object with static or thread storage duration exits
via an exception (<a href='basic.start.term'>[basic.start.term]</a>), or</p></li><li id='except.terminate-1.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#except.terminate-1.7'>(1.7)</a></div><p >when execution of a function registered with
<span class='texttt'>std::atexit</span> or <span class='texttt'>std::at_quick_exit</span>
exits via an exception (<a href='support.start.term'>[support.start.term]</a>), or</p></li><li id='except.terminate-1.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#except.terminate-1.8'>(1.8)</a></div><p >when a
<i ><a href='except#nt:throw-expression'>throw-expression</a></i>
with no operand attempts to rethrow an exception and no exception is being
handled (<a href='except.throw'>[except.throw]</a>), or</p></li><li id='except.terminate-1.9'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#except.terminate-1.9'>(1.9)</a></div><p >when
<span class='texttt'>std::unexpected</span>
throws an exception which is not allowed by the previously violated
<i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specification</a></i>,
and
<span class='texttt'>std::bad_exception</span>
is not included in that
<span class='grammarterm'>dynamic-exception-specifica-tion</span> (<a href='except.unexpected'>[except.unexpected]</a>), or</p></li><li id='except.terminate-1.10'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#except.terminate-1.10'>(1.10)</a></div><p >when the implementation's default
unexpected exception handler
is called (<a href='unexpected.handler'>[unexpected.handler]</a>), or</p></li><li id='except.terminate-1.11'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#except.terminate-1.11'>(1.11)</a></div><p >when the function <span class='texttt'>std::nested_exception::rethrow_nested</span> is called for an object
that has captured no exception (<a href='except.nested'>[except.nested]</a>), or</p></li><li id='except.terminate-1.12'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#except.terminate-1.12'>(1.12)</a></div><p >when execution of the initial function of a thread exits via
an exception (<a href='thread.thread.constr'>[thread.thread.constr]</a>), or</p></li><li id='except.terminate-1.13'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#except.terminate-1.13'>(1.13)</a></div><p >when the destructor or the copy assignment operator is invoked on an object
of type <span class='texttt'>std::thread</span> that refers to a joinable thread
(<a href='thread.thread.destr'>[thread.thread.destr]</a>, <a href='thread.thread.assign'>[thread.thread.assign]</a>).</p></li></ul><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='except.terminate-2'><div class='marginalizedparent'><a class='marginalized' href='#except.terminate-2'>2</a></div><p ><span class='indexparent'><a class='index' id='terminate()'></a></span>In such cases,
<span class='texttt'>std::terminate()</span>
is called (<a href='exception.terminate'>[exception.terminate]</a>).
In the situation where no matching handler is found, it is
<span class='indexparent'><a class='index' id='stack_unwinding_before_call_to_std::terminate()'></a></span>implementation-defined whether or not the
stack is unwound
before
<span class='texttt'>std::terminate()</span>
is called.
In the situation where the search for a handler (<a href='except.handle'>[except.handle]</a>) encounters the
outermost block of a function with a <i ><a href='except.spec#nt:noexcept-specification'>noexcept-specification</a></i>
that does not allow the exception (<a href='except.spec'>[except.spec]</a>), it is
<span class='indexparent'><a class='index' id='whether_stack_is_unwound_before_calling_std::terminate()_when_a_noexcept_specification_is_violated'></a></span>implementation-defined
whether the stack is unwound, unwound partially, or not unwound at all
before <span class='texttt'>std::terminate()</span> is called.
In all other situations, the stack shall not be unwound before
<span class='texttt'>std::terminate()</span>
is called.
An implementation is not permitted to finish stack unwinding
prematurely based on a determination that the unwind process
will eventually cause a call to
<span class='texttt'>std::terminate()</span>.</p></div></div><div id='except.unexpected'><h3 ><a class='secnum' href='#except.unexpected' style='min-width:103pt'>15.5.2</a> The <span class='texttt'>std::unexpected()</span> function <a class='abbr_ref' href='except.unexpected'>[except.unexpected]</a></h3><div class='para' id='except.unexpected-1'><div class='marginalizedparent'><a class='marginalized' href='#except.unexpected-1'>1</a></div><p ><span class='indexparent'><a class='index' id='unexpected()'></a></span>If a function with
a <i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specification</a></i>
throws an exception that is not listed in the
<span class='grammarterm'> dynamic-exception-specification</span>,
the function
<span class='texttt'>std::unexpected()</span>
is called (<a href='exception.unexpected'>[exception.unexpected]</a>) immediately after completing
the stack unwinding for the former function.</p></div><div class='para' id='except.unexpected-2'><div class='marginalizedparent'><a class='marginalized' href='#except.unexpected-2'>2</a></div><p >[&nbsp;<i>Note:</i> By default, <span class='texttt'>std::unexpected()</span> calls <span class='texttt'>std::terminate()</span>, but a
program can install its own handler function (<a href='set.unexpected'>[set.unexpected]</a>). In either case, the
constraints in the following paragraph apply. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='except.unexpected-3'><div class='marginalizedparent'><a class='marginalized' href='#except.unexpected-3'>3</a></div><p >The
<span class='texttt'>std::unexpected()</span>
function shall not return, but it can throw (or re-throw) an exception.
If it throws a new exception which is allowed by the exception specification
which previously was violated, then the search for another handler
will continue at the call of the function whose exception specification was violated.
If it throws or rethrows an exception that the
<span class='grammarterm'> dynamic-exception-specification</span>
does not allow
then the following happens:
<span class='indexparent'><a class='index' id='bad_exception'></a></span>If the
<span class='grammarterm'> dynamic-exception-specification</span>
does not include the class
<span class='texttt'>std::bad_exception</span> (<a href='bad.exception'>[bad.exception]</a>)
then the function
<span class='texttt'>std::terminate()</span>
is called, otherwise the thrown exception is replaced by an
implementation-defined object of the type
<span class='texttt'>std::bad_exception</span>
and the search for another handler will continue at the call of the function
whose
<span class='grammarterm'> dynamic-exception-specification</span>
was violated.</p></div><div class='para' id='except.unexpected-4'><div class='marginalizedparent'><a class='marginalized' href='#except.unexpected-4'>4</a></div><p >Thus,
a <i ><a href='except.spec#nt:dynamic-exception-specification'>dynamic-exception-specification</a></i>
guarantees that only the listed exceptions will be thrown.
If the
<span class='grammarterm'> dynamic-exception-specification</span>
includes the type
<span class='texttt'>std::bad_exception</span>
then any exception not on the list may be replaced by
<span class='texttt'>std::bad_exception</span>
within the function
<span class='texttt'>std::unexpected()</span>.</p></div></div><div id='except.uncaught'><h3 ><a class='secnum' href='#except.uncaught' style='min-width:103pt'>15.5.3</a> The <span class='texttt'>std::uncaught_exception()</span> function <a class='abbr_ref' href='except.uncaught'>[except.uncaught]</a></h3><p ><span class='indexparent'><a class='index' id='uncaught_exception()'></a></span></p><div class='para' id='except.uncaught-1'><div class='marginalizedparent'><a class='marginalized' href='#except.uncaught-1'>1</a></div><p >The function
<span class='texttt'>std::uncaught_exception()</span>
returns
<span class='texttt'>true</span>
after completing
the initialization of the exception object (<a href='except.throw'>[except.throw]</a>)
until completing
the
activation of a handler for the exception (<a href='except.handle'>[except.handle]</a>, <a href='uncaught'>[uncaught]</a>).
This includes stack unwinding.
If the exception is rethrown (<a href='except.throw'>[except.throw]</a>),
<span class='texttt'>std::uncaught_exception()</span>
returns
<span class='texttt'>true</span>
from the point of rethrow until the rethrown exception is caught again.<span class='indexparent'><a class='index' id='exception_handling'></a></span>
</p></div></div></div></div></body></html>