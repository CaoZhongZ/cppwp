<!DOCTYPE html><html lang='en'><head><title>[basic.stc]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><div id='basic.stc'><h2 ><a class='secnum' style='min-width:88pt'>3.7</a> Storage duration <a class='abbr_ref'>[basic.stc]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='storage_duration'></a></span>Storage duration is the property of an object that defines the minimum
potential lifetime of the storage containing the object. The storage
duration is determined by the construct used to create the object and is
one of the following:</p><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p >static storage duration
</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p >thread storage duration
</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p >automatic storage duration
</p></li><li id='1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.4'>(1.4)</a></div><p >dynamic storage duration
</p></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='storage_duration,static'></a></span><span class='indexparent'><a class='index' id='storage_duration,thread'></a></span><span class='indexparent'><a class='index' id='storage_duration,automatic'></a></span><span class='indexparent'><a class='index' id='storage_duration,dynamic'></a></span>Static, thread, and automatic storage durations are associated with objects
introduced by declarations (<a href='basic.def'>[basic.def]</a>) and implicitly created by
the implementation (<a href='class.temporary'>[class.temporary]</a>). The dynamic storage duration
is associated with objects created with <span class='texttt'>operator</span>
<span class='texttt'>new</span> (<a href='expr.new'>[expr.new]</a>).</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The storage duration categories apply to references as well. The
lifetime of a reference is its storage duration.</p></div><div id='static'><h3 ><a class='secnum' href='#static' style='min-width:103pt'>3.7.1</a> Static storage duration <a class='abbr_ref' href='basic.stc.static'>[basic.stc.static]</a></h3><div class='para' id='static-1'><div class='marginalizedparent'><a class='marginalized' href='#static-1'>1</a></div><p ><span class='indexparent'><a class='index' id='storage_duration,static'></a></span>All variables which do not have dynamic storage duration, do not have thread
storage duration, and are not local
have <a class='hidden_link' href='#def:static_storage_duration' id='def:static_storage_duration'><i>static storage duration</i></a>. The
storage for these entities shall last for the duration of the
program (<a href='basic.start.init'>[basic.start.init]</a>, <a href='basic.start.term'>[basic.start.term]</a>).</p></div><div class='para' id='static-2'><div class='marginalizedparent'><a class='marginalized' href='#static-2'>2</a></div><p >If a variable with static storage duration has initialization or a
destructor with side effects, it shall not be eliminated even if it
appears to be unused, except that a class object or its copy/move may be
eliminated as specified in <a href='class.copy'>[class.copy]</a>.</p></div><div class='para' id='static-3'><div class='marginalizedparent'><a class='marginalized' href='#static-3'>3</a></div><p ><span class='indexparent'><a class='index' id='object,local_static'></a></span>The keyword <span class='texttt'>static</span> can be used to declare a local variable with
static storage duration. [&nbsp;<i>Note:</i> <a href='stmt.dcl'>[stmt.dcl]</a> describes the
initialization of local <span class='texttt'>static</span> variables; <a href='basic.start.term'>[basic.start.term]</a>
describes the destruction of local <span class='texttt'>static</span> variables. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='static-4'><div class='marginalizedparent'><a class='marginalized' href='#static-4'>4</a></div><p ><span class='indexparent'><a class='index' id='member,class_static'></a></span>The keyword <span class='texttt'>static</span> applied to a class data member in a class
definition gives the data member static storage duration.</p></div></div><div id='thread'><h3 ><a class='secnum' href='#thread' style='min-width:103pt'>3.7.2</a> Thread storage duration <a class='abbr_ref' href='basic.stc.thread'>[basic.stc.thread]</a></h3><div class='para' id='thread-1'><div class='marginalizedparent'><a class='marginalized' href='#thread-1'>1</a></div><p ><span class='indexparent'><a class='index' id='storage_duration,thread'></a></span>All variables declared with the <span class='texttt'>thread_local</span> keyword have <a class='hidden_link' href='#def:thread_storage_duration' id='def:thread_storage_duration'><i>thread
storage duration</i></a>. The storage for these entities shall last for the duration of
the thread in which they are created. There is a distinct object or reference
per thread, and use of the declared name refers to the entity associated with
the current thread.</p></div><div class='para' id='thread-2'><div class='marginalizedparent'><a class='marginalized' href='#thread-2'>2</a></div><p >A variable with thread storage duration shall be initialized before
its first odr-use (<a href='basic.def.odr'>[basic.def.odr]</a>) and, if constructed, shall be destroyed on thread exit.</p></div></div><div id='auto'><h3 ><a class='secnum' href='#auto' style='min-width:103pt'>3.7.3</a> Automatic storage duration <a class='abbr_ref' href='basic.stc.auto'>[basic.stc.auto]</a></h3><div class='para' id='auto-1'><div class='marginalizedparent'><a class='marginalized' href='#auto-1'>1</a></div><p ><span class='indexparent'><a class='index' id='storage_duration,automatic'></a></span><span class='indexparent'><a class='index' id='storage_duration,register'></a></span><span class='indexparent'><a class='index' id='storage_duration,local_object'></a></span>Block-scope variables explicitly declared <span class='texttt'>register</span> or
not explicitly declared <span class='texttt'>static</span> or <span class='texttt'>extern</span> have
<a class='hidden_link' href='#def:automatic_storage_duration' id='def:automatic_storage_duration'><i>automatic storage duration</i></a>. The storage
for these entities lasts until the block in which they are created exits.</p></div><div class='para' id='auto-2'><div class='marginalizedparent'><a class='marginalized' href='#auto-2'>2</a></div><p >[&nbsp;<i>Note:</i> 
These variables are initialized and destroyed as described in <a href='stmt.dcl'>[stmt.dcl]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='auto-3'><div class='marginalizedparent'><a class='marginalized' href='#auto-3'>3</a></div><p >If a variable with automatic storage duration has initialization or a destructor with side
effects, it shall not be destroyed before the end of its block, nor
shall it be eliminated as an optimization even if it appears to be
unused, except that a class object or its copy/move may be eliminated as
specified in <a href='class.copy'>[class.copy]</a>.</p></div></div><div id='dynamic'><h3 ><a class='secnum' href='#dynamic' style='min-width:103pt'>3.7.4</a> Dynamic storage duration <a class='abbr_ref' href='basic.stc.dynamic'>[basic.stc.dynamic]</a></h3><p ><span class='indexparent'><a class='index' id='storage_duration,dynamic'></a></span></p><div class='para' id='dynamic-1'><div class='marginalizedparent'><a class='marginalized' href='#dynamic-1'>1</a></div><p >Objects can be created dynamically during program
execution (<a href='intro.execution'>[intro.execution]</a>), using
<span class='indexparent'><a class='index' id='new'></a></span><i ><a href='expr.new#nt:new-expression'>new-expressions</a></i> (<a href='expr.new'>[expr.new]</a>), and destroyed using
<span class='indexparent'><a class='index' id='delete'></a></span><i ><a href='expr.delete#nt:delete-expression'>delete-expressions</a></i> (<a href='expr.delete'>[expr.delete]</a>). A C++ implementation
provides access to, and management of, dynamic storage via the global
<a class='hidden_link' href='#def:allocation_functions' id='def:allocation_functions'><i>allocation functions</i></a> <span class='texttt'>operator new</span> and <span class='texttt'>operator
new[]</span> and the global <a class='hidden_link' href='#def:deallocation_functions' id='def:deallocation_functions'><i>deallocation functions</i></a> <span class='texttt'>operator
delete</span> and <span class='texttt'>operator delete[]</span>.</p></div><div class='para' id='dynamic-2'><div class='marginalizedparent'><a class='marginalized' href='#dynamic-2'>2</a></div><p >The library provides default definitions for the global allocation and
deallocation functions. Some global allocation and deallocation
functions are replaceable (<a href='new.delete'>[new.delete]</a>). A C++ program shall
provide at most one definition of a replaceable allocation or
deallocation function. Any such function definition replaces the default
version provided in the library (<a href='replacement.functions'>[replacement.functions]</a>). The
following allocation and deallocation functions (<a href='support.dynamic'>[support.dynamic]</a>)
are implicitly declared in global scope in each translation unit of a
program.</p><pre class='codeblock'>
void* operator new(std::size_t);
void* operator new[](std::size_t);
void operator delete(void*) noexcept;
void operator delete[](void*) noexcept;
void operator delete(void*, std::size_t) noexcept;
void operator delete[](void*, std::size_t) noexcept;
</pre><p >These implicit declarations introduce only the function names
<span class='texttt'>operator</span> <span class='texttt'>new</span>, <span class='texttt'>operator</span> <span class='texttt'>new[]</span>,
<span class='texttt'>operator</span> <span class='texttt'>delete</span>, and <span class='texttt'>operator</span>
<span class='texttt'>delete[]</span>. [&nbsp;<i>Note:</i> The implicit declarations do not introduce
the names <span class='texttt'>std</span>,
<span class='texttt'>std::size_t</span>, or any other names that the library uses to
declare these names. Thus, a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>,
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> or function call that refers to one of
these functions without including the header <span class='texttt'>&lt;new&gt;</span> is
well-formed. However, referring to <span class='texttt'>std</span>
or <span class='texttt'>std::size_t</span> is ill-formed unless the name has been declared
by including the appropriate header. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Allocation and/or
deallocation functions can also be declared and defined for any
class (<a href='class.free'>[class.free]</a>).</p></div><div class='para' id='dynamic-3'><div class='marginalizedparent'><a class='marginalized' href='#dynamic-3'>3</a></div><p >Any allocation and/or deallocation functions defined in a C++ program,
including the default versions in the library, shall conform to the
semantics specified in <a href='basic.stc.dynamic.allocation'>[basic.stc.dynamic.allocation]</a>
and <a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>.</p></div><div id='dynamic.allocation'><h4 ><a class='secnum' href='#dynamic.allocation' style='min-width:118pt'>3.7.4.1</a> Allocation functions <a class='abbr_ref' href='basic.stc.dynamic.allocation'>[basic.stc.dynamic.allocation]</a></h4><div class='para' id='dynamic.allocation-1'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.allocation-1'>1</a></div><p ><span class='indexparent'><a class='index' id='function,allocation'></a></span>An allocation function shall be a class member function or a global
function; a program is ill-formed if an allocation function is declared
in a namespace scope other than global scope or declared static in
global scope. The return type shall be <span class='texttt'>void*</span>. The first
parameter shall have type <span class='texttt'>std::size_t</span> (<a href='support.types'>[support.types]</a>). The
first parameter shall not have an associated default
argument (<a href='dcl.fct.default'>[dcl.fct.default]</a>). The value of the first parameter shall
be interpreted as the requested size of the allocation. An allocation
function can be a function template. Such a template shall declare its
return type and first parameter as specified above (that is, template
parameter types shall not be used in the return type and first parameter
type). Template allocation functions shall have two or more parameters.</p></div><div class='para' id='dynamic.allocation-2'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.allocation-2'>2</a></div><p >The allocation function attempts to allocate the requested amount of
storage. If it is successful, it shall return the address of the start
of a block of storage whose length in bytes shall be at least as large
as the requested size. There are no constraints on the contents of the
allocated storage on return from the allocation function. The order,
contiguity, and initial value of storage allocated by successive calls
to an allocation function are unspecified. The pointer returned shall be
suitably aligned so that it can be converted to a pointer of any
complete object type with a fundamental alignment requirement (<a href='basic.align'>[basic.align]</a>)
and then used to access the object or array in the
storage allocated (until the storage is explicitly deallocated by a call
to a corresponding deallocation function). Even if the size of the space
requested is zero, the request can fail. If the request succeeds, the
value returned shall be a non-null pointer value (<a href='conv.ptr'>[conv.ptr]</a>)
<span class='texttt'>p0</span> different from any previously returned value <span class='texttt'>p1</span>,
unless that value <span class='texttt'>p1</span> was subsequently passed to an
<span class='texttt'>operator</span> <span class='texttt'>delete</span>. The effect of indirecting through a pointer
returned as a request for zero size is undefined.<a class='footnotenum' href='#footnote-36'>36</a></p></div><div class='para' id='dynamic.allocation-3'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.allocation-3'>3</a></div><p >An allocation function that fails to allocate storage can invoke the
currently installed new-handler function (<a href='new.handler'>[new.handler]</a>), if any.
[&nbsp;<i>Note:</i>
<span class='indexparent'><a class='index' id='new_handler'></a></span>A program-supplied allocation function can obtain the address of the
currently installed <span class='texttt'>new_handler</span> using the
<span class='texttt'>std::get_new_handler</span> function (<a href='set.new.handler'>[set.new.handler]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]
If an allocation function declared with a non-throwing
<i ><a href='except.spec#nt:exception-specification'>exception-specification</a></i> (<a href='except.spec'>[except.spec]</a>)
fails to allocate storage, it shall return a null pointer. Any other
allocation function that fails to allocate storage shall indicate
failure only by throwing an exception (<a href='except.throw'>[except.throw]</a>) of a type
that would match a handler (<a href='except.handle'>[except.handle]</a>) of type
<span class='texttt'>std::bad_alloc</span> (<a href='bad.alloc'>[bad.alloc]</a>).</p></div><div class='para' id='dynamic.allocation-4'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.allocation-4'>4</a></div><p >A global allocation function is only called as the result of a new
expression (<a href='expr.new'>[expr.new]</a>), or called directly using the function call
syntax (<a href='expr.call'>[expr.call]</a>), or called indirectly through calls to the
functions in the C++ standard library. [&nbsp;<i>Note:</i> In particular, a
global allocation function is not called to allocate storage for objects
with static storage duration (<a href='basic.stc.static'>[basic.stc.static]</a>), for objects or references
with thread storage duration (<a href='basic.stc.thread'>[basic.stc.thread]</a>), for objects of
type <span class='texttt'>std::type_info</span> (<a href='expr.typeid'>[expr.typeid]</a>), or for an
exception object (<a href='except.throw'>[except.throw]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-36'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-36'>36)</a></div><p >The intent is
to have <span class='texttt'>operator new()</span> implementable by
calling <span class='texttt'>std::malloc()</span> or <span class='texttt'>std::calloc()</span>, so the rules are
substantially the same. C++ differs from C in requiring a zero request
to return a non-null pointer.</p></div></div><div id='dynamic.deallocation'><h4 ><a class='secnum' href='#dynamic.deallocation' style='min-width:118pt'>3.7.4.2</a> Deallocation functions <a class='abbr_ref' href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a></h4><div class='para' id='dynamic.deallocation-1'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.deallocation-1'>1</a></div><p ><span class='indexparent'><a class='index' id='function,deallocation'></a></span>Deallocation functions shall be class member functions or global
functions; a program is ill-formed if deallocation functions are
declared in a namespace scope other than global scope or declared static
in global scope.</p></div><div class='para' id='dynamic.deallocation-2'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.deallocation-2'>2</a></div><p ><span class='indexparent'><a class='index' id='delete,overloading_and'></a></span>Each deallocation function shall return <span class='texttt'>void</span> and its first
parameter shall be <span class='texttt'>void*</span>. A deallocation function can have more
than one parameter.
The global <span class='texttt'>operator delete</span> with exactly one parameter is a usual
(non-placement) deallocation function. The global <span class='texttt'>operator delete</span> with
exactly two parameters, the second of which has type <span class='texttt'>std::size_t</span>, is a usual
deallocation function. Similarly, the global <span class='texttt'>operator delete[]</span> with exactly one
parameter is a usual deallocation function. The global <span class='texttt'>operator delete[]</span> with
exactly two parameters, the second of which has type <span class='texttt'>std::size_t</span>, is a usual
deallocation function.<a class='footnotenum' href='#footnote-37'>37</a>
If a class <span class='texttt'>T</span> has a member deallocation
function named <span class='texttt'>operator</span> <span class='texttt'>delete</span> with exactly one
parameter, then that function is a usual deallocation
function. If class <span class='texttt'>T</span> does not declare such an <span class='texttt'>operator</span>
<span class='texttt'>delete</span> but does declare a member deallocation function named
<span class='texttt'>operator</span> <span class='texttt'>delete</span> with exactly two parameters, the second
of which has type <span class='texttt'>std::size_t</span>, then this
function is a usual deallocation function. Similarly, if a class
<span class='texttt'>T</span> has a member deallocation function named <span class='texttt'>operator</span>
<span class='texttt'>delete[]</span> with exactly one parameter, then that function is a
usual (non-placement) deallocation function. If class <span class='texttt'>T</span> does not
declare such an <span class='texttt'>operator</span> <span class='texttt'>delete[]</span> but does declare a
member deallocation function named <span class='texttt'>operator</span> <span class='texttt'>delete[]</span>
with exactly two parameters, the second of which has type
<span class='texttt'>std::size_t</span>, then this function is a usual deallocation
function. A deallocation function can be an instance of a function
template. Neither the first parameter nor the return type shall depend
on a template parameter. [&nbsp;<i>Note:</i> That is, a deallocation function
template shall have a first parameter of type <span class='texttt'>void*</span> and a return
type of <span class='texttt'>void</span> (as specified above). <i>&nbsp;—&nbsp;end note</i>&nbsp;] A deallocation
function template shall have two or more function parameters. A template
instance is never a usual deallocation function, regardless of its
signature.</p></div><div class='para' id='dynamic.deallocation-3'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.deallocation-3'>3</a></div><p >If a deallocation function terminates by throwing an exception, the behavior is undefined.
The value of the first argument supplied to a deallocation function may
be a null pointer value; if so, and if the deallocation function is one
supplied in the standard library, the call has no effect. Otherwise,
the behavior is undefined if
the
value supplied to <span class='texttt'>operator</span> <span class='texttt'>delete(void*)</span> in the standard
library is not one of the values returned by a previous invocation of
either <span class='texttt'>operator</span> <span class='texttt'>new(std::size_t)</span> or <span class='texttt'>operator</span>
<span class='texttt'>new(std::size_t,</span> <span class='texttt'>const</span> <span class='texttt'>std::nothrow_t&amp;)</span> in the
standard library, and
the behavior is undefined if
the value supplied to <span class='texttt'>operator</span>
<span class='texttt'>delete[](void*)</span> in the standard library is not one of the
values returned by a previous invocation of either <span class='texttt'>operator</span>
<span class='texttt'>new[](std::size_t)</span> or <span class='texttt'>operator</span>
<span class='texttt'>new[](std::size_t,</span> <span class='texttt'>const</span> <span class='texttt'>std::nothrow_t&amp;)</span> in
the standard library.</p></div><div class='para' id='dynamic.deallocation-4'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.deallocation-4'>4</a></div><p >If the argument given to a deallocation function in the standard library
is a pointer that is not the null pointer value (<a href='conv.ptr'>[conv.ptr]</a>), the
deallocation function shall deallocate the storage referenced by the
pointer, rendering invalid all pointers referring to any part of the
deallocated storage.
<span class='indexparent'><a class='index' id='object,undefined_deleted'></a></span>Indirection through an invalid pointer value and passing an invalid
pointer value to a deallocation function have undefined behavior. Any
other use of an invalid pointer value has implementation-defined
behavior.<a class='footnotenum' href='#footnote-38'>38</a></p></div><div class='footnote' id='footnote-37'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-37'>37)</a></div><p >This deallocation function precludes use of an
allocation function <span class='texttt'>void operator new(std::size_t, std::size_t)</span> as a placement
allocation function (<a href='diff.cpp11.basic'>[diff.cpp11.basic]</a>).</p></div><div class='footnote' id='footnote-38'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-38'>38)</a></div><p >Some implementations might define that copying an
  invalid pointer value causes a system-generated runtime fault.</p></div></div><div id='dynamic.safety'><h4 ><a class='secnum' href='#dynamic.safety' style='min-width:118pt'>3.7.4.3</a> Safely-derived pointers <a class='abbr_ref' href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a></h4><div class='para' id='dynamic.safety-1'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.safety-1'>1</a></div><p ><span class='indexparent'><a class='index' id='pointer,safely-derived'></a></span><span class='indexparent'><a class='index' id='pointer,to_traceable_object'></a></span>A <a class='hidden_link' href='#def:traceable_pointer_object' id='def:traceable_pointer_object'><i>traceable pointer object</i></a> is</p><ul class='itemize'><li id='dynamic.safety-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-1.1'>(1.1)</a></div><p >an object of an object pointer
type (<a href='basic.compound'>[basic.compound]</a>), or
</p></li><li id='dynamic.safety-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-1.2'>(1.2)</a></div><p >an object of an integral type that is at least as large as <span class='texttt'>std::intptr_t</span>,
or
</p></li><li id='dynamic.safety-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-1.3'>(1.3)</a></div><p >a sequence of elements in an array of narrow character
type (<a href='basic.fundamental'>[basic.fundamental]</a>), where the size and alignment of the sequence
match those of some object pointer type.
</p></li></ul></div><div class='para' id='dynamic.safety-2'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.safety-2'>2</a></div><p ><span class='indexparent'><a class='index' id='safely-derived_pointer'></a></span>A pointer value is a <span class='grammarterm'>safely-derived pointer</span> to a dynamic object only if it
has an object pointer type and it is one of the following:</p><ul class='itemize'><li id='dynamic.safety-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-2.1'>(2.1)</a></div><p >the value returned by a call to the C++ standard library implementation of
<span class='texttt'>::operator new(std::size_t)</span>;<a class='footnotenum' href='#footnote-39'>39</a></p></li><li id='dynamic.safety-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-2.2'>(2.2)</a></div><p >the result of taking the address of an object (or one of its
  subobjects) designated by an lvalue resulting from indirection
  through a safely-derived pointer value;</p></li><li id='dynamic.safety-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-2.3'>(2.3)</a></div><p >the result of well-defined pointer arithmetic (<a href='expr.add'>[expr.add]</a>) using a safely-derived pointer
value;</p></li><li id='dynamic.safety-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-2.4'>(2.4)</a></div><p >the result of a well-defined pointer
conversion (<a href='conv.ptr'>[conv.ptr]</a>, <a href='expr.cast'>[expr.cast]</a>) of a safely-derived pointer value;</p></li><li id='dynamic.safety-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-2.5'>(2.5)</a></div><p >the result of a <span class='texttt'>reinterpret_cast</span> of a safely-derived pointer value;</p></li><li id='dynamic.safety-2.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-2.6'>(2.6)</a></div><p >the result of a <span class='texttt'>reinterpret_cast</span> of an integer representation of a
safely-derived pointer value;</p></li><li id='dynamic.safety-2.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-2.7'>(2.7)</a></div><p >the value of an object whose value was copied from a traceable pointer object,
where at the time of the copy the source object contained a copy of a safely-derived
pointer value.
</p></li></ul></div><div class='para' id='dynamic.safety-3'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.safety-3'>3</a></div><p ><span class='indexparent'><a class='index' id='integer_representation'></a></span><span class='indexparent'><a class='index' id='safely-derived_pointer,integer_representation'></a></span><span class='indexparent'><a class='index' id='pointer,_integer_representation_of_safely-derived'></a></span>An integer value is an <span class='grammarterm'>integer representation of a safely-derived pointer</span>
only if its type is at least as large as <span class='texttt'>std::intptr_t</span> and it is one of the
following:</p><ul class='itemize'><li id='dynamic.safety-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-3.1'>(3.1)</a></div><p >the result of a <span class='texttt'>reinterpret_cast</span> of a safely-derived pointer value;</p></li><li id='dynamic.safety-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-3.2'>(3.2)</a></div><p >the result of a valid conversion of an integer representation of a safely-derived
pointer value;</p></li><li id='dynamic.safety-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-3.3'>(3.3)</a></div><p >the value of an object whose value was copied from a traceable pointer object,
where at the time of the copy the source object contained an integer representation of a
safely-derived pointer value;</p></li><li id='dynamic.safety-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#dynamic.safety-3.4'>(3.4)</a></div><p >the result of an additive or bitwise operation, one of whose operands is an
integer representation of a safely-derived pointer value <span class='texttt'>P</span>, if that result
converted by <span class='texttt'>reinterpret_cast&lt;void*&gt;</span> would compare equal to a safely-derived
pointer computable from <span class='texttt'>reinterpret_cast&lt;void*&gt;(P)</span>.
</p></li></ul></div><div class='para' id='dynamic.safety-4'><div class='marginalizedparent'><a class='marginalized' href='#dynamic.safety-4'>4</a></div><p >An implementation may have <a class='hidden_link' href='#def:relaxed_pointer_safety' id='def:relaxed_pointer_safety'><i>relaxed pointer safety</i></a>, in which case the
validity of a pointer value does not depend on whether it is a safely-derived
pointer value. Alternatively, an implementation may have <a class='hidden_link' href='#def:strict_pointer_safety' id='def:strict_pointer_safety'><i>strict pointer
safety</i></a>, in which case a pointer value referring to an object with dynamic
storage duration that is not a safely-derived pointer
value is an invalid pointer value unless
the referenced complete object has previously been declared
reachable (<a href='util.dynamic.safety'>[util.dynamic.safety]</a>). [&nbsp;<i>Note:</i>
the effect of using an invalid pointer value (including passing it to a
deallocation function) is undefined, see <a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>.
This is true even if the unsafely-derived pointer value might compare equal to
some safely-derived pointer value. <i>&nbsp;—&nbsp;end note</i>&nbsp;] It is implementation
defined<span class='indexparent'><a class='index' id='whether_an_implementation_has_relaxed_or_strict_pointer_safety'></a></span> whether an implementation has relaxed or strict pointer safety.<span class='indexparent'><a class='index' id='pointer,safely-derived'></a></span><span class='indexparent'><a class='index' id='storage_duration,dynamic'></a></span></p></div><div class='footnote' id='footnote-39'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-39'>39)</a></div><p >This section does not impose restrictions
on indirection through pointers to memory not allocated by <span class='texttt'>::operator new</span>. This
maintains the ability of many C++ implementations to use binary libraries and
components written in other languages. In particular, this applies to C binaries,
because indirection through pointers to memory allocated by <span class='texttt'>std::malloc</span> is not restricted.</p></div></div></div><div id='inherit'><h3 ><a class='secnum' href='#inherit' style='min-width:103pt'>3.7.5</a> Duration of subobjects <a class='abbr_ref' href='basic.stc.inherit'>[basic.stc.inherit]</a></h3><div class='para' id='inherit-1'><div class='marginalizedparent'><a class='marginalized' href='#inherit-1'>1</a></div><p ><span class='indexparent'><a class='index' id='storage_duration,class_member'></a></span>The storage duration of member subobjects, base class subobjects and
array elements is that of their complete object (<a href='intro.object'>[intro.object]</a>).
<span class='indexparent'><a class='index' id='storage_duration'></a></span>
</p></div></div></div></div></body></html>