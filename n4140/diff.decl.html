<!DOCTYPE html><html lang='en'><head><title>[diff.decl]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='annexnum' style='min-width:73pt'>Annex C&emsp;(informative)</a> Compatibility <a class='abbr_ref' href='./#diff'>[diff]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>C.1</a> C++ and ISO C <a class='abbr_ref' href='diff.iso#diff.decl'>[diff.iso]</a></h2><div id='diff.decl'><h3 ><a class='secnum' style='min-width:103pt'>C.1.7</a> Clause <a href='dcl.decl'>[dcl.decl]</a>: declarators <a class='abbr_ref'>[diff.decl]</a></h3><p ><a href='dcl.fct'>[dcl.fct]</a>
<span class='hfill'></span><br/><b>Change:</b> In C++, a function declared with an empty parameter list takes no arguments.
In C, an empty parameter list means that the number and type of the function arguments are unknown.</p><p >Example:</p><pre class='codeblock'>
int f();            <span class='comment'>// means   <span class='texttt'>int f(void)</span> in C++
</span>                    <span class='comment'>// <span class='texttt'>int f(</span> unknown <span class='texttt'>)</span> in C
</span></pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
This is to avoid erroneous function calls (i.e., function calls
with the wrong number or type of arguments).
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Change to semantics of well-defined feature.
This feature was marked as “obsolescent” in C.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Syntactic transformation.
The function declarations using C incomplete declaration style must
be completed to become full prototype declarations.
A program may need to be updated further if different calls to the
same (non-prototype) function have different numbers of arguments or
if the type of corresponding arguments differed.
<span class='hfill'></span><br/><b>How widely used:</b>
Common.</p><p ><a href='dcl.fct'>[dcl.fct]</a> [see <a href='expr.sizeof'>[expr.sizeof]</a>]
<span class='hfill'></span><br/><b>Change:</b> In C++, types may not be defined in return or parameter types. In C, these type definitions are allowed</p><p >Example:</p><pre class='codeblock'>
void f( struct S { int a; } arg ) {}    <span class='comment'>// valid C, invalid C++
</span>enum E { A, B, C } f() {}               <span class='comment'>// valid C, invalid C++
</span></pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
When comparing types in different compilation units, C++ relies
on name equivalence when C relies on structural equivalence.
Regarding parameter types: since the type defined in an parameter list
would be in the scope of the function, the only legal calls in C++
would be from within the function itself.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
The type definitions must be moved to file scope, or in header files.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.
This style of type definitions is seen as poor coding style.</p><p ><a href='dcl.fct.def'>[dcl.fct.def]</a>
<span class='hfill'></span><br/><b>Change:</b> In C++, the syntax for function definition excludes the “old-style” C function.
In C, “old-style” syntax is allowed, but deprecated as “obsolescent.”
<span class='hfill'></span><br/><b>Rationale:</b>
Prototypes are essential to type safety.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Syntactic transformation.
<span class='hfill'></span><br/><b>How widely used:</b>
Common in old programs, but already known to be obsolescent.</p><p ><a href='dcl.init.string'>[dcl.init.string]</a>
<span class='hfill'></span><br/><b>Change:</b> In C++, when initializing an array of character with a string, the number of
characters in the string (including the terminating <span class='texttt'>'\0'</span>) must not exceed the
number of elements in the array. In C, an array can be initialized with a string even if
the array is not large enough to contain the string-terminating <span class='texttt'>'\0'</span></p><p >Example:</p><pre class='codeblock'>
char array[4] = "abcd";         <span class='comment'>// valid C, invalid C++
</span></pre><p ><span class='hfill'></span><br/><b>Rationale:</b>
When these non-terminated arrays are manipulated by standard
string routines, there is potential for major catastrophe.
<span class='hfill'></span><br/><b>Effect on original feature:</b>
Deletion of semantically well-defined feature.
<span class='hfill'></span><br/><b>Difficulty of converting:</b>
Semantic transformation.
The arrays must be declared one element bigger to contain the
string terminating <span class='texttt'>'\0'</span>.
<span class='hfill'></span><br/><b>How widely used:</b>
Seldom.
This style of array initialization is seen as poor coding style.</p></div></div></body></html>