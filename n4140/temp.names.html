<!DOCTYPE html><html lang='en'><head><title>[temp.names]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><div id='temp.names'><h2 ><a class='secnum' style='min-width:88pt'>14.2</a> Names of template specializations <a class='abbr_ref'>[temp.names]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A template specialization (<a href='temp.spec'>[temp.spec]</a>) can be referred to by a
<i ><a href='temp.names#nt:template-id'>template-id</a></i>:</p><pre class='bnf'><a id='nt:simple-template-id'>simple-template-id:</a>
  <i ><a href='temp.names#nt:template-name'>template-name</a></i> <span class='terminal'>&lt;</span> <i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>&gt;</span></pre><pre class='bnf'><a id='nt:template-id'>template-id:</a>
  <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
  <i ><a href='over.oper#nt:operator-function-id'>operator-function-id</a></i> <span class='terminal'>&lt;</span> <i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>&gt;</span>
  <i ><a href='over.literal#nt:literal-operator-id'>literal-operator-id</a></i> <span class='terminal'>&lt;</span> <i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>&gt;</span></pre><pre class='bnf'><a id='nt:template-name'>template-name:</a>
  <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre><pre class='bnf'><a id='nt:template-argument-list'>template-argument-list:</a>
  <i ><a href='temp.names#nt:template-argument'>template-argument</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
  <i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i> <span class='terminal'>,</span> <i ><a href='temp.names#nt:template-argument'>template-argument</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:template-argument'>template-argument:</a>
  <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i>
  <i ><a href='dcl.name#nt:type-id'>type-id</a></i>
  <i ><a href='expr.prim.general#nt:id-expression'>id-expression</a></i></pre><p >[&nbsp;<i>Note:</i>
The name lookup rules (<a href='basic.lookup'>[basic.lookup]</a>) are used to associate the use of
a name with a template declaration;
that is, to identify a name as a
<i ><a href='temp.names#nt:template-name'>template-name</a></i>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >For a
<i ><a href='temp.names#nt:template-name'>template-name</a></i>
to be explicitly qualified by the template arguments,
the name must be known to refer to a template.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='<,template_and'></a></span>After name lookup (<a href='basic.lookup'>[basic.lookup]</a>) finds that a name is a
<i ><a href='temp.names#nt:template-name'>template-name</a></i>
or that an <i ><a href='over.oper#nt:operator-function-id'>operator-function-id</a></i> or a <i ><a href='over.literal#nt:literal-operator-id'>literal-operator-id</a></i> refers to a set of
overloaded functions any member of which is a function template,
if this is followed by a
<span class='texttt'>&lt;</span>,
the
<span class='texttt'>&lt;</span>
is always taken as the delimiter of a
<i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i>
and never as the less-than operator.
When parsing a <i ><a href='temp.names#nt:template-argument-list'>template-argument-list</a></i>,
the first non-nested
<span class='texttt'>&gt;</span><a class='footnotenum' href='#footnote-138'>138</a>
is taken as the ending delimiter
rather than a greater-than operator.
Similarly, the first non-nested <span class='texttt'>&gt;&gt;</span> is treated as two
consecutive but distinct <span class='texttt'>&gt;</span> tokens, the first of which is taken
as the end of the <span class='rmfamily'></span><i> template-argument-list</i> and completes
the <span class='rmfamily'></span><i> template-id</i>. [&nbsp;<i>Note:</i> The second <span class='texttt'>&gt;</span>
token produced by this replacement rule may terminate an enclosing
<span class='rmfamily'></span><i> template-id</i> construct or it may be part of a different
construct (e.g. a cast).<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;int i&gt; class X <span class='texttt'>{ /* ... */ };</span>

X&lt; 1&gt;2 &gt; x1;                        <span class='comment'>// syntax error
</span>X&lt;(1&gt;2)&gt; x2;                        <span class='comment'>// OK
</span>
template&lt;class T&gt; class Y <span class='texttt'>{ /* ... */ };</span>
Y&lt;X&lt;1&gt;&gt; x3;                         <span class='comment'>// OK, same as <span class='texttt'>Y&lt;X&lt;1&gt; &gt; x3;</span>
</span>Y&lt;X&lt;6&gt;&gt;1&gt;&gt; x4;                      <span class='comment'>// syntax error
</span>Y&lt;X&lt;(6&gt;&gt;1)&gt;&gt; x5;                    <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >When the name of a member template specialization appears after
<span class='texttt'>.</span>
or
<span class='texttt'>-&gt;</span>
in a
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>
or after a
<i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i>
in a
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>,
and the
object expression of the
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>
is type-dependent
or
the <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> in the
<i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i>
refers to a dependent type, but the name is not
a member of the current instantiation (<a href='temp.dep.type'>[temp.dep.type]</a>),
the member template name must be prefixed by the keyword
<span class='texttt'>template</span>.
Otherwise the name is assumed to name a non-template.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct X {
  template&lt;std::size_t&gt; X* alloc();
  template&lt;std::size_t&gt; static X* adjust();
};
template&lt;class T&gt; void f(T* p) {
  T* p1 = p-&gt;alloc&lt;200&gt;();          <span class='comment'>// ill-formed: <span class='texttt'>&lt;</span> means less than
</span>  T* p2 = p-&gt;template alloc&lt;200&gt;(); <span class='comment'>// OK: <span class='texttt'>&lt;</span> starts template argument list
</span>  T::adjust&lt;100&gt;();                 <span class='comment'>// ill-formed: <span class='texttt'>&lt;</span> means less than
</span>  T::template adjust&lt;100&gt;();        <span class='comment'>// OK: <span class='texttt'>&lt;</span> starts template argument list
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A name prefixed by the keyword
<span class='texttt'>template</span>
shall be a <i ><a href='temp.names#nt:template-id'>template-id</a></i> or the name shall refer to a class template.
[&nbsp;<i>Note:</i>
The keyword
<span class='texttt'>template</span>
may not be applied to non-template members of class templates.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Note:</i>
As is the case with the
<span class='texttt'>typename</span>
prefix, the
<span class='texttt'>template</span>
prefix is allowed in cases where it is not strictly
necessary; i.e., when the <i ><a href='expr.prim.general#nt:nested-name-specifier'>nested-name-specifier</a></i> or
the expression on the left of
the
<span class='texttt'>-&gt;</span>
or
<span class='texttt'>.</span>
is not dependent on a
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i>, or the use does not appear in the
scope of a template.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; struct A {
  void f(int);
  template &lt;class U&gt; void f(U);
};

template &lt;class T&gt; void f(T t) {
  A&lt;T&gt; a;
  a.template f&lt;&gt;(t);                <span class='comment'>// OK: calls template
</span>  a.template f(t);                  <span class='comment'>// error: not a <span class='grammarterm'>template-id</span>
</span>}

template &lt;class T&gt; struct B {
  template &lt;class T2&gt; struct C { };
};

<span class='comment'>// OK: <span class='texttt'>T::template C</span> names a class template:
</span>template &lt;class T, template &lt;class X&gt; class TT = T::template C&gt; struct D { };
D&lt;B&lt;int&gt; &gt; db;
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='specialization,class_template'></a></span>A
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
that names a class template specialization is a
<i ><a href='class#nt:class-name'>class-name</a></i>
(Clause <a href='class'>[class]</a>).</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >A <i ><a href='temp.names#nt:template-id'>template-id</a></i> that names an alias template
specialization is a <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>.</p></div><div class='footnote' id='footnote-138'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-138'>138)</a></div><p >A <span class='texttt'>&gt;</span> that encloses the <i ><a href='dcl.name#nt:type-id'>type-id</a></i>
of a <span class='texttt'>dynamic_cast</span>, <span class='texttt'>static_cast</span>, <span class='texttt'>reinterpret_cast</span>
or <span class='texttt'>const_cast</span>, or which encloses the <i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>
of a subsequent <i ><a href='temp.names#nt:template-id'>template-id</a></i>, is considered nested for the purpose
of this description.
</p></div></div></div></body></html>