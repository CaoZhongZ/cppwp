<!DOCTYPE html><html lang='en'><head><title>[dcl.spec.auto]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Declarations <a class='abbr_ref' href='./#dcl.dcl'>[dcl.dcl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>7.1</a> Specifiers <a class='abbr_ref' href='dcl.spec#auto'>[dcl.spec]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>7.1.6</a> Type specifiers <a class='abbr_ref' href='dcl.type#dcl.spec.auto'>[dcl.type]</a></h3><div id='dcl.spec.auto'><h4 ><a class='secnum' style='min-width:118pt'>7.1.6.4</a> <span class='texttt'>auto</span> specifier <a class='abbr_ref'>[dcl.spec.auto]</a></h4><p ><span class='indexparent'><a class='index' id='type_specifier,auto'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The <span class='texttt'>auto</span> and <span class='texttt'>decltype(auto)</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifiers</a></i>
designate a placeholder type that will be replaced later, either by deduction
from an initializer or by explicit specification with a
<i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i>. The <span class='texttt'>auto</span>
<i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> is also used to signify that a lambda is a
generic lambda.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The placeholder type can appear with a function declarator in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>, <i ><a href='dcl.type#nt:type-specifier-seq'>type-specifier-seq</a></i>,
<i ><a href='class.conv.fct#nt:conversion-function-id'>conversion-function-id</a></i>, or <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i>,
in any context where such a declarator is valid. If the function declarator
includes a <i ><a href='dcl.decl#nt:trailing-return-type'>trailing-return-type</a></i> (<a href='dcl.fct'>[dcl.fct]</a>), that specifies
the declared return type of the function. If the declared return type of the
function contains a placeholder type, the return type of the function is
deduced from <span class='texttt'>return</span> statements in the body of the function, if any.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >If the <span class='texttt'>auto</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> appears as one of the
<i ><a href='dcl.spec#nt:decl-specifier'>decl-specifiers</a></i> in the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> of a
<i ><a href='dcl.fct#nt:parameter-declaration'>parameter-declaration</a></i> of a <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i>, the
<span class='indexparent'><a class='index' id='generic_lambda,definition_of'></a></span>lambda is a <a class='hidden_link' href='#def:generic_lambda' id='def:generic_lambda'><i>generic lambda</i></a> (<a href='expr.prim.lambda'>[expr.prim.lambda]</a>). [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto glambda = [](int i, auto a) { return i; }; <span class='comment'>// OK: a generic lambda
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The type of a variable declared using <span class='texttt'>auto</span> or <span class='texttt'>decltype(auto)</span> is
deduced from its initializer. This use is allowed when declaring variables in a
block (<a href='stmt.block'>[stmt.block]</a>), in
namespace scope (<a href='basic.scope.namespace'>[basic.scope.namespace]</a>), and in a
<span class='small'></span><span class='rmfamily'></span><i> for-init-statement</i> (<a href='stmt.for'>[stmt.for]</a>).
<span class='texttt'>auto</span> or <span class='texttt'>decltype(auto)</span> shall appear as one of the
<i ><a href='dcl.spec#nt:decl-specifier'>decl-specifiers</a></i> in the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> and the
<i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
shall be followed by one or more <i ><a href='dcl.decl#nt:init-declarator'>init-declarators</a></i>, each of which shall
have a non-empty <i ><a href='dcl.init#nt:initializer'>initializer</a></i>. In an
<i ><a href='dcl.init#nt:initializer'>initializer</a></i> of the form</p><pre class='codeblock'>
( <span class='grammarterm'>expression-list</span> )
</pre><p >the <i ><a href='expr.post#nt:expression-list'>expression-list</a></i> shall be a single
<i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto x = 5;                 <span class='comment'>// OK: <span class='texttt'>x</span> has type <span class='texttt'>int</span>
</span>const auto *v = &amp;x, u = 6;  <span class='comment'>// OK: <span class='texttt'>v</span> has type <span class='texttt'>const int*</span>, <span class='texttt'>u</span> has type <span class='texttt'>const int</span>
</span>static auto y = 0.0;        <span class='comment'>// OK: <span class='texttt'>y</span> has type <span class='texttt'>double</span>
</span>auto int r;                 <span class='comment'>// error: auto is not a <span class='grammarterm'>storage-class-specifier</span>
</span>auto f() -&gt; int;            <span class='comment'>// OK: <span class='texttt'>f</span> returns <span class='texttt'>int</span>
</span>auto g() { return 0.0; }    <span class='comment'>// OK: <span class='texttt'>g</span> returns <span class='texttt'>double</span>
</span>auto h();                   <span class='comment'>// OK: <span class='texttt'>h</span>'s return type will be deduced when it is defined
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A placeholder type can also be used in declaring a variable in
the <span class='small'></span><span class='rmfamily'></span><i> condition</i> of a selection statement (<a href='stmt.select'>[stmt.select]</a>) or an iteration
statement (<a href='stmt.iter'>[stmt.iter]</a>), in the <span class='small'></span><span class='rmfamily'></span><i> type-specifier-seq</i> in 
the <span class='small'></span><span class='rmfamily'></span><i> new-type-id</i> or <span class='small'></span><span class='rmfamily'></span><i> type-id</i> of a
<span class='small'></span><span class='rmfamily'></span><i> new-expression</i> (<a href='expr.new'>[expr.new]</a>), in a
<i ><a href='stmt.iter#nt:for-range-declaration'>for-range-declaration</a></i>, and in declaring a static data member with a
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> that appears within the
<span class='small'></span><span class='rmfamily'></span><i> member-specification</i> of a class definition (<a href='class.static.data'>[class.static.data]</a>).</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >A program that uses <span class='texttt'>auto</span> or <span class='texttt'>decltype(auto)</span> in a context not
explicitly allowed in this section is ill-formed.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >When a variable declared using a placeholder type is initialized, or a
<span class='texttt'>return</span> statement occurs in a function declared with a return type that
contains a placeholder type, the deduced return type or variable type is
determined from the type of its initializer. In the case of a <span class='texttt'>return</span>
with no operand, the initializer is considered to be <span class='texttt'>void()</span>.
Let <span class='texttt'>T</span> be the declared type of the variable or return type of the
function.
If the placeholder is the <span class='texttt'>auto</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>, the
deduced type is determined using the rules for template argument deduction.
If the deduction is for a <span class='texttt'>return</span> statement and the initializer is a
<i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i> (<a href='dcl.init.list'>[dcl.init.list]</a>), the program is
ill-formed. Otherwise, obtain <span class='texttt'>P</span> from
<span class='texttt'>T</span> by replacing the occurrences of <span class='texttt'>auto</span> with either a new
invented type template parameter <span class='texttt'>U</span> or, if the initializer is a
<i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>, with
<span class='texttt'>std::initializer_list&lt;U&gt;</span>. Deduce a value for <span class='texttt'>U</span> using the rules
of template argument deduction from a function call (<a href='temp.deduct.call'>[temp.deduct.call]</a>),
where <span class='texttt'>P</span> is a
function template parameter type and the initializer is the
corresponding argument. If the deduction fails, the declaration is ill-formed.
Otherwise, the type deduced for the variable or return type is obtained by
substituting the deduced <span class='texttt'>U</span> into <span class='texttt'>P</span>.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto x1 = { 1, 2 };         <span class='comment'>// <span class='texttt'>decltype(x1)</span> is <span class='texttt'>std::initializer_list&lt;int&gt;</span>
</span>auto x2 = { 1, 2.0 };       <span class='comment'>// error: cannot deduce element type
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
const auto &amp;i = expr;
</pre><p >The type of <span class='texttt'>i</span> is the deduced type of the parameter <span class='texttt'>u</span> in
the call <span class='texttt'>f(expr)</span> of the following invented function template:</p><pre class='codeblock'>
template &lt;class U&gt; void f(const U&amp; u);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >If the placeholder is the <span class='texttt'>decltype(auto)</span> <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i>,
the declared type of the variable or return type of the function shall be the
placeholder alone. The type deduced for the variable or return type is
determined as described in <a href='dcl.type.simple'>[dcl.type.simple]</a>, as though the initializer had
been the operand of the <span class='texttt'>decltype</span>. [&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
int i;
int&amp;&amp; f();
auto           x3a = i;        <span class='comment'>// <span class='texttt'>decltype(x3a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x3d = i;        <span class='comment'>// <span class='texttt'>decltype(x3d)</span> is <span class='texttt'>int</span>
</span>auto           x4a = (i);      <span class='comment'>// <span class='texttt'>decltype(x4a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x4d = (i);      <span class='comment'>// <span class='texttt'>decltype(x4d)</span> is <span class='texttt'>int&amp;</span>
</span>auto           x5a = f();      <span class='comment'>// <span class='texttt'>decltype(x5a)</span> is <span class='texttt'>int</span>
</span>decltype(auto) x5d = f();      <span class='comment'>// <span class='texttt'>decltype(x5d)</span> is <span class='texttt'>int&amp;&amp;</span>
</span>auto           x6a = { 1, 2 }; <span class='comment'>// <span class='texttt'>decltype(x6a)</span> is <span class='texttt'>std::initializer_list&lt;int&gt;</span>
</span>decltype(auto) x6d = { 1, 2 }; <span class='comment'>// error, <span class='texttt'>{ 1, 2 }</span> is not an expression
</span>auto          *x7a = &amp;i;       <span class='comment'>// <span class='texttt'>decltype(x7a)</span> is <span class='texttt'>int*</span>
</span>decltype(auto)*x7d = &amp;i;       <span class='comment'>// error, declared type is not plain <span class='texttt'>decltype(auto)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >If the <i ><a href='dcl.decl#nt:init-declarator-list'>init-declarator-list</a></i> contains more than one
<i ><a href='dcl.decl#nt:init-declarator'>init-declarator</a></i>, they shall all form declarations of
variables. The type of each declared variable is determined as
described above, and if the type that replaces the placeholder type is not the
same in each deduction, the program is ill-formed.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto x = 5, *y = &amp;x;        <span class='comment'>// OK: <span class='texttt'>auto</span> is <span class='texttt'>int</span>
</span>auto a = 5, b = { 1, 2 };   <span class='comment'>// error: different types for <span class='texttt'>auto</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='specifier'></a></span></p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >If a function with a declared return type that contains a placeholder type has
multiple <span class='texttt'>return</span> statements, the return type is deduced for each
<span class='texttt'>return</span> statement. If the type deduced is not the same in each
deduction, the program is ill-formed.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >If a function with a declared return type that uses a placeholder type has no
<span class='texttt'>return</span> statements, the return type is deduced as though from a
<span class='texttt'>return</span> statement with no operand at the closing brace of the function
body.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto  f() { } <span class='comment'>// OK, return type is <span class='texttt'>void</span>
</span>auto* g() { } <span class='comment'>// error, cannot deduce <span class='texttt'>auto*</span> from <span class='texttt'>void()</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >If the type of an entity with an undeduced placeholder type is needed to
determine the type of an expression, the program is ill-formed. Once a
<span class='texttt'>return</span> statement has been seen in a function, however, the return type deduced
from that statement can be used in the rest of the function, including in other
<span class='texttt'>return</span> statements.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto n = n;            <span class='comment'>// error, <span class='texttt'>n</span>'s type is unknown
</span>auto f();
void g() { &amp;f; }       <span class='comment'>// error, <span class='texttt'>f</span>'s return type is unknown
</span>auto sum(int i) {
  if (i == 1)
    return i;          <span class='comment'>// <span class='texttt'>sum</span>'s return type is <span class='texttt'>int</span>
</span>  else
    return sum(i-1)+i; <span class='comment'>// OK, <span class='texttt'>sum</span>'s return type has been deduced
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >Return type deduction for a function template with a placeholder in its
declared type occurs when the definition is instantiated even if the function
body contains a <span class='texttt'>return</span> statement with a non-type-dependent operand.
[&nbsp;<i>Note:</i> Therefore, any use of a specialization of the function template will
cause an implicit instantiation. Any errors that arise from this instantiation
are not in the immediate context of the function type and can result in the
program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; auto f(T t) { return t; }  <span class='comment'>// return type deduced at instantiation time
</span>typedef decltype(f(1)) fint_t;                <span class='comment'>// instantiates <span class='texttt'>f&lt;int&gt;</span> to deduce return type
</span>template&lt;class T&gt; auto f(T* t) { return *t; }
void g() { int (*p)(int*) = &amp;f; }             <span class='comment'>// instantiates both <span class='texttt'>f</span>s to determine return types,
</span>                                              <span class='comment'>// chooses second
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p >Redeclarations or specializations of a function or function template with a
declared return type that uses a placeholder type shall also use that
placeholder, not a deduced type.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
auto f();
auto f() { return 42; } <span class='comment'>// return type is <span class='texttt'>int</span>
</span>auto f();               <span class='comment'>// OK
</span>int f();                <span class='comment'>// error, cannot be overloaded with <span class='texttt'>auto f()</span>
</span>decltype(auto) f();     <span class='comment'>// error, <span class='texttt'>auto</span> and <span class='texttt'>decltype(auto)</span> don't match
</span>
template &lt;typename T&gt; auto g(T t) { return t; } <span class='comment'>// #1
</span>template auto g(int);                           <span class='comment'>// OK, return type is <span class='texttt'>int</span>
</span>template char g(char);                          <span class='comment'>// error, no matching template
</span>template&lt;&gt; auto g(double);                      <span class='comment'>// OK, forward declaration with unknown return type
</span>
template &lt;class T&gt; T g(T t) { return t; } <span class='comment'>// OK, not functionally equivalent to #1
</span>template char g(char);                    <span class='comment'>// OK, now there is a matching template
</span>template auto g(float);                   <span class='comment'>// still matches #1
</span>
void h() { return g(42); } <span class='comment'>// error, ambiguous
</span>
template &lt;typename T&gt; struct A {
  friend T frf(T);
};
auto frf(int i) { return i; } <span class='comment'>// not a friend of <span class='texttt'>A&lt;int&gt;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><p >A function declared with a return type that uses a placeholder type shall not
be <span class='texttt'>virtual</span> (<a href='class.virtual'>[class.virtual]</a>).</p></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><p >An explicit instantiation declaration (<a href='temp.explicit'>[temp.explicit]</a>) does not cause the
instantiation of an entity declared using a placeholder type, but it also does
not prevent that entity from being instantiated as needed to determine its
type.
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;typename T&gt; auto f(T t) { return t; }
extern template auto f(int); <span class='comment'>// does not instantiate <span class='texttt'>f&lt;int&gt;</span>
</span>int (*p)(int) = f;           <span class='comment'>// instantiates <span class='texttt'>f&lt;int&gt;</span> to determine its return type, but an explicit
</span>                             <span class='comment'>// instantiation definition is still required somewhere in the program
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></body></html>