<!DOCTYPE html><html lang='en'><head><title>[file.streams]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>27</a> Input/output library <a class='abbr_ref' href='./#input.output'>[input.output]</a></h1><div id='file.streams'><h2 ><a class='secnum' style='min-width:88pt'>27.9</a> File-based streams <a class='abbr_ref'>[file.streams]</a></h2><div id='fstreams'><h3 ><a class='secnum' href='#fstreams' style='min-width:103pt'>27.9.1</a> File streams <a class='abbr_ref' href='fstreams'>[fstreams]</a></h3><div class='para' id='fstreams-1'><div class='marginalizedparent'><a class='marginalized' href='#fstreams-1'>1</a></div><p >The header
<span class='texttt'>&lt;fstream&gt;</span>
defines four class templates and eight types
that associate stream buffers with files and assist
reading and writing files.</p><p ><b>Header <span class='texttt'>&lt;fstream&gt;</span> synopsis</b>
<span class='indexparent'><a class='index' id='fstream'></a></span><span class='indexparent'><a class='index' id='filebuf'></a></span><span class='indexparent'><a class='index' id='basic_filebuf<char>'></a></span><span class='indexparent'><a class='index' id='wfilebuf'></a></span><span class='indexparent'><a class='index' id='basic_filebuf<wchar_t>'></a></span><span class='indexparent'><a class='index' id='ifstream'></a></span><span class='indexparent'><a class='index' id='basic_ifstream<char>'></a></span><span class='indexparent'><a class='index' id='wifstream'></a></span><span class='indexparent'><a class='index' id='basic_ifstream<wchar_t>'></a></span><span class='indexparent'><a class='index' id='ofstream'></a></span><span class='indexparent'><a class='index' id='basic_ofstream<char>'></a></span><span class='indexparent'><a class='index' id='wofstream'></a></span><span class='indexparent'><a class='index' id='basic_ofstream<wchar_t>'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
    class basic_filebuf;
  typedef basic_filebuf&lt;char&gt;    filebuf;
  typedef basic_filebuf&lt;wchar_t&gt; wfilebuf;

  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
    class basic_ifstream;
  typedef basic_ifstream&lt;char&gt;    ifstream;
  typedef basic_ifstream&lt;wchar_t&gt; wifstream;

  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
    class basic_ofstream;
  typedef basic_ofstream&lt;char&gt;    ofstream;
  typedef basic_ofstream&lt;wchar_t&gt; wofstream;

  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
    class basic_fstream;
  typedef basic_fstream&lt;char&gt;     fstream;
  typedef basic_fstream&lt;wchar_t&gt; wfstream;
}
</pre></div><div class='para' id='fstreams-2'><div class='marginalizedparent'><a class='marginalized' href='#fstreams-2'>2</a></div><p >In this subclause, the type name <span class='texttt'>FILE</span> refers to
the type
<span class='texttt'>FILE</span>
declared in
<span class='texttt'>&lt;cstdio&gt;</span>
<span class='indexparent'><a class='index' id='cstdio'></a></span>(<a href='c.files'>[c.files]</a>).</p></div><div class='para' id='fstreams-3'><div class='marginalizedparent'><a class='marginalized' href='#fstreams-3'>3</a></div><p >[&nbsp;<i>Note:</i> The class template <span class='texttt'>basic_filebuf</span> treats a file as a source or
sink of bytes. In an environment that uses a large character set, the file
typically holds multibyte character sequences and the <span class='texttt'>basic_filebuf</span>
object converts those multibyte sequences into wide character sequences.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='filebuf'><h4 ><a class='secnum' href='#filebuf' style='min-width:118pt'>27.9.1.1</a> Class template <span class='texttt'>basic_filebuf</span> <a class='abbr_ref' href='filebuf'>[filebuf]</a></h4><p ><span class='indexparent'><a class='index' id='basic_filebuf'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class basic_filebuf : public basic_streambuf&lt;charT,traits&gt; {
  public:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;

    <span class='comment'>// <a href='filebuf.cons'>[filebuf.cons]</a> Constructors/destructor:
</span>    basic_filebuf();
    basic_filebuf(const basic_filebuf&amp; rhs) = delete;
    basic_filebuf(basic_filebuf&amp;&amp; rhs);
    virtual ~basic_filebuf();

    <span class='comment'>// <a href='filebuf.assign'>[filebuf.assign]</a> Assign/swap:
</span>    basic_filebuf&amp; operator=(const basic_filebuf&amp; rhs) = delete;
    basic_filebuf&amp; operator=(basic_filebuf&amp;&amp; rhs);
    void swap(basic_filebuf&amp; rhs);

     <span class='comment'>// <a href='filebuf.members'>[filebuf.members]</a> Members:
</span>    bool is_open() const;
    basic_filebuf&lt;charT,traits&gt;* open(const char* s,
        ios_base::openmode mode);
    basic_filebuf&lt;charT,traits&gt;* open(const string&amp; s,
        ios_base::openmode mode);
    basic_filebuf&lt;charT,traits&gt;* close();

  protected:
    <span class='comment'>// <a href='filebuf.virtuals'>[filebuf.virtuals]</a> Overridden virtual functions:
</span>    virtual streamsize showmanyc();
    virtual int_type underflow();
    virtual int_type uflow();
    virtual int_type pbackfail(int_type c = traits::eof());
    virtual int_type overflow (int_type c = traits::eof());

    virtual basic_streambuf&lt;charT,traits&gt;*
        setbuf(char_type* s, streamsize n);
    virtual pos_type seekoff(off_type off, ios_base::seekdir way,
        ios_base::openmode which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type sp,
        ios_base::openmode which = ios_base::in | ios_base::out);
    virtual int      sync();
    virtual void     imbue(const locale&amp; loc);
  };

  template &lt;class charT, class traits&gt;
  void swap(basic_filebuf&lt;charT, traits&gt;&amp; x,
            basic_filebuf&lt;charT, traits&gt;&amp; y);
}
</pre><div class='para' id='filebuf-1'><div class='marginalizedparent'><a class='marginalized' href='#filebuf-1'>1</a></div><p >The class
<span class='texttt'>basic_filebuf&lt;charT,traits&gt;</span>
associates both the input sequence and the output
sequence with a file.</p></div><div class='para' id='filebuf-2'><div class='marginalizedparent'><a class='marginalized' href='#filebuf-2'>2</a></div><p >The restrictions on reading and writing a sequence controlled by an
object of class
<span class='texttt'>basic_filebuf&lt;charT, traits&gt;</span>
are the same as for reading and writing with the Standard C library
<span class='texttt'>FILE</span>s.</p></div><div class='para' id='filebuf-3'><div class='marginalizedparent'><a class='marginalized' href='#filebuf-3'>3</a></div><p >In particular:
</p><ul ><li ><p >If the file is not open for reading the input sequence
cannot be read.
</p></li><li ><p >If the file is not open for writing the output
sequence cannot be written.
</p></li><li ><p >A joint file position is maintained for both the input sequence and
the output sequence.
</p></li></ul></div><div class='para' id='filebuf-4'><div class='marginalizedparent'><a class='marginalized' href='#filebuf-4'>4</a></div><p >An instance of
<span class='texttt'>basic_filebuf</span>
behaves as described in <a href='filebuf'>[filebuf]</a> provided
<span class='texttt'>traits::pos_type</span>
is
<span class='texttt'>fpos&lt;traits<span class='discretionary'></span>::<span class='discretionary'></span>state_type&gt;</span>.
Otherwise the behavior is undefined.</p></div><div class='para' id='filebuf-5'><div class='marginalizedparent'><a class='marginalized' href='#filebuf-5'>5</a></div><p >In order to support file I/O and multibyte/wide character conversion,
conversions are performed using members of a facet, referred to as
<span class='texttt'>a_codecvt</span> in following sections, obtained as if by</p><pre class='codeblock'>
const codecvt&lt;charT,char,typename traits::state_type&gt;&amp; a_codecvt =
  use_facet&lt;codecvt&lt;charT,char,typename traits::state_type&gt; &gt;(getloc());
</pre></div></div><div id='filebuf.cons'><h4 ><a class='secnum' href='#filebuf.cons' style='min-width:118pt'>27.9.1.2</a> <span class='texttt'>basic_filebuf</span> constructors <a class='abbr_ref' href='filebuf.cons'>[filebuf.cons]</a></h4><p ><span class='indexparent'><a class='index' id='basic_filebuf,basic_filebuf'></a></span><code class='itemdecl'>
basic_filebuf();
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>basic_filebuf&lt;charT,traits&gt;</span>,
initializing the base class with
<span class='texttt'>basic_streambuf&lt;charT,traits&gt;()</span> (<a href='streambuf.cons'>[streambuf.cons]</a>).</p></div></div><div class='para' id='filebuf.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postcondition:</i>
<span class='texttt'>is_open() == false</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_filebuf,constructor'></a></span><code class='itemdecl'>
basic_filebuf(basic_filebuf&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs from the rvalue <span class='texttt'>rhs</span>. It
is <span class='indexparent'><a class='index' id='whether_sequence_pointers_are_copied_by_basic_filebuf_move_constructor'></a></span>implementation-defined whether the sequence pointers in <span class='texttt'>*this</span>
(<span class='texttt'>eback()</span>, <span class='texttt'>gptr()</span>, <span class='texttt'>egptr()</span>,
<span class='texttt'>pbase()</span>, <span class='texttt'>pptr()</span>, <span class='texttt'>epptr()</span>) obtain
the values which <span class='texttt'>rhs</span> had. Whether they do or not, <span class='texttt'>*this</span>
and <span class='texttt'>rhs</span> reference separate buffers (if any at all) after the
construction. Additionally <span class='texttt'>*this</span> references the file
which <span class='texttt'>rhs</span> did before the construction, and
<span class='texttt'>rhs</span> references no file after the construction. The
openmode, locale and any other state of <span class='texttt'>rhs</span> is also
copied.</p></div></div><div class='para' id='filebuf.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.cons-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> Let <span class='texttt'>rhs_p</span> refer to the state of
<span class='texttt'>rhs</span> just prior to this construction and let <span class='texttt'>rhs_a</span>
refer to the state of <span class='texttt'>rhs</span> just after this construction.</p><ul ><li ><p ><span class='texttt'>is_open() == rhs_p.is_open()</span>
</p></li><li ><p ><span class='texttt'>rhs_a.is_open() == false</span>
</p></li><li ><p ><span class='texttt'>gptr() - eback() == rhs_p.gptr() - rhs_p.eback()</span>
</p></li><li ><p ><span class='texttt'>egptr() - eback() == rhs_p.egptr() - rhs_p.eback()</span>
</p></li><li ><p ><span class='texttt'>pptr() - pbase() == rhs_p.pptr() - rhs_p.pbase()</span>
</p></li><li ><p ><span class='texttt'>epptr() - pbase() == rhs_p.epptr() - rhs_p.pbase()</span>
</p></li><li ><p ><span class='texttt'>if (eback()) eback() != rhs_a.eback()</span>
</p></li><li ><p ><span class='texttt'>if (gptr()) gptr() != rhs_a.gptr()</span>
</p></li><li ><p ><span class='texttt'>if (egptr()) egptr() != rhs_a.egptr()</span>
</p></li><li ><p ><span class='texttt'>if (pbase()) pbase() != rhs_a.pbase()</span>
</p></li><li ><p ><span class='texttt'>if (pptr()) pptr() != rhs_a.pptr()</span>
</p></li><li ><p ><span class='texttt'>if (epptr()) epptr() != rhs_a.epptr()</span>
</p></li></ul></div></div><p ><span class='indexparent'><a class='index' id='basic_filebuf,destructor'></a></span><code class='itemdecl'>
virtual ~basic_filebuf();
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Destroys an object of class
<span class='texttt'>basic_filebuf&lt;charT,traits&gt;</span>.
Calls
<span class='texttt'>close()</span>.
If an exception occurs during the destruction of the object, including the call to <span class='texttt'>close()</span>, the exception is caught but not rethrown (see <a href='res.on.exception.handling'>[res.on.exception.handling]</a>).
</p></div></div></div><div id='filebuf.assign'><h4 ><a class='secnum' href='#filebuf.assign' style='min-width:118pt'>27.9.1.3</a> Assign and swap <a class='abbr_ref' href='filebuf.assign'>[filebuf.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,basic_filebuf'></a></span><span class='indexparent'><a class='index' id='basic_filebuf,operator='></a></span><code class='itemdecl'>
basic_filebuf&amp; operator=(basic_filebuf&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Calls <span class='texttt'>this-&gt;close()</span> then move assigns from <span class='texttt'>rhs</span>. After the
move assignment <span class='texttt'>*this</span> has the observable state it would have had if it
had been move constructed from <span class='texttt'>rhs</span> (see <a href='filebuf.cons'>[filebuf.cons]</a>).</p></div></div><div class='para' id='filebuf.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,basic_filebuf'></a></span><span class='indexparent'><a class='index' id='basic_filebuf,swap'></a></span><code class='itemdecl'>
void swap(basic_filebuf&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.assign-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Exchanges the state of <span class='texttt'>*this</span>
and <span class='texttt'>rhs</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,basic_filebuf'></a></span><span class='indexparent'><a class='index' id='basic_filebuf,swap'></a></span><code class='itemdecl'>
template &lt;class charT, class traits&gt;
void swap(basic_filebuf&lt;charT, traits&gt;&amp; x,
          basic_filebuf&lt;charT, traits&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.assign-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>x.swap(y)</span>.
</p></div></div></div><div id='filebuf.members'><h4 ><a class='secnum' href='#filebuf.members' style='min-width:118pt'>27.9.1.4</a> Member functions <a class='abbr_ref' href='filebuf.members'>[filebuf.members]</a></h4><p ><span class='indexparent'><a class='index' id='is_open,basic_filebuf'></a></span><code class='itemdecl'>
bool is_open() const;
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.members-1'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>
if a previous call to
<span class='texttt'>open</span>
succeeded (returned a non-null value) and there has been no intervening
call to close.
</p></div></div><p ><span class='indexparent'><a class='index' id='open,basic_filebuf'></a></span><code class='itemdecl'>
basic_filebuf&lt;charT,traits&gt;* open(const char* s,
    ios_base::openmode mode);
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.members-2'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.members-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
If
<span class='texttt'>is_open() != false</span>,
returns a null pointer.
Otherwise,
initializes the
<span class='texttt'>filebuf</span>
as required.
It then opens a file, if possible, whose name is the
<span class='textsc'>ntbs</span> <span class='texttt'>s</span>
(as if by calling
<span class='texttt'>std::fopen(s,modstr)</span>).
<span class='indexparent'><a class='index' id='NTBS'></a></span><span class='indexparent'><a class='index' id='fopen'></a></span>The <span class='textsc'>ntbs</span> <span class='texttt'>modstr</span> is determined from
<span class='texttt'>mode &amp; ~ios_base::ate</span>
as indicated in Table <a href='#tab:iostreams.file.open.modes'>[tab:iostreams.file.open.modes]</a>.
If <span class='texttt'>mode</span> is not some combination of flags shown in the table then
the open fails.</p><div class='numberedTable' id='tab:iostreams.file.open.modes'>Table <a href='#tab:iostreams.file.open.modes'>132</a> — File open modes<br><table ><tr class='rowsep'><td colspan='5' class='center'><span class='texttt'>ios_base</span> flag combination</td><td class='left'> <span class='texttt'>stdio</span> equivalent </td></tr><tr ><td class='center'>
<span class='texttt'>binary</span>  </td><td class='center'> <span class='texttt'>in</span>  </td><td class='center'> <span class='texttt'>out</span> </td><td class='center'> <span class='texttt'>trunc</span> </td><td class='center'> <span class='texttt'>app</span> </td><td class='left'>     </td></tr><tr class='capsep'><td class='center'> 
    </td><td class='center'>   </td><td class='center'> + </td><td class='center'>   </td><td class='center'>   </td><td class='left'> <span class='texttt'>"w"</span>   </td></tr><tr class='rowsep'><td class='center'> 
    </td><td class='center'>   </td><td class='center'> + </td><td class='center'>   </td><td class='center'> + </td><td class='left'> <span class='texttt'>"a"</span>   </td></tr><tr class='rowsep'><td class='center'> 
    </td><td class='center'>   </td><td class='center'>   </td><td class='center'>   </td><td class='center'> + </td><td class='left'> <span class='texttt'>"a"</span>   </td></tr><tr class='rowsep'><td class='center'> 
    </td><td class='center'>   </td><td class='center'> + </td><td class='center'> + </td><td class='center'>   </td><td class='left'> <span class='texttt'>"w"</span>   </td></tr><tr class='rowsep'><td class='center'> 
    </td><td class='center'> + </td><td class='center'>   </td><td class='center'>   </td><td class='center'>   </td><td class='left'> <span class='texttt'>"r"</span>   </td></tr><tr class='rowsep'><td class='center'> 
    </td><td class='center'> + </td><td class='center'> + </td><td class='center'>   </td><td class='center'>   </td><td class='left'> <span class='texttt'>"r+"</span>  </td></tr><tr class='rowsep'><td class='center'> 
    </td><td class='center'> + </td><td class='center'> + </td><td class='center'> + </td><td class='center'>   </td><td class='left'> <span class='texttt'>"w+"</span>  </td></tr><tr class='rowsep'><td class='center'> 
    </td><td class='center'> + </td><td class='center'> + </td><td class='center'>   </td><td class='center'> + </td><td class='left'> <span class='texttt'>"a+"</span>  </td></tr><tr class='rowsep'><td class='center'> 
    </td><td class='center'> + </td><td class='center'>   </td><td class='center'>   </td><td class='center'> + </td><td class='left'> <span class='texttt'>"a+"</span>  </td></tr><tr class='capsep'><td class='center'> 
  + </td><td class='center'>   </td><td class='center'> + </td><td class='center'>   </td><td class='center'>   </td><td class='left'> <span class='texttt'>"wb"</span>  </td></tr><tr class='rowsep'><td class='center'> 
  + </td><td class='center'>   </td><td class='center'> + </td><td class='center'>   </td><td class='center'> + </td><td class='left'> <span class='texttt'>"ab"</span>  </td></tr><tr class='rowsep'><td class='center'> 
  + </td><td class='center'>   </td><td class='center'>   </td><td class='center'>   </td><td class='center'> + </td><td class='left'> <span class='texttt'>"ab"</span>  </td></tr><tr class='rowsep'><td class='center'> 
  + </td><td class='center'>   </td><td class='center'> + </td><td class='center'> + </td><td class='center'>   </td><td class='left'> <span class='texttt'>"wb"</span>  </td></tr><tr class='rowsep'><td class='center'> 
  + </td><td class='center'> + </td><td class='center'>   </td><td class='center'>   </td><td class='center'>   </td><td class='left'> <span class='texttt'>"rb"</span>  </td></tr><tr class='rowsep'><td class='center'> 
  + </td><td class='center'> + </td><td class='center'> + </td><td class='center'>   </td><td class='center'>   </td><td class='left'> <span class='texttt'>"r+b"</span> </td></tr><tr class='rowsep'><td class='center'> 
  + </td><td class='center'> + </td><td class='center'> + </td><td class='center'> + </td><td class='center'>   </td><td class='left'> <span class='texttt'>"w+b"</span> </td></tr><tr class='rowsep'><td class='center'> 
  + </td><td class='center'> + </td><td class='center'> + </td><td class='center'>   </td><td class='center'> + </td><td class='left'> <span class='texttt'>"a+b"</span> </td></tr><tr class='rowsep'><td class='center'> 
  + </td><td class='center'> + </td><td class='center'>   </td><td class='center'>   </td><td class='center'> + </td><td class='left'> <span class='texttt'>"a+b"</span> </td></tr></table></div></div></div><div class='para' id='filebuf.members-3'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.members-3'>3</a></div><div class='itemdescr'><p >If the open operation succeeds and
<span class='texttt'>(mode &amp; ios_base::ate) != 0</span>,
positions the file to the end
(as if by calling
<span class='texttt'>std::fseek(file,0,SEEK_END)</span>).<a class='footnotenum' href='#footnote-334'>334</a></p></div></div><div class='para' id='filebuf.members-4'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.members-4'>4</a></div><div class='itemdescr'><p >If the repositioning operation fails, calls
<span class='texttt'>close()</span>
and returns a null pointer to indicate failure.</p></div></div><div class='para' id='filebuf.members-5'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.members-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>this</span>
if successful, a null pointer otherwise.
</p></div></div><p ><span class='indexparent'><a class='index' id='open,basic_filebuf'></a></span><code class='itemdecl'>
basic_filebuf&lt;charT,traits&gt;* open(const string&amp; s,
    ios_base::openmode mode);
</code></p><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>open(s.c_str(), mode);</span>
</p></div><p ><span class='indexparent'><a class='index' id='close,basic_filebuf'></a></span><code class='itemdecl'>
basic_filebuf&lt;charT,traits&gt;* close();
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.members-6'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.members-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
If
<span class='texttt'>is_open() == false</span>,
returns a null pointer.
If a put area exists, calls
<span class='texttt'>overflow(traits::<span class='discretionary'></span>eof())</span>
to flush characters.
If the last virtual member function called on
<span class='texttt'>*this</span>
(between
<span class='texttt'>underflow</span>,
<span class='texttt'>overflow</span>,
<span class='texttt'>seekoff</span>,
and
<span class='texttt'>seekpos</span>)
was
<span class='texttt'>overflow</span>
then calls
<span class='texttt'>a_codecvt.unshift</span>
(possibly several times) to determine a termination sequence, inserts those
characters and calls
<span class='texttt'>overflow(traits::<span class='discretionary'></span>eof())</span>
again.
Finally, regardless of whether any of the preceding calls fails or throws an
exception, the function closes the file
(as if by calling
<span class='indexparent'><a class='index' id='fclose'></a></span><span class='texttt'>std::fclose(file)</span>).<a class='footnotenum' href='#footnote-335'>335</a>
If any of the calls made by the function, including <span class='texttt'>std::fclose</span>, fails,
<span class='texttt'>close</span> fails by returning a null pointer. If one of these calls throws an
exception, the exception is caught and rethrown after closing the file.</p></div></div><div class='para' id='filebuf.members-7'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.members-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>this</span>
on success, a null pointer otherwise.</p></div></div><div class='para' id='filebuf.members-8'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.members-8'>8</a></div><div class='itemdescr'><p ><i>Postcondition:</i>
<span class='texttt'>is_open() == false</span>.
</p></div></div><div class='footnote' id='footnote-333'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-333'>333)</a></div><p >The macro
<span class='texttt'>SEEK_END</span>
is defined, and the function signatures
<span class='indexparent'><a class='index' id='fopen'></a></span><span class='texttt'>fopen(const char*, const char*)</span>
and
<span class='texttt'>fseek(FILE*, long, int)</span>
<span class='indexparent'><a class='index' id='fseek'></a></span>are declared, in
<span class='indexparent'><a class='index' id='cstdio'></a></span><span class='texttt'>&lt;cstdio&gt;</span> (<a href='c.files'>[c.files]</a>).</p></div><div class='footnote' id='footnote-334'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-334'>334)</a></div><p >The function signature
<span class='texttt'>fclose(FILE*)</span>
is declared in
<span class='texttt'>&lt;cstdio&gt;</span>
<span class='indexparent'><a class='index' id='cstdio'></a></span><span class='indexparent'><a class='index' id='fclose'></a></span>(<a href='c.files'>[c.files]</a>).</p></div></div><div id='filebuf.virtuals'><h4 ><a class='secnum' href='#filebuf.virtuals' style='min-width:118pt'>27.9.1.5</a> Overridden virtual functions <a class='abbr_ref' href='filebuf.virtuals'>[filebuf.virtuals]</a></h4><p ><span class='indexparent'><a class='index' id='showmanyc,basic_filebuf'></a></span><code class='itemdecl'>
streamsize showmanyc();
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.virtuals-1'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Behaves the same as
<span class='texttt'>basic_streambuf::showmanyc()</span> (<a href='streambuf.virtuals'>[streambuf.virtuals]</a>).
<span class='indexparent'><a class='index' id='showmanyc,basic_streambuf'></a></span>
</p></div></div><div class='para' id='filebuf.virtuals-2'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i>
An
implementation might well provide an overriding definition for this function
signature if it can determine that more characters can be read from the input
sequence.
</p></div></div><p ><span class='indexparent'><a class='index' id='underflow,basic_filebuf'></a></span><code class='itemdecl'>
int_type underflow();
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.virtuals-3'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Behaves according to the description of
<span class='texttt'>basic_streambuf&lt;charT,traits&gt;::underflow()</span>,
with the specialization that a sequence of characters is read from the input
sequence as if by reading from the associated file
into an internal buffer (
<span class='texttt'>extern_buf</span>)
and then as if by doing</p><pre class='codeblock'>
char   extern_buf[XSIZE];
char*  extern_end;
charT  intern_buf[ISIZE];
charT* intern_end;
codecvt_base::result r =
  a_codecvt.in(state, extern_buf, extern_buf+XSIZE, extern_end,
               intern_buf, intern_buf+ISIZE, intern_end);
</pre><p >This shall be done in such a way that the class can recover the
position
(<span class='texttt'>fpos_t</span>)
corresponding to each character between
<span class='texttt'>intern_buf</span>
and
<span class='texttt'>intern_end</span>.
If the value of
<span class='texttt'>r</span>
indicates that
<span class='texttt'>a_codecvt.in()</span>
ran out of space in
<span class='texttt'>intern_buf</span>,
retry with a larger
<span class='texttt'>intern_buf</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='uflow,basic_filebuf'></a></span><code class='itemdecl'>
int_type uflow();
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.virtuals-4'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
Behaves according to the description of
<span class='texttt'>basic_streambuf&lt;charT,traits&gt;::uflow()</span>,
with the specialization that a sequence of characters is read from the input
with the same method as used by
<span class='texttt'>underflow</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='pbackfail,basic_filebuf'></a></span><code class='itemdecl'>
int_type pbackfail(int_type c = traits::eof());
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.virtuals-5'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Puts back the character designated by <span class='texttt'>c</span> to the input
sequence, if possible, in one of three ways:
</p><ul ><li ><p >If
<span class='texttt'>traits::eq_int_type(c,traits::eof())</span>
returns
<span class='texttt'>false</span>
and
if the function makes a putback position available
and if
<span class='texttt'>traits::eq(to_char_type(c),gptr()[-1])</span>
returns
<span class='texttt'>true</span>,
decrements the next pointer for the input sequence,
<span class='texttt'>gptr()</span>.</p><p >Returns:
<span class='texttt'>c</span>.</p></li><li ><p >If
<span class='texttt'>traits::eq_int_type(c,traits::eof())</span>
returns
<span class='texttt'>false</span>
and
if the function makes a putback position available
and if the function is permitted to assign to the putback position,
decrements the next pointer for the input sequence,
and stores <span class='texttt'>c</span> there.</p><p >Returns:
<span class='texttt'>c</span>.</p></li><li ><p >If
<span class='texttt'>traits::eq_int_type(c,traits::eof())</span>
returns
<span class='texttt'>true</span>,
and if either the input sequence has a putback position available or
the function makes a putback position available,
decrements the next pointer for the input sequence,
<span class='texttt'>gptr()</span>.</p><p >Returns:
<span class='texttt'>traits::not_eof(c)</span>.
</p></li></ul></div></div><div class='para' id='filebuf.virtuals-6'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>traits::eof()</span>
to indicate failure.</p></div></div><div class='para' id='filebuf.virtuals-7'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i>
If
<span class='texttt'>is_open() == false</span>,
the function always fails.</p></div></div><div class='para' id='filebuf.virtuals-8'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-8'>8</a></div><div class='itemdescr'><p >The function does not put back a character directly to the input sequence.</p></div></div><div class='para' id='filebuf.virtuals-9'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-9'>9</a></div><div class='itemdescr'><p >If the function can succeed in more than one of these ways, it is
unspecified which way is chosen.
The function can alter the number of putback positions available as a result of any call.
</p></div></div><p ><span class='indexparent'><a class='index' id='overflow,basic_filebuf'></a></span><code class='itemdecl'>
int_type overflow(int_type c = traits::eof());
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.virtuals-10'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
Behaves according to the description of
<span class='texttt'>basic_streambuf&lt;charT,traits&gt;::overflow(c)</span>,
except that the behavior of “consuming characters” is performed by first
converting as if by:</p><pre class='codeblock'>
charT* b = pbase();
charT* p = pptr();
charT* end;
char   xbuf[XSIZE];
char*  xbuf_end;
codecvt_base::result r =
  a_codecvt.out(state, b, p, end, xbuf, xbuf+XSIZE, xbuf_end);
</pre><p >and then
</p><ul ><li ><p >If <span class='texttt'>r == codecvt_base::error</span> then fail.
</p></li><li ><p >If <span class='texttt'>r == codecvt_base::noconv</span> then output characters from
<span class='texttt'>b</span> up to (and not including) <span class='texttt'>p</span>.
</p></li><li ><p >If <span class='texttt'>r == codecvt_base::partial</span> then output to the file characters from
<span class='texttt'>xbuf</span> up to <span class='texttt'>xbuf_end</span>, and repeat using characters from
<span class='texttt'>end</span> to <span class='texttt'>p</span>. If output fails, fail (without repeating).
</p></li><li ><p >Otherwise output from <span class='texttt'>xbuf</span> to <span class='texttt'>xbuf_end</span>, and fail if output fails.
At this point if <span class='texttt'>b != p</span> and <span class='texttt'>b == end</span> (<span class='texttt'>xbuf</span> isn't large
enough) then increase <span class='texttt'>XSIZE</span> and repeat from the beginning.
</p></li></ul></div></div><div class='para' id='filebuf.virtuals-11'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>traits::not_eof(c)</span>
to indicate success, and
<span class='texttt'>traits::eof()</span>
to indicate failure.
If
<span class='texttt'>is_open() == false</span>,
the function always fails.
</p></div></div><p ><span class='indexparent'><a class='index' id='setbuf,basic_filebuf'></a></span><code class='itemdecl'>
basic_streambuf* setbuf(char_type* s, streamsize n);
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.virtuals-12'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i>
If
<span class='texttt'>setbuf(0,0)</span>
is called on a stream before any I/O has occurred on that stream, the
stream becomes unbuffered.
Otherwise the results are <span class='indexparent'><a class='index' id='effect_of_calling_basic_filebuf::setbuf_with_non-zero_arguments'></a></span>implementation-defined.
“Unbuffered” means that
<span class='texttt'>pbase()</span>
and
<span class='texttt'>pptr()</span>
always return null
and output to the file should appear as soon as possible.
</p></div></div><p ><span class='indexparent'><a class='index' id='seekoff,basic_filebuf'></a></span><code class='itemdecl'>
pos_type seekoff(off_type off, ios_base::seekdir way,
    ios_base::openmode which = ios_base::in | ios_base::out);
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.virtuals-13'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i>
Let
<span class='texttt'>width</span>
denote
<span class='texttt'>a_codecvt.encoding()</span>.
If
<span class='texttt'>is_open() == false</span>,
or
<span class='texttt'>off != 0 &amp;&amp; width &lt;= 0</span>,
then the positioning operation fails.
Otherwise, if
<span class='texttt'>way != basic_ios::cur</span>
or
<span class='texttt'>off != 0</span>,
and if the last operation was output,
then update the output sequence and write any unshift sequence.
Next, seek to the new position: if
<span class='texttt'>width &gt; 0</span>,
call
<span class='texttt'>std::fseek(file, width * off, whence)</span>,
otherwise call
<span class='texttt'>std::fseek(file, 0, whence)</span>.</p></div></div><div class='para' id='filebuf.virtuals-14'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-14'>14</a></div><div class='itemdescr'><p ><i>Remarks:</i>
“The last operation was output” means either
the last virtual operation was overflow or
the put buffer is non-empty.
“Write any unshift sequence” means,
if
<span class='texttt'>width</span>
if less than zero then call
<span class='texttt'>a_codecvt.unshift(state, xbuf, xbuf+XSIZE, xbuf_end)</span>
and output the resulting unshift sequence.
The function determines one of three values for the
argument <span class='texttt'>whence</span>, of type
<span class='texttt'>int</span>,
as indicated in Table <a href='#tab:iostreams.seekoff.effects'>[tab:iostreams.seekoff.effects]</a>.</p><div class='numberedTable' id='tab:iostreams.seekoff.effects'>Table <a href='#tab:iostreams.seekoff.effects'>133</a> — <span class='texttt'>seekoff</span> effects<br><table ><tr class='rowsep'><td colspan='1' class='center'><b><span class='texttt'>way</span> Value</b></td><td colspan='1' class='center'><b><span class='texttt'>stdio</span> Equivalent</b></td></tr><tr class='capsep'><td class='left'> 

<span class='texttt'>basic_ios::beg</span>  </td><td class='left'> <span class='texttt'>SEEK_SET</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>basic_ios::cur</span>  </td><td class='left'> <span class='texttt'>SEEK_CUR</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>basic_ios::end</span>  </td><td class='left'> <span class='texttt'>SEEK_END</span>  </td></tr></table></div></div></div><div class='para' id='filebuf.virtuals-15'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i>
A newly constructed
<span class='texttt'>pos_type</span>
object that stores the resultant
stream position, if possible.
If the positioning operation fails, or
if the object cannot represent the resultant stream position,
returns
<span class='texttt'>pos_type(off_type(-1))</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='seekpos,basic_filebuf'></a></span><code class='itemdecl'>
pos_type seekpos(pos_type sp,
    ios_base::openmode which = ios_base::in | ios_base::out);
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.virtuals-16'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-16'>16</a></div><div class='itemdescr'><p >Alters the file position, if possible, to correspond to the position
stored in <span class='texttt'>sp</span> (as described below).
Altering the file position performs as follows:
</p><ol ><li ><p >if
<span class='texttt'>(om &amp; ios_base::out) != 0</span>,
then update the output sequence and
write any unshift sequence;
</p></li><li ><p >set the file position to <span class='texttt'>sp</span>;
</p></li><li ><p >if
<span class='texttt'>(om &amp; ios_base::in) != 0</span>,
then update the input sequence;
</p></li></ol><p >where <span class='texttt'>om</span> is the open mode passed to the last call to
<span class='texttt'>open()</span>.
The operation fails if
<span class='texttt'>is_open()</span>
returns false.</p></div></div><div class='para' id='filebuf.virtuals-17'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-17'>17</a></div><div class='itemdescr'><p >If <span class='texttt'>sp</span> is an invalid stream position, or if the function positions
neither sequence, the positioning operation fails.
If <span class='texttt'>sp</span> has not been obtained by a previous successful call to one of
the positioning functions
(<span class='texttt'>seekoff</span>
or
<span class='texttt'>seekpos</span>)
on the same file the effects are undefined.</p></div></div><div class='para' id='filebuf.virtuals-18'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-18'>18</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>sp</span>
on success.
Otherwise returns
<span class='texttt'>pos_type(off_type(-1))</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='sync,basic_filebuf'></a></span><code class='itemdecl'>
int sync();
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.virtuals-19'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i>
If a put area exists, calls
<span class='texttt'>filebuf::overflow</span>
to write the characters to the file.
If a get area exists, the effect is <span class='indexparent'><a class='index' id='effect_of_calling_basic_filebuf::sync_when_a_get_area_exists'></a></span>implementation-defined.
</p></div></div><p ><span class='indexparent'><a class='index' id='imbue,basic_filebuf'></a></span><code class='itemdecl'>
void imbue(const locale&amp; loc);
</code></p><div class='itemdescr'></div><div class='para' id='filebuf.virtuals-20'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-20'>20</a></div><div class='itemdescr'><p ><i>Requires:</i>
If the file is not positioned at its beginning and the encoding of the current
locale as determined by
<span class='texttt'>a_codecvt.encoding()</span>
is state-dependent (<a href='locale.codecvt.virtuals'>[locale.codecvt.virtuals]</a>)
then that facet is the same as
the corresponding facet of <span class='texttt'>loc</span>.</p></div></div><div class='para' id='filebuf.virtuals-21'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-21'>21</a></div><div class='itemdescr'><p ><i>Effects:</i>
Causes characters inserted or extracted after this call
to be converted according to <span class='texttt'>loc</span> until another call of
<span class='texttt'>imbue</span>.</p></div></div><div class='para' id='filebuf.virtuals-22'><div class='marginalizedparent'><a class='marginalized' href='#filebuf.virtuals-22'>22</a></div><div class='itemdescr'><p ><i>Remark:</i>
This may require reconversion of previously converted characters.
This in turn may require the implementation to be able to reconstruct
the original contents of the file.
</p></div></div></div><div id='ifstream'><h4 ><a class='secnum' href='#ifstream' style='min-width:118pt'>27.9.1.6</a> Class template <span class='texttt'>basic_ifstream</span> <a class='abbr_ref' href='ifstream'>[ifstream]</a></h4><p ><span class='indexparent'><a class='index' id='basic_ifstream'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class basic_ifstream : public basic_istream&lt;charT,traits&gt; {
  public:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;

    <span class='comment'>// <a href='ifstream.cons'>[ifstream.cons]</a> Constructors:
</span>    basic_ifstream();
    explicit basic_ifstream(const char* s,
        ios_base::openmode mode = ios_base::in);
    explicit basic_ifstream(const string&amp; s,
        ios_base::openmode mode = ios_base::in);
    basic_ifstream(const basic_ifstream&amp; rhs) = delete;
    basic_ifstream(basic_ifstream&amp;&amp; rhs);

    <span class='comment'>// <a href='ifstream.assign'>[ifstream.assign]</a> Assign/swap:
</span>    basic_ifstream&amp; operator=(const basic_ifstream&amp; rhs) = delete;
    basic_ifstream&amp; operator=(basic_ifstream&amp;&amp; rhs);
    void swap(basic_ifstream&amp; rhs);

    <span class='comment'>// <a href='ifstream.members'>[ifstream.members]</a> Members:
</span>    basic_filebuf&lt;charT,traits&gt;* rdbuf() const;

    bool is_open() const;
    void open(const char* s, ios_base::openmode mode = ios_base::in);
    void open(const string&amp; s, ios_base::openmode mode = ios_base::in);
    void close();
  private:
    basic_filebuf&lt;charT,traits&gt; sb; <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class charT, class traits&gt;
  void swap(basic_ifstream&lt;charT, traits&gt;&amp; x,
            basic_ifstream&lt;charT, traits&gt;&amp; y);
}
</pre><div class='para' id='ifstream-1'><div class='marginalizedparent'><a class='marginalized' href='#ifstream-1'>1</a></div><p >The class
<span class='texttt'>basic_ifstream&lt;charT, traits&gt;</span>
supports reading from named files.
It uses a
<span class='texttt'>basic_filebuf&lt;<span class='discretionary'></span>charT, traits&gt;</span>
object to control the associated
sequence.
For the sake of exposition, the maintained data is presented here as:</p><ul ><li ><p ><span class='texttt'>sb</span>, the <span class='texttt'>filebuf</span> object.
</p></li></ul></div></div><div id='ifstream.cons'><h4 ><a class='secnum' href='#ifstream.cons' style='min-width:118pt'>27.9.1.7</a> <span class='texttt'>basic_ifstream</span> constructors <a class='abbr_ref' href='ifstream.cons'>[ifstream.cons]</a></h4><p ><span class='indexparent'><a class='index' id='basic_ifstream,basic_ifstream'></a></span><code class='itemdecl'>
basic_ifstream();
</code></p><div class='itemdescr'></div><div class='para' id='ifstream.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#ifstream.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>basic_ifstream&lt;charT,traits&gt;</span>,
initializing the base class with
<span class='texttt'>basic_istream(&amp;sb)</span>
and initializing <span class='texttt'>sb</span> with
<span class='texttt'>basic_filebuf&lt;charT,traits&gt;())</span> (<a href='istream.cons'>[istream.cons]</a>,
<a href='filebuf.cons'>[filebuf.cons]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_ifstream,constructor'></a></span><code class='itemdecl'>
explicit basic_ifstream(const char* s,
    ios_base::openmode mode = ios_base::in);
</code></p><div class='itemdescr'></div><div class='para' id='ifstream.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#ifstream.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>basic_ifstream</span>,
initializing the base class with
<span class='texttt'>basic_istream(&amp;sb)</span>
and initializing <span class='texttt'>sb</span> with
<span class='texttt'>basic_filebuf&lt;charT, traits&gt;())</span> (<a href='istream.cons'>[istream.cons]</a>,
<a href='filebuf.cons'>[filebuf.cons]</a>),
then calls
<span class='texttt'>rdbuf()-&gt;open(s, mode | ios_base::in)</span>.
If that function returns a null pointer, calls
<span class='texttt'>setstate(failbit)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_ifstream,constructor'></a></span><code class='itemdecl'>
explicit basic_ifstream(const string&amp; s,
    ios_base::openmode mode = ios_base::in);
</code></p><div class='itemdescr'></div><div class='para' id='ifstream.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#ifstream.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> the same as <span class='texttt'>basic_ifstream(s.c_str(), mode)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_ifstream,constructor'></a></span><code class='itemdecl'>
basic_ifstream(basic_ifstream&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='ifstream.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#ifstream.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs from the rvalue <span class='texttt'>rhs</span>. This
is accomplished by move constructing the base class, and the contained
<span class='texttt'>basic_filebuf</span>. Next
<span class='texttt'>basic_istream&lt;charT,traits&gt;::set_rdbuf(&amp;sb)</span> is called to install
the contained <span class='texttt'>basic_filebuf</span>.
</p></div></div></div><div id='ifstream.assign'><h4 ><a class='secnum' href='#ifstream.assign' style='min-width:118pt'>27.9.1.8</a> Assign and swap <a class='abbr_ref' href='ifstream.assign'>[ifstream.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,basic_ifstream'></a></span><span class='indexparent'><a class='index' id='basic_ifstream,operator='></a></span><code class='itemdecl'>
basic_ifstream&amp; operator=(basic_ifstream&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='ifstream.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#ifstream.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Move assigns the base and members of <span class='texttt'>*this</span> from the base and corresponding
members of <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='ifstream.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#ifstream.assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,basic_ifstream'></a></span><span class='indexparent'><a class='index' id='basic_ifstream,swap'></a></span><code class='itemdecl'>
void swap(basic_ifstream&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='ifstream.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#ifstream.assign-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Exchanges the state of <span class='texttt'>*this</span>
and <span class='texttt'>rhs</span> by calling
<span class='texttt'>basic_istream&lt;charT,traits&gt;::swap(rhs)</span> and
<span class='texttt'>sb.swap(rhs.sb)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,basic_ifstream'></a></span><span class='indexparent'><a class='index' id='basic_ifstream,swap'></a></span><code class='itemdecl'>
template &lt;class charT, class traits&gt;
void swap(basic_ifstream&lt;charT, traits&gt;&amp; x,
          basic_ifstream&lt;charT, traits&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='ifstream.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#ifstream.assign-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>x.swap(y)</span>.
</p></div></div></div><div id='ifstream.members'><h4 ><a class='secnum' href='#ifstream.members' style='min-width:118pt'>27.9.1.9</a> Member functions <a class='abbr_ref' href='ifstream.members'>[ifstream.members]</a></h4><p ><span class='indexparent'><a class='index' id='rdbuf,basic_ifstream'></a></span><code class='itemdecl'>
basic_filebuf&lt;charT,traits&gt;* rdbuf() const;
</code></p><div class='itemdescr'></div><div class='para' id='ifstream.members-1'><div class='marginalizedparent'><a class='marginalized' href='#ifstream.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>const_cast&lt;basic_filebuf&lt;charT,traits&gt;*&gt;(&amp;sb)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_open,basic_ifstream'></a></span><code class='itemdecl'>
bool is_open() const;
</code></p><div class='itemdescr'></div><div class='para' id='ifstream.members-2'><div class='marginalizedparent'><a class='marginalized' href='#ifstream.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>rdbuf()-&gt;is_open()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='open,basic_ifstream'></a></span><code class='itemdecl'>
void open(const char* s, ios_base::openmode mode = ios_base::in);
</code></p><div class='itemdescr'></div><div class='para' id='ifstream.members-3'><div class='marginalizedparent'><a class='marginalized' href='#ifstream.members-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Calls
<span class='texttt'>rdbuf()-&gt;open(s, mode | ios_base::in)</span>.
If that function does not return a null pointer
calls <span class='texttt'>clear()</span>,
otherwise calls
<span class='texttt'>setstate(<span class='discretionary'></span>failbit)</span>
(which may throw
<span class='texttt'>ios_base::failure</span> (<a href='iostate.flags'>[iostate.flags]</a>)).
</p></div></div><p ><span class='indexparent'><a class='index' id='open,basic_ifstream'></a></span><code class='itemdecl'>
void open(const string&amp; s, ios_base::openmode mode = ios_base::in);
</code></p><div class='itemdescr'></div><div class='para' id='ifstream.members-4'><div class='marginalizedparent'><a class='marginalized' href='#ifstream.members-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>  calls <span class='texttt'>open(s.c_str(), mode)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='close,basic_ifstream'></a></span><code class='itemdecl'>
void close();
</code></p><div class='itemdescr'></div><div class='para' id='ifstream.members-5'><div class='marginalizedparent'><a class='marginalized' href='#ifstream.members-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Calls
<span class='texttt'>rdbuf()-&gt;close()</span>
and, if that function returns
a null pointer,
calls
<span class='texttt'>setstate(failbit)</span>
(which may throw
<span class='texttt'>ios_base::failure</span> (<a href='iostate.flags'>[iostate.flags]</a>)).
</p></div></div></div><div id='ofstream'><h4 ><a class='secnum' href='#ofstream' style='min-width:118pt'>27.9.1.10</a> Class template <span class='texttt'>basic_ofstream</span> <a class='abbr_ref' href='ofstream'>[ofstream]</a></h4><p ><span class='indexparent'><a class='index' id='basic_ofstream'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class basic_ofstream : public basic_ostream&lt;charT,traits&gt; {
  public:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;

    <span class='comment'>// <a href='ofstream.cons'>[ofstream.cons]</a> Constructors:
</span>    basic_ofstream();
    explicit basic_ofstream(const char* s,
        ios_base::openmode mode = ios_base::out);
    explicit basic_ofstream(const string&amp; s,
        ios_base::openmode mode = ios_base::out);
    basic_ofstream(const basic_ofstream&amp; rhs) = delete;
    basic_ofstream(basic_ofstream&amp;&amp; rhs);

    <span class='comment'>// <a href='ofstream.assign'>[ofstream.assign]</a> Assign/swap:
</span>    basic_ofstream&amp; operator=(const basic_ofstream&amp; rhs) = delete;
    basic_ofstream&amp; operator=(basic_ofstream&amp;&amp; rhs);
    void swap(basic_ofstream&amp; rhs);

    <span class='comment'>// <a href='ofstream.members'>[ofstream.members]</a> Members:
</span>    basic_filebuf&lt;charT,traits&gt;* rdbuf() const;

    bool is_open() const;
    void open(const char* s, ios_base::openmode mode = ios_base::out);
    void open(const string&amp; s, ios_base::openmode mode = ios_base::out);
    void close();
  private:
    basic_filebuf&lt;charT,traits&gt; sb; <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class charT, class traits&gt;
  void swap(basic_ofstream&lt;charT, traits&gt;&amp; x,
            basic_ofstream&lt;charT, traits&gt;&amp; y);
}
</pre><div class='para' id='ofstream-1'><div class='marginalizedparent'><a class='marginalized' href='#ofstream-1'>1</a></div><p >The class
<span class='texttt'>basic_ofstream&lt;charT, traits&gt;</span>
supports writing to named files.
It uses a
<span class='texttt'>basic_filebuf&lt;<span class='discretionary'></span>charT, traits&gt;</span>
object to control the associated
sequence.
For the sake of exposition, the maintained data is presented here as:
</p><ul ><li ><p ><span class='texttt'>sb</span>, the <span class='texttt'>filebuf</span> object.
</p></li></ul></div></div><div id='ofstream.cons'><h4 ><a class='secnum' href='#ofstream.cons' style='min-width:118pt'>27.9.1.11</a> <span class='texttt'>basic_ofstream</span> constructors <a class='abbr_ref' href='ofstream.cons'>[ofstream.cons]</a></h4><p ><span class='indexparent'><a class='index' id='basic_ofstream,basic_ofstream'></a></span><code class='itemdecl'>
basic_ofstream();
</code></p><div class='itemdescr'></div><div class='para' id='ofstream.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#ofstream.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>basic_ofstream&lt;charT,traits&gt;</span>,
initializing the base class with
<span class='texttt'>basic_ostream(&amp;sb)</span>
and initializing <span class='texttt'>sb</span> with
<span class='texttt'>basic_filebuf&lt;charT,traits&gt;())</span> (<a href='ostream.cons'>[ostream.cons]</a>,
<a href='filebuf.cons'>[filebuf.cons]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_ofstream,constructor'></a></span><code class='itemdecl'>
explicit basic_ofstream(const char* s,
    ios_base::openmode mode = ios_base::out);
</code></p><div class='itemdescr'></div><div class='para' id='ofstream.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#ofstream.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>basic_ofstream&lt;charT,traits&gt;</span>,
initializing the base class with
<span class='texttt'>basic_ostream(&amp;sb)</span>
and initializing <span class='texttt'>sb</span> with
<span class='texttt'>basic_filebuf&lt;charT,traits&gt;())</span> (<a href='ostream.cons'>[ostream.cons]</a>,
<a href='filebuf.cons'>[filebuf.cons]</a>),
then calls
<span class='texttt'>rdbuf()-&gt;open(s, mode|ios_base::out)</span>.
If that function returns a null pointer, calls
<span class='texttt'>setstate(<span class='discretionary'></span>failbit)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_ofstream,constructor'></a></span><code class='itemdecl'>
explicit basic_ofstream(const string&amp; s,
    ios_base::openmode mode = ios_base::out);
</code></p><div class='itemdescr'></div><div class='para' id='ofstream.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#ofstream.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> the same as <span class='texttt'>basic_ofstream(s.c_str(), mode);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_ofstream,constructor'></a></span><code class='itemdecl'>
basic_ofstream(basic_ofstream&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='ofstream.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#ofstream.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs from the rvalue <span class='texttt'>rhs</span>. This
is accomplished by move constructing the base class, and the contained
<span class='texttt'>basic_filebuf</span>. Next
<span class='texttt'>basic_ostream&lt;charT,traits&gt;::set_rdbuf(&amp;sb)</span> is called to install
the contained <span class='texttt'>basic_filebuf</span>.
</p></div></div></div><div id='ofstream.assign'><h4 ><a class='secnum' href='#ofstream.assign' style='min-width:118pt'>27.9.1.12</a> Assign and swap <a class='abbr_ref' href='ofstream.assign'>[ofstream.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,basic_ofstream'></a></span><span class='indexparent'><a class='index' id='basic_ofstream,operator='></a></span><code class='itemdecl'>
basic_ofstream&amp; operator=(basic_ofstream&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='ofstream.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#ofstream.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Move assigns the base and members of <span class='texttt'>*this</span> from the base and corresponding
members of <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='ofstream.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#ofstream.assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,basic_ofstream'></a></span><span class='indexparent'><a class='index' id='basic_ofstream,swap'></a></span><code class='itemdecl'>
void swap(basic_ofstream&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='ofstream.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#ofstream.assign-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Exchanges the state of <span class='texttt'>*this</span>
and <span class='texttt'>rhs</span> by calling
<span class='texttt'>basic_ostream&lt;charT,traits&gt;::swap(rhs)</span> and
<span class='texttt'>sb.swap(rhs.sb)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,basic_ofstream'></a></span><span class='indexparent'><a class='index' id='basic_ofstream,swap'></a></span><code class='itemdecl'>
template &lt;class charT, class traits&gt;
void swap(basic_ofstream&lt;charT, traits&gt;&amp; x,
          basic_ofstream&lt;charT, traits&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='ofstream.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#ofstream.assign-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>x.swap(y)</span>.
</p></div></div></div><div id='ofstream.members'><h4 ><a class='secnum' href='#ofstream.members' style='min-width:118pt'>27.9.1.13</a> Member functions <a class='abbr_ref' href='ofstream.members'>[ofstream.members]</a></h4><p ><span class='indexparent'><a class='index' id='rdbuf,basic_ofstream'></a></span><code class='itemdecl'>
basic_filebuf&lt;charT,traits&gt;* rdbuf() const;
</code></p><div class='itemdescr'></div><div class='para' id='ofstream.members-1'><div class='marginalizedparent'><a class='marginalized' href='#ofstream.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>const_cast&lt;basic_filebuf&lt;charT,traits&gt;*&gt;(&amp;sb)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_open,basic_ofstream'></a></span><code class='itemdecl'>
bool is_open() const;
</code></p><div class='itemdescr'></div><div class='para' id='ofstream.members-2'><div class='marginalizedparent'><a class='marginalized' href='#ofstream.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>rdbuf()-&gt;is_open()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='open,basic_ofstream'></a></span><code class='itemdecl'>
void open(const char* s, ios_base::openmode mode = ios_base::out);
</code></p><div class='itemdescr'></div><div class='para' id='ofstream.members-3'><div class='marginalizedparent'><a class='marginalized' href='#ofstream.members-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Calls
<span class='texttt'>rdbuf()-&gt;open(s, mode | ios_base::out)</span>.
If that function does not return a null pointer
calls <span class='texttt'>clear()</span>,
otherwise calls
<span class='texttt'>setstate(<span class='discretionary'></span>failbit)</span>
(which may throw
<span class='texttt'>ios_base::failure</span> (<a href='iostate.flags'>[iostate.flags]</a>)).
</p></div></div><p ><span class='indexparent'><a class='index' id='close,basic_ofstream'></a></span><code class='itemdecl'>
void close();
</code></p><div class='itemdescr'></div><div class='para' id='ofstream.members-4'><div class='marginalizedparent'><a class='marginalized' href='#ofstream.members-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
Calls
<span class='texttt'>rdbuf()-&gt;close()</span>
and, if that function fails (returns a null pointer), calls
<span class='texttt'>setstate(<span class='discretionary'></span>failbit)</span>
(which may throw
<span class='texttt'>ios_base::failure</span> (<a href='iostate.flags'>[iostate.flags]</a>)).
</p></div></div><p ><span class='indexparent'><a class='index' id='open,basic_ofstream'></a></span><code class='itemdecl'>
void open(const string&amp; s, ios_base::openmode mode = ios_base::out);
</code></p><div class='itemdescr'></div><div class='para' id='ofstream.members-5'><div class='marginalizedparent'><a class='marginalized' href='#ofstream.members-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> calls <span class='texttt'>open(s.c_str(), mode);</span>
</p></div></div></div><div id='fstream'><h4 ><a class='secnum' href='#fstream' style='min-width:118pt'>27.9.1.14</a> Class template <span class='texttt'>basic_fstream</span> <a class='abbr_ref' href='fstream'>[fstream]</a></h4><p ><span class='indexparent'><a class='index' id='basic_fstream'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT, class traits=char_traits&lt;charT&gt; &gt;
  class basic_fstream
    : public basic_iostream&lt;charT,traits&gt; {

  public:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;

    <span class='comment'>// constructors/destructor
</span>    basic_fstream();
    explicit basic_fstream(const char* s,
        ios_base::openmode mode = ios_base::in|ios_base::out);
    explicit basic_fstream(const string&amp; s,
        ios_base::openmode mode = ios_base::in|ios_base::out);
    basic_fstream(const basic_fstream&amp; rhs) = delete;
    basic_fstream(basic_fstream&amp;&amp; rhs);

    <span class='comment'>// <a href='fstream.assign'>[fstream.assign]</a> Assign/swap:
</span>    basic_fstream&amp; operator=(const basic_fstream&amp; rhs) = delete;
    basic_fstream&amp; operator=(basic_fstream&amp;&amp; rhs);
    void swap(basic_fstream&amp; rhs);

    <span class='comment'>// Members:
</span>    basic_filebuf&lt;charT,traits&gt;* rdbuf() const;
    bool is_open() const;
    void open(const char* s,
        ios_base::openmode mode = ios_base::in|ios_base::out);
    void open(const string&amp; s,
        ios_base::openmode mode = ios_base::in|ios_base::out);
    void close();

  private:
    basic_filebuf&lt;charT,traits&gt; sb; <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class charT, class traits&gt;
  void swap(basic_fstream&lt;charT, traits&gt;&amp; x,
            basic_fstream&lt;charT, traits&gt;&amp; y);
}
</pre><div class='para' id='fstream-1'><div class='marginalizedparent'><a class='marginalized' href='#fstream-1'>1</a></div><p >The
class template
<span class='texttt'>basic_fstream&lt;charT,traits&gt;</span>
supports reading and writing from named files.
It uses a
<span class='texttt'>basic_filebuf&lt;charT,traits&gt;</span>
object to control the associated sequences.
For the sake of exposition, the maintained data is presented here as:
</p><ul ><li ><p ><span class='texttt'>sb</span>, the <span class='texttt'>basic_filebuf</span> object.
</p></li></ul></div></div><div id='fstream.cons'><h4 ><a class='secnum' href='#fstream.cons' style='min-width:118pt'>27.9.1.15</a> <span class='texttt'>basic_fstream</span> constructors <a class='abbr_ref' href='fstream.cons'>[fstream.cons]</a></h4><p ><span class='indexparent'><a class='index' id='basic_fstream,basic_fstream'></a></span><code class='itemdecl'>
basic_fstream();
</code></p><div class='itemdescr'></div><div class='para' id='fstream.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#fstream.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>basic_fstream&lt;charT,traits&gt;</span>,
initializing the base class with
<span class='texttt'>basic_iostream(&amp;sb)</span>
and initializing
<span class='texttt'>sb</span>
with
<span class='texttt'>basic_filebuf&lt;charT,traits&gt;()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_fstream,constructor'></a></span><code class='itemdecl'>
explicit basic_fstream(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
</code></p><div class='itemdescr'></div><div class='para' id='fstream.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#fstream.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>basic_fstream&lt;charT, traits&gt;</span>,
initializing the base class with
<span class='texttt'>basic_iostream(&amp;sb)</span>
and initializing
<span class='texttt'>sb</span>
with
<span class='texttt'>basic_filebuf&lt;charT, traits&gt;()</span>.
Then calls
<span class='texttt'>rdbuf()-&gt;open(s, mode)</span>.
If that function returns a null pointer, calls
<span class='texttt'>setstate(failbit)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_fstream,constructor'></a></span><code class='itemdecl'>
explicit basic_fstream(const string&amp; s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
</code></p><div class='itemdescr'></div><div class='para' id='fstream.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#fstream.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> the same as <span class='texttt'>basic_fstream(s.c_str(), mode);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='basic_fstream,constructor'></a></span><code class='itemdecl'>
basic_fstream(basic_fstream&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='fstream.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#fstream.cons-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Move constructs from the rvalue <span class='texttt'>rhs</span>. This
is accomplished by move constructing the base class, and the contained
<span class='texttt'>basic_filebuf</span>. Next
<span class='texttt'>basic_istream&lt;charT,traits&gt;::set_rdbuf(&amp;sb)</span> is called to install
the contained <span class='texttt'>basic_filebuf</span>.
</p></div></div></div><div id='fstream.assign'><h4 ><a class='secnum' href='#fstream.assign' style='min-width:118pt'>27.9.1.16</a> Assign and swap <a class='abbr_ref' href='fstream.assign'>[fstream.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,basic_fstream'></a></span><span class='indexparent'><a class='index' id='basic_fstream,operator='></a></span><code class='itemdecl'>
basic_fstream&amp; operator=(basic_fstream&amp;&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='fstream.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#fstream.assign-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Move assigns the base and members of <span class='texttt'>*this</span> from the base and corresponding
members of <span class='texttt'>rhs</span>.</p></div></div><div class='para' id='fstream.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#fstream.assign-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,basic_fstream'></a></span><span class='indexparent'><a class='index' id='basic_fstream,swap'></a></span><code class='itemdecl'>
void swap(basic_fstream&amp; rhs);
</code></p><div class='itemdescr'></div><div class='para' id='fstream.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#fstream.assign-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Exchanges the state of <span class='texttt'>*this</span>
and <span class='texttt'>rhs</span> by calling
<span class='texttt'>basic_iostream&lt;charT,traits&gt;::swap(rhs)</span> and
<span class='texttt'>sb.swap(rhs.sb)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap,basic_fstream'></a></span><span class='indexparent'><a class='index' id='basic_fstream,swap'></a></span><code class='itemdecl'>
template &lt;class charT, class traits&gt;
void swap(basic_fstream&lt;charT, traits&gt;&amp; x,
          basic_fstream&lt;charT, traits&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='fstream.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#fstream.assign-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>x.swap(y)</span>.
</p></div></div></div><div id='fstream.members'><h4 ><a class='secnum' href='#fstream.members' style='min-width:118pt'>27.9.1.17</a> Member functions <a class='abbr_ref' href='fstream.members'>[fstream.members]</a></h4><p ><span class='indexparent'><a class='index' id='rdbuf,basic_filebuf'></a></span><code class='itemdecl'>
basic_filebuf&lt;charT,traits&gt;* rdbuf() const;
</code></p><div class='itemdescr'></div><div class='para' id='fstream.members-1'><div class='marginalizedparent'><a class='marginalized' href='#fstream.members-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>const_cast&lt;basic_filebuf&lt;charT,traits&gt;*&gt;(&amp;sb)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='is_open,basic_filebuf'></a></span><code class='itemdecl'>
bool is_open() const;
</code></p><div class='itemdescr'></div><div class='para' id='fstream.members-2'><div class='marginalizedparent'><a class='marginalized' href='#fstream.members-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>rdbuf()-&gt;is_open()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='open,basic_filebuf'></a></span><code class='itemdecl'>
void open(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
</code></p><div class='itemdescr'></div><div class='para' id='fstream.members-3'><div class='marginalizedparent'><a class='marginalized' href='#fstream.members-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Calls
<span class='texttt'>rdbuf()-&gt;open(s,mode)</span>.
If that function does not return a null pointer calls <span class='texttt'>clear()</span>,
otherwise calls
<span class='texttt'>setstate(failbit)</span>,
(which may throw
<span class='texttt'>ios_base::failure</span>) (<a href='iostate.flags'>[iostate.flags]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='open,basic_filebuf'></a></span><code class='itemdecl'>
void open(const string&amp; s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
</code></p><div class='itemdescr'></div><div class='para' id='fstream.members-4'><div class='marginalizedparent'><a class='marginalized' href='#fstream.members-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> calls <span class='texttt'>open(s.c_str(), mode);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='close,basic_filebuf'></a></span><code class='itemdecl'>
void close();
</code></p><div class='itemdescr'></div><div class='para' id='fstream.members-5'><div class='marginalizedparent'><a class='marginalized' href='#fstream.members-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Calls
<span class='texttt'>rdbuf()-&gt;close()</span>
and, if that function returns
returns a null pointer,
calls
<span class='texttt'>setstate(<span class='discretionary'></span>failbit)</span> (<a href='iostate.flags'>[iostate.flags]</a>)
(which may throw
<span class='texttt'>ios_base::failure</span>).
</p></div></div></div></div><div id='c.files'><h3 ><a class='secnum' href='#c.files' style='min-width:103pt'>27.9.2</a> C library files <a class='abbr_ref' href='c.files'>[c.files]</a></h3><div class='para' id='c.files-1'><div class='marginalizedparent'><a class='marginalized' href='#c.files-1'>1</a></div><p >Table <a href='#tab:iostreams.hdr.cstdio'>[tab:iostreams.hdr.cstdio]</a> describes header <span class='texttt'>&lt;cstdio&gt;</span>.
[&nbsp;<i>Note:</i> C++ does not define the function <span class='texttt'>gets</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><div class='numberedTable' id='tab:iostreams.hdr.cstdio'>Table <a href='#tab:iostreams.hdr.cstdio'>134</a> — Header <span class='texttt'>&lt;cstdio&gt;</span> synopsis<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Type</b></td><td colspan='5' class='center'><b>Name(s)</b></td></tr><tr class='capsep'><td colspan='6' class='left'><b>Macros</b>:</td></tr><tr ><td class='left'>
<span class='texttt'>BUFSIZ</span>    </td><td class='left'>
<span class='texttt'>FOPEN_MAX</span> </td><td class='left'>
<span class='texttt'>SEEK_CUR</span>  </td><td class='left'>
<span class='texttt'>TMP_MAX</span> </td><td class='left'>
<span class='texttt'>_IONBF</span>    </td><td class='left'>
<span class='texttt'>stdout</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>EOF</span>     </td><td class='left'>
<span class='texttt'>L_tmpnam</span>  </td><td class='left'>
<span class='texttt'>SEEK_END</span>  </td><td class='left'>
<span class='texttt'>_IOFBF</span>    </td><td class='left'>
<span class='texttt'>stderr</span>    </td><td class='left'> </td></tr><tr ><td class='left'>
<span class='texttt'>FILENAME_MAX</span>  </td><td class='left'>
<span class='texttt'>NULL &lt;cstdio&gt;</span> </td><td class='left'>
<span class='texttt'>SEEK_SET</span>  </td><td class='left'>
<span class='texttt'>_IOLBF</span>    </td><td class='left'>
<span class='texttt'>stdin</span>   </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> 
<b>Types</b>:        </td><td class='left'>
 <span class='texttt'>FILE</span>   </td><td class='left'>
 <span class='texttt'>fpos_t</span>   </td><td class='left'>
 <span class='texttt'>size_t &lt;cstdio&gt;</span>  </td><td class='left'></td><td class='left'>  </td></tr><tr class='rowsep'><td colspan='6' class='left'><b>Functions</b>:</td></tr><tr ><td class='left'><span class='texttt'>clearerr</span> </td><td class='left'>
<span class='texttt'>fopen</span> </td><td class='left'>
<span class='texttt'>fsetpos</span> </td><td class='left'>
<span class='texttt'>putchar</span> </td><td class='left'>
<span class='texttt'>snprintf</span> </td><td class='left'>
<span class='texttt'>vscanf</span> </td></tr><tr ><td class='left'><span class='texttt'>fclose</span> </td><td class='left'>
<span class='texttt'>fprintf</span> </td><td class='left'>
<span class='texttt'>ftell</span> </td><td class='left'>
<span class='texttt'>puts</span> </td><td class='left'>
<span class='texttt'>sprintf</span> </td><td class='left'>
<span class='texttt'>vsnprintf</span> </td></tr><tr ><td class='left'><span class='texttt'>feof</span> </td><td class='left'>
<span class='texttt'>fputc</span> </td><td class='left'>
<span class='texttt'>fwrite</span> </td><td class='left'>
<span class='texttt'>remove</span> </td><td class='left'>
<span class='texttt'>sscanf</span> </td><td class='left'>
<span class='texttt'>vsprintf</span> </td></tr><tr ><td class='left'><span class='texttt'>ferror</span> </td><td class='left'>
<span class='texttt'>fputs</span> </td><td class='left'>
<span class='texttt'>getc</span> </td><td class='left'>
<span class='texttt'>rename</span> </td><td class='left'>
<span class='texttt'>tmpfile</span> </td><td class='left'>
<span class='texttt'>vsscanf</span> </td></tr><tr ><td class='left'><span class='texttt'>fflush</span> </td><td class='left'>
<span class='texttt'>fread</span> </td><td class='left'>
<span class='texttt'>getchar</span> </td><td class='left'>
<span class='texttt'>rewind</span> </td><td class='left'>
<span class='texttt'>tmpnam</span> </td><td class='left'></td></tr><tr ><td class='left'><span class='texttt'>fgetc</span> </td><td class='left'>
<span class='texttt'>freopen</span> </td><td class='left'>
<span class='texttt'>perror</span> </td><td class='left'>
<span class='texttt'>scanf</span> </td><td class='left'>
<span class='texttt'>ungetc</span> </td><td class='left'></td></tr><tr ><td class='left'><span class='texttt'>fgetpos</span> </td><td class='left'>
<span class='texttt'>fscanf</span> </td><td class='left'>
<span class='texttt'>printf</span> </td><td class='left'>
<span class='texttt'>setbuf</span> </td><td class='left'>
<span class='texttt'>vfprintf</span> </td><td class='left'></td></tr><tr ><td class='left'><span class='texttt'>fgets</span> </td><td class='left'>
<span class='texttt'>fseek</span> </td><td class='left'>
<span class='texttt'>putc</span> </td><td class='left'>
<span class='texttt'>setvbuf</span> </td><td class='left'>
<span class='texttt'>vprintf</span> </td><td class='left'></td></tr></table></div></div><div class='para' id='c.files-2'><div class='marginalizedparent'><a class='marginalized' href='#c.files-2'>2</a></div><p >Calls to the function <span class='texttt'>tmpnam</span> with an argument of <span class='texttt'>NULL</span> may
introduce a data race (<a href='res.on.data.races'>[res.on.data.races]</a>) with other calls to <span class='texttt'>tmpnam</span> with
an argument of <span class='texttt'>NULL</span>.</p><p ><span class='textsc'>See also:</span>
ISO C 7.9, Amendment 1 4.6.2.</p></div><div class='para' id='c.files-3'><div class='marginalizedparent'><a class='marginalized' href='#c.files-3'>3</a></div><p >Table <a href='#tab:iostreams.hdr.cinttypes'>[tab:iostreams.hdr.cinttypes]</a> describes header <span class='texttt'>&lt;cinttypes&gt;</span>. [&nbsp;<i>Note:</i> The
macros defined by <span class='texttt'>&lt;cinttypes&gt;</span> are provided unconditionally. In particular, the symbol
<span class='texttt'>__STDC_FORMAT_MACROS</span>, mentioned in footnote 182 of the C standard, plays no role in
C++. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><div class='numberedTable' id='tab:iostreams.hdr.cinttypes'>Table <a href='#tab:iostreams.hdr.cinttypes'>135</a> — Header <span class='texttt'>&lt;cinttypes&gt;</span> synopsis<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Type</b></td><td colspan='3' class='center'><b>Name(s)</b></td></tr><tr class='capsep'><td colspan='4' class='left'><b>Macros</b>:</td></tr><tr ><td colspan='4' class='left'><span class='texttt'>PRI{d i o u x X}[FAST LEAST]{8 16 32 64}</span></td></tr><tr ><td colspan='4' class='left'><span class='texttt'>PRI{d i o u x X}{MAX PTR}</span></td></tr><tr ><td colspan='4' class='left'><span class='texttt'>SCN{d i o u x X}[FAST LEAST]{8 16 32 64}</span></td></tr><tr ><td colspan='4' class='left'><span class='texttt'>SCN{d i o u x X}{MAX PTR}</span></td></tr><tr class='rowsep'><td class='left'> 
<b>Types</b>:  </td><td class='left'> <span class='texttt'>imaxdiv_t</span> </td><td class='left'></td><td class='left'></td></tr><tr class='rowsep'><td colspan='4' class='left'><b>Functions</b>:</td></tr><tr ><td class='left'>
<span class='texttt'>abs</span> </td><td class='left'>
<span class='texttt'>imaxabs</span> </td><td class='left'>
<span class='texttt'>strtoimax</span> </td><td class='left'>
<span class='texttt'>wcstoimax</span> </td></tr><tr ><td class='left'>
<span class='texttt'>div</span> </td><td class='left'>
<span class='texttt'>imaxdiv</span> </td><td class='left'>
<span class='texttt'>strtoumax</span> </td><td class='left'>
<span class='texttt'>wcstoumax</span></td></tr></table></div></div><div class='para' id='c.files-4'><div class='marginalizedparent'><a class='marginalized' href='#c.files-4'>4</a></div><p >The contents of header <span class='texttt'>&lt;cinttypes&gt;</span> are the same as the Standard C Library header
<span class='texttt'>&lt;inttypes.h&gt;</span>, with the following changes:</p><ul ><li ><p >the header <span class='texttt'>&lt;cinttypes&gt;</span> includes the header <span class='texttt'>&lt;cstdint&gt;</span> instead
of <span class='texttt'>&lt;stdint.h&gt;</span>, and</p></li><li ><p >if and only if the type <span class='texttt'>intmax_t</span> designates an extended integer 
type (<a href='basic.fundamental'>[basic.fundamental]</a>), the following function signatures are added:
</p><pre class='codeblock'>
intmax_t abs(intmax_t);
imaxdiv_t div(intmax_t, intmax_t);
</pre><p >which shall have the same semantics as the function signatures
<span class='texttt'>intmax_t imaxabs(intmax_t)</span> and
<span class='texttt'>imaxdiv_t imaxdiv(intmax_t, intmax_t)</span>, respectively.
</p></li></ul></div></div></div></div></body></html>