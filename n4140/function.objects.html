<!DOCTYPE html><html lang='en'><head><title>[function.objects]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><div id='function.objects'><h2 ><a class='secnum' style='min-width:88pt'>20.9</a> Function objects <a class='abbr_ref'>[function.objects]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A <span class='indexparent'><a class='index' id='function_object,type'></a></span><a class='hidden_link' href='#def:function_object_type' id='def:function_object_type'><i>function object type</i></a> is an object
type (<a href='basic.types'>[basic.types]</a>) that can be the type of the
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> in a function call
(<a href='expr.call'>[expr.call]</a>, <a href='over.match.call'>[over.match.call]</a>).<a class='footnotenum' href='#footnote-231'>231</a> A <a class='hidden_link' href='#def:function_object' id='def:function_object'><i>function object</i></a> is an
object of a function object type. In the places where one would expect to pass a
pointer to a function to an algorithmic template (Clause <a href='algorithms'>[algorithms]</a>), the
interface is specified to accept a function object. This not only makes
algorithmic templates work with pointers to functions, but also enables them to
work with arbitrary function objects.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><b>Header <span class='texttt'>&lt;functional&gt;</span> synopsis</b></p><p ><span class='indexparent'><a class='index' id='functional'></a></span></p><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='depr.base'>[depr.base]</a>, base (deprecated):
</span>  template &lt;class Arg, class Result&gt; struct unary_function;
  template &lt;class Arg1, class Arg2, class Result&gt; struct binary_function;

  <span class='comment'>// <a href='refwrap'>[refwrap]</a>, reference_wrapper:
</span>  template &lt;class T&gt; class reference_wrapper;

  template &lt;class T&gt; reference_wrapper&lt;T&gt; ref(T&amp;) noexcept;
  template &lt;class T&gt; reference_wrapper&lt;const T&gt; cref(const T&amp;) noexcept;
  template &lt;class T&gt; void ref(const T&amp;&amp;) = delete;
  template &lt;class T&gt; void cref(const T&amp;&amp;) = delete;

  template &lt;class T&gt; reference_wrapper&lt;T&gt; ref(reference_wrapper&lt;T&gt;) noexcept;
  template &lt;class T&gt; reference_wrapper&lt;const T&gt; cref(reference_wrapper&lt;T&gt;) noexcept;

  <span class='comment'>// <a href='arithmetic.operations'>[arithmetic.operations]</a>, arithmetic operations:
</span>  template &lt;class T = void&gt; struct plus;
  template &lt;class T = void&gt; struct minus;
  template &lt;class T = void&gt; struct multiplies;
  template &lt;class T = void&gt; struct divides;
  template &lt;class T = void&gt; struct modulus;
  template &lt;class T = void&gt; struct negate;
  template &lt;&gt; struct plus&lt;void&gt;;
  template &lt;&gt; struct minus&lt;void&gt;;
  template &lt;&gt; struct multiplies&lt;void&gt;;
  template &lt;&gt; struct divides&lt;void&gt;;
  template &lt;&gt; struct modulus&lt;void&gt;;
  template &lt;&gt; struct negate&lt;void&gt;;

  <span class='comment'>// <a href='comparisons'>[comparisons]</a>, comparisons:
</span>  template &lt;class T = void&gt; struct equal_to;
  template &lt;class T = void&gt; struct not_equal_to;
  template &lt;class T = void&gt; struct greater;
  template &lt;class T = void&gt; struct less;
  template &lt;class T = void&gt; struct greater_equal;
  template &lt;class T = void&gt; struct less_equal;
  template &lt;&gt; struct equal_to&lt;void&gt;;
  template &lt;&gt; struct not_equal_to&lt;void&gt;;
  template &lt;&gt; struct greater&lt;void&gt;;
  template &lt;&gt; struct less&lt;void&gt;;
  template &lt;&gt; struct greater_equal&lt;void&gt;;
  template &lt;&gt; struct less_equal&lt;void&gt;;

  <span class='comment'>// <a href='logical.operations'>[logical.operations]</a>, logical operations:
</span>  template &lt;class T = void&gt; struct logical_and;
  template &lt;class T = void&gt; struct logical_or;
  template &lt;class T = void&gt; struct logical_not;
  template &lt;&gt; struct logical_and&lt;void&gt;;
  template &lt;&gt; struct logical_or&lt;void&gt;;
  template &lt;&gt; struct logical_not&lt;void&gt;;

  <span class='comment'>// <a href='bitwise.operations'>[bitwise.operations]</a>, bitwise operations:
</span>  template &lt;class T = void&gt; struct bit_and;
  template &lt;class T = void&gt; struct bit_or;
  template &lt;class T = void&gt; struct bit_xor;
  template &lt;class T = void&gt; struct bit_not;
  template &lt;&gt; struct bit_and&lt;void&gt;;
  template &lt;&gt; struct bit_or&lt;void&gt;;
  template &lt;&gt; struct bit_xor&lt;void&gt;;
  template &lt;&gt; struct bit_not&lt;void&gt;;

  <span class='comment'>// <a href='negators'>[negators]</a>, negators:
</span>  template &lt;class Predicate&gt; class unary_negate;
  template &lt;class Predicate&gt;
    constexpr unary_negate&lt;Predicate&gt; not1(const Predicate&amp;);
  template &lt;class Predicate&gt; class binary_negate;
  template &lt;class Predicate&gt;
    constexpr binary_negate&lt;Predicate&gt; not2(const Predicate&amp;);

  <span class='comment'>// <a href='func.bind'>[func.bind]</a>, bind:
</span>  template&lt;class T&gt; struct is_bind_expression;
  template&lt;class T&gt; struct is_placeholder;

  template&lt;class F, class... BoundArgs&gt;
    <i><span class='texttt'>unspecified</span></i> bind(F&amp;&amp;, BoundArgs&amp;&amp;...);
  template&lt;class R, class F, class... BoundArgs&gt;
    <i><span class='texttt'>unspecified</span></i> bind(F&amp;&amp;, BoundArgs&amp;&amp;...);

  namespace placeholders {
    <span class='comment'>// M is the implementation-defined number of placeholders
</span>    extern <i><span class='texttt'>unspecified</span></i> _1;
    extern <i><span class='texttt'>unspecified</span></i> _2;
                .
                .
                .
    extern <i><span class='texttt'>unspecified</span></i> _M;
  }

  <span class='comment'>// <a href='depr.lib.binders'>[depr.lib.binders]</a>, binders (deprecated):
</span>  template &lt;class Fn&gt; class binder1st;
  template &lt;class Fn, class T&gt;
    binder1st&lt;Fn&gt; bind1st(const Fn&amp;, const T&amp;);
  template &lt;class Fn&gt; class binder2nd;
  template &lt;class Fn, class T&gt;
    binder2nd&lt;Fn&gt; bind2nd(const Fn&amp;, const T&amp;);

  <span class='comment'>// <a href='depr.function.pointer.adaptors'>[depr.function.pointer.adaptors]</a>, adaptors (deprecated):
</span>  template &lt;class Arg, class Result&gt; class pointer_to_unary_function;
  template &lt;class Arg, class Result&gt;
    pointer_to_unary_function&lt;Arg,Result&gt; ptr_fun(Result (*)(Arg));
  template &lt;class Arg1, class Arg2, class Result&gt;
    class pointer_to_binary_function;
  template &lt;class Arg1, class Arg2, class Result&gt;
    pointer_to_binary_function&lt;Arg1,Arg2,Result&gt;
      ptr_fun(Result (*)(Arg1,Arg2));

  <span class='comment'>// <a href='depr.member.pointer.adaptors'>[depr.member.pointer.adaptors]</a>, adaptors (deprecated):
</span>  template&lt;class S, class T&gt; class mem_fun_t;
  template&lt;class S, class T, class A&gt; class mem_fun1_t;
  template&lt;class S, class T&gt;
      mem_fun_t&lt;S,T&gt; mem_fun(S (T::*f)());
  template&lt;class S, class T, class A&gt;
      mem_fun1_t&lt;S,T,A&gt; mem_fun(S (T::*f)(A));
  template&lt;class S, class T&gt; class mem_fun_ref_t;
  template&lt;class S, class T, class A&gt; class mem_fun1_ref_t;
  template&lt;class S, class T&gt;
      mem_fun_ref_t&lt;S,T&gt; mem_fun_ref(S (T::*f)());
  template&lt;class S, class T, class A&gt;
      mem_fun1_ref_t&lt;S,T,A&gt; mem_fun_ref(S (T::*f)(A));

  template &lt;class S, class T&gt; class const_mem_fun_t;
  template &lt;class S, class T, class A&gt; class const_mem_fun1_t;
  template &lt;class S, class T&gt;
    const_mem_fun_t&lt;S,T&gt; mem_fun(S (T::*f)() const);
  template &lt;class S, class T, class A&gt;
    const_mem_fun1_t&lt;S,T,A&gt; mem_fun(S (T::*f)(A) const);
  template &lt;class S, class T&gt; class const_mem_fun_ref_t;
  template &lt;class S, class T, class A&gt; class const_mem_fun1_ref_t;
  template &lt;class S, class T&gt;
    const_mem_fun_ref_t&lt;S,T&gt; mem_fun_ref(S (T::*f)() const);
  template &lt;class S, class T, class A&gt;
    const_mem_fun1_ref_t&lt;S,T,A&gt; mem_fun_ref(S (T::*f)(A) const);

  <span class='comment'>// <a href='func.memfn'>[func.memfn]</a>, member function adaptors:
</span>  template&lt;class R, class T&gt; <i><span class='texttt'>unspecified</span></i> mem_fn(R T::*);

  <span class='comment'>// <a href='func.wrap'>[func.wrap]</a> polymorphic function wrappers:
</span>  class bad_function_call;

  template&lt;class&gt; class function; <span class='comment'>// undefined
</span>  template&lt;class R, class... ArgTypes&gt; class function&lt;R(ArgTypes...)&gt;;

  template&lt;class R, class... ArgTypes&gt;
    void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);

  template&lt;class R, class... ArgTypes&gt;
    bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t);
  template&lt;class R, class... ArgTypes&gt;
    bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;);
  template&lt;class R, class... ArgTypes&gt;
    bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t);
  template&lt;class R, class... ArgTypes&gt;
    bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;);

  <span class='comment'>// <a href='unord.hash'>[unord.hash]</a>, hash function primary template:
</span>  template &lt;class T&gt; struct hash;

  <span class='comment'>// Hash function specializations
</span>  template &lt;&gt; struct hash&lt;bool&gt;;
  template &lt;&gt; struct hash&lt;char&gt;;
  template &lt;&gt; struct hash&lt;signed char&gt;;
  template &lt;&gt; struct hash&lt;unsigned char&gt;;
  template &lt;&gt; struct hash&lt;char16_t&gt;;
  template &lt;&gt; struct hash&lt;char32_t&gt;;
  template &lt;&gt; struct hash&lt;wchar_t&gt;;
  template &lt;&gt; struct hash&lt;short&gt;;
  template &lt;&gt; struct hash&lt;unsigned short&gt;;
  template &lt;&gt; struct hash&lt;int&gt;;
  template &lt;&gt; struct hash&lt;unsigned int&gt;;
  template &lt;&gt; struct hash&lt;long&gt;;
  template &lt;&gt; struct hash&lt;long long&gt;;
  template &lt;&gt; struct hash&lt;unsigned long&gt;;
  template &lt;&gt; struct hash&lt;unsigned long long&gt;;

  template &lt;&gt; struct hash&lt;float&gt;;
  template &lt;&gt; struct hash&lt;double&gt;;
  template &lt;&gt; struct hash&lt;long double&gt;;

  template&lt;class T&gt; struct hash&lt;T*&gt;;
}
</pre></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >[&nbsp;<i>Example:</i>
If a C++ program wants to have a by-element addition of two vectors <span class='texttt'>a</span>
and <span class='texttt'>b</span> containing <span class='texttt'>double</span> and put the result into <span class='texttt'>a</span>,
it can do:</p><pre class='codeblock'>
transform(a.begin(), a.end(), b.begin(), a.begin(), plus&lt;double&gt;());
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >[&nbsp;<i>Example:</i>
To negate every element of <span class='texttt'>a</span>:</p><pre class='codeblock'>
transform(a.begin(), a.end(), a.begin(), negate&lt;double&gt;());
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >[&nbsp;<i>Note:</i>
To enable adaptors and other components to manipulate function objects that
take one or two arguments many of the function objects in this clause
correspondingly provide typedefs
<span class='texttt'>argument_type</span>
and
<span class='texttt'>result_type</span>
for function objects that take one argument and <span class='texttt'>first_argument_type</span>,
<span class='texttt'>second_argument_type</span>, and <span class='texttt'>result_type</span> for function objects
that take two arguments.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-230'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-230'>230)</a></div><p >Such a type is a function
pointer or a class type which has a member <span class='texttt'>operator()</span> or a class type
which has a conversion to a pointer to function.</p></div><div id='func.def'><h3 ><a class='secnum' href='#func.def' style='min-width:103pt'>20.9.1</a> Definitions <a class='abbr_ref' href='func.def'>[func.def]</a></h3><div class='para' id='func.def-1'><div class='marginalizedparent'><a class='marginalized' href='#func.def-1'>1</a></div><p >The following definitions apply to this Clause:</p></div><div class='para' id='func.def-2'><div class='marginalizedparent'><a class='marginalized' href='#func.def-2'>2</a></div><p ><span class='indexparent'><a class='index' id='call_signature'></a></span>A <a class='hidden_link' href='#def:call_signature' id='def:call_signature'><i>call signature</i></a> is the name of a return type followed by a
parenthesized comma-separated list of zero or more argument types.</p></div><div class='para' id='func.def-3'><div class='marginalizedparent'><a class='marginalized' href='#func.def-3'>3</a></div><p ><span class='indexparent'><a class='index' id='callable_type'></a></span>A <a class='hidden_link' href='#def:callable_type' id='def:callable_type'><i>callable type</i></a> is a function object type (<a href='function.objects'>[function.objects]</a>) or a pointer to member.</p></div><div class='para' id='func.def-4'><div class='marginalizedparent'><a class='marginalized' href='#func.def-4'>4</a></div><p ><span class='indexparent'><a class='index' id='callable_object'></a></span>A <a class='hidden_link' href='#def:callable_object' id='def:callable_object'><i>callable object</i></a> is an object of a callable type.</p></div><div class='para' id='func.def-5'><div class='marginalizedparent'><a class='marginalized' href='#func.def-5'>5</a></div><p ><span class='indexparent'><a class='index' id='call_wrapper,type'></a></span>A <a class='hidden_link' href='#def:call_wrapper_type' id='def:call_wrapper_type'><i>call wrapper type</i></a> is a type that holds a callable object
and supports a call operation that forwards to that object.</p></div><div class='para' id='func.def-6'><div class='marginalizedparent'><a class='marginalized' href='#func.def-6'>6</a></div><p ><span class='indexparent'><a class='index' id='call_wrapper'></a></span>A <a class='hidden_link' href='#def:call_wrapper' id='def:call_wrapper'><i>call wrapper</i></a> is an object of a call wrapper type.</p></div><div class='para' id='func.def-7'><div class='marginalizedparent'><a class='marginalized' href='#func.def-7'>7</a></div><p ><span class='indexparent'><a class='index' id='target_object'></a></span>A <a class='hidden_link' href='#def:target_object' id='def:target_object'><i>target object</i></a> is the callable object held by a call wrapper.</p></div></div><div id='func.require'><h3 ><a class='secnum' href='#func.require' style='min-width:103pt'>20.9.2</a> Requirements <a class='abbr_ref' href='func.require'>[func.require]</a></h3><div class='para' id='func.require-1'><div class='marginalizedparent'><a class='marginalized' href='#func.require-1'>1</a></div><p ><span class='indexparent'><a class='index' id='invoke'></a></span>Define <span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN)</span> as follows:</p><ul class='itemize'><li id='func.require-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-1.1'>(1.1)</a></div><p ><span class='texttt'>(t1.*f)(t2, ..., tN)</span> when <span class='texttt'>f</span> is a pointer to a
member function of a class <span class='texttt'>T</span> and <span class='texttt'>t1</span> is an object of
type <span class='texttt'>T</span> or a reference to an object of type <span class='texttt'>T</span> or a
reference to an object of a type derived from <span class='texttt'>T</span>;</p></li><li id='func.require-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-1.2'>(1.2)</a></div><p ><span class='texttt'>((*t1).*f)(t2, ..., tN)</span> when <span class='texttt'>f</span> is a pointer to a
member function of a class <span class='texttt'>T</span> and <span class='texttt'>t1</span> is not one of the
types described in the previous item;</p></li><li id='func.require-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-1.3'>(1.3)</a></div><p ><span class='texttt'>t1.*f</span> when <span class='texttt'>N == 1</span> and
<span class='texttt'>f</span> is a pointer to member data of a
class <span class='texttt'>T</span> and <span class='texttt'>t1</span> is an object of type <span class='texttt'>T</span> or a
reference to an object of type <span class='texttt'>T</span> or a reference to an object
of a type derived from <span class='texttt'>T</span>;</p></li><li id='func.require-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-1.4'>(1.4)</a></div><p ><span class='texttt'>(*t1).*f</span> when <span class='texttt'>N == 1</span> and
<span class='texttt'>f</span> is a pointer to member data of a
class <span class='texttt'>T</span> and <span class='texttt'>t1</span> is not one of the types described in
the previous item;</p></li><li id='func.require-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-1.5'>(1.5)</a></div><p ><span class='texttt'>f(t1, t2, ..., tN)</span> in all other cases.
</p></li></ul></div><div class='para' id='func.require-2'><div class='marginalizedparent'><a class='marginalized' href='#func.require-2'>2</a></div><p ><span class='indexparent'><a class='index' id='invoke'></a></span>Define <span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN, R)</span> as
<span class='texttt'><i>INVOKE</i>(f, t1, t2, ..., tN)</span> implicitly converted
to <span class='texttt'>R</span>.</p></div><div class='para' id='func.require-3'><div class='marginalizedparent'><a class='marginalized' href='#func.require-3'>3</a></div><p ><span class='indexparent'><a class='index' id='weak_result_type'></a></span><span class='indexparent'><a class='index' id='call_wrapper'></a></span><span class='indexparent'><a class='index' id='target_object'></a></span>If a call wrapper (<a href='func.def'>[func.def]</a>) has a <i>weak result type</i>
the type of its member type <span class='texttt'>result_type</span> is based on the
type <span class='texttt'>T</span> of the wrapper's target object (<a href='func.def'>[func.def]</a>):
</p><ul class='itemize'><li id='func.require-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-3.1'>(3.1)</a></div><p >if <span class='texttt'>T</span> is a pointer to
function type, <span class='texttt'>result_type</span> shall be a synonym for the return
type of <span class='texttt'>T</span>;</p></li><li id='func.require-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-3.2'>(3.2)</a></div><p >if <span class='texttt'>T</span> is a pointer to member function, <span class='texttt'>result_type</span>
shall be a synonym for the return type of <span class='texttt'>T</span>;</p></li><li id='func.require-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-3.3'>(3.3)</a></div><p >if <span class='texttt'>T</span> is a class type with a member type <span class='texttt'>result_type</span>,
then <span class='texttt'>result_type</span> shall be a synonym for <span class='texttt'>T::result_type</span>;</p></li><li id='func.require-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.require-3.4'>(3.4)</a></div><p >otherwise <span class='texttt'>result_type</span> shall not be defined.
</p></li></ul></div><div class='para' id='func.require-4'><div class='marginalizedparent'><a class='marginalized' href='#func.require-4'>4</a></div><p ><span class='indexparent'><a class='index' id='call_wrapper'></a></span><span class='indexparent'><a class='index' id='call_wrapper,simple'></a></span><span class='indexparent'><a class='index' id='call_wrapper,forwarding'></a></span><span class='indexparent'><a class='index' id='simple_call_wrapper'></a></span><span class='indexparent'><a class='index' id='forwarding_call_wrapper'></a></span>Every call wrapper (<a href='func.def'>[func.def]</a>) shall be
<span class='texttt'>MoveConstructible</span>. A <a class='hidden_link' href='#def:simple_call_wrapper' id='def:simple_call_wrapper'><i>simple call wrapper</i></a> is a call wrapper
that is <span class='texttt'>CopyConstructible</span> and <span class='texttt'>CopyAssignable</span> and whose copy
constructor, move constructor, and assignment operator
do not throw exceptions. A <a class='hidden_link' href='#def:forwarding_call_wrapper' id='def:forwarding_call_wrapper'><i>forwarding call wrapper</i></a> is a
call wrapper that can be called with an arbitrary argument list
and delivers the arguments to the wrapped callable object as references.
This forwarding step shall ensure that rvalue arguments are delivered as rvalue-references
and lvalue arguments are delivered as lvalue-references.
[&nbsp;<i>Note:</i> In a typical implementation
forwarding call wrappers have an overloaded function call
operator of
the form</p><pre class='codeblock'>
template&lt;class... UnBoundArgs&gt;
R operator()(UnBoundArgs&amp;&amp;... unbound_args) <i>cv-qual</i>;
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='refwrap'><h3 ><a class='secnum' href='#refwrap' style='min-width:103pt'>20.9.3</a> Class template <span class='texttt'>reference_wrapper</span> <a class='abbr_ref' href='refwrap'>[refwrap]</a></h3><p ><span class='indexparent'><a class='index' id='reference_wrapper'></a></span><span class='indexparent'><a class='index' id='function_object,reference_wrapper'></a></span><span class='indexparent'><a class='index' id='unary_function'></a></span><span class='indexparent'><a class='index' id='binary_function'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; class reference_wrapper {
  public :
    <span class='comment'>// types
</span>    typedef T type;
    typedef <i><span class='texttt'>see below</span></i> result_type;               <span class='comment'>// not always defined
</span>    typedef <i><span class='texttt'>see below</span></i> argument_type;             <span class='comment'>// not always defined
</span>    typedef <i><span class='texttt'>see below</span></i> first_argument_type;       <span class='comment'>// not always defined
</span>    typedef <i><span class='texttt'>see below</span></i> second_argument_type;      <span class='comment'>// not always defined
</span>
    <span class='comment'>// construct/copy/destroy
</span>    reference_wrapper(T&amp;) noexcept;
    reference_wrapper(T&amp;&amp;) = delete;     <span class='comment'>// do not bind to temporary objects
</span>    reference_wrapper(const reference_wrapper&amp; x) noexcept;

    <span class='comment'>// assignment
</span>    reference_wrapper&amp; operator=(const reference_wrapper&amp; x) noexcept;

    <span class='comment'>// access
</span>    operator T&amp; () const noexcept;
    T&amp; get() const noexcept;

    <span class='comment'>// invocation
</span>    template &lt;class... ArgTypes&gt;
    result_of_t&lt;T&amp;(ArgTypes&amp;&amp;...)&gt;
    operator() (ArgTypes&amp;&amp;...) const;
  };
}
</pre><div class='para' id='refwrap-1'><div class='marginalizedparent'><a class='marginalized' href='#refwrap-1'>1</a></div><p ><span class='texttt'>reference_wrapper&lt;T&gt;</span> is a <span class='texttt'>CopyConstructible</span> and <span class='texttt'>CopyAssignable</span> wrapper
around a reference to an object or function of type <span class='texttt'>T</span>.</p></div><div class='para' id='refwrap-2'><div class='marginalizedparent'><a class='marginalized' href='#refwrap-2'>2</a></div><p ><span class='texttt'>reference_wrapper&lt;T&gt;</span> has a weak result type (<a href='func.require'>[func.require]</a>).
If <span class='texttt'>T</span> is a function type, <span class='texttt'>result_type</span> shall be a synonym for the
return type of <span class='texttt'>T</span>.</p></div><div class='para' id='refwrap-3'><div class='marginalizedparent'><a class='marginalized' href='#refwrap-3'>3</a></div><p ><span class='indexparent'><a class='index' id='unary_function'></a></span>The template specialization <span class='texttt'>reference_wrapper&lt;T&gt;</span> shall
define a nested type named <span class='texttt'>argument_type</span> as a synonym for <span class='texttt'>T1</span>
only if the type <span class='texttt'>T</span> is any of the
following:</p><ul class='itemize'><li id='refwrap-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#refwrap-3.1'>(3.1)</a></div><p >a function type or a pointer to function type taking one argument of type <span class='texttt'>T1</span></p></li><li id='refwrap-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#refwrap-3.2'>(3.2)</a></div><p >a pointer to member function <span class='texttt'>R T0::f</span> <i>cv</i> (where <i>cv</i> represents the
member function's cv-qualifiers); the type <span class='texttt'>T1</span> is <i>cv</i> <span class='texttt'>T0*</span></p></li><li id='refwrap-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#refwrap-3.3'>(3.3)</a></div><p >a class type with a member type <span class='texttt'>argument_type</span>; the type <span class='texttt'>T1</span> is
<span class='texttt'>T::argument_type</span>.
</p></li></ul><p ><span class='indexparent'><a class='index' id='binary_function'></a></span></p></div><div class='para' id='refwrap-4'><div class='marginalizedparent'><a class='marginalized' href='#refwrap-4'>4</a></div><p >The template instantiation <span class='texttt'>reference_wrapper&lt;T&gt;</span> shall
define two nested types named <span class='texttt'>first_argument_type</span> and <span class='texttt'>second_argument_type</span>
as synonyms for <span class='texttt'>T1</span> and <span class='texttt'>T2</span>, respectively,
only if the type
<span class='texttt'>T</span> is any of the following:</p><ul class='itemize'><li id='refwrap-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#refwrap-4.1'>(4.1)</a></div><p >a function type or a pointer to function type taking two arguments of types <span class='texttt'>T1</span> and
<span class='texttt'>T2</span></p></li><li id='refwrap-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#refwrap-4.2'>(4.2)</a></div><p >a pointer to member function <span class='texttt'>R T0::f(T2)</span> <i>cv</i> (where <i>cv</i> represents the
member function's cv-qualifiers); the type <span class='texttt'>T1</span> is <i>cv</i> <span class='texttt'>T0*</span></p></li><li id='refwrap-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#refwrap-4.3'>(4.3)</a></div><p >a class type with member types <span class='texttt'>first_argument_type</span> and
<span class='texttt'>second_argument_type</span>;
the type <span class='texttt'>T1</span> is <span class='texttt'>T::first_argument_type</span>
and the type <span class='texttt'>T2</span> is <span class='texttt'>T::second_argument_type</span>.</p></li></ul></div><div id='refwrap.const'><h4 ><a class='secnum' href='#refwrap.const' style='min-width:118pt'>20.9.3.1</a> <span class='texttt'>reference_wrapper</span> construct/copy/destroy <a class='abbr_ref' href='refwrap.const'>[refwrap.const]</a></h4><p ><span class='indexparent'><a class='index' id='reference_wrapper,reference_wrapper'></a></span><code class='itemdecl'>
reference_wrapper(T&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.const-1'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.const-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>reference_wrapper</span> object that stores a
reference to <span class='texttt'>t</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reference_wrapper,reference_wrapper'></a></span><code class='itemdecl'>
reference_wrapper(const reference_wrapper&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.const-2'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.const-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>reference_wrapper</span> object that
stores a reference to <span class='texttt'>x.get()</span>.
</p></div></div></div><div id='refwrap.assign'><h4 ><a class='secnum' href='#refwrap.assign' style='min-width:118pt'>20.9.3.2</a> <span class='texttt'>reference_wrapper</span> assignment <a class='abbr_ref' href='refwrap.assign'>[refwrap.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,reference_wrapper'></a></span>
<span class='indexparent'><a class='index' id='reference_wrapper,operator='></a></span>
<code class='itemdecl'>
reference_wrapper&amp; operator=(const reference_wrapper&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.assign-1'>1</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>*this</span> stores a reference to  <span class='texttt'>x.get()</span>.
</p></div></div></div><div id='refwrap.access'><h4 ><a class='secnum' href='#refwrap.access' style='min-width:118pt'>20.9.3.3</a> <span class='texttt'>reference_wrapper</span> access <a class='abbr_ref' href='refwrap.access'>[refwrap.access]</a></h4><p ><span class='indexparent'><a class='index' id='operator_T&,reference_wrapper'></a></span>
<span class='indexparent'><a class='index' id='reference_wrapper,operator_T&'></a></span>
<code class='itemdecl'>
operator T&amp; () const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.access-1'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.access-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The stored reference.
</p></div></div><p ><span class='indexparent'><a class='index' id='reference_wrapper,get'></a></span><span class='indexparent'><a class='index' id='get,reference_wrapper'></a></span><code class='itemdecl'>
T&amp; get() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.access-2'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.access-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> The stored reference.
</p></div></div></div><div id='refwrap.invoke'><h4 ><a class='secnum' href='#refwrap.invoke' style='min-width:118pt'>20.9.3.4</a> reference_wrapper invocation <a class='abbr_ref' href='refwrap.invoke'>[refwrap.invoke]</a></h4><p ><span class='indexparent'><a class='index' id='reference_wrapper,operator()'></a></span><span class='indexparent'><a class='index' id='operator(),reference_wrapper'></a></span><code class='itemdecl'>
template &lt;class... ArgTypes&gt;
  result_of_t&lt;T&amp;(ArgTypes&amp;&amp;... )&gt;
    operator()(ArgTypes&amp;&amp;... args) const;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.invoke-1'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.invoke-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'><i>INVOKE</i>(get(), std::forward&lt;ArgTypes&gt;(args)...)</span>. (<a href='func.require'>[func.require]</a>)</p></div></div><div class='para' id='refwrap.invoke-2'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.invoke-2'>2</a></div><div class='itemdescr'><p ><i>Remark:</i> <span class='texttt'>operator()</span> is described for exposition only.
Implementations are not required to provide an actual
<span class='texttt'>reference_wrapper::operator()</span>.  Implementations are
permitted to support <span class='texttt'>reference_wrapper</span> function invocation
through multiple overloaded operators or through other means.</p></div></div></div><div id='refwrap.helpers'><h4 ><a class='secnum' href='#refwrap.helpers' style='min-width:118pt'>20.9.3.5</a> reference_wrapper helper functions <a class='abbr_ref' href='refwrap.helpers'>[refwrap.helpers]</a></h4><p ><span class='indexparent'><a class='index' id='reference_wrapper,ref'></a></span><span class='indexparent'><a class='index' id='ref,reference_wrapper'></a></span><code class='itemdecl'>
template &lt;class T&gt; reference_wrapper&lt;T&gt; ref(T&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.helpers-1'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.helpers-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>reference_wrapper&lt;T&gt;(t)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='reference_wrapper,ref'></a></span><span class='indexparent'><a class='index' id='ref,reference_wrapper'></a></span><code class='itemdecl'>
template &lt;class T&gt; reference_wrapper&lt;T&gt; ref(reference_wrapper&lt;T&gt; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.helpers-2'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.helpers-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>ref(t.get())</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='reference_wrapper,cref'></a></span><span class='indexparent'><a class='index' id='cref,reference_wrapper'></a></span><code class='itemdecl'>
template &lt;class T&gt; reference_wrapper&lt;const T&gt; cref(const T&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.helpers-3'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.helpers-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>reference_wrapper &lt;const T&gt;(t)</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='reference_wrapper,cref'></a></span><span class='indexparent'><a class='index' id='cref,reference_wrapper'></a></span><code class='itemdecl'>
template &lt;class T&gt; reference_wrapper&lt;const T&gt; cref(reference_wrapper&lt;T&gt; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='refwrap.helpers-4'><div class='marginalizedparent'><a class='marginalized' href='#refwrap.helpers-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cref(t.get());</span>
</p></div></div></div></div><div id='arithmetic.operations'><h3 ><a class='secnum' href='#arithmetic.operations' style='min-width:103pt'>20.9.4</a> Arithmetic operations <a class='abbr_ref' href='arithmetic.operations'>[arithmetic.operations]</a></h3><div class='para' id='arithmetic.operations-1'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-1'>1</a></div><p >The library provides basic function object classes for all of the arithmetic
operators in the language (<a href='expr.mul'>[expr.mul]</a>, <a href='expr.add'>[expr.add]</a>).</p><p ><span class='indexparent'><a class='index' id='plus'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct plus {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p></div><div class='itemdescr'></div><div class='para' id='arithmetic.operations-2'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-2'>2</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span>
returns
<span class='texttt'>x + y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='minus'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct minus {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-3'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-3'>3</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span>
returns
<span class='texttt'>x - y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='multiplies'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct multiplies {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-4'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-4'>4</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span>
returns
<span class='texttt'>x * y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='divides'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct divides {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-5'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-5'>5</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span>
returns
<span class='texttt'>x / y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='modulus'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct modulus {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-6'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-6'>6</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x % y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='negate'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct negate {
  constexpr T operator()(const T&amp; x) const;
  typedef T argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-7'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-7'>7</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>-x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='plus<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct plus&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) + std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-8'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-8'>8</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) + std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='minus<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct minus&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) - std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-9'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-9'>9</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) - std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='multiplies<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct multiplies&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) * std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-10'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-10'>10</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) * std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='divides<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct divides&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) / std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-11'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-11'>11</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) / std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='modulus<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct modulus&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) % std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-12'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-12'>12</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) % std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='negate<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct negate&lt;void&gt; {
  template &lt;class T&gt; constexpr auto operator()(T&amp;&amp; t) const
    -&gt; decltype(-std::forward&lt;T&gt;(t));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='arithmetic.operations-13'><div class='marginalizedparent'><a class='marginalized' href='#arithmetic.operations-13'>13</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>-std::forward&lt;T&gt;(t)</span>.
</p></div></div></div><div id='comparisons'><h3 ><a class='secnum' href='#comparisons' style='min-width:103pt'>20.9.5</a> Comparisons <a class='abbr_ref' href='comparisons'>[comparisons]</a></h3><div class='para' id='comparisons-1'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-1'>1</a></div><p >The library provides basic function object classes for all of the comparison
operators in the language (<a href='expr.rel'>[expr.rel]</a>, <a href='expr.eq'>[expr.eq]</a>).</p><p ><span class='indexparent'><a class='index' id='equal_to'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct equal_to {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p></div><div class='itemdescr'></div><div class='para' id='comparisons-2'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-2'>2</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x == y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='not_equal_to'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct not_equal_to {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-3'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-3'>3</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x != y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='greater'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct greater {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-4'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-4'>4</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x &gt; y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='less'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct less {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-5'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-5'>5</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x &lt; y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='greater_equal'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct greater_equal {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-6'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-6'>6</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x &gt;= y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='less_equal'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct less_equal {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-7'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-7'>7</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x &lt;= y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='equal_to<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct equal_to&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) == std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-8'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-8'>8</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) == std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='not_equal_to<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct not_equal_to&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) != std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-9'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-9'>9</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) != std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='greater<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct greater&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) &gt; std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-10'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-10'>10</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) &gt; std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='less<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct less&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) &lt; std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-11'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-11'>11</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) &lt; std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='greater_equal<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct greater_equal&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) &gt;= std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-12'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-12'>12</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) &gt;= std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='less_equal<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct less_equal&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) &lt;= std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='comparisons-13'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-13'>13</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) &lt;= std::forward&lt;U&gt;(u)</span>.
</p></div></div><div class='para' id='comparisons-14'><div class='marginalizedparent'><a class='marginalized' href='#comparisons-14'>14</a></div><p >For templates <span class='texttt'>greater</span>, <span class='texttt'>less</span>, <span class='texttt'>greater_equal</span>, and
<span class='texttt'>less_equal</span>, the specializations for any pointer type yield a total order,
even if the built-in operators <span class='texttt'>&lt;</span>, <span class='texttt'>&gt;</span>, <span class='texttt'>&lt;=</span>, <span class='texttt'>&gt;=</span>
do not.</p></div></div><div id='logical.operations'><h3 ><a class='secnum' href='#logical.operations' style='min-width:103pt'>20.9.6</a> Logical operations <a class='abbr_ref' href='logical.operations'>[logical.operations]</a></h3><div class='para' id='logical.operations-1'><div class='marginalizedparent'><a class='marginalized' href='#logical.operations-1'>1</a></div><p >The library provides basic function object classes for all of the logical
operators in the language (<a href='expr.log.and'>[expr.log.and]</a>, <a href='expr.log.or'>[expr.log.or]</a>, <a href='expr.unary.op'>[expr.unary.op]</a>).</p><p ><span class='indexparent'><a class='index' id='logical_and'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct logical_and {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p></div><div class='itemdescr'></div><div class='para' id='logical.operations-2'><div class='marginalizedparent'><a class='marginalized' href='#logical.operations-2'>2</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x &amp;&amp; y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='logical_or'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct logical_or {
  constexpr bool operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef bool result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='logical.operations-3'><div class='marginalizedparent'><a class='marginalized' href='#logical.operations-3'>3</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x || y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='logical_not'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct logical_not {
  constexpr bool operator()(const T&amp; x) const;
  typedef T argument_type;
  typedef bool result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='logical.operations-4'><div class='marginalizedparent'><a class='marginalized' href='#logical.operations-4'>4</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>!x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='logical_and<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct logical_and&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) &amp;&amp; std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='logical.operations-5'><div class='marginalizedparent'><a class='marginalized' href='#logical.operations-5'>5</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) &amp;&amp; std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='logical_or<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct logical_or&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) || std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='logical.operations-6'><div class='marginalizedparent'><a class='marginalized' href='#logical.operations-6'>6</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) || std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='logical_not<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct logical_not&lt;void&gt; {
  template &lt;class T&gt; constexpr auto operator()(T&amp;&amp; t) const
    -&gt; decltype(!std::forward&lt;T&gt;(t));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='logical.operations-7'><div class='marginalizedparent'><a class='marginalized' href='#logical.operations-7'>7</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>!std::forward&lt;T&gt;(t)</span>.
</p></div></div></div><div id='bitwise.operations'><h3 ><a class='secnum' href='#bitwise.operations' style='min-width:103pt'>20.9.7</a> Bitwise operations <a class='abbr_ref' href='bitwise.operations'>[bitwise.operations]</a></h3><div class='para' id='bitwise.operations-1'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-1'>1</a></div><p >The library provides basic function object classes for all of the bitwise
operators in the language (<a href='expr.bit.and'>[expr.bit.and]</a>, <a href='expr.or'>[expr.or]</a>,
<a href='expr.xor'>[expr.xor]</a>, <a href='expr.unary.op'>[expr.unary.op]</a>).</p><p ><span class='indexparent'><a class='index' id='bit_and'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct bit_and {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p></div><div class='itemdescr'></div><div class='para' id='bitwise.operations-2'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-2'>2</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x &amp; y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bit_or'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct bit_or {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='bitwise.operations-3'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-3'>3</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x | y</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bit_xor'></a></span><code class='itemdecl'>
template &lt;class T = void&gt; struct bit_xor {
  constexpr T operator()(const T&amp; x, const T&amp; y) const;
  typedef T first_argument_type;
  typedef T second_argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='bitwise.operations-4'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-4'>4</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>x ^ y</span>.
</p></div></div><p ><code class='itemdecl'>
template &lt;class T = void&gt; struct bit_not {
  constexpr T operator()(const T&amp; x) const;
  typedef T argument_type;
  typedef T result_type;
};
</code></p><div class='itemdescr'></div><div class='para' id='bitwise.operations-5'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-5'>5</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>~x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bit_and<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct bit_and&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) &amp; std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='bitwise.operations-6'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-6'>6</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) &amp; std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bit_or<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct bit_or&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) | std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='bitwise.operations-7'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-7'>7</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) | std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bit_xor<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct bit_xor&lt;void&gt; {
  template &lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) ^ std::forward&lt;U&gt;(u));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='bitwise.operations-8'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-8'>8</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>std::forward&lt;T&gt;(t) ^ std::forward&lt;U&gt;(u)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='bit_not<>'></a></span><code class='itemdecl'>
template &lt;&gt; struct bit_not&lt;void&gt; {
  template &lt;class T&gt; constexpr auto operator()(T&amp;&amp; t) const
    -&gt; decltype(~std::forward&lt;T&gt;(t));

  typedef <i><span class='texttt'>unspecified</span></i> is_transparent;
};
</code></p><div class='itemdescr'></div><div class='para' id='bitwise.operations-9'><div class='marginalizedparent'><a class='marginalized' href='#bitwise.operations-9'>9</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>~std::forward&lt;T&gt;(t)</span>.
</p></div></div></div><div id='negators'><h3 ><a class='secnum' href='#negators' style='min-width:103pt'>20.9.8</a> Negators <a class='abbr_ref' href='negators'>[negators]</a></h3><div class='para' id='negators-1'><div class='marginalizedparent'><a class='marginalized' href='#negators-1'>1</a></div><p >Negators <span class='texttt'>not1</span> and <span class='texttt'>not2</span> take a unary and a binary predicate,
respectively, and return their complements (<a href='expr.unary.op'>[expr.unary.op]</a>).</p><p ><span class='indexparent'><a class='index' id='unary_negate'></a></span><code class='itemdecl'>
template &lt;class Predicate&gt;
  class unary_negate {
public:
  constexpr explicit unary_negate(const Predicate&amp; pred);
  constexpr bool operator()(const typename Predicate::argument_type&amp; x) const;
  typedef typename Predicate::argument_type argument_type;
  typedef bool result_type;
};
</code></p></div><div class='itemdescr'></div><div class='para' id='negators-2'><div class='marginalizedparent'><a class='marginalized' href='#negators-2'>2</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>!pred(x)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='not1'></a></span><code class='itemdecl'>
template &lt;class Predicate&gt;
  constexpr unary_negate&lt;Predicate&gt; not1(const Predicate&amp; pred);
</code></p><div class='itemdescr'></div><div class='para' id='negators-3'><div class='marginalizedparent'><a class='marginalized' href='#negators-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>unary_negate&lt;Predicate&gt;(pred)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='binary_negate'></a></span><code class='itemdecl'>
template &lt;class Predicate&gt;
  class binary_negate {
  public:
    constexpr explicit binary_negate(const Predicate&amp; pred);
    constexpr bool operator()(const typename Predicate::first_argument_type&amp; x,
        const typename Predicate::second_argument_type&amp; y) const;
  typedef typename Predicate::first_argument_type first_argument_type;
  typedef typename Predicate::second_argument_type second_argument_type;
  typedef bool result_type;
  };
</code></p><div class='itemdescr'></div><div class='para' id='negators-4'><div class='marginalizedparent'><a class='marginalized' href='#negators-4'>4</a></div><div class='itemdescr'><p ><span class='texttt'>operator()</span> returns <span class='texttt'>!pred(x,y)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='not2'></a></span><code class='itemdecl'>
template &lt;class Predicate&gt;
  constexpr binary_negate&lt;Predicate&gt; not2(const Predicate&amp; pred);
</code></p><div class='itemdescr'></div><div class='para' id='negators-5'><div class='marginalizedparent'><a class='marginalized' href='#negators-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>binary_negate&lt;Predicate&gt;(pred)</span>.
</p></div></div></div><div id='func.bind'><h3 ><a class='secnum' href='#func.bind' style='min-width:103pt'>20.9.9</a> Function object binders <a class='abbr_ref' href='func.bind'>[func.bind]</a></h3><p ><span class='indexparent'><a class='index' id='function_object,binders'></a></span></p><div class='para' id='func.bind-1'><div class='marginalizedparent'><a class='marginalized' href='#func.bind-1'>1</a></div><p >This subclause describes a uniform mechanism for binding
arguments of callable objects.</p></div><div id='func.bind.isbind'><h4 ><a class='secnum' href='#func.bind.isbind' style='min-width:118pt'>20.9.9.1</a> Class template <span class='texttt'>is_bind_expression</span> <a class='abbr_ref' href='func.bind.isbind'>[func.bind.isbind]</a></h4><p ><span class='indexparent'><a class='index' id='is_bind_expression'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; struct is_bind_expression; <span class='comment'>// see below
</span>}
</pre><div class='para' id='func.bind.isbind-1'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.isbind-1'>1</a></div><p ><span class='texttt'>is_bind_expression</span> can be used to detect function objects
generated by <span class='texttt'>bind</span>. <span class='texttt'>bind</span>
uses <span class='texttt'>is_bind_expression</span> to detect subexpressions.</p></div><div class='para' id='func.bind.isbind-2'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.isbind-2'>2</a></div><p >Instantiations of the <span class='texttt'>is_bind_expression</span> template shall meet
the UnaryTypeTrait requirements (<a href='meta.rqmts'>[meta.rqmts]</a>). The implementation
shall provide a definition that has a BaseCharacteristic of
<span class='texttt'>true_type</span> if <span class='texttt'>T</span> is a type returned from <span class='texttt'>bind</span>,
otherwise it shall have a BaseCharacteristic of <span class='texttt'>false_type</span>.
A program may specialize this template for a user-defined type <span class='texttt'>T</span>
to have a BaseCharacteristic of <span class='texttt'>true_type</span> to indicate that
<span class='texttt'>T</span> should be treated as a subexpression in a <span class='texttt'>bind</span> call.</p></div></div><div id='func.bind.isplace'><h4 ><a class='secnum' href='#func.bind.isplace' style='min-width:118pt'>20.9.9.2</a> Class template <span class='texttt'>is_placeholder</span> <a class='abbr_ref' href='func.bind.isplace'>[func.bind.isplace]</a></h4><p ><span class='indexparent'><a class='index' id='is_placeholder'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; struct is_placeholder; <span class='comment'>// see below
</span>}
</pre><div class='para' id='func.bind.isplace-1'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.isplace-1'>1</a></div><p ><span class='texttt'>is_placeholder</span> can be used to detect the standard placeholders
<span class='texttt'>_1</span>, <span class='texttt'>_2</span>, and so on. <span class='texttt'>bind</span> uses
<span class='texttt'>is_placeholder</span> to detect placeholders.</p></div><div class='para' id='func.bind.isplace-2'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.isplace-2'>2</a></div><p >Instantiations of the <span class='texttt'>is_placeholder</span> template shall meet
the UnaryTypeTrait requirements (<a href='meta.rqmts'>[meta.rqmts]</a>). The implementation
shall provide a definition that has the BaseCharacteristic of
<span class='texttt'>integral_constant&lt;int, J&gt;</span> if <span class='texttt'>T</span> is the type of
<span class='texttt'>std::placeholders::_J</span>, otherwise it shall have a
BaseCharacteristic of <span class='texttt'>integral_constant&lt;int, 0&gt;</span>. A program
may specialize this template for a user-defined type <span class='texttt'>T</span> to
have a BaseCharacteristic of <span class='texttt'>integral_constant&lt;int, <i>N</i>&gt;</span>
with <span class='texttt'><i>N</i> &gt; 0</span> to indicate that <span class='texttt'>T</span> should be
treated as a placeholder type.</p></div></div><div id='func.bind.bind'><h4 ><a class='secnum' href='#func.bind.bind' style='min-width:118pt'>20.9.9.3</a> Function template <span class='texttt'>bind</span> <a class='abbr_ref' href='func.bind.bind'>[func.bind.bind]</a></h4><p ><span class='indexparent'><a class='index' id='bind'></a></span></p><div class='para' id='func.bind.bind-1'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-1'>1</a></div><p >In the text that follows, the following names have the following meanings:</p><ul class='itemize'><li id='func.bind.bind-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.1'>(1.1)</a></div><p ><span class='texttt'>FD</span> is the type <span class='texttt'>decay_t&lt;F&gt;</span>,
</p></li><li id='func.bind.bind-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.2'>(1.2)</a></div><p ><span class='texttt'>fd</span> is an lvalue of type <span class='texttt'>FD</span> constructed from <span class='texttt'>std::forward&lt;F&gt;(f)</span>,
</p></li><li id='func.bind.bind-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.3'>(1.3)</a></div><p ><span class='texttt'>Ti</span> is the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> type in the template parameter pack <span class='texttt'>BoundArgs</span>,
</p></li><li id='func.bind.bind-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.4'>(1.4)</a></div><p ><span class='texttt'>TiD</span> is the type <span class='texttt'>decay_t&lt;Ti&gt;</span>,
</p></li><li id='func.bind.bind-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.5'>(1.5)</a></div><p ><span class='texttt'>ti</span> is the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> argument in the function parameter pack <span class='texttt'>bound_args</span>,
</p></li><li id='func.bind.bind-1.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.6'>(1.6)</a></div><p ><span class='texttt'>tid</span> is an lvalue of type <span class='texttt'>TiD</span> constructed from <span class='texttt'>std::forward&lt;Ti&gt;(ti)</span>,
</p></li><li id='func.bind.bind-1.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.7'>(1.7)</a></div><p ><span class='texttt'>Uj</span> is the <span class='math'><span class='mathalpha'>j</span><sup ><span class='mathalpha'>th</span></sup></span> deduced type of the <span class='texttt'>UnBoundArgs&amp;&amp;...</span> parameter
  of the forwarding call wrapper, and
</p></li><li id='func.bind.bind-1.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-1.8'>(1.8)</a></div><p ><span class='texttt'>uj</span> is the <span class='math'><span class='mathalpha'>j</span><sup ><span class='mathalpha'>th</span></sup></span> argument associated with <span class='texttt'>Uj</span>.
</p></li></ul><p ><span class='indexparent'><a class='index' id='bind'></a></span>
<code class='itemdecl'>
template&lt;class F, class... BoundArgs&gt;
  <i><span class='texttt'>unspecified</span></i> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);
</code></p></div><div class='itemdescr'></div><div class='para' id='func.bind.bind-2'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>is_constructible&lt;FD, F&gt;::value</span> shall be <span class='texttt'>true</span>. For each <span class='texttt'>Ti</span>
in <span class='texttt'>BoundArgs</span>, <span class='texttt'>is_constructible&lt;TiD, Ti&gt;::value</span> shall be <span class='texttt'>true</span>.
<span class='texttt'><i>INVOKE</i> (fd, w1, w2, ...,
wN)</span> (<a href='func.require'>[func.require]</a>) shall be a valid expression for some
values <i>w1, w2, ..., wN</i>, where
<span class='texttt'>N == sizeof...(bound_args)</span>.</p></div></div><div class='para' id='func.bind.bind-3'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> A forwarding call wrapper <span class='texttt'>g</span> with a weak result
type (<a href='func.require'>[func.require]</a>). The effect of <span class='texttt'>g(u1, u2, ..., uM)</span> shall
be <span class='texttt'><i>INVOKE</i>(fd, std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ..., std::forward&lt;VN&gt;(vN), result_of_t&lt;FD <i>cv</i> &amp;
(V1, V2, ..., VN)&gt;)</span>, where <span class='texttt'><i>cv</i></span> represents the
<i>cv</i>-qualifiers of <span class='texttt'>g</span> and the values and types of the bound
arguments <span class='texttt'>v1, v2, ..., vN</span> are determined as specified below.
The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <span class='texttt'>FD</span> or of any of the types
<span class='texttt'>TiD</span> throws an exception.</p></div></div><div class='para' id='func.bind.bind-4'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing unless the construction of
<span class='texttt'>fd</span> or of one of the values <span class='texttt'>tid</span> throws an exception.</p></div></div><div class='para' id='func.bind.bind-5'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> The return type shall satisfy the requirements of <span class='texttt'>MoveConstructible</span>. If all
of <span class='texttt'>FD</span> and <span class='texttt'>TiD</span> satisfy the requirements of <span class='texttt'>CopyConstructible</span>, then the
return type shall satisfy the requirements of <span class='texttt'>CopyConstructible</span>. [&nbsp;<i>Note:</i> This implies
that all of <span class='texttt'>FD</span> and <span class='texttt'>TiD</span> are <span class='texttt'>MoveConstructible</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='bind'></a></span>
<code class='itemdecl'>
template&lt;class R, class F, class... BoundArgs&gt;
  <i><span class='texttt'>unspecified</span></i> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);
</code></p><div class='itemdescr'></div><div class='para' id='func.bind.bind-6'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>is_constructible&lt;FD, F&gt;::value</span> shall be <span class='texttt'>true</span>. For each <span class='texttt'>Ti</span>
in <span class='texttt'>BoundArgs</span>, <span class='texttt'>is_constructible&lt;TiD, Ti&gt;::value</span> shall be <span class='texttt'>true</span>.
<span class='texttt'><i>INVOKE</i>(fd, w1, w2, ..., wN)</span> shall be  a valid
expression for some
values <i>w1, w2, ..., wN</i>, where
<span class='texttt'>N == sizeof...(bound_args)</span>.</p></div></div><div class='para' id='func.bind.bind-7'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> A forwarding call wrapper <span class='texttt'>g</span> with a nested  type
<span class='texttt'>result_type</span> defined as a synonym for <span class='texttt'>R</span>.  The effect of
<span class='texttt'>g(u1, u2, ..., uM)</span> shall be <span class='texttt'><i>INVOKE</i>(fd,
std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ...,
std::forward&lt;VN&gt;(vN), R)</span>, where the values and types of the bound
arguments <span class='texttt'>v1, v2, ..., vN</span> are determined as specified below.
The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <span class='texttt'>FD</span> or of any of the types
<span class='texttt'>TiD</span> throws an exception.</p></div></div><div class='para' id='func.bind.bind-8'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-8'>8</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing unless the construction of
<span class='texttt'>fd</span> or of one of the values <span class='texttt'>tid</span> throws an exception.</p></div></div><div class='para' id='func.bind.bind-9'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-9'>9</a></div><div class='itemdescr'><p ><i>Remarks:</i> The return type shall satisfy the requirements of <span class='texttt'>MoveConstructible</span>. If all
of <span class='texttt'>FD</span> and <span class='texttt'>TiD</span> satisfy the requirements of <span class='texttt'>CopyConstructible</span>, then the
return type shall satisfy the requirements of <span class='texttt'>CopyConstructible</span>. [&nbsp;<i>Note:</i> This implies
that all of <span class='texttt'>FD</span> and <span class='texttt'>TiD</span> are <span class='texttt'>MoveConstructible</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><div class='para' id='func.bind.bind-10'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.bind-10'>10</a></div><p ><span class='indexparent'><a class='index' id='bound_arguments'></a></span>The values of the <i>bound arguments</i> <span class='texttt'>v1, v2, ..., vN</span> and their
corresponding types <span class='texttt'>V1, V2, ..., VN</span> depend on the
types <span class='texttt'>TiD</span> derived from
the call to <span class='texttt'>bind</span> and the
<i>cv</i>-qualifiers <i>cv</i> of the call wrapper <span class='texttt'>g</span> as follows:</p><ul class='itemize'><li id='func.bind.bind-10.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-10.1'>(10.1)</a></div><p >if <span class='texttt'>TiD</span> is <span class='texttt'>reference_wrapper&lt;T&gt;</span>, the
argument is <span class='texttt'>tid.get()</span> and its type <span class='texttt'>Vi</span> is <span class='texttt'>T&amp;</span>;</p></li><li id='func.bind.bind-10.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-10.2'>(10.2)</a></div><p >if the value of <span class='texttt'>is_bind_expression&lt;TiD&gt;::value</span>
is <span class='texttt'>true</span>, the argument is <span class='texttt'>tid(std::forward&lt;Uj&gt;(<span class='discretionary'></span>uj)...)</span>  and its
type <span class='texttt'>Vi</span> is
<span class='texttt'>result_of_t&lt;TiD <i>cv</i> &amp; (Uj&amp;&amp;...)&gt;&amp;&amp;</span>;</p></li><li id='func.bind.bind-10.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-10.3'>(10.3)</a></div><p >if the value <span class='texttt'>j</span> of <span class='texttt'>is_placeholder&lt;TiD&gt;::value</span>
is not zero, the  argument is <span class='texttt'>std::forward&lt;Uj&gt;(uj)</span>
and its type <span class='texttt'>Vi</span>
is <span class='texttt'>Uj&amp;&amp;</span>;</p></li><li id='func.bind.bind-10.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.bind.bind-10.4'>(10.4)</a></div><p >otherwise, the value is <span class='texttt'>tid</span> and its type <span class='texttt'>Vi</span>
is <span class='texttt'>TiD <i>cv</i> &amp;</span>.
</p></li></ul></div></div><div id='func.bind.place'><h4 ><a class='secnum' href='#func.bind.place' style='min-width:118pt'>20.9.9.4</a> Placeholders <a class='abbr_ref' href='func.bind.place'>[func.bind.place]</a></h4><p ><span class='indexparent'><a class='index' id='placeholders'></a></span><span class='indexparent'><a class='index' id='1'></a></span></p><pre class='codeblock'>
namespace std {
  namespace placeholders {
    <span class='comment'>// M is the implementation-defined number of placeholders
</span>    extern <i><span class='texttt'>unspecified</span></i> _1;
    extern <i><span class='texttt'>unspecified</span></i> _2;
                .
                .
                .
    extern <i>unspecified</i> _M;
  }
}
</pre><div class='para' id='func.bind.place-1'><div class='marginalizedparent'><a class='marginalized' href='#func.bind.place-1'>1</a></div><p >All placeholder types shall be <span class='texttt'>DefaultConstructible</span> and
<span class='texttt'>CopyConstructible</span>, and their default constructors and copy/move
constructors shall not throw exceptions. It is <span class='indexparent'><a class='index' id='assignability_of_placeholder_objects'></a></span>implementation-defined whether
placeholder types are <span class='texttt'>CopyAssignable</span>. <span class='texttt'>CopyAssignable</span> placeholders' copy
assignment operators shall not throw exceptions.<span class='indexparent'><a class='index' id='bind'></a></span><span class='indexparent'><a class='index' id='function_object,binders'></a></span></p></div></div></div><div id='func.memfn'><h3 ><a class='secnum' href='#func.memfn' style='min-width:103pt'>20.9.10</a> Function template <span class='texttt'>mem_fn</span> <a class='abbr_ref' href='func.memfn'>[func.memfn]</a></h3><p ><span class='indexparent'><a class='index' id='function_object,mem_fn'></a></span></p><p ><span class='indexparent'><a class='index' id='mem_fn'></a></span><code class='itemdecl'>
template&lt;class R, class T&gt; <i><span class='texttt'>unspecified</span></i> mem_fn(R T::* pm);
</code></p><div class='itemdescr'></div><div class='para' id='func.memfn-1'><div class='marginalizedparent'><a class='marginalized' href='#func.memfn-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> A simple call wrapper (<a href='func.def'>[func.def]</a>) <span class='texttt'>fn</span>
such that the expression <span class='texttt'>fn(t, a2, ..., aN)</span> is equivalent
to <span class='texttt'><i>INVOKE</i>(pm, t, a2, ..., aN)</span> (<a href='func.require'>[func.require]</a>).
<span class='texttt'>fn</span> shall have a nested type <span class='texttt'>result_type</span> that is a synonym
for the return type of <span class='texttt'>pm</span> when <span class='texttt'>pm</span> is a pointer to
member function.</p></div></div><div class='para' id='func.memfn-2'><div class='marginalizedparent'><a class='marginalized' href='#func.memfn-2'>2</a></div><div class='itemdescr'><p >The simple call wrapper shall
define two nested types named <span class='texttt'>argument_type</span> and <span class='texttt'>result_type</span> as synonyms
for <span class='texttt'><i>cv</i> T*</span> and <span class='texttt'>Ret</span>, respectively,
when <span class='texttt'>pm</span> is
a pointer to member function with cv-qualifier <i>cv</i> and taking no
arguments, where <i>Ret</i> is <span class='texttt'>pm</span>'s return type.</p></div></div><div class='para' id='func.memfn-3'><div class='marginalizedparent'><a class='marginalized' href='#func.memfn-3'>3</a></div><div class='itemdescr'><p >The simple call wrapper shall
define three nested types named <span class='texttt'>first_argument_type</span>,
<span class='texttt'>second_argument_type</span>, and <span class='texttt'>result_type</span> as synonyms
for <span class='texttt'><i>cv</i> T*</span>, <span class='texttt'>T1</span>, and <span class='texttt'>Ret</span>, respectively,
when <span class='texttt'>pm</span> is
a pointer to member function with cv-qualifier <i>cv</i> and taking
one argument of type <span class='texttt'>T1</span>, where <i>Ret</i> is <span class='texttt'>pm</span>'s return type.</p></div></div><div class='para' id='func.memfn-4'><div class='marginalizedparent'><a class='marginalized' href='#func.memfn-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='function_object,mem_fn'></a></span></p></div><div id='func.wrap'><h3 ><a class='secnum' href='#func.wrap' style='min-width:103pt'>20.9.11</a> Polymorphic function wrappers <a class='abbr_ref' href='func.wrap'>[func.wrap]</a></h3><p ><span class='indexparent'><a class='index' id='function_object,wrapper'></a></span></p><div class='para' id='func.wrap-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap-1'>1</a></div><p >This subclause describes a polymorphic wrapper class that
encapsulates arbitrary callable objects.</p></div><div id='func.wrap.badcall'><h4 ><a class='secnum' href='#func.wrap.badcall' style='min-width:118pt'>20.9.11.1</a> Class <span class='texttt'>bad_function_call</span> <a class='abbr_ref' href='func.wrap.badcall'>[func.wrap.badcall]</a></h4><p ><span class='indexparent'><a class='index' id='bad_function_call'></a></span><span class='indexparent'><a class='index' id='exception,bad_function_call'></a></span></p><div class='para' id='func.wrap.badcall-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.badcall-1'>1</a></div><p >An exception of type <span class='texttt'>bad_function_call</span> is thrown by
<span class='texttt'>function::operator()</span> (<a href='func.wrap.func.inv'>[func.wrap.func.inv]</a>)
when the function wrapper object has no target.</p><pre class='codeblock'>
namespace std {
  class bad_function_call : public std::exception {
  public:
    <span class='comment'>// <a href='func.wrap.badcall.const'>[func.wrap.badcall.const]</a>, constructor:
</span>    bad_function_call() noexcept;
  };
} <span class='comment'>// namespace std
</span></pre></div><div id='func.wrap.badcall.const'><h4 ><a class='secnum' href='#func.wrap.badcall.const' style='min-width:133pt'>20.9.11.1.1</a> <span class='texttt'>bad_function_call</span> constructor <a class='abbr_ref' href='func.wrap.badcall.const'>[func.wrap.badcall.const]</a></h4><p ><span class='indexparent'><a class='index' id='bad_function_call,bad_function_call'></a></span><code class='itemdecl'>
bad_function_call() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.badcall.const-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.badcall.const-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> constructs a <span class='texttt'>bad_function_call</span> object.
</p></div></div></div></div><div id='func.wrap.func'><h4 ><a class='secnum' href='#func.wrap.func' style='min-width:118pt'>20.9.11.2</a> Class template <span class='texttt'>function</span> <a class='abbr_ref' href='func.wrap.func'>[func.wrap.func]</a></h4><p ><span class='indexparent'><a class='index' id='function'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class&gt; class function; <span class='comment'>// undefined
</span>
  template&lt;class R, class... ArgTypes&gt;
  class function&lt;R(ArgTypes...)&gt; {
  public:
    typedef R result_type;
    typedef T1 argument_type;           <span class='comment'>// only if <span class='texttt'>sizeof...(ArgTypes) == 1</span> and
</span>                                        <span class='comment'>// the type in <span class='texttt'>ArgTypes</span> is <span class='texttt'>T1</span>
</span>    typedef T1 first_argument_type;     <span class='comment'>// only if <span class='texttt'>sizeof...(ArgTypes) == 2</span> and
</span>                                        <span class='comment'>// <span class='texttt'>ArgTypes</span> contains <span class='texttt'>T1</span> and <span class='texttt'>T2</span>
</span>    typedef T2 second_argument_type;    <span class='comment'>// only if <span class='texttt'>sizeof...(ArgTypes) == 2</span> and
</span>                                        <span class='comment'>// <span class='texttt'>ArgTypes</span> contains <span class='texttt'>T1</span> and <span class='texttt'>T2</span>
</span>
    <span class='comment'>// <a href='func.wrap.func.con'>[func.wrap.func.con]</a>, construct/copy/destroy:
</span>    function() noexcept;
    function(nullptr_t) noexcept;
    function(const function&amp;);
    function(function&amp;&amp;);
    template&lt;class F&gt; function(F);
    template&lt;class A&gt; function(allocator_arg_t, const A&amp;) noexcept;
    template&lt;class A&gt; function(allocator_arg_t, const A&amp;,
      nullptr_t) noexcept;
    template&lt;class A&gt; function(allocator_arg_t, const A&amp;,
      const function&amp;);
    template&lt;class A&gt; function(allocator_arg_t, const A&amp;,
      function&amp;&amp;);
    template&lt;class F, class A&gt; function(allocator_arg_t, const A&amp;, F);

    function&amp; operator=(const function&amp;);
    function&amp; operator=(function&amp;&amp;);
    function&amp; operator=(nullptr_t);
    template&lt;class F&gt; function&amp; operator=(F&amp;&amp;);
    template&lt;class F&gt; function&amp; operator=(reference_wrapper&lt;F&gt;) noexcept;

    ~function();

    <span class='comment'>// <a href='func.wrap.func.mod'>[func.wrap.func.mod]</a>, function modifiers:
</span>    void swap(function&amp;) noexcept;
    template&lt;class F, class A&gt; void assign(F&amp;&amp;, const A&amp;);

    <span class='comment'>// <a href='func.wrap.func.cap'>[func.wrap.func.cap]</a>, function capacity:
</span>    explicit operator bool() const noexcept;

    <span class='comment'>// <a href='func.wrap.func.inv'>[func.wrap.func.inv]</a>, function invocation:
</span>    R operator()(ArgTypes...) const;

    <span class='comment'>// <a href='func.wrap.func.targ'>[func.wrap.func.targ]</a>, function target access:
</span>    const std::type_info&amp; target_type() const noexcept;
    template&lt;class T&gt;       T* target() noexcept;
    template&lt;class T&gt; const T* target() const noexcept;

  };

  <span class='comment'>// <a href='func.wrap.func.nullptr'>[func.wrap.func.nullptr]</a>, Null pointer comparisons:
</span>  template &lt;class R, class... ArgTypes&gt;
    bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;

  template &lt;class R, class... ArgTypes&gt;
    bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;

  template &lt;class R, class... ArgTypes&gt;
    bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;

  template &lt;class R, class... ArgTypes&gt;
    bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;

  <span class='comment'>// <a href='func.wrap.func.alg'>[func.wrap.func.alg]</a>, specialized algorithms:
</span>  template &lt;class R, class... ArgTypes&gt;
    void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);

  template&lt;class R, class... ArgTypes, class Alloc&gt;
    struct uses_allocator&lt;function&lt;R(ArgTypes...)&gt;, Alloc&gt;
      : true_type { };
}
</pre><div class='para' id='func.wrap.func-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func-1'>1</a></div><p >The <span class='texttt'>function</span> class template provides polymorphic wrappers that
generalize the notion of a function pointer. Wrappers can store, copy,
and call arbitrary callable objects (<a href='func.def'>[func.def]</a>), given a call
signature (<a href='func.def'>[func.def]</a>), allowing functions to be first-class objects.</p></div><div class='para' id='func.wrap.func-2'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func-2'>2</a></div><p ><span class='indexparent'><a class='index' id='callable_object'></a></span>A callable object <span class='texttt'>f</span> of type <span class='texttt'>F</span>
is <a class='hidden_link' href='#def:Callable' id='def:Callable'><i>Callable</i></a> for argument
types <span class='texttt'>ArgTypes</span>
and return type <span class='texttt'>R</span>
if the expression
<span class='texttt'><i>INVOKE</i>(f, declval&lt;ArgTypes&gt;()..., R)</span>,
considered as an unevaluated operand (Clause <a href='expr'>[expr]</a>), is
well formed (<a href='func.require'>[func.require]</a>).</p></div><div class='para' id='func.wrap.func-3'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func-3'>3</a></div><p >The <span class='texttt'>function</span> class template is a call
wrapper (<a href='func.def'>[func.def]</a>) whose call signature (<a href='func.def'>[func.def]</a>)
is <span class='texttt'>R(ArgTypes...)</span>.</p></div><div id='func.wrap.func.con'><h4 ><a class='secnum' href='#func.wrap.func.con' style='min-width:133pt'>20.9.11.2.1</a> <span class='texttt'>function</span> construct/copy/destroy <a class='abbr_ref' href='func.wrap.func.con'>[func.wrap.func.con]</a></h4><div class='para' id='func.wrap.func.con-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-1'>1</a></div><p >When any <span class='texttt'>function</span> constructor that takes a first argument of type
<span class='texttt'>allocator_arg_t</span> is invoked, the second argument shall have a type that conforms
to the requirements for Allocator (Table <a href='allocator.requirements'>[allocator.requirements]</a>). A copy of the
allocator argument is used to allocate memory, if necessary, for the internal data
structures of the constructed <span class='texttt'>function</span> object.</p><p ><span class='indexparent'><a class='index' id='function,function'></a></span>
<code class='itemdecl'>
function() noexcept;
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-2'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='function,function'></a></span>
<span class='indexparent'><a class='index' id='function,function'></a></span>
<code class='itemdecl'>
function(nullptr_t) noexcept;
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, nullptr_t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-3'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-3'>3</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='function,function'></a></span>
<span class='indexparent'><a class='index' id='function,function'></a></span>
<code class='itemdecl'>
function(const function&amp; f);
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, const function&amp; f);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-4'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-4'>4</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!*this</span> if <span class='texttt'>!f</span>; otherwise,
<span class='texttt'>*this</span> targets a copy of <span class='texttt'>f.target()</span>.</p></div></div><div class='para' id='func.wrap.func.con-5'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i> shall not throw exceptions if <span class='texttt'>f</span>'s target is
a callable object passed via <span class='texttt'>reference_wrapper</span> or
a function pointer. Otherwise, may throw <span class='texttt'>bad_alloc</span>
or any exception thrown by the copy constructor of the stored callable object.
[&nbsp;<i>Note:</i> Implementations are encouraged to avoid the use of
dynamically allocated memory for small callable objects, for example, where
<span class='texttt'>f</span>'s target is an object holding only a pointer or reference
to an object and a member function pointer. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='function,function'></a></span>
<span class='indexparent'><a class='index' id='function,function'></a></span>
<code class='itemdecl'>
function(function&amp;&amp; f);
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, function&amp;&amp; f);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-6'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>!f</span>, <span class='texttt'>*this</span> has
no target; otherwise, move-constructs the target of <span class='texttt'>f</span>
into the target of <span class='texttt'>*this</span>, leaving <span class='texttt'>f</span> in
a valid state with an unspecified value.
</p></div></div><p ><span class='indexparent'><a class='index' id='function,function'></a></span>
<span class='indexparent'><a class='index' id='function,function'></a></span>
<code class='itemdecl'>
template&lt;class F&gt; function(F f);
template &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-7'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>F</span> shall be <span class='texttt'>CopyConstructible</span>.</p></div></div><div class='para' id='func.wrap.func.con-8'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i> These constructors shall not participate in overload resolution unless
<span class='texttt'>f</span> is Callable (<a href='func.wrap.func'>[func.wrap.func]</a>) for argument types
<span class='texttt'>ArgTypes...</span> and return type <span class='texttt'>R</span>.</p></div></div><div class='para' id='func.wrap.func.con-9'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-9'>9</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!*this</span> if any of the following hold:
</p><ul class='itemize'><li id='func.wrap.func.con-9.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.wrap.func.con-9.1'>(9.1)</a></div><p ><span class='texttt'>f</span> is a null function pointer value.
</p></li><li id='func.wrap.func.con-9.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.wrap.func.con-9.2'>(9.2)</a></div><p ><span class='texttt'>f</span> is a null member pointer value.
</p></li><li id='func.wrap.func.con-9.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#func.wrap.func.con-9.3'>(9.3)</a></div><p ><span class='texttt'>F</span> is an instance of the <span class='texttt'>function</span> class template, and
  <span class='texttt'>!f</span>.
</p></li></ul></div></div><div class='para' id='func.wrap.func.con-10'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-10'>10</a></div><div class='itemdescr'><p >Otherwise, <span class='texttt'>*this</span> targets a copy of <span class='texttt'>f</span>
initialized with <span class='texttt'>std::move(f)</span>.
[&nbsp;<i>Note:</i> Implementations are encouraged to avoid the use of
dynamically allocated memory for small callable objects, for example,
where <span class='texttt'>f</span>'s target is an object holding only a pointer or
reference to an object and a member function pointer. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='func.wrap.func.con-11'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-11'>11</a></div><div class='itemdescr'><p ><i>Throws:</i> shall not throw exceptions when <span class='texttt'>f</span> is a function pointer
or a <span class='texttt'>reference_wrapper&lt;T&gt;</span> for some <span class='texttt'>T</span>. Otherwise,
may throw <span class='texttt'>bad_alloc</span> or any exception thrown by <span class='texttt'>F</span>'s copy
or move constructor.
</p></div></div><p ><span class='indexparent'><a class='index' id='function,operator='></a></span><span class='indexparent'><a class='index' id='operator=,function'></a></span><code class='itemdecl'>
function&amp; operator=(const function&amp; f);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-12'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>function(f).swap(*this);</span></p></div></div><div class='para' id='func.wrap.func.con-13'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-13'>13</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='function,operator='></a></span><span class='indexparent'><a class='index' id='operator=,function'></a></span><code class='itemdecl'>
function&amp; operator=(function&amp;&amp; f);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-14'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> Replaces the target of <span class='texttt'>*this</span>
with the target of <span class='texttt'>f</span>.</p></div></div><div class='para' id='func.wrap.func.con-15'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='function,operator='></a></span><span class='indexparent'><a class='index' id='operator=,function'></a></span><code class='itemdecl'>
function&amp; operator=(nullptr_t);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-16'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-16'>16</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>*this != nullptr</span>, destroys the target of <span class='texttt'>this</span>.</p></div></div><div class='para' id='func.wrap.func.con-17'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-17'>17</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>!(*this)</span>.</p></div></div><div class='para' id='func.wrap.func.con-18'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-18'>18</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='function,operator='></a></span><span class='indexparent'><a class='index' id='operator=,function'></a></span><code class='itemdecl'>
template&lt;class F&gt; function&amp; operator=(F&amp;&amp; f);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-19'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-19'>19</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>function(std::forward&lt;F&gt;(f)).swap(*this);</span></p></div></div><div class='para' id='func.wrap.func.con-20'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-20'>20</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span></p></div></div><div class='para' id='func.wrap.func.con-21'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-21'>21</a></div><div class='itemdescr'><p ><i>Remarks:</i> This assignment operator shall not participate in overload
resolution unless <span class='texttt'>declval&lt;typename decay&lt;F&gt;::type&amp;&gt;()</span> is
Callable (<a href='func.wrap.func'>[func.wrap.func]</a>) for argument types <span class='texttt'>ArgTypes...</span> and
return type <span class='texttt'>R</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='function,operator='></a></span><span class='indexparent'><a class='index' id='operator=,function'></a></span><code class='itemdecl'>
template&lt;class F&gt; function&amp; operator=(reference_wrapper&lt;F&gt; f) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-22'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-22'>22</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>function(f).swap(*this);</span></p></div></div><div class='para' id='func.wrap.func.con-23'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-23'>23</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='function,destructor'></a></span><code class='itemdecl'>
~function();
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.con-24'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.con-24'>24</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>*this != nullptr</span>, destroys the target of <span class='texttt'>this</span>.
</p></div></div></div><div id='func.wrap.func.mod'><h4 ><a class='secnum' href='#func.wrap.func.mod' style='min-width:133pt'>20.9.11.2.2</a> <span class='texttt'>function</span> modifiers <a class='abbr_ref' href='func.wrap.func.mod'>[func.wrap.func.mod]</a></h4><p ><span class='indexparent'><a class='index' id='function,swap'></a></span><span class='indexparent'><a class='index' id='swap,function'></a></span><code class='itemdecl'>
void swap(function&amp; other) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.mod-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.mod-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> interchanges the targets of <span class='texttt'>*this</span> and <span class='texttt'>other</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='function,assign'></a></span><span class='indexparent'><a class='index' id='assign,function'></a></span><code class='itemdecl'>
template&lt;class F, class A&gt;
  void assign(F&amp;&amp; f, const A&amp; a);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.mod-2'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.mod-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>function(allocator_arg, a, std::forward&lt;F&gt;(f)).swap(*this)</span>
</p></div></div></div><div id='func.wrap.func.cap'><h4 ><a class='secnum' href='#func.wrap.func.cap' style='min-width:133pt'>20.9.11.2.3</a> <span class='texttt'>function</span> capacity <a class='abbr_ref' href='func.wrap.func.cap'>[func.wrap.func.cap]</a></h4><p ><span class='indexparent'><a class='index' id='function,bool_conversion'></a></span><code class='itemdecl'>
explicit operator bool() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.cap-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.cap-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>true</span> if <span class='texttt'>*this</span> has a target, otherwise <span class='texttt'>false</span>.
</p></div></div></div><div id='func.wrap.func.inv'><h4 ><a class='secnum' href='#func.wrap.func.inv' style='min-width:133pt'>20.9.11.2.4</a> <span class='texttt'>function</span> invocation <a class='abbr_ref' href='func.wrap.func.inv'>[func.wrap.func.inv]</a></h4><p ><span class='indexparent'><a class='index' id='function,invocation'></a></span><span class='indexparent'><a class='index' id='function,operator()'></a></span><span class='indexparent'><a class='index' id='operator(),function'></a></span><code class='itemdecl'>
R operator()(ArgTypes... args) const
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.inv-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.inv-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
<span class='texttt'><i>INVOKE</i>(f, std::forward&lt;ArgTypes&gt;(args)..., R)</span> (<a href='func.require'>[func.require]</a>),
where <span class='texttt'>f</span> is the target object (<a href='func.def'>[func.def]</a>) of <span class='texttt'>*this</span>.</p></div></div><div class='para' id='func.wrap.func.inv-2'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.inv-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> Nothing if <span class='texttt'>R</span> is <span class='texttt'>void</span>, otherwise the
return value of
<span class='texttt'><i>INVOKE</i>(f, std::forward&lt;ArgTypes&gt;(<span class='discretionary'></span>args)..., R)</span>.</p></div></div><div class='para' id='func.wrap.func.inv-3'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.inv-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i>
<span class='texttt'>bad_function_call</span> if <span class='texttt'>!*this</span>; otherwise, any
exception thrown by the wrapped callable object.
</p></div></div></div><div id='func.wrap.func.targ'><h4 ><a class='secnum' href='#func.wrap.func.targ' style='min-width:133pt'>20.9.11.2.5</a> function target access <a class='abbr_ref' href='func.wrap.func.targ'>[func.wrap.func.targ]</a></h4><p ><span class='indexparent'><a class='index' id='function,target_type'></a></span><span class='indexparent'><a class='index' id='target_type,function'></a></span><code class='itemdecl'>
const std::type_info&amp; target_type() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.targ-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.targ-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>*this</span> has a target of type <span class='texttt'>T</span>,
  <span class='texttt'>typeid(T)</span>; otherwise, <span class='texttt'>typeid(void)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='function,target'></a></span><span class='indexparent'><a class='index' id='target,function'></a></span><code class='itemdecl'>
template&lt;class T&gt;       T* target() noexcept;
template&lt;class T&gt; const T* target() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.targ-2'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.targ-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>T</span> shall be a type that is
Callable (<a href='func.wrap.func'>[func.wrap.func]</a>) for parameter types
<span class='texttt'>ArgTypes</span>
and return type <span class='texttt'>R</span>.</p></div></div><div class='para' id='func.wrap.func.targ-3'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.targ-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> If <span class='texttt'>target_type() == typeid(T)</span>
a pointer to the stored function target; otherwise a null pointer.
</p></div></div></div><div id='func.wrap.func.nullptr'><h4 ><a class='secnum' href='#func.wrap.func.nullptr' style='min-width:133pt'>20.9.11.2.6</a> null pointer comparison operators <a class='abbr_ref' href='func.wrap.func.nullptr'>[func.wrap.func.nullptr]</a></h4><p ><span class='indexparent'><a class='index' id='operator==,function'></a></span><span class='indexparent'><a class='index' id='function,operator=='></a></span><code class='itemdecl'>
template &lt;class R, class... ArgTypes&gt;
  bool operator==(const function&lt;R(ArgTypes...)&gt;&amp; f, nullptr_t) noexcept;
template &lt;class R, class... ArgTypes&gt;
  bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp; f) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.nullptr-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.nullptr-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!f</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,function'></a></span><span class='indexparent'><a class='index' id='function,operator!='></a></span><code class='itemdecl'>
template &lt;class R, class... ArgTypes&gt;
  bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp; f, nullptr_t) noexcept;
template &lt;class R, class... ArgTypes&gt;
  bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp; f) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.nullptr-2'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.nullptr-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'> (bool) f</span>.
</p></div></div></div><div id='func.wrap.func.alg'><h4 ><a class='secnum' href='#func.wrap.func.alg' style='min-width:133pt'>20.9.11.2.7</a> specialized algorithms <a class='abbr_ref' href='func.wrap.func.alg'>[func.wrap.func.alg]</a></h4><p ><span class='indexparent'><a class='index' id='function,swap'></a></span><span class='indexparent'><a class='index' id='swap,function'></a></span><code class='itemdecl'>
template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2);
</code></p><div class='itemdescr'></div><div class='para' id='func.wrap.func.alg-1'><div class='marginalizedparent'><a class='marginalized' href='#func.wrap.func.alg-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>f1.swap(f2);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='function_object,wrapper'></a></span></p></div></div></div><div id='unord.hash'><h3 ><a class='secnum' href='#unord.hash' style='min-width:103pt'>20.9.12</a> Class template <span class='texttt'>hash</span> <a class='abbr_ref' href='unord.hash'>[unord.hash]</a></h3><div class='para' id='unord.hash-1'><div class='marginalizedparent'><a class='marginalized' href='#unord.hash-1'>1</a></div><p ><span class='indexparent'><a class='index' id='hash'></a></span><span class='indexparent'><a class='index' id='hash,instantiation_restrictions'></a></span>The unordered associative containers defined in <a href='unord'>[unord]</a> use
specializations of the class template <span class='texttt'>hash</span> as the default hash function.
For all object types <span class='texttt'>Key</span> for which there exists a specialization <span class='texttt'>hash&lt;Key&gt;</span>,
and for all enumeration types (<a href='dcl.enum'>[dcl.enum]</a>) <span class='texttt'>Key</span>,
the instantiation <span class='texttt'>hash&lt;Key&gt;</span> shall:</p><ul class='itemize'><li id='unord.hash-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unord.hash-1.1'>(1.1)</a></div><p >satisfy the <span class='texttt'>Hash</span> requirements (<a href='hash.requirements'>[hash.requirements]</a>),
with <span class='texttt'>Key</span> as the function
call argument type, the <span class='texttt'>DefaultConstructible</span> requirements (Table <a href='defaultconstructible'>[defaultconstructible]</a>),
the <span class='texttt'>CopyAssignable</span> requirements (Table <a href='copyassignable'>[copyassignable]</a>),
</p></li><li id='unord.hash-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unord.hash-1.2'>(1.2)</a></div><p >be swappable (<a href='swappable.requirements'>[swappable.requirements]</a>) for lvalues,
</p></li><li id='unord.hash-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unord.hash-1.3'>(1.3)</a></div><p >provide two nested types <span class='texttt'>result_type</span> and <span class='texttt'>argument_type</span> which shall be
synonyms for <span class='texttt'>size_t</span> and <span class='texttt'>Key</span>, respectively,
</p></li><li id='unord.hash-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unord.hash-1.4'>(1.4)</a></div><p >satisfy the requirement that if <span class='texttt'>k1 == k2</span> is true, <span class='texttt'>h(k1) == h(k2)</span> is
also true, where <span class='texttt'>h</span> is an object of type <span class='texttt'>hash&lt;Key&gt;</span> and <span class='texttt'>k1</span> and <span class='texttt'>k2</span>
are objects of type <span class='texttt'>Key</span>;
</p></li><li id='unord.hash-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#unord.hash-1.5'>(1.5)</a></div><p >satisfy the requirement that the expression <span class='texttt'>h(k)</span>, where <span class='texttt'>h</span>
is an object of type <span class='texttt'>hash&lt;Key&gt;</span> and <span class='texttt'>k</span> is an object of type
<span class='texttt'>Key</span>, shall not throw an exception unless <span class='texttt'>hash&lt;Key&gt;</span> is a
user-defined specialization that depends on at least one user-defined type.
</p></li></ul><p ><span class='indexparent'><a class='index' id='hash'></a></span><code class='itemdecl'>
template &lt;&gt; struct hash&lt;bool&gt;;
template &lt;&gt; struct hash&lt;char&gt;;
template &lt;&gt; struct hash&lt;signed char&gt;;
template &lt;&gt; struct hash&lt;unsigned char&gt;;
template &lt;&gt; struct hash&lt;char16_t&gt;;
template &lt;&gt; struct hash&lt;char32_t&gt;;
template &lt;&gt; struct hash&lt;wchar_t&gt;;
template &lt;&gt; struct hash&lt;short&gt;;
template &lt;&gt; struct hash&lt;unsigned short&gt;;
template &lt;&gt; struct hash&lt;int&gt;;
template &lt;&gt; struct hash&lt;unsigned int&gt;;
template &lt;&gt; struct hash&lt;long&gt;;
template &lt;&gt; struct hash&lt;unsigned long&gt;;
template &lt;&gt; struct hash&lt;long long&gt;;
template &lt;&gt; struct hash&lt;unsigned long long&gt;;
template &lt;&gt; struct hash&lt;float&gt;;
template &lt;&gt; struct hash&lt;double&gt;;
template &lt;&gt; struct hash&lt;long double&gt;;
template &lt;class T&gt; struct hash&lt;T*&gt;;
</code></p></div><div class='itemdescr'></div><div class='para' id='unord.hash-2'><div class='marginalizedparent'><a class='marginalized' href='#unord.hash-2'>2</a></div><div class='itemdescr'><p >The template specializations shall meet the requirements of class template
<span class='texttt'>hash</span> (<a href='unord.hash'>[unord.hash]</a>).
</p></div></div></div></div></div></body></html>