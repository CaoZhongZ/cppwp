<!DOCTYPE html><html lang='en'><head><title>[dcl.init.ref]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Declarators <a class='abbr_ref' href='./#dcl.decl'>[dcl.decl]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>8.5</a> Initializers <a class='abbr_ref' href='dcl.init#ref'>[dcl.init]</a></h2><div id='dcl.init.ref'><h3 ><a class='secnum' style='min-width:103pt'>8.5.3</a> References <a class='abbr_ref'>[dcl.init.ref]</a></h3><p ><span class='indexparent'><a class='index' id='initialization,reference'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A variable declared to be a
<span class='texttt'>T&amp;</span> or <span class='texttt'>T&amp;&amp;</span>,
that is, “reference to type
<span class='texttt'>T</span>”
(<a href='dcl.ref'>[dcl.ref]</a>),
shall be initialized by an object, or function, of type
<span class='texttt'>T</span>
or by an object that can be converted into a
<span class='texttt'>T</span>.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int g(int);
void f() {
  int i;
  int&amp; r = i;                   <span class='comment'>// <span class='texttt'>r</span> refers to <span class='texttt'>i</span>
</span>  r = 1;                        <span class='comment'>// the value of <span class='texttt'>i</span> becomes <span class='texttt'>1</span>
</span>  int* p = &amp;r;                  <span class='comment'>// <span class='texttt'>p</span> points to <span class='texttt'>i</span>
</span>  int&amp; rr = r;                  <span class='comment'>// <span class='texttt'>rr</span> refers to what <span class='texttt'>r</span> refers to, that is, to <span class='texttt'>i</span>
</span>  int (&amp;rg)(int) = g;           <span class='comment'>// <span class='texttt'>rg</span> refers to the function <span class='texttt'>g</span>
</span>  rg(i);                        <span class='comment'>// calls function <span class='texttt'>g</span>
</span>  int a[3];
  int (&amp;ra)[3] = a;             <span class='comment'>// <span class='texttt'>ra</span> refers to the array <span class='texttt'>a</span>
</span>  ra[1] = i;                    <span class='comment'>// modifies <span class='texttt'>a[1]</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A reference cannot be changed to refer to another object after initialization.
<span class='indexparent'><a class='index' id='assignment,reference'></a></span>Note that initialization of a reference is treated very differently from assignment
to it.
<span class='indexparent'><a class='index' id='argument_passing,reference_and'></a></span>Argument passing (<a href='expr.call'>[expr.call]</a>)
<span class='indexparent'><a class='index' id='return,reference_and'></a></span>and function value return (<a href='stmt.return'>[stmt.return]</a>) are initializations.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The initializer can be omitted for a reference only in a parameter declaration
(<a href='dcl.fct'>[dcl.fct]</a>), in the declaration of a function return type, in the declaration of
a class member within its class definition (<a href='class.mem'>[class.mem]</a>), and where the
<span class='texttt'>extern</span>
specifier is explicitly used.
<span class='indexparent'><a class='index' id='declaration,extern'></a></span>[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int&amp; r1;                        <span class='comment'>// error: initializer missing
</span>extern int&amp; r2;                 <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >Given types “<span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” and “<span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>,”
“<span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is <span class='rmfamily'></span><i> reference-related</i> to
<span class='indexparent'><a class='index' id='reference-related'></a></span>“<span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>” if
<span class='texttt'>T1</span>
is the same type as
<span class='texttt'>T2</span>,
or
<span class='texttt'>T1</span>
is a base class of
<span class='texttt'>T2</span>.
“<span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is <span class='rmfamily'></span><i> reference-compatible</i>
<span class='indexparent'><a class='index' id='reference-compatible'></a></span>with “<span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>” if
<span class='texttt'>T1</span>
is reference-related to
<span class='texttt'>T2</span>
and
<i>cv1</i>
is the same cv-qualification as, or greater cv-qualification than,
<i>cv2</i>.
In all cases where the reference-related or reference-compatible relationship
of two types is used to establish the validity of a reference binding, and
<span class='texttt'>T1</span>
is a base class of
<span class='texttt'>T2</span>,
a program that necessitates such a binding is ill-formed if
<span class='texttt'>T1</span>
is an inaccessible (Clause <a href='class.access'>[class.access]</a>) or ambiguous (<a href='class.member.lookup'>[class.member.lookup]</a>)
base class of
<span class='texttt'>T2</span>.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A reference to type “<i>cv1</i> <span class='texttt'>T1</span>” is initialized by
an expression of type “<i>cv2</i> <span class='texttt'>T2</span>” as follows:<span class='indexparent'><a class='index' id='binding,reference'></a></span></p><ul class='itemize'><li id='5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.1'>(5.1)</a></div><p >If the reference is an lvalue reference and the initializer expression</p><ul class='itemize'><li id='5.1.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#5.1.1'>(5.1.1)</a></div><p >is an lvalue (but is not a
bit-field), and
“<span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is reference-compatible with
“<span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>,” or
</p></li><li id='5.1.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#5.1.2'>(5.1.2)</a></div><p >has a class type (i.e.,
<span class='texttt'>T2</span>
is a class type), where <span class='texttt'>T1</span> is not reference-related to <span class='texttt'>T2</span>, and can be converted
to an lvalue of type “<span class='rmfamily'></span><i> cv3</i> <span class='texttt'>T3</span>,” where
“<span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is reference-compatible with
“<span class='rmfamily'></span><i> cv3</i> <span class='texttt'>T3</span>”<a class='footnotenum' href='#footnote-107'>107</a>
(this conversion is selected by enumerating the applicable conversion
functions (<a href='over.match.ref'>[over.match.ref]</a>) and choosing the best one through overload
resolution (<a href='over.match'>[over.match]</a>)),
</p></li></ul><p >then the reference is bound to the initializer expression lvalue in the
first case and to the lvalue result of the conversion
in the second case (or, in either case, to the appropriate base class subobject of the object).
[&nbsp;<i>Note:</i>
The usual lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>), array-to-pointer
(<a href='conv.array'>[conv.array]</a>), and function-to-pointer (<a href='conv.func'>[conv.func]</a>) standard
conversions are not needed, and therefore are suppressed, when such
direct bindings to lvalues are done.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
double d = 2.0;
double&amp; rd = d;                 <span class='comment'>// <span class='texttt'>rd</span> refers to <span class='texttt'>d</span>
</span>const double&amp; rcd = d;          <span class='comment'>// <span class='texttt'>rcd</span> refers to <span class='texttt'>d</span>
</span>
struct A { };
struct B : A { operator int&amp;(); } b;
A&amp; ra = b;                      <span class='comment'>// <span class='texttt'>ra</span> refers to <span class='texttt'>A</span> subobject in <span class='texttt'>b</span>
</span>const A&amp; rca = b;               <span class='comment'>// <span class='texttt'>rca</span> refers to <span class='texttt'>A</span> subobject in <span class='texttt'>b</span>
</span>int&amp; ir = B();                  <span class='comment'>// <span class='texttt'>ir</span> refers to the result of <span class='texttt'>B::operator int&amp;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li id='5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.2'>(5.2)</a></div><p >Otherwise, the reference shall be an lvalue reference to a non-volatile
const type (i.e.,
<i>cv1</i>
shall be
<span class='texttt'>const</span>), or the reference shall be an rvalue reference.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
double&amp; rd2 = 2.0;              <span class='comment'>// error: not an lvalue and reference not <span class='texttt'>const</span>
</span>int  i = 2;
double&amp; rd3 = i;                <span class='comment'>// error: type mismatch and reference not <span class='texttt'>const</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><ul class='itemize'><li id='5.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#5.2.1'>(5.2.1)</a></div><p >If the initializer expression</p><ul class='itemize'><li id='5.2.1.1'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#5.2.1.1'>(5.2.1.1)</a></div><p >is an xvalue (but not a bit-field), class prvalue, array prvalue or function lvalue and
“<i>cv1</i> <span class='texttt'>T1</span>” is
reference-compatible with “<i>cv2</i> <span class='texttt'>T2</span>”, or</p></li><li id='5.2.1.2'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#5.2.1.2'>(5.2.1.2)</a></div><p >has a class type (i.e., <span class='texttt'>T2</span> is a class type), where <span class='texttt'>T1</span>
is not reference-related to <span class='texttt'>T2</span>, and can be converted to
an xvalue, class prvalue, or function lvalue of type “<i>cv3</i> <span class='texttt'>T3</span>”,
where “<i>cv1</i> <span class='texttt'>T1</span>” is
reference-compatible with “<i>cv3</i> <span class='texttt'>T3</span>” (see <a href='over.match.ref'>[over.match.ref]</a>),</p></li></ul><p >then the reference is bound to the value of the initializer expression in the first
case and to the result of the conversion in the second case (or, in either case, to
an appropriate base class subobject). In the second case, if the reference is an
rvalue reference and the second standard conversion sequence of the user-defined
conversion sequence includes an lvalue-to-rvalue conversion, the program is ill-formed.</p><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct A { };
struct B : A { } b;
extern B f();
const A&amp; rca2 = f();                <span class='comment'>// bound to the <span class='texttt'>A</span> subobject of the <span class='texttt'>B</span> rvalue.
</span>A&amp;&amp; rra = f();                      <span class='comment'>// same as above
</span>struct X {
  operator B();
  operator int&amp;();
} x;
const A&amp; r = x;                     <span class='comment'>// bound to the <span class='texttt'>A</span> subobject of the result of the conversion
</span>int i2 = 42;
int&amp;&amp; rri = static_cast&lt;int&amp;&amp;&gt;(i2); <span class='comment'>// bound directly to <span class='texttt'>i2</span>
</span>B&amp;&amp; rrb = x;                        <span class='comment'>// bound directly to the result of <span class='texttt'>operator B</span>
</span>int&amp;&amp; rri2 = X();                   <span class='comment'>// error: lvalue-to-rvalue conversion applied to the
</span>                                    <span class='comment'>// result of <span class='texttt'>operator int&amp;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li id='5.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#5.2.2'>(5.2.2)</a></div><p >Otherwise:
</p><ul class='itemize'><li id='5.2.2.1'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#5.2.2.1'>(5.2.2.1)</a></div><p >If <span class='texttt'>T1</span> is a class type, user-defined conversions are considered
using the rules for copy-initialization of an object of type 
“<span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” by
user-defined conversion (<a href='dcl.init'>[dcl.init]</a>, <a href='over.match.copy'>[over.match.copy]</a>);
the program is ill-formed if the corresponding non-reference
copy-initialization would be ill-formed. The result of the call to the
conversion function, as described for the non-reference
copy-initialization, is then used to direct-initialize the reference.
The program is ill-formed if the direct-initialization does not result
in a direct binding or if it involves a user-defined conversion.
</p></li><li id='5.2.2.2'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#5.2.2.2'>(5.2.2.2)</a></div><p >If <span class='texttt'>T1</span> is a non-class type,
a temporary of type “<span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is created and
copy-initialized (<a href='dcl.init'>[dcl.init]</a>) from the initializer expression.
The reference is then bound to the temporary.
</p></li></ul><p >If
<span class='texttt'>T1</span>
is reference-related to
<span class='texttt'>T2</span>:
</p><ul class='itemize'><li id='5.2.2.3'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#5.2.2.3'>(5.2.2.3)</a></div><p ><i>cv1</i>
shall be the same cv-qualification as, or greater cv-qualification than,
<i>cv2</i>; and
</p></li><li id='5.2.2.4'><div class='marginalizedparent' style='left:-11em'><a class='marginalized' href='#5.2.2.4'>(5.2.2.4)</a></div><p >if the reference is an rvalue reference,
the initializer expression shall not be an lvalue.
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct Banana { };
struct Enigma { operator const Banana(); };
void enigmatic() {
  typedef const Banana ConstBanana;
  Banana &amp;&amp;banana1 = ConstBanana(); <span class='comment'>// ill-formed
</span>  Banana &amp;&amp;banana2 = Enigma();      <span class='comment'>// ill-formed
</span>}

const double&amp; rcd2 = 2;         <span class='comment'>// <span class='texttt'>rcd2</span> refers to temporary with value <span class='texttt'>2.0</span>
</span>double&amp;&amp; rrd = 2;               <span class='comment'>// <span class='texttt'>rrd</span> refers to temporary with value <span class='texttt'>2.0</span>
</span>const volatile int cvi = 1;
const int&amp; r2 = cvi;            <span class='comment'>// error: type qualifiers dropped
</span>double d2 = 1.0;
double&amp;&amp; rrd2 = d2;             <span class='comment'>// error: copying lvalue of related type
</span>int i3 = 2;
double&amp;&amp; rrd3 = i3;             <span class='comment'>// <span class='texttt'>rrd3</span> refers to temporary with value <span class='texttt'>2.0</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li></ul></li></ul><p >In all cases except the last (i.e., creating and initializing a temporary from the
initializer expression), the reference is said to <a class='hidden_link' href='#def:bind_directly' id='def:bind_directly'><i>bind directly</i></a> to the
initializer expression.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >[&nbsp;<i>Note:</i>
<a href='class.temporary'>[class.temporary]</a> describes the lifetime of temporaries bound to references.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-107'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-107'>107)</a></div><p >This requires a conversion
function (<a href='class.conv.fct'>[class.conv.fct]</a>) returning a reference type.</p></div></div></div></body></html>