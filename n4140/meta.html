<!DOCTYPE html><html lang='en'><head><title>[meta]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><div id='meta'><h2 ><a class='secnum' style='min-width:88pt'>20.10</a> Metaprogramming and type traits <a class='abbr_ref'>[meta]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >This subclause describes components used by C++ programs, particularly in
templates, to support the widest possible range of types, optimise
template code usage, detect type related user errors, and perform
type inference and transformation at compile time. It includes type
classification traits, type property inspection traits, and type
transformations. The type classification traits describe a complete taxonomy
of all possible C++ types, and state where in that taxonomy a given
type belongs. The type property inspection traits allow important
characteristics of types or of combinations of types to be inspected. The
type transformations allow certain properties of types to be manipulated.</p></div><div id='rqmts'><h3 ><a class='secnum' href='#rqmts' style='min-width:103pt'>20.10.1</a> Requirements <a class='abbr_ref' href='meta.rqmts'>[meta.rqmts]</a></h3><div class='para' id='rqmts-1'><div class='marginalizedparent'><a class='marginalized' href='#rqmts-1'>1</a></div><p >A <a class='hidden_link' href='#def:UnaryTypeTrait' id='def:UnaryTypeTrait'><i>UnaryTypeTrait</i></a> describes a property
of a type. It shall be a class template that takes one template type
argument and, optionally, additional arguments that help define the
property being described. It shall be <span class='texttt'>DefaultConstructible</span>,
<span class='texttt'>CopyConstructible</span>,
and publicly and unambiguously derived, directly or indirectly, from
its <a class='hidden_link' href='#def:BaseCharacteristic' id='def:BaseCharacteristic'><i>BaseCharacteristic</i></a>, which is
a specialization of the template
<span class='texttt'>integral_constant</span> (<a href='meta.help'>[meta.help]</a>), with
the arguments to the template <span class='texttt'>integral_constant</span> determined by the
requirements for the particular property being described.
The member names of the BaseCharacteristic shall not be hidden and shall be
unambiguously available in the UnaryTypeTrait.</p></div><div class='para' id='rqmts-2'><div class='marginalizedparent'><a class='marginalized' href='#rqmts-2'>2</a></div><p >A <a class='hidden_link' href='#def:BinaryTypeTrait' id='def:BinaryTypeTrait'><i>BinaryTypeTrait</i></a> describes a
relationship between two types. It shall be a class template that
takes two template type arguments and, optionally, additional
arguments that help define the relationship being described. It shall
be <span class='texttt'>DefaultConstructible</span>, <span class='texttt'>CopyConstructible</span>,
and publicly and unambiguously derived, directly or
indirectly, from
its <a class='hidden_link' href='#def:BaseCharacteristic' id='def:BaseCharacteristic'><i>BaseCharacteristic</i></a>, which is a specialization
of the template
<span class='texttt'>integral_constant</span> (<a href='meta.help'>[meta.help]</a>), with
the arguments to the template <span class='texttt'>integral_constant</span> determined by the
requirements for the particular relationship being described.
The member names of the BaseCharacteristic shall not be hidden and shall be
unambiguously available in the BinaryTypeTrait.</p></div><div class='para' id='rqmts-3'><div class='marginalizedparent'><a class='marginalized' href='#rqmts-3'>3</a></div><p >A <a class='hidden_link' href='#def:TransformationTrait' id='def:TransformationTrait'><i>TransformationTrait</i></a>
modifies a property
of a type. It shall be a class template that takes one
template type argument and, optionally, additional arguments that help
define the modification. It shall define a publicly accessible nested type
named <span class='texttt'>type</span>, which shall be a synonym for the modified type.</p></div></div><div id='type.synop'><h3 ><a class='secnum' href='#type.synop' style='min-width:103pt'>20.10.2</a> Header <span class='texttt'>&lt;type_traits&gt;</span> synopsis <a class='abbr_ref' href='meta.type.synop'>[meta.type.synop]</a></h3><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='meta.help'>[meta.help]</a>, helper class:
</span>  template &lt;class T, T v&gt; struct integral_constant;
  typedef integral_constant&lt;bool, true&gt;  true_type;
  typedef integral_constant&lt;bool, false&gt; false_type;

  <span class='comment'>// <a href='meta.unary.cat'>[meta.unary.cat]</a>, primary type categories:
</span>  template &lt;class T&gt; struct is_void;
  template &lt;class T&gt; struct is_null_pointer;
  template &lt;class T&gt; struct is_integral;
  template &lt;class T&gt; struct is_floating_point;
  template &lt;class T&gt; struct is_array;
  template &lt;class T&gt; struct is_pointer;
  template &lt;class T&gt; struct is_lvalue_reference;
  template &lt;class T&gt; struct is_rvalue_reference;
  template &lt;class T&gt; struct is_member_object_pointer;
  template &lt;class T&gt; struct is_member_function_pointer;
  template &lt;class T&gt; struct is_enum;
  template &lt;class T&gt; struct is_union;
  template &lt;class T&gt; struct is_class;
  template &lt;class T&gt; struct is_function;

  <span class='comment'>// <a href='meta.unary.comp'>[meta.unary.comp]</a>, composite type categories:
</span>  template &lt;class T&gt; struct is_reference;
  template &lt;class T&gt; struct is_arithmetic;
  template &lt;class T&gt; struct is_fundamental;
  template &lt;class T&gt; struct is_object;
  template &lt;class T&gt; struct is_scalar;
  template &lt;class T&gt; struct is_compound;
  template &lt;class T&gt; struct is_member_pointer;

  <span class='comment'>// <a href='meta.unary.prop'>[meta.unary.prop]</a>, type properties:
</span>  template &lt;class T&gt; struct is_const;
  template &lt;class T&gt; struct is_volatile;
  template &lt;class T&gt; struct is_trivial;
  template &lt;class T&gt; struct is_trivially_copyable;
  template &lt;class T&gt; struct is_standard_layout;
  template &lt;class T&gt; struct is_pod;
  template &lt;class T&gt; struct is_literal_type;
  template &lt;class T&gt; struct is_empty;
  template &lt;class T&gt; struct is_polymorphic;
  template &lt;class T&gt; struct is_abstract;
  template &lt;class T&gt; struct is_final;

  template &lt;class T&gt; struct is_signed;
  template &lt;class T&gt; struct is_unsigned;

  template &lt;class T, class... Args&gt; struct is_constructible;
  template &lt;class T&gt; struct is_default_constructible;
  template &lt;class T&gt; struct is_copy_constructible;
  template &lt;class T&gt; struct is_move_constructible;

  template &lt;class T, class U&gt; struct is_assignable;
  template &lt;class T&gt; struct is_copy_assignable;
  template &lt;class T&gt; struct is_move_assignable;

  template &lt;class T&gt; struct is_destructible;

  template &lt;class T, class... Args&gt; struct is_trivially_constructible;
  template &lt;class T&gt; struct is_trivially_default_constructible;
  template &lt;class T&gt; struct is_trivially_copy_constructible;
  template &lt;class T&gt; struct is_trivially_move_constructible;

  template &lt;class T, class U&gt; struct is_trivially_assignable;
  template &lt;class T&gt; struct is_trivially_copy_assignable;
  template &lt;class T&gt; struct is_trivially_move_assignable;
  template &lt;class T&gt; struct is_trivially_destructible;

  template &lt;class T, class... Args&gt; struct is_nothrow_constructible;
  template &lt;class T&gt; struct is_nothrow_default_constructible;
  template &lt;class T&gt; struct is_nothrow_copy_constructible;
  template &lt;class T&gt; struct is_nothrow_move_constructible;

  template &lt;class T, class U&gt; struct is_nothrow_assignable;
  template &lt;class T&gt; struct  is_nothrow_copy_assignable;
  template &lt;class T&gt; struct is_nothrow_move_assignable;

  template &lt;class T&gt; struct is_nothrow_destructible;
  template &lt;class T&gt; struct has_virtual_destructor;

  <span class='comment'>// <a href='meta.unary.prop.query'>[meta.unary.prop.query]</a>, type property queries:
</span>  template &lt;class T&gt; struct alignment_of;
  template &lt;class T&gt; struct rank;
  template &lt;class T, unsigned I = 0&gt; struct extent;

  <span class='comment'>// <a href='meta.rel'>[meta.rel]</a>, type relations:
</span>  template &lt;class T, class U&gt; struct is_same;
  template &lt;class Base, class Derived&gt; struct is_base_of;
  template &lt;class From, class To&gt; struct is_convertible;

  <span class='comment'>// <a href='meta.trans.cv'>[meta.trans.cv]</a>, const-volatile modifications:
</span>  template &lt;class T&gt; struct remove_const;
  template &lt;class T&gt; struct remove_volatile;
  template &lt;class T&gt; struct remove_cv;
  template &lt;class T&gt; struct add_const;
  template &lt;class T&gt; struct add_volatile;
  template &lt;class T&gt; struct add_cv;

  template &lt;class T&gt;
    using remove_const_t    = typename remove_const&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_volatile_t = typename remove_volatile&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_cv_t       = typename remove_cv&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_const_t       = typename add_const&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_volatile_t    = typename add_volatile&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_cv_t          = typename add_cv&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.ref'>[meta.trans.ref]</a>, reference modifications:
</span>  template &lt;class T&gt; struct remove_reference;
  template &lt;class T&gt; struct add_lvalue_reference;
  template &lt;class T&gt; struct add_rvalue_reference;

  template &lt;class T&gt;
    using remove_reference_t     = typename remove_reference&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_lvalue_reference_t = typename add_lvalue_reference&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_rvalue_reference_t = typename add_rvalue_reference&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.sign'>[meta.trans.sign]</a>, sign modifications:
</span>  template &lt;class T&gt; struct make_signed;
  template &lt;class T&gt; struct make_unsigned;

  template &lt;class T&gt;
    using make_signed_t   = typename make_signed&lt;T&gt;::type;
  template &lt;class T&gt;
    using make_unsigned_t = typename make_unsigned&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.arr'>[meta.trans.arr]</a>, array modifications:
</span>  template &lt;class T&gt; struct remove_extent;
  template &lt;class T&gt; struct remove_all_extents;

  template &lt;class T&gt;
    using remove_extent_t      = typename remove_extent&lt;T&gt;::type;
  template &lt;class T&gt;
    using remove_all_extents_t = typename remove_all_extents&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.ptr'>[meta.trans.ptr]</a>, pointer modifications:
</span>  template &lt;class T&gt; struct remove_pointer;
  template &lt;class T&gt; struct add_pointer;

  template &lt;class T&gt;
    using remove_pointer_t = typename remove_pointer&lt;T&gt;::type;
  template &lt;class T&gt;
    using add_pointer_t    = typename add_pointer&lt;T&gt;::type;

  <span class='comment'>// <a href='meta.trans.other'>[meta.trans.other]</a>, other transformations:
</span>  template &lt;std::size_t Len,
            std::size_t Align = default-alignment&gt;   <span class='comment'>// see <a href='meta.trans.other'>[meta.trans.other]</a>
</span>    struct aligned_storage;      
  template &lt;std::size_t Len, class... Types&gt; struct aligned_union;
  template &lt;class T&gt; struct decay;
  template &lt;bool, class T = void&gt; struct enable_if;
  template &lt;bool, class T, class F&gt; struct conditional;
  template &lt;class... T&gt; struct common_type;
  template &lt;class T&gt; struct underlying_type;
  template &lt;class&gt; class result_of;   <span class='comment'>// not defined
</span>  template &lt;class F, class... ArgTypes&gt; class result_of&lt;F(ArgTypes...)&gt;;

  template &lt;std::size_t Len,
            std::size_t Align = default-alignment &gt; <span class='comment'>// see <a href='meta.trans.other'>[meta.trans.other]</a>
</span>    using aligned_storage_t = typename aligned_storage&lt;Len,Align&gt;::type;
  template &lt;std::size_t Len, class... Types&gt;
    using aligned_union_t   = typename aligned_union&lt;Len,Types...&gt;::type;
  template &lt;class T&gt;
    using decay_t           = typename decay&lt;T&gt;::type;
  template &lt;bool b, class T = void&gt;
    using enable_if_t       = typename enable_if&lt;b,T&gt;::type;
  template &lt;bool b, class T, class F&gt;
    using conditional_t     = typename conditional&lt;b,T,F&gt;::type;
  template &lt;class... T&gt;
    using common_type_t     = typename common_type&lt;T...&gt;::type;
  template &lt;class T&gt;
    using underlying_type_t = typename underlying_type&lt;T&gt;::type;
  template &lt;class T&gt;
    using result_of_t       = typename result_of&lt;T&gt;::type;  
} <span class='comment'>// namespace std
</span></pre><div class='para' id='type.synop-1'><div class='marginalizedparent'><a class='marginalized' href='#type.synop-1'>1</a></div><p >The behavior of a program that adds specializations for any of
the class templates defined in this subclause is undefined unless otherwise specified.</p></div></div><div id='help'><h3 ><a class='secnum' href='#help' style='min-width:103pt'>20.10.3</a> Helper classes <a class='abbr_ref' href='meta.help'>[meta.help]</a></h3><pre class='codeblock'>
namespace std {
  template &lt;class T, T v&gt;
  struct integral_constant {
    static constexpr T value = v;
    typedef T value_type;
    typedef integral_constant&lt;T,v&gt; type;
    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
  };
  typedef integral_constant&lt;bool, true&gt; true_type;
  typedef integral_constant&lt;bool, false&gt; false_type;
}
</pre><div class='para' id='help-1'><div class='marginalizedparent'><a class='marginalized' href='#help-1'>1</a></div><p >The class template <span class='texttt'>integral_constant</span> and its associated typedefs
<span class='texttt'>true_type</span> and <span class='texttt'>false_type</span> are used as base classes to define
the interface for various type traits.</p></div></div><div id='unary'><h3 ><a class='secnum' href='#unary' style='min-width:103pt'>20.10.4</a> Unary type traits <a class='abbr_ref' href='meta.unary'>[meta.unary]</a></h3><div class='para' id='unary-1'><div class='marginalizedparent'><a class='marginalized' href='#unary-1'>1</a></div><p >This sub-clause contains templates that may be used to query the
properties of a type at compile time.</p></div><div class='para' id='unary-2'><div class='marginalizedparent'><a class='marginalized' href='#unary-2'>2</a></div><p >Each of these templates shall be a
UnaryTypeTrait (<a href='meta.rqmts'>[meta.rqmts]</a>)
with a BaseCharacteristic of
<span class='texttt'>true_type</span> if the corresponding condition is true, otherwise
<span class='texttt'>false_type</span>.</p></div><div id='unary.cat'><h4 ><a class='secnum' href='#unary.cat' style='min-width:118pt'>20.10.4.1</a> Primary type categories <a class='abbr_ref' href='meta.unary.cat'>[meta.unary.cat]</a></h4><div class='para' id='unary.cat-1'><div class='marginalizedparent'><a class='marginalized' href='#unary.cat-1'>1</a></div><p >The primary type categories correspond to the descriptions given in
section <a href='basic.types'>[basic.types]</a> of the C++ standard.</p></div><div class='para' id='unary.cat-2'><div class='marginalizedparent'><a class='marginalized' href='#unary.cat-2'>2</a></div><p >For any given type <span class='texttt'>T</span>, the result of applying one of these templates to
<span class='texttt'>T</span> and to <i>cv-qualified</i> <span class='texttt'>T</span> shall yield the same result.</p></div><div class='para' id='unary.cat-3'><div class='marginalizedparent'><a class='marginalized' href='#unary.cat-3'>3</a></div><p >[&nbsp;<i>Note:</i>
For any given type <span class='texttt'>T</span>, exactly one of the primary type categories
has a <span class='texttt'>value</span> member that evaluates to <span class='texttt'>true</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><div class='numberedTable' id='tab:type-traits.primary'>Table <a href='#tab:type-traits.primary'>47</a> — Primary type category predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 

<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_void;</span>                </td><td class='left'>
<span class='texttt'>T</span> is <span class='texttt'>void</span>       </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_null_pointer;</span>                </td><td class='left'>
<span class='texttt'>T</span> is <span class='texttt'>std::nullptr_t</span> (<a href='basic.fundamental'>[basic.fundamental]</a>)       </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_integral;</span>        </td><td class='left'>
<span class='texttt'>T</span> is an integral type (<a href='basic.fundamental'>[basic.fundamental]</a>)                 </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_floating_point;</span>  </td><td class='left'>
<span class='texttt'>T</span> is a floating point type (<a href='basic.fundamental'>[basic.fundamental]</a>)            </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_array;</span>           </td><td class='left'>
<span class='texttt'>T</span> is an array type (<a href='basic.compound'>[basic.compound]</a>) of known or unknown extent    </td><td class='left'>
Class template <span class='texttt'>array</span> (<a href='array'>[array]</a>)
is not an array type.                   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_pointer;</span>         </td><td class='left'>
<span class='texttt'>T</span> is a pointer type (<a href='basic.compound'>[basic.compound]</a>)                      </td><td class='left'>
Includes pointers to functions
but not pointers to non-static members.                        </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_lvalue_reference;</span>    </td><td class='left'>
 <span class='texttt'>T</span> is an lvalue reference type (<a href='dcl.ref'>[dcl.ref]</a>)   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_rvalue_reference;</span>    </td><td class='left'>
 <span class='texttt'>T</span> is an rvalue reference type (<a href='dcl.ref'>[dcl.ref]</a>)   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_member_object_pointer;</span></td><td class='left'>
 <span class='texttt'>T</span> is a pointer to non-static data member                              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_member_function_pointer;</span></td><td class='left'>
<span class='texttt'>T</span> is a pointer to non-static member function                           </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_enum;</span>            </td><td class='left'>
<span class='texttt'>T</span> is an enumeration type (<a href='basic.compound'>[basic.compound]</a>)                 </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_union;</span>           </td><td class='left'>
<span class='texttt'>T</span> is a union type (<a href='basic.compound'>[basic.compound]</a>)                        </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_class;</span>           </td><td class='left'>
<span class='texttt'>T</span> is a class type but not a union type (<a href='basic.compound'>[basic.compound]</a>) </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_function;</span>        </td><td class='left'>
<span class='texttt'>T</span> is a function type (<a href='basic.compound'>[basic.compound]</a>)                     </td><td class='left'>   </td></tr></table></div></div></div><div id='unary.comp'><h4 ><a class='secnum' href='#unary.comp' style='min-width:118pt'>20.10.4.2</a> Composite type traits <a class='abbr_ref' href='meta.unary.comp'>[meta.unary.comp]</a></h4><div class='para' id='unary.comp-1'><div class='marginalizedparent'><a class='marginalized' href='#unary.comp-1'>1</a></div><p >These templates provide convenient compositions of the primary type
categories, corresponding to the descriptions given in section <a href='basic.types'>[basic.types]</a>.</p></div><div class='para' id='unary.comp-2'><div class='marginalizedparent'><a class='marginalized' href='#unary.comp-2'>2</a></div><p >For any given type <span class='texttt'>T</span>, the result of applying one of these templates to
<span class='texttt'>T</span>, and to <i>cv-qualified</i> <span class='texttt'>T</span> shall yield the same result.</p><div class='numberedTable' id='tab:type-traits.composite'>Table <a href='#tab:type-traits.composite'>48</a> — Composite type category predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 

<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_reference;</span>   </td><td class='left'>
 <span class='texttt'>T</span> is an lvalue reference or an rvalue reference </td><td class='left'>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_arithmetic;</span>          </td><td class='left'>
 <span class='texttt'>T</span> is an arithmetic type (<a href='basic.fundamental'>[basic.fundamental]</a>)              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_fundamental;</span>         </td><td class='left'>
 <span class='texttt'>T</span> is a fundamental type (<a href='basic.fundamental'>[basic.fundamental]</a>)              </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_object;</span>              </td><td class='left'>
 <span class='texttt'>T</span> is an object type (<a href='basic.types'>[basic.types]</a>)                            </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_scalar;</span>              </td><td class='left'>
 <span class='texttt'>T</span> is a scalar type (<a href='basic.types'>[basic.types]</a>)                         </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_compound;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is a compound type (<a href='basic.compound'>[basic.compound]</a>)                        </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_member_pointer;</span>      </td><td class='left'>
 <span class='texttt'>T</span> is a pointer to non-static data member
 or non-static member function             </td><td class='left'>   </td></tr></table></div></div></div><div id='unary.prop'><h4 ><a class='secnum' href='#unary.prop' style='min-width:118pt'>20.10.4.3</a> Type properties <a class='abbr_ref' href='meta.unary.prop'>[meta.unary.prop]</a></h4><div class='para' id='unary.prop-1'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-1'>1</a></div><p >These templates provide access to some of the more important
properties of types.</p></div><div class='para' id='unary.prop-2'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-2'>2</a></div><p >It is unspecified whether the library defines any full or partial
specializations of any of these templates.</p></div><div class='para' id='unary.prop-3'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-3'>3</a></div><p >For all of the class templates <span class='texttt'>X</span> declared in this Clause,
instantiating that template with a template-argument that is a class
template specialization may result in the implicit instantiation of
the template argument if and only if the semantics of <span class='texttt'>X</span> require that
the argument must be a complete type.</p><div class='numberedTable' id='tab:type-traits.properties'>Table <a href='#tab:type-traits.properties'>49</a> — Type property predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Preconditions</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_const;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is const-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>)                  </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_volatile;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is volatile-qualified (<a href='basic.type.qualifier'>[basic.type.qualifier]</a>)                   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivial;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a trivial type (<a href='basic.types'>[basic.types]</a>)     </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete
 type or (possibly cv-qualified) void.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_copyable;</span>      </td><td class='left'>
 <span class='texttt'>T</span> is a trivially copyable type (<a href='basic.types'>[basic.types]</a>) </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete type or
 (possibly cv-qualified) <span class='texttt'>void</span>.                               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_standard_layout;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a standard-layout type (<a href='basic.types'>[basic.types]</a>)   </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete
 type or (possibly cv-qualified) void.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_pod;</span>                 </td><td class='left'>
 <span class='texttt'>T</span> is a POD type (<a href='basic.types'>[basic.types]</a>)                                </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete
 type or (possibly cv-qualified) void.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_literal_type;</span>        </td><td class='left'>
 <span class='texttt'>T</span> is a literal type (<a href='basic.types'>[basic.types]</a>)  </td><td class='left'>
 <span class='texttt'>remove_all_extents_t&lt;T&gt;</span> shall be a complete type or
 (possibly cv-qualified) <span class='texttt'>void</span>.                               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_empty;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is a class type, but not a union type, with no non-static data
 members other than bit-fields of length 0, no virtual member functions,
 no virtual base classes, and no base class <span class='texttt'>B</span> for
 which <span class='texttt'>is_empty&lt;B&gt;::value</span> is false. </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                               </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_polymorphic;</span>         </td><td class='left'>
 <span class='texttt'>T</span> is a polymorphic class (<a href='class.virtual'>[class.virtual]</a>)                             </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_abstract;</span>            </td><td class='left'>
 <span class='texttt'>T</span> is an abstract class (<a href='class.abstract'>[class.abstract]</a>)                              </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_final;</span>               </td><td class='left'>
 <span class='texttt'>T</span> is a class type marked with the <span class='grammarterm'>class-virt-specifier</span>
 <span class='texttt'>final</span> (Clause <a href='class'>[class]</a>). [&nbsp;<i>Note:</i> A union is a class type that
 can be marked with <span class='texttt'>final</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]                                        </td><td class='left'>
 If <span class='texttt'>T</span> is a class type, <span class='texttt'>T</span> shall be a complete type.                          </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_signed;</span>              </td><td class='left'>
  If <span class='texttt'>is_arithmetic&lt;T&gt;::value</span> is <span class='texttt'>true</span>, the same result as
  <span class='texttt'>integral_constant&lt;bool, T(-1) &lt; T(0)&gt;::value</span>;
  otherwise, <span class='texttt'>false</span>   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'>  <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_unsigned;</span>            </td><td class='left'>
  If <span class='texttt'>is_arithmetic&lt;T&gt;::value</span> is <span class='texttt'>true</span>, the same result as
  <span class='texttt'>integral_constant&lt;bool, T(0) &lt; T(-1)&gt;::value</span>;
  otherwise, <span class='texttt'>false</span>   </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'>  <span class='texttt'>template &lt;class T, class... Args&gt;</span><br/>
 <span class='texttt'>struct is_constructible;</span>   </td><td class='left'>
 <i><span class='texttt'>see below</span></i>                          </td><td class='left'>
 <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span>
 shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
 or arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_default_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_copy_constructible;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_constructible&lt;T, const T&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_move_constructible;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_constructible&lt;T, T&amp;&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_assignable;</span> </td><td class='left'>
  The expression <span class='texttt'>declval&lt;T&gt;() =</span> <span class='texttt'>declval&lt;U&gt;()</span> is well-formed
  when treated as an unevaluated
  operand (Clause <a href='expr'>[expr]</a>). Access checking is performed as if in a context
  unrelated to <span class='texttt'>T</span> and <span class='texttt'>U</span>. Only the validity of the immediate context
  of the assignment expression is considered. [&nbsp;<i>Note:</i> The compilation of the
  expression can result in side effects such as the instantiation of class template
  specializations and function template specializations, the generation of
  implicitly-defined functions, and so on. Such side effects are not in the “immediate
  context” and can result in the program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_copy_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_assignable&lt;T&amp;, const T&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_move_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_destructible;</span> </td><td class='left'>
  For reference types, <span class='texttt'>is_destructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>. <br/>
  For incomplete types and function types, <span class='texttt'>is_destructible&lt;T&gt;::value</span> is
  <span class='texttt'>false</span>. <br/>
  For object types and given <span class='texttt'>U</span> equal to <span class='texttt'>remove_all_extents_t&lt;T&gt;</span>,
  if the expression <span class='texttt'>std::declval&lt;U&amp;&gt;().~U()</span> is well-formed
  when treated as an unevaluated operand (Clause <a href='expr'>[expr]</a>), <br/> then
  <span class='texttt'>is_destructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>,
  otherwise it is <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type, (possibly <i>cv</i>-qualified) <span class='texttt'>void</span>,
  or an array of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class... Args&gt;</span><br/>
  <span class='texttt'>struct</span><br/>
  <span class='texttt'>is_trivially_constructible;</span> </td><td class='left'>
  <span class='texttt'>is_constructible&lt;T,</span><br/>
  <span class='texttt'>Args...&gt;::value</span> is <span class='texttt'>true</span> and the variable
  definition for <span class='texttt'>is_constructible</span>, as defined below, is known to call
  no operation that is not trivial ( <a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span> shall be complete types,
  (possibly cv-qualified) <span class='texttt'>void</span>, or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_default_constructible;</span> </td><td class='left'>
 <span class='texttt'>is_trivially_constructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_copy_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_constructible&lt;T, const T&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_move_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_constructible&lt;T, T&amp;&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_trivially_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable&lt;T, U&gt;::value</span> is <span class='texttt'>true</span> and the assignment, as defined by
  <span class='texttt'>is_assignable</span>, is known to call no operation that is not trivial
  (<a href='basic.types'>[basic.types]</a>, <a href='special'>[special]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_copy_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_assignable&lt;T&amp;, const T&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_move_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_trivially_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_trivially_destructible;</span> </td><td class='left'>
 <span class='texttt'>is_destructible&lt;T&gt;::value</span> is <span class='texttt'>true</span> and the indicated destructor is known
 to be trivial. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class... Args&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_constructible;</span>   </td><td class='left'>
 <span class='texttt'>is_constructible&lt;T,</span> <span class='texttt'> Args...&gt;::value</span> is <span class='texttt'>true</span>
 and the
 variable definition for <span class='texttt'>is_constructible</span>, as defined below, is known not to
 throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>).
 </td><td class='left'>
 <span class='texttt'>T</span> and all types in the parameter pack <span class='texttt'>Args</span>
 shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
 or arrays of unknown bound.  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_default_constructible;</span> </td><td class='left'>
 <span class='texttt'>is_nothrow_constructible&lt;T&gt;::value</span> is <span class='texttt'>true</span>.  </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_copy_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_nothrow_constructible&lt;T, const T&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_move_constructible;</span>      </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_nothrow_constructible&lt;T, T&amp;&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T, class U&gt;</span><br/>
  <span class='texttt'>struct is_nothrow_assignable;</span> </td><td class='left'>
  <span class='texttt'>is_assignable&lt;T, U&gt;::value</span> is <span class='texttt'>true</span> and the assignment is known not to
  throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> and <span class='texttt'>U</span> shall be complete types, (possibly cv-qualified) <span class='texttt'>void</span>,
  or arrays of unknown bound. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct is_nothrow_copy_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
 <span class='texttt'>is_nothrow_assignable&lt;T&amp;, const T&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_nothrow_move_assignable;</span> </td><td class='left'>
  For a referenceable type <span class='texttt'>T</span>, the same result as
  <span class='texttt'>is_nothrow_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</span>, otherwise <span class='texttt'>false</span>. </td><td class='left'>
 <span class='texttt'>T</span> shall be a complete type,
 (possibly cv-qualified) void, or an array of unknown
 bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
  <span class='texttt'>struct is_nothrow_destructible;</span> </td><td class='left'>
  <span class='texttt'>is_destructible&lt;T&gt;::value</span> is <span class='texttt'>true</span> and the indicated destructor is known
  not to throw any exceptions (<a href='expr.unary.noexcept'>[expr.unary.noexcept]</a>). </td><td class='left'>
  <span class='texttt'>T</span> shall be a complete type,
  (possibly cv-qualified) void, or an array of unknown
  bound.                </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct has_virtual_destructor;</span> </td><td class='left'>
 <span class='texttt'>T</span> has a virtual destructor (<a href='class.dtor'>[class.dtor]</a>) </td><td class='left'>
 If <span class='texttt'>T</span> is a non-union class type, <span class='texttt'>T</span> shall be a complete type.                </td></tr></table></div></div><div class='para' id='unary.prop-4'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-4'>4</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
is_const&lt;const volatile int&gt;::value     <span class='comment'>// true
</span>is_const&lt;const int*&gt;::value             <span class='comment'>// false
</span>is_const&lt;const int&amp;&gt;::value             <span class='comment'>// false
</span>is_const&lt;int[3]&gt;::value                 <span class='comment'>// false
</span>is_const&lt;const int[3]&gt;::value           <span class='comment'>// true
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='unary.prop-5'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-5'>5</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
remove_const_t&lt;const volatile int&gt;  <span class='comment'>// <span class='texttt'>volatile int</span>
</span>remove_const_t&lt;const int* const&gt;    <span class='comment'>// <span class='texttt'>const int*</span>
</span>remove_const_t&lt;const int&amp;&gt;          <span class='comment'>// <span class='texttt'>const int&amp;</span>
</span>remove_const_t&lt;const int[3]&gt;        <span class='comment'>// <span class='texttt'>int[3]</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='unary.prop-6'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-6'>6</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// Given:
</span>struct P final { };
union U1 { };
union U2 final { };

<span class='comment'>// the following assertions hold:
</span>static_assert(!is_final&lt;int&gt;::value, "Error!");
static_assert( is_final&lt;P&gt;::value, "Error!");
static_assert(!is_final&lt;U1&gt;::value, "Error!");
static_assert( is_final&lt;U2&gt;::value, "Error!");
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='unary.prop-7'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop-7'>7</a></div><p >Given the following function prototype:
</p><pre class='codeblock'>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; create() noexcept;
</pre><p >the predicate condition for a template specialization
<span class='texttt'>is_constructible&lt;T, Args...&gt;</span> shall be satisfied if and only if the
following variable definition would be well-formed for some invented variable <span class='texttt'>t</span>:</p><pre class='codeblock'>
T t(create&lt;Args&gt;()...);
</pre><p >[&nbsp;<i>Note:</i> These tokens are never interpreted as a function declaration.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] Access checking is performed as if in a context unrelated to <span class='texttt'>T</span>
and any of the <span class='texttt'>Args</span>. Only the validity of the immediate context of the
variable initialization is considered. [&nbsp;<i>Note:</i> The evaluation of the
initialization can result in side effects such as the instantiation of class
template specializations and function template specializations, the generation
of implicitly-defined functions, and so on. Such side effects are not in the
“immediate context” and can result in the program being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='unary.prop.query'><h3 ><a class='secnum' href='#unary.prop.query' style='min-width:103pt'>20.10.5</a> Type property queries <a class='abbr_ref' href='meta.unary.prop.query'>[meta.unary.prop.query]</a></h3><div class='para' id='unary.prop.query-1'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop.query-1'>1</a></div><p >This sub-clause contains templates that may be used to query
properties of types at compile time.</p><div class='numberedTable' id='tab:type-traits.properties.queries'>Table <a href='#tab:type-traits.properties.queries'>50</a> — Type property queries<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Value</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;<br/>
 struct alignment_of;</span>      </td><td class='left'>
 <span class='texttt'>alignof(T)</span>.<br/>
 <i>Requires:</i>
 <span class='texttt'>alignof(T)</span> shall be a valid expression (<a href='expr.alignof'>[expr.alignof]</a>)  </td></tr><tr class='rowsep'><td class='left'>  <span class='texttt'>template &lt;class T&gt;<br/>
 struct rank;</span>      </td><td class='left'>
 If <span class='texttt'>T</span> names an array type, an integer value representing
 the number of dimensions of <span class='texttt'>T</span>; otherwise, 0. </td></tr><tr class='rowsep'><td class='left'>    <span class='texttt'>template &lt;class T,<br/>
 unsigned I = 0&gt;<br/>
 struct extent;</span>        </td><td class='left'>
 If <span class='texttt'>T</span> is not an array type, or if it has rank less
 than or equal to <span class='texttt'>I</span>, or if <span class='texttt'>I</span> is 0 and <span class='texttt'>T</span>
 has type “array of unknown bound of <span class='texttt'>U</span>”, then
 0; otherwise, the bound (<a href='dcl.array'>[dcl.array]</a>) of the <span class='texttt'>I</span>'th dimension of
<span class='texttt'>T</span>, where indexing of <span class='texttt'>I</span> is zero-based </td></tr></table></div></div><div class='para' id='unary.prop.query-2'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop.query-2'>2</a></div><p >Each of these templates shall be a <span class='texttt'>UnaryTypeTrait</span> (<a href='meta.rqmts'>[meta.rqmts]</a>) with a
<span class='texttt'>BaseCharacteristic</span> of <span class='texttt'>integral_constant&lt;size_t, Value&gt;</span>.</p></div><div class='para' id='unary.prop.query-3'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop.query-3'>3</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
<span class='comment'>// the following assertions hold:
</span>assert(rank&lt;int&gt;::value == 0);
assert(rank&lt;int[2]&gt;::value == 1);
assert(rank&lt;int[][4]&gt;::value == 2);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='unary.prop.query-4'><div class='marginalizedparent'><a class='marginalized' href='#unary.prop.query-4'>4</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
 <span class='comment'>// the following assertions hold:
</span>assert(extent&lt;int&gt;::value == 0);
assert(extent&lt;int[2]&gt;::value == 2);
assert(extent&lt;int[2][4]&gt;::value == 2);
assert(extent&lt;int[][4]&gt;::value == 0);
assert((extent&lt;int, 1&gt;::value) == 0);
assert((extent&lt;int[2], 1&gt;::value) == 0);
assert((extent&lt;int[2][4], 1&gt;::value) == 4);
assert((extent&lt;int[][4], 1&gt;::value) == 4);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='rel'><h3 ><a class='secnum' href='#rel' style='min-width:103pt'>20.10.6</a> Relationships between types <a class='abbr_ref' href='meta.rel'>[meta.rel]</a></h3><div class='para' id='rel-1'><div class='marginalizedparent'><a class='marginalized' href='#rel-1'>1</a></div><p >This sub-clause contains templates that may be used to query
relationships between types at compile time.</p></div><div class='para' id='rel-2'><div class='marginalizedparent'><a class='marginalized' href='#rel-2'>2</a></div><p >Each of these templates shall be a
BinaryTypeTrait (<a href='meta.rqmts'>[meta.rqmts]</a>)
with a BaseCharacteristic of
<span class='texttt'>true_type</span> if the corresponding condition is true, otherwise
<span class='texttt'>false_type</span>.</p><div class='numberedTable' id='tab:type-traits.relationship'>Table <a href='#tab:type-traits.relationship'>51</a> — Type relationship predicates<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 

<span class='texttt'>template &lt;class T, class U&gt;</span><br/>
 <span class='texttt'>struct is_same;</span>                    </td><td class='left'>
 <span class='texttt'>T</span> and <span class='texttt'>U</span> name the same type with the same cv-qualifications                            </td><td class='left'>   </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class Base, class Derived&gt;</span><br/>
 <span class='texttt'>struct is_base_of;</span>                 </td><td class='left'>
 <span class='texttt'>Base</span> is a base class of <span class='texttt'>Derived</span> (Clause <a href='class.derived'>[class.derived]</a>)
 without regard to cv-qualifiers
 or <span class='texttt'>Base</span> and <span class='texttt'>Derived</span> are not unions and
 name the same class type
 without regard to cv-qualifiers</td><td class='left'>
 If <span class='texttt'>Base</span> and
 <span class='texttt'>Derived</span> are non-union class types and are different types (ignoring
 possible cv-qualifiers) then
 <span class='texttt'>Derived</span> shall be a complete
 type.
 [&nbsp;<i>Note:</i> Base classes that are private, protected, or ambiguous
 are, nonetheless, base classes. <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class From, class To&gt;</span><br/>
 <span class='texttt'>struct is_convertible;</span>             </td><td class='left'>
 <i><span class='texttt'>see below</span></i>
  </td><td class='left'>
 <span class='texttt'>From</span> and <span class='texttt'>To</span> shall be complete
 types, arrays of unknown
 bound, or (possibly cv-qualified) <span class='texttt'>void</span> types.                      </td></tr></table></div></div><div class='para' id='rel-3'><div class='marginalizedparent'><a class='marginalized' href='#rel-3'>3</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct B {};
struct B1 : B {};
struct B2 : B {};
struct D : private B1, private B2 {};

is_base_of&lt;B, D&gt;::value         <span class='comment'>// true
</span>is_base_of&lt;const B, D&gt;::value   <span class='comment'>// true
</span>is_base_of&lt;B, const D&gt;::value   <span class='comment'>// true
</span>is_base_of&lt;B, const B&gt;::value   <span class='comment'>// true
</span>is_base_of&lt;D, B&gt;::value         <span class='comment'>// false
</span>is_base_of&lt;B&amp;, D&amp;&gt;::value       <span class='comment'>// false
</span>is_base_of&lt;B[3], D[3]&gt;::value   <span class='comment'>// false
</span>is_base_of&lt;int, int&gt;::value     <span class='comment'>// false
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='rel-4'><div class='marginalizedparent'><a class='marginalized' href='#rel-4'>4</a></div><p >Given the following function prototype:</p><pre class='codeblock'>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; create() noexcept;
</pre><p >the predicate condition for a template specialization <span class='texttt'>is_convertible&lt;From, To&gt;</span>
shall be satisfied if and only if the return expression in the following code would be
well-formed, including any implicit conversions to the return type of the function:</p><pre class='codeblock'>
To test() {
  return create&lt;From&gt;();
}
</pre><p >[&nbsp;<i>Note:</i> This requirement gives well defined results for reference types, void
types, array types, and function types.<i>&nbsp;—&nbsp;end note</i>&nbsp;] Access checking is performed as
if in a context unrelated to <span class='texttt'>To</span> and <span class='texttt'>From</span>. Only the validity of
the immediate context of the expression of the <span class='grammarterm'>return-statement</span>
(including conversions to the return type) is considered. [&nbsp;<i>Note:</i> The
evaluation of the conversion can result in side effects such as the
instantiation of class template specializations and function template
specializations, the generation of implicitly-defined functions, and so on. Such
side effects are not in the “immediate context” and can result in the program
being ill-formed. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='trans'><h3 ><a class='secnum' href='#trans' style='min-width:103pt'>20.10.7</a> Transformations between types <a class='abbr_ref' href='meta.trans'>[meta.trans]</a></h3><div class='para' id='trans-1'><div class='marginalizedparent'><a class='marginalized' href='#trans-1'>1</a></div><p >This sub-clause contains templates that may be used to transform one
type to another following some predefined rule.</p></div><div class='para' id='trans-2'><div class='marginalizedparent'><a class='marginalized' href='#trans-2'>2</a></div><p >Each of the templates in this subclause shall be a
<a class='hidden_link' href='#def:TransformationTrait' id='def:TransformationTrait'><i>TransformationTrait</i></a> (<a href='meta.rqmts'>[meta.rqmts]</a>).</p></div><div id='trans.cv'><h4 ><a class='secnum' href='#trans.cv' style='min-width:118pt'>20.10.7.1</a> Const-volatile modifications <a class='abbr_ref' href='meta.trans.cv'>[meta.trans.cv]</a></h4><div class='numberedTable' id='tab:type-traits.const-volatile'>Table <a href='#tab:type-traits.const-volatile'>52</a> — Const-volatile modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 

<span class='texttt'>template &lt;class T&gt;<br/>
 struct remove_const;</span>                  </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall name
 the same type as <span class='texttt'>T</span>
 except that any top-level const-qualifier has been removed.
 [&nbsp;<i>Example:</i> <span class='texttt'>remove_const_t&lt;const volatile int&gt;</span> evaluates
 to <span class='texttt'>volatile int</span>, whereas <span class='texttt'>remove_const_t&lt;const int*&gt;</span> evaluates to
 <span class='texttt'>const int*</span>. <i>&nbsp;—&nbsp;end example</i>&nbsp;]                          </td></tr><tr class='rowsep'><td class='left'>  
<span class='texttt'>template &lt;class T&gt;<br/>
 struct remove_volatile;</span>               </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall name
 the same type as <span class='texttt'>T</span>
 except that any top-level volatile-qualifier has been removed.
 [&nbsp;<i>Example:</i> <span class='texttt'>remove_volatile_t&lt;const volatile int&gt;</span>
 evaluates to <span class='texttt'>const int</span>,
 whereas <span class='texttt'>remove_volatile_t&lt;volatile int*&gt;</span> evaluates to <span class='texttt'>volatile int*</span>.
 <i>&nbsp;—&nbsp;end example</i>&nbsp;]                                              </td></tr><tr class='rowsep'><td class='left'>  
<span class='texttt'>template &lt;class T&gt;<br/>
 struct remove_cv;</span>                 </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall be the same as <span class='texttt'>T</span>
 except that any top-level cv-qualifier has been removed.
 [&nbsp;<i>Example:</i> <span class='texttt'>remove_cv_t&lt;const volatile int&gt;</span>
 evaluates to <span class='texttt'>int</span>, whereas <span class='texttt'>remove_cv_t&lt;const volatile int*&gt;</span>
 evaluates to <span class='texttt'>const volatile int*</span>. <i>&nbsp;—&nbsp;end example</i>&nbsp;]  </td></tr><tr class='rowsep'><td class='left'>  
<span class='texttt'>template &lt;class T&gt;<br/>
 struct add_const;</span>                 </td><td class='left'>
 If <span class='texttt'>T</span> is a reference, function, or top-level const-qualified
 type, then <span class='texttt'>type</span> shall name
 the same type as <span class='texttt'>T</span>, otherwise
 <span class='texttt'>T const</span>.                                                           </td></tr><tr class='rowsep'><td class='left'>  
<span class='texttt'>template &lt;class T&gt;<br/>
 struct add_volatile;</span>                  </td><td class='left'>
 If <span class='texttt'>T</span> is a reference, function, or top-level volatile-qualified
 type, then <span class='texttt'>type</span> shall name
 the same type as <span class='texttt'>T</span>, otherwise
 <span class='texttt'>T volatile</span>.                                                            </td></tr><tr class='rowsep'><td class='left'>  
<span class='texttt'>template &lt;class T&gt;<br/>
 struct add_cv;</span>                    </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall name
 the same type as
 <span class='texttt'>add_const_t&lt;add_volatile_t&lt;T&gt;&gt;</span>.                               </td></tr></table></div></div><div id='trans.ref'><h4 ><a class='secnum' href='#trans.ref' style='min-width:118pt'>20.10.7.2</a> Reference modifications <a class='abbr_ref' href='meta.trans.ref'>[meta.trans.ref]</a></h4><div class='numberedTable' id='tab:type-traits.reference'>Table <a href='#tab:type-traits.reference'>53</a> — Reference modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;<br/>
 struct remove_reference;</span>                  </td><td class='left'>
 If <span class='texttt'>T</span> has type “reference to <span class='texttt'>T1</span>” then the
 member typedef <span class='texttt'>type</span> shall name <span class='texttt'>T1</span>;
 otherwise, <span class='texttt'>type</span> shall name <span class='texttt'>T</span>.</td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;<br/>
 struct add_lvalue_reference;</span>                     </td><td class='left'>
 If <span class='texttt'>T</span> names an object or function type then
 the member typedef <span class='texttt'>type</span> shall name <span class='texttt'>T&amp;</span>;
 otherwise, if <span class='texttt'>T</span> names a
  type “rvalue reference to <span class='texttt'>T1</span>” then
 the member typedef <span class='texttt'>type</span> shall name <span class='texttt'>T1&amp;</span>;
 otherwise, <span class='texttt'>type</span> shall
 name <span class='texttt'>T</span>. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct add_rvalue_reference;</span>    </td><td class='left'>
 If <span class='texttt'>T</span> names an object or function type then
 the member typedef <span class='texttt'>type</span> shall name <span class='texttt'>T&amp;&amp;</span>;
 otherwise, <span class='texttt'>type</span> shall name <span class='texttt'>T</span>.
 [&nbsp;<i>Note:</i> This rule reflects the semantics of reference collapsing (<a href='dcl.ref'>[dcl.ref]</a>).
 For example, when a type <span class='texttt'>T</span> names a type <span class='texttt'>T1&amp;</span>, the type
 <span class='texttt'>add_rvalue_reference_t&lt;T&gt;</span> is not an rvalue reference.
 <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td></tr></table></div></div><div id='trans.sign'><h4 ><a class='secnum' href='#trans.sign' style='min-width:118pt'>20.10.7.3</a> Sign modifications <a class='abbr_ref' href='meta.trans.sign'>[meta.trans.sign]</a></h4><div class='numberedTable' id='tab:type-traits.sign'>Table <a href='#tab:type-traits.sign'>54</a> — Sign modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 

<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct make_signed;</span> </td><td class='left'>
 If <span class='texttt'>T</span> names a (possibly cv-qualified) signed integer
 type (<a href='basic.fundamental'>[basic.fundamental]</a>) then the member typedef
 <span class='texttt'>type</span> shall name the type <span class='texttt'>T</span>; otherwise,
 if <span class='texttt'>T</span> names a (possibly cv-qualified) unsigned integer
 type then <span class='texttt'>type</span> shall name the corresponding
 signed integer type, with the same cv-qualifiers as <span class='texttt'>T</span>;
 otherwise, <span class='texttt'>type</span> shall name the signed integer type with smallest
 rank (<a href='conv.rank'>[conv.rank]</a>) for which
 <span class='texttt'>sizeof(T) == sizeof(type)</span>, with the same
 cv-qualifiers as <span class='texttt'>T</span>.<br/>
 <i>Requires:</i> <span class='texttt'>T</span> shall be a (possibly cv-qualified)
 integral type or enumeration
 but not a <span class='texttt'>bool</span> type.</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct make_unsigned;</span> </td><td class='left'>
 If <span class='texttt'>T</span> names a (possibly cv-qualified) unsigned integer
 type (<a href='basic.fundamental'>[basic.fundamental]</a>) then the member typedef
 <span class='texttt'>type</span> shall name the type <span class='texttt'>T</span>; otherwise,
 if <span class='texttt'>T</span> names a (possibly cv-qualified) signed integer
 type then <span class='texttt'>type</span> shall name the corresponding
 unsigned integer type, with the same cv-qualifiers as <span class='texttt'>T</span>;
 otherwise, <span class='texttt'>type</span> shall name the unsigned integer type with smallest
 rank (<a href='conv.rank'>[conv.rank]</a>) for which
 <span class='texttt'>sizeof(T) == sizeof(type)</span>, with the same
 cv-qualifiers as <span class='texttt'>T</span>.<br/>
 <i>Requires:</i> <span class='texttt'>T</span> shall be a (possibly cv-qualified)
 integral type or enumeration
 but not a <span class='texttt'>bool</span> type.</td></tr></table></div></div><div id='trans.arr'><h4 ><a class='secnum' href='#trans.arr' style='min-width:118pt'>20.10.7.4</a> Array modifications <a class='abbr_ref' href='meta.trans.arr'>[meta.trans.arr]</a></h4><div class='numberedTable' id='tab:type-traits.array'>Table <a href='#tab:type-traits.array'>55</a> — Array modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 

<span class='texttt'>template &lt;class T&gt;<br/>
 struct remove_extent;</span>                 </td><td class='left'>
 If <span class='texttt'>T</span> names a type “array of <span class='texttt'>U</span>”,
 the member typedef <span class='texttt'>type</span> shall
 be <span class='texttt'>U</span>, otherwise <span class='texttt'>T</span>.
 [&nbsp;<i>Note:</i> For multidimensional arrays, only the first array dimension is
 removed. For a type “array of <span class='texttt'>const U</span>”, the resulting type is
 <span class='texttt'>const U</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]                                 </td></tr><tr class='rowsep'><td class='left'>  
<span class='texttt'>template &lt;class T&gt;<br/>
 struct remove_all_extents;</span>                </td><td class='left'>
 If <span class='texttt'>T</span> is “multi-dimensional array of <span class='texttt'>U</span>”, the resulting member
 typedef <span class='texttt'>type</span> is <span class='texttt'>U</span>, otherwise <span class='texttt'>T</span>.                                       </td></tr></table></div><div class='para' id='trans.arr-1'><div class='marginalizedparent'><a class='marginalized' href='#trans.arr-1'>1</a></div><p >[<i>Example</i>
</p><pre class='codeblock'>
<span class='comment'>// the following assertions hold:
</span>assert((is_same&lt;remove_extent_t&lt;int&gt;, int&gt;::value));
assert((is_same&lt;remove_extent_t&lt;int[2]&gt;, int&gt;::value));
assert((is_same&lt;remove_extent_t&lt;int[2][3]&gt;, int[3]&gt;::value));
assert((is_same&lt;remove_extent_t&lt;int[][3]&gt;, int[3]&gt;::value));
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='trans.arr-2'><div class='marginalizedparent'><a class='marginalized' href='#trans.arr-2'>2</a></div><p >[<i>Example</i>
</p><pre class='codeblock'>
<span class='comment'>// the following assertions hold:
</span>assert((is_same&lt;remove_all_extents_t&lt;int&gt;, int&gt;::value));
assert((is_same&lt;remove_all_extents_t&lt;int[2]&gt;, int&gt;::value));
assert((is_same&lt;remove_all_extents_t&lt;int[2][3]&gt;, int&gt;::value));
assert((is_same&lt;remove_all_extents_t&lt;int[][3]&gt;, int&gt;::value));
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='trans.ptr'><h4 ><a class='secnum' href='#trans.ptr' style='min-width:118pt'>20.10.7.5</a> Pointer modifications <a class='abbr_ref' href='meta.trans.ptr'>[meta.trans.ptr]</a></h4><div class='numberedTable' id='tab:type-traits.pointer'>Table <a href='#tab:type-traits.pointer'>56</a> — Pointer modifications<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 

<span class='texttt'>template &lt;class T&gt;<br/>
 struct remove_pointer;</span>                    </td><td class='left'>
 If <span class='texttt'>T</span> has type “(possibly cv-qualified) pointer
 to <span class='texttt'>T1</span>” then the member typedef <span class='texttt'>type</span>
 shall name <span class='texttt'>T1</span>; otherwise, it shall name <span class='texttt'>T</span>.</td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>template &lt;class T&gt;<br/>
 struct add_pointer;</span>                       </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall name the same type as
 <span class='texttt'>remove_reference_t&lt;T&gt;*</span>.                         </td></tr></table></div></div><div id='trans.other'><h4 ><a class='secnum' href='#trans.other' style='min-width:118pt'>20.10.7.6</a> Other transformations <a class='abbr_ref' href='meta.trans.other'>[meta.trans.other]</a></h4><div class='numberedTable' id='tab:type-traits.other'>Table <a href='#tab:type-traits.other'>57</a> — Other transformations<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Template</b></td><td colspan='1' class='center'><b>Condition</b></td><td colspan='1' class='center'><b>Comments</b></td></tr><tr class='capsep'><td class='left'> 
<span class='texttt'>template &lt;std::size_t Len,<br/>
 std::size_t Align<br/>
 = <i>default-alignment</i>&gt;<br/>
 struct aligned_storage;</span>
 </td><td class='left'>
 <span class='texttt'>Len</span> shall not be zero.
 <span class='texttt'>Align</span> shall be equal
 to <span class='texttt'>alignof(T)</span> for some type <span class='texttt'>T</span>
 or to <i>default-alignment</i>.
 </td><td class='left'>
 The value of <i>default-alignment</i> shall be the most
 stringent alignment requirement for any C++ object type whose size
 is no greater than <span class='texttt'>Len</span> (<a href='basic.types'>[basic.types]</a>).
 The member typedef <span class='texttt'>type</span> shall be a POD type
 suitable for use as uninitialized storage for any object whose size
 is at most <i>Len</i> and whose alignment is a divisor of <i>Align</i>. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;std::size_t Len,<br/>
  class... Types&gt;<br/>
  struct aligned_union;</span>
  </td><td class='left'>
  At least one type is provided.
  </td><td class='left'>
  The member typedef <span class='texttt'>type</span> shall be a POD type suitable for use as
  uninitialized storage for any object whose type is listed in <span class='texttt'>Types</span>;
  its size shall be at least <span class='texttt'>Len</span>. The static member <span class='texttt'>alignment_value</span>
  shall be an integral constant of type <span class='texttt'>std::size_t</span> whose value is the
  strictest alignment of all types listed in <span class='texttt'>Types</span>.
  </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt; struct</span> <span class='texttt'>decay;</span> </td><td class='left'>   </td><td class='left'>
 Let <span class='texttt'>U</span> be <span class='texttt'>remove_reference_t&lt;T&gt;</span>. If <span class='texttt'>is_array&lt;U&gt;::value</span>
 is <span class='texttt'>true</span>, the member typedef <span class='texttt'>type</span> shall equal
 <span class='texttt'>remove_extent_t&lt;U&gt;*</span>. If <span class='texttt'>is_function&lt;U&gt;::value</span> is <span class='texttt'>true</span>,
 the member typedef <span class='texttt'>type</span> shall equal <span class='texttt'>add_pointer_t&lt;U&gt;</span>. Otherwise
 the member typedef <span class='texttt'>type</span> equals <span class='texttt'>remove_cv_t&lt;U&gt;</span>.
 [&nbsp;<i>Note:</i> This behavior is similar to the lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>),
 array-to-pointer (<a href='conv.array'>[conv.array]</a>), and function-to-pointer (<a href='conv.func'>[conv.func]</a>)
 conversions applied when an lvalue expression is used as an rvalue, but also
 strips <i>cv</i>-qualifiers from class types in order to more closely model by-value
 argument passing. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
 </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;bool B, class T = void&gt;</span> <span class='texttt'>struct enable_if;</span> </td><td class='left'> </td><td class='left'>
 If <span class='texttt'>B</span> is <span class='texttt'>true</span>, the member typedef <span class='texttt'>type</span>
 shall equal <span class='texttt'>T</span>; otherwise, there shall be no member
 <span class='texttt'>type</span>. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;bool B, class T,</span> <span class='texttt'>class F&gt; struct conditional</span>; </td><td class='left'> </td><td class='left'>
 If <span class='texttt'>B</span> is <span class='texttt'>true</span>, the member typedef <span class='texttt'>type</span>
 shall equal <span class='texttt'>T</span>.
 If <span class='texttt'>B</span> is <span class='texttt'>false</span>, the member typedef <span class='texttt'>type</span>
 shall equal <span class='texttt'>F</span>. </td></tr><tr class='rowsep'><td class='left'>  <span class='texttt'>template &lt;class... T&gt;</span> <span class='texttt'>struct common_type;</span> </td><td class='left'> </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall be defined as set out below. All types in
the parameter pack <span class='texttt'>T</span> shall be complete or (possibly <i>cv</i>) <span class='texttt'>void</span>. A
program may specialize this trait if at least one template parameter in the
specialization is a user-defined type. [&nbsp;<i>Note:</i> Such specializations are
needed when only explicit conversions are desired among the template arguments.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class T&gt;</span><br/>
 <span class='texttt'>struct underlying_type;</span>  </td><td class='left'>
 <span class='texttt'>T</span> shall be an enumeration type (<a href='dcl.enum'>[dcl.enum]</a>) </td><td class='left'>
 The member typedef <span class='texttt'>type</span> shall name the underlying type
 of <span class='texttt'>T</span>. </td></tr><tr class='rowsep'><td class='left'> <span class='texttt'>template &lt;class Fn,</span><br/>
 <span class='texttt'>class... ArgTypes&gt; struct</span>
 <span class='texttt'>result_of&lt;Fn(ArgTypes...)&gt;;</span>  </td><td class='left'>
 <span class='texttt'>Fn</span> and all types in the parameter pack <span class='texttt'>ArgTypes</span> shall
 be complete types, (possibly cv-qualified) <span class='texttt'>void</span>, or arrays of
 unknown bound. </td><td class='left'>
 If the expression <span class='texttt'>INVOKE(declval&lt;Fn&gt;(), declval&lt;ArgTypes&gt;()...)</span>
 is well formed when treated as an unevaluated operand (Clause <a href='expr'>[expr]</a>),
 the member typedef <span class='texttt'>type</span> shall name the type
 <span class='texttt'>decltype(INVOKE(declval&lt;Fn&gt;(),</span> <span class='texttt'>declval&lt;ArgTypes&gt;()...))</span>;
 otherwise, there shall be no member <span class='texttt'>type</span>. Access checking is
 performed as if in a context unrelated to <span class='texttt'>Fn</span> and
 <span class='texttt'>ArgTypes</span>. Only the validity of the immediate context of the
 expression is considered.
 [&nbsp;<i>Note:</i>
 The compilation of the expression can result in side effects such as
 the instantiation of class template specializations and function
 template specializations, the generation of implicitly-defined
 functions, and so on. Such side effects are not in the “immediate
 context” and can result in the program being ill-formed.
 <i>&nbsp;—&nbsp;end note</i>&nbsp;] </td></tr></table></div><div class='para' id='trans.other-1'><div class='marginalizedparent'><a class='marginalized' href='#trans.other-1'>1</a></div><p >[&nbsp;<i>Note:</i> A typical implementation would define <span class='texttt'>aligned_storage</span> as:</p><pre class='codeblock'>
template &lt;std::size_t Len, std::size_t Alignment&gt;
struct aligned_storage {
  typedef struct {
    alignas(Alignment) unsigned char __data[Len];
  } type;
};
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='trans.other-2'><div class='marginalizedparent'><a class='marginalized' href='#trans.other-2'>2</a></div><p >It is <span class='indexparent'><a class='index' id='support_for_extended_alignment'></a></span>implementation-defined whether any extended alignment is
supported (<a href='basic.align'>[basic.align]</a>).</p></div><div class='para' id='trans.other-3'><div class='marginalizedparent'><a class='marginalized' href='#trans.other-3'>3</a></div><p >The nested typedef <span class='texttt'>common_type::type</span> shall be defined as follows:</p><pre class='codeblock'>
template &lt;class ...T&gt; struct common_type;

template &lt;class T&gt;
struct common_type&lt;T&gt; {
  typedef decay_t&lt;T&gt; type;
};

template &lt;class T, class U&gt;
struct common_type&lt;T, U&gt; {
  typedef decay_t&lt;decltype(true ? declval&lt;T&gt;() : declval&lt;U&gt;())&gt; type;
};

template &lt;class T, class U, class... V&gt;
struct common_type&lt;T, U, V...&gt; {
  typedef common_type_t&lt;common_type_t&lt;T, U&gt;, V...&gt; type;
};
</pre></div><div class='para' id='trans.other-4'><div class='marginalizedparent'><a class='marginalized' href='#trans.other-4'>4</a></div><p >[&nbsp;<i>Example:</i>
Given these definitions:
</p><pre class='codeblock'>
typedef bool (&amp;PF1)();
typedef short (*PF2)(long);

struct S {
  operator PF2() const;
  double operator()(char, int&amp;);
  void fn(long) const;
  char data;
};

typedef void (S::*PMF)(long) const;
typedef char S::*PMD;
</pre><p >the following assertions will hold:</p><pre class='codeblock'>
static_assert(is_same&lt;result_of_t&lt;S(int)&gt;, short&gt;::value, "Error!");
static_assert(is_same&lt;result_of_t&lt;S&amp;(unsigned char, int&amp;)&gt;, double&gt;::value, "Error!");
static_assert(is_same&lt;result_of_t&lt;PF1()&gt;, bool&gt;::value, "Error!");
static_assert(is_same&lt;result_of_t&lt;PMF(unique_ptr&lt;S&gt;, int)&gt;, void&gt;::value, "Error!");
static_assert(is_same&lt;result_of_t&lt;PMD(S)&gt;, char&amp;&amp;&gt;::value, "Error!");
static_assert(is_same&lt;result_of_t&lt;PMD(const S*)&gt;, const char&amp;&gt;::value, "Error!");
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></div></div></body></html>