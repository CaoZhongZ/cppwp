<!DOCTYPE html><html lang='en'><head><title>[temp.friend]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.5</a> Template declarations <a class='abbr_ref' href='temp.decls#temp.friend'>[temp.decls]</a></h2><div id='temp.friend'><h3 ><a class='secnum' style='min-width:103pt'>14.5.4</a> Friends <a class='abbr_ref'>[temp.friend]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='friend,template_and'></a></span>A friend of a class or class template can be a function template or
class template, a specialization of a function template or class
template, or a non-template function or class.
For a friend function declaration that is not a template declaration:</p><ul ><li ><p >if the name of the friend is a qualified or unqualified <i ><a href='temp.names#nt:template-id'>template-id</a></i>,
the friend declaration refers to a specialization of a function
template, otherwise,
</p></li><li ><p >if the name of the friend is a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> and a matching non-template
function is found in the specified class or namespace, the friend
declaration refers to that function, otherwise,
</p></li><li ><p >if the name of the friend is a <i ><a href='expr.prim.general#nt:qualified-id'>qualified-id</a></i> and a matching
function template
is found in the specified class
or namespace, the friend declaration refers to
the deduced specialization of that function template (<a href='temp.deduct.decl'>[temp.deduct.decl]</a>), otherwise,
</p></li><li ><p >the name shall be an <i ><a href='expr.prim.general#nt:unqualified-id'>unqualified-id</a></i> that declares (or redeclares) a
non-template function.
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; class task;
template&lt;class T&gt; task&lt;T&gt;* preempt(task&lt;T&gt;*);

template&lt;class T&gt; class task {
  friend void next_time();
  friend void process(task&lt;T&gt;*);
  friend task&lt;T&gt;* preempt&lt;T&gt;(task&lt;T&gt;*);
  template&lt;class C&gt; friend int func(C);

  friend class task&lt;int&gt;;
  template&lt;class P&gt; friend class frd;
};
</pre><p >Here,
each specialization of the
<span class='texttt'>task</span>
class template has the function
<span class='texttt'>next_time</span>
as a friend;
because
<span class='texttt'>process</span>
does not have explicit
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>,
each specialization of the
<span class='texttt'>task</span>
class template has an appropriately typed function
<span class='texttt'>process</span>
as a friend, and this friend is not a function template specialization;
because the friend
<span class='texttt'>preempt</span>
has an explicit
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
<span class='texttt'>T</span>,
each specialization of the
<span class='texttt'>task</span>
class template has the appropriate specialization of the function
template
<span class='texttt'>preempt</span>
as a friend;
and each specialization of the
<span class='texttt'>task</span>
class template has all specializations of the function template
<span class='texttt'>func</span>
as friends.
Similarly,
each specialization of the
<span class='texttt'>task</span>
class template has the class template specialization
<span class='texttt'>task&lt;int&gt;</span>
as a friend, and has all specializations of the class template
<span class='texttt'>frd</span>
as friends.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A friend template may be declared within a class or class template.
A friend function template may be defined within a class or class
template, but a friend class template may not be defined in a class
or class template.
In these cases, all specializations of the friend class or friend function
template are friends of the class or class template granting friendship.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class A {
  template&lt;class T&gt; friend class B;                 <span class='comment'>// OK
</span>  template&lt;class T&gt; friend void f(T)<span class='texttt'>{ /* ... */ }</span>  <span class='comment'>// OK
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >A template friend declaration specifies that all specializations of that
template, whether they are implicitly instantiated (<a href='temp.inst'>[temp.inst]</a>), partially
specialized (<a href='temp.class.spec'>[temp.class.spec]</a>) or explicitly specialized (<a href='temp.expl.spec'>[temp.expl.spec]</a>),
are friends of the class containing the template friend declaration.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class X {
  template&lt;class T&gt; friend struct A;
  class Y { };
};

template&lt;class T&gt; struct A { X::Y ab; };            <span class='comment'>// OK
</span>template&lt;class T&gt; struct A&lt;T*&gt; { X::Y ab; };        <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >When a function is defined in a friend function declaration in a class
template, the function is instantiated when the function is
odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>). The
same restrictions on multiple declarations and definitions that apply
to non-template function declarations and definitions also apply to
these implicit definitions.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A member of a class template may be declared to be a friend of a
non-template class.
In this case, the corresponding member of every specialization of
the class template is a friend of the class granting friendship.
For explicit specializations the corresponding member is the member (if any)
that has the same name, kind (type, function, class template, or function
template), template parameters, and signature as the member of the class
template instantiation that would otherwise have been generated.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  struct B { };
  void f();
  struct D {
    void g();
  };
};
template&lt;&gt; struct A&lt;int&gt; {
  struct B { };
  int f();
  struct D {
    void g();
  };
};

class C {
  template&lt;class T&gt; friend struct A&lt;T&gt;::B;    <span class='comment'>// grants friendship to <span class='texttt'>A&lt;int&gt;::B</span> even though
</span>                                              <span class='comment'>// it is not a specialization of <span class='texttt'>A&lt;T&gt;::B</span>
</span>  template&lt;class T&gt; friend void A&lt;T&gt;::f();    <span class='comment'>// does not grant friendship to <span class='texttt'>A&lt;int&gt;::f()</span>
</span>                                              <span class='comment'>// because its return type does not match
</span>  template&lt;class T&gt; friend void A&lt;T&gt;::D::g(); <span class='comment'>// does not grant friendship to <span class='texttt'>A&lt;int&gt;::D::g()</span>
</span>                                              <span class='comment'>// because <span class='texttt'>A&lt;int&gt;::D</span> is not a specialization of <span class='texttt'>A&lt;T&gt;::D</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >[&nbsp;<i>Note:</i>
A friend declaration may first declare a member of an enclosing namespace scope (<a href='temp.inject'>[temp.inject]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >A friend template shall not be declared in a local class.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >Friend declarations shall not declare partial specializations.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; class A { };
class X {
  template&lt;class T&gt; friend class A&lt;T*&gt;; <span class='comment'>// error
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >When a friend declaration refers to a specialization of a function
template, the function parameter declarations shall not include
default arguments, nor shall the inline specifier be used in such a
declaration.</p></div></div></div></body></html>