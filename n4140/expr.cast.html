<!DOCTYPE html><html lang='en'><head><title>[expr.cast]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>5</a> Expressions <a class='abbr_ref' href='./#expr'>[expr]</a></h1><div id='expr.cast'><h2 ><a class='secnum' style='min-width:88pt'>5.4</a> Explicit type conversion (cast notation) <a class='abbr_ref'>[expr.cast]</a></h2><p ><span class='indexparent'><a class='index' id='expression,cast'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The result of the expression <span class='texttt'>(T)</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i> is
of type <span class='texttt'>T</span>. The result is an lvalue if <span class='texttt'>T</span> is an lvalue
reference type or an rvalue reference to function type and an xvalue if <span class='texttt'>T</span>
is an rvalue reference to object type; otherwise the result is a prvalue.
[&nbsp;<i>Note:</i> 
if <span class='texttt'>T</span> is a non-class type that is cv-qualified, the
<span class='grammarterm'>cv-qualifiers</span> are discarded when determining the type of the
resulting prvalue; see Clause <a href='expr'>[expr]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;] </p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >An explicit type conversion can be expressed using functional
notation (<a href='expr.type.conv'>[expr.type.conv]</a>), a type conversion operator
(<span class='texttt'>dynamic_cast</span>, <span class='texttt'>static_cast</span>, <span class='texttt'>reinterpret_cast</span>,
<span class='texttt'>const_cast</span>), or the <a class='hidden_link' href='#def:cast' id='def:cast'><i>cast</i></a> notation.</p><pre class='bnf'><a id='nt:cast-expression'>cast-expression:</a>
    <i ><a href='expr.unary#nt:unary-expression'>unary-expression</a></i>
    <span class='terminal'>(</span> <i ><a href='dcl.name#nt:type-id'>type-id</a></i> <span class='terminal'>)</span> <i ><a href='expr.cast#nt:cast-expression'>cast-expression</a></i></pre></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >Any type conversion not mentioned below and not explicitly defined by
the user (<a href='class.conv'>[class.conv]</a>) is ill-formed.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The conversions performed by</p><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><p ><span class='indexparent'><a class='index' id='cast,const'></a></span><span class='indexparent'><a class='index' id='cast,static'></a></span><span class='indexparent'><a class='index' id='cast,reinterpret'></a></span></p><p >a <span class='texttt'>const_cast</span> (<a href='expr.const.cast'>[expr.const.cast]</a>),
</p></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><p >a <span class='texttt'>static_cast</span> (<a href='expr.static.cast'>[expr.static.cast]</a>),
</p></li><li id='4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.3'>(4.3)</a></div><p >a <span class='texttt'>static_cast</span> followed by a <span class='texttt'>const_cast</span>,
</p></li><li id='4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.4'>(4.4)</a></div><p >a <span class='texttt'>reinterpret_cast</span> (<a href='expr.reinterpret.cast'>[expr.reinterpret.cast]</a>), or
</p></li><li id='4.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.5'>(4.5)</a></div><p >a <span class='texttt'>reinterpret_cast</span> followed by a <span class='texttt'>const_cast</span>,
</p></li></ul><p >can be performed using the cast notation of explicit type conversion.
The same semantic restrictions and behaviors apply, with the exception
that in performing a <span class='texttt'>static_cast</span> in the following situations the
conversion is valid even if the base class is inaccessible:</p><ul class='itemize'><li id='4.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.6'>(4.6)</a></div><p >a pointer to an object of derived class type or an lvalue or
rvalue of derived class type may be explicitly converted to a pointer or
reference to an unambiguous base class type, respectively;</p></li><li id='4.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.7'>(4.7)</a></div><p >a pointer to member of derived class type may be explicitly
converted to a pointer to member of an unambiguous non-virtual base
class type;</p></li><li id='4.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.8'>(4.8)</a></div><p >a pointer to an object of an unambiguous non-virtual base class
type, a glvalue of an unambiguous non-virtual base class type,
or a pointer to member of an unambiguous non-virtual base class type may
be explicitly converted to a pointer, a reference, or a pointer to
member of a derived class type, respectively.
</p></li></ul><p >If a conversion can be interpreted in more than one of the ways listed
above, the interpretation that appears first in the list is used, even
if a cast resulting from that interpretation is ill-formed. If a
conversion can be interpreted in more than one way as a
<span class='texttt'>static_cast</span> followed by a <span class='texttt'>const_cast</span>, the conversion is
ill-formed.
[&nbsp;<i>Example:</i> </p><pre class='codeblock'>
struct A { };
struct I1 : A { };
struct I2 : A { };
struct D : I1, I2 { };
A* foo( D* p ) {
  return (A*)( p ); <span class='comment'>// ill-formed <span class='texttt'>static_cast</span> interpretation
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;] </p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p ><span class='indexparent'><a class='index' id='class,cast_to_incomplete'></a></span>The operand of a cast using the cast notation can be a prvalue of type
“pointer to incomplete class type”. The destination type of a cast
using the cast notation can be “pointer to incomplete class type”. If
both the operand and destination types are class types and one or both
are incomplete, it is unspecified whether the <span class='texttt'>static_cast</span> or the
<span class='texttt'>reinterpret_cast</span> interpretation is used, even if there is an
inheritance relationship between the two classes.
[&nbsp;<i>Note:</i>
For example, if the classes were defined later in the translation unit,
a multi-pass compiler would be permitted to interpret a cast between
pointers to the classes as if the class types were complete at the point
of the cast.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]<span class='indexparent'><a class='index' id='expression,cast'></a></span></p></div></div></div></body></html>