<!DOCTYPE html><html lang='en'><head><title>[basic.stc.dynamic.deallocation]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>3.7</a> Storage duration <a class='abbr_ref' href='basic.stc#dynamic.deallocation'>[basic.stc]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>3.7.4</a> Dynamic storage duration <a class='abbr_ref' href='basic.stc.dynamic#deallocation'>[basic.stc.dynamic]</a></h3><div id='basic.stc.dynamic.deallocation'><h4 ><a class='secnum' style='min-width:118pt'>3.7.4.2</a> Deallocation functions <a class='abbr_ref'>[basic.stc.dynamic.deallocation]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='function,deallocation'></a></span>Deallocation functions shall be class member functions or global
functions; a program is ill-formed if deallocation functions are
declared in a namespace scope other than global scope or declared static
in global scope.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='delete,overloading_and'></a></span>Each deallocation function shall return <span class='texttt'>void</span> and its first
parameter shall be <span class='texttt'>void*</span>. A deallocation function can have more
than one parameter.
The global <span class='texttt'>operator delete</span> with exactly one parameter is a usual
(non-placement) deallocation function. The global <span class='texttt'>operator delete</span> with
exactly two parameters, the second of which has type <span class='texttt'>std::size_t</span>, is a usual
deallocation function. Similarly, the global <span class='texttt'>operator delete[]</span> with exactly one
parameter is a usual deallocation function. The global <span class='texttt'>operator delete[]</span> with
exactly two parameters, the second of which has type <span class='texttt'>std::size_t</span>, is a usual
deallocation function.<a class='footnotenum' href='#footnote-37'>37</a>
If a class <span class='texttt'>T</span> has a member deallocation
function named <span class='texttt'>operator</span> <span class='texttt'>delete</span> with exactly one
parameter, then that function is a usual deallocation
function. If class <span class='texttt'>T</span> does not declare such an <span class='texttt'>operator</span>
<span class='texttt'>delete</span> but does declare a member deallocation function named
<span class='texttt'>operator</span> <span class='texttt'>delete</span> with exactly two parameters, the second
of which has type <span class='texttt'>std::size_t</span>, then this
function is a usual deallocation function. Similarly, if a class
<span class='texttt'>T</span> has a member deallocation function named <span class='texttt'>operator</span>
<span class='texttt'>delete[]</span> with exactly one parameter, then that function is a
usual (non-placement) deallocation function. If class <span class='texttt'>T</span> does not
declare such an <span class='texttt'>operator</span> <span class='texttt'>delete[]</span> but does declare a
member deallocation function named <span class='texttt'>operator</span> <span class='texttt'>delete[]</span>
with exactly two parameters, the second of which has type
<span class='texttt'>std::size_t</span>, then this function is a usual deallocation
function. A deallocation function can be an instance of a function
template. Neither the first parameter nor the return type shall depend
on a template parameter. [&nbsp;<i>Note:</i> That is, a deallocation function
template shall have a first parameter of type <span class='texttt'>void*</span> and a return
type of <span class='texttt'>void</span> (as specified above). <i>&nbsp;â€”&nbsp;end note</i>&nbsp;] A deallocation
function template shall have two or more function parameters. A template
instance is never a usual deallocation function, regardless of its
signature.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >If a deallocation function terminates by throwing an exception, the behavior is undefined.
The value of the first argument supplied to a deallocation function may
be a null pointer value; if so, and if the deallocation function is one
supplied in the standard library, the call has no effect. Otherwise,
the behavior is undefined if
the
value supplied to <span class='texttt'>operator</span> <span class='texttt'>delete(void*)</span> in the standard
library is not one of the values returned by a previous invocation of
either <span class='texttt'>operator</span> <span class='texttt'>new(std::size_t)</span> or <span class='texttt'>operator</span>
<span class='texttt'>new(std::size_t,</span> <span class='texttt'>const</span> <span class='texttt'>std::nothrow_t&amp;)</span> in the
standard library, and
the behavior is undefined if
the value supplied to <span class='texttt'>operator</span>
<span class='texttt'>delete[](void*)</span> in the standard library is not one of the
values returned by a previous invocation of either <span class='texttt'>operator</span>
<span class='texttt'>new[](std::size_t)</span> or <span class='texttt'>operator</span>
<span class='texttt'>new[](std::size_t,</span> <span class='texttt'>const</span> <span class='texttt'>std::nothrow_t&amp;)</span> in
the standard library.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >If the argument given to a deallocation function in the standard library
is a pointer that is not the null pointer value (<a href='conv.ptr'>[conv.ptr]</a>), the
deallocation function shall deallocate the storage referenced by the
pointer, rendering invalid all pointers referring to any part of the
deallocated storage.
<span class='indexparent'><a class='index' id='object,undefined_deleted'></a></span>Indirection through an invalid pointer value and passing an invalid
pointer value to a deallocation function have undefined behavior. Any
other use of an invalid pointer value has implementation-defined
behavior.<a class='footnotenum' href='#footnote-38'>38</a></p></div><div class='footnote' id='footnote-37'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-37'>37)</a></div><p >This deallocation function precludes use of an
allocation function <span class='texttt'>void operator new(std::size_t, std::size_t)</span> as a placement
allocation function (<a href='diff.cpp11.basic'>[diff.cpp11.basic]</a>).</p></div><div class='footnote' id='footnote-38'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-38'>38)</a></div><p >Some implementations might define that copying an
  invalid pointer value causes a system-generated runtime fault.</p></div></div></div></body></html>