<!DOCTYPE html><html lang='en'><head><title>[class.init]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>12</a> Special member functions <a class='abbr_ref' href='./#special'>[special]</a></h1><div id='class.init'><h2 ><a class='secnum' style='min-width:88pt'>12.6</a> Initialization <a class='abbr_ref'>[class.init]</a></h2><p ><span class='indexparent'><a class='index' id='initialization,class_object'></a></span><span class='indexparent'><a class='index' id='initialization,default_constructor_and'></a></span><span class='indexparent'><a class='index' id='initialization,constructor_and'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >When no initializer is specified for an object of (possibly
cv-qualified) class type (or array thereof), or the initializer has
the form
<span class='texttt'>()</span>,
the object is initialized as specified in <a href='dcl.init'>[dcl.init]</a>.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >An object of class type (or array thereof) can be explicitly initialized;
see <a href='class.expl.init'>[class.expl.init]</a> and <a href='class.base.init'>[class.base.init]</a>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='order_of_execution,constructor_and_array'></a></span>When an array of class objects is initialized
(either explicitly or implicitly) and the elements are initialized by constructor,
the constructor shall be called for each element of the array,
following the subscript order; see <a href='dcl.array'>[dcl.array]</a>.
[&nbsp;<i>Note:</i>
Destructors for the array elements are called in reverse order of their
construction.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='class.expl.init'><h3 ><a class='secnum' href='#class.expl.init' style='min-width:103pt'>12.6.1</a> Explicit initialization <a class='abbr_ref' href='class.expl.init'>[class.expl.init]</a></h3><p ><span class='indexparent'><a class='index' id='initialization,explicit'></a></span><span class='indexparent'><a class='index' id='initialization,constructor_and'></a></span>
</p><div class='para' id='class.expl.init-1'><div class='marginalizedparent'><a class='marginalized' href='#class.expl.init-1'>1</a></div><p >An object of class type can be initialized with a parenthesized
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>,
where the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
is construed as an argument list for a constructor
that is called to initialize the object.
Alternatively, a single
<i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
can be specified as an
<i ><a href='dcl.init#nt:initializer'>initializer</a></i>
using the
<span class='texttt'>=</span>
form of initialization.
Either direct-initialization semantics or copy-initialization semantics apply;
see <a href='dcl.init'>[dcl.init]</a>.
<span class='indexparent'><a class='index' id='example,constructor_and_initialization'></a></span>[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct complex {
  complex();
  complex(double);
  complex(double,double);
};

complex sqrt(complex,complex);

complex a(1);                   <span class='comment'>// initialize by a call of
</span>                                <span class='comment'>// <span class='texttt'>complex(double)</span>
</span>complex b = a;                  <span class='comment'>// initialize by a copy of <span class='texttt'>a</span>
</span>complex c = complex(1,2);       <span class='comment'>// construct <span class='texttt'>complex(1,2)</span>
</span>                                <span class='comment'>// using <span class='texttt'>complex(double,double)</span>
</span>                                <span class='comment'>// copy/move it into <span class='texttt'>c</span>
</span>complex d = sqrt(b,c);          <span class='comment'>// call <span class='texttt'>sqrt(complex,complex)</span>
</span>                                <span class='comment'>// and copy/move the result into <span class='texttt'>d</span>
</span>complex e;                      <span class='comment'>// initialize by a call of
</span>                                <span class='comment'>// <span class='texttt'>complex()</span>
</span>complex f = 3;                  <span class='comment'>// construct <span class='texttt'>complex(3)</span> using
</span>                                <span class='comment'>// <span class='texttt'>complex(double)</span>
</span>                                <span class='comment'>// copy/move it into <span class='texttt'>f</span>
</span>complex g = { 1, 2 };           <span class='comment'>// initialize by a call of
</span>                                <span class='comment'>// <span class='texttt'>complex(double, double)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
<span class='indexparent'><a class='index' id='initialization,overloaded_assignment_and'></a></span>overloading of the assignment operator (<a href='over.ass'>[over.ass]</a>)
has no effect on initialization.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.expl.init-2'><div class='marginalizedparent'><a class='marginalized' href='#class.expl.init-2'>2</a></div><p ><span class='indexparent'><a class='index' id='initialization,array_of_class_objects'></a></span><span class='indexparent'><a class='index' id='constructor,array_of_class_objects_and'></a></span>An object of class type can also be initialized by a
<i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>. List-initialization semantics apply;
see <a href='dcl.init'>[dcl.init]</a> and <a href='dcl.init.list'>[dcl.init.list]</a>. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
complex v[6] = { 1, complex(1,2), complex(), 2 };
</pre><p >Here,
<span class='texttt'>complex::complex(double)</span>
is called for the initialization of
<span class='texttt'>v[0]</span>
and
<span class='texttt'>v[3]</span>,
<span class='texttt'>complex::complex(<span class='discretionary'></span>double, double)</span>
is called for the initialization of
<span class='texttt'>v[1]</span>,
<span class='texttt'>complex::complex()</span>
is called for the initialization
<span class='texttt'>v[2]</span>,
<span class='texttt'>v[4]</span>,
and
<span class='texttt'>v[5]</span>.
For another example,</p><pre class='codeblock'>
struct X {
  int i;
  float f;
  complex c;
} x = { 99, 88.8, 77.7 };
</pre><p >Here,
<span class='texttt'>x.i</span>
is initialized with 99,
<span class='texttt'>x.f</span>
is initialized with 88.8, and
<span class='texttt'>complex::complex(double)</span>
is called for the initialization of
<span class='texttt'>x.c</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
Braces can be elided in the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
for any aggregate, even if the aggregate has members of a class type with
user-defined type conversions; see <a href='dcl.init.aggr'>[dcl.init.aggr]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.expl.init-3'><div class='marginalizedparent'><a class='marginalized' href='#class.expl.init-3'>3</a></div><p >[&nbsp;<i>Note:</i>
If
<span class='texttt'>T</span>
is a class type with no default constructor,
any declaration of an object of type
<span class='texttt'>T</span>
(or array thereof) is ill-formed if no
<i ><a href='dcl.init#nt:initializer'>initializer</a></i>
is explicitly specified (see <a href='class.init'>[class.init]</a> and <a href='dcl.init'>[dcl.init]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.expl.init-4'><div class='marginalizedparent'><a class='marginalized' href='#class.expl.init-4'>4</a></div><p >[&nbsp;<i>Note:</i>
<span class='indexparent'><a class='index' id='order_of_execution,constructor_and_static_objects'></a></span>the order in which objects with static or thread storage duration
are initialized is described in <a href='basic.start.init'>[basic.start.init]</a> and <a href='stmt.dcl'>[stmt.dcl]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='class.base.init'><h3 ><a class='secnum' href='#class.base.init' style='min-width:103pt'>12.6.2</a> Initializing bases and members <a class='abbr_ref' href='class.base.init'>[class.base.init]</a></h3><p ><span class='indexparent'><a class='index' id='initialization,base_class'></a></span><span class='indexparent'><a class='index' id='initialization,member'></a></span></p><div class='para' id='class.base.init-1'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-1'>1</a></div><p >In the definition of a constructor for a class,
initializers for direct and virtual base subobjects and
non-static data members can be specified by a
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>,
which has the form</p><pre class='bnf'><a id='nt:ctor-initializer'>ctor-initializer:</a>
    <span class='terminal'>:</span> <i ><a href='class.base.init#nt:mem-initializer-list'>mem-initializer-list</a></i></pre><pre class='bnf'><a id='nt:mem-initializer-list'>mem-initializer-list:</a>
    <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>,</span> <i ><a href='class.base.init#nt:mem-initializer-list'>mem-initializer-list</a></i></pre><pre class='bnf'><a id='nt:mem-initializer'>mem-initializer:</a>
    <i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i> <span class='terminal'>(</span> <i ><a href='expr.post#nt:expression-list'>expression-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>)</span>
    <i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i> <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i></pre><pre class='bnf'><a id='nt:mem-initializer-id'>mem-initializer-id:</a>
    <i ><a href='class.derived#nt:class-or-decltype'>class-or-decltype</a></i>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i></pre></div><div class='para' id='class.base.init-2'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-2'>2</a></div><p >In a <i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i> an initial unqualified
<i ><a href='lex.name#nt:identifier'>identifier</a></i> is looked up in the scope of the constructor's class
and, if not found in that scope, it is looked up in the scope containing the
constructor's definition.
[&nbsp;<i>Note:</i>
If the constructor's class contains a member with the same name as a direct
or virtual base class of the class, a
<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i>
naming the member or base class and composed of a single identifier
refers to the class member.
A
<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i>
for the hidden base class may be specified using a qualified name.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
Unless the
<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i>
names the constructor's class,
a non-static data member of the constructor's class, or
a direct or virtual base of that class,
the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
is ill-formed.</p></div><div class='para' id='class.base.init-3'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-3'>3</a></div><p >A
<i ><a href='class.base.init#nt:mem-initializer-list'>mem-initializer-list</a></i>
can initialize a base class using any <i ><a href='class.derived#nt:class-or-decltype'>class-or-decltype</a></i> that denotes that base class type.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct A { A(); };
  typedef A global_A;
  struct B { };
  struct C: public A, public B { C(); };
  C::C(): global_A() { }        <span class='comment'>// mem-initializer for base <span class='texttt'>A</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-4'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-4'>4</a></div><p >If a
<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i>
is ambiguous because it designates both a direct non-virtual base class and
an inherited virtual base class, the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
is ill-formed.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct A { A(); };
struct B: public virtual A { };
struct C: public A, public B { C(); };
C::C(): A() { }                 <span class='comment'>// ill-formed: which <span class='texttt'>A</span>?
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-5'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-5'>5</a></div><p >A
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>
may initialize a variant member of the
constructor's class.
If a
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>
specifies more than one
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
for the same member or for the same base class,
the
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>
is ill-formed.</p></div><div class='para' id='class.base.init-6'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-6'>6</a></div><p >A <i ><a href='class.base.init#nt:mem-initializer-list'>mem-initializer-list</a></i> can delegate to another
constructor of the constructor's class using any
<i ><a href='class.derived#nt:class-or-decltype'>class-or-decltype</a></i> that denotes the constructor's class itself. If a
<span class='small'></span><span class='rmfamily'></span><i> mem-initializer-id</i> designates the constructor's class,
it shall be the only <span class='small'></span><span class='rmfamily'></span><i> mem-initializer</i>; the constructor
is a <a class='hidden_link' href='#def:delegating_constructor' id='def:delegating_constructor'><i>delegating constructor</i></a>, and the constructor selected by the
<span class='small'></span><span class='rmfamily'></span><i> mem-initializer</i> is the <a class='hidden_link' href='#def:target_constructor' id='def:target_constructor'><i>target constructor</i></a>.
The <a class='hidden_link' href='#def:principal_constructor' id='def:principal_constructor'><i>principal constructor</i></a> is the first constructor invoked in
the construction of an object (that is, not a target constructor for that
object's construction). The target constructor is selected by overload resolution.
Once the target constructor returns, the body of the delegating constructor
is executed. If a constructor delegates to itself directly or indirectly,
the program is ill-formed; no diagnostic is required. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct C {
  C( int ) { }                  <span class='comment'>// #1: non-delegating constructor
</span>  C(): C(42) { }                <span class='comment'>// #2: delegates to #1
</span>  C( char c ) : C(42.0) { }     <span class='comment'>// #3: ill-formed due to recursion with #4
</span>  C( double d ) : C('a') { }    <span class='comment'>// #4: ill-formed due to recursion with #3
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-7'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-7'>7</a></div><p ><span class='indexparent'><a class='index' id='initialization,base_class'></a></span><span class='indexparent'><a class='index' id='initialization,member_object'></a></span>The
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
or <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>
in a
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
is used to initialize the
designated subobject (or, in the case of a delegating constructor, the complete class object)
according to the initialization rules of <a href='dcl.init'>[dcl.init]</a> for direct-initialization.</p><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct B1 { B1(int); <span class='comment'>/* ... */</span> };
struct B2 { B2(int); <span class='comment'>/* ... */</span> };
struct D : B1, B2 {
  D(int);
  B1 b;
  const int c;
};

D::D(int a) : B2(a+1), B1(a+2), c(a+3), b(a+4)
  { <span class='comment'>/* ... */</span> }
D d(10);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
The initialization
performed by each <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
constitutes a full-expression.
Any expression in
a
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
is evaluated as part of the full-expression that performs the initialization.
A <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> where the <i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i> denotes
a virtual base class is ignored during execution of a constructor of any class that is
not the most derived class.</p></div><div class='para' id='class.base.init-8'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-8'>8</a></div><p >In a non-delegating constructor, if
a given potentially constructed subobject is not designated by a
<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i>
(including the case where there is no
<i ><a href='class.base.init#nt:mem-initializer-list'>mem-initializer-list</a></i>
because the constructor has no
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>),
then</p><ul ><li ><p >if the entity is a non-static data member that has a <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> and either</p><ul ><li ><p >the constructor's class is a union (<a href='class.union'>[class.union]</a>), and no other variant
member of that union is designated by a <i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i> or</p></li><li ><p >the constructor's class is not a union, and, if the entity is a member of an
anonymous union, no other member of that union is designated by a
<i ><a href='class.base.init#nt:mem-initializer-id'>mem-initializer-id</a></i>,
</p></li></ul><p >the entity is initialized as specified in <a href='dcl.init'>[dcl.init]</a>;</p></li><li ><p >otherwise, if the entity is an anonymous union or a variant member (<a href='class.union'>[class.union]</a>), no initialization is performed;</p></li><li ><p >otherwise, the entity is default-initialized (<a href='dcl.init'>[dcl.init]</a>).
</p></li></ul><p >[&nbsp;<i>Note:</i> An abstract class (<a href='class.abstract'>[class.abstract]</a>) is never a most derived
class, thus its constructors never initialize virtual base classes, therefore the
corresponding <i ><a href='class.base.init#nt:mem-initializer'>mem-initializers</a></i> may be omitted. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
An attempt to initialize more than one non-static data member of a union renders the
program ill-formed.
<span class='indexparent'><a class='index' id='initialization,const_member'></a></span><span class='indexparent'><a class='index' id='initialization,reference_member'></a></span>[&nbsp;<i>Note:</i>
After the call to a constructor for class
<span class='texttt'>X</span>
for an object with automatic or dynamic storage duration
has completed, if
the constructor was not invoked as part of value-initialization and
a member of
<span class='texttt'>X</span>
is neither initialized nor
given a value
during execution of the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> of the body of the constructor,
the member has an indeterminate value.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct A {
  A();
};

struct B {
  B(int);
};

struct C {
  C() { }               <span class='comment'>// initializes members as follows:
</span>  A a;                    <span class='comment'>// OK: calls <span class='texttt'>A::A()</span>
</span>  const B b;              <span class='comment'>// error: <span class='texttt'>B</span> has no default constructor
</span>  int i;                  <span class='comment'>// OK: <span class='texttt'>i</span> has indeterminate value
</span>  int j = 5;              <span class='comment'>// OK: <span class='texttt'>j</span> has the value <span class='texttt'>5</span>
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-9'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-9'>9</a></div><p >If a given non-static data member has both a <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i>
and a <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>, the initialization specified by the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> is performed, and the non-static data member's 
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> is ignored.
[&nbsp;<i>Example:</i> Given
</p><pre class='codeblock'>
struct A {
  int i = <span class='comment'>/* some integer expression with side effects */</span> ;
  A(int arg) : i(arg) { }
  <span class='comment'>// ...
</span>};
</pre><p >the <span class='texttt'>A(int)</span> constructor will simply initialize <span class='texttt'>i</span> to the value of
<span class='texttt'>arg</span>, and the
<span class='indexparent'><a class='index' id='side_effects'></a></span>side effects in <span class='texttt'>i</span>'s <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i>
will not take place.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-10'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-10'>10</a></div><p >In a non-delegating constructor, the destructor for each potentially constructed
subobject of class type is potentially invoked (<a href='class.dtor'>[class.dtor]</a>).
[&nbsp;<i>Note:</i> This provision ensures that destructors can be called for fully-constructed
sub-objects in case an exception is thrown (<a href='except.ctor'>[except.ctor]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.base.init-11'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-11'>11</a></div><p >In a non-delegating constructor, initialization
proceeds in the following order:</p><ul ><li ><p ><span class='indexparent'><a class='index' id='initialization,order_of_virtual_base_class'></a></span>First, and only for the constructor of the most derived class (<a href='intro.object'>[intro.object]</a>),
virtual base classes are initialized in the order they appear on a
depth-first left-to-right traversal of the directed acyclic graph of
base classes,
where “left-to-right” is the order of appearance of the base classes
in the derived class
<i ><a href='class.derived#nt:base-specifier-list'>base-specifier-list</a></i>.
</p></li><li ><p ><span class='indexparent'><a class='index' id='initialization,order_of_base_class'></a></span>Then, direct base classes are initialized in declaration order
as they appear in the
<i ><a href='class.derived#nt:base-specifier-list'>base-specifier-list</a></i>
(regardless of the order of the
<span class='grammarterm'>mem-initializers</span>).
</p></li><li ><p ><span class='indexparent'><a class='index' id='initialization,order_of_member'></a></span>Then, non-static data members are initialized in the order
they were declared in the class definition
(again regardless of the order of the
<span class='grammarterm'>mem-initializers</span>).
</p></li><li ><p >Finally, the <i ><a href='stmt.block#nt:compound-statement'>compound-statement</a></i> of the constructor
body  is executed.
</p></li></ul><p >[&nbsp;<i>Note:</i>
The declaration order is mandated to ensure that base and member
subobjects are destroyed in the reverse order of initialization.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.base.init-12'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-12'>12</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct V {
  V();
  V(int);
};

struct A : virtual V {
  A();
  A(int);
};

struct B : virtual V {
  B();
  B(int);
};

struct C : A, B, virtual V {
  C();
  C(int);
};

A::A(int i) : V(i) { <span class='comment'>/* ... */</span> }
B::B(int i) { <span class='comment'>/* ... */</span> }
C::C(int i) { <span class='comment'>/* ... */</span> }

V v(1);             <span class='comment'>// use <span class='texttt'>V(int)</span>
</span>A a(2);             <span class='comment'>// use <span class='texttt'>V(int)</span>
</span>B b(3);             <span class='comment'>// use <span class='texttt'>V()</span>
</span>C c(4);             <span class='comment'>// use <span class='texttt'>V()</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-13'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-13'>13</a></div><p ><span class='indexparent'><a class='index' id='initializer,scope_of_member'></a></span>Names in the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
or <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>
of a
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
are evaluated in the scope of the constructor for which the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
is specified.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class X {
  int a;
  int b;
  int i;
  int j;
public:
  const int&amp; r;
  X(int i): r(a), b(i), i(i), j(this-&gt;i) { }
};
</pre><p >initializes
<span class='texttt'>X::r</span>
to refer to
<span class='texttt'>X::a</span>,
initializes
<span class='texttt'>X::b</span>
with the value of the constructor parameter
<span class='texttt'>i</span>,
initializes
<span class='texttt'>X::i</span>
with the value of the constructor parameter
<span class='texttt'>i</span>,
and initializes
<span class='texttt'>X::j</span>
with the value of
<span class='texttt'>X::i</span>;
this takes place each time an object of class
<span class='texttt'>X</span>
is created.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
Because the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
are evaluated in the scope of the constructor, the
<span class='texttt'>this</span>
pointer can be used in the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i>
of a
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i>
to refer to the object being initialized.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.base.init-14'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-14'>14</a></div><p ><span class='indexparent'><a class='index' id='initialization,member_function_call_during'></a></span>Member functions (including virtual member functions, <a href='class.virtual'>[class.virtual]</a>) can be
called for an object under construction.
Similarly, an object under construction can be the operand of the
<span class='texttt'>typeid</span>
operator (<a href='expr.typeid'>[expr.typeid]</a>) or of a
<span class='texttt'>dynamic_cast</span> (<a href='expr.dynamic.cast'>[expr.dynamic.cast]</a>).
However, if these operations are performed in a
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>
(or in a function called directly or indirectly from a
<i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>)
before all the
<i ><a href='class.base.init#nt:mem-initializer'>mem-initializers</a></i>
for base classes have completed, the result of the operation is undefined.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
class A {
public:
  A(int);
};

class B : public A {
  int j;
public:
  int f();
  B() : A(f()),     <span class='comment'>// undefined: calls member function
</span>                    <span class='comment'>// but base <span class='texttt'>A</span> not yet initialized
</span>  j(f()) { }        <span class='comment'>// well-defined: bases are all initialized
</span>};

class C {
public:
  C(int);
};

class D : public B, C {
  int i;
public:
  D() : C(f()),     <span class='comment'>// undefined: calls member function
</span>                    <span class='comment'>// but base <span class='texttt'>C</span> not yet initialized
</span>  i(f()) { }        <span class='comment'>// well-defined: bases are all initialized
</span>};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.base.init-15'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-15'>15</a></div><p >[&nbsp;<i>Note:</i>
<a href='class.cdtor'>[class.cdtor]</a> describes the result of virtual function calls,
<span class='texttt'>typeid</span>
and
<span class='texttt'>dynamic_cast</span>s
during construction for the well-defined cases;
that is, describes the
<a class='hidden_link' href='#def:polymorphic_behavior' id='def:polymorphic_behavior'><i>polymorphic behavior</i></a>
of an object under construction.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='class.base.init-16'><div class='marginalizedparent'><a class='marginalized' href='#class.base.init-16'>16</a></div><p ><span class='indexparent'><a class='index' id='initializer,pack_expansion'></a></span>A <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> followed by an ellipsis is
a pack expansion (<a href='temp.variadic'>[temp.variadic]</a>) that initializes the base
classes specified by a pack expansion in the <i ><a href='class.derived#nt:base-specifier-list'>base-specifier-list</a></i>
for the class. [&nbsp;<i>Example:</i></p><pre class='codeblock'>
template&lt;class... Mixins&gt;
class X : public Mixins... {
public:
  X(const Mixins&amp;... mixins) : Mixins(mixins)... { }
};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='initialization,class_object'></a></span></p></div></div></div></div></body></html>