<!DOCTYPE html><html lang='en'><head><title>[dcl.init]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>8</a> Declarators <a class='abbr_ref' href='./#dcl.decl'>[dcl.decl]</a></h1><div id='dcl.init'><h2 ><a class='secnum' style='min-width:88pt'>8.5</a> Initializers <a class='abbr_ref'>[dcl.init]</a></h2><p ><span class='indexparent'><a class='index' id='initialization'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A declarator can specify an initial value for the
identifier being declared.
The identifier designates a variable being initialized.
The process of initialization described in the
remainder of <a href='dcl.init'>[dcl.init]</a>
applies also to initializations
specified by other syntactic contexts, such as the initialization
of function parameters with argument expressions (<a href='expr.call'>[expr.call]</a>) or
the initialization of return values (<a href='stmt.return'>[stmt.return]</a>).</p><pre class='bnf'><a id='nt:initializer'>initializer:</a>
    <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i>
    <span class='terminal'>(</span> <i ><a href='expr.post#nt:expression-list'>expression-list</a></i> <span class='terminal'>)</span></pre><pre class='bnf'><a id='nt:brace-or-equal-initializer'>brace-or-equal-initializer:</a>
    <span class='terminal'>=</span> <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
    <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i></pre><pre class='bnf'><a id='nt:initializer-clause'>initializer-clause:</a>
    <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
    <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i></pre><pre class='bnf'><a id='nt:initializer-list'>initializer-list:</a>
    <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> <span class='terminal'>,</span> <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> <span class='terminal'>...</span><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:braced-init-list'>braced-init-list:</a>
    <span class='terminal'>{</span> <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> <span class='terminal'>,<span class='math'><sub ><span class='mathit'>opt</span></sub></span></span> <span class='terminal'>}</span>
    <span class='terminal'>{</span> <span class='terminal'>}</span></pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Except for objects declared with the <span class='texttt'>constexpr</span> specifier, for which see <a href='dcl.constexpr'>[dcl.constexpr]</a>,
an <i ><a href='dcl.init#nt:initializer'>initializer</a></i> in the definition of a variable can consist of
arbitrary
<span class='indexparent'><a class='index' id='initialization,automatic_object'></a></span><span class='indexparent'><a class='index' id='initialization,static_object'></a></span>expressions involving literals and previously declared
variables and functions,
regardless of the variable's storage duration.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int f(int);
int a = 2;
int b = f(a);
int c(b);
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >[&nbsp;<i>Note:</i>
Default arguments are more restricted; see <a href='dcl.fct.default'>[dcl.fct.default]</a>.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >The order of initialization of variables with static storage duration is described in <a href='basic.start'>[basic.start]</a>
and <a href='stmt.dcl'>[stmt.dcl]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A declaration of a block-scope variable with external or internal
linkage that has an <i ><a href='dcl.init#nt:initializer'>initializer</a></i> is ill-formed.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p ><span class='indexparent'><a class='index' id='initialization,static_object'></a></span><span class='indexparent'><a class='index' id='initialization,default'></a></span><span class='indexparent'><a class='index' id='variable,indeterminate_uninitialized'></a></span><span class='indexparent'><a class='index' id='zero-initialization'></a></span>To
<span class='grammarterm'>zero-initialize</span>
an object or reference of type
<span class='texttt'>T</span>
means:</p><ul ><li ><p >if
<span class='texttt'>T</span>
is a scalar type (<a href='basic.types'>[basic.types]</a>), the
object
is initialized to the value obtained by converting the integer literal <span class='texttt'>0</span>
(zero) to
<span class='texttt'>T</span>;<a class='footnotenum' href='#footnote-105'>105</a></p></li><li ><p >if
<span class='texttt'>T</span>
is a (possibly cv-qualified) non-union class type,
each non-static data member and each
base-class subobject is zero-initialized and padding is initialized to zero bits;</p></li><li ><p >if
<span class='texttt'>T</span>
is a (possibly cv-qualified) union type,
the
object's first non-static named
data member
is zero-initialized and padding is initialized to zero bits;</p></li><li ><p >if
<span class='texttt'>T</span>
is an array type,
each element is zero-initialized;
</p></li><li ><p >if
<span class='texttt'>T</span>
is a reference type, no initialization is performed.
</p></li></ul></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p ><span class='indexparent'><a class='index' id='default-initialization'></a></span>To
<span class='grammarterm'>default-initialize</span>
an object of type
<span class='texttt'>T</span>
means:</p><ul ><li ><p >if
<span class='texttt'>T</span>
is a (possibly cv-qualified) class type (Clause <a href='class'>[class]</a>), the default
constructor (<a href='class.ctor'>[class.ctor]</a>) for
<span class='texttt'>T</span>
is called (and the initialization is ill-formed if
<span class='texttt'>T</span>
has no default constructor or overload resolution (<a href='over.match'>[over.match]</a>) results
in an ambiguity or in a function that is deleted or inaccessible from the
context of the initialization);</p></li><li ><p >if
<span class='texttt'>T</span>
is an array type, each element is default-initialized;</p></li><li ><p >otherwise,
no initialization is performed.
</p></li></ul><p >If a program calls for the default initialization of an object of a
const-qualified type <span class='texttt'>T</span>, <span class='texttt'>T</span> shall be a class type with a user-provided default constructor.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p ><span class='indexparent'><a class='index' id='value-initialization'></a></span>To
<span class='grammarterm'>value-initialize</span>
an object of type
<span class='texttt'>T</span>
means:</p><ul ><li ><p >if
<span class='texttt'>T</span>
is a (possibly cv-qualified) class type (Clause <a href='class'>[class]</a>) with
either no default constructor (<a href='class.ctor'>[class.ctor]</a>) or a default
constructor that is user-provided or deleted, then the object is default-initialized;</p></li><li ><p >if
<span class='texttt'>T</span>
is a (possibly cv-qualified) class type without a
user-provided or deleted default constructor,
then the object is zero-initialized and the semantic constraints for
default-initialization are checked, and if <span class='texttt'>T</span> has a
non-trivial default constructor, the object is default-initialized;</p></li><li ><p >if
<span class='texttt'>T</span>
is an array type, then each element is value-initialized;</p></li><li ><p >otherwise, the object is zero-initialized.
</p></li></ul><p >An object that is value-initialized is deemed to be constructed and thus subject to
provisions of this International Standard applying to “constructed” objects, objects
“for which the constructor has completed,” etc., even if no constructor is invoked
for the object's initialization.</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >A program that calls for default-initialization
or value-initialization
of an entity
of reference type is ill-formed.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >[&nbsp;<i>Note:</i> Every
object of static storage duration is
zero-initialized at program startup before any other initialization
takes place.
In some cases, additional initialization is done later.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >An object whose initializer is an empty set of parentheses, i.e.,
<span class='texttt'>()</span>,
shall be
value-initialized.</p><p ><span class='indexparent'><a class='index' id='ambiguity,function_declaration'></a></span>[&nbsp;<i>Note:</i>
Since
<span class='texttt'>()</span>
is not permitted by the syntax for
<i ><a href='dcl.init#nt:initializer'>initializer</a></i>,</p><pre class='codeblock'>
X a();
</pre><p >is not the declaration of an object of class
<span class='texttt'>X</span>,
but the declaration of a function taking no argument and returning an
<span class='texttt'>X</span>.
The form
<span class='texttt'>()</span>
is permitted in certain other initialization contexts (<a href='expr.new'>[expr.new]</a>,
<a href='expr.type.conv'>[expr.type.conv]</a>, <a href='class.base.init'>[class.base.init]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p ><span class='indexparent'><a class='index' id='value,indeterminate'></a></span><span class='indexparent'><a class='index' id='indeterminate_value'></a></span>If no initializer is specified for an object, the object is default-initialized.
When storage for an object with automatic or dynamic storage duration
is obtained, the object has an <a class='hidden_link' href='#def:indeterminate_value' id='def:indeterminate_value'><i>indeterminate value</i></a>, and if
no initialization is performed for the object, that object retains an
indeterminate value until that value is replaced (<a href='expr.ass'>[expr.ass]</a>).
[&nbsp;<i>Note:</i> Objects with static or thread storage duration are zero-initialized,
see <a href='basic.start.init'>[basic.start.init]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
If an indeterminate value is produced by an evaluation, the behavior is
undefined except in the following cases:</p><ul ><li ><p >If an indeterminate value of unsigned narrow character
type (<a href='basic.fundamental'>[basic.fundamental]</a>) is produced by the evaluation of:
</p><ul ><li ><p >the second or third operand of a conditional expression (<a href='expr.cond'>[expr.cond]</a>),
</p></li><li ><p >the right operand of a comma expression (<a href='expr.comma'>[expr.comma]</a>),
</p></li><li ><p >the operand of a cast or conversion to an unsigned narrow character
type (<a href='conv.integral'>[conv.integral]</a>, <a href='expr.type.conv'>[expr.type.conv]</a>, <a href='expr.static.cast'>[expr.static.cast]</a>,
<a href='expr.cast'>[expr.cast]</a>), or
</p></li><li ><p >a discarded-value expression (Clause <a href='expr'>[expr]</a>),
</p></li></ul><p >then the result of the operation is an indeterminate value.</p></li><li ><p >If an indeterminate value of unsigned narrow character
type is produced by the evaluation of the right
operand of a simple assignment operator (<a href='expr.ass'>[expr.ass]</a>) whose first operand
is an lvalue of unsigned narrow character type, an indeterminate value replaces
the value of the object referred to by the left operand.</p></li><li ><p >If an indeterminate value of unsigned narrow character type is produced by the
evaluation of the initialization expression when initializing an object of
unsigned narrow character type, that object is initialized to an indeterminate
value.
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
  int f(bool b) {
    unsigned char c;
    unsigned char d = c; <span class='comment'>// OK, <span class='texttt'>d</span> has an indeterminate value
</span>    int e = d;           <span class='comment'>// undefined behavior
</span>    return b ? d : 0;    <span class='comment'>// undefined behavior if <span class='texttt'>b</span> is <span class='texttt'>true</span>
</span>  }
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p ><span class='indexparent'><a class='index' id='initialization,class_member'></a></span>An initializer for a static member is in the scope of the member's class.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int a;

struct X {
  static int a;
  static int b;
};

int X::a = 1;
int X::b = a;       <span class='comment'>// <span class='texttt'>X::b = X::a</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><p >The form of initialization (using parentheses or
<span class='texttt'>=</span>)
is generally insignificant, but does matter when the initializer or the entity
being initialized has a class type; see below.
If the entity being initialized does not have class type, the
<i ><a href='expr.post#nt:expression-list'>expression-list</a></i> in a
parenthesized initializer shall be a single expression.</p></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><p ><span class='indexparent'><a class='index' id='initialization,copy'></a></span><span class='indexparent'><a class='index' id='initialization,direct'></a></span>The initialization that occurs in the form</p><pre class='codeblock'>
T x = a;
</pre><p >as well as in argument passing, function return,
throwing an exception (<a href='except.throw'>[except.throw]</a>),
handling an exception (<a href='except.handle'>[except.handle]</a>),
and aggregate member initialization (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>)
is called
<a class='hidden_link' href='#def:copy-initialization' id='def:copy-initialization'><i>copy-initialization</i></a>.
[&nbsp;<i>Note:</i> Copy-initialization may invoke a move (<a href='class.copy'>[class.copy]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><p >The initialization that occurs in the forms</p><pre class='codeblock'>
T x(a);
T x{a};
</pre><p >as well as in
<span class='texttt'>new</span>
expressions (<a href='expr.new'>[expr.new]</a>),
<span class='texttt'>static_cast</span>
expressions (<a href='expr.static.cast'>[expr.static.cast]</a>),
functional notation type conversions (<a href='expr.type.conv'>[expr.type.conv]</a>),
and base and member initializers (<a href='class.base.init'>[class.base.init]</a>)
is called
<span class='grammarterm'>direct-initialization</span>.</p></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><p >The semantics of initializers are as follows.
The
<span class='indexparent'><a class='index' id='type,destination'></a></span><a class='hidden_link' href='#def:destination_type' id='def:destination_type'><i>destination type</i></a>
is the type of the object or reference being initialized and the
<a class='hidden_link' href='#def:source_type' id='def:source_type'><i>source type</i></a>
is the type of the initializer expression.
If the initializer is not a single (possibly parenthesized) expression, the
source type is not defined.</p><ul ><li ><p >If the initializer is a (non-parenthesized) <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>, the object or reference
is list-initialized (<a href='dcl.init.list'>[dcl.init.list]</a>).
</p></li><li ><p >If the destination type is a reference type, see <a href='dcl.init.ref'>[dcl.init.ref]</a>.
</p></li><li ><p >If the destination type is an array of characters,
an array of <span class='texttt'>char16_t</span>,
an array of <span class='texttt'>char32_t</span>,
or an array of
<span class='texttt'>wchar_t</span>,
and the initializer is a string literal, see <a href='dcl.init.string'>[dcl.init.string]</a>.
</p></li><li ><p >If the initializer is <span class='texttt'>()</span>, the object is value-initialized.
</p></li><li ><p >Otherwise, if the destination type is an array, the program is ill-formed.
</p></li><li ><p >If the destination type is a (possibly cv-qualified) class type:</p><ul ><li ><p >If the initialization is direct-initialization,
or if it is copy-initialization where the cv-unqualified version of the source
type is the same class as, or a derived class of, the class of the destination,
constructors are considered.
The applicable constructors
are enumerated (<a href='over.match.ctor'>[over.match.ctor]</a>), and the best one is chosen
through overload resolution (<a href='over.match'>[over.match]</a>).
The constructor so selected
is called to initialize the object, with the initializer
expression or <i ><a href='expr.post#nt:expression-list'>expression-list</a></i> as its argument(s).
If no constructor applies, or the overload resolution is
ambiguous, the initialization is ill-formed.
</p></li><li ><p >Otherwise (i.e., for the remaining copy-initialization cases),
user-defined conversion sequences that can convert from the
source type to the destination type or (when a conversion function
is used) to a derived class thereof are enumerated as described in <a href='over.match.copy'>[over.match.copy]</a>, and the best one is chosen through overload
resolution (<a href='over.match'>[over.match]</a>).  If the conversion cannot be done or
is ambiguous, the initialization is ill-formed.  The function
selected is called with the initializer expression as its
argument; if the function is a constructor, the call initializes
a temporary of the cv-unqualified version of the
destination type.  The temporary is a prvalue. The result of the call
(which is the temporary for the constructor case) is then used
to direct-initialize, according to the rules above, the object
that is the destination of the copy-initialization.  In certain
cases, an implementation is permitted to eliminate the copying
inherent in this direct-initialization by constructing the
intermediate result directly into the object being initialized;
see <a href='class.temporary'>[class.temporary]</a>, <a href='class.copy'>[class.copy]</a>.
</p></li></ul></li><li ><p >Otherwise, if the source type
is a (possibly cv-qualified) class type, conversion functions are
considered.
The applicable conversion functions are enumerated
(<a href='over.match.conv'>[over.match.conv]</a>), and the best one is chosen through overload
resolution (<a href='over.match'>[over.match]</a>).
The user-defined conversion so selected
is called to convert the initializer expression into the
object being initialized.
If the conversion cannot be done or is
ambiguous, the initialization is ill-formed.
</p></li><li ><p >Otherwise, the initial value of the object being initialized is
the (possibly converted) value of the initializer expression.
Standard conversions (Clause <a href='conv'>[conv]</a>) will be used, if necessary,
to convert the initializer expression to the cv-unqualified version of
the destination type;
no user-defined conversions are considered.
If the conversion cannot
be done, the initialization is ill-formed.
<span class='indexparent'><a class='index' id='initialization,const'></a></span>[&nbsp;<i>Note:</i>
An expression of type
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T</span>”
can initialize an object of type
“<span class='small'></span><span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T</span>”
independently of
the cv-qualifiers
<span class='small'></span><span class='rmfamily'></span><i> cv1</i>
and <span class='small'></span><span class='rmfamily'></span><i> cv2</i>.</p><pre class='codeblock'>
int a;
const int b = a;
int c = b;
</pre><p ><i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><p >An <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> followed by an ellipsis is a
pack expansion (<a href='temp.variadic'>[temp.variadic]</a>).</p></div><div class='footnote' id='footnote-105'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-105'>105)</a></div><p >As specified in <a href='conv.ptr'>[conv.ptr]</a>, converting an integer
literal whose value is
<span class='texttt'>0</span>
to a pointer type results in a null pointer value.
</p></div><div id='aggr'><h3 ><a class='secnum' href='#aggr' style='min-width:103pt'>8.5.1</a> Aggregates <a class='abbr_ref' href='dcl.init.aggr'>[dcl.init.aggr]</a></h3><p ><span class='indexparent'><a class='index' id='aggregate'></a></span><span class='indexparent'><a class='index' id='initialization,aggregate'></a></span><span class='indexparent'><a class='index' id='aggregate_initialization'></a></span><span class='indexparent'><a class='index' id='initialization,array'></a></span><span class='indexparent'><a class='index' id='initialization,class_object'></a></span><span class='indexparent'><a class='index' id='class_object_initialization'></a></span><span class='indexparent'><a class='index' id='{},initializer_list'></a></span></p><div class='para' id='aggr-1'><div class='marginalizedparent'><a class='marginalized' href='#aggr-1'>1</a></div><p >An
<a class='hidden_link' href='#def:aggregate' id='def:aggregate'><i>aggregate</i></a>
is an array or a class (Clause <a href='class'>[class]</a>) with no
user-provided constructors (<a href='class.ctor'>[class.ctor]</a>),
no private or protected non-static data members (Clause <a href='class.access'>[class.access]</a>),
no base classes (Clause <a href='class.derived'>[class.derived]</a>),
and no virtual functions (<a href='class.virtual'>[class.virtual]</a>).</p></div><div class='para' id='aggr-2'><div class='marginalizedparent'><a class='marginalized' href='#aggr-2'>2</a></div><p >When an aggregate is initialized by an initializer list, as specified in <a href='dcl.init.list'>[dcl.init.list]</a>, the elements of the initializer list are taken as initializers
for the members of the aggregate,
in increasing subscript or member order.
Each member is copy-initialized from the corresponding <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>. If the <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> is an expression and a narrowing conversion (<a href='dcl.init.list'>[dcl.init.list]</a>) is required to convert the expression, the program is ill-formed. [&nbsp;<i>Note:</i> If an <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> is itself an initializer list, the member is list-initialized, which will result in a recursive application of the rules in this section if the member is an aggregate. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct A {
  int x;
  struct B {
    int i;
    int j;
  } b;
} a = { 1, { 2, 3 } };
</pre><p >initializes
<span class='texttt'>a.x</span>
with 1,
<span class='texttt'>a.b.i</span>
with 2,
<span class='texttt'>a.b.j</span>
with 3.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-3'><div class='marginalizedparent'><a class='marginalized' href='#aggr-3'>3</a></div><p >An aggregate that is a class can also be initialized with a single
expression not enclosed in braces, as described in <a href='dcl.init'>[dcl.init]</a>.</p></div><div class='para' id='aggr-4'><div class='marginalizedparent'><a class='marginalized' href='#aggr-4'>4</a></div><p >An array of unknown size initialized with a
brace-enclosed
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
containing
<span class='texttt'>n</span>
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>,
where
<span class='texttt'>n</span>
shall be greater than zero, is defined as having
<span class='texttt'>n</span>
elements (<a href='dcl.array'>[dcl.array]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int x[] = { 1, 3, 5 };
</pre><p >declares and initializes
<span class='texttt'>x</span>
as a one-dimensional array that has three elements
since no size was specified and there are three initializers.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
An empty initializer list
<span class='texttt'>{}</span>
shall not be used as the <span class='grammarterm'>initializer-clause </span>
for an array of unknown bound.<a class='footnotenum' href='#footnote-106'>106</a></p></div><div class='para' id='aggr-5'><div class='marginalizedparent'><a class='marginalized' href='#aggr-5'>5</a></div><p >Static data members and anonymous bit-fields are not considered
members of the class for purposes of aggregate initialization.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct A {
  int i;
  static int s;
  int j;
  int :17;
  int k;
} a = { 1, 2, 3 };
</pre><p >Here, the second initializer 2 initializes
<span class='texttt'>a.j</span>
and not the static data member
<span class='texttt'>A::s</span>, and the third initializer 3 initializes <span class='texttt'>a.k</span>
and not the anonymous bit-field before it.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-6'><div class='marginalizedparent'><a class='marginalized' href='#aggr-6'>6</a></div><p >An
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
is ill-formed if the number of
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i> 
exceeds the number of members or elements to initialize.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
char cv[4] = { 'a', 's', 'd', 'f', 0 };     <span class='comment'>// error
</span></pre><p >is ill-formed.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-7'><div class='marginalizedparent'><a class='marginalized' href='#aggr-7'>7</a></div><p >If there are fewer <i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i> in the list than there
are members in the aggregate, then each member not explicitly initialized
shall be initialized from its <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> or,
if there is no <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i>, from an empty
initializer list (<a href='dcl.init.list'>[dcl.init.list]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct S { int a; const char* b; int c; int d = b[a]; };
S ss = { 1, "asdf" };
</pre><p >initializes
<span class='texttt'>ss.a</span>
with 1,
<span class='texttt'>ss.b</span>
with <span class='texttt'>"asdf"</span>,
<span class='texttt'>ss.c</span>
with the value of an expression of the form
<span class='texttt'>int{}</span>
(that is, <span class='texttt'>0</span>), and <span class='texttt'>ss.d</span> with the value of <span class='texttt'>ss.b[ss.a]</span>
(that is, <span class='texttt'>'s'</span>), and in</p><pre class='codeblock'>
struct X { int i, j, k = 42; };
X a[] = { 1, 2, 3, 4, 5, 6 };
X b[2] = { { 1, 2, 3 }, { 4, 5, 6 } };
</pre><p ><span class='texttt'>a</span> and <span class='texttt'>b</span> have the same value
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-8'><div class='marginalizedparent'><a class='marginalized' href='#aggr-8'>8</a></div><p >If an aggregate class <span class='texttt'>C</span> contains a subaggregate member
<span class='texttt'>m</span> that has no members for purposes of aggregate initialization,
the <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> for <span class='texttt'>m</span> shall not be
omitted from an <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> for an object of type
<span class='texttt'>C</span> unless the <i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i> for all
members of <span class='texttt'>C</span> following <span class='texttt'>m</span> are also omitted.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct S { } s;
struct A {
  S s1;
  int i1;
  S s2;
  int i2;
  S s3;
  int i3;
} a = {
  { },      <span class='comment'>// Required initialization
</span>  0,
  s,        <span class='comment'>// Required initialization
</span>  0
};          <span class='comment'>// Initialization not required for <span class='texttt'>A::s3</span> because <span class='texttt'>A::i3</span> is also not initialized
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-9'><div class='marginalizedparent'><a class='marginalized' href='#aggr-9'>9</a></div><p >If an incomplete or empty
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
leaves a member of reference type uninitialized, the program is ill-formed.</p></div><div class='para' id='aggr-10'><div class='marginalizedparent'><a class='marginalized' href='#aggr-10'>10</a></div><p >When initializing a multi-dimensional array,
the
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
initialize the elements with the last (rightmost) index of the array
varying the fastest (<a href='dcl.array'>[dcl.array]</a>).
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int x[2][2] = { 3, 1, 4, 2 };
</pre><p >initializes
<span class='texttt'>x[0][0]</span>
to
<span class='texttt'>3</span>,
<span class='texttt'>x[0][1]</span>
to
<span class='texttt'>1</span>,
<span class='texttt'>x[1][0]</span>
to
<span class='texttt'>4</span>,
and
<span class='texttt'>x[1][1]</span>
to
<span class='texttt'>2</span>.
On the other hand,</p><pre class='codeblock'>
float y[4][3] = {
  { 1 }, { 2 }, { 3 }, { 4 }
};
</pre><p >initializes the first column of
<span class='texttt'>y</span>
(regarded as a two-dimensional array)
and leaves the rest zero.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-11'><div class='marginalizedparent'><a class='marginalized' href='#aggr-11'>11</a></div><p >Braces can be elided in an
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
as follows.
If the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
begins with a left brace,
then the succeeding comma-separated list of
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
initializes the members of a subaggregate;
it is erroneous for there to be more
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
than members.
If, however, the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
for a subaggregate does not begin with a left brace,
then only enough
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
from the list are taken to initialize the members of the subaggregate;
any remaining
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>
are left to initialize the next member of the aggregate
of which the current subaggregate is a member.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
float y[4][3] = {
  { 1, 3, 5 },
  { 2, 4, 6 },
  { 3, 5, 7 },
};
</pre><p >is a completely-braced initialization:
1, 3, and 5 initialize the first row of the array
<span class='texttt'>y[0]</span>,
namely
<span class='texttt'>y[0][0]</span>,
<span class='texttt'>y[0][1]</span>,
and
<span class='texttt'>y[0][2]</span>.
Likewise the next two lines initialize
<span class='texttt'>y[1]</span>
and
<span class='texttt'>y[2]</span>.
The initializer ends early and therefore
<span class='texttt'>y[3]</span>s
elements are initialized as if explicitly initialized with an
expression of the form
<span class='texttt'>float()</span>,
that is, are initialized with
<span class='texttt'>0.0</span>.
In the following example, braces in the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
are elided;
however the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
has the same effect as the completely-braced
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>
of the above example,</p><pre class='codeblock'>
float y[4][3] = {
  1, 3, 5, 2, 4, 6, 3, 5, 7
};
</pre><p >The initializer for
<span class='texttt'>y</span>
begins with a left brace, but the one for
<span class='texttt'>y[0]</span>
does not,
therefore three elements from the list are used.
Likewise the next three are taken successively for
<span class='texttt'>y[1]</span>
and
<span class='texttt'>y[2]</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-12'><div class='marginalizedparent'><a class='marginalized' href='#aggr-12'>12</a></div><p >All implicit type conversions (Clause <a href='conv'>[conv]</a>) are considered when
initializing the aggregate member with an <i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>.
If the
<i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
can initialize a member, the member is initialized.
Otherwise, if the member is itself a subaggregate,
brace elision is assumed and the
<i ><a href='expr.ass#nt:assignment-expression'>assignment-expression</a></i>
is considered for the initialization of the first member of the subaggregate.
[&nbsp;<i>Note:</i> As specified above, brace elision cannot apply to
subaggregates with no members for purposes of aggregate initialization; an
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> for the entire subobject is
required.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct A {
  int i;
  operator int();
};
struct B {
  A a1, a2;
  int z;
};
A a;
B b = { 4, a, a };
</pre><p >Braces are elided around the
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
for
<span class='texttt'>b.a1.i</span>.
<span class='texttt'>b.a1.i</span>
is initialized with 4,
<span class='texttt'>b.a2</span>
is initialized with
<span class='texttt'>a</span>,
<span class='texttt'>b.z</span>
is initialized with whatever
<span class='texttt'>a.operator int()</span>
returns.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-13'><div class='marginalizedparent'><a class='marginalized' href='#aggr-13'>13</a></div><p ><span class='indexparent'><a class='index' id='initialization,array_of_class_objects'></a></span>[&nbsp;<i>Note:</i>
An aggregate array or an aggregate class may contain members of a
class type with a user-provided constructor (<a href='class.ctor'>[class.ctor]</a>).
Initialization of these aggregate objects is described in <a href='class.expl.init'>[class.expl.init]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='aggr-14'><div class='marginalizedparent'><a class='marginalized' href='#aggr-14'>14</a></div><p >[&nbsp;<i>Note:</i> Whether the initialization of aggregates with static storage duration is static or dynamic is specified in <a href='basic.start.init'>[basic.start.init]</a> and <a href='stmt.dcl'>[stmt.dcl]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='aggr-15'><div class='marginalizedparent'><a class='marginalized' href='#aggr-15'>15</a></div><p ><span class='indexparent'><a class='index' id='initialization,union'></a></span>When a union is initialized with a brace-enclosed initializer,
the braces shall only contain an
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
for the first non-static data member of the union.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
union u { int a; const char* b; };
u a = { 1 };
u b = a;
u c = 1;                        <span class='comment'>// error
</span>u d = { 0, "asdf" };            <span class='comment'>// error
</span>u e = { "asdf" };               <span class='comment'>// error
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='aggr-16'><div class='marginalizedparent'><a class='marginalized' href='#aggr-16'>16</a></div><p >[&nbsp;<i>Note:</i>
As described above,
the braces around the
<i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
for a union member can be omitted if the
union is a member of another aggregate.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-106'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-106'>106)</a></div><p >The syntax provides for empty
<i ><a href='dcl.init#nt:initializer-list'>initializer-lists</a></i>,
but nonetheless C++ does not have zero length arrays.</p></div></div><div id='string'><h3 ><a class='secnum' href='#string' style='min-width:103pt'>8.5.2</a> Character arrays <a class='abbr_ref' href='dcl.init.string'>[dcl.init.string]</a></h3><p ><span class='indexparent'><a class='index' id='initialization,character_array'></a></span></p><div class='para' id='string-1'><div class='marginalizedparent'><a class='marginalized' href='#string-1'>1</a></div><p >An array of narrow character type (<a href='basic.fundamental'>[basic.fundamental]</a>),
<span class='texttt'>char16_t</span> array,
<span class='texttt'>char32_t</span> array,
or <span class='texttt'>wchar_t</span> array
can be initialized by a
narrow string literal, <span class='texttt'>char16_t</span> string literal, <span class='texttt'>char32_t</span> string
literal, or wide string literal,
respectively, or by an appropriately-typed string literal enclosed in
braces (<a href='lex.string'>[lex.string]</a>).
<span class='indexparent'><a class='index' id='initialization,character_array'></a></span>Successive
characters of the
value of the string literal
initialize the elements of the array.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
char msg[] = "Syntax error on line %s\n";
</pre><p >shows a character array whose members are initialized
with a
<i ><a href='lex.string#nt:string-literal'>string-literal</a></i>.
Note that because
<span class='texttt'>'\n'</span>
is a single character and
because a trailing
<span class='texttt'>'\0'</span>
is appended,
<span class='texttt'>sizeof(msg)</span>
is
<span class='texttt'>25</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='string-2'><div class='marginalizedparent'><a class='marginalized' href='#string-2'>2</a></div><p >There shall not be more initializers than there are array elements.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
char cv[4] = "asdf";            <span class='comment'>// error
</span></pre><p >is ill-formed since there is no space for the implied trailing
<span class='texttt'>'\0'</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='string-3'><div class='marginalizedparent'><a class='marginalized' href='#string-3'>3</a></div><p >If there are fewer initializers than there are array elements, each element not
explicitly initialized shall be zero-initialized (<a href='dcl.init'>[dcl.init]</a>).</p></div></div><div id='ref'><h3 ><a class='secnum' href='#ref' style='min-width:103pt'>8.5.3</a> References <a class='abbr_ref' href='dcl.init.ref'>[dcl.init.ref]</a></h3><p ><span class='indexparent'><a class='index' id='initialization,reference'></a></span></p><div class='para' id='ref-1'><div class='marginalizedparent'><a class='marginalized' href='#ref-1'>1</a></div><p >A variable declared to be a
<span class='texttt'>T&amp;</span> or <span class='texttt'>T&amp;&amp;</span>,
that is, “reference to type
<span class='texttt'>T</span>”
(<a href='dcl.ref'>[dcl.ref]</a>),
shall be initialized by an object, or function, of type
<span class='texttt'>T</span>
or by an object that can be converted into a
<span class='texttt'>T</span>.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int g(int);
void f() {
  int i;
  int&amp; r = i;                   <span class='comment'>// <span class='texttt'>r</span> refers to <span class='texttt'>i</span>
</span>  r = 1;                        <span class='comment'>// the value of <span class='texttt'>i</span> becomes <span class='texttt'>1</span>
</span>  int* p = &amp;r;                  <span class='comment'>// <span class='texttt'>p</span> points to <span class='texttt'>i</span>
</span>  int&amp; rr = r;                  <span class='comment'>// <span class='texttt'>rr</span> refers to what <span class='texttt'>r</span> refers to, that is, to <span class='texttt'>i</span>
</span>  int (&amp;rg)(int) = g;           <span class='comment'>// <span class='texttt'>rg</span> refers to the function <span class='texttt'>g</span>
</span>  rg(i);                        <span class='comment'>// calls function <span class='texttt'>g</span>
</span>  int a[3];
  int (&amp;ra)[3] = a;             <span class='comment'>// <span class='texttt'>ra</span> refers to the array <span class='texttt'>a</span>
</span>  ra[1] = i;                    <span class='comment'>// modifies <span class='texttt'>a[1]</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='ref-2'><div class='marginalizedparent'><a class='marginalized' href='#ref-2'>2</a></div><p >A reference cannot be changed to refer to another object after initialization.
<span class='indexparent'><a class='index' id='assignment,reference'></a></span>Note that initialization of a reference is treated very differently from assignment
to it.
<span class='indexparent'><a class='index' id='argument_passing,reference_and'></a></span>Argument passing (<a href='expr.call'>[expr.call]</a>)
<span class='indexparent'><a class='index' id='return,reference_and'></a></span>and function value return (<a href='stmt.return'>[stmt.return]</a>) are initializations.</p></div><div class='para' id='ref-3'><div class='marginalizedparent'><a class='marginalized' href='#ref-3'>3</a></div><p >The initializer can be omitted for a reference only in a parameter declaration
(<a href='dcl.fct'>[dcl.fct]</a>), in the declaration of a function return type, in the declaration of
a class member within its class definition (<a href='class.mem'>[class.mem]</a>), and where the
<span class='texttt'>extern</span>
specifier is explicitly used.
<span class='indexparent'><a class='index' id='declaration,extern'></a></span>[&nbsp;<i>Example:</i></p><pre class='codeblock'>
int&amp; r1;                        <span class='comment'>// error: initializer missing
</span>extern int&amp; r2;                 <span class='comment'>// OK
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='ref-4'><div class='marginalizedparent'><a class='marginalized' href='#ref-4'>4</a></div><p >Given types “<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” and “<span class='small'></span><span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>,”
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is <span class='small'></span><span class='rmfamily'></span><i> reference-related</i> to
<span class='indexparent'><a class='index' id='reference-related'></a></span>“<span class='small'></span><span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>” if
<span class='texttt'>T1</span>
is the same type as
<span class='texttt'>T2</span>,
or
<span class='texttt'>T1</span>
is a base class of
<span class='texttt'>T2</span>.
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is <span class='small'></span><span class='rmfamily'></span><i> reference-compatible</i>
<span class='indexparent'><a class='index' id='reference-compatible'></a></span>with “<span class='small'></span><span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>” if
<span class='texttt'>T1</span>
is reference-related to
<span class='texttt'>T2</span>
and
<i>cv1</i>
is the same cv-qualification as, or greater cv-qualification than,
<i>cv2</i>.
In all cases where the reference-related or reference-compatible relationship
of two types is used to establish the validity of a reference binding, and
<span class='texttt'>T1</span>
is a base class of
<span class='texttt'>T2</span>,
a program that necessitates such a binding is ill-formed if
<span class='texttt'>T1</span>
is an inaccessible (Clause <a href='class.access'>[class.access]</a>) or ambiguous (<a href='class.member.lookup'>[class.member.lookup]</a>)
base class of
<span class='texttt'>T2</span>.</p></div><div class='para' id='ref-5'><div class='marginalizedparent'><a class='marginalized' href='#ref-5'>5</a></div><p >A reference to type “<i>cv1</i> <span class='texttt'>T1</span>” is initialized by
an expression of type “<i>cv2</i> <span class='texttt'>T2</span>” as follows:<span class='indexparent'><a class='index' id='binding,reference'></a></span></p><ul ><li ><p >If the reference is an lvalue reference and the initializer expression</p><ul ><li ><p >is an lvalue (but is not a
bit-field), and
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is reference-compatible with
“<span class='small'></span><span class='rmfamily'></span><i> cv2</i> <span class='texttt'>T2</span>,” or
</p></li><li ><p >has a class type (i.e.,
<span class='texttt'>T2</span>
is a class type), where <span class='texttt'>T1</span> is not reference-related to <span class='texttt'>T2</span>, and can be converted
to an lvalue of type “<span class='small'></span><span class='rmfamily'></span><i> cv3</i> <span class='texttt'>T3</span>,” where
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is reference-compatible with
“<span class='small'></span><span class='rmfamily'></span><i> cv3</i> <span class='texttt'>T3</span>”<a class='footnotenum' href='#footnote-107'>107</a>
(this conversion is selected by enumerating the applicable conversion
functions (<a href='over.match.ref'>[over.match.ref]</a>) and choosing the best one through overload
resolution (<a href='over.match'>[over.match]</a>)),
</p></li></ul><p >then the reference is bound to the initializer expression lvalue in the
first case and to the lvalue result of the conversion
in the second case (or, in either case, to the appropriate base class subobject of the object).
[&nbsp;<i>Note:</i>
The usual lvalue-to-rvalue (<a href='conv.lval'>[conv.lval]</a>), array-to-pointer
(<a href='conv.array'>[conv.array]</a>), and function-to-pointer (<a href='conv.func'>[conv.func]</a>) standard
conversions are not needed, and therefore are suppressed, when such
direct bindings to lvalues are done.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
double d = 2.0;
double&amp; rd = d;                 <span class='comment'>// <span class='texttt'>rd</span> refers to <span class='texttt'>d</span>
</span>const double&amp; rcd = d;          <span class='comment'>// <span class='texttt'>rcd</span> refers to <span class='texttt'>d</span>
</span>
struct A { };
struct B : A { operator int&amp;(); } b;
A&amp; ra = b;                      <span class='comment'>// <span class='texttt'>ra</span> refers to <span class='texttt'>A</span> subobject in <span class='texttt'>b</span>
</span>const A&amp; rca = b;               <span class='comment'>// <span class='texttt'>rca</span> refers to <span class='texttt'>A</span> subobject in <span class='texttt'>b</span>
</span>int&amp; ir = B();                  <span class='comment'>// <span class='texttt'>ir</span> refers to the result of <span class='texttt'>B::operator int&amp;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise, the reference shall be an lvalue reference to a non-volatile
const type (i.e.,
<i>cv1</i>
shall be
<span class='texttt'>const</span>), or the reference shall be an rvalue reference.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
double&amp; rd2 = 2.0;              <span class='comment'>// error: not an lvalue and reference not <span class='texttt'>const</span>
</span>int  i = 2;
double&amp; rd3 = i;                <span class='comment'>// error: type mismatch and reference not <span class='texttt'>const</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><ul ><li ><p >If the initializer expression</p><ul ><li ><p >is an xvalue (but not a bit-field), class prvalue, array prvalue or function lvalue and
“<i>cv1</i> <span class='texttt'>T1</span>” is
reference-compatible with “<i>cv2</i> <span class='texttt'>T2</span>”, or</p></li><li ><p >has a class type (i.e., <span class='texttt'>T2</span> is a class type), where <span class='texttt'>T1</span>
is not reference-related to <span class='texttt'>T2</span>, and can be converted to
an xvalue, class prvalue, or function lvalue of type “<i>cv3</i> <span class='texttt'>T3</span>”,
where “<i>cv1</i> <span class='texttt'>T1</span>” is
reference-compatible with “<i>cv3</i> <span class='texttt'>T3</span>” (see <a href='over.match.ref'>[over.match.ref]</a>),</p></li></ul><p >then the reference is bound to the value of the initializer expression in the first
case and to the result of the conversion in the second case (or, in either case, to
an appropriate base class subobject). In the second case, if the reference is an
rvalue reference and the second standard conversion sequence of the user-defined
conversion sequence includes an lvalue-to-rvalue conversion, the program is ill-formed.</p><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
struct A { };
struct B : A { } b;
extern B f();
const A&amp; rca2 = f();                <span class='comment'>// bound to the <span class='texttt'>A</span> subobject of the <span class='texttt'>B</span> rvalue.
</span>A&amp;&amp; rra = f();                      <span class='comment'>// same as above
</span>struct X {
  operator B();
  operator int&amp;();
} x;
const A&amp; r = x;                     <span class='comment'>// bound to the <span class='texttt'>A</span> subobject of the result of the conversion
</span>int i2 = 42;
int&amp;&amp; rri = static_cast&lt;int&amp;&amp;&gt;(i2); <span class='comment'>// bound directly to <span class='texttt'>i2</span>
</span>B&amp;&amp; rrb = x;                        <span class='comment'>// bound directly to the result of <span class='texttt'>operator B</span>
</span>int&amp;&amp; rri2 = X();                   <span class='comment'>// error: lvalue-to-rvalue conversion applied to the
</span>                                    <span class='comment'>// result of <span class='texttt'>operator int&amp;</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise:
</p><ul ><li ><p >If <span class='texttt'>T1</span> is a class type, user-defined conversions are considered
using the rules for copy-initialization of an object of type 
“<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” by
user-defined conversion (<a href='dcl.init'>[dcl.init]</a>, <a href='over.match.copy'>[over.match.copy]</a>);
the program is ill-formed if the corresponding non-reference
copy-initialization would be ill-formed. The result of the call to the
conversion function, as described for the non-reference
copy-initialization, is then used to direct-initialize the reference.
The program is ill-formed if the direct-initialization does not result
in a direct binding or if it involves a user-defined conversion.
</p></li><li ><p >If <span class='texttt'>T1</span> is a non-class type,
a temporary of type “<span class='small'></span><span class='rmfamily'></span><i> cv1</i> <span class='texttt'>T1</span>” is created and
copy-initialized (<a href='dcl.init'>[dcl.init]</a>) from the initializer expression.
The reference is then bound to the temporary.
</p></li></ul><p >If
<span class='texttt'>T1</span>
is reference-related to
<span class='texttt'>T2</span>:
</p><ul ><li ><p ><i>cv1</i>
shall be the same cv-qualification as, or greater cv-qualification than,
<i>cv2</i>; and
</p></li><li ><p >if the reference is an rvalue reference,
the initializer expression shall not be an lvalue.
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct Banana { };
struct Enigma { operator const Banana(); };
void enigmatic() {
  typedef const Banana ConstBanana;
  Banana &amp;&amp;banana1 = ConstBanana(); <span class='comment'>// ill-formed
</span>  Banana &amp;&amp;banana2 = Enigma();      <span class='comment'>// ill-formed
</span>}

const double&amp; rcd2 = 2;         <span class='comment'>// <span class='texttt'>rcd2</span> refers to temporary with value <span class='texttt'>2.0</span>
</span>double&amp;&amp; rrd = 2;               <span class='comment'>// <span class='texttt'>rrd</span> refers to temporary with value <span class='texttt'>2.0</span>
</span>const volatile int cvi = 1;
const int&amp; r2 = cvi;            <span class='comment'>// error: type qualifiers dropped
</span>double d2 = 1.0;
double&amp;&amp; rrd2 = d2;             <span class='comment'>// error: copying lvalue of related type
</span>int i3 = 2;
double&amp;&amp; rrd3 = i3;             <span class='comment'>// <span class='texttt'>rrd3</span> refers to temporary with value <span class='texttt'>2.0</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li></ul></li></ul><p >In all cases except the last (i.e., creating and initializing a temporary from the
initializer expression), the reference is said to <a class='hidden_link' href='#def:bind_directly' id='def:bind_directly'><i>bind directly</i></a> to the
initializer expression.</p></div><div class='para' id='ref-6'><div class='marginalizedparent'><a class='marginalized' href='#ref-6'>6</a></div><p >[&nbsp;<i>Note:</i>
<a href='class.temporary'>[class.temporary]</a> describes the lifetime of temporaries bound to references.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='footnote' id='footnote-107'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-107'>107)</a></div><p >This requires a conversion
function (<a href='class.conv.fct'>[class.conv.fct]</a>) returning a reference type.</p></div></div><div id='list'><h3 ><a class='secnum' href='#list' style='min-width:103pt'>8.5.4</a> List-initialization <a class='abbr_ref' href='dcl.init.list'>[dcl.init.list]</a></h3><p ><span class='indexparent'><a class='index' id='initialization,list-initialization'></a></span></p><div class='para' id='list-1'><div class='marginalizedparent'><a class='marginalized' href='#list-1'>1</a></div><p ><span class='grammarterm'>List-initialization</span> is initialization of an object or reference from a
<i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>. Such an initializer is called an <a class='hidden_link' href='#def:initializer
list' id='def:initializer
list'><i>initializer
list</i></a>, and the comma-separated <i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i> of the list are
called the <a class='hidden_link' href='#def:elements' id='def:elements'><i>elements</i></a> of the initializer list. An initializer list may be empty.
List-initialization can occur in direct-initialization or copy-initialization contexts;
list-initialization in a direct-initialization context is called
<span class='grammarterm'>direct-list-initialization</span> and list-initialization in a
copy-initialization context is called <span class='grammarterm'>copy-list-initialization</span>. [&nbsp;<i>Note:</i>
List-initialization can be used</p><ul ><li ><p >as the initializer in a variable definition (<a href='dcl.init'>[dcl.init]</a>)
</p></li><li ><p >as the initializer in a new expression (<a href='expr.new'>[expr.new]</a>)
</p></li><li ><p >in a return statement (<a href='stmt.return'>[stmt.return]</a>)
</p></li><li ><p >as a <i ><a href='stmt.iter#nt:for-range-initializer'>for-range-initializer</a></i> (<a href='stmt.iter'>[stmt.iter]</a>)
</p></li><li ><p >as a function argument (<a href='expr.call'>[expr.call]</a>)
</p></li><li ><p >as a subscript (<a href='expr.sub'>[expr.sub]</a>)
</p></li><li ><p >as an argument to a constructor invocation (<a href='dcl.init'>[dcl.init]</a>, <a href='expr.type.conv'>[expr.type.conv]</a>)
</p></li><li ><p >as an initializer for a non-static data member (<a href='class.mem'>[class.mem]</a>)
</p></li><li ><p >in a <i ><a href='class.base.init#nt:mem-initializer'>mem-initializer</a></i> (<a href='class.base.init'>[class.base.init]</a>)
</p></li><li ><p >on the right-hand side of an assignment (<a href='expr.ass'>[expr.ass]</a>)
</p></li></ul><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
int a = {1};
std::complex&lt;double&gt; z{1,2};
new std::vector&lt;std::string&gt;{"once", "upon", "a", "time"};  <span class='comment'>// 4 string elements
</span>f( {"Nicholas","Annemarie"} );  <span class='comment'>// pass list of two elements
</span>return { "Norah" };             <span class='comment'>// return list of one element
</span>int* e {};                      <span class='comment'>// initialization to zero / null pointer
</span>x = double{1};                  <span class='comment'>// explicitly construct a double 
</span>std::map&lt;std::string,int&gt; anim = { {"bear",4}, {"cassowary",2}, {"tiger",7} };
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;] <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='list-2'><div class='marginalizedparent'><a class='marginalized' href='#list-2'>2</a></div><p >A constructor is an <span class='grammarterm'>initializer-list constructor</span> if its first parameter is
of type <span class='texttt'>std::initializer_list&lt;E&gt;</span> or reference to possibly cv-qualified
<span class='texttt'>std::initializer_list&lt;E&gt;</span> for some type <span class='texttt'>E</span>, and either there are no other
parameters or else all other parameters have default arguments (<a href='dcl.fct.default'>[dcl.fct.default]</a>).
[&nbsp;<i>Note:</i> Initializer-list constructors are favored over other constructors in
list-initialization (<a href='over.match.list'>[over.match.list]</a>). Passing an initializer list as the argument
to the constructor template <span class='texttt'>template&lt;class T&gt; C(T)</span> of a class <span class='texttt'>C</span> does not
create an initializer-list constructor, because an initializer list argument causes the 
corresponding parameter to be a non-deduced context (<a href='temp.deduct.call'>[temp.deduct.call]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]
The template
<span class='texttt'>std::initializer_list</span> is not predefined; if the header
<span class='texttt'>&lt;initializer_list&gt;</span> is not included prior to a use of
<span class='texttt'>std::initializer_list</span> — even an implicit use in which the type is not
named (<a href='dcl.spec.auto'>[dcl.spec.auto]</a>) — the program is ill-formed.</p></div><div class='para' id='list-3'><div class='marginalizedparent'><a class='marginalized' href='#list-3'>3</a></div><p >List-initialization of an object or reference of type <span class='texttt'>T</span> is defined as follows:
</p><ul ><li ><p >If <span class='texttt'>T</span> is an aggregate, aggregate initialization is
performed (<a href='dcl.init.aggr'>[dcl.init.aggr]</a>).</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
double ad[] = { 1, 2.0 };           <span class='comment'>// OK
</span>int ai[] = { 1, 2.0 };              <span class='comment'>// error: narrowing
</span>
struct S2 {
  int m1;
  double m2, m3;
};
S2 s21 = { 1, 2, 3.0 };             <span class='comment'>// OK
</span>S2 s22 { 1.0, 2, 3 };               <span class='comment'>// error: narrowing
</span>S2 s23 { };                         <span class='comment'>// OK: default to 0,0,0
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise, if the initializer list has no elements and <span class='texttt'>T</span> is a class type with a
default constructor, the object is value-initialized.</p></li><li ><p >Otherwise, if <span class='texttt'>T</span> is a specialization of <span class='texttt'>std::initializer_list&lt;E&gt;</span>,
a prvalue <span class='texttt'>initializer_list</span> object is constructed as described below and used to
initialize the object according to the rules for initialization of an object from a
class of the same type (<a href='dcl.init'>[dcl.init]</a>).</p></li><li ><p >Otherwise, if <span class='texttt'>T</span> is a class type, constructors are considered.
The applicable constructors are enumerated and
the best one is chosen through overload resolution (<a href='over.match'>[over.match]</a>, <a href='over.match.list'>[over.match.list]</a>). If a narrowing
conversion (see below) is required to convert any of the arguments, the program is
ill-formed.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct S {
  S(std::initializer_list&lt;double&gt;); <span class='comment'>// #1
</span>  S(std::initializer_list&lt;int&gt;);    <span class='comment'>// #2
</span>  S();                              <span class='comment'>// #3
</span>  <span class='comment'>// ...
</span>};
S s1 = { 1.0, 2.0, 3.0 };           <span class='comment'>// invoke #1
</span>S s2 = { 1, 2, 3 };                 <span class='comment'>// invoke #2
</span>S s3 = { };                         <span class='comment'>// invoke #3
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct Map {
  Map(std::initializer_list&lt;std::pair&lt;std::string,int&gt;&gt;);
};
Map ship = {{"Sophie",14}, {"Surprise",28}};
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct S {
  <span class='comment'>// no initializer-list constructors
</span>  S(int, double, double);           <span class='comment'>// #1
</span>  S();                              <span class='comment'>// #2
</span>  <span class='comment'>// ...
</span>};
S s1 = { 1, 2, 3.0 };               <span class='comment'>// OK: invoke #1
</span>S s2 { 1.0, 2, 3 };                 <span class='comment'>// error: narrowing
</span>S s3 { };                           <span class='comment'>// OK: invoke #2
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise, if
the initializer list has a single element of type <span class='texttt'>E</span> and either
<span class='texttt'>T</span> is not a reference type or its referenced type is
reference-related to <span class='texttt'>E</span>, the object or reference is initialized
from that element; if a narrowing conversion (see below) is required
to convert the element to <span class='texttt'>T</span>, the program is ill-formed.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
int x1 {2};                         <span class='comment'>// OK
</span>int x2 {2.0};                       <span class='comment'>// error: narrowing
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise, if <span class='texttt'>T</span> is a reference type, a prvalue temporary of the type
referenced by <span class='texttt'>T</span> is copy-list-initialized or direct-list-initialized,
depending on the kind of initialization for the reference, and the reference is
bound to that temporary.
[&nbsp;<i>Note:</i> As usual, the binding will fail and the program is ill-formed if
the reference type is an lvalue reference to a non-const type. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct S {
  S(std::initializer_list&lt;double&gt;); <span class='comment'>// #1
</span>  S(const std::string&amp;);            <span class='comment'>// #2
</span>  <span class='comment'>// ...
</span>};
const S&amp; r1 = { 1, 2, 3.0 };        <span class='comment'>// OK: invoke #1
</span>const S&amp; r2 { "Spinach" };          <span class='comment'>// OK: invoke #2
</span>S&amp; r3 = { 1, 2, 3 };                <span class='comment'>// error: initializer is not an lvalue
</span>const int&amp; i1 = { 1 };              <span class='comment'>// OK
</span>const int&amp; i2 = { 1.1 };            <span class='comment'>// error: narrowing
</span>const int (&amp;iar)[2] = { 1, 2 };     <span class='comment'>// OK: <span class='texttt'>iar</span> is bound to temporary array
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise, if the initializer list has no elements, the object is
value-initialized.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
int** pp {};                        <span class='comment'>// initialized to null pointer
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li><li ><p >Otherwise, the program is ill-formed.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct A { int i; int j; };
A a1 { 1, 2 };                      <span class='comment'>// aggregate initialization 
</span>A a2 { 1.2 };                       <span class='comment'>// error: narrowing
</span>struct B {
  B(std::initializer_list&lt;int&gt;);
};
B b1 { 1, 2 };                      <span class='comment'>// creates <span class='texttt'>initializer_list&lt;int&gt;</span> and calls constructor
</span>B b2 { 1, 2.0 };                    <span class='comment'>// error: narrowing
</span>struct C {
  C(int i, double j);
};
C c1 = { 1, 2.2 };                  <span class='comment'>// calls constructor with arguments (1, 2.2) 
</span>C c2 = { 1.1, 2 };                  <span class='comment'>// error: narrowing
</span>
int j { 1 };                        <span class='comment'>// initialize to 1
</span>int k { };                          <span class='comment'>// initialize to 0
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></li></ul></div><div class='para' id='list-4'><div class='marginalizedparent'><a class='marginalized' href='#list-4'>4</a></div><p >Within the <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> of a <i ><a href='dcl.init#nt:braced-init-list'>braced-init-list</a></i>,
the <i ><a href='dcl.init#nt:initializer-clause'>initializer-clauses</a></i>, including any that result from pack
expansions (<a href='temp.variadic'>[temp.variadic]</a>), are evaluated in the order in which they
appear. That is, every value computation and side effect associated with a
given <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i> is sequenced before every value
computation and side effect associated with any <i ><a href='dcl.init#nt:initializer-clause'>initializer-clause</a></i>
that follows it in the comma-separated list of the <i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i>.
[&nbsp;<i>Note:</i> This evaluation ordering holds regardless of the semantics of the
initialization; for example, it applies when the elements of the
<i ><a href='dcl.init#nt:initializer-list'>initializer-list</a></i> are interpreted as arguments of a constructor
call, even though ordinarily there are no sequencing constraints on the
arguments of a call. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='list-5'><div class='marginalizedparent'><a class='marginalized' href='#list-5'>5</a></div><p >An object of type <span class='texttt'>std::initializer_list&lt;E&gt;</span> is constructed from
an initializer list as if the implementation allocated a temporary array of <span class='math'><span class='mathalpha'>N</span></span>
elements of type <span class='texttt'>const E</span>, where <span class='math'><span class='mathalpha'>N</span></span> is the number of elements in the
initializer list. Each element of that array is copy-initialized with the
corresponding element of the initializer list, and the
<span class='texttt'>std::initializer_list&lt;E&gt;</span> object is constructed to refer to that array.
[&nbsp;<i>Note:</i> A constructor or conversion function selected for the copy shall be
accessible (Clause <a href='class.access'>[class.access]</a>) in the context of the initializer list.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
If a narrowing conversion is required to initialize any of the elements, the program is ill-formed.[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct X {
  X(std::initializer_list&lt;double&gt; v);
};
X x{ 1,2,3 };
</pre><p >The initialization will be implemented in a way roughly equivalent to this:</p><pre class='codeblock'>
const double __a[3] = {double{1}, double{2}, double{3}};
X x(std::initializer_list&lt;double&gt;(__a, __a+3));
</pre><p >assuming that the implementation can construct an <span class='texttt'>initializer_list</span> object with a pair of pointers. <i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='list-6'><div class='marginalizedparent'><a class='marginalized' href='#list-6'>6</a></div><p >The array has the same lifetime as any other temporary
object (<a href='class.temporary'>[class.temporary]</a>), except that initializing an
<span class='texttt'>initializer_list</span> object from the array extends the lifetime of
the array exactly like binding a reference to a temporary.
[&nbsp;<i>Example:</i></p><pre class='codeblock'>
typedef std::complex&lt;double&gt; cmplx;
std::vector&lt;cmplx&gt; v1 = { 1, 2, 3 };

void f() {
  std::vector&lt;cmplx&gt; v2{ 1, 2, 3 };
  std::initializer_list&lt;int&gt; i3 = { 1, 2, 3 };
}

struct A {
  std::initializer_list&lt;int&gt; i4;
  A() : i4{ 1, 2, 3 } {}  <span class='comment'>// creates an <span class='texttt'>A</span> with a dangling reference
</span>};
</pre><p >For <span class='texttt'>v1</span> and <span class='texttt'>v2</span>, the <span class='texttt'>initializer_list</span> object
is a parameter in a function call, so the array created for
<span class='texttt'>{ 1, 2, 3 }</span> has full-expression lifetime.
For <span class='texttt'>i3</span>, the <span class='texttt'>initializer_list</span> object is a variable,
so the array persists for the lifetime of the variable.
For <span class='texttt'>i4</span>, the <span class='texttt'>initializer_list</span> object is initialized in
a constructor's <i ><a href='class.base.init#nt:ctor-initializer'>ctor-initializer</a></i>, so the array persists
only until the constructor exits, and so any use of the elements of
<span class='texttt'>i4</span> after the constructor exits produces undefined behavior.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Note:</i>
The implementation is free to allocate the array in read-only memory if an explicit array with the same initializer could be so allocated. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='list-7'><div class='marginalizedparent'><a class='marginalized' href='#list-7'>7</a></div><p >A
<span class='indexparent'><a class='index' id='narrowing_conversion'></a></span><span class='indexparent'><a class='index' id='conversion,narrowing'></a></span><a class='hidden_link' href='#def:narrowing_conversion' id='def:narrowing_conversion'><i>narrowing conversion</i></a> is an implicit conversion</p><ul ><li ><p >from a floating-point type to an integer type, or</p></li><li ><p >from <span class='texttt'>long double</span> to <span class='texttt'>double</span> or <span class='texttt'>float</span>, or from
<span class='texttt'>double</span> to <span class='texttt'>float</span>, except where the source is a constant expression and
the actual value after conversion
is within the range of values that can be represented (even if it cannot be represented exactly),
or</p></li><li ><p >from an integer type or unscoped enumeration type to a floating-point type, except
where the source is a constant expression and the actual value after conversion will fit
into the target type and will produce the original value when converted back to the
original type, or</p></li><li ><p >from an integer type or unscoped enumeration type to an integer type that cannot
represent all the values of the original type, except where the source is a constant
expression whose value after integral promotions will fit into the target type.
</p></li></ul><p >[&nbsp;<i>Note:</i> As indicated above, such conversions are not allowed at the top level in
list-initializations.<i>&nbsp;—&nbsp;end note</i>&nbsp;] [&nbsp;<i>Example:</i></p><pre class='codeblock'>
int x = 999;              <span class='comment'>// x is not a constant expression
</span>const int y = 999;
const int z = 99;
char c1 = x;              <span class='comment'>// OK, though it might narrow (in this case, it does narrow)
</span>char c2{x};               <span class='comment'>// error: might narrow
</span>char c3{y};               <span class='comment'>// error: narrows (assuming <span class='texttt'>char</span> is 8 bits)
</span>char c4{z};               <span class='comment'>// OK: no narrowing needed
</span>unsigned char uc1 = {5};  <span class='comment'>// OK: no narrowing needed
</span>unsigned char uc2 = {-1}; <span class='comment'>// error: narrows
</span>unsigned int ui1 = {-1};  <span class='comment'>// error: narrows
</span>signed int si1 =
  { (unsigned int)-1 };   <span class='comment'>// error: narrows
</span>int ii = {2.0};           <span class='comment'>// error: narrows
</span>float f1 { x };           <span class='comment'>// error: might narrow
</span>float f2 { 7 };           <span class='comment'>// OK: 7 can be exactly represented as a float
</span>int f(int);
int a[] =
  { 2, f(2), f(2.0) };    <span class='comment'>// OK: the double-to-int conversion is not at the top level
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]<span class='indexparent'><a class='index' id='initialization,list-initialization'></a></span><span class='indexparent'><a class='index' id='initialization'></a></span><span class='indexparent'><a class='index' id='declarator'></a></span>
</p></div></div></div></div></body></html>