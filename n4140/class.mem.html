<!DOCTYPE html><html lang='en'><head><title>[class.mem]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>9</a> Classes <a class='abbr_ref' href='./#class'>[class]</a></h1><div id='class.mem'><h2 ><a class='secnum' style='min-width:88pt'>9.2</a> Class members <a class='abbr_ref'>[class.mem]</a></h2><p ><span class='indexparent'><a class='index' id='declaration,member'></a></span><span class='indexparent'><a class='index' id='data_member'></a></span></p><pre class='bnf'><a id='nt:member-specification'>member-specification:</a>
    <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i> <i ><a href='class.mem#nt:member-specification'>member-specification</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='class.derived#nt:access-specifier'>access-specifier</a></i> <span class='terminal'>:</span> <i ><a href='class.mem#nt:member-specification'>member-specification</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span></pre><pre class='bnf'><a id='nt:member-declaration'>member-declaration:</a>
    <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>;</span>
    <i ><a href='dcl.fct.def.general#nt:function-definition'>function-definition</a></i>
    <i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i>
    <i ><a href='dcl.dcl#nt:static_assert-declaration'>static_assert-declaration</a></i>
    <i ><a href='temp#nt:template-declaration'>template-declaration</a></i>
    <i ><a href='dcl.dcl#nt:alias-declaration'>alias-declaration</a></i>
    <i ><a href='dcl.dcl#nt:empty-declaration'>empty-declaration</a></i></pre><pre class='bnf'><a id='nt:member-declarator-list'>member-declarator-list:</a>
    <i ><a href='class.mem#nt:member-declarator'>member-declarator</a></i>
    <i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i> <span class='terminal'>,</span> <i ><a href='class.mem#nt:member-declarator'>member-declarator</a></i></pre><pre class='bnf'><a id='nt:member-declarator'>member-declarator:</a>
    <i ><a href='dcl.decl#nt:declarator'>declarator</a></i> <i ><a href='class.mem#nt:virt-specifier-seq'>virt-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='class.mem#nt:pure-specifier'>pure-specifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='dcl.decl#nt:declarator'>declarator</a></i> <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>
    <i ><a href='lex.name#nt:identifier'>identifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>:</span> <i ><a href='expr.const#nt:constant-expression'>constant-expression</a></i></pre><pre class='bnf'><a id='nt:virt-specifier-seq'>virt-specifier-seq:</a>
    <i ><a href='class.mem#nt:virt-specifier'>virt-specifier</a></i>
    <i ><a href='class.mem#nt:virt-specifier-seq'>virt-specifier-seq</a></i> <i ><a href='class.mem#nt:virt-specifier'>virt-specifier</a></i></pre><pre class='bnf'><a id='nt:virt-specifier'>virt-specifier:</a>
    <span class='terminal'>override</span>
    <span class='terminal'>final</span></pre><pre class='bnf'><a id='nt:pure-specifier'>pure-specifier:</a>
    <span class='terminal'>= 0</span></pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='definition,class'></a></span>The <i ><a href='class.mem#nt:member-specification'>member-specification</a></i> in a class definition declares the
full set of members of the class; no member can be added elsewhere.
Members of a class are data members, member
functions (<a href='class.mfct'>[class.mfct]</a>), nested types, and enumerators. Data
members and member functions are static or non-static;
see <a href='class.static'>[class.static]</a>. Nested types are
classes (<a href='class.name'>[class.name]</a>, <a href='class.nest'>[class.nest]</a>) and
enumerations (<a href='dcl.enum'>[dcl.enum]</a>) defined in the class, and arbitrary types
declared as members by use of a typedef declaration (<a href='dcl.typedef'>[dcl.typedef]</a>).
The enumerators of an unscoped enumeration (<a href='dcl.enum'>[dcl.enum]</a>) defined in the class
are members of the class. Except when used to declare
friends (<a href='class.friend'>[class.friend]</a>), to declare an unnamed bit-field (<a href='class.bit'>[class.bit]</a>),
or to introduce the name of a member of a
base class into a derived
class (<a href='namespace.udecl'>[namespace.udecl]</a>), or when the declaration is an
<i ><a href='dcl.dcl#nt:empty-declaration'>empty-declaration</a></i>,
<i ><a href='class.mem#nt:member-declaration'>member-declarations</a></i> declare members of the class, and each
such <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i> shall declare at least one member
name of the class. A member shall not be declared twice in the
<i ><a href='class.mem#nt:member-specification'>member-specification</a></i>, except that a nested class or member
class template can be declared and then later defined, and except that an
enumeration can be introduced with an <i ><a href='dcl.enum#nt:opaque-enum-declaration'>opaque-enum-declaration</a></i> and later
redeclared with an <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i>.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='completely_defined'></a></span>A class is considered a completely-defined object
type (<a href='basic.types'>[basic.types]</a>) (or complete type) at the closing <span class='texttt'>}</span> of
the <i ><a href='class#nt:class-specifier'>class-specifier</a></i>.
Within the class
<i ><a href='class.mem#nt:member-specification'>member-specification</a></i>, the class is regarded as complete
within function bodies, default arguments,
<i ><a href='namespace.udecl#nt:using-declaration'>using-declarations</a></i> introducing inheriting
constructors (<a href='class.inhctor'>[class.inhctor]</a>),
<i ><a href='except.spec#nt:exception-specification'>exception-specifications</a></i>, and
<i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializers</a></i> for non-static data members
(including such things in nested classes).
Otherwise it is regarded as incomplete within its own class
<i ><a href='class.mem#nt:member-specification'>member-specification</a></i>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >[&nbsp;<i>Note:</i>
A single name can denote several function members provided their types
are sufficiently different (Clause <a href='over'>[over]</a>).
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >A <i ><a href='dcl.init#nt:brace-or-equal-initializer'>brace-or-equal-initializer</a></i> shall appear only in the
declaration of a data member. (For static data members,
see <a href='class.static.data'>[class.static.data]</a>; for non-static data members,
see <a href='class.base.init'>[class.base.init]</a>).</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >A member shall not be declared with the <span class='texttt'>extern</span>
or <span class='texttt'>register</span>
<span class='rmfamily'></span><i> storage-class-specifier</i>. Within a class definition, a member shall not be declared with the <span class='texttt'>thread_local</span> <span class='rmfamily'></span><i> storage-class-specifier</i> unless also declared <span class='texttt'>static</span>.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >The <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i> may be omitted in constructor, destructor,
and conversion function declarations only;
when declaring another kind of member the <i ><a href='dcl.spec#nt:decl-specifier-seq'>decl-specifier-seq</a></i>
shall contain a <i ><a href='dcl.type#nt:type-specifier'>type-specifier</a></i> that is not a <i ><a href='dcl.decl#nt:cv-qualifier'>cv-qualifier</a></i>.
The
<i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i> can be omitted only after a
<i ><a href='class#nt:class-specifier'>class-specifier</a></i> or an <i ><a href='dcl.enum#nt:enum-specifier'>enum-specifier</a></i> or in a
<span class='texttt'>friend</span> declaration (<a href='class.friend'>[class.friend]</a>). A
<i ><a href='class.mem#nt:pure-specifier'>pure-specifier</a></i> shall be used only in the declaration of a
virtual function (<a href='class.virtual'>[class.virtual]</a>).</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >The optional <i ><a href='dcl.attr.grammar#nt:attribute-specifier-seq'>attribute-specifier-seq</a></i> in a <i ><a href='class.mem#nt:member-declaration'>member-declaration</a></i>
appertains to each of the entities declared by the <i ><a href='class.mem#nt:member-declarator'>member-declarators</a></i>;
it shall not appear if the optional <i ><a href='class.mem#nt:member-declarator-list'>member-declarator-list</a></i> is omitted.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >A <i ><a href='class.mem#nt:virt-specifier-seq'>virt-specifier-seq</a></i> shall contain at most one of each
<i ><a href='class.mem#nt:virt-specifier'>virt-specifier</a></i>.
A <i ><a href='class.mem#nt:virt-specifier-seq'>virt-specifier-seq</a></i>
shall appear only in the declaration of a virtual member
function (<a href='class.virtual'>[class.virtual]</a>).</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p ><span class='indexparent'><a class='index' id='class_object,member'></a></span>Non-<span class='texttt'>static</span> (<a href='class.static'>[class.static]</a>) data members shall not have
incomplete types. In particular, a class <span class='texttt'>C</span> shall not contain a
non-static member of class <span class='texttt'>C</span>, but it can contain a pointer or
reference to an object of class <span class='texttt'>C</span>.</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >[&nbsp;<i>Note:</i>
See <a href='expr.prim'>[expr.prim]</a> for restrictions on the use of non-static data
members and non-static member functions.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >[&nbsp;<i>Note:</i>
The type of a non-static member function is an ordinary function type,
and the type of a non-static data member is an ordinary object type.
There are no special member function types or data member types.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p ><span class='indexparent'><a class='index' id='example,class_definition'></a></span>[&nbsp;<i>Example:</i>
A simple example of a class definition is</p><pre class='codeblock'>
struct tnode {
  char tword[20];
  int count;
  tnode* left;
  tnode* right;
};
</pre><p >which contains an array of twenty characters, an integer, and two
pointers to objects of the same type. Once this definition has been
given, the declaration</p><pre class='codeblock'>
tnode s, *sp;
</pre><p >declares <span class='texttt'>s</span> to be a <span class='texttt'>tnode</span> and <span class='texttt'>sp</span> to be a pointer
to a <span class='texttt'>tnode</span>. With these declarations, <span class='texttt'>sp-&gt;count</span> refers to
the <span class='texttt'>count</span> member of the object to which <span class='texttt'>sp</span> points;
<span class='texttt'>s.left</span> refers to the <span class='texttt'>left</span> subtree pointer of the object
<span class='texttt'>s</span>; and <span class='texttt'>s.right-&gt;tword[0]</span> refers to the initial character
of the <span class='texttt'>tword</span> member of the <span class='texttt'>right</span> subtree of <span class='texttt'>s</span>.
<i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p ><span class='indexparent'><a class='index' id='layout,class_object'></a></span>Nonstatic data members of a (non-union) class
with the same access control (Clause <a href='class.access'>[class.access]</a>)
are allocated so that later
members have higher addresses within a class object.
<span class='indexparent'><a class='index' id='allocation,unspecified'></a></span>The order of allocation of non-static data members
with different access control
is unspecified (Clause <a href='class.access'>[class.access]</a>).
Implementation alignment requirements might cause two adjacent members
not to be allocated immediately after each other; so might requirements
for space for managing virtual functions (<a href='class.virtual'>[class.virtual]</a>) and
virtual base classes (<a href='class.mi'>[class.mi]</a>).</p></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><p >If <span class='texttt'>T</span> is the name of a class, then each of the following shall
have a name different from <span class='texttt'>T</span>:</p><ul class='itemize'><li id='14.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#14.1'>(14.1)</a></div><p >every static data member of class <span class='texttt'>T</span>;</p></li><li id='14.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#14.2'>(14.2)</a></div><p >every member function of class <span class='texttt'>T</span>
[&nbsp;<i>Note:</i>
This restriction does not apply to constructors, which do not have
names (<a href='class.ctor'>[class.ctor]</a>)
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;];</p></li><li id='14.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#14.3'>(14.3)</a></div><p >every member of class <span class='texttt'>T</span> that is itself a type;</p></li><li id='14.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#14.4'>(14.4)</a></div><p >every enumerator of every member of class <span class='texttt'>T</span> that is an
unscoped enumerated type; and</p></li><li id='14.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#14.5'>(14.5)</a></div><p >every member of every anonymous union that is a member of class
<span class='texttt'>T</span>.
</p></li></ul></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><p >In addition, if class <span class='texttt'>T</span> has a user-declared
constructor (<a href='class.ctor'>[class.ctor]</a>), every non-static data member of class
<span class='texttt'>T</span> shall have a name different from <span class='texttt'>T</span>.</p></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><p >Two standard-layout struct (Clause <a href='class'>[class]</a>) types are <a class='hidden_link' href='#def:layout-compatible' id='def:layout-compatible'><i>layout-compatible</i></a> if they
have the same number of non-static data members and corresponding
non-static data members (in declaration order) have layout-compatible
types (<a href='basic.types'>[basic.types]</a>).</p></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><p >Two standard-layout union (Clause <a href='class'>[class]</a>) types are <a class='hidden_link' href='#def:layout-compatible' id='def:layout-compatible'><i>layout-compatible</i></a> if they
have the same number of non-static data members and corresponding
non-static data members (in any order) have layout-compatible
types (<a href='basic.types'>[basic.types]</a>).</p></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><p >If a standard-layout union contains two or more
standard-layout structs that share a common
initial sequence, and if the standard-layout union object currently contains one of
these standard-layout structs, it is permitted to inspect the common initial part of
any of them. Two standard-layout structs share a common initial sequence if
corresponding members have layout-compatible types and either neither member is a bit-field or both are bit-fields with the same width for a sequence of one or more initial members.</p></div><div class='para' id='19'><div class='marginalizedparent'><a class='marginalized' href='#19'>19</a></div><p >If a standard-layout class object has any non-static data members, its address
is the same as the address of its first non-static data member. Otherwise, its
address is the same as the address of its first base class subobject (if any).
[&nbsp;<i>Note:</i>
There might therefore be unnamed padding within a standard-layout struct object, but
not at its beginning, as necessary to achieve appropriate alignment.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div></div></body></html>