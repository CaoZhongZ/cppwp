<!DOCTYPE html><html lang='en'><head><title>[numarray]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>26</a> Numerics library <a class='abbr_ref' href='./#numerics'>[numerics]</a></h1><div id='numarray'><h2 ><a class='secnum' style='min-width:88pt'>26.7</a> Numeric arrays <a class='abbr_ref'>[numarray]</a></h2><div id='valarray.syn'><h3 ><a class='secnum' href='#valarray.syn' style='min-width:103pt'>26.7.1</a> Header <span class='texttt'>&lt;valarray&gt;</span> synopsis <a class='abbr_ref' href='valarray.syn'>[valarray.syn]</a></h3><p ><span class='indexparent'><a class='index' id='valarray'></a></span></p><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  template&lt;class T&gt; class valarray;         <span class='comment'>// An array of type <span class='texttt'>T</span>
</span>  class slice;                              <span class='comment'>// a BLAS-like slice out of an array
</span>  template&lt;class T&gt; class slice_array;
  class gslice;                             <span class='comment'>// a generalized slice out of an array
</span>  template&lt;class T&gt; class gslice_array;
  template&lt;class T&gt; class mask_array;       <span class='comment'>// a masked array
</span>  template&lt;class T&gt; class indirect_array;   <span class='comment'>// an indirected array
</span>
  template&lt;class T&gt; void swap(valarray&lt;T&gt;&amp;, valarray&lt;T&gt;&amp;) noexcept;

  template&lt;class T&gt; valarray&lt;T&gt; operator* (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator* (const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator* (const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; operator/ (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator/ (const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator/ (const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; operator% (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator% (const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator% (const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; operator+ (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator+ (const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator+ (const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; operator- (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator- (const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator- (const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; operator^ (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator^ (const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator^ (const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; operator&amp; (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator&amp; (const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator&amp; (const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; operator| (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator| (const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator| (const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; operator&lt;&lt;(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator&lt;&lt;(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator&lt;&lt;(const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; operator&gt;&gt;(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator&gt;&gt;(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; operator&gt;&gt;(const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;bool&gt; operator&amp;&amp;(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator&amp;&amp;(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator&amp;&amp;(const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;bool&gt; operator||(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator||(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator||(const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt;
    valarray&lt;bool&gt; operator==(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator==(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator==(const T&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt;
    valarray&lt;bool&gt; operator!=(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator!=(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator!=(const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt;
    valarray&lt;bool&gt; operator&lt; (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator&lt; (const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator&lt; (const T&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt;
    valarray&lt;bool&gt; operator&gt; (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator&gt; (const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator&gt; (const T&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt;
    valarray&lt;bool&gt; operator&lt;=(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator&lt;=(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator&lt;=(const T&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt;
    valarray&lt;bool&gt; operator&gt;=(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator&gt;=(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; operator&gt;=(const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; abs  (const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; acos (const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; asin (const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; atan (const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; atan2(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; atan2(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; atan2(const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; cos  (const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; cosh (const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; exp  (const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; log  (const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; log10(const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; pow(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; pow(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; pow(const T&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; sin  (const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; sinh (const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; sqrt (const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; tan  (const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; tanh (const valarray&lt;T&gt;&amp;);

  template &lt;class T&gt; <i><span class='texttt'>unspecified</span></i>1 begin(valarray&lt;T&gt;&amp; v);
  template &lt;class T&gt; <i><span class='texttt'>unspecified</span></i>2 begin(const valarray&lt;T&gt;&amp; v);
  template &lt;class T&gt; <i><span class='texttt'>unspecified</span></i>1 end(valarray&lt;T&gt;&amp; v);
  template &lt;class T&gt; <i><span class='texttt'>unspecified</span></i>2 end(const valarray&lt;T&gt;&amp; v);
}
</pre><div class='para' id='valarray.syn-1'><div class='marginalizedparent'><a class='marginalized' href='#valarray.syn-1'>1</a></div><p >The header
<span class='texttt'>&lt;valarray&gt;</span>
defines five
class templates
(<span class='texttt'>valarray</span>,
<span class='texttt'>slice_array</span>,
<span class='texttt'>gslice_array</span>,
<span class='texttt'>mask_array</span>,
and
<span class='texttt'>indirect_array</span>),
two classes (<span class='texttt'>slice</span>
and
<span class='texttt'>gslice</span>),
and a series of related
function templates
for representing
and manipulating arrays of values.</p></div><div class='para' id='valarray.syn-2'><div class='marginalizedparent'><a class='marginalized' href='#valarray.syn-2'>2</a></div><p >The
<span class='texttt'>valarray</span>
array classes
are defined to be free of certain forms of aliasing, thus allowing
operations on these classes to be optimized.</p></div><div class='para' id='valarray.syn-3'><div class='marginalizedparent'><a class='marginalized' href='#valarray.syn-3'>3</a></div><p >Any function returning a
<span class='texttt'>valarray&lt;T&gt;</span>
is permitted to return an object of another type, provided all the
const member functions of
<span class='texttt'>valarray&lt;T&gt;</span>
are also applicable to this type.
This return type shall not add
more than two levels of template nesting over the most deeply nested
argument type.<a class='footnotenum' href='#footnote-276'>276</a></p></div><div class='para' id='valarray.syn-4'><div class='marginalizedparent'><a class='marginalized' href='#valarray.syn-4'>4</a></div><p >Implementations introducing such replacement types shall provide
additional functions and operators as follows:
</p><ul ><li ><p >for every function taking a
<span class='texttt'>const valarray&lt;T&gt;&amp;</span> other than <span class='texttt'>begin</span> and
<span class='texttt'>end</span> (<a href='valarray.range'>[valarray.range]</a>),
identical functions taking the replacement types shall be added;
</p></li><li ><p >for every function taking two
<span class='texttt'>const valarray&lt;T&gt;&amp;</span>
arguments, identical functions taking every combination of
<span class='texttt'>const valarray&lt;T&gt;&amp;</span>
and replacement types shall be added.
</p></li></ul></div><div class='para' id='valarray.syn-5'><div class='marginalizedparent'><a class='marginalized' href='#valarray.syn-5'>5</a></div><p >In particular, an implementation shall allow a
<span class='texttt'>valarray&lt;T&gt;</span>
to be constructed from such replacement types and shall allow assignments
and compound assignments of such types to
<span class='texttt'>valarray&lt;T&gt;</span>,
<span class='texttt'>slice_array&lt;T&gt;</span>,
<span class='texttt'>gslice_array&lt;T&gt;</span>,
<span class='texttt'>mask_array&lt;T&gt;</span>
and
<span class='texttt'>indirect_array&lt;T&gt;</span>
objects.</p></div><div class='para' id='valarray.syn-6'><div class='marginalizedparent'><a class='marginalized' href='#valarray.syn-6'>6</a></div><p >These library functions are permitted to throw a
<span class='texttt'>bad_alloc</span> (<a href='bad.alloc'>[bad.alloc]</a>) exception if there are not sufficient resources available
to carry out the operation.
Note that the exception is not mandated.</p></div><div class='footnote' id='footnote-276'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-276'>276)</a></div><p >Annex <a href='implimits'>[implimits]</a> recommends a minimum number
of recursively nested template
instantiations.
This requirement thus indirectly suggests a minimum
allowable complexity for valarray expressions.</p></div></div><div id='template.valarray'><h3 ><a class='secnum' href='#template.valarray' style='min-width:103pt'>26.7.2</a> Class template <span class='texttt'>valarray</span> <a class='abbr_ref' href='template.valarray'>[template.valarray]</a></h3><div id='template.valarray.overview'><h4 ><a class='secnum' href='#template.valarray.overview' style='min-width:118pt'>26.7.2.1</a> Class template <span class='texttt'>valarray</span> overview <a class='abbr_ref' href='template.valarray.overview'>[template.valarray.overview]</a></h4><p ><span class='indexparent'><a class='index' id='valarray'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; class valarray {
  public:
    using value_type = T;

    <span class='comment'>// <a href='valarray.cons'>[valarray.cons]</a> construct/destroy:
</span>    valarray();
    explicit valarray(size_t);
    valarray(const T&amp;, size_t);
    valarray(const T*, size_t);
    valarray(const valarray&amp;);
    valarray(valarray&amp;&amp;) noexcept;
    valarray(const slice_array&lt;T&gt;&amp;);
    valarray(const gslice_array&lt;T&gt;&amp;);
    valarray(const mask_array&lt;T&gt;&amp;);
    valarray(const indirect_array&lt;T&gt;&amp;);
    valarray(initializer_list&lt;T&gt;);
    ~valarray();

    <span class='comment'>// <a href='valarray.assign'>[valarray.assign]</a> assignment:
</span>    valarray&amp; operator=(const valarray&amp;);
    valarray&amp; operator=(valarray&amp;&amp;) noexcept;
    valarray&amp; operator=(initializer_list&lt;T&gt;);
    valarray&amp; operator=(const T&amp;);
    valarray&amp; operator=(const slice_array&lt;T&gt;&amp;);
    valarray&amp; operator=(const gslice_array&lt;T&gt;&amp;);
    valarray&amp; operator=(const mask_array&lt;T&gt;&amp;);
    valarray&amp; operator=(const indirect_array&lt;T&gt;&amp;);

    <span class='comment'>// <a href='valarray.access'>[valarray.access]</a> element access:
</span>    const T&amp;          operator[](size_t) const;
    T&amp;                operator[](size_t);

    <span class='comment'>// <a href='valarray.sub'>[valarray.sub]</a> subset operations:
</span>    valarray          operator[](slice) const;
    slice_array&lt;T&gt;    operator[](slice);
    valarray          operator[](const gslice&amp;) const;
    gslice_array&lt;T&gt;   operator[](const gslice&amp;);
    valarray          operator[](const valarray&lt;bool&gt;&amp;) const;
    mask_array&lt;T&gt;     operator[](const valarray&lt;bool&gt;&amp;);
    valarray          operator[](const valarray&lt;size_t&gt;&amp;) const;
    indirect_array&lt;T&gt; operator[](const valarray&lt;size_t&gt;&amp;);

    <span class='comment'>// <a href='valarray.unary'>[valarray.unary]</a> unary operators:
</span>    valarray operator+() const;
    valarray operator-() const;
    valarray operator~() const;
    valarray&lt;bool&gt; operator!() const;

    <span class='comment'>// <a href='valarray.cassign'>[valarray.cassign]</a> compound assignment:
</span>    valarray&amp; operator*= (const T&amp;);
    valarray&amp; operator/= (const T&amp;);
    valarray&amp; operator%= (const T&amp;);
    valarray&amp; operator+= (const T&amp;);
    valarray&amp; operator-= (const T&amp;);
    valarray&amp; operator^= (const T&amp;);
    valarray&amp; operator&amp;= (const T&amp;);
    valarray&amp; operator|= (const T&amp;);
    valarray&amp; operator&lt;&lt;=(const T&amp;);
    valarray&amp; operator&gt;&gt;=(const T&amp;);

    valarray&amp; operator*= (const valarray&amp;);
    valarray&amp; operator/= (const valarray&amp;);
    valarray&amp; operator%= (const valarray&amp;);
    valarray&amp; operator+= (const valarray&amp;);
    valarray&amp; operator-= (const valarray&amp;);
    valarray&amp; operator^= (const valarray&amp;);
    valarray&amp; operator|= (const valarray&amp;);
    valarray&amp; operator&amp;= (const valarray&amp;);
    valarray&amp; operator&lt;&lt;=(const valarray&amp;);
    valarray&amp; operator&gt;&gt;=(const valarray&amp;);

    <span class='comment'>// <a href='valarray.members'>[valarray.members]</a> member functions:
</span>    void swap(valarray&amp;) noexcept;

    size_t size() const;

    T sum() const;
    T min() const;
    T max() const;

    valarray shift (int) const;
    valarray cshift(int) const;
    valarray apply(T func(T)) const;
    valarray apply(T func(const T&amp;)) const;
    void resize(size_t sz, T c = T());
  };
}
</pre><div class='para' id='template.valarray.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#template.valarray.overview-1'>1</a></div><p >The
class template
<span class='texttt'>valarray&lt;T&gt;</span>
is a
one-dimensional smart array, with elements numbered sequentially from zero.
It is a representation of the mathematical concept
of an ordered set of values.
The illusion of higher dimensionality
may be produced by the familiar idiom of computed indices, together
with the powerful subsetting capabilities provided
by the generalized subscript operators.<a class='footnotenum' href='#footnote-277'>277</a></p></div><div class='para' id='template.valarray.overview-2'><div class='marginalizedparent'><a class='marginalized' href='#template.valarray.overview-2'>2</a></div><p >An implementation is permitted to qualify any of the functions declared in
<span class='texttt'>&lt;valarray&gt;</span>
as
<span class='texttt'>inline</span>.</p></div><div class='footnote' id='footnote-277'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-277'>277)</a></div><p >The intent is to specify
an array template that has the minimum functionality
necessary to address aliasing ambiguities and the proliferation of
temporaries.
Thus, the
<span class='texttt'>valarray</span>
template is neither a
matrix class nor a field class.
However, it is a very useful building block for designing such classes.</p></div></div><div id='valarray.cons'><h4 ><a class='secnum' href='#valarray.cons' style='min-width:118pt'>26.7.2.2</a> <span class='texttt'>valarray</span> constructors <a class='abbr_ref' href='valarray.cons'>[valarray.cons]</a></h4><p ><span class='indexparent'><a class='index' id='valarray,constructor'></a></span><code class='itemdecl'>
valarray();
</code></p><div class='itemdescr'></div><div class='para' id='valarray.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an object of class
<span class='texttt'>valarray&lt;T&gt;</span><a class='footnotenum' href='#footnote-278'>278</a>
which has zero length.<a class='footnotenum' href='#footnote-279'>279</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='valarray,constructor'></a></span><code class='itemdecl'>
explicit valarray(size_t);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cons-2'>2</a></div><div class='itemdescr'><p >The array created by this constructor has a length equal to the value of the argument.
The elements of the array are value-initialized (<a href='dcl.init'>[dcl.init]</a>).
</p></div></div><p ><span class='indexparent'><a class='index' id='valarray,constructor'></a></span><code class='itemdecl'>
valarray(const T&amp;, size_t);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cons-3'>3</a></div><div class='itemdescr'><p >The array created by this constructor has a length equal to the second
argument.
The elements of the array are initialized with the value of the first argument.
</p></div></div><p ><span class='indexparent'><a class='index' id='valarray,constructor'></a></span><code class='itemdecl'>
valarray(const T*, size_t);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cons-4'>4</a></div><div class='itemdescr'><p >The array created by this constructor has a length equal to the second
argument
<span class='texttt'>n</span>.
The values of the elements of the array are initialized with the
first
<span class='texttt'>n</span>
values pointed to by the first argument.<a class='footnotenum' href='#footnote-280'>280</a>
If the value of the second argument is greater than the number of values
pointed to by the first argument, the behavior is undefined.<span class='indexparent'><a class='index' id='undefined'></a></span>
</p></div></div><p ><span class='indexparent'><a class='index' id='valarray,constructor'></a></span><code class='itemdecl'>
valarray(const valarray&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cons-5'>5</a></div><div class='itemdescr'><p >The array created by this constructor has the same length as the argument
array.
The elements are initialized with the values of the corresponding
elements of the argument array.<a class='footnotenum' href='#footnote-281'>281</a>
</p></div></div><p ><span class='indexparent'><a class='index' id='valarray,constructor'></a></span><code class='itemdecl'>
valarray(valarray&amp;&amp; v) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='valarray.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cons-6'>6</a></div><div class='itemdescr'><p >The array created by this constructor has the same length as the argument
array.
The elements are initialized with the values of the corresponding
elements of the argument array.</p></div></div><div class='para' id='valarray.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cons-7'>7</a></div><div class='itemdescr'><p ><i>Complexity:</i> Constant.
</p></div></div><p ><span class='indexparent'><a class='index' id='valarray,constructor'></a></span><code class='itemdecl'>
valarray(initializer_list&lt;T&gt; il);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.cons-8'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cons-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> Same as <span class='texttt'>valarray(il.begin(), il.size())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='valarray,constructor'></a></span><code class='itemdecl'>
valarray(const slice_array&lt;T&gt;&amp;);
valarray(const gslice_array&lt;T&gt;&amp;);
valarray(const mask_array&lt;T&gt;&amp;);
valarray(const indirect_array&lt;T&gt;&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.cons-9'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cons-9'>9</a></div><div class='itemdescr'><p >These conversion constructors convert one of the four reference templates
to a
<span class='texttt'>valarray</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='valarray,destructor'></a></span><code class='itemdecl'>
~valarray();
</code></p><div class='itemdescr'></div><div class='para' id='valarray.cons-10'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cons-10'>10</a></div><div class='itemdescr'><p >The destructor is applied to every element of
<span class='texttt'>*this</span>;
an implementation may return all allocated memory.
</p></div></div><div class='footnote' id='footnote-278'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-278'>278)</a></div><p >For convenience, such objects are referred
to as “arrays” throughout the
remainder of <a href='numarray'>[numarray]</a>.</p></div><div class='footnote' id='footnote-279'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-279'>279)</a></div><p >This default constructor is essential,
since arrays of
<span class='texttt'>valarray</span>
may be useful.
After initialization, the length of an empty array can be increased with the
<span class='texttt'>resize</span>
member function.</p></div><div class='footnote' id='footnote-280'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-280'>280)</a></div><p >This constructor is the
preferred method for converting a C array to a
<span class='texttt'>valarray</span>
object.</p></div><div class='footnote' id='footnote-281'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-281'>281)</a></div><p >This copy constructor creates
a distinct array rather than an alias.
Implementations in which arrays share storage are permitted, but they
shall implement a copy-on-reference mechanism to ensure that arrays are
conceptually distinct.</p></div></div><div id='valarray.assign'><h4 ><a class='secnum' href='#valarray.assign' style='min-width:118pt'>26.7.2.3</a> <span class='texttt'>valarray</span> assignment <a class='abbr_ref' href='valarray.assign'>[valarray.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator='></a></span><code class='itemdecl'>
valarray&amp; operator=(const valarray&amp; v);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#valarray.assign-1'>1</a></div><div class='itemdescr'><p >Each element of the
<span class='texttt'>*this</span>
array is assigned the value of the corresponding element of the argument
array.
If the length of <span class='texttt'>v</span> is not equal to the length of <span class='texttt'>*this</span>
, resizes <span class='texttt'>*this</span> to make the two arrays the same length,
as if by calling <span class='texttt'>resize(v.size())</span>, before performing the assignment.</p></div></div><div class='para' id='valarray.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#valarray.assign-2'>2</a></div><div class='itemdescr'><p ><i>Postconditions:</i> <span class='texttt'>size() == v.size()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator='></a></span><code class='itemdecl'>
valarray&amp; operator=(valarray&amp;&amp; v) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='valarray.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#valarray.assign-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>*this</span> obtains the value of <span class='texttt'>v</span>.
The value of <span class='texttt'>v</span> after the assignment is not specified.</p></div></div><div class='para' id='valarray.assign-4'><div class='marginalizedparent'><a class='marginalized' href='#valarray.assign-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i> Linear.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator='></a></span><code class='itemdecl'>
valarray&amp; operator=(initializer_list&lt;T&gt; il);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.assign-5'><div class='marginalizedparent'><a class='marginalized' href='#valarray.assign-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by: <span class='texttt'>*this = valarray(il);</span></p></div></div><div class='para' id='valarray.assign-6'><div class='marginalizedparent'><a class='marginalized' href='#valarray.assign-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator='></a></span><code class='itemdecl'>
valarray&amp; operator=(const T&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.assign-7'><div class='marginalizedparent'><a class='marginalized' href='#valarray.assign-7'>7</a></div><div class='itemdescr'><p >The scalar assignment operator causes each element of the
<span class='texttt'>*this</span>
array to be assigned the value of the argument.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator='></a></span><code class='itemdecl'>
valarray&amp; operator=(const slice_array&lt;T&gt;&amp;);
valarray&amp; operator=(const gslice_array&lt;T&gt;&amp;);
valarray&amp; operator=(const mask_array&lt;T&gt;&amp;);
valarray&amp; operator=(const indirect_array&lt;T&gt;&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.assign-8'><div class='marginalizedparent'><a class='marginalized' href='#valarray.assign-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i> The length of the array to which the argument refers equals <span class='texttt'>size()</span>.</p></div></div><div class='para' id='valarray.assign-9'><div class='marginalizedparent'><a class='marginalized' href='#valarray.assign-9'>9</a></div><div class='itemdescr'><p >These operators allow the results of a generalized subscripting operation
to be assigned directly to a
<span class='texttt'>valarray</span>.</p></div></div><div class='para' id='valarray.assign-10'><div class='marginalizedparent'><a class='marginalized' href='#valarray.assign-10'>10</a></div><div class='itemdescr'><p >If the value of an element in the left-hand side of a valarray assignment
operator depends on the value of another element in that left-hand side,
the behavior is undefined.
</p></div></div></div><div id='valarray.access'><h4 ><a class='secnum' href='#valarray.access' style='min-width:118pt'>26.7.2.4</a> <span class='texttt'>valarray</span> element access <a class='abbr_ref' href='valarray.access'>[valarray.access]</a></h4><p ><span class='indexparent'><a class='index' id='operator[],valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator[]'></a></span><code class='itemdecl'>
const T&amp;  operator[](size_t) const;
T&amp; operator[](size_t);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.access-1'><div class='marginalizedparent'><a class='marginalized' href='#valarray.access-1'>1</a></div><div class='itemdescr'><p >The subscript operator
returns a reference to the corresponding element of the array.</p></div></div><div class='para' id='valarray.access-2'><div class='marginalizedparent'><a class='marginalized' href='#valarray.access-2'>2</a></div><div class='itemdescr'><p >Thus, the expression
<span class='texttt'>(a[i] = q, a[i]) == q</span>
evaluates as <span class='texttt'>true</span> for any non-constant
<span class='texttt'>valarray&lt;T&gt; a</span>,
any
<span class='texttt'>T q</span>,
and for any
<span class='texttt'>size_t i</span>
such that the value of
<span class='texttt'>i</span>
is less than the length of
<span class='texttt'>a</span>.</p></div></div><div class='para' id='valarray.access-3'><div class='marginalizedparent'><a class='marginalized' href='#valarray.access-3'>3</a></div><div class='itemdescr'><p >The expression
<span class='texttt'>&amp;a[i+j] == &amp;a[i] + j</span>
evaluates as <span class='texttt'>true</span> for all
<span class='texttt'>size_t i</span>
and
<span class='texttt'>size_t j</span>
such that
<span class='texttt'>i+j</span>
is less than the length of the array
<span class='texttt'>a</span>.</p></div></div><div class='para' id='valarray.access-4'><div class='marginalizedparent'><a class='marginalized' href='#valarray.access-4'>4</a></div><div class='itemdescr'><p >Likewise, the expression
<span class='texttt'>&amp;a[i] != &amp;b[j]</span>
evaluates as
<span class='texttt'>true</span>
for any two arrays
<span class='texttt'>a</span>
and
<span class='texttt'>b</span>
and for any
<span class='texttt'>size_t i</span>
and
<span class='texttt'>size_t j</span>
such that
<span class='texttt'>i</span>
is less than the length of
<span class='texttt'>a</span>
and
<span class='texttt'>j</span>
is less than the length of
<span class='texttt'>b</span>.
This property indicates an absence of aliasing and may be used to
advantage by optimizing compilers.<a class='footnotenum' href='#footnote-282'>282</a></p></div></div><div class='para' id='valarray.access-5'><div class='marginalizedparent'><a class='marginalized' href='#valarray.access-5'>5</a></div><div class='itemdescr'><p >The reference returned by the subscript operator for an array shall
be valid until the member function
<span class='texttt'>resize(size_t, T)</span> (<a href='valarray.members'>[valarray.members]</a>) is called for that array or until the lifetime of
that array ends, whichever happens first.</p></div></div><div class='para' id='valarray.access-6'><div class='marginalizedparent'><a class='marginalized' href='#valarray.access-6'>6</a></div><div class='itemdescr'><p >If the subscript operator
is invoked with a
<span class='texttt'>size_t</span>
argument whose value is not
less than the length of the array, the behavior is undefined.<span class='indexparent'><a class='index' id='undefined'></a></span>
</p></div></div><div class='footnote' id='footnote-282'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-282'>282)</a></div><p >Compilers may take advantage
of inlining, constant propagation, loop fusion,
tracking of pointers obtained from
<span class='texttt'>operator new</span>,
and other
techniques to generate efficient
<span class='texttt'>valarray</span>s.</p></div></div><div id='valarray.sub'><h4 ><a class='secnum' href='#valarray.sub' style='min-width:118pt'>26.7.2.5</a> <span class='texttt'>valarray</span> subset operations <a class='abbr_ref' href='valarray.sub'>[valarray.sub]</a></h4><p ><span class='indexparent'><a class='index' id='operator[],valarray'></a></span></p><div class='para' id='valarray.sub-1'><div class='marginalizedparent'><a class='marginalized' href='#valarray.sub-1'>1</a></div><p >The member <span class='texttt'>operator[]</span> is overloaded to provide several ways to select
sequences of elements from among those controlled by <span class='texttt'>*this</span>. Each of these
operations returns a subset of the array. The const-qualified versions return this
subset as a new <span class='texttt'>valarray</span> object. The non-const versions return a class
template object which has reference semantics to the original array, working in
conjunction with various overloads of <span class='texttt'>operator=</span> and other assigning
operators to allow selective replacement (slicing) of the controlled sequence.
In each case the selected element(s) must exist.</p><p ><span class='indexparent'><a class='index' id='operator[],valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator[]'></a></span><code class='itemdecl'>
valarray operator[](slice slicearr) const;
</code></p></div><div class='itemdescr'></div><div class='para' id='valarray.sub-2'><div class='marginalizedparent'><a class='marginalized' href='#valarray.sub-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> An object of class <span class='texttt'>valarray&lt;T&gt;</span> containing those
elements of the controlled sequence designated by <span class='texttt'>slicearr</span>.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
const valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
<span class='comment'>// <span class='texttt'>v0[slice(2, 5, 3)]</span> returns <span class='texttt'>valarray&lt;char&gt;("cfilo", 5)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='operator[],valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator[]'></a></span><code class='itemdecl'>
slice_array&lt;T&gt; operator[](slice slicearr);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.sub-3'><div class='marginalizedparent'><a class='marginalized' href='#valarray.sub-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> An object that holds references to elements of the controlled
sequence selected by <span class='texttt'>slicearr</span>. [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDE", 5);
v0[slice(2, 5, 3)] = v1;
<span class='comment'>// <span class='texttt'>v0 == valarray&lt;char&gt;("abAdeBghCjkDmnEp", 16);</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='operator[],valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator[]'></a></span><code class='itemdecl'>
valarray operator[](const gslice&amp; gslicearr) const;
</code></p><div class='itemdescr'></div><div class='para' id='valarray.sub-4'><div class='marginalizedparent'><a class='marginalized' href='#valarray.sub-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> An object of class <span class='texttt'>valarray&lt;T&gt;</span> containing those
elements of the controlled sequence designated by <span class='texttt'>gslicearr</span>.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
const valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const size_t lv[] = { 2, 3 };
const size_t dv[] = { 7, 2 };
const valarray&lt;size_t&gt; len(lv, 2), str(dv, 2);
<span class='comment'>// <span class='texttt'>v0[gslice(3, len, str)]</span> returns
</span><span class='comment'>// <span class='texttt'>valarray&lt;char&gt;("dfhkmo", 6)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='operator[],valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator[]'></a></span><code class='itemdecl'>
gslice_array&lt;T&gt; operator[](const gslice&amp; gslicearr);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.sub-5'><div class='marginalizedparent'><a class='marginalized' href='#valarray.sub-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> An object that holds references to elements of the controlled
sequence selected by <span class='texttt'>gslicearr</span>. [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDEF", 6);
const size_t lv[] = { 2, 3 };
const size_t dv[] = { 7, 2 };
const valarray&lt;size_t&gt; len(lv, 2), str(dv, 2);
v0[gslice(3, len, str)] = v1;
<span class='comment'>// <span class='texttt'>v0 == valarray&lt;char&gt;("abcAeBgCijDlEnFp", 16)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='operator[],valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator[]'></a></span><code class='itemdecl'>
valarray operator[](const valarray&lt;bool&gt;&amp; boolarr) const;
</code></p><div class='itemdescr'></div><div class='para' id='valarray.sub-6'><div class='marginalizedparent'><a class='marginalized' href='#valarray.sub-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> An object of class <span class='texttt'>valarray&lt;T&gt;</span> containing those
elements of the controlled sequence designated by <span class='texttt'>boolarr</span>.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
const valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const bool vb[] = { false, false, true, true, false, true };
<span class='comment'>// <span class='texttt'>v0[valarray&lt;bool&gt;(vb, 6)]</span> returns
</span><span class='comment'>// <span class='texttt'>valarray&lt;char&gt;("cdf", 3)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='operator[],valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator[]'></a></span><code class='itemdecl'>
mask_array&lt;T&gt; operator[](const valarray&lt;bool&gt;&amp; boolarr);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.sub-7'><div class='marginalizedparent'><a class='marginalized' href='#valarray.sub-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i> An object that holds references to elements of the controlled
sequence selected by <span class='texttt'>boolarr</span>. [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABC", 3);
const bool vb[] = { false, false, true, true, false, true };
v0[valarray&lt;bool&gt;(vb, 6)] = v1;
<span class='comment'>// <span class='texttt'>v0 == valarray&lt;char&gt;("abABeCghijklmnop", 16)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='operator[],valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator[]'></a></span><code class='itemdecl'>
valarray operator[](const valarray&lt;size_t&gt;&amp; indarr) const;
</code></p><div class='itemdescr'></div><div class='para' id='valarray.sub-8'><div class='marginalizedparent'><a class='marginalized' href='#valarray.sub-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> An object of class <span class='texttt'>valarray&lt;T&gt;</span> containing those
elements of the controlled sequence designated by <span class='texttt'>indarr</span>.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
const valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
const size_t vi[] = { 7, 5, 2, 3, 8 };
<span class='comment'>// <span class='texttt'>v0[valarray&lt;size_t&gt;(vi, 5)]</span> returns
</span><span class='comment'>// <span class='texttt'>valarray&lt;char&gt;("hfcdi", 5)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='operator[],valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator[]'></a></span><code class='itemdecl'>
indirect_array&lt;T&gt; operator[](const valarray&lt;size_t&gt;&amp; indarr);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.sub-9'><div class='marginalizedparent'><a class='marginalized' href='#valarray.sub-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> An object that holds references to elements of the controlled
sequence selected by <span class='texttt'>indarr</span>. [&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
valarray&lt;char&gt; v0("abcdefghijklmnop", 16);
valarray&lt;char&gt; v1("ABCDE", 5);
const size_t vi[] = { 7, 5, 2, 3, 8 };
v0[valarray&lt;size_t&gt;(vi, 5)] = v1;
<span class='comment'>// <span class='texttt'>v0 == valarray&lt;char&gt;("abCDeBgAEjklmnop", 16)</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div></div><div id='valarray.unary'><h4 ><a class='secnum' href='#valarray.unary' style='min-width:118pt'>26.7.2.6</a> <span class='texttt'>valarray</span> unary operators <a class='abbr_ref' href='valarray.unary'>[valarray.unary]</a></h4><p ><span class='indexparent'><a class='index' id='operator+,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator+'></a></span><span class='indexparent'><a class='index' id='operator-,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator-'></a></span><span class='indexparent'><a class='index' id='operator_,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator_'></a></span><span class='indexparent'><a class='index' id='operator!,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator!'></a></span><code class='itemdecl'>
valarray operator+() const;
valarray operator-() const;
valarray operator~() const;
valarray&lt;bool&gt; operator!() const;
</code></p><div class='itemdescr'></div><div class='para' id='valarray.unary-1'><div class='marginalizedparent'><a class='marginalized' href='#valarray.unary-1'>1</a></div><div class='itemdescr'><p >Each of these operators may only be instantiated for a type <span class='texttt'>T</span>
to which the indicated operator can be applied and for which the indicated
operator returns a value which is of type <span class='texttt'>T</span> (<span class='texttt'>bool</span> for
<span class='texttt'>operator!</span>) or which may be unambiguously implicitly converted to type
<span class='texttt'>T</span> (<span class='texttt'>bool</span> for <span class='texttt'>operator!</span>).</p></div></div><div class='para' id='valarray.unary-2'><div class='marginalizedparent'><a class='marginalized' href='#valarray.unary-2'>2</a></div><div class='itemdescr'><p >Each of these operators returns an array whose length is equal to the length
of the array.
Each element of the returned array is initialized with the result of
applying the indicated operator to the corresponding element of the array.
</p></div></div></div><div id='valarray.cassign'><h4 ><a class='secnum' href='#valarray.cassign' style='min-width:118pt'>26.7.2.7</a> <span class='texttt'>valarray</span> compound assignment <a class='abbr_ref' href='valarray.cassign'>[valarray.cassign]</a></h4><p ><span class='indexparent'><a class='index' id='operator*=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator*='></a></span><span class='indexparent'><a class='index' id='operator/=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator/='></a></span><span class='indexparent'><a class='index' id='operator%=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator%='></a></span><span class='indexparent'><a class='index' id='operator+=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator+='></a></span><span class='indexparent'><a class='index' id='operator-=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator-='></a></span><span class='indexparent'><a class='index' id='operator^=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator^='></a></span><span class='indexparent'><a class='index' id='operator&=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator&='></a></span><span class='indexparent'><a class='index' id='operator|=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator|='></a></span><span class='indexparent'><a class='index' id='operator<<=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator<<='></a></span><span class='indexparent'><a class='index' id='operator>>=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator>>='></a></span><code class='itemdecl'>
valarray&amp; operator*= (const valarray&amp;);
valarray&amp; operator/= (const valarray&amp;);
valarray&amp; operator%= (const valarray&amp;);
valarray&amp; operator+= (const valarray&amp;);
valarray&amp; operator-= (const valarray&amp;);
valarray&amp; operator^= (const valarray&amp;);
valarray&amp; operator&amp;= (const valarray&amp;);
valarray&amp; operator|= (const valarray&amp;);
valarray&amp; operator&lt;&lt;=(const valarray&amp;);
valarray&amp; operator&gt;&gt;=(const valarray&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.cassign-1'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cassign-1'>1</a></div><div class='itemdescr'><p >Each of these operators may only be instantiated for a type <span class='texttt'>T</span>
to which the indicated operator can be applied.
Each of these operators
performs the indicated operation on each of its elements and the
corresponding element of the argument array.</p></div></div><div class='para' id='valarray.cassign-2'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cassign-2'>2</a></div><div class='itemdescr'><p >The array is then returned by reference.</p></div></div><div class='para' id='valarray.cassign-3'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cassign-3'>3</a></div><div class='itemdescr'><p >If the array and the
argument array do not have the same length, the behavior is undefined.<span class='indexparent'><a class='index' id='undefined'></a></span>
The appearance of an array on the left-hand side of a compound assignment
does <span class='texttt'>not</span> invalidate references or pointers.</p></div></div><div class='para' id='valarray.cassign-4'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cassign-4'>4</a></div><div class='itemdescr'><p >If the value of an element in the left-hand side of a valarray compound
assignment operator depends on the value of another element in that left
hand side, the behavior is undefined.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator*=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator*='></a></span><span class='indexparent'><a class='index' id='operator/=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator/='></a></span><span class='indexparent'><a class='index' id='operator%=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator%='></a></span><span class='indexparent'><a class='index' id='operator+=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator+='></a></span><span class='indexparent'><a class='index' id='operator-=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator-='></a></span><span class='indexparent'><a class='index' id='operator^=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator^='></a></span><span class='indexparent'><a class='index' id='operator&=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator&='></a></span><span class='indexparent'><a class='index' id='operator|=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator|='></a></span><span class='indexparent'><a class='index' id='operator<<=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator<<='></a></span><span class='indexparent'><a class='index' id='operator>>=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator>>='></a></span><code class='itemdecl'>
valarray&amp; operator*= (const T&amp;);
valarray&amp; operator/= (const T&amp;);
valarray&amp; operator%= (const T&amp;);
valarray&amp; operator+= (const T&amp;);
valarray&amp; operator-= (const T&amp;);
valarray&amp; operator^= (const T&amp;);
valarray&amp; operator&amp;= (const T&amp;);
valarray&amp; operator|= (const T&amp;);
valarray&amp; operator&lt;&lt;=(const T&amp;);
valarray&amp; operator&gt;&gt;=(const T&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.cassign-5'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cassign-5'>5</a></div><div class='itemdescr'><p >Each of these operators may only be instantiated for a type <span class='texttt'>T</span>
to which the indicated operator can be applied.</p></div></div><div class='para' id='valarray.cassign-6'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cassign-6'>6</a></div><div class='itemdescr'><p >Each of these operators applies the indicated operation to each element
of the array and the non-array argument.</p></div></div><div class='para' id='valarray.cassign-7'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cassign-7'>7</a></div><div class='itemdescr'><p >The array is then returned by reference.</p></div></div><div class='para' id='valarray.cassign-8'><div class='marginalizedparent'><a class='marginalized' href='#valarray.cassign-8'>8</a></div><div class='itemdescr'><p >The appearance of an array on the left-hand side of a compound assignment
does
<i>not</i>
invalidate references or pointers to the elements of the array.
</p></div></div></div><div id='valarray.members'><h4 ><a class='secnum' href='#valarray.members' style='min-width:118pt'>26.7.2.8</a> <span class='texttt'>valarray</span> member functions <a class='abbr_ref' href='valarray.members'>[valarray.members]</a></h4><p ><span class='indexparent'><a class='index' id='swap,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,swap'></a></span><code class='itemdecl'>
void swap(valarray&amp; v) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='valarray.members-1'><div class='marginalizedparent'><a class='marginalized' href='#valarray.members-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>*this</span> obtains the value of
<span class='texttt'>v</span>. <span class='texttt'>v</span> obtains the value of <span class='texttt'>*this</span>.</p></div></div><div class='para' id='valarray.members-2'><div class='marginalizedparent'><a class='marginalized' href='#valarray.members-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i> Constant.
</p></div></div><p ><span class='indexparent'><a class='index' id='size,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,size'></a></span><code class='itemdecl'>
size_t size() const;
</code></p><div class='itemdescr'></div><div class='para' id='valarray.members-3'><div class='marginalizedparent'><a class='marginalized' href='#valarray.members-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> The number of elements in the array.</p></div></div><div class='para' id='valarray.members-4'><div class='marginalizedparent'><a class='marginalized' href='#valarray.members-4'>4</a></div><div class='itemdescr'><p ><i>Complexity:</i> Constant time.
</p></div></div><p ><span class='indexparent'><a class='index' id='sum,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,sum'></a></span><code class='itemdecl'>
T sum() const;
</code></p><div class='itemdescr'><p >This function may only be instantiated for a type <span class='texttt'>T</span> to which
<span class='texttt'>operator+=</span>
can be applied.
This function returns the sum of all the elements of the array.</p></div><div class='para' id='valarray.members-5'><div class='marginalizedparent'><a class='marginalized' href='#valarray.members-5'>5</a></div><div class='itemdescr'><p >If the array has length 0, the behavior is undefined.<span class='indexparent'><a class='index' id='undefined'></a></span>
If the array has length 1,
<span class='texttt'>sum()</span>
returns the value of element 0.
Otherwise, the returned value is calculated by applying
<span class='texttt'>operator+=</span>
to a copy of an element of the array and
all other elements of the array in an unspecified order.<span class='indexparent'><a class='index' id='unspecified_behavior'></a></span>
</p></div></div><p ><span class='indexparent'><a class='index' id='min,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,min'></a></span><code class='itemdecl'>
T min() const;
</code></p><div class='itemdescr'></div><div class='para' id='valarray.members-6'><div class='marginalizedparent'><a class='marginalized' href='#valarray.members-6'>6</a></div><div class='itemdescr'><p >This function returns the minimum value contained in
<span class='texttt'>*this</span>.
The value returned for an array of length 0 is undefined.
For an array
of length 1, the value of element 0 is returned.
For all other array
lengths, the determination is made using
<span class='texttt'>operator&lt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='max,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,max'></a></span><code class='itemdecl'>
T max() const;
</code></p><div class='itemdescr'></div><div class='para' id='valarray.members-7'><div class='marginalizedparent'><a class='marginalized' href='#valarray.members-7'>7</a></div><div class='itemdescr'><p >This function returns the maximum value contained in
<span class='texttt'>*this</span>.
The value returned for an array of length 0 is undefined.
For an array
of length 1, the value of element 0 is returned.
For all other array
lengths, the determination is made using
<span class='texttt'>operator&lt;</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='shift,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,shift'></a></span><code class='itemdecl'>
valarray shift(int n) const;
</code></p><div class='itemdescr'></div><div class='para' id='valarray.members-8'><div class='marginalizedparent'><a class='marginalized' href='#valarray.members-8'>8</a></div><div class='itemdescr'><p >This function returns an object of class
<span class='texttt'>valarray&lt;T&gt;</span>
of length
<span class='texttt'>size()</span>,
each of whose elements
<i>I</i>
is
<span class='texttt'>(*this)[I + n]</span>
if
<span class='texttt'>I + n</span>
is non-negative and less than
<span class='texttt'>size()</span>,
otherwise
<span class='texttt'>T()</span>.
Thus if element zero is taken as the leftmost element,
a positive value of <span class='texttt'>n</span> shifts the elements left <span class='texttt'>n</span>
places, with zero fill.</p></div></div><div class='para' id='valarray.members-9'><div class='marginalizedparent'><a class='marginalized' href='#valarray.members-9'>9</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i><span class='space'></span>
If the argument has the value -2,
the first two elements of the result will be value-initialized (<a href='dcl.init'>[dcl.init]</a>); the third element of the result will be assigned the value
of the first element of the argument; etc.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='cshift,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,cshift'></a></span><code class='itemdecl'>
valarray cshift(int n) const;
</code></p><div class='itemdescr'></div><div class='para' id='valarray.members-10'><div class='marginalizedparent'><a class='marginalized' href='#valarray.members-10'>10</a></div><div class='itemdescr'><p >This function returns an object of class
<span class='texttt'>valarray&lt;T&gt;</span>
of length
<span class='texttt'>size()</span>
that is a circular shift of <span class='texttt'>*this</span>. If element zero is taken as the leftmost element, a non-negative value of <span class='emph'>n</span> shifts the elements circularly left <span class='emph'>n</span> places and a negative value of <span class='emph'>n</span> shifts the elements circularly right <span class='emph'>-n</span> places.
</p></div></div><p ><span class='indexparent'><a class='index' id='apply,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,apply'></a></span><code class='itemdecl'>
valarray apply(T func(T)) const;
valarray apply(T func(const T&amp;)) const;
</code></p><div class='itemdescr'></div><div class='para' id='valarray.members-11'><div class='marginalizedparent'><a class='marginalized' href='#valarray.members-11'>11</a></div><div class='itemdescr'><p >These functions return an array whose length is equal to the array.
Each element of the returned array is assigned
the value returned by applying the argument function to the
corresponding element of the array.
</p></div></div><p ><span class='indexparent'><a class='index' id='resize,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,resize'></a></span><code class='itemdecl'>
void resize(size_t sz, T c = T());
</code></p><div class='itemdescr'></div><div class='para' id='valarray.members-12'><div class='marginalizedparent'><a class='marginalized' href='#valarray.members-12'>12</a></div><div class='itemdescr'><p >This member function changes the length of the
<span class='texttt'>*this</span>
array to
<span class='texttt'>sz</span>
and then assigns to each element the value of the second argument.
Resizing invalidates all pointers and references to elements in the array.
</p></div></div></div></div><div id='valarray.nonmembers'><h3 ><a class='secnum' href='#valarray.nonmembers' style='min-width:103pt'>26.7.3</a> <span class='texttt'>valarray</span> non-member operations <a class='abbr_ref' href='valarray.nonmembers'>[valarray.nonmembers]</a></h3><div id='valarray.binary'><h4 ><a class='secnum' href='#valarray.binary' style='min-width:118pt'>26.7.3.1</a> <span class='texttt'>valarray</span> binary operators <a class='abbr_ref' href='valarray.binary'>[valarray.binary]</a></h4><p ><span class='indexparent'><a class='index' id='operator*,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator*'></a></span><span class='indexparent'><a class='index' id='operator/,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator/'></a></span><span class='indexparent'><a class='index' id='operator%,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator%'></a></span><span class='indexparent'><a class='index' id='operator+,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator+'></a></span><span class='indexparent'><a class='index' id='operator-,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator-'></a></span><span class='indexparent'><a class='index' id='operator^,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator^'></a></span><span class='indexparent'><a class='index' id='operator&,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator&'></a></span><span class='indexparent'><a class='index' id='operator|,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator|'></a></span><span class='indexparent'><a class='index' id='operator<<,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator<<'></a></span><span class='indexparent'><a class='index' id='operator>>,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator>>'></a></span><code class='itemdecl'>
template&lt;class T&gt; valarray&lt;T&gt; operator*
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator/
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator%
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator+
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator-
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator^
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&amp;
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator|
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&lt;&lt;
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&gt;&gt;
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.binary-1'><div class='marginalizedparent'><a class='marginalized' href='#valarray.binary-1'>1</a></div><div class='itemdescr'><p >Each of these operators may only be instantiated for a type <span class='texttt'>T</span>
to which the indicated operator can be applied and for which the indicated
operator returns a value which is of type <span class='texttt'>T</span> or which
can be unambiguously implicitly converted to type <span class='texttt'>T</span>.</p></div></div><div class='para' id='valarray.binary-2'><div class='marginalizedparent'><a class='marginalized' href='#valarray.binary-2'>2</a></div><div class='itemdescr'><p >Each of these operators returns an array whose length is equal to the
lengths of the argument arrays.
Each element of the returned array is
initialized with the result of applying the indicated operator to the
corresponding elements of the argument arrays.</p></div></div><div class='para' id='valarray.binary-3'><div class='marginalizedparent'><a class='marginalized' href='#valarray.binary-3'>3</a></div><div class='itemdescr'><p >If the argument arrays do not have the same length, the behavior is undefined.<span class='indexparent'><a class='index' id='undefined'></a></span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator*,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator*'></a></span><span class='indexparent'><a class='index' id='operator/,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator/'></a></span><span class='indexparent'><a class='index' id='operator%,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator%'></a></span><span class='indexparent'><a class='index' id='operator+,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator+'></a></span><span class='indexparent'><a class='index' id='operator-,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator-'></a></span><span class='indexparent'><a class='index' id='operator^,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator^'></a></span><span class='indexparent'><a class='index' id='operator&,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator&'></a></span><span class='indexparent'><a class='index' id='operator|,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator|'></a></span><span class='indexparent'><a class='index' id='operator<<,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator<<'></a></span><span class='indexparent'><a class='index' id='operator>>,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator>>'></a></span><code class='itemdecl'>
template&lt;class T&gt; valarray&lt;T&gt; operator* (const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator* (const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator/ (const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator/ (const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator% (const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator% (const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator+ (const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator+ (const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator- (const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator- (const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator^ (const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator^ (const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&amp; (const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&amp; (const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator| (const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator| (const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&lt;&lt;(const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&lt;&lt;(const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&gt;&gt;(const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&gt;&gt;(const T&amp;, const valarray&lt;T&gt;&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.binary-4'><div class='marginalizedparent'><a class='marginalized' href='#valarray.binary-4'>4</a></div><div class='itemdescr'><p >Each of these operators may only be instantiated for a type <span class='texttt'>T</span>
to which the indicated operator can be applied and for which
the indicated operator returns a value which is of type <span class='texttt'>T</span>
or which can be unambiguously implicitly converted to type <span class='texttt'>T</span>.</p></div></div><div class='para' id='valarray.binary-5'><div class='marginalizedparent'><a class='marginalized' href='#valarray.binary-5'>5</a></div><div class='itemdescr'><p >Each of these operators returns an array whose length is equal to the
length of the array argument.
Each element of the returned array is
initialized with the result of applying the indicated operator to the
corresponding element of the array argument and the non-array argument.
</p></div></div></div><div id='valarray.comparison'><h4 ><a class='secnum' href='#valarray.comparison' style='min-width:118pt'>26.7.3.2</a> <span class='texttt'>valarray</span> logical operators <a class='abbr_ref' href='valarray.comparison'>[valarray.comparison]</a></h4><p ><span class='indexparent'><a class='index' id='operator==,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator=='></a></span><span class='indexparent'><a class='index' id='operator!=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator!='></a></span><span class='indexparent'><a class='index' id='operator<,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator<'></a></span><span class='indexparent'><a class='index' id='operator>,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator>'></a></span><span class='indexparent'><a class='index' id='operator<=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator<='></a></span><span class='indexparent'><a class='index' id='operator>=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator>='></a></span><span class='indexparent'><a class='index' id='operator&&,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator&&'></a></span><span class='indexparent'><a class='index' id='operator||,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator||'></a></span><code class='itemdecl'>
template&lt;class T&gt; valarray&lt;bool&gt; operator==
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator!=
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&lt;
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&gt;
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&lt;=
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&gt;=
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&amp;&amp;
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator||
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.comparison-1'><div class='marginalizedparent'><a class='marginalized' href='#valarray.comparison-1'>1</a></div><div class='itemdescr'><p >Each of these operators may only be instantiated for a type <span class='texttt'>T</span>
to which the indicated operator can be applied and for which
the indicated operator returns a value which is of type <span class='texttt'>bool</span>
or which can be unambiguously implicitly converted to type <span class='texttt'>bool</span>.</p></div></div><div class='para' id='valarray.comparison-2'><div class='marginalizedparent'><a class='marginalized' href='#valarray.comparison-2'>2</a></div><div class='itemdescr'><p >Each of these operators returns a <span class='texttt'>bool</span> array whose length
is equal to the length of the array arguments.
Each element of the returned
array is initialized with the result of applying the indicated
operator to the corresponding elements of the argument arrays.</p></div></div><div class='para' id='valarray.comparison-3'><div class='marginalizedparent'><a class='marginalized' href='#valarray.comparison-3'>3</a></div><div class='itemdescr'><p >If the two array arguments do not have the same length,
the behavior is undefined.<span class='indexparent'><a class='index' id='undefined'></a></span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator==,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator=='></a></span><span class='indexparent'><a class='index' id='operator!=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator!='></a></span><span class='indexparent'><a class='index' id='operator<,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator<'></a></span><span class='indexparent'><a class='index' id='operator<=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator<='></a></span><span class='indexparent'><a class='index' id='operator>,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator>'></a></span><span class='indexparent'><a class='index' id='operator>=,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator>='></a></span><span class='indexparent'><a class='index' id='operator&&,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator&&'></a></span><span class='indexparent'><a class='index' id='operator||,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,operator||'></a></span><code class='itemdecl'>
template&lt;class T&gt; valarray&lt;bool&gt; operator==(const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator==(const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator!=(const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator!=(const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&lt; (const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&lt; (const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&gt; (const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&gt; (const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&lt;=(const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&lt;=(const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&gt;=(const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&gt;=(const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&amp;&amp;(const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&amp;&amp;(const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator||(const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator||(const T&amp;, const valarray&lt;T&gt;&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.comparison-4'><div class='marginalizedparent'><a class='marginalized' href='#valarray.comparison-4'>4</a></div><div class='itemdescr'><p >Each of these operators may only be instantiated for a type <span class='texttt'>T</span>
to which the indicated operator can be applied and for which
the indicated operator returns a value which is of type <span class='texttt'>bool</span>
or which can be unambiguously implicitly converted to type <span class='texttt'>bool</span>.</p></div></div><div class='para' id='valarray.comparison-5'><div class='marginalizedparent'><a class='marginalized' href='#valarray.comparison-5'>5</a></div><div class='itemdescr'><p >Each of these operators returns a <span class='texttt'>bool</span> array whose
length is equal to the length of the array argument.
Each element
of the returned array is initialized with the result of applying the
indicated operator to the corresponding element of the array and the non-array argument.
</p></div></div></div><div id='valarray.transcend'><h4 ><a class='secnum' href='#valarray.transcend' style='min-width:118pt'>26.7.3.3</a> <span class='texttt'>valarray</span> transcendentals <a class='abbr_ref' href='valarray.transcend'>[valarray.transcend]</a></h4><p ><span class='indexparent'><a class='index' id='abs,valarray'></a></span><span class='indexparent'><a class='index' id='acos,valarray'></a></span><span class='indexparent'><a class='index' id='asin,valarray'></a></span><span class='indexparent'><a class='index' id='atan,valarray'></a></span><span class='indexparent'><a class='index' id='atan2,valarray'></a></span><span class='indexparent'><a class='index' id='cos,valarray'></a></span><span class='indexparent'><a class='index' id='cosh,valarray'></a></span><span class='indexparent'><a class='index' id='exp,valarray'></a></span><span class='indexparent'><a class='index' id='log,valarray'></a></span><span class='indexparent'><a class='index' id='log10,valarray'></a></span><span class='indexparent'><a class='index' id='pow,valarray'></a></span><span class='indexparent'><a class='index' id='sin,valarray'></a></span><span class='indexparent'><a class='index' id='sinh,valarray'></a></span><span class='indexparent'><a class='index' id='sqrt,valarray'></a></span><span class='indexparent'><a class='index' id='tan,valarray'></a></span><span class='indexparent'><a class='index' id='tanh,valarray'></a></span><code class='itemdecl'>
template&lt;class T&gt; valarray&lt;T&gt; abs  (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; acos (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; asin (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan2
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan2(const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan2(const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; cos  (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; cosh (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; exp  (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; log  (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; log10(const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; pow
    (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; pow  (const valarray&lt;T&gt;&amp;, const T&amp;);
template&lt;class T&gt; valarray&lt;T&gt; pow  (const T&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; sin  (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; sinh (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; sqrt (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; tan  (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; tanh (const valarray&lt;T&gt;&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.transcend-1'><div class='marginalizedparent'><a class='marginalized' href='#valarray.transcend-1'>1</a></div><div class='itemdescr'><p >Each of these functions may only be instantiated for a type <span class='texttt'>T</span>
to which a unique function with the indicated name can be applied (unqualified).
This function shall return a value which is of type <span class='texttt'>T</span>
or which can be unambiguously implicitly converted to type <span class='texttt'>T</span>.
</p></div></div></div><div id='valarray.special'><h4 ><a class='secnum' href='#valarray.special' style='min-width:118pt'>26.7.3.4</a> <span class='texttt'>valarray</span> specialized algorithms <a class='abbr_ref' href='valarray.special'>[valarray.special]</a></h4><p ><span class='indexparent'><a class='index' id='swap,valarray'></a></span><span class='indexparent'><a class='index' id='valarray,swap'></a></span><code class='itemdecl'>
template &lt;class T&gt; void swap(valarray&lt;T&gt;&amp; x, valarray&lt;T&gt;&amp; y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='valarray.special-1'><div class='marginalizedparent'><a class='marginalized' href='#valarray.special-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>x.swap(y)</span>.
</p></div></div></div></div><div id='class.slice'><h3 ><a class='secnum' href='#class.slice' style='min-width:103pt'>26.7.4</a> Class <span class='texttt'>slice</span> <a class='abbr_ref' href='class.slice'>[class.slice]</a></h3><div id='class.slice.overview'><h4 ><a class='secnum' href='#class.slice.overview' style='min-width:118pt'>26.7.4.1</a> Class <span class='texttt'>slice</span> overview <a class='abbr_ref' href='class.slice.overview'>[class.slice.overview]</a></h4><p ><span class='indexparent'><a class='index' id='slice'></a></span></p><pre class='codeblock'>
namespace std {
  class slice {
  public:
    slice();
    slice(size_t, size_t, size_t);

    size_t start() const;
    size_t size() const;
    size_t stride() const;
  };
}
</pre><div class='para' id='class.slice.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#class.slice.overview-1'>1</a></div><p >The
<span class='texttt'>slice</span>
class represents a BLAS-like slice from an array.
Such a slice is specified by a starting index, a length, and a
stride.<a class='footnotenum' href='#footnote-283'>283</a></p></div><div class='footnote' id='footnote-283'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-283'>283)</a></div><p >BLAS stands for
<i>Basic Linear Algebra Subprograms.</i>
C++ programs may instantiate this class.
See, for example,
Dongarra, Du Croz, Duff, and Hammerling:
<i>A set of Level 3 Basic Linear Algebra Subprograms</i>;
Technical Report MCS-P1-0888,
Argonne National Laboratory (USA),
Mathematics and Computer Science Division,
August, 1988.</p></div></div><div id='cons.slice'><h4 ><a class='secnum' href='#cons.slice' style='min-width:118pt'>26.7.4.2</a> <span class='texttt'>slice</span> constructors <a class='abbr_ref' href='cons.slice'>[cons.slice]</a></h4><p ><span class='indexparent'><a class='index' id='slice,constructor'></a></span><code class='itemdecl'>
slice();
slice(size_t start, size_t length, size_t stride);
slice(const slice&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='cons.slice-1'><div class='marginalizedparent'><a class='marginalized' href='#cons.slice-1'>1</a></div><div class='itemdescr'><p >The default constructor is equivalent to <span class='texttt'>slice(0, 0, 0)</span>.
A default constructor is provided only to permit the declaration of arrays of slices.
The constructor with arguments for a slice takes a start, length, and stride
parameter.</p></div></div><div class='para' id='cons.slice-2'><div class='marginalizedparent'><a class='marginalized' href='#cons.slice-2'>2</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i><span class='space'></span>
<span class='texttt'>slice(3, 8, 2)</span>
constructs a slice which selects elements 3, 5, 7, ... 17 from an array.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div></div><div id='slice.access'><h4 ><a class='secnum' href='#slice.access' style='min-width:118pt'>26.7.4.3</a> <span class='texttt'>slice</span> access functions <a class='abbr_ref' href='slice.access'>[slice.access]</a></h4><p ><span class='indexparent'><a class='index' id='start,slice'></a></span><span class='indexparent'><a class='index' id='slice,start'></a></span><span class='indexparent'><a class='index' id='size,slice'></a></span><span class='indexparent'><a class='index' id='slice,size'></a></span><span class='indexparent'><a class='index' id='stride,slice'></a></span><span class='indexparent'><a class='index' id='slice,stride'></a></span><code class='itemdecl'>
size_t start() const;
size_t size() const;
size_t stride() const;
</code></p><div class='itemdescr'></div><div class='para' id='slice.access-1'><div class='marginalizedparent'><a class='marginalized' href='#slice.access-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The start, length, or stride specified
by a <span class='texttt'>slice</span> object.</p></div></div><div class='para' id='slice.access-2'><div class='marginalizedparent'><a class='marginalized' href='#slice.access-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i> Constant time.
</p></div></div></div></div><div id='template.slice.array'><h3 ><a class='secnum' href='#template.slice.array' style='min-width:103pt'>26.7.5</a> Class template <span class='texttt'>slice_array</span> <a class='abbr_ref' href='template.slice.array'>[template.slice.array]</a></h3><div id='template.slice.array.overview'><h4 ><a class='secnum' href='#template.slice.array.overview' style='min-width:118pt'>26.7.5.1</a> Class template <span class='texttt'>slice_array</span> overview <a class='abbr_ref' href='template.slice.array.overview'>[template.slice.array.overview]</a></h4><p ><span class='indexparent'><a class='index' id='slice_array'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; class slice_array {
  public:
    using value_type = T;

    void operator=  (const valarray&lt;T&gt;&amp;) const;
    void operator*= (const valarray&lt;T&gt;&amp;) const;
    void operator/= (const valarray&lt;T&gt;&amp;) const;
    void operator%= (const valarray&lt;T&gt;&amp;) const;
    void operator+= (const valarray&lt;T&gt;&amp;) const;
    void operator-= (const valarray&lt;T&gt;&amp;) const;
    void operator^= (const valarray&lt;T&gt;&amp;) const;
    void operator&amp;= (const valarray&lt;T&gt;&amp;) const;
    void operator|= (const valarray&lt;T&gt;&amp;) const;
    void operator&lt;&lt;=(const valarray&lt;T&gt;&amp;) const;
    void operator&gt;&gt;=(const valarray&lt;T&gt;&amp;) const;

    slice_array(const slice_array&amp;);
    ~slice_array();
    const slice_array&amp; operator=(const slice_array&amp;) const;
    void operator=(const T&amp;) const;

    slice_array() = delete;       <span class='comment'>// as implied by declaring copy constructor above
</span>  };
}
</pre><div class='para' id='template.slice.array.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#template.slice.array.overview-1'>1</a></div><p >The
<span class='texttt'>slice_array</span>
template is a helper template used by the
<span class='texttt'>slice</span>
subscript operator</p><pre class='codeblock'>
slice_array&lt;T&gt; valarray&lt;T&gt;::operator[](slice);
</pre><p >It has reference semantics to a subset of an array specified by a
<span class='texttt'>slice</span>
object.</p></div><div class='para' id='template.slice.array.overview-2'><div class='marginalizedparent'><a class='marginalized' href='#template.slice.array.overview-2'>2</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
The expression
<span class='texttt'>a[slice(1, 5, 3)] = b;</span>
has the effect of assigning the elements of
<span class='texttt'>b</span>
to a slice of the elements in
<span class='texttt'>a</span>.
For the slice shown, the elements
selected from
<span class='texttt'>a</span>
are 1, 4, ..., 13.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='slice.arr.assign'><h4 ><a class='secnum' href='#slice.arr.assign' style='min-width:118pt'>26.7.5.2</a> <span class='texttt'>slice_array</span> assignment <a class='abbr_ref' href='slice.arr.assign'>[slice.arr.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,slice_array'></a></span><code class='itemdecl'>
void operator=(const valarray&lt;T&gt;&amp;) const;
const slice_array&amp; operator=(const slice_array&amp;) const;
</code></p><div class='itemdescr'></div><div class='para' id='slice.arr.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#slice.arr.assign-1'>1</a></div><div class='itemdescr'><p >These assignment operators have reference semantics,
assigning the values of the argument array elements to selected
elements of the
<span class='texttt'>valarray&lt;T&gt;</span>
object to which the
<span class='texttt'>slice_array</span>
object refers.
</p></div></div></div><div id='slice.arr.comp.assign'><h4 ><a class='secnum' href='#slice.arr.comp.assign' style='min-width:118pt'>26.7.5.3</a> <span class='texttt'>slice_array</span> compound assignment <a class='abbr_ref' href='slice.arr.comp.assign'>[slice.arr.comp.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator*=,slice_array'></a></span><span class='indexparent'><a class='index' id='slice_array,operator*='></a></span><span class='indexparent'><a class='index' id='operator/=,slice_array'></a></span><span class='indexparent'><a class='index' id='slice_array,operator/='></a></span><span class='indexparent'><a class='index' id='operator%=,slice_array'></a></span><span class='indexparent'><a class='index' id='slice_array,operator%='></a></span><span class='indexparent'><a class='index' id='operator+=,slice_array'></a></span><span class='indexparent'><a class='index' id='slice_array,operator+='></a></span><span class='indexparent'><a class='index' id='operator-=,slice_array'></a></span><span class='indexparent'><a class='index' id='slice_array,operator-='></a></span><span class='indexparent'><a class='index' id='operator^=,slice_array'></a></span><span class='indexparent'><a class='index' id='slice_array,operator^='></a></span><span class='indexparent'><a class='index' id='operator&=,slice_array'></a></span><span class='indexparent'><a class='index' id='slice_array,operator&='></a></span><span class='indexparent'><a class='index' id='operator|=,slice_array'></a></span><span class='indexparent'><a class='index' id='slice_array,operator|='></a></span><span class='indexparent'><a class='index' id='operator<<=,slice_array'></a></span><span class='indexparent'><a class='index' id='slice_array,operator<<='></a></span><span class='indexparent'><a class='index' id='operator>>=,slice_array'></a></span><span class='indexparent'><a class='index' id='slice_array,operator>>='></a></span><code class='itemdecl'>
void operator*= (const valarray&lt;T&gt;&amp;) const;
void operator/= (const valarray&lt;T&gt;&amp;) const;
void operator%= (const valarray&lt;T&gt;&amp;) const;
void operator+= (const valarray&lt;T&gt;&amp;) const;
void operator-= (const valarray&lt;T&gt;&amp;) const;
void operator^= (const valarray&lt;T&gt;&amp;) const;
void operator&amp;= (const valarray&lt;T&gt;&amp;) const;
void operator|= (const valarray&lt;T&gt;&amp;) const;
void operator&lt;&lt;=(const valarray&lt;T&gt;&amp;) const;
void operator&gt;&gt;=(const valarray&lt;T&gt;&amp;) const;
</code></p><div class='itemdescr'></div><div class='para' id='slice.arr.comp.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#slice.arr.comp.assign-1'>1</a></div><div class='itemdescr'><p >These compound assignments have reference semantics, applying the
indicated operation to the elements of the argument array
and selected elements of the
<span class='texttt'>valarray&lt;T&gt;</span>
object to which the
<span class='texttt'>slice_array</span>
object refers.
</p></div></div></div><div id='slice.arr.fill'><h4 ><a class='secnum' href='#slice.arr.fill' style='min-width:118pt'>26.7.5.4</a> <span class='texttt'>slice_array</span> fill function <a class='abbr_ref' href='slice.arr.fill'>[slice.arr.fill]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,slice_array'></a></span><span class='indexparent'><a class='index' id='slice_array,operator='></a></span><code class='itemdecl'>
void operator=(const T&amp;) const;
</code></p><div class='itemdescr'></div><div class='para' id='slice.arr.fill-1'><div class='marginalizedparent'><a class='marginalized' href='#slice.arr.fill-1'>1</a></div><div class='itemdescr'><p >This function has reference semantics, assigning the value of its argument
to the elements of the
<span class='texttt'>valarray&lt;T&gt;</span>
object to which the
<span class='texttt'>slice_array</span>
object refers.
</p></div></div></div></div><div id='class.gslice'><h3 ><a class='secnum' href='#class.gslice' style='min-width:103pt'>26.7.6</a> The <span class='texttt'>gslice</span> class <a class='abbr_ref' href='class.gslice'>[class.gslice]</a></h3><div id='class.gslice.overview'><h4 ><a class='secnum' href='#class.gslice.overview' style='min-width:118pt'>26.7.6.1</a> The <span class='texttt'>gslice</span> class overview <a class='abbr_ref' href='class.gslice.overview'>[class.gslice.overview]</a></h4><p ><span class='indexparent'><a class='index' id='gslice'></a></span></p><pre class='codeblock'>
namespace std {
  class gslice {
  public:
    gslice();
    gslice(size_t s, const valarray&lt;size_t&gt;&amp; l, const valarray&lt;size_t&gt;&amp; d);

    size_t           start() const;
    valarray&lt;size_t&gt; size() const;
    valarray&lt;size_t&gt; stride() const;
  };
}
</pre><div class='para' id='class.gslice.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#class.gslice.overview-1'>1</a></div><p >This class represents a generalized slice out of an array.
A
<span class='texttt'>gslice</span>
is defined by a starting offset (<span class='math'><span class='mathalpha'>s</span></span>),
a set of lengths (<span class='math'><span class='mathalpha'>l</span><sub ><span class='mathalpha'>j</span></sub></span>),
and a set of strides (<span class='math'><span class='mathalpha'>d</span><sub ><span class='mathalpha'>j</span></sub></span>).
The number of lengths shall equal the number of strides.</p></div><div class='para' id='class.gslice.overview-2'><div class='marginalizedparent'><a class='marginalized' href='#class.gslice.overview-2'>2</a></div><p >A
<span class='texttt'>gslice</span>
represents a mapping from a set of indices (<span class='math'><span class='mathalpha'>i</span><sub ><span class='mathalpha'>j</span></sub></span>),
equal in number to the number of strides, to a single index <span class='math'><span class='mathalpha'>k</span></span>.
It is useful for building multidimensional array classes using
the
<span class='texttt'>valarray</span>
template, which is one-dimensional.
The set of one-dimensional index values specified by a
<span class='texttt'>gslice</span>
are <img src='math/3834175389367651919.png' class='mathinlineimg' alt='$k = s + \sum_ji_jd_j$'/>
where the multidimensional indices <span class='math'><span class='mathalpha'>i</span><sub ><span class='mathalpha'>j</span></sub></span> range in value from
0 to <span class='math'><span class='mathalpha'>l</span><sub ><span class='mathalpha'>ij</span></sub> - 1</span>.</p></div><div class='para' id='class.gslice.overview-3'><div class='marginalizedparent'><a class='marginalized' href='#class.gslice.overview-3'>3</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
The
<span class='texttt'>gslice</span>
specification
</p><pre class='codeblock'>
start  = 3
length = {2, 4, 3}
stride = {19, 4, 1}
</pre><p >yields the sequence of one-dimensional indices</p><p ><span class='math'><span class='mathalpha'>k</span> = 3 + (0,1) &times; 19 + (0,1,2,3) &times; 4 + (0,1,2) &times; 1</span></p><p >which are ordered as shown in the following table:</p><pre >
<span class='='></span><span class='='></span><span class='kill'></span>&#9;<span class='math'>(<span class='mathalpha'>i</span><sub >0</sub>,&emsp;&ensp; <span class='mathalpha'>i</span><sub >1</sub>,&emsp;&ensp; <span class='mathalpha'>i</span><sub >2</sub>,&emsp;&ensp; <span class='mathalpha'>k</span>)&emsp;&ensp; =</span>
&#9;&#9;<span class='math'>(0,&emsp;&ensp; 0,&emsp;&ensp; 0,&emsp;&ensp;  3)</span>,    
&#9;&#9;<span class='math'>(0,&emsp;&ensp; 0,&emsp;&ensp; 1,&emsp;&ensp;  4)</span>,    
&#9;&#9;<span class='math'>(0,&emsp;&ensp; 0,&emsp;&ensp; 2,&emsp;&ensp;  5)</span>,    
&#9;&#9;<span class='math'>(0,&emsp;&ensp; 1,&emsp;&ensp; 0,&emsp;&ensp;  7)</span>,    
&#9;&#9;<span class='math'>(0,&emsp;&ensp; 1,&emsp;&ensp; 1,&emsp;&ensp;  8)</span>,    
&#9;&#9;<span class='math'>(0,&emsp;&ensp; 1,&emsp;&ensp; 2,&emsp;&ensp;  9)</span>,    
&#9;&#9;<span class='math'>(0,&emsp;&ensp; 2,&emsp;&ensp; 0,&emsp;&ensp; 11)</span>, 
&#9;&#9;<span class='math'>(0,&emsp;&ensp; 2,&emsp;&ensp; 1,&emsp;&ensp; 12)</span>, 
&#9;&#9;<span class='math'>(0,&emsp;&ensp; 2,&emsp;&ensp; 2,&emsp;&ensp; 13)</span>, 
&#9;&#9;<span class='math'>(0,&emsp;&ensp; 3,&emsp;&ensp; 0,&emsp;&ensp; 15)</span>, 
&#9;&#9;<span class='math'>(0,&emsp;&ensp; 3,&emsp;&ensp; 1,&emsp;&ensp; 16)</span>, 
&#9;&#9;<span class='math'>(0,&emsp;&ensp; 3,&emsp;&ensp; 2,&emsp;&ensp; 17)</span>, 
&#9;&#9;<span class='math'>(1,&emsp;&ensp; 0,&emsp;&ensp; 0,&emsp;&ensp; 22)</span>, 
&#9;&#9;<span class='math'>(1,&emsp;&ensp; 0,&emsp;&ensp; 1,&emsp;&ensp; 23)</span>, 
&#9;&#9;<span class='math'>&hellip;</span>      
&#9;&#9;<span class='math'>(1,&emsp;&ensp; 3,&emsp;&ensp; 2,&emsp;&ensp; 36)</span>
</pre><p >That is, the highest-ordered index turns fastest.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.gslice.overview-4'><div class='marginalizedparent'><a class='marginalized' href='#class.gslice.overview-4'>4</a></div><p >It is possible to have degenerate generalized slices in which an address
is repeated.</p></div><div class='para' id='class.gslice.overview-5'><div class='marginalizedparent'><a class='marginalized' href='#class.gslice.overview-5'>5</a></div><p >[&nbsp;<i>Example:</i><span class='space'></span>
If the stride parameters in the previous
example are changed to {1, 1, 1}, the first few elements of the
resulting sequence of indices will be</p><pre >
<span class='='></span><span class='kill'></span>&#9;<span class='math'>(0,&emsp;&ensp; 0,&emsp;&ensp; 0,&emsp;&ensp;  3)</span>,  
&#9;<span class='math'>(0,&emsp;&ensp; 0,&emsp;&ensp; 1,&emsp;&ensp;  4)</span>,  
&#9;<span class='math'>(0,&emsp;&ensp; 0,&emsp;&ensp; 2,&emsp;&ensp;  5)</span>,  
&#9;<span class='math'>(0,&emsp;&ensp; 1,&emsp;&ensp; 0,&emsp;&ensp;  4)</span>,  
&#9;<span class='math'>(0,&emsp;&ensp; 1,&emsp;&ensp; 1,&emsp;&ensp;  5)</span>,  
&#9;<span class='math'>(0,&emsp;&ensp; 1,&emsp;&ensp; 2,&emsp;&ensp;  6)</span>,  
&#9;<span class='math'>&hellip;</span>
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='class.gslice.overview-6'><div class='marginalizedparent'><a class='marginalized' href='#class.gslice.overview-6'>6</a></div><p >If a degenerate slice is used as the argument to the
non-<span class='texttt'>const</span>
version of
<span class='texttt'>operator[](const gslice&amp;)</span>,
the behavior is undefined.
<span class='indexparent'><a class='index' id='undefined'></a></span>
</p></div></div><div id='gslice.cons'><h4 ><a class='secnum' href='#gslice.cons' style='min-width:118pt'>26.7.6.2</a> <span class='texttt'>gslice</span> constructors <a class='abbr_ref' href='gslice.cons'>[gslice.cons]</a></h4><p ><span class='indexparent'><a class='index' id='gslice,constructor'></a></span><code class='itemdecl'>
gslice();
gslice(size_t start, const valarray&lt;size_t&gt;&amp; lengths,
         const valarray&lt;size_t&gt;&amp; strides);
gslice(const gslice&amp;);
</code></p><div class='itemdescr'></div><div class='para' id='gslice.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#gslice.cons-1'>1</a></div><div class='itemdescr'><p >The default constructor is equivalent to
<span class='texttt'>gslice(0, valarray&lt;size_t&gt;(), valarray&lt;size_t&gt;())</span>.
The constructor with arguments builds a
<span class='texttt'>gslice</span>
based on a specification of start, lengths, and strides, as explained
in the previous section.
</p></div></div></div><div id='gslice.access'><h4 ><a class='secnum' href='#gslice.access' style='min-width:118pt'>26.7.6.3</a> <span class='texttt'>gslice</span> access functions <a class='abbr_ref' href='gslice.access'>[gslice.access]</a></h4><p ><span class='indexparent'><a class='index' id='start,gslice'></a></span><span class='indexparent'><a class='index' id='gslice,start'></a></span><span class='indexparent'><a class='index' id='size,gslice'></a></span><span class='indexparent'><a class='index' id='gslice,size'></a></span><span class='indexparent'><a class='index' id='stride,gslice'></a></span><span class='indexparent'><a class='index' id='gslice,stride'></a></span><code class='itemdecl'>
size_t           start()  const;
valarray&lt;size_t&gt; size() const;
valarray&lt;size_t&gt; stride() const;
</code></p><div class='itemdescr'></div><div class='para' id='gslice.access-1'><div class='marginalizedparent'><a class='marginalized' href='#gslice.access-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> The representation of the
start, lengths, or strides specified for the <span class='texttt'>gslice</span>.</p></div></div><div class='para' id='gslice.access-2'><div class='marginalizedparent'><a class='marginalized' href='#gslice.access-2'>2</a></div><div class='itemdescr'><p ><i>Complexity:</i> <span class='texttt'>start()</span> is constant time. <span class='texttt'>size()</span> and <span class='texttt'>stride()</span>
are linear in the number of strides.
</p></div></div></div></div><div id='template.gslice.array'><h3 ><a class='secnum' href='#template.gslice.array' style='min-width:103pt'>26.7.7</a> Class template <span class='texttt'>gslice_array</span> <a class='abbr_ref' href='template.gslice.array'>[template.gslice.array]</a></h3><div id='template.gslice.array.overview'><h4 ><a class='secnum' href='#template.gslice.array.overview' style='min-width:118pt'>26.7.7.1</a> Class template <span class='texttt'>gslice_array</span> overview <a class='abbr_ref' href='template.gslice.array.overview'>[template.gslice.array.overview]</a></h4><p ><span class='indexparent'><a class='index' id='gslice_array'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; class gslice_array {
  public:
    using value_type = T;

    void operator=  (const valarray&lt;T&gt;&amp;) const;
    void operator*= (const valarray&lt;T&gt;&amp;) const;
    void operator/= (const valarray&lt;T&gt;&amp;) const;
    void operator%= (const valarray&lt;T&gt;&amp;) const;
    void operator+= (const valarray&lt;T&gt;&amp;) const;
    void operator-= (const valarray&lt;T&gt;&amp;) const;
    void operator^= (const valarray&lt;T&gt;&amp;) const;
    void operator&amp;= (const valarray&lt;T&gt;&amp;) const;
    void operator|= (const valarray&lt;T&gt;&amp;) const;
    void operator&lt;&lt;=(const valarray&lt;T&gt;&amp;) const;
    void operator&gt;&gt;=(const valarray&lt;T&gt;&amp;) const;

    gslice_array(const gslice_array&amp;);
    ~gslice_array();
    const gslice_array&amp; operator=(const gslice_array&amp;) const;
    void operator=(const T&amp;) const;

    gslice_array() = delete;      <span class='comment'>// as implied by declaring copy constructor above
</span>  };
}
</pre><div class='para' id='template.gslice.array.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#template.gslice.array.overview-1'>1</a></div><p >This template is a helper template used by the
<span class='texttt'>slice</span>
subscript operator</p><p ><span class='indexparent'><a class='index' id='gslice_array'></a></span><span class='indexparent'><a class='index' id='valarray'></a></span><code class='itemdecl'>
gslice_array&lt;T&gt; valarray&lt;T&gt;::operator[](const gslice&amp;);
</code></p></div><div class='itemdescr'></div><div class='para' id='template.gslice.array.overview-2'><div class='marginalizedparent'><a class='marginalized' href='#template.gslice.array.overview-2'>2</a></div><div class='itemdescr'><p >It has reference semantics to a subset of an array specified by a
<span class='texttt'>gslice</span>
object.</p></div></div><div class='para' id='template.gslice.array.overview-3'><div class='marginalizedparent'><a class='marginalized' href='#template.gslice.array.overview-3'>3</a></div><div class='itemdescr'><p >Thus, the expression
<span class='texttt'>a[gslice(1, length, stride)] = b</span>
has the effect of assigning the elements of
<span class='texttt'>b</span>
to a
generalized slice of the elements in
<span class='texttt'>a</span>.
</p></div></div></div><div id='gslice.array.assign'><h4 ><a class='secnum' href='#gslice.array.assign' style='min-width:118pt'>26.7.7.2</a> <span class='texttt'>gslice_array</span> assignment <a class='abbr_ref' href='gslice.array.assign'>[gslice.array.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,gslice_array'></a></span><span class='indexparent'><a class='index' id='gslice_array,operator='></a></span><code class='itemdecl'>
void operator=(const valarray&lt;T&gt;&amp;) const;
const gslice_array&amp; operator=(const gslice_array&amp;) const;
</code></p><div class='itemdescr'></div><div class='para' id='gslice.array.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#gslice.array.assign-1'>1</a></div><div class='itemdescr'><p >These assignment operators have reference semantics, assigning the values
of the argument array elements to selected elements of the
<span class='texttt'>valarray&lt;T&gt;</span>
object to which the
<span class='texttt'>gslice_array</span>
refers.
</p></div></div></div><div id='gslice.array.comp.assign'><h4 ><a class='secnum' href='#gslice.array.comp.assign' style='min-width:118pt'>26.7.7.3</a> <span class='texttt'>gslice_array</span> compound assignment <a class='abbr_ref' href='gslice.array.comp.assign'>[gslice.array.comp.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator*=,gslice_array'></a></span><span class='indexparent'><a class='index' id='gslice_array,operator*='></a></span><span class='indexparent'><a class='index' id='operator/=,gslice_array'></a></span><span class='indexparent'><a class='index' id='gslice_array,operator/='></a></span><span class='indexparent'><a class='index' id='operator%=,gslice_array'></a></span><span class='indexparent'><a class='index' id='gslice_array,operator%='></a></span><span class='indexparent'><a class='index' id='operator+=,gslice_array'></a></span><span class='indexparent'><a class='index' id='gslice_array,operator+='></a></span><span class='indexparent'><a class='index' id='operator-=,gslice_array'></a></span><span class='indexparent'><a class='index' id='gslice_array,operator-='></a></span><span class='indexparent'><a class='index' id='operator^=,gslice_array'></a></span><span class='indexparent'><a class='index' id='gslice_array,operator^='></a></span><span class='indexparent'><a class='index' id='operator&=,gslice_array'></a></span><span class='indexparent'><a class='index' id='gslice_array,operator&='></a></span><span class='indexparent'><a class='index' id='operator|=,gslice_array'></a></span><span class='indexparent'><a class='index' id='gslice_array,operator|='></a></span><span class='indexparent'><a class='index' id='operator<<=,gslice_array'></a></span><span class='indexparent'><a class='index' id='gslice_array,operator<<='></a></span><span class='indexparent'><a class='index' id='operator>>=,gslice_array'></a></span><span class='indexparent'><a class='index' id='gslice_array,operator>>='></a></span><code class='itemdecl'>
void operator*= (const valarray&lt;T&gt;&amp;) const;
void operator/= (const valarray&lt;T&gt;&amp;) const;
void operator%= (const valarray&lt;T&gt;&amp;) const;
void operator+= (const valarray&lt;T&gt;&amp;) const;
void operator-= (const valarray&lt;T&gt;&amp;) const;
void operator^= (const valarray&lt;T&gt;&amp;) const;
void operator&amp;= (const valarray&lt;T&gt;&amp;) const;
void operator|= (const valarray&lt;T&gt;&amp;) const;
void operator&lt;&lt;=(const valarray&lt;T&gt;&amp;) const;
void operator&gt;&gt;=(const valarray&lt;T&gt;&amp;) const;
</code></p><div class='itemdescr'></div><div class='para' id='gslice.array.comp.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#gslice.array.comp.assign-1'>1</a></div><div class='itemdescr'><p >These compound assignments have reference semantics, applying the
indicated operation to the elements of the argument array and selected
elements of the
<span class='texttt'>valarray&lt;T&gt;</span>
object to which the
<span class='texttt'>gslice_array</span>
object refers.
</p></div></div></div><div id='gslice.array.fill'><h4 ><a class='secnum' href='#gslice.array.fill' style='min-width:118pt'>26.7.7.4</a> <span class='texttt'>gslice_array</span> fill function <a class='abbr_ref' href='gslice.array.fill'>[gslice.array.fill]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,gslice_array'></a></span><span class='indexparent'><a class='index' id='gslice_array,operator='></a></span><code class='itemdecl'>
void operator=(const T&amp;) const;
</code></p><div class='itemdescr'></div><div class='para' id='gslice.array.fill-1'><div class='marginalizedparent'><a class='marginalized' href='#gslice.array.fill-1'>1</a></div><div class='itemdescr'><p >This function has reference semantics, assigning the value of its argument
to the elements of the
<span class='texttt'>valarray&lt;T&gt;</span>
object to which the
<span class='texttt'>gslice_array</span>
object refers.
</p></div></div></div></div><div id='template.mask.array'><h3 ><a class='secnum' href='#template.mask.array' style='min-width:103pt'>26.7.8</a> Class template <span class='texttt'>mask_array</span> <a class='abbr_ref' href='template.mask.array'>[template.mask.array]</a></h3><div id='template.mask.array.overview'><h4 ><a class='secnum' href='#template.mask.array.overview' style='min-width:118pt'>26.7.8.1</a> Class template <span class='texttt'>mask_array</span> overview <a class='abbr_ref' href='template.mask.array.overview'>[template.mask.array.overview]</a></h4><p ><span class='indexparent'><a class='index' id='mask_array'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; class mask_array {
  public:
    using value_type = T;

    void operator=  (const valarray&lt;T&gt;&amp;) const;
    void operator*= (const valarray&lt;T&gt;&amp;) const;
    void operator/= (const valarray&lt;T&gt;&amp;) const;
    void operator%= (const valarray&lt;T&gt;&amp;) const;
    void operator+= (const valarray&lt;T&gt;&amp;) const;
    void operator-= (const valarray&lt;T&gt;&amp;) const;
    void operator^= (const valarray&lt;T&gt;&amp;) const;
    void operator&amp;= (const valarray&lt;T&gt;&amp;) const;
    void operator|= (const valarray&lt;T&gt;&amp;) const;
    void operator&lt;&lt;=(const valarray&lt;T&gt;&amp;) const;
    void operator&gt;&gt;=(const valarray&lt;T&gt;&amp;) const;

    mask_array(const mask_array&amp;);
   ~mask_array();
    const mask_array&amp; operator=(const mask_array&amp;) const;
    void operator=(const T&amp;) const;

    mask_array() = delete;        <span class='comment'>// as implied by declaring copy constructor above
</span>  };
}
</pre><div class='para' id='template.mask.array.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#template.mask.array.overview-1'>1</a></div><p >This template is a helper template used by the mask subscript operator:</p><p ><span class='indexparent'><a class='index' id='operator[],mask_array'></a></span><span class='indexparent'><a class='index' id='mask_array,operator[]'></a></span><code class='itemdecl'>
mask_array&lt;T&gt; valarray&lt;T&gt;::operator[](const valarray&lt;bool&gt;&amp;).
</code></p></div><div class='itemdescr'></div><div class='para' id='template.mask.array.overview-2'><div class='marginalizedparent'><a class='marginalized' href='#template.mask.array.overview-2'>2</a></div><div class='itemdescr'><p >It has reference semantics to a subset of an array specified by a boolean mask.
Thus, the expression
<span class='texttt'>a[mask] = b;</span>
has the effect of assigning the elements of
<span class='texttt'>b</span>
to the masked
elements in
<span class='texttt'>a</span>
(those for which the corresponding element
in
<span class='texttt'>mask</span>
is
<span class='texttt'>true</span>.)
</p></div></div></div><div id='mask.array.assign'><h4 ><a class='secnum' href='#mask.array.assign' style='min-width:118pt'>26.7.8.2</a> <span class='texttt'>mask_array</span> assignment <a class='abbr_ref' href='mask.array.assign'>[mask.array.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,mask_array'></a></span><span class='indexparent'><a class='index' id='mask_array,operator='></a></span><code class='itemdecl'>
void operator=(const valarray&lt;T&gt;&amp;) const;
const mask_array&amp; operator=(const mask_array&amp;) const;
</code></p><div class='itemdescr'></div><div class='para' id='mask.array.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#mask.array.assign-1'>1</a></div><div class='itemdescr'><p >These assignment operators have reference semantics, assigning the values
of the argument array elements to selected elements of the
<span class='texttt'>valarray&lt;T&gt;</span>
object to which it refers.
</p></div></div></div><div id='mask.array.comp.assign'><h4 ><a class='secnum' href='#mask.array.comp.assign' style='min-width:118pt'>26.7.8.3</a> <span class='texttt'>mask_array</span> compound assignment <a class='abbr_ref' href='mask.array.comp.assign'>[mask.array.comp.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator*=,mask_array'></a></span><span class='indexparent'><a class='index' id='mask_array,operator*='></a></span><span class='indexparent'><a class='index' id='operator/=,mask_array'></a></span><span class='indexparent'><a class='index' id='mask_array,operator/='></a></span><span class='indexparent'><a class='index' id='operator%=,mask_array'></a></span><span class='indexparent'><a class='index' id='mask_array,operator%='></a></span><span class='indexparent'><a class='index' id='operator+=,mask_array'></a></span><span class='indexparent'><a class='index' id='mask_array,operator+='></a></span><span class='indexparent'><a class='index' id='operator-=,mask_array'></a></span><span class='indexparent'><a class='index' id='mask_array,operator-='></a></span><span class='indexparent'><a class='index' id='operator^=,mask_array'></a></span><span class='indexparent'><a class='index' id='mask_array,operator^='></a></span><span class='indexparent'><a class='index' id='operator&=,mask_array'></a></span><span class='indexparent'><a class='index' id='mask_array,operator&='></a></span><span class='indexparent'><a class='index' id='operator|=,mask_array'></a></span><span class='indexparent'><a class='index' id='mask_array,operator|='></a></span><span class='indexparent'><a class='index' id='operator<<=,mask_array'></a></span><span class='indexparent'><a class='index' id='mask_array,operator<<='></a></span><span class='indexparent'><a class='index' id='operator>>=,mask_array'></a></span><span class='indexparent'><a class='index' id='mask_array,operator>>='></a></span><code class='itemdecl'>
void operator*= (const valarray&lt;T&gt;&amp;) const;
void operator/= (const valarray&lt;T&gt;&amp;) const;
void operator%= (const valarray&lt;T&gt;&amp;) const;
void operator+= (const valarray&lt;T&gt;&amp;) const;
void operator-= (const valarray&lt;T&gt;&amp;) const;
void operator^= (const valarray&lt;T&gt;&amp;) const;
void operator&amp;= (const valarray&lt;T&gt;&amp;) const;
void operator|= (const valarray&lt;T&gt;&amp;) const;
void operator&lt;&lt;=(const valarray&lt;T&gt;&amp;) const;
void operator&gt;&gt;=(const valarray&lt;T&gt;&amp;) const;
</code></p><div class='itemdescr'></div><div class='para' id='mask.array.comp.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#mask.array.comp.assign-1'>1</a></div><div class='itemdescr'><p >These compound assignments have reference semantics, applying the
indicated operation to the elements of the argument array and selected elements
of the
<span class='texttt'>valarray&lt;T&gt;</span>
object to which the mask object refers.
</p></div></div></div><div id='mask.array.fill'><h4 ><a class='secnum' href='#mask.array.fill' style='min-width:118pt'>26.7.8.4</a> <span class='texttt'>mask_array</span> fill function <a class='abbr_ref' href='mask.array.fill'>[mask.array.fill]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,mask_array'></a></span><span class='indexparent'><a class='index' id='mask_array,operator='></a></span><code class='itemdecl'>
void operator=(const T&amp;) const;
</code></p><div class='itemdescr'></div><div class='para' id='mask.array.fill-1'><div class='marginalizedparent'><a class='marginalized' href='#mask.array.fill-1'>1</a></div><div class='itemdescr'><p >This function has reference semantics, assigning the value of its
argument to the elements of the
<span class='texttt'>valarray&lt;T&gt;</span>
object to which the
<span class='texttt'>mask_array</span>
object refers.
</p></div></div></div></div><div id='template.indirect.array'><h3 ><a class='secnum' href='#template.indirect.array' style='min-width:103pt'>26.7.9</a> Class template <span class='texttt'>indirect_array</span> <a class='abbr_ref' href='template.indirect.array'>[template.indirect.array]</a></h3><div id='template.indirect.array.overview'><h4 ><a class='secnum' href='#template.indirect.array.overview' style='min-width:118pt'>26.7.9.1</a> Class template <span class='texttt'>indirect_array</span> overview <a class='abbr_ref' href='template.indirect.array.overview'>[template.indirect.array.overview]</a></h4><p ><span class='indexparent'><a class='index' id='indirect_array'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; class indirect_array {
  public:
    using value_type = T;

    void operator=  (const valarray&lt;T&gt;&amp;) const;
    void operator*= (const valarray&lt;T&gt;&amp;) const;
    void operator/= (const valarray&lt;T&gt;&amp;) const;
    void operator%= (const valarray&lt;T&gt;&amp;) const;
    void operator+= (const valarray&lt;T&gt;&amp;) const;
    void operator-= (const valarray&lt;T&gt;&amp;) const;
    void operator^= (const valarray&lt;T&gt;&amp;) const;
    void operator&amp;= (const valarray&lt;T&gt;&amp;) const;
    void operator|= (const valarray&lt;T&gt;&amp;) const;
    void operator&lt;&lt;=(const valarray&lt;T&gt;&amp;) const;
    void operator&gt;&gt;=(const valarray&lt;T&gt;&amp;) const;

    indirect_array(const indirect_array&amp;);
   ~indirect_array();
    const indirect_array&amp; operator=(const indirect_array&amp;) const;
    void operator=(const T&amp;) const;

    indirect_array() = delete;        <span class='comment'>// as implied by declaring copy constructor above
</span>  };
}
</pre><div class='para' id='template.indirect.array.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#template.indirect.array.overview-1'>1</a></div><p >This template is a helper template used by the indirect subscript operator</p><p ><span class='indexparent'><a class='index' id='operator[],indirect_array'></a></span><span class='indexparent'><a class='index' id='indirect_array,operator[]'></a></span><code class='itemdecl'>
indirect_array&lt;T&gt; valarray&lt;T&gt;::operator[](const valarray&lt;size_t&gt;&amp;).
</code></p></div><div class='itemdescr'></div><div class='para' id='template.indirect.array.overview-2'><div class='marginalizedparent'><a class='marginalized' href='#template.indirect.array.overview-2'>2</a></div><div class='itemdescr'><p >It has reference semantics to a subset of an array specified by an
<span class='texttt'>indirect_array</span>.
Thus the expression
<span class='texttt'>a[<span class='discretionary'></span>indirect] = b;</span>
has the effect of assigning the elements of
<span class='texttt'>b</span>
to the elements in
<span class='texttt'>a</span>
whose indices appear in
<span class='texttt'>indirect</span>.
</p></div></div></div><div id='indirect.array.assign'><h4 ><a class='secnum' href='#indirect.array.assign' style='min-width:118pt'>26.7.9.2</a> <span class='texttt'>indirect_array</span> assignment <a class='abbr_ref' href='indirect.array.assign'>[indirect.array.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,indirect_array'></a></span><span class='indexparent'><a class='index' id='indirect_array,operator='></a></span><code class='itemdecl'>
void operator=(const valarray&lt;T&gt;&amp;) const;
const indirect_array&amp; operator=(const indirect_array&amp;) const;
</code></p><div class='itemdescr'></div><div class='para' id='indirect.array.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#indirect.array.assign-1'>1</a></div><div class='itemdescr'><p >These assignment operators have reference semantics, assigning the values
of the argument array elements to selected elements of the
<span class='texttt'>valarray&lt;T&gt;</span>
object to which it refers.</p></div></div><div class='para' id='indirect.array.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#indirect.array.assign-2'>2</a></div><div class='itemdescr'><p >If the
<span class='texttt'>indirect_array</span>
specifies an element in the
<span class='texttt'>valarray&lt;T&gt;</span>
object to which it refers more than once, the behavior is undefined.
<span class='indexparent'><a class='index' id='undefined'></a></span>
</p></div></div><div class='para' id='indirect.array.assign-3'><div class='marginalizedparent'><a class='marginalized' href='#indirect.array.assign-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
int addr[] = {2, 3, 1, 4, 4};
valarray&lt;size_t&gt; indirect(addr, 5);
valarray&lt;double&gt; a(0., 10), b(1., 5);
a[indirect] = b;
</pre><p >results in undefined behavior since element 4 is specified twice in the
indirection.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div></div><div id='indirect.array.comp.assign'><h4 ><a class='secnum' href='#indirect.array.comp.assign' style='min-width:118pt'>26.7.9.3</a> <span class='texttt'>indirect_array</span> compound assignment <a class='abbr_ref' href='indirect.array.comp.assign'>[indirect.array.comp.assign]</a></h4><p ><span class='indexparent'><a class='index' id='operator*=,indirect_array'></a></span><span class='indexparent'><a class='index' id='indirect_array,operator*='></a></span><span class='indexparent'><a class='index' id='operator/=,indirect_array'></a></span><span class='indexparent'><a class='index' id='indirect_array,operator/='></a></span><span class='indexparent'><a class='index' id='operator%=,indirect_array'></a></span><span class='indexparent'><a class='index' id='indirect_array,operator%='></a></span><span class='indexparent'><a class='index' id='operator+=,indirect_array'></a></span><span class='indexparent'><a class='index' id='indirect_array,operator+='></a></span><span class='indexparent'><a class='index' id='operator-=,indirect_array'></a></span><span class='indexparent'><a class='index' id='indirect_array,operator-='></a></span><span class='indexparent'><a class='index' id='operator^=,indirect_array'></a></span><span class='indexparent'><a class='index' id='indirect_array,operator^='></a></span><span class='indexparent'><a class='index' id='operator&=,indirect_array'></a></span><span class='indexparent'><a class='index' id='indirect_array,operator&='></a></span><span class='indexparent'><a class='index' id='operator|=,indirect_array'></a></span><span class='indexparent'><a class='index' id='indirect_array,operator|='></a></span><span class='indexparent'><a class='index' id='operator<<=,indirect_array'></a></span><span class='indexparent'><a class='index' id='indirect_array,operator<<='></a></span><span class='indexparent'><a class='index' id='operator>>=,indirect_array'></a></span><span class='indexparent'><a class='index' id='indirect_array,operator>>='></a></span><code class='itemdecl'>
void operator*= (const valarray&lt;T&gt;&amp;) const;
void operator/= (const valarray&lt;T&gt;&amp;) const;
void operator%= (const valarray&lt;T&gt;&amp;) const;
void operator+= (const valarray&lt;T&gt;&amp;) const;
void operator-= (const valarray&lt;T&gt;&amp;) const;
void operator^= (const valarray&lt;T&gt;&amp;) const;
void operator&amp;= (const valarray&lt;T&gt;&amp;) const;
void operator|= (const valarray&lt;T&gt;&amp;) const;
void operator&lt;&lt;=(const valarray&lt;T&gt;&amp;) const;
void operator&gt;&gt;=(const valarray&lt;T&gt;&amp;) const;
</code></p><div class='itemdescr'></div><div class='para' id='indirect.array.comp.assign-1'><div class='marginalizedparent'><a class='marginalized' href='#indirect.array.comp.assign-1'>1</a></div><div class='itemdescr'><p >These compound assignments have reference semantics, applying the indicated
operation to the elements of the argument array and selected elements of the
<span class='texttt'>valarray&lt;T&gt;</span>
object to which the
<span class='texttt'>indirect_array</span>
object refers.</p></div></div><div class='para' id='indirect.array.comp.assign-2'><div class='marginalizedparent'><a class='marginalized' href='#indirect.array.comp.assign-2'>2</a></div><div class='itemdescr'><p >If the
<span class='texttt'>indirect_array</span>
specifies an element in the
<span class='texttt'>valarray&lt;T&gt;</span>
object to which it refers more than once,
the behavior is undefined.
<span class='indexparent'><a class='index' id='undefined'></a></span>
</p></div></div></div><div id='indirect.array.fill'><h4 ><a class='secnum' href='#indirect.array.fill' style='min-width:118pt'>26.7.9.4</a> <span class='texttt'>indirect_array</span> fill function <a class='abbr_ref' href='indirect.array.fill'>[indirect.array.fill]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,indirect_array'></a></span><span class='indexparent'><a class='index' id='indirect_array,operator='></a></span><code class='itemdecl'>
void operator=(const T&amp;) const;
</code></p><div class='itemdescr'></div><div class='para' id='indirect.array.fill-1'><div class='marginalizedparent'><a class='marginalized' href='#indirect.array.fill-1'>1</a></div><div class='itemdescr'><p >This function has reference semantics, assigning the value of its argument
to the elements of the
<span class='texttt'>valarray&lt;T&gt;</span>
object to which the
<span class='texttt'>indirect_array</span>
object refers.
</p></div></div></div></div><div id='valarray.range'><h3 ><a class='secnum' href='#valarray.range' style='min-width:103pt'>26.7.10</a> valarray range access <a class='abbr_ref' href='valarray.range'>[valarray.range]</a></h3><div class='para' id='valarray.range-1'><div class='marginalizedparent'><a class='marginalized' href='#valarray.range-1'>1</a></div><p >In the <span class='texttt'>begin</span> and <span class='texttt'>end</span> function templates that follow, <i><span class='texttt'>unspecified</span></i>1
is a type that meets the requirements of a mutable random access
iterator (<a href='random.access.iterators'>[random.access.iterators]</a>)
and of a contiguous iterator (<a href='iterator.requirements.general'>[iterator.requirements.general]</a>)
whose <span class='texttt'>value_type</span> is the template
parameter <span class='texttt'>T</span> and whose <span class='texttt'>reference</span> type is <span class='texttt'>T&amp;</span>. <i><span class='texttt'>unspecified</span></i>2 is a
type that meets the requirements of a constant random access
iterator (<a href='random.access.iterators'>[random.access.iterators]</a>)
and of a contiguous iterator (<a href='iterator.requirements.general'>[iterator.requirements.general]</a>)
whose <span class='texttt'>value_type</span> is the template
parameter <span class='texttt'>T</span> and whose <span class='texttt'>reference</span> type is <span class='texttt'>const T&amp;</span>.</p></div><div class='para' id='valarray.range-2'><div class='marginalizedparent'><a class='marginalized' href='#valarray.range-2'>2</a></div><p >The iterators returned by <span class='texttt'>begin</span> and <span class='texttt'>end</span> for an array
are guaranteed to be valid until the member function
<span class='texttt'>resize(size_t, T)</span> (<a href='valarray.members'>[valarray.members]</a>) is called for that
array or until the lifetime of that array ends, whichever happens
first.</p><p ><span class='indexparent'><a class='index' id='begin,valarray'></a></span><code class='itemdecl'>
template &lt;class T&gt; <i><span class='texttt'>unspecified</span></i>1 begin(valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; <i><span class='texttt'>unspecified</span></i>2 begin(const valarray&lt;T&gt;&amp; v);
</code></p></div><div class='itemdescr'></div><div class='para' id='valarray.range-3'><div class='marginalizedparent'><a class='marginalized' href='#valarray.range-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> An iterator referencing the first value in the numeric array.
</p></div></div><p ><span class='indexparent'><a class='index' id='end,valarray'></a></span><code class='itemdecl'>
template &lt;class T&gt; <i><span class='texttt'>unspecified</span></i>1 end(valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; <i><span class='texttt'>unspecified</span></i>2 end(const valarray&lt;T&gt;&amp; v);
</code></p><div class='itemdescr'></div><div class='para' id='valarray.range-4'><div class='marginalizedparent'><a class='marginalized' href='#valarray.range-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> An iterator referencing one past the last value in the numeric array.
</p></div></div></div></div></div></body></html>