<!DOCTYPE html><html lang='en'><head><title>[basic.stc.dynamic]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>3.7</a> Storage duration <a class='abbr_ref' href='basic.stc#dynamic'>[basic.stc]</a></h2><div id='basic.stc.dynamic'><h3 ><a class='secnum' style='min-width:103pt'>3.7.4</a> Dynamic storage duration <a class='abbr_ref'>[basic.stc.dynamic]</a></h3><p ><span class='indexparent'><a class='index' id='storage_duration,dynamic'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L2911'>#</a></div><p >Objects can be created dynamically during <a href='intro.execution'>program
execution</a>, using
<span class='indexparent'><a class='index' id='new'></a></span><i ><a href='expr.new#nt:new-expression'>new-expression</a></i><span class='textit'>s</span> (<a href='expr.new'>[expr.new]</a>), and destroyed using
<span class='indexparent'><a class='index' id='delete'></a></span><i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i><span class='textit'>s</span> (<a href='expr.delete'>[expr.delete]</a>). A C++ implementation
provides access to, and management of, dynamic storage via the global
<a class='hidden_link' href='#def:allocation_functions' id='def:allocation_functions'><i>allocation functions</i></a> <span class='texttt'>operator new</span> and <span class='texttt'>operator
new[]</span> and the global <a class='hidden_link' href='#def:deallocation_functions' id='def:deallocation_functions'><i>deallocation functions</i></a> <span class='texttt'>operator
delete</span> and <span class='texttt'>operator delete[]</span>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
The non-allocating forms described in <a href='new.delete.placement'>[new.delete.placement]</a>
do not perform allocation or deallocation.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L2927'>#</a></div><p >The library provides default definitions for the global allocation and
deallocation functions. Some global allocation and deallocation
functions are replaceable (<a href='new.delete'>[new.delete]</a>). A C++ program shall
provide at most one definition of a replaceable allocation or
deallocation function. Any such function definition replaces the default
version provided in the library (<a href='replacement.functions'>[replacement.functions]</a>). The
following allocation and deallocation functions (<a href='support.dynamic'>[support.dynamic]</a>)
are implicitly declared in global scope in each translation unit of a
program.</p><p ><pre class='codeblock'>
void* operator new(std::size_t);
void* operator new(std::size_t, std::align_val_t);

void operator delete(void*) noexcept;
void operator delete(void*, std::size_t) noexcept;
void operator delete(void*, std::align_val_t) noexcept;
void operator delete(void*, std::size_t, std::align_val_t) noexcept;

void* operator new[](std::size_t);
void* operator new[](std::size_t, std::align_val_t);

void operator delete[](void*) noexcept;
void operator delete[](void*, std::size_t) noexcept;
void operator delete[](void*, std::align_val_t) noexcept;
void operator delete[](void*, std::size_t, std::align_val_t) noexcept;</pre></p><p >These implicit declarations introduce only the function names
<span class='texttt'>operator</span> <span class='texttt'>new</span>, <span class='texttt'>operator</span> <span class='texttt'>new[]</span>,
<span class='texttt'>operator</span> <span class='texttt'>delete</span>, and <span class='texttt'>operator</span>
<span class='texttt'>delete[]</span>. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  The implicit declarations do not introduce
the names <span class='texttt'>std</span>,
<span class='texttt'>std&#x200b;::&#x200b;size_&shy;t</span>,
<span class='texttt'>std&#x200b;::&#x200b;align_&shy;val_&shy;t</span>,
or any other names that the library uses to
declare these names. Thus, a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>,
<i ><a href='expr.delete#nt:delete-expression'>delete-expression</a></i> or function call that refers to one of
these functions without including the header <span class='texttt'>&lt;new&gt;</span> is
well-formed. However, referring to <span class='texttt'>std</span>
or <span class='texttt'>std&#x200b;::&#x200b;size_&shy;t</span>
or <span class='texttt'>std&#x200b;::&#x200b;align_&shy;val_&shy;t</span>
is ill-formed unless the name has been declared
by including the appropriate header. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]  Allocation and/or
deallocation functions may also be declared and defined for any
class (<a href='class.free'>[class.free]</a>).</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L2975'>#</a></div><p >Any allocation and/or deallocation functions defined in a C++ program,
including the default versions in the library, shall conform to the
semantics specified in <a href='basic.stc.dynamic.allocation'>[basic.stc.dynamic.allocation]</a>
and <a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>.</p></div><div id='allocation'><h4 ><a class='secnum' href='#allocation' style='min-width:118pt'>3.7.4.1</a> Allocation functions <a class='abbr_ref' href='basic.stc.dynamic.allocation'>[basic.stc.dynamic.allocation]</a></h4><div class='para' id='allocation-1'><div class='marginalizedparent'><a class='marginalized' href='#allocation-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L2983'>#</a></div><p ><span class='indexparent'><a class='index' id='function,allocation'></a></span>An allocation function shall be a class member function or a global
function; a program is ill-formed if an allocation function is declared
in a namespace scope other than global scope or declared static in
global scope. The return type shall be <span class='texttt'>void*</span>. The first
parameter shall have type <span class='texttt'>std&#x200b;::&#x200b;size_&shy;t</span> (<a href='support.types'>[support.types]</a>). The
first parameter shall not have an associated <a href='dcl.fct.default'>default
argument</a>. The value of the first parameter shall
be interpreted as the requested size of the allocation. An allocation
function can be a function template. Such a template shall declare its
return type and first parameter as specified above (that is, template
parameter types shall not be used in the return type and first parameter
type). Template allocation functions shall have two or more parameters.</p></div><div class='para' id='allocation-2'><div class='marginalizedparent'><a class='marginalized' href='#allocation-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L2998'>#</a></div><p >The allocation function attempts to allocate the requested amount of
storage. If it is successful, it shall return the address of the start
of a block of storage whose length in bytes shall be at least as large
as the requested size. There are no constraints on the contents of the
allocated storage on return from the allocation function. The order,
contiguity, and initial value of storage allocated by successive calls
to an allocation function are unspecified. The pointer returned shall be
suitably aligned so that it can be converted to a pointer to any
suitable complete object type (<a href='new.delete.single'>[new.delete.single]</a>)
and then used to access the object or array in the
storage allocated (until the storage is explicitly deallocated by a call
to a corresponding deallocation function). Even if the size of the space
requested is zero, the request can fail. If the request succeeds, the
value returned shall be a non-null pointer value (<a href='conv.ptr'>[conv.ptr]</a>)
<span class='texttt'>p0</span> different from any previously returned value <span class='texttt'>p1</span>,
unless that value <span class='texttt'>p1</span> was subsequently passed to an
<span class='texttt'>operator</span> <span class='texttt'>delete</span>.
Furthermore, for the library allocation functions
in <a href='new.delete.single'>[new.delete.single]</a> and <a href='new.delete.array'>[new.delete.array]</a>,
<span class='texttt'>p0</span> shall represent the address of a block of storage disjoint from the storage
for any other object accessible to the caller.
The effect of indirecting through a pointer
returned as a request for zero size is undefined.<a class='footnotenum' href='#footnote-38'>38</a></p></div><div class='para' id='allocation-3'><div class='marginalizedparent'><a class='marginalized' href='#allocation-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L3027'>#</a></div><p >An allocation function that fails to allocate storage can invoke the
currently installed new-handler function (<a href='new.handler'>[new.handler]</a>), if any.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
<span class='indexparent'><a class='index' id='new_handler'></a></span>A program-supplied allocation function can obtain the address of the
currently installed <span class='texttt'>new_&shy;handler</span> using the
<span class='texttt'>std&#x200b;::&#x200b;get_&shy;new_&shy;handler</span> function (<a href='set.new.handler'>[set.new.handler]</a>). <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
If an allocation function that has a non-throwing
<a href='except.spec'>exception specification</a>
fails to allocate storage, it shall return a null pointer. Any other
allocation function that fails to allocate storage shall indicate
failure only by <a href='except.throw'>throwing an exception</a> of a type
that would match a <a href='except.handle'>handler</a> of type
<a href='bad.alloc'><span class='texttt'>std&#x200b;::&#x200b;bad_&shy;alloc</span></a>.</p></div><div class='para' id='allocation-4'><div class='marginalizedparent'><a class='marginalized' href='#allocation-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L3043'>#</a></div><p >A global allocation function is only called as the result of a <a href='expr.new'>new
expression</a>, or called directly using the <a href='expr.call'>function call</a>
syntax, or called indirectly through calls to the
functions in the C++ standard library. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  In particular, a
global allocation function is not called to allocate storage for objects
with <a href='basic.stc.static'>static storage duration</a>, for objects or references
with <a href='basic.stc.thread'>thread storage duration</a>, for objects of
type <a href='expr.typeid'><span class='texttt'>std&#x200b;::&#x200b;type_&shy;info</span></a>, or for an
<a href='except.throw'>exception object</a>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='footnote' id='footnote-38'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-38'>38)</a></div><p >The intent is
to have <span class='texttt'>operator new()</span> implementable by
calling <span class='texttt'>std&#x200b;::&#x200b;malloc()</span> or <span class='texttt'>std&#x200b;::&#x200b;calloc()</span>, so the rules are
substantially the same. C++ differs from C in requiring a zero request
to return a non-null pointer.</p></div></div><div id='deallocation'><h4 ><a class='secnum' href='#deallocation' style='min-width:118pt'>3.7.4.2</a> Deallocation functions <a class='abbr_ref' href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a></h4><div class='para' id='deallocation-1'><div class='marginalizedparent'><a class='marginalized' href='#deallocation-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L3057'>#</a></div><p ><span class='indexparent'><a class='index' id='function,deallocation'></a></span>Deallocation functions shall be class member functions or global
functions; a program is ill-formed if deallocation functions are
declared in a namespace scope other than global scope or declared static
in global scope.</p></div><div class='para' id='deallocation-2'><div class='marginalizedparent'><a class='marginalized' href='#deallocation-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L3064'>#</a></div><p ><span class='indexparent'><a class='index' id='delete,overloading_and'></a></span>Each deallocation function shall return <span class='texttt'>void</span> and its first
parameter shall be <span class='texttt'>void*</span>. A deallocation function may have more
than one parameter.
<span class='indexparent'><a class='index' id='deallocation_function,usual'></a></span>A <a class='hidden_link' href='#def:usual_deallocation_function' id='def:usual_deallocation_function'><i>usual deallocation function</i></a> is a deallocation function that has:
</p><ul class='itemize'><li id='deallocation-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#deallocation-2.1'>(2.1)</a></div><p >exactly one parameter; or
</p></li><li id='deallocation-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#deallocation-2.2'>(2.2)</a></div><p >exactly two parameters,
the type of the second being either
<span class='texttt'>std&#x200b;::&#x200b;align_&shy;val_&shy;t</span> or
<span class='texttt'>std&#x200b;::&#x200b;size_&shy;t</span><a class='footnotenum' href='#footnote-39'>39</a>; or
</p></li><li id='deallocation-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#deallocation-2.3'>(2.3)</a></div><p >exactly three parameters,
the type of the second being <span class='texttt'>std&#x200b;::&#x200b;size_&shy;t</span>
and
the type of the third being <span class='texttt'>std&#x200b;::&#x200b;align_&shy;val_&shy;t</span>.
</p></li></ul><p >A deallocation function may be an instance of a function
template. Neither the first parameter nor the return type shall depend
on a template parameter. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  That is, a deallocation function
template shall have a first parameter of type <span class='texttt'>void*</span> and a return
type of <span class='texttt'>void</span> (as specified above). <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]  A deallocation
function template shall have two or more function parameters. A template
instance is never a usual deallocation function, regardless of its
signature.</p></div><div class='para' id='deallocation-3'><div class='marginalizedparent'><a class='marginalized' href='#deallocation-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L3098'>#</a></div><p >If a deallocation function terminates by throwing an exception, the behavior is undefined.
The value of the first argument supplied to a deallocation function may
be a null pointer value; if so, and if the deallocation function is one
supplied in the standard library, the call has no effect.</p></div><div class='para' id='deallocation-4'><div class='marginalizedparent'><a class='marginalized' href='#deallocation-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L3104'>#</a></div><p >If the argument given to a deallocation function in the standard library
is a pointer that is not the <a href='conv.ptr#def:null_pointer_value'>null pointer value</a>, the
deallocation function shall deallocate the storage referenced by the
pointer, ending the duration of the region of storage.</p></div><div class='footnote' id='footnote-39'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-39'>39)</a></div><p >The global <span class='texttt'>operator delete(void*, std&#x200b;::&#x200b;size_&shy;t)</span>
precludes use of an
allocation function <span class='texttt'>void operator new(std&#x200b;::&#x200b;size_&shy;t, std&#x200b;::&#x200b;size_&shy;t)</span> as a placement
allocation function (<a href='diff.cpp11.basic'>[diff.cpp11.basic]</a>).</p></div></div><div id='safety'><h4 ><a class='secnum' href='#safety' style='min-width:118pt'>3.7.4.3</a> Safely-derived pointers <a class='abbr_ref' href='basic.stc.dynamic.safety'>[basic.stc.dynamic.safety]</a></h4><div class='para' id='safety-1'><div class='marginalizedparent'><a class='marginalized' href='#safety-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L3112'>#</a></div><p ><span class='indexparent'><a class='index' id='pointer,safely-derived'></a></span><span class='indexparent'><a class='index' id='pointer,to_traceable_object'></a></span>A <a class='hidden_link' href='#def:traceable_pointer_object' id='def:traceable_pointer_object'><i>traceable pointer object</i></a> is
</p><ul class='itemize'><li id='safety-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#safety-1.1'>(1.1)</a></div><p >an object of an <a href='basic.compound#def:object_pointer_type'>object pointer type</a>, or
</p></li><li id='safety-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#safety-1.2'>(1.2)</a></div><p >an object of an integral type that is at least as large as <span class='texttt'>std&#x200b;::&#x200b;intptr_&shy;t</span>,
or
</p></li><li id='safety-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#safety-1.3'>(1.3)</a></div><p >a sequence of elements in an array of
<a href='basic.fundamental#def:type,narrow_character'>narrow character type</a>, where the size and alignment of the sequence
match those of some object pointer type.
</p></li></ul></div><div class='para' id='safety-2'><div class='marginalizedparent'><a class='marginalized' href='#safety-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L3125'>#</a></div><p >A pointer value is a <a class='hidden_link' href='#def:safely-derived_pointer' id='def:safely-derived_pointer'><i>safely-derived pointer</i></a> to a dynamic object only if it
has an object pointer type and it is one of the following:
</p><ul class='itemize'><li id='safety-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#safety-2.1'>(2.1)</a></div><p >the value returned by a call to the C++ standard library implementation of
<span class='texttt'>&#x200b;::&#x200b;operator new(std&#x200b;::&#x200b;&#x200b;size_&shy;t)</span> or
<span class='texttt'>&#x200b;::&#x200b;operator new(std&#x200b;::&#x200b;size_&shy;t, std&#x200b;::&#x200b;align_&shy;val_&shy;t)</span>;<a class='footnotenum' href='#footnote-40'>40</a></p></li><li id='safety-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#safety-2.2'>(2.2)</a></div><p >the result of taking the address of an object (or one of its
  subobjects) designated by an lvalue resulting from indirection
  through a safely-derived pointer value;</p></li><li id='safety-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#safety-2.3'>(2.3)</a></div><p >the result of well-defined pointer arithmetic (<a href='expr.add'>[expr.add]</a>) using a safely-derived pointer
value;</p></li><li id='safety-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#safety-2.4'>(2.4)</a></div><p >the result of a well-defined pointer
conversion (<a href='conv.ptr'>[conv.ptr]</a>, <a href='expr.cast'>[expr.cast]</a>) of a safely-derived pointer value;</p></li><li id='safety-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#safety-2.5'>(2.5)</a></div><p >the result of a <span class='texttt'>reinterpret_&shy;cast</span> of a safely-derived pointer value;</p></li><li id='safety-2.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#safety-2.6'>(2.6)</a></div><p >the result of a <span class='texttt'>reinterpret_&shy;cast</span> of an integer representation of a
safely-derived pointer value;</p></li><li id='safety-2.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#safety-2.7'>(2.7)</a></div><p >the value of an object whose value was copied from a traceable pointer object,
where at the time of the copy the source object contained a copy of a safely-derived
pointer value.
</p></li></ul></div><div class='para' id='safety-3'><div class='marginalizedparent'><a class='marginalized' href='#safety-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L3158'>#</a></div><p ><span class='indexparent'><a class='index' id='integer_representation'></a></span><span class='indexparent'><a class='index' id='safely-derived_pointer,integer_representation'></a></span>An integer value is an
<a class='hidden_link' href='#def:pointer,integer_representation_of_safely-derived' id='def:pointer,integer_representation_of_safely-derived'><i>integer representation of a safely-derived pointer</i></a>
only if its type is at least as large as <span class='texttt'>std&#x200b;::&#x200b;intptr_&shy;t</span> and it is one of the
following:</p><ul class='itemize'><li id='safety-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#safety-3.1'>(3.1)</a></div><p >the result of a <span class='texttt'>reinterpret_&shy;cast</span> of a safely-derived pointer value;</p></li><li id='safety-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#safety-3.2'>(3.2)</a></div><p >the result of a valid conversion of an integer representation of a safely-derived
pointer value;</p></li><li id='safety-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#safety-3.3'>(3.3)</a></div><p >the value of an object whose value was copied from a traceable pointer object,
where at the time of the copy the source object contained an integer representation of a
safely-derived pointer value;</p></li><li id='safety-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#safety-3.4'>(3.4)</a></div><p >the result of an additive or bitwise operation, one of whose operands is an
integer representation of a safely-derived pointer value <span class='texttt'>P</span>, if that result
converted by <span class='texttt'>reinterpret_&shy;cast&lt;void*&gt;</span> would compare equal to a safely-derived
pointer computable from <span class='texttt'>reinterpret_&shy;cast&lt;void*&gt;(P)</span>.
</p></li></ul></div><div class='para' id='safety-4'><div class='marginalizedparent'><a class='marginalized' href='#safety-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/44f489bba7c7595077043c7360cf7ff329eeb090/source/basic.tex#L3182'>#</a></div><p >An implementation may have <a class='hidden_link' href='#def:relaxed_pointer_safety' id='def:relaxed_pointer_safety'><i>relaxed pointer safety</i></a>, in which case the
validity of a pointer value does not depend on whether it is a safely-derived
pointer value. Alternatively, an implementation may have <a class='hidden_link' href='#def:strict_pointer_safety' id='def:strict_pointer_safety'><i>strict pointer
safety</i></a>, in which case a pointer value referring to an object with dynamic
storage duration that is not a safely-derived pointer
value is an invalid pointer value unless
the referenced complete object has previously been declared
reachable (<a href='util.dynamic.safety'>[util.dynamic.safety]</a>). [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
The effect of using an invalid pointer value (including passing it to a
deallocation function) is undefined, see <a href='basic.stc.dynamic.deallocation'>[basic.stc.dynamic.deallocation]</a>.
This is true even if the unsafely-derived pointer value might compare equal to
some safely-derived pointer value. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]  It is
<span class='indexparent'><a class='index' id='whether_an_implementation_has_relaxed_or_strict_pointer_safety'></a></span>implementation-defined whether an implementation has relaxed or strict pointer safety.</p></div><div class='footnote' id='footnote-40'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-40'>40)</a></div><p >This section does not impose restrictions
on indirection through pointers to memory not allocated by <span class='texttt'>&#x200b;::&#x200b;operator new</span>. This
maintains the ability of many C++ implementations to use binary libraries and
components written in other languages. In particular, this applies to C binaries,
because indirection through pointers to memory allocated by <span class='texttt'>std&#x200b;::&#x200b;malloc</span> is not restricted.</p></div></div></div></div></body></html>