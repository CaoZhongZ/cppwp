<!DOCTYPE html><html lang='en'><head><title>[class.member.lookup]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>10</a> Derived classes <a class='abbr_ref' href='./#class.derived'>[class.derived]</a></h1><div id='class.member.lookup'><h2 ><a class='secnum' style='min-width:88pt'>10.2</a> Member name lookup <a class='abbr_ref'>[class.member.lookup]</a></h2><p ><span class='indexparent'><a class='index' id='lookup,member_name'></a></span><span class='indexparent'><a class='index' id='ambiguity,base_class_member'></a></span><span class='indexparent'><a class='index' id='ambiguity,member_access'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Member name lookup determines the meaning of a name
(<i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>) in a class scope (<a href='basic.scope.class'>[basic.scope.class]</a>).
Name lookup can result in an <i>ambiguity</i>, in which case the
program is ill-formed. For an <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i>, name lookup
begins in the class scope of <span class='texttt'>this</span>; for a
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i>, name lookup begins in the scope of the
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i>. Name lookup takes place before access
control (<a href='basic.lookup'>[basic.lookup]</a>, Clause <a href='class.access'>[class.access]</a>).</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The following steps define the result of name lookup for a member name
<span class='texttt'>f</span> in a class scope <span class='texttt'>C</span>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The <i>lookup set</i> for <span class='texttt'>f</span> in <span class='texttt'>C</span>, called <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>C</span>)</span>,
consists of two component sets: the <i>declaration set</i>, a set of
members named <span class='texttt'>f</span>; and the <i>subobject set</i>, a set of
subobjects where declarations of these members (possibly including
<i ><a href='namespace.udecl#nt:using-declaration'>using-declarations</a></i>) were found. In the declaration set,
<i ><a href='namespace.udecl#nt:using-declaration'>using-declarations</a></i> are replaced by the
set of designated members that are not hidden or overridden by members of the
derived class (<a href='namespace.udecl'>[namespace.udecl]</a>),
and type declarations (including injected-class-names) are
replaced by the types they designate. <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>C</span>)</span> is calculated as follows:</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >If <span class='texttt'>C</span> contains a declaration of the name <span class='texttt'>f</span>, the
declaration set contains every declaration of <span class='texttt'>f</span> declared in
<span class='texttt'>C</span> that satisfies the requirements of the language construct in
which the lookup occurs.
[&nbsp;<i>Note:</i><span class='space'></span>
Looking up a name in an
<i ><a href='dcl.type.elab#nt:elaborated-type-specifier'>elaborated-type-specifier</a></i> (<a href='basic.lookup.elab'>[basic.lookup.elab]</a>) or
<i ><a href='class.derived#nt:base-specifier'>base-specifier</a></i> (Clause <a href='class.derived'>[class.derived]</a>), for instance,
ignores all non-type declarations, while looking up a name in a
<i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> (<a href='basic.lookup.qual'>[basic.lookup.qual]</a>) ignores
function, variable, and enumerator declarations. As another example,
looking up a name in a
<i ><a href='namespace.udecl#nt:using-declaration'>using-declaration</a></i> (<a href='namespace.udecl'>[namespace.udecl]</a>) includes the
declaration of a class or enumeration that would ordinarily be hidden by
another declaration of that name in the same scope.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
If the resulting declaration set is not empty, the subobject set
contains <span class='texttt'>C</span> itself, and calculation is complete.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >Otherwise (i.e., <span class='texttt'>C</span> does not contain a declaration of <span class='texttt'>f</span>
or the resulting declaration set is empty), <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>C</span>)</span> is initially empty.
If <span class='texttt'>C</span> has base classes, calculate the lookup set for <span class='texttt'>f</span> in
each direct base class subobject <span class='math'><span class='mathalpha'>B</span><sub ><span class='mathalpha'>i</span></sub></span>, and merge each such lookup set
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>B</span><sub ><span class='mathalpha'>i</span></sub>)</span> in turn into <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>C</span>)</span>.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >The following steps define the result of merging lookup set <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>B</span><sub ><span class='mathalpha'>i</span></sub>)</span>
into the intermediate <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>C</span>)</span>:</p><ul ><li ><p >If each of the subobject members of <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>B</span><sub ><span class='mathalpha'>i</span></sub>)</span> is a base class
subobject of at least one of the subobject members of <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>C</span>)</span>, or if
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>B</span><sub ><span class='mathalpha'>i</span></sub>)</span> is empty, <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>C</span>)</span> is unchanged and the merge is complete.
Conversely, if each of the subobject members of <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>C</span>)</span> is a base class
subobject of at least one of the subobject members of <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>B</span><sub ><span class='mathalpha'>i</span></sub>)</span>, or if
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>C</span>)</span> is empty, the new <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>C</span>)</span> is a copy of <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>B</span><sub ><span class='mathalpha'>i</span></sub>)</span>.</p></li><li ><p >Otherwise, if the declaration sets of <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>B</span><sub ><span class='mathalpha'>i</span></sub>)</span> and <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>C</span>)</span>
differ, the merge is ambiguous: the new <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>C</span>)</span> is a lookup set with an
invalid declaration set and the union of the subobject sets. In
subsequent merges, an invalid declaration set is considered different
from any other.</p></li><li ><p >Otherwise, the new <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>C</span>)</span> is a lookup set with the shared set of
declarations and the union of the subobject sets.
</p></li></ul></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >The result of name lookup for <span class='texttt'>f</span> in <span class='texttt'>C</span> is the declaration
set of <span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>f</span>,<span class='mathalpha'>C</span>)</span>. If it is an invalid set, the program is ill-formed.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A { int x; };                    <span class='comment'>// S(x,A) = { { <span class='texttt'>A::x</span> }, { <span class='texttt'>A</span> } }
</span>struct B { float x; };                  <span class='comment'>// S(x,B) = { { <span class='texttt'>B::x</span> }, { <span class='texttt'>B</span> } }
</span>struct C: public A, public B { };       <span class='comment'>// S(x,C) = { invalid, { <span class='texttt'>A</span> in <span class='texttt'>C</span>, <span class='texttt'>B</span> in <span class='texttt'>C</span> } }
</span>struct D: public virtual C { };         <span class='comment'>// S(x,D) = S(x,C)
</span>struct E: public virtual C { char x; }; <span class='comment'>// S(x,E) = { { <span class='texttt'>E::x</span> }, { <span class='texttt'>E</span> } }
</span>struct F: public D, public E { };       <span class='comment'>// S(x,F) = S(x,E)
</span>int main() {
  F f;
  f.x = 0;                              <span class='comment'>// OK, lookup finds <span class='texttt'>E::x</span>
</span>}
</pre><p ><span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>x</span>,<span class='mathalpha'>F</span>)</span> is unambiguous because the <span class='texttt'>A</span> and <span class='texttt'>B</span> base
subobjects of <span class='texttt'>D</span> are also base subobjects of <span class='texttt'>E</span>, so
<span class='math'><span class='mathalpha'>S</span>(<span class='mathalpha'>x</span>,<span class='mathalpha'>D</span>)</span> is discarded in the first merge step.
<i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p ><span class='indexparent'><a class='index' id='access_control,overload_resolution_and'></a></span>If the name of an overloaded function is unambiguously found,
overload resolution (<a href='over.match'>[over.match]</a>) also takes place before access
control.
<span class='indexparent'><a class='index' id='example,scope_resolution_operator'></a></span><span class='indexparent'><a class='index' id='example,explicit_qualification'></a></span><span class='indexparent'><a class='index' id='overloading,resolution,scoping_ambiguity'></a></span>Ambiguities can often be resolved by qualifying a name with its class name.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A {
  int f();
};

</pre><pre class='codeblock'>
struct B {
  int f();
};

</pre><pre class='codeblock'>
struct C : A, B {
  int f() { return A::f() + B::f(); }
};
</pre><p ><i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
A static member, a nested type or an enumerator defined in a base class
<span class='texttt'>T</span> can unambiguously be found even if an object has more than one
base class subobject of type <span class='texttt'>T</span>. Two base class subobjects share
the non-static member subobjects of their common virtual base classes.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct V {
  int v;
};
struct A {
  int a;
  static int   s;
  enum { e };
};
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };

void f(D* pd) {
  pd-&gt;v++;          <span class='comment'>// OK: only one <span class='texttt'>v</span> (virtual)
</span>  pd-&gt;s++;          <span class='comment'>// OK: only one <span class='texttt'>s</span> (static)
</span>  int i = pd-&gt;e;    <span class='comment'>// OK: only one <span class='texttt'>e</span> (enumerator)
</span>  pd-&gt;a++;          <span class='comment'>// error, ambiguous: two <span class='texttt'>a</span>s in <span class='texttt'>D</span>
</span>}
</pre><p ><i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
<span class='indexparent'><a class='index' id='dominance,virtual_base_class'></a></span>When virtual base classes are used, a hidden declaration can be reached
along a path through the subobject lattice that does not pass through
the hiding declaration. This is not an ambiguity. The identical use with
non-virtual base classes is an ambiguity; in that case there is no
unique instance of the name that hides all the others.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct V { int f();  int x; };
struct W { int g();  int y; };
struct B : virtual V, W {
  int f();  int x;
  int g();  int y;
};
struct C : virtual V, W { };

struct D : B, C { void glorp(); };
</pre><div class='figure' id='fig:name'><svg width="386pt" height="182pt"
 viewBox="0.00 0.00 386.00 182.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g class="graph" transform="scale(1 1) rotate(0) translate(4 178)">
<title>virt</title>
<!-- W1 -->
<g class="node"><title>W1</title>
<text text-anchor="middle" x="27" y="-150.8" font-family="Times,serif" font-size="24.00">W</text>
</g>
<!-- V -->
<g class="node"><title>V</title>
<text text-anchor="middle" x="189" y="-150.8" font-family="Times,serif" font-size="24.00">V</text>
</g>
<!-- W2 -->
<g class="node"><title>W2</title>
<text text-anchor="middle" x="351" y="-150.8" font-family="Times,serif" font-size="24.00">W</text>
</g>
<!-- B -->
<g class="node"><title>B</title>
<text text-anchor="middle" x="108" y="-80.8" font-family="Times,serif" font-size="24.00">B</text>
</g>
<!-- B&#45;&gt;W1 -->
<g class="edge"><title>B&#45;&gt;W1</title>
<path fill="none" stroke="black" d="M88.8041,-104.115C78.4893,-112.774 65.597,-123.598 54.2599,-133.115"/>
<polygon fill="black" stroke="black" points="51.7473,-130.655 46.3388,-139.765 56.2481,-136.016 51.7473,-130.655"/>
</g>
<!-- B&#45;&gt;V -->
<g class="edge"><title>B&#45;&gt;V</title>
<path fill="none" stroke="black" d="M127.196,-104.115C137.511,-112.774 150.403,-123.598 161.74,-133.115"/>
<polygon fill="black" stroke="black" points="159.752,-136.016 169.661,-139.765 164.253,-130.655 159.752,-136.016"/>
</g>
<!-- C -->
<g class="node"><title>C</title>
<text text-anchor="middle" x="270" y="-80.8" font-family="Times,serif" font-size="24.00">C</text>
</g>
<!-- C&#45;&gt;V -->
<g class="edge"><title>C&#45;&gt;V</title>
<path fill="none" stroke="black" d="M250.804,-104.115C240.489,-112.774 227.597,-123.598 216.26,-133.115"/>
<polygon fill="black" stroke="black" points="213.747,-130.655 208.339,-139.765 218.248,-136.016 213.747,-130.655"/>
</g>
<!-- C&#45;&gt;W2 -->
<g class="edge"><title>C&#45;&gt;W2</title>
<path fill="none" stroke="black" d="M289.196,-104.115C299.511,-112.774 312.403,-123.598 323.74,-133.115"/>
<polygon fill="black" stroke="black" points="321.752,-136.016 331.661,-139.765 326.253,-130.655 321.752,-136.016"/>
</g>
<!-- D -->
<g class="node"><title>D</title>
<text text-anchor="middle" x="189" y="-10.8" font-family="Times,serif" font-size="24.00">D</text>
</g>
<!-- D&#45;&gt;B -->
<g class="edge"><title>D&#45;&gt;B</title>
<path fill="none" stroke="black" d="M169.804,-34.1151C159.489,-42.7745 146.597,-53.5976 135.26,-63.1151"/>
<polygon fill="black" stroke="black" points="132.747,-60.6546 127.339,-69.765 137.248,-66.0159 132.747,-60.6546"/>
</g>
<!-- D&#45;&gt;C -->
<g class="edge"><title>D&#45;&gt;C</title>
<path fill="none" stroke="black" d="M208.196,-34.1151C218.511,-42.7745 231.403,-53.5976 242.74,-63.1151"/>
<polygon fill="black" stroke="black" points="240.752,-66.0159 250.661,-69.765 245.253,-60.6546 240.752,-66.0159"/>
</g>
</g>
</svg>
<br>Figure <a href='#fig:name'>6</a> â€” Name lookup</div></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
The names declared in <span class='texttt'>V</span> and the left-hand instance of <span class='texttt'>W</span>
are hidden by those in <span class='texttt'>B</span>, but the names declared in the
right-hand instance of <span class='texttt'>W</span> are not hidden at all.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
</p><pre class='codeblock'>
void D::glorp() {
  x++;              <span class='comment'>// OK: <span class='texttt'>B::x</span> hides <span class='texttt'>V::x</span>
</span>  f();              <span class='comment'>// OK: <span class='texttt'>B::f()</span> hides <span class='texttt'>V::f()</span>
</span>  y++;              <span class='comment'>// error: <span class='texttt'>B::y</span> and <span class='texttt'>C</span>'s <span class='texttt'>W::y</span>
</span>  g();              <span class='comment'>// error: <span class='texttt'>B::g()</span> and <span class='texttt'>C</span>'s <span class='texttt'>W::g()</span>
</span>}
</pre><p ><i>&nbsp;â€”&nbsp;end example</i>&nbsp;]
<span class='indexparent'><a class='index' id='ambiguity,class_conversion'></a></span>
</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >An explicit or implicit conversion from a pointer to or
an expression designating an object
of a
derived class to a pointer or reference to one of its base classes shall
unambiguously refer to a unique object representing the base class.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct V { };
struct A { };
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };

void g() {
  D d;
  B* pb = &amp;d;
  A* pa = &amp;d;       <span class='comment'>// error, ambiguous: <span class='texttt'>C</span>'s <span class='texttt'>A</span> or <span class='texttt'>B</span>'s <span class='texttt'>A</span>?
</span>  V* pv = &amp;d;       <span class='comment'>// OK: only one <span class='texttt'>V</span> subobject
</span>}
</pre><p ><i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span>
Even if the result of name lookup is unambiguous, use of a name found in
multiple subobjects might still be
ambiguous (<a href='conv.mem'>[conv.mem]</a>, <a href='expr.ref'>[expr.ref]</a>, <a href='class.access.base'>[class.access.base]</a>).<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct B1 {
  void f();
  static void f(int);
  int i;
};
struct B2 {
  void f(double);
};
struct I1: B1 { };
struct I2: B1 { };

struct D: I1, I2, B2 {
  using B1::f;
  using B2::f;
  void g() {
    f();                        <span class='comment'>// Ambiguous conversion of <span class='texttt'>this</span>
</span>    f(0);                       <span class='comment'>// Unambiguous (static)
</span>    f(0.0);                     <span class='comment'>// Unambiguous (only one <span class='texttt'>B2</span>)
</span>    int B1::* mpB1 = &amp;D::i;     <span class='comment'>// Unambiguous
</span>    int D::* mpD = &amp;D::i;       <span class='comment'>// Ambiguous conversion
</span>  }
};
</pre><p ><i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p></div></div></div></body></html>