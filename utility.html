<!DOCTYPE html><html lang='en'><head><title>[utility]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><div id='utility'><h2 ><a class='secnum' style='min-width:88pt'>20.2</a> Utility components <a class='abbr_ref'>[utility]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >This subclause contains some basic function and class templates that are used
throughout the rest of the library.</p><p ><span class='indexparent'><a class='index' id='utility'></a></span><span class='indexparent'><a class='index' id='rel_ops'></a></span><b>Header <span class='texttt'>&lt;utility&gt;</span> synopsis</b></p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The header <span class='texttt'>&lt;utility&gt;</span> defines several types and function templates
that are described in this Clause. It also defines the template <span class='texttt'>pair</span>
and various function templates that operate on <span class='texttt'>pair</span> objects.</p><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// <a href='operators'>[operators]</a>, operators:
</span>  namespace rel_ops {
    template&lt;class T&gt; bool operator!=(const T&amp;, const T&amp;);
    template&lt;class T&gt; bool operator&gt; (const T&amp;, const T&amp;);
    template&lt;class T&gt; bool operator&lt;=(const T&amp;, const T&amp;);
    template&lt;class T&gt; bool operator&gt;=(const T&amp;, const T&amp;);
  }

  <span class='comment'>// <a href='utility.swap'>[utility.swap]</a>, swap:
</span>  template &lt;class T&gt; void swap(T&amp; a, T&amp; b) noexcept(<i><span class='texttt'>see below</span></i>);
  template &lt;class T, size_t N&gt; void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(is_nothrow_swappable_v&lt;T&gt;);

  <span class='comment'>// <a href='utility.exchange'>[utility.exchange]</a>, exchange:
</span>  template &lt;class T, class U=T&gt; T exchange(T&amp; obj, U&amp;&amp; new_val);

  <span class='comment'>// <a href='forward'>[forward]</a>, forward/move:
</span>  template &lt;class T&gt; 
    constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp; t) noexcept;
  template &lt;class T&gt;
    constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp;&amp; t) noexcept;
  template &lt;class T&gt;
    constexpr remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp;&amp;) noexcept;
  template &lt;class T&gt;
    constexpr conditional_t&lt;
    !is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; is_copy_constructible_v&lt;T&gt;,
    const T&amp;, T&amp;&amp;&gt; move_if_noexcept(T&amp; x) noexcept;

  <span class='comment'>// <a href='utility.as_const'>[utility.as_const]</a>, as_const:
</span>  template &lt;class T&gt; constexpr add_const_t&lt;T&gt;&amp; as_const(T&amp; t) noexcept;
  template &lt;class T&gt; void as_const(const T&amp;&amp;) = delete;

  <span class='comment'>// <a href='declval'>[declval]</a>, declval:
</span>  template &lt;class T&gt;
    add_rvalue_reference_t&lt;T&gt; declval() noexcept;  <span class='comment'>// as unevaluated operand
</span>

<span class='indexparent'><a class='index' id='index_sequence'></a></span><span class='indexparent'><a class='index' id='make_index_sequence'></a></span><span class='indexparent'><a class='index' id='index_sequence_for'></a></span>
  <span class='comment'>// <a href='intseq'>[intseq]</a>, Compile-time integer sequences
</span>  template&lt;class T, T...&gt; struct integer_sequence;
  template&lt;size_t... I&gt;
    using index_sequence = integer_sequence&lt;size_t, I...&gt;;

  template&lt;class T, T N&gt;
    using make_integer_sequence = integer_sequence&lt;T, <i><span class='texttt'>see below</span></i>&gt;;
  template&lt;size_t N&gt;
    using make_index_sequence = make_integer_sequence&lt;size_t, N&gt;;

  template&lt;class... T&gt;
    using index_sequence_for = make_index_sequence&lt;sizeof...(T)&gt;;

  <span class='comment'>// <a href='pairs'>[pairs]</a>, pairs:
</span>  template &lt;class T1, class T2&gt; struct pair;

  <span class='comment'>// <a href='pairs.spec'>[pairs.spec]</a>, pair specialized algorithms:
</span>  template &lt;class T1, class T2&gt;
    constexpr bool operator==(const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator&lt; (const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator!=(const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator&gt; (const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator&gt;=(const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator&lt;=(const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp; y) noexcept(noexcept(x.swap(y)));
  template &lt;class T1, class T2&gt;
    constexpr <i><span class='texttt'>see below</span></i> make_pair(T1&amp;&amp;, T2&amp;&amp;);

  <span class='comment'>// <a href='pair.astuple'>[pair.astuple]</a>, tuple-like access to pair:
</span>  template &lt;class T&gt; class tuple_size;
  template &lt;size_t I, class T&gt; class tuple_element;

  template &lt;class T1, class T2&gt; struct tuple_size&lt;pair&lt;T1, T2&gt;&gt;;
  template &lt;class T1, class T2&gt; struct tuple_element&lt;0, pair&lt;T1, T2&gt;&gt;;
  template &lt;class T1, class T2&gt; struct tuple_element&lt;1, pair&lt;T1, T2&gt;&gt;;

  template&lt;size_t I, class T1, class T2&gt;
    constexpr tuple_element_t&lt;I, pair&lt;T1, T2&gt;&gt;&amp;
      get(pair&lt;T1, T2&gt;&amp;) noexcept;
  template&lt;size_t I, class T1, class T2&gt;
    constexpr tuple_element_t&lt;I, pair&lt;T1, T2&gt;&gt;&amp;&amp;
      get(pair&lt;T1, T2&gt;&amp;&amp;) noexcept;
  template&lt;size_t I, class T1, class T2&gt;
    constexpr const tuple_element_t&lt;I, pair&lt;T1, T2&gt;&gt;&amp;
      get(const pair&lt;T1, T2&gt;&amp;) noexcept;
  template&lt;size_t I, class T1, class T2&gt;
    constexpr const tuple_element_t&lt;I, pair&lt;T1, T2&gt;&gt;&amp;&amp;
      get(const pair&lt;T1, T2&gt;&amp;&amp;) noexcept;
  template &lt;class T, class U&gt;
    constexpr T&amp; get(pair&lt;T, U&gt;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr const T&amp; get(const pair&lt;T, U&gt;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr T&amp;&amp; get(pair&lt;T, U&gt;&amp;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr const T&amp;&amp; get(const pair&lt;T, U&gt;&amp;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr T&amp; get(pair&lt;U, T&gt;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr const T&amp; get(const pair&lt;U, T&gt;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr T&amp;&amp; get(pair&lt;U, T&gt;&amp;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr const T&amp;&amp; get(const pair&lt;U, T&gt;&amp;&amp; p) noexcept;

  <span class='comment'>// <a href='pair.piecewise'>[pair.piecewise]</a>, pair piecewise construction
</span>  struct piecewise_construct_t { };
  constexpr piecewise_construct_t piecewise_construct{};
  template &lt;class... Types&gt; class tuple;  <span class='comment'>// defined in <span class='texttt'>&lt;tuple&gt;</span>
</span>
  <span class='comment'>// <a href='utility.inplace'>[utility.inplace]</a>, in-place construction
</span>  struct in_place_tag {
    in_place_tag() = delete;
  };
  using in_place_t = in_place_tag(&amp;)(<i><span class='texttt'>unspecified</span></i>);
  template &lt;class T&gt;
    using in_place_type_t = in_place_tag(&amp;)(<i><span class='texttt'>unspecified</span></i>&lt;T&gt;);
  template &lt;size_t I&gt;
    using in_place_index_t = in_place_tag(&amp;)(<i><span class='texttt'>unspecified</span></i>&lt;I&gt;);
  in_place_tag in_place(<i><span class='texttt'>unspecified</span></i>);
  template &lt;class T&gt;
    in_place_tag in_place(<i><span class='texttt'>unspecified</span></i>&lt;T&gt;);
  template &lt;size_t I&gt;
    in_place_tag in_place(<i><span class='texttt'>unspecified</span></i>&lt;I&gt;);
}
</pre></div><div id='operators'><h3 ><a class='secnum' href='#operators' style='min-width:103pt'>20.2.1</a> Operators <a class='abbr_ref' href='operators'>[operators]</a></h3><div class='para' id='operators-1'><div class='marginalizedparent'><a class='marginalized' href='#operators-1'>1</a></div><p >To avoid redundant definitions of <span class='texttt'>operator!=</span> out of <span class='texttt'>operator==</span>
and operators <span class='texttt'>&gt;</span>, <span class='texttt'>&lt;=</span>, and <span class='texttt'>&gt;=</span> out of <span class='texttt'>operator&lt;</span>,
the library provides the following:</p><p ><span class='indexparent'><a class='index' id='operator!='></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator!=(const T&amp; x, const T&amp; y);
</code></p></div><div class='itemdescr'></div><div class='para' id='operators-2'><div class='marginalizedparent'><a class='marginalized' href='#operators-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>EqualityComparable</span> (Table <a href='utility.arg.requirements#tab:equalitycomparable'>[tab:equalitycomparable]</a>).</p></div></div><div class='para' id='operators-3'><div class='marginalizedparent'><a class='marginalized' href='#operators-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!(x == y)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>'></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator&gt;(const T&amp; x, const T&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='operators-4'><div class='marginalizedparent'><a class='marginalized' href='#operators-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>LessThanComparable</span> (Table <a href='utility.arg.requirements#tab:lessthancomparable'>[tab:lessthancomparable]</a>).</p></div></div><div class='para' id='operators-5'><div class='marginalizedparent'><a class='marginalized' href='#operators-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>y &lt; x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<='></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator&lt;=(const T&amp; x, const T&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='operators-6'><div class='marginalizedparent'><a class='marginalized' href='#operators-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>LessThanComparable</span> (Table <a href='utility.arg.requirements#tab:lessthancomparable'>[tab:lessthancomparable]</a>).</p></div></div><div class='para' id='operators-7'><div class='marginalizedparent'><a class='marginalized' href='#operators-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!(y &lt; x)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>='></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator&gt;=(const T&amp; x, const T&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='operators-8'><div class='marginalizedparent'><a class='marginalized' href='#operators-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>LessThanComparable</span> (Table <a href='utility.arg.requirements#tab:lessthancomparable'>[tab:lessthancomparable]</a>).</p></div></div><div class='para' id='operators-9'><div class='marginalizedparent'><a class='marginalized' href='#operators-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!(x &lt; y)</span>.
</p></div></div><div class='para' id='operators-10'><div class='marginalizedparent'><a class='marginalized' href='#operators-10'>10</a></div><p >In this library, whenever a declaration is provided for an <span class='texttt'>operator!=</span>,
<span class='texttt'>operator&gt;</span>, <span class='texttt'>operator&gt;=</span>, or <span class='texttt'>operator&lt;=</span>,
and requirements and semantics are not explicitly provided,
the requirements and semantics are as specified in this Clause.</p></div></div><div id='swap'><h3 ><a class='secnum' href='#swap' style='min-width:103pt'>20.2.2</a> swap <a class='abbr_ref' href='utility.swap'>[utility.swap]</a></h3><p ><span class='indexparent'><a class='index' id='swap'></a></span><code class='itemdecl'>
template &lt;class T&gt; void swap(T&amp; a, T&amp; b) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='swap-1'><div class='marginalizedparent'><a class='marginalized' href='#swap-1'>1</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution
unless <span class='texttt'>is_move_constructible_v&lt;T&gt;</span> is <span class='texttt'>true</span> and
<span class='texttt'>is_move_assignable_v&lt;T&gt;</span> is <span class='texttt'>true</span>.
The expression inside <span class='texttt'>noexcept</span> is equivalent to:</p><pre class='codeblock'>
is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; is_nothrow_move_assignable_v&lt;T&gt;
</pre></div></div><div class='para' id='swap-2'><div class='marginalizedparent'><a class='marginalized' href='#swap-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type
<span class='texttt'>T</span>
shall be
<span class='texttt'>MoveConstructible</span> (Table <a href='utility.arg.requirements#tab:moveconstructible'>[tab:moveconstructible]</a>)
and
<span class='texttt'>MoveAssignable</span> (Table <a href='utility.arg.requirements#tab:moveassignable'>[tab:moveassignable]</a>).</p></div></div><div class='para' id='swap-3'><div class='marginalizedparent'><a class='marginalized' href='#swap-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Exchanges values stored in two locations.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap'></a></span><code class='itemdecl'>
template &lt;class T, size_t N&gt;
  void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(is_nothrow_swappable_v&lt;T&gt;);
</code></p><div class='itemdescr'></div><div class='para' id='swap-4'><div class='marginalizedparent'><a class='marginalized' href='#swap-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution
unless <span class='texttt'>is_swappable_v&lt;T&gt;</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='swap-5'><div class='marginalizedparent'><a class='marginalized' href='#swap-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>a[i]</span> shall be swappable with (<a href='swappable.requirements'>[swappable.requirements]</a>) <span class='texttt'>b[i]</span>
for all <span class='texttt'>i</span> in the range <span class='texttt'>[0, N)</span>.</p></div></div><div class='para' id='swap-6'><div class='marginalizedparent'><a class='marginalized' href='#swap-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>swap_ranges(a, a + N, b)</span>.
</p></div></div></div><div id='exchange'><h3 ><a class='secnum' href='#exchange' style='min-width:103pt'>20.2.3</a> exchange <a class='abbr_ref' href='utility.exchange'>[utility.exchange]</a></h3><p ><span class='indexparent'><a class='index' id='exchange'></a></span><code class='itemdecl'>
template &lt;class T, class U=T&gt; T exchange(T&amp; obj, U&amp;&amp; new_val);
</code></p><div class='itemdescr'></div><div class='para' id='exchange-1'><div class='marginalizedparent'><a class='marginalized' href='#exchange-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Equivalent to:
</p><pre class='codeblock'>
T old_val = std::move(obj);
obj = std::forward&lt;U&gt;(new_val);
return old_val;
</pre></div></div></div><div id='forward'><h3 ><a class='secnum' href='#forward' style='min-width:103pt'>20.2.4</a> forward/move helpers <a class='abbr_ref' href='forward'>[forward]</a></h3><div class='para' id='forward-1'><div class='marginalizedparent'><a class='marginalized' href='#forward-1'>1</a></div><p >The library provides templated helper functions to simplify
applying move semantics to an lvalue and to simplify the implementation
of forwarding functions.</p><p ><span class='indexparent'><a class='index' id='forward'></a></span><code class='itemdecl'>
template &lt;class T&gt; constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp; t) noexcept;
template &lt;class T&gt; constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp;&amp; t) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='forward-2'><div class='marginalizedparent'><a class='marginalized' href='#forward-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>static_cast&lt;T&amp;&amp;&gt;(t)</span>.</p></div></div><div class='para' id='forward-3'><div class='marginalizedparent'><a class='marginalized' href='#forward-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> If the second form is instantiated with an lvalue reference type, the program is ill-formed.</p></div></div><div class='para' id='forward-4'><div class='marginalizedparent'><a class='marginalized' href='#forward-4'>4</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T, class A1, class A2&gt;
shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1, A2&amp;&amp; a2) {
  return shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1), std::forward&lt;A2&gt;(a2)));
}

struct A {
  A(int&amp;, const double&amp;);
};

void g() {
  shared_ptr&lt;A&gt; sp1 = factory&lt;A&gt;(2, 1.414); <span class='comment'>// error: 2 will not bind to <span class='texttt'>int&amp;</span>
</span>  int i = 2;
  shared_ptr&lt;A&gt; sp2 = factory&lt;A&gt;(i, 1.414); <span class='comment'>// OK
</span>}
</pre></div></div><div class='para' id='forward-5'><div class='marginalizedparent'><a class='marginalized' href='#forward-5'>5</a></div><div class='itemdescr'><p >In the first call to <span class='texttt'>factory</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>int</span>, so 2 is forwarded
to <span class='texttt'>A</span>'s constructor as an rvalue.
In the second call to <span class='texttt'>factory</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>int&amp;</span>, so <span class='texttt'>i</span> is forwarded
to <span class='texttt'>A</span>'s constructor as an lvalue. In
both cases, <span class='texttt'>A2</span> is deduced as <span class='texttt'>double</span>, so
1.414 is forwarded to <span class='texttt'>A</span>'s constructor as an rvalue.</p><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='move,function'></a></span><code class='itemdecl'>
template &lt;class T&gt; constexpr remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp;&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='forward-6'><div class='marginalizedparent'><a class='marginalized' href='#forward-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>static_cast&lt;remove_reference_t&lt;T&gt;&amp;&amp;&gt;(t)</span>.</p></div></div><div class='para' id='forward-7'><div class='marginalizedparent'><a class='marginalized' href='#forward-7'>7</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T, class A1&gt;
shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) {
  return shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1)));
}

struct A {
  A();
  A(const A&amp;);  <span class='comment'>// copies from lvalues
</span>  A(A&amp;&amp;);       <span class='comment'>// moves from rvalues
</span>};

void g() {
  A a;
  shared_ptr&lt;A&gt; sp1 = factory&lt;A&gt;(a);              <span class='comment'>// “<span class='texttt'>a</span>” binds to <span class='texttt'>A(const A&amp;)</span>
</span>  shared_ptr&lt;A&gt; sp1 = factory&lt;A&gt;(std::move(a));   <span class='comment'>// “<span class='texttt'>a</span>” binds to <span class='texttt'>A(A&amp;&amp;)</span>
</span>}
</pre></div></div><div class='para' id='forward-8'><div class='marginalizedparent'><a class='marginalized' href='#forward-8'>8</a></div><div class='itemdescr'><p >In the first call to <span class='texttt'>factory</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>A&amp;</span>, so <span class='texttt'>a</span> is forwarded
as a non-const lvalue. This binds to the constructor <span class='texttt'>A(const A&amp;)</span>,
which copies the value from <span class='texttt'>a</span>.
In the second call to <span class='texttt'>factory</span>, because of the call
<span class='texttt'>std::move(a)</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>A</span>, so <span class='texttt'>a</span> is forwarded
as an rvalue. This binds to the constructor <span class='texttt'>A(A&amp;&amp;)</span>,
which moves the value from <span class='texttt'>a</span>.</p><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='move_if_noexcept'></a></span><code class='itemdecl'>
template &lt;class T&gt; constexpr conditional_t&lt;
  !is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; is_copy_constructible_v&lt;T&gt;,
  const T&amp;, T&amp;&amp;&gt; move_if_noexcept(T&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='forward-9'><div class='marginalizedparent'><a class='marginalized' href='#forward-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>std::move(x)</span>.
</p></div></div></div><div id='as_const'><h3 ><a class='secnum' href='#as_const' style='min-width:103pt'>20.2.5</a> Function template <span class='texttt'>as_const</span> <a class='abbr_ref' href='utility.as_const'>[utility.as_const]</a></h3><p ><span class='indexparent'><a class='index' id='as_const'></a></span><code class='itemdecl'>
template &lt;class T&gt; constexpr add_const_t&lt;T&gt;&amp; as_const(T&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='as_const-1'><div class='marginalizedparent'><a class='marginalized' href='#as_const-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>t</span>.
</p></div></div></div><div id='declval'><h3 ><a class='secnum' href='#declval' style='min-width:103pt'>20.2.6</a> Function template <span class='texttt'>declval</span> <a class='abbr_ref' href='declval'>[declval]</a></h3><div class='para' id='declval-1'><div class='marginalizedparent'><a class='marginalized' href='#declval-1'>1</a></div><p >The library provides the function template <span class='texttt'>declval</span> to simplify the definition of
expressions which occur as unevaluated operands (Clause <a href='expr'>[expr]</a>).</p><p ><span class='indexparent'><a class='index' id='declval'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; declval() noexcept;  <span class='comment'>// as unevaluated operand
</span></code></p></div><div class='itemdescr'></div><div class='para' id='declval-2'><div class='marginalizedparent'><a class='marginalized' href='#declval-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> If this function is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>), the program is ill-formed.</p></div></div><div class='para' id='declval-3'><div class='marginalizedparent'><a class='marginalized' href='#declval-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> The template parameter <span class='texttt'>T</span> of <span class='texttt'>declval</span> may be an incomplete type.
</p></div></div><div class='para' id='declval-4'><div class='marginalizedparent'><a class='marginalized' href='#declval-4'>4</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class To, class From&gt;
  decltype(static_cast&lt;To&gt;(declval&lt;From&gt;())) convert(From&amp;&amp;);
</pre><p >declares a function template <span class='texttt'>convert</span> which only participates in overloading if the
type <span class='texttt'>From</span> can be explicitly converted to type <span class='texttt'>To</span>. For another example see class
template <span class='texttt'>common_type</span> (<a href='meta.trans.other'>[meta.trans.other]</a>).
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='inplace'><h3 ><a class='secnum' href='#inplace' style='min-width:103pt'>20.2.7</a> In-place construction <a class='abbr_ref' href='utility.inplace'>[utility.inplace]</a></h3><div class='para' id='inplace-1'><div class='marginalizedparent'><a class='marginalized' href='#inplace-1'>1</a></div><p >The <span class='texttt'>in_place_t</span>, <span class='texttt'>in_place_type_t</span>, and <span class='texttt'>in_place_index_t</span>
function types are used as unique types to disambiguate constructor and function
overloading. Specifically, <span class='texttt'>optional</span> has a constructor with <span class='texttt'>in_place_t</span>
as the first parameter followed by a parameter pack; this indicates that <span class='texttt'>T</span>
should be constructed in-place (as if by a call to a placement <i ><a href='expr.new#nt:new-expression'>new-expression</a></i>)
with the forwarded pack expansion as arguments for the initialization of <span class='texttt'>T</span>.</p></div><div class='para' id='inplace-2'><div class='marginalizedparent'><a class='marginalized' href='#inplace-2'>2</a></div><p ><i>Remarks:</i>
Calling <span class='texttt'>in_place</span> functions results in undefined behavior.
[&nbsp;<i>Note:</i> These functions might be instantiated into every object file.  <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div></div></body></html>