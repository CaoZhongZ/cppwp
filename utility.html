<!DOCTYPE html><html lang='en'><head><title>[utility]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><div id='utility'><h2 ><a class='secnum' style='min-width:88pt'>20.2</a> Utility components <a class='abbr_ref'>[utility]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >This subclause contains some basic function and class templates that are used
throughout the rest of the library.</p><p ><span class='indexparent'><a class='index' id='utility'></a></span><span class='indexparent'><a class='index' id='rel_ops'></a></span><b>Header <span class='texttt'>&lt;utility&gt;</span> synopsis</b></p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The header <span class='texttt'>&lt;utility&gt;</span> defines several types and function templates
that are described in this Clause. It also defines the template <span class='texttt'>pair</span>
and various function templates that operate on <span class='texttt'>pair</span> objects.</p><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// <a href='operators'>[operators]</a>, operators
</span>  namespace rel_ops {
    template&lt;class T&gt; bool operator!=(const T&amp;, const T&amp;);
    template&lt;class T&gt; bool operator&gt; (const T&amp;, const T&amp;);
    template&lt;class T&gt; bool operator&lt;=(const T&amp;, const T&amp;);
    template&lt;class T&gt; bool operator&gt;=(const T&amp;, const T&amp;);
  }

  <span class='comment'>// <a href='utility.swap'>[utility.swap]</a>, swap
</span>  template &lt;class T&gt; void swap(T&amp; a, T&amp; b) noexcept(<i><span class='texttt'>see below</span></i>);
  template &lt;class T, size_t N&gt; void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(is_nothrow_swappable_v&lt;T&gt;);

  <span class='comment'>// <a href='utility.exchange'>[utility.exchange]</a>, exchange
</span>  template &lt;class T, class U=T&gt; T exchange(T&amp; obj, U&amp;&amp; new_val);

  <span class='comment'>// <a href='forward'>[forward]</a>, forward/move
</span>  template &lt;class T&gt; 
    constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp; t) noexcept;
  template &lt;class T&gt;
    constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp;&amp; t) noexcept;
  template &lt;class T&gt;
    constexpr remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp;&amp;) noexcept;
  template &lt;class T&gt;
    constexpr conditional_t&lt;
    !is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; is_copy_constructible_v&lt;T&gt;,
    const T&amp;, T&amp;&amp;&gt; move_if_noexcept(T&amp; x) noexcept;

  <span class='comment'>// <a href='utility.as_const'>[utility.as_const]</a>, as_const
</span>  template &lt;class T&gt; constexpr add_const_t&lt;T&gt;&amp; as_const(T&amp; t) noexcept;
  template &lt;class T&gt; void as_const(const T&amp;&amp;) = delete;

  <span class='comment'>// <a href='declval'>[declval]</a>, declval
</span>  template &lt;class T&gt;
    add_rvalue_reference_t&lt;T&gt; declval() noexcept;  <span class='comment'>// as unevaluated operand
</span>

<span class='indexparent'><a class='index' id='index_sequence'></a></span><span class='indexparent'><a class='index' id='make_index_sequence'></a></span><span class='indexparent'><a class='index' id='index_sequence_for'></a></span>
  <span class='comment'>// <a href='intseq'>[intseq]</a>, Compile-time integer sequences
</span>  template&lt;class T, T...&gt; struct integer_sequence;
  template&lt;size_t... I&gt;
    using index_sequence = integer_sequence&lt;size_t, I...&gt;;

  template&lt;class T, T N&gt;
    using make_integer_sequence = integer_sequence&lt;T, <i><span class='texttt'>see below</span></i>&gt;;
  template&lt;size_t N&gt;
    using make_index_sequence = make_integer_sequence&lt;size_t, N&gt;;

  template&lt;class... T&gt;
    using index_sequence_for = make_index_sequence&lt;sizeof...(T)&gt;;

  <span class='comment'>// <a href='pairs'>[pairs]</a>, pairs
</span>  template &lt;class T1, class T2&gt; struct pair;

  <span class='comment'>// <a href='pairs.spec'>[pairs.spec]</a>, pair specialized algorithms
</span>  template &lt;class T1, class T2&gt;
    constexpr bool operator==(const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator&lt; (const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator!=(const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator&gt; (const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator&gt;=(const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    constexpr bool operator&lt;=(const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);
  template &lt;class T1, class T2&gt;
    void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp; y) noexcept(noexcept(x.swap(y)));
  template &lt;class T1, class T2&gt;
    constexpr <i><span class='texttt'>see below</span></i> make_pair(T1&amp;&amp;, T2&amp;&amp;);

  <span class='comment'>// <a href='pair.astuple'>[pair.astuple]</a>, tuple-like access to pair
</span>  template &lt;class T&gt; class tuple_size;
  template &lt;size_t I, class T&gt; class tuple_element;

  template &lt;class T1, class T2&gt; struct tuple_size&lt;pair&lt;T1, T2&gt;&gt;;
  template &lt;class T1, class T2&gt; struct tuple_element&lt;0, pair&lt;T1, T2&gt;&gt;;
  template &lt;class T1, class T2&gt; struct tuple_element&lt;1, pair&lt;T1, T2&gt;&gt;;

  template&lt;size_t I, class T1, class T2&gt;
    constexpr tuple_element_t&lt;I, pair&lt;T1, T2&gt;&gt;&amp;
      get(pair&lt;T1, T2&gt;&amp;) noexcept;
  template&lt;size_t I, class T1, class T2&gt;
    constexpr tuple_element_t&lt;I, pair&lt;T1, T2&gt;&gt;&amp;&amp;
      get(pair&lt;T1, T2&gt;&amp;&amp;) noexcept;
  template&lt;size_t I, class T1, class T2&gt;
    constexpr const tuple_element_t&lt;I, pair&lt;T1, T2&gt;&gt;&amp;
      get(const pair&lt;T1, T2&gt;&amp;) noexcept;
  template&lt;size_t I, class T1, class T2&gt;
    constexpr const tuple_element_t&lt;I, pair&lt;T1, T2&gt;&gt;&amp;&amp;
      get(const pair&lt;T1, T2&gt;&amp;&amp;) noexcept;
  template &lt;class T, class U&gt;
    constexpr T&amp; get(pair&lt;T, U&gt;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr const T&amp; get(const pair&lt;T, U&gt;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr T&amp;&amp; get(pair&lt;T, U&gt;&amp;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr const T&amp;&amp; get(const pair&lt;T, U&gt;&amp;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr T&amp; get(pair&lt;U, T&gt;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr const T&amp; get(const pair&lt;U, T&gt;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr T&amp;&amp; get(pair&lt;U, T&gt;&amp;&amp; p) noexcept;
  template &lt;class T, class U&gt;
    constexpr const T&amp;&amp; get(const pair&lt;U, T&gt;&amp;&amp; p) noexcept;

  <span class='comment'>// <a href='pair.piecewise'>[pair.piecewise]</a>, pair piecewise construction
</span>  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };
  constexpr piecewise_construct_t piecewise_construct{};
  template &lt;class... Types&gt; class tuple;  <span class='comment'>// defined in <span class='texttt'>&lt;tuple&gt;</span>
</span>
  <span class='comment'>// in-place construction
</span>  struct in_place_t {
    explicit in_place_t() = default;
  };
  inline constexpr in_place_t in_place{};
  template &lt;class T&gt;
    struct in_place_type_t {
      explicit in_place_type_t() = default;
    };
  template &lt;class T&gt;
    inline constexpr in_place_type_t&lt;T&gt; in_place_type{};
  template &lt;size_t I&gt;
    struct in_place_index_t {
      explicit in_place_index_t() = default;
    };
  template &lt;size_t I&gt;
    inline constexpr in_place_index_t&lt;I&gt; in_place_index{};

<span class='indexparent'><a class='index' id='chars_format'></a></span><span class='indexparent'><a class='index' id='scientific,chars_format'></a></span><span class='indexparent'><a class='index' id='chars_format,scientific'></a></span><span class='indexparent'><a class='index' id='fixed,chars_format'></a></span><span class='indexparent'><a class='index' id='chars_format,fixed'></a></span><span class='indexparent'><a class='index' id='hex,chars_format'></a></span><span class='indexparent'><a class='index' id='chars_format,hex'></a></span><span class='indexparent'><a class='index' id='general,chars_format'></a></span><span class='indexparent'><a class='index' id='chars_format,general'></a></span>
  <span class='comment'>// floating-point format for primitive numerical conversion
</span>  enum class chars_format {
    scientific = <i><span class='texttt'>unspecified</span></i>,
    fixed = <i><span class='texttt'>unspecified</span></i>,
    hex = <i><span class='texttt'>unspecified</span></i>,
    general = fixed | scientific
  };

<span class='indexparent'><a class='index' id='to_chars_result'></a></span><span class='indexparent'><a class='index' id='ptr,to_chars_result'></a></span><span class='indexparent'><a class='index' id='to_chars_result,ptr'></a></span><span class='indexparent'><a class='index' id='ec,to_chars_result'></a></span><span class='indexparent'><a class='index' id='to_chars_result,ec'></a></span>

  <span class='comment'>// <a href='utility.to.chars'>[utility.to.chars]</a>, primitive numerical output conversion
</span>  struct to_chars_result {
    char* ptr;
    error_code ec;
  };

  to_chars_result to_chars(char* first, char* last, <i><span class='texttt'>see below</span></i> value, int base = 10);

  to_chars_result to_chars(char* first, char* last, float value);
  to_chars_result to_chars(char* first, char* last, double value);
  to_chars_result to_chars(char* first, char* last, long double value);

  to_chars_result to_chars(char* first, char* last, float value, chars_format fmt);
  to_chars_result to_chars(char* first, char* last, double value, chars_format fmt);
  to_chars_result to_chars(char* first, char* last, long double value, chars_format fmt);

  to_chars_result to_chars(char* first, char* last, float value,
                           chars_format fmt, int precision);
  to_chars_result to_chars(char* first, char* last, double value,
                           chars_format fmt, int precision);
  to_chars_result to_chars(char* first, char* last, long double value,
                           chars_format fmt, int precision);

<span class='indexparent'><a class='index' id='from_chars_result'></a></span><span class='indexparent'><a class='index' id='ptr,from_chars_result'></a></span><span class='indexparent'><a class='index' id='from_chars_result,ptr'></a></span><span class='indexparent'><a class='index' id='ec,from_chars_result'></a></span><span class='indexparent'><a class='index' id='from_chars_result,ec'></a></span>

  <span class='comment'>// <a href='utility.from.chars'>[utility.from.chars]</a>, primitive numerical input conversion
</span>  struct from_chars_result {
    const char* ptr;
    error_code ec;
  };

  from_chars_result from_chars(const char* first, const char* last,
                               <i><span class='texttt'>see below</span></i>&amp; value, int base = 10);

  from_chars_result from_chars(const char* first, const char* last, float&amp; value,
                               chars_format fmt = chars_format::general);
  from_chars_result from_chars(const char* first, const char* last, double&amp; value,
                               chars_format fmt = chars_format::general);
  from_chars_result from_chars(const char* first, const char* last, long double&amp; value,
                               chars_format fmt = chars_format::general);
}
</pre></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >The type <span class='texttt'>chars_format</span>
is a bitmask type (<a href='bitmask.types'>[bitmask.types]</a>)
with elements
<span class='texttt'>scientific</span>,
<span class='texttt'>fixed</span>,
and <span class='texttt'>hex</span>.</p></div><div id='operators'><h3 ><a class='secnum' href='#operators' style='min-width:103pt'>20.2.1</a> Operators <a class='abbr_ref' href='operators'>[operators]</a></h3><div class='para' id='operators-1'><div class='marginalizedparent'><a class='marginalized' href='#operators-1'>1</a></div><p >To avoid redundant definitions of <span class='texttt'>operator!=</span> out of <span class='texttt'>operator==</span>
and operators <span class='texttt'>&gt;</span>, <span class='texttt'>&lt;=</span>, and <span class='texttt'>&gt;=</span> out of <span class='texttt'>operator&lt;</span>,
the library provides the following:</p><p ><span class='indexparent'><a class='index' id='operator!='></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator!=(const T&amp; x, const T&amp; y);
</code></p></div><div class='itemdescr'></div><div class='para' id='operators-2'><div class='marginalizedparent'><a class='marginalized' href='#operators-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>EqualityComparable</span> (Table <a href='utility.arg.requirements#tab:equalitycomparable'>[tab:equalitycomparable]</a>).</p></div></div><div class='para' id='operators-3'><div class='marginalizedparent'><a class='marginalized' href='#operators-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!(x == y)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>'></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator&gt;(const T&amp; x, const T&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='operators-4'><div class='marginalizedparent'><a class='marginalized' href='#operators-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>LessThanComparable</span> (Table <a href='utility.arg.requirements#tab:lessthancomparable'>[tab:lessthancomparable]</a>).</p></div></div><div class='para' id='operators-5'><div class='marginalizedparent'><a class='marginalized' href='#operators-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>y &lt; x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<='></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator&lt;=(const T&amp; x, const T&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='operators-6'><div class='marginalizedparent'><a class='marginalized' href='#operators-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>LessThanComparable</span> (Table <a href='utility.arg.requirements#tab:lessthancomparable'>[tab:lessthancomparable]</a>).</p></div></div><div class='para' id='operators-7'><div class='marginalizedparent'><a class='marginalized' href='#operators-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!(y &lt; x)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>='></a></span><code class='itemdecl'>
template &lt;class T&gt; bool operator&gt;=(const T&amp; x, const T&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='operators-8'><div class='marginalizedparent'><a class='marginalized' href='#operators-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type <span class='texttt'>T</span> is <span class='texttt'>LessThanComparable</span> (Table <a href='utility.arg.requirements#tab:lessthancomparable'>[tab:lessthancomparable]</a>).</p></div></div><div class='para' id='operators-9'><div class='marginalizedparent'><a class='marginalized' href='#operators-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!(x &lt; y)</span>.
</p></div></div><div class='para' id='operators-10'><div class='marginalizedparent'><a class='marginalized' href='#operators-10'>10</a></div><p >In this library, whenever a declaration is provided for an <span class='texttt'>operator!=</span>,
<span class='texttt'>operator&gt;</span>, <span class='texttt'>operator&gt;=</span>, or <span class='texttt'>operator&lt;=</span>,
and requirements and semantics are not explicitly provided,
the requirements and semantics are as specified in this Clause.</p></div></div><div id='swap'><h3 ><a class='secnum' href='#swap' style='min-width:103pt'>20.2.2</a> swap <a class='abbr_ref' href='utility.swap'>[utility.swap]</a></h3><p ><span class='indexparent'><a class='index' id='swap'></a></span><code class='itemdecl'>
template &lt;class T&gt; void swap(T&amp; a, T&amp; b) noexcept(<i><span class='texttt'>see below</span></i>);
</code></p><div class='itemdescr'></div><div class='para' id='swap-1'><div class='marginalizedparent'><a class='marginalized' href='#swap-1'>1</a></div><div class='itemdescr'><p ><i>Remarks:</i> This function shall not participate in overload resolution
unless <span class='texttt'>is_move_constructible_v&lt;T&gt;</span> is <span class='texttt'>true</span> and
<span class='texttt'>is_move_assignable_v&lt;T&gt;</span> is <span class='texttt'>true</span>.
The expression inside <span class='texttt'>noexcept</span> is equivalent to:</p><pre class='codeblock'>
is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; is_nothrow_move_assignable_v&lt;T&gt;
</pre></div></div><div class='para' id='swap-2'><div class='marginalizedparent'><a class='marginalized' href='#swap-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
Type
<span class='texttt'>T</span>
shall be
<span class='texttt'>MoveConstructible</span> (Table <a href='utility.arg.requirements#tab:moveconstructible'>[tab:moveconstructible]</a>)
and
<span class='texttt'>MoveAssignable</span> (Table <a href='utility.arg.requirements#tab:moveassignable'>[tab:moveassignable]</a>).</p></div></div><div class='para' id='swap-3'><div class='marginalizedparent'><a class='marginalized' href='#swap-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Exchanges values stored in two locations.
</p></div></div><p ><span class='indexparent'><a class='index' id='swap'></a></span><code class='itemdecl'>
template &lt;class T, size_t N&gt;
  void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(is_nothrow_swappable_v&lt;T&gt;);
</code></p><div class='itemdescr'></div><div class='para' id='swap-4'><div class='marginalizedparent'><a class='marginalized' href='#swap-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i>
This function shall not participate in overload resolution
unless <span class='texttt'>is_swappable_v&lt;T&gt;</span> is <span class='texttt'>true</span>.</p></div></div><div class='para' id='swap-5'><div class='marginalizedparent'><a class='marginalized' href='#swap-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>a[i]</span> shall be swappable with (<a href='swappable.requirements'>[swappable.requirements]</a>) <span class='texttt'>b[i]</span>
for all <span class='texttt'>i</span> in the range <span class='texttt'>[0, N)</span>.</p></div></div><div class='para' id='swap-6'><div class='marginalizedparent'><a class='marginalized' href='#swap-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> As if by <span class='texttt'>swap_ranges(a, a + N, b)</span>.
</p></div></div></div><div id='exchange'><h3 ><a class='secnum' href='#exchange' style='min-width:103pt'>20.2.3</a> exchange <a class='abbr_ref' href='utility.exchange'>[utility.exchange]</a></h3><p ><span class='indexparent'><a class='index' id='exchange'></a></span><code class='itemdecl'>
template &lt;class T, class U=T&gt; T exchange(T&amp; obj, U&amp;&amp; new_val);
</code></p><div class='itemdescr'></div><div class='para' id='exchange-1'><div class='marginalizedparent'><a class='marginalized' href='#exchange-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Equivalent to:
</p><pre class='codeblock'>
T old_val = std::move(obj);
obj = std::forward&lt;U&gt;(new_val);
return old_val;
</pre></div></div></div><div id='forward'><h3 ><a class='secnum' href='#forward' style='min-width:103pt'>20.2.4</a> forward/move helpers <a class='abbr_ref' href='forward'>[forward]</a></h3><div class='para' id='forward-1'><div class='marginalizedparent'><a class='marginalized' href='#forward-1'>1</a></div><p >The library provides templated helper functions to simplify
applying move semantics to an lvalue and to simplify the implementation
of forwarding functions.</p><p ><span class='indexparent'><a class='index' id='forward'></a></span><code class='itemdecl'>
template &lt;class T&gt; constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp; t) noexcept;
template &lt;class T&gt; constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp;&amp; t) noexcept;
</code></p></div><div class='itemdescr'></div><div class='para' id='forward-2'><div class='marginalizedparent'><a class='marginalized' href='#forward-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>static_cast&lt;T&amp;&amp;&gt;(t)</span>.</p></div></div><div class='para' id='forward-3'><div class='marginalizedparent'><a class='marginalized' href='#forward-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> If the second form is instantiated with an lvalue reference type, the program is ill-formed.</p></div></div><div class='para' id='forward-4'><div class='marginalizedparent'><a class='marginalized' href='#forward-4'>4</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T, class A1, class A2&gt;
shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1, A2&amp;&amp; a2) {
  return shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1), std::forward&lt;A2&gt;(a2)));
}

struct A {
  A(int&amp;, const double&amp;);
};

void g() {
  shared_ptr&lt;A&gt; sp1 = factory&lt;A&gt;(2, 1.414); <span class='comment'>// error: 2 will not bind to <span class='texttt'>int&amp;</span>
</span>  int i = 2;
  shared_ptr&lt;A&gt; sp2 = factory&lt;A&gt;(i, 1.414); <span class='comment'>// OK
</span>}
</pre></div></div><div class='para' id='forward-5'><div class='marginalizedparent'><a class='marginalized' href='#forward-5'>5</a></div><div class='itemdescr'><p >In the first call to <span class='texttt'>factory</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>int</span>, so 2 is forwarded
to <span class='texttt'>A</span>'s constructor as an rvalue.
In the second call to <span class='texttt'>factory</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>int&amp;</span>, so <span class='texttt'>i</span> is forwarded
to <span class='texttt'>A</span>'s constructor as an lvalue. In
both cases, <span class='texttt'>A2</span> is deduced as <span class='texttt'>double</span>, so
1.414 is forwarded to <span class='texttt'>A</span>'s constructor as an rvalue.</p><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='move,function'></a></span><code class='itemdecl'>
template &lt;class T&gt; constexpr remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp;&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='forward-6'><div class='marginalizedparent'><a class='marginalized' href='#forward-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>static_cast&lt;remove_reference_t&lt;T&gt;&amp;&amp;&gt;(t)</span>.</p></div></div><div class='para' id='forward-7'><div class='marginalizedparent'><a class='marginalized' href='#forward-7'>7</a></div><div class='itemdescr'><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T, class A1&gt;
shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) {
  return shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1)));
}

struct A {
  A();
  A(const A&amp;);  <span class='comment'>// copies from lvalues
</span>  A(A&amp;&amp;);       <span class='comment'>// moves from rvalues
</span>};

void g() {
  A a;
  shared_ptr&lt;A&gt; sp1 = factory&lt;A&gt;(a);              <span class='comment'>// “<span class='texttt'>a</span>” binds to <span class='texttt'>A(const A&amp;)</span>
</span>  shared_ptr&lt;A&gt; sp1 = factory&lt;A&gt;(std::move(a));   <span class='comment'>// “<span class='texttt'>a</span>” binds to <span class='texttt'>A(A&amp;&amp;)</span>
</span>}
</pre></div></div><div class='para' id='forward-8'><div class='marginalizedparent'><a class='marginalized' href='#forward-8'>8</a></div><div class='itemdescr'><p >In the first call to <span class='texttt'>factory</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>A&amp;</span>, so <span class='texttt'>a</span> is forwarded
as a non-const lvalue. This binds to the constructor <span class='texttt'>A(const A&amp;)</span>,
which copies the value from <span class='texttt'>a</span>.
In the second call to <span class='texttt'>factory</span>, because of the call
<span class='texttt'>std::move(a)</span>,
<span class='texttt'>A1</span> is deduced as <span class='texttt'>A</span>, so <span class='texttt'>a</span> is forwarded
as an rvalue. This binds to the constructor <span class='texttt'>A(A&amp;&amp;)</span>,
which moves the value from <span class='texttt'>a</span>.</p><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='move_if_noexcept'></a></span><code class='itemdecl'>
template &lt;class T&gt; constexpr conditional_t&lt;
  !is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; is_copy_constructible_v&lt;T&gt;,
  const T&amp;, T&amp;&amp;&gt; move_if_noexcept(T&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='forward-9'><div class='marginalizedparent'><a class='marginalized' href='#forward-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>std::move(x)</span>.
</p></div></div></div><div id='as_const'><h3 ><a class='secnum' href='#as_const' style='min-width:103pt'>20.2.5</a> Function template <span class='texttt'>as_const</span> <a class='abbr_ref' href='utility.as_const'>[utility.as_const]</a></h3><p ><span class='indexparent'><a class='index' id='as_const'></a></span><code class='itemdecl'>
template &lt;class T&gt; constexpr add_const_t&lt;T&gt;&amp; as_const(T&amp; t) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='as_const-1'><div class='marginalizedparent'><a class='marginalized' href='#as_const-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>t</span>.
</p></div></div></div><div id='declval'><h3 ><a class='secnum' href='#declval' style='min-width:103pt'>20.2.6</a> Function template <span class='texttt'>declval</span> <a class='abbr_ref' href='declval'>[declval]</a></h3><div class='para' id='declval-1'><div class='marginalizedparent'><a class='marginalized' href='#declval-1'>1</a></div><p >The library provides the function template <span class='texttt'>declval</span> to simplify the definition of
expressions which occur as unevaluated operands (Clause <a href='expr'>[expr]</a>).</p><p ><span class='indexparent'><a class='index' id='declval'></a></span><code class='itemdecl'>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; declval() noexcept;  <span class='comment'>// as unevaluated operand
</span></code></p></div><div class='itemdescr'></div><div class='para' id='declval-2'><div class='marginalizedparent'><a class='marginalized' href='#declval-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> If this function is odr-used (<a href='basic.def.odr'>[basic.def.odr]</a>), the program is ill-formed.</p></div></div><div class='para' id='declval-3'><div class='marginalizedparent'><a class='marginalized' href='#declval-3'>3</a></div><div class='itemdescr'><p ><i>Remarks:</i> The template parameter <span class='texttt'>T</span> of <span class='texttt'>declval</span> may be an incomplete type.
</p></div></div><div class='para' id='declval-4'><div class='marginalizedparent'><a class='marginalized' href='#declval-4'>4</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class To, class From&gt;
  decltype(static_cast&lt;To&gt;(declval&lt;From&gt;())) convert(From&amp;&amp;);
</pre><p >declares a function template <span class='texttt'>convert</span> which only participates in overloading if the
type <span class='texttt'>From</span> can be explicitly converted to type <span class='texttt'>To</span>. For another example see class
template <span class='texttt'>common_type</span> (<a href='meta.trans.other'>[meta.trans.other]</a>).
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><div id='to.chars'><h3 ><a class='secnum' href='#to.chars' style='min-width:103pt'>20.2.7</a> Primitive numeric output conversion <a class='abbr_ref' href='utility.to.chars'>[utility.to.chars]</a></h3><div class='para' id='to.chars-1'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-1'>1</a></div><p >All functions named <span class='texttt'>to_chars</span>
convert <span class='texttt'>value</span> into a character string
by successively filling the range
<span class='texttt'>[first, last)</span>,
where <span class='texttt'>[first, last)</span> is required to be a valid range.
If the member <span class='texttt'>ec</span>
of the return value
is such that the value,
when converted to <span class='texttt'>bool</span>,
is <span class='texttt'>false</span>,
the conversion was successful
and the member <span class='texttt'>ptr</span>
is the one-past-the-end pointer of the characters written.
Otherwise,
the member <span class='texttt'>ec</span> has the value <span class='texttt'>errc::value_too_large</span>,
the member <span class='texttt'>ptr</span> has the value <span class='texttt'>last</span>,
and the contents of the range <span class='texttt'>[first, last)</span> are unspecified.</p></div><div class='para' id='to.chars-2'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-2'>2</a></div><p >The functions that take a floating-point <span class='texttt'>value</span>
but not a <span class='texttt'>precision</span> parameter
ensure that the string representation
consists of the smallest number of characters
such that
there is at least one digit before the radix point (if present) and
parsing the representation using the corresponding <span class='texttt'>from_chars</span> function
recovers <span class='texttt'>value</span> exactly.
[&nbsp;<i>Note:</i>
This guarantee applies only if
<span class='texttt'>to_chars</span> and <span class='texttt'>from_chars</span>
are executed on the same implementation.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='to.chars-3'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-3'>3</a></div><p >The functions taking a <span class='texttt'>chars_format</span> parameter
determine the conversion specifier for <span class='texttt'>printf</span> as follows:
The conversion specifier is
<span class='texttt'>f</span> if <span class='texttt'>fmt</span> is <span class='texttt'>chars_format::fixed</span>,
<span class='texttt'>e</span> if <span class='texttt'>fmt</span> is <span class='texttt'>chars_format::scientific</span>,
<span class='texttt'>a</span> (without leading <span class='texttt'>"0x"</span> in the result)
if <span class='texttt'>fmt</span> is <span class='texttt'>chars_format::hex</span>,
and
<span class='texttt'>g</span> if <span class='texttt'>fmt</span> is <span class='texttt'>chars_format::general</span>.</p><p ><span class='indexparent'><a class='index' id='to_chars'></a></span><code class='itemdecl'>
to_chars_result to_chars(char* first, char* last, <i><span class='texttt'>see below</span></i> value, int base = 10);
</code></p></div><div class='itemdescr'></div><div class='para' id='to.chars-4'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>base</span> has a value between 2 and 36 (inclusive).</p></div></div><div class='para' id='to.chars-5'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> The value of <span class='texttt'>value</span> is converted
to a string of digits in the given base
(with no redundant leading zeroes).
Digits in the range 10..35 (inclusive)
are represented as lowercase characters <span class='texttt'>a</span>..<span class='texttt'>z</span>.
If <span class='texttt'>value</span> is less than zero,
the representation starts with a minus sign.</p></div></div><div class='para' id='to.chars-6'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='to.chars-7'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The implementation shall provide overloads
for all signed and unsigned integer types
and <span class='texttt'>char</span>
as the type of the parameter <span class='texttt'>value</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_chars'></a></span><code class='itemdecl'>
to_chars_result to_chars(char* first, char* last, float value);
to_chars_result to_chars(char* first, char* last, double value);
to_chars_result to_chars(char* first, char* last, long double value);
</code></p><div class='itemdescr'></div><div class='para' id='to.chars-8'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-8'>8</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>value</span> is converted to a string
in the style of <span class='texttt'>printf</span>
in the <span class='texttt'>"C"</span> locale.
The conversion specifier is <span class='texttt'>f</span> or <span class='texttt'>e</span>,
chosen according to the requirement for a shortest representation
(see above);
a tie is resolved in favor of <span class='texttt'>f</span>.</p></div></div><div class='para' id='to.chars-9'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-9'>9</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_chars'></a></span><code class='itemdecl'>
to_chars_result to_chars(char* first, char* last, float value, chars_format fmt);
to_chars_result to_chars(char* first, char* last, double value, chars_format fmt);
to_chars_result to_chars(char* first, char* last, long double value, chars_format fmt);
</code></p><div class='itemdescr'></div><div class='para' id='to.chars-10'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-10'>10</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>fmt</span> has the value of
one of the enumerators of <span class='texttt'>chars_format</span>.</p></div></div><div class='para' id='to.chars-11'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>value</span> is converted to a string
in the style of <span class='texttt'>printf</span>
in the <span class='texttt'>"C"</span> locale.</p></div></div><div class='para' id='to.chars-12'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-12'>12</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='indexparent'><a class='index' id='to_chars'></a></span><code class='itemdecl'>
to_chars_result to_chars(char* first, char* last, float value,
                         chars_format fmt, int precision);
to_chars_result to_chars(char* first, char* last, double value,
                         chars_format fmt, int precision);
to_chars_result to_chars(char* first, char* last, long double value,
                         chars_format fmt, int precision);
</code></p><div class='itemdescr'></div><div class='para' id='to.chars-13'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>fmt</span> has the value of
one of the enumerators of <span class='texttt'>chars_format</span>.</p></div></div><div class='para' id='to.chars-14'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>value</span> is converted to a string
in the style of <span class='texttt'>printf</span>
in the <span class='texttt'>"C"</span> locale
with the given precision.</p></div></div><div class='para' id='to.chars-15'><div class='marginalizedparent'><a class='marginalized' href='#to.chars-15'>15</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='textsc'>See also:</span> ISO C 7.21.6.1.</p></div><div id='from.chars'><h3 ><a class='secnum' href='#from.chars' style='min-width:103pt'>20.2.8</a> Primitive numeric input conversion <a class='abbr_ref' href='utility.from.chars'>[utility.from.chars]</a></h3><div class='para' id='from.chars-1'><div class='marginalizedparent'><a class='marginalized' href='#from.chars-1'>1</a></div><p >All functions named <span class='texttt'>from_chars</span>
analyze the string <span class='texttt'>[first, last)</span>
for a pattern,
where <span class='texttt'>[first, last)</span> is required to be a valid range.
If no characters match the pattern,
<span class='texttt'>value</span> is unmodified,
the member <span class='texttt'>ptr</span> of the return value is <span class='texttt'>first</span> and
the member <span class='texttt'>ec</span> is equal to <span class='texttt'>errc::invalid_argument</span>.
Otherwise,
the characters matching the pattern
are interpreted as a representation
of a value of the type of <span class='texttt'>value</span>.
The member <span class='texttt'>ptr</span>
of the return value
points to the first character
not matching the pattern,
or has the value <span class='texttt'>last</span>
if all characters match.
If the parsed value
is not in the range
representable by the type of <span class='texttt'>value</span>,
<span class='texttt'>value</span> is unmodified and
the member <span class='texttt'>ec</span> of the return value
is equal to <span class='texttt'>errc::result_out_of_range</span>.
Otherwise,
<span class='texttt'>value</span> is set to the parsed value and
the member <span class='texttt'>ec</span> is set
such that the conversion to <span class='texttt'>bool</span> yields <span class='texttt'>false</span>.</p><p ><span class='indexparent'><a class='index' id='from_chars'></a></span><code class='itemdecl'>
from_chars_result from_chars(const char* first, const char* last,
                             <i><span class='texttt'>see below</span></i>&amp; value, int base = 10);
</code></p></div><div class='itemdescr'></div><div class='para' id='from.chars-2'><div class='marginalizedparent'><a class='marginalized' href='#from.chars-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>base</span> has a value between 2 and 36 (inclusive).</p></div></div><div class='para' id='from.chars-3'><div class='marginalizedparent'><a class='marginalized' href='#from.chars-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> The pattern is the expected form of the subject sequence
in the <span class='texttt'>"C"</span> locale
for the given non-zero base,
as described for <span class='texttt'>strtol</span>,
except that no <span class='texttt'>"0x"</span> or <span class='texttt'>"0X"</span> prefix shall appear
if the value of <span class='texttt'>base</span> is 16,
and except that a minus sign
is the only sign that may appear,
and only if <span class='texttt'>value</span> has a signed type.</p></div></div><div class='para' id='from.chars-4'><div class='marginalizedparent'><a class='marginalized' href='#from.chars-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.</p></div></div><div class='para' id='from.chars-5'><div class='marginalizedparent'><a class='marginalized' href='#from.chars-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i>
The implementation shall provide overloads
for all signed and unsigned integer types
and <span class='texttt'>char</span>
as the referenced type of the parameter <span class='texttt'>value</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='from_chars'></a></span><code class='itemdecl'>
from_chars_result from_chars(const char* first, const char* last, float&amp; value,
                             chars_format fmt = chars_format::general);
from_chars_result from_chars(const char* first, const char* last, double&amp; value,
                             chars_format fmt = chars_format::general);
from_chars_result from_chars(const char* first, const char* last, long double&amp; value,
                             chars_format fmt = chars_format::general);
</code></p><div class='itemdescr'></div><div class='para' id='from.chars-6'><div class='marginalizedparent'><a class='marginalized' href='#from.chars-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>fmt</span> has the value of
one of the enumerators of <span class='texttt'>chars_format</span>.</p></div></div><div class='para' id='from.chars-7'><div class='marginalizedparent'><a class='marginalized' href='#from.chars-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> The pattern is the expected form of the subject sequence
in the <span class='texttt'>"C"</span> locale,
as described for <span class='texttt'>strtod</span>,
except that
</p><ul class='itemize'><li id='from.chars-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#from.chars-7.1'>(7.1)</a></div><p >the only sign that may appear is a minus sign;
</p></li><li id='from.chars-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#from.chars-7.2'>(7.2)</a></div><p >if <span class='texttt'>fmt</span> has <span class='texttt'>chars_format::scientific</span> set
but not <span class='texttt'>chars_format::fixed</span>,
the otherwise optional exponent part shall appear;
</p></li><li id='from.chars-7.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#from.chars-7.3'>(7.3)</a></div><p >if <span class='texttt'>fmt</span> has <span class='texttt'>chars_format::fixed</span> set
but not <span class='texttt'>chars_format::scientific</span>,
the optional exponent part shall not appear; and
</p></li><li id='from.chars-7.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#from.chars-7.4'>(7.4)</a></div><p >if <span class='texttt'>fmt</span> is <span class='texttt'>chars_format::hex</span>,
the prefix <span class='texttt'>"0x"</span> or <span class='texttt'>"0X"</span> is assumed.
[&nbsp;<i>Example:</i>
The string <span class='texttt'>0x123</span>
is parsed to have the value
<span class='texttt'>0</span>
with remaining characters <span class='texttt'>x123</span>.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></li></ul><p >In any case, the resulting <span class='texttt'>value</span> is one of
at most two floating-point values
closest to the value of the string matching the pattern.</p></div></div><div class='para' id='from.chars-8'><div class='marginalizedparent'><a class='marginalized' href='#from.chars-8'>8</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><span class='textsc'>See also:</span> ISO C 7.22.1.3, ISO C 7.22.1.4.</p></div></div></div></body></html>