<!DOCTYPE html><html lang='en'><head><title>[over.dcl]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><div id='over.dcl'><h2 ><a class='secnum' style='min-width:88pt'>13.2</a> Declaration matching <a class='abbr_ref'>[over.dcl]</a></h2><p ><span class='indexparent'><a class='index' id='overloading,declaration_matching'></a></span><span class='indexparent'><a class='index' id='scope,overloading_and'></a></span><span class='indexparent'><a class='index' id='base_class,overloading_and'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/overloading.tex#L308'>#</a></div><p >Two function declarations of the same name refer to the same function if they
are in the same scope and have equivalent parameter declarations (<a href='over.load'>[over.load]</a>).
A function member of a derived class is
<i>not</i>
in the same scope as a function member of the same name in a base class.
[ <i>Example:</i></p><pre class='codeblock'>
struct B {
  int f(int);
};

struct D : B {
  int f(const char*);
};</pre><p ><span class='indexparent'><a class='index' id='name_hiding,function'></a></span><span class='indexparent'><a class='index' id='name_hiding,overloading_versus'></a></span>Here
<span class='texttt'>D::f(const char*)</span>
hides
<span class='texttt'>B::f(int)</span>
rather than overloading it.</p><p ><span class='indexparent'><a class='index' id='Ben'></a></span></p><pre class='codeblock'>
void h(D* pd) {
  pd-&gt;f(1);                     <span class='comment'>// error:
</span>                                <span class='comment'>// <span class='texttt'>D::f(const char*)</span> hides <span class='texttt'>B::f(int)</span>
</span>  pd-&gt;B::f(1);                  <span class='comment'>// OK
</span>  pd-&gt;f("Ben");                 <span class='comment'>// OK, calls <span class='texttt'>D::f</span>
</span>}</pre><p ><i> — end example</i> ]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/overloading.tex#L345'>#</a></div><p >A locally declared function is not in the same scope as a function in
a containing scope.
[ <i>Example:</i></p><pre class='codeblock'>
void f(const char*);
void g() {
  extern void f(int);
  f("asdf");                    <span class='comment'>// error: <span class='texttt'>f(int)</span> hides <span class='texttt'>f(const char*)</span>
</span>                                <span class='comment'>// so there is no <span class='texttt'>f(const char*)</span> in this scope
</span>}

void caller () {
  extern void callee(int, int);
  {
    extern void callee(int);    <span class='comment'>// hides <span class='texttt'>callee(int, int)</span>
</span>    callee(88, 99);             <span class='comment'>// error: only <span class='texttt'>callee(int)</span> in scope
</span>  }
}</pre><p ><i> — end example</i> ]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/1357aed3958027db9fcf1fb0e91d06a7c3d52658/source/overloading.tex#L368'>#</a></div><p ><span class='indexparent'><a class='index' id='access_control,overloading_and'></a></span><span class='indexparent'><a class='index' id='overloading,access_control_and'></a></span>Different versions of an overloaded member function can be given different
access rules.
[ <i>Example:</i></p><pre class='codeblock'>
class buffer {
private:
    char* p;
    int size;
protected:
    buffer(int s, char* store) { size = s; p = store; }
public:
    buffer(int s) { p = new char[size = s]; }
};</pre><p ><i> — end example</i> ]</p></div></div></div></body></html>