<!DOCTYPE html><html lang='en'><head><title>[intro.object]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>1</a> General <a class='abbr_ref' href='./#intro'>[intro]</a></h1><div id='intro.object'><h2 ><a class='secnum' style='min-width:88pt'>1.8</a> The C++ object model <a class='abbr_ref'>[intro.object]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='object_model'></a></span>The constructs in a C++ program create, destroy, refer to, access, and
manipulate objects.
An <a class='hidden_link' href='#def:object' id='def:object'><i>object</i></a> is created
by a definition (<a href='basic.def'>[basic.def]</a>),
by a <i ><a href='expr.new#nt:new-expression'>new-expression</a></i> (<a href='expr.new'>[expr.new]</a>),
when implicitly changing the active member of a union (<a href='class.union'>[class.union]</a>),
or
when a temporary object is created (<a href='conv.rval'>[conv.rval]</a>, <a href='class.temporary'>[class.temporary]</a>). 
An object occupies a region of storage
in its period of construction (<a href='class.cdtor'>[class.cdtor]</a>),
throughout its lifetime (<a href='basic.life'>[basic.life]</a>),
and
in its period of destruction (<a href='class.cdtor'>[class.cdtor]</a>).
[&nbsp;<i>Note:</i> A function is not an object, regardless of whether or not it
occupies storage in the way that objects do. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
The properties of an
object are determined when the object is created. An object can have a
name (Clause <a href='basic'>[basic]</a>). An object has a storage
duration (<a href='basic.stc'>[basic.stc]</a>) which influences its
lifetime (<a href='basic.life'>[basic.life]</a>). An object has a
type (<a href='basic.types'>[basic.types]</a>). The term <a class='hidden_link' href='#def:object_type' id='def:object_type'><i>object type</i></a> refers to
the type with which the object is created.
Some objects are
polymorphic (<a href='class.virtual'>[class.virtual]</a>); the implementation
generates information associated with each such object that makes it
possible to determine that object's type during program execution. For
other objects, the interpretation of the values found therein is
determined by the type of the <i ><a href='expr.comma#nt:expression'>expressions</a></i> (Clause <a href='expr'>[expr]</a>)
used to access them.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='subobject'></a></span>Objects can contain other objects, called <a class='hidden_link' href='#def:subobject' id='def:subobject'><i>subobjects</i></a>.
A subobject can be
a <a class='hidden_link' href='#def:member_subobject' id='def:member_subobject'><i>member subobject</i></a> (<a href='class.mem'>[class.mem]</a>), a <a class='hidden_link' href='#def:base_class_subobject' id='def:base_class_subobject'><i>base class subobject</i></a>
(Clause <a href='class.derived'>[class.derived]</a>), or an array element.
<span class='indexparent'><a class='index' id='object,complete'></a></span>An object that is not a subobject of any other object is called a <a class='hidden_link' href='#def:complete_object' id='def:complete_object'><i>complete
object</i></a>.
If an object is created
in storage associated with a member subobject or array element <i>e</i>
(which may or may not be within its lifetime),
the created object
is a subobject of <i>e</i>'s containing object if:
</p><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><p >the lifetime of <i>e</i>'s containing object has begun and not ended, and
</p></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><p >the storage for the new object exactly overlays the storage location associated with <i>e</i>, and
</p></li><li id='2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.3'>(2.3)</a></div><p >the new object is of the same type as <i>e</i> (ignoring cv-qualification).
</p></li></ul><p >[&nbsp;<i>Note:</i>
If the subobject contains a reference member or a <span class='texttt'>const</span> subobject,
the name of the original subobject cannot be used to access the new object (<a href='basic.life'>[basic.life]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
struct X { const int n; };
union U { X x; float f; };
void tong() {
  U u = {{ 1 }};
  u.f = 5.f;                          <span class='comment'>// OK, creates new subobject of <span class='texttt'>u</span> (<a href='class.union'>[class.union]</a>)
</span>  X *p = new (&amp;u.x) X {2};            <span class='comment'>// OK, creates new subobject of <span class='texttt'>u</span>
</span>  assert(p-&gt;n == 2);                  <span class='comment'>// OK
</span>  assert(*std::launder(&amp;u.x.n) == 2); <span class='comment'>// OK
</span>  assert(u.x.n == 2);                 <span class='comment'>// undefined behavior, <span class='texttt'>u.x</span> does not name new subobject
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='object,providing_storage_for'></a></span>If a complete object is created (<a href='expr.new'>[expr.new]</a>)
in storage associated with another object <i>e</i>
of type “array of <span class='math'><span class='mathalpha'>N</span></span> <span class='texttt'>unsigned char</span>”,
that array <a class='hidden_link' href='#def:provides_storage' id='def:provides_storage'><i>provides storage</i></a>
for the created object if:
</p><ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><p >the lifetime of <i>e</i> has begun and not ended, and
</p></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><p >the storage for the new object fits entirely within <i>e</i>, and
</p></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><p >there is no smaller array object that satisfies these constraints.
</p></li></ul><p >[&nbsp;<i>Note:</i>
If that portion of the array
previously provided storage for another object,
the lifetime of that object ends
because its storage was reused (<a href='basic.life'>[basic.life]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template&lt;typename ...T&gt;
struct AlignedUnion {
  alignas(T...) unsigned char data[max(sizeof(T)...)];
};
int f() {
  AlignedUnion&lt;int, char&gt; au;
  int *p = new (au.data) int;     <span class='comment'>// OK, <span class='texttt'>au.data</span> provides storage
</span>  char *c = new (au.data) char(); <span class='comment'>// OK, ends lifetime of <span class='texttt'>*p</span>
</span>  char *d = new (au.data + 1) char();
  return *c + *d; <span class='comment'>// OK
</span>}

struct A { unsigned char a[32]; };
struct B { unsigned char b[16]; };
A a;
B *b = new (a.a + 8) B;      <span class='comment'>// <span class='texttt'>a.a</span> provides storage for <span class='texttt'>*b</span>
</span>int *p = new (b-&gt;b + 4) int; <span class='comment'>// <span class='texttt'>b-&gt;b</span> provides storage for <span class='texttt'>*p</span>
</span>                             <span class='comment'>// <span class='texttt'>a.a</span> does not provide storage for <span class='texttt'>*p</span> (directly),
</span>                             <span class='comment'>// but <span class='texttt'>*p</span> is nested within <span class='texttt'>a</span> (see below)
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p ><span class='indexparent'><a class='index' id='object,nested_within'></a></span>An object <i>a</i> is <a class='hidden_link' href='#def:nested_within' id='def:nested_within'><i>nested within</i></a> another object <i>b</i> if:
</p><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><p ><i>a</i> is a subobject of <i>b</i>, or
</p></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><p ><i>b</i> provides storage for <i>a</i>, or
</p></li><li id='4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.3'>(4.3)</a></div><p >there exists an object <i>c</i>
where <i>a</i> is nested within <i>c</i>,
and <i>c</i> is nested within <i>b</i>.
</p></li></ul></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >For every object <span class='texttt'>x</span>, there is some object called the
<a class='hidden_link' href='#def:complete_object_of' id='def:complete_object_of'><i>complete object of</i></a> <span class='texttt'>x</span>, determined as follows:</p><ul class='itemize'><li id='5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.1'>(5.1)</a></div><p >If <span class='texttt'>x</span> is a complete object, then the complete object
of <span class='texttt'>x</span> is itself.</p></li><li id='5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#5.2'>(5.2)</a></div><p >Otherwise, the complete object of <span class='texttt'>x</span> is the complete object
of the (unique) object that contains <span class='texttt'>x</span>.</p></li></ul></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >If a complete object, a data member (<a href='class.mem'>[class.mem]</a>), or an array element is of
class type, its type is considered the <a class='hidden_link' href='#def:most_derived_class' id='def:most_derived_class'><i>most derived
class</i></a>, to distinguish it from the class type of any base class subobject;
an object of a most derived class type or of a non-class type is called a
<a class='hidden_link' href='#def:most_derived_object' id='def:most_derived_object'><i>most derived object</i></a>.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p ><span class='indexparent'><a class='index' id='most_derived_object,bit-field'></a></span>Unless it is a bit-field (<a href='class.bit'>[class.bit]</a>), a most derived object shall have a
non-zero size and shall occupy one or more bytes of storage. Base class
subobjects may have zero size. An object of trivially copyable or
standard-layout type (<a href='basic.types'>[basic.types]</a>) shall occupy contiguous bytes of
storage.</p></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p ><span class='indexparent'><a class='index' id='most_derived_object,bit-field'></a></span><span class='indexparent'><a class='index' id='most_derived_object,zero_size_subobject'></a></span>Unless an object is a bit-field or a base class subobject of zero size, the
address of that object is the address of the first byte it occupies.
Two objects <i>a</i> and <i>b</i>
with overlapping lifetimes
that are not bit-fields
may have the same address
if one is nested within the other,
or
if at least one is a base class subobject of zero size
and they are of different types;
otherwise, they have distinct addresses.<a class='footnotenum' href='#footnote-5'>5</a></p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
static const char test1 = 'x';
static const char test2 = 'x';
const bool b = &amp;test1 != &amp;test2;      <span class='comment'>// always <span class='texttt'>true</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >[&nbsp;<i>Note:</i> 
C++  provides a variety of fundamental types and several ways of composing
new types from existing types (<a href='basic.types'>[basic.types]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]<span class='indexparent'><a class='index' id='object_model'></a></span></p></div><div class='footnote' id='footnote-5'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-5'>5)</a></div><p >Under the “as-if” rule an
implementation is allowed to store two objects at the same machine address or
not store an object at all if the program cannot observe the
difference (<a href='intro.execution'>[intro.execution]</a>).</p></div></div></div></body></html>