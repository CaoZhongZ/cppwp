<!DOCTYPE html><html lang='en'><head><title>[depr.func.adaptor.binding]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='annexnum' style='min-width:73pt'>Annex D&emsp;(normative)</a> Compatibility features <a class='abbr_ref' href='./#depr'>[depr]</a></h1><div id='depr.func.adaptor.binding'><h2 ><a class='secnum' style='min-width:88pt'>D.7</a> Old adaptable function bindings <a class='abbr_ref'>[depr.func.adaptor.binding]</a></h2><div id='depr.weak.result_type'><h3 ><a class='secnum' href='#depr.weak.result_type' style='min-width:103pt'>D.7.1</a> Weak result types <a class='abbr_ref' href='depr.weak.result_type'>[depr.weak.result_type]</a></h3><div class='para' id='depr.weak.result_type-1'><div class='marginalizedparent'><a class='marginalized' href='#depr.weak.result_type-1'>1</a></div><p >A call wrapper (<a href='func.def'>[func.def]</a>) may have a <a class='hidden_link' href='#def:weak_result_type' id='def:weak_result_type'><i>weak result type</i></a>.
If it does, the type of its member type <span class='texttt'>result_type</span>
is based on the type <span class='texttt'>T</span> of the wrapper's target object:
</p><ul class='itemize'><li id='depr.weak.result_type-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#depr.weak.result_type-1.1'>(1.1)</a></div><p >if <span class='texttt'>T</span> is a pointer to function type,
<span class='texttt'>result_type</span> shall be a synonym for the return type of <span class='texttt'>T</span>;
</p></li><li id='depr.weak.result_type-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#depr.weak.result_type-1.2'>(1.2)</a></div><p >if <span class='texttt'>T</span> is a pointer to member function,
<span class='texttt'>result_type</span> shall be a synonym for the return type of <span class='texttt'>T</span>;
</p></li><li id='depr.weak.result_type-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#depr.weak.result_type-1.3'>(1.3)</a></div><p >if <span class='texttt'>T</span> is a class type
and the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>T::result_type</span> is valid and denotes a type (<a href='temp.deduct'>[temp.deduct]</a>),
then <span class='texttt'>result_type</span> shall be a synonym for <span class='texttt'>T::result_type</span>;
</p></li><li id='depr.weak.result_type-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#depr.weak.result_type-1.4'>(1.4)</a></div><p >otherwise <span class='texttt'>result_type</span> shall not be defined.
</p></li></ul></div></div><div id='depr.func.adaptor.typedefs'><h3 ><a class='secnum' href='#depr.func.adaptor.typedefs' style='min-width:103pt'>D.7.2</a> Typedefs to support function binders <a class='abbr_ref' href='depr.func.adaptor.typedefs'>[depr.func.adaptor.typedefs]</a></h3><div class='para' id='depr.func.adaptor.typedefs-1'><div class='marginalizedparent'><a class='marginalized' href='#depr.func.adaptor.typedefs-1'>1</a></div><p >To enable old function adaptors to manipulate function objects
that take one or two arguments,
many of the function objects in this standard
correspondingly provide <i ><a href='dcl.typedef#nt:typedef-name'>typedef-names</a></i>
<span class='texttt'>argument_type</span> and <span class='texttt'>result_type</span>
for function objects that take one argument and
<span class='texttt'>first_argument_type</span>, <span class='texttt'>second_argument_type</span>, and <span class='texttt'>result_type</span>
for function objects that take two arguments.</p></div><div class='para' id='depr.func.adaptor.typedefs-2'><div class='marginalizedparent'><a class='marginalized' href='#depr.func.adaptor.typedefs-2'>2</a></div><p >The following member names are defined in addition to names specified in Clause <a href='function.objects'>[function.objects]</a>:</p><p ><span class='indexparent'><a class='index' id='result_type,owner_less'></a></span><span class='indexparent'><a class='index' id='owner_less,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,owner_less'></a></span><span class='indexparent'><a class='index' id='owner_less,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,owner_less'></a></span><span class='indexparent'><a class='index' id='owner_less,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,owner_less'></a></span><span class='indexparent'><a class='index' id='owner_less,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,owner_less'></a></span><span class='indexparent'><a class='index' id='owner_less,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,owner_less'></a></span><span class='indexparent'><a class='index' id='owner_less,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,plus'></a></span><span class='indexparent'><a class='index' id='plus,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,plus'></a></span><span class='indexparent'><a class='index' id='plus,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,plus'></a></span><span class='indexparent'><a class='index' id='plus,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,minus'></a></span><span class='indexparent'><a class='index' id='minus,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,minus'></a></span><span class='indexparent'><a class='index' id='minus,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,minus'></a></span><span class='indexparent'><a class='index' id='minus,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,multiplies'></a></span><span class='indexparent'><a class='index' id='multiplies,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,multiplies'></a></span><span class='indexparent'><a class='index' id='multiplies,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,multiplies'></a></span><span class='indexparent'><a class='index' id='multiplies,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,divides'></a></span><span class='indexparent'><a class='index' id='divides,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,divides'></a></span><span class='indexparent'><a class='index' id='divides,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,divides'></a></span><span class='indexparent'><a class='index' id='divides,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,modulus'></a></span><span class='indexparent'><a class='index' id='modulus,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,modulus'></a></span><span class='indexparent'><a class='index' id='modulus,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,modulus'></a></span><span class='indexparent'><a class='index' id='modulus,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,negate'></a></span><span class='indexparent'><a class='index' id='negate,result_type'></a></span><span class='indexparent'><a class='index' id='argument_type,negate'></a></span><span class='indexparent'><a class='index' id='negate,argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,equal_to'></a></span><span class='indexparent'><a class='index' id='equal_to,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,equal_to'></a></span><span class='indexparent'><a class='index' id='equal_to,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,equal_to'></a></span><span class='indexparent'><a class='index' id='equal_to,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,not_equal_to'></a></span><span class='indexparent'><a class='index' id='not_equal_to,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,not_equal_to'></a></span><span class='indexparent'><a class='index' id='not_equal_to,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,not_equal_to'></a></span><span class='indexparent'><a class='index' id='not_equal_to,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,greater'></a></span><span class='indexparent'><a class='index' id='greater,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,greater'></a></span><span class='indexparent'><a class='index' id='greater,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,greater'></a></span><span class='indexparent'><a class='index' id='greater,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,less'></a></span><span class='indexparent'><a class='index' id='less,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,less'></a></span><span class='indexparent'><a class='index' id='less,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,less'></a></span><span class='indexparent'><a class='index' id='less,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,greater_equal'></a></span><span class='indexparent'><a class='index' id='greater_equal,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,greater_equal'></a></span><span class='indexparent'><a class='index' id='greater_equal,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,greater_equal'></a></span><span class='indexparent'><a class='index' id='greater_equal,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,less_equal'></a></span><span class='indexparent'><a class='index' id='less_equal,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,less_equal'></a></span><span class='indexparent'><a class='index' id='less_equal,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,less_equal'></a></span><span class='indexparent'><a class='index' id='less_equal,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,logical_and'></a></span><span class='indexparent'><a class='index' id='logical_and,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,logical_and'></a></span><span class='indexparent'><a class='index' id='logical_and,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,logical_and'></a></span><span class='indexparent'><a class='index' id='logical_and,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,logical_or'></a></span><span class='indexparent'><a class='index' id='logical_or,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,logical_or'></a></span><span class='indexparent'><a class='index' id='logical_or,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,logical_or'></a></span><span class='indexparent'><a class='index' id='logical_or,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,logical_not'></a></span><span class='indexparent'><a class='index' id='logical_not,result_type'></a></span><span class='indexparent'><a class='index' id='argument_type,logical_not'></a></span><span class='indexparent'><a class='index' id='logical_not,argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,bit_and'></a></span><span class='indexparent'><a class='index' id='bit_and,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,bit_and'></a></span><span class='indexparent'><a class='index' id='bit_and,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,bit_and'></a></span><span class='indexparent'><a class='index' id='bit_and,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,bit_or'></a></span><span class='indexparent'><a class='index' id='bit_or,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,bit_or'></a></span><span class='indexparent'><a class='index' id='bit_or,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,bit_or'></a></span><span class='indexparent'><a class='index' id='bit_or,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,bit_xor'></a></span><span class='indexparent'><a class='index' id='bit_xor,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,bit_xor'></a></span><span class='indexparent'><a class='index' id='bit_xor,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,bit_xor'></a></span><span class='indexparent'><a class='index' id='bit_xor,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,bit_not'></a></span><span class='indexparent'><a class='index' id='bit_not,result_type'></a></span><span class='indexparent'><a class='index' id='argument_type,bit_not'></a></span><span class='indexparent'><a class='index' id='bit_not,argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,function'></a></span><span class='indexparent'><a class='index' id='function,result_type'></a></span><span class='indexparent'><a class='index' id='argument_type,function'></a></span><span class='indexparent'><a class='index' id='function,argument_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,function'></a></span><span class='indexparent'><a class='index' id='function,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,function'></a></span><span class='indexparent'><a class='index' id='function,second_argument_type'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; struct owner_less&lt;shared_ptr&lt;T&gt;&gt; {
    using result_type          = bool;
    using first_argument_type  = shared_ptr&lt;T&gt;;
    using second_argument_type = shared_ptr&lt;T&gt;;
  };

  template&lt;class T&gt; struct owner_less&lt;weak_ptr&lt;T&gt;&gt; {
    using result_type          = bool;
    using first_argument_type  = weak_ptr&lt;T&gt;;
    using second_argument_type = weak_ptr&lt;T&gt;;
  };

  template &lt;class T&gt; class reference_wrapper {
  public :
    using result_type          = <i><span class='texttt'>see below</span></i>; <span class='comment'>// not always defined
</span>    using argument_type        = <i><span class='texttt'>see below</span></i>; <span class='comment'>// not always defined
</span>    using first_argument_type  = <i><span class='texttt'>see below</span></i>; <span class='comment'>// not always defined
</span>    using second_argument_type = <i><span class='texttt'>see below</span></i>; <span class='comment'>// not always defined
</span>  };

  template &lt;class T&gt; struct plus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct minus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct multiplies {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct divides {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct modulus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct negate {
    using argument_type = T;
    using result_type   = T;
  };

  template &lt;class T&gt; struct equal_to {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct not_equal_to {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct greater {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct less {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct greater_equal {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct less_equal {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct logical_and {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct logical_or {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template &lt;class T&gt; struct logical_not {
    using argument_type = T;
    using result_type   = bool;
  };

  template &lt;class T&gt; struct bit_and {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct bit_or {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct bit_xor {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template &lt;class T&gt; struct bit_not {
    using argument_type = T;
    using result_type   = T;
  };

  template&lt;class R, class T1&gt;
  class function&lt;R(T1)&gt; {
  public:
    using argument_type = T1;
  };

  template&lt;class R, class T1, class T2&gt;
  class function&lt;R(T1, T2)&gt; {
  public:
    using first_argument_type  = T1;
    using second_argument_type = T2;
  };
}
</pre><p ><span class='indexparent'><a class='index' id='reference_wrapper,weak_result_type'></a></span></p></div><div class='para' id='depr.func.adaptor.typedefs-3'><div class='marginalizedparent'><a class='marginalized' href='#depr.func.adaptor.typedefs-3'>3</a></div><p ><span class='texttt'>reference_wrapper&lt;T&gt;</span> has a weak result type (<a href='depr.weak.result_type'>[depr.weak.result_type]</a>).
If <span class='texttt'>T</span> is a function type,
<span class='texttt'>result_type</span> shall be a synonym for the return type of <span class='texttt'>T</span>.</p><p ><span class='indexparent'><a class='index' id='argument_type,reference_wrapper'></a></span><span class='indexparent'><a class='index' id='reference_wrapper,argument_type'></a></span></p></div><div class='para' id='depr.func.adaptor.typedefs-4'><div class='marginalizedparent'><a class='marginalized' href='#depr.func.adaptor.typedefs-4'>4</a></div><p >The template specialization <span class='texttt'>reference_wrapper&lt;T&gt;</span>
shall define a nested type named <span class='texttt'>argument_type</span>
as a synonym for <span class='texttt'>T1</span>
only if the type <span class='texttt'>T</span> is any of the following:
</p><ul class='itemize'><li id='depr.func.adaptor.typedefs-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#depr.func.adaptor.typedefs-4.1'>(4.1)</a></div><p >a function type or a pointer to function type taking one argument of type <span class='texttt'>T1</span>
</p></li><li id='depr.func.adaptor.typedefs-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#depr.func.adaptor.typedefs-4.2'>(4.2)</a></div><p >a pointer to member function <span class='texttt'>R T0::f</span> <i>cv</i> (where <i>cv</i> represents the member function's cv-qualifiers); the type <span class='texttt'>T1</span> is <i>cv</i> <span class='texttt'>T0*</span>
</p></li><li id='depr.func.adaptor.typedefs-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#depr.func.adaptor.typedefs-4.3'>(4.3)</a></div><p >a class type where the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> <span class='texttt'>T::argument_type</span>
is valid and denotes a type (<a href='temp.deduct'>[temp.deduct]</a>);
the type <span class='texttt'>T1</span> is <span class='texttt'>T::argument_type</span>.
</p></li></ul><p ><span class='indexparent'><a class='index' id='first_argument_type,reference_wrapper'></a></span><span class='indexparent'><a class='index' id='reference_wrapper,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,reference_wrapper'></a></span><span class='indexparent'><a class='index' id='reference_wrapper,second_argument_type'></a></span></p></div><div class='para' id='depr.func.adaptor.typedefs-5'><div class='marginalizedparent'><a class='marginalized' href='#depr.func.adaptor.typedefs-5'>5</a></div><p >The template instantiation <span class='texttt'>reference_wrapper&lt;T&gt;</span>
shall define two nested types
named <span class='texttt'>first_argument_type</span> and <span class='texttt'>second_argument_type</span>
as synonyms for <span class='texttt'>T1</span> and <span class='texttt'>T2</span>, respectively,
only if the type <span class='texttt'>T</span> is any of the following:
</p><ul class='itemize'><li id='depr.func.adaptor.typedefs-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#depr.func.adaptor.typedefs-5.1'>(5.1)</a></div><p >a function type or a pointer to function type taking two arguments of types <span class='texttt'>T1</span> and <span class='texttt'>T2</span>
</p></li><li id='depr.func.adaptor.typedefs-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#depr.func.adaptor.typedefs-5.2'>(5.2)</a></div><p >a pointer to member function <span class='texttt'>R T0::f(T2)</span> <i>cv</i> (where <i>cv</i> represents the member function's cv-qualifiers); the type <span class='texttt'>T1</span> is <i>cv</i> <span class='texttt'>T0*</span>
</p></li><li id='depr.func.adaptor.typedefs-5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#depr.func.adaptor.typedefs-5.3'>(5.3)</a></div><p >a class type where the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-ids</a></i>
<span class='texttt'>T::first_argument_type</span> and <span class='texttt'>T::second_argument_type</span>
are both valid and both denote types (<a href='temp.deduct'>[temp.deduct]</a>);
the type <span class='texttt'>T1</span> is <span class='texttt'>T::first_argument_type</span> and
the type <span class='texttt'>T2</span> is <span class='texttt'>T::second_argument_type</span>.
</p></li></ul><p ><span class='indexparent'><a class='index' id='result_type,hash'></a></span><span class='indexparent'><a class='index' id='hash,result_type'></a></span><span class='indexparent'><a class='index' id='argument_type,hash'></a></span><span class='indexparent'><a class='index' id='hash,argument_type'></a></span></p></div><div class='para' id='depr.func.adaptor.typedefs-6'><div class='marginalizedparent'><a class='marginalized' href='#depr.func.adaptor.typedefs-6'>6</a></div><p >All enabled specializations <span class='texttt'>hash&lt;Key&gt;</span> of <span class='texttt'>hash</span> (<a href='unord.hash'>[unord.hash]</a>)
provide two nested types, <span class='texttt'>result_type</span> and <span class='texttt'>argument_type</span>,
which shall be synonyms for <span class='texttt'>size_t</span> and <span class='texttt'>Key</span>, respectively.</p><p ><span class='indexparent'><a class='index' id='bind,weak_result_type'></a></span></p></div><div class='para' id='depr.func.adaptor.typedefs-7'><div class='marginalizedparent'><a class='marginalized' href='#depr.func.adaptor.typedefs-7'>7</a></div><p >The forwarding call wrapper <span class='texttt'>g</span>
returned by a call to <span class='texttt'>bind(f, bound_args...)</span> (<a href='func.bind.bind'>[func.bind.bind]</a>)
shall have a weak result type (<a href='depr.weak.result_type'>[depr.weak.result_type]</a>).</p></div><div class='para' id='depr.func.adaptor.typedefs-8'><div class='marginalizedparent'><a class='marginalized' href='#depr.func.adaptor.typedefs-8'>8</a></div><p >The forwarding call wrapper <span class='texttt'>g</span>
returned by a call to <span class='texttt'>bind&lt;R&gt;(f, bound_args...)</span> (<a href='func.bind.bind'>[func.bind.bind]</a>)
shall have a nested type <span class='texttt'>result_type</span> defined as a synonym for <span class='texttt'>R</span>.</p><p ><span class='indexparent'><a class='index' id='result_type,mem_fn'></a></span><span class='indexparent'><a class='index' id='mem_fn,result_type'></a></span></p></div><div class='para' id='depr.func.adaptor.typedefs-9'><div class='marginalizedparent'><a class='marginalized' href='#depr.func.adaptor.typedefs-9'>9</a></div><p >The simple call wrapper
returned from a call to <span class='texttt'>mem_fn(pm)</span>
shall have a nested type <span class='texttt'>result_type</span>
that is a synonym for
the return type of <span class='texttt'>pm</span>
when <span class='texttt'>pm</span> is a pointer to member function.</p><p ><span class='indexparent'><a class='index' id='result_type,mem_fn'></a></span><span class='indexparent'><a class='index' id='mem_fn,result_type'></a></span><span class='indexparent'><a class='index' id='argument_type,mem_fn'></a></span><span class='indexparent'><a class='index' id='mem_fn,argument_type'></a></span></p></div><div class='para' id='depr.func.adaptor.typedefs-10'><div class='marginalizedparent'><a class='marginalized' href='#depr.func.adaptor.typedefs-10'>10</a></div><p >The simple call wrapper
returned from a call to <span class='texttt'>mem_fn(pm)</span>
shall define two nested types
named <span class='texttt'>argument_type</span> and <span class='texttt'>result_type</span>
as synonyms for <i>cv</i> <span class='texttt'>T*</span> and <span class='texttt'>Ret</span>, respectively,
when <span class='texttt'>pm</span> is a pointer to member function
with cv-qualifier <i>cv</i>
and taking no arguments,
where <span class='texttt'>Ret</span> is <span class='texttt'>pm</span>'s return type.</p><p ><span class='indexparent'><a class='index' id='result_type,mem_fn'></a></span><span class='indexparent'><a class='index' id='mem_fn,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,mem_fn'></a></span><span class='indexparent'><a class='index' id='mem_fn,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,mem_fn'></a></span><span class='indexparent'><a class='index' id='mem_fn,second_argument_type'></a></span></p></div><div class='para' id='depr.func.adaptor.typedefs-11'><div class='marginalizedparent'><a class='marginalized' href='#depr.func.adaptor.typedefs-11'>11</a></div><p >The simple call wrapper
returned from a call to <span class='texttt'>mem_fn(pm)</span>
shall define three nested types
named <span class='texttt'>first_argument_type</span>, <span class='texttt'>second_argument_type</span>, and <span class='texttt'>result_type</span>
as synonyms for <i>cv</i> <span class='texttt'>T*</span>, <span class='texttt'>T1</span>, and <span class='texttt'>Ret</span>, respectively,
when <span class='texttt'>pm</span> is a pointer to member function
with cv-qualifier <i>cv</i>
and taking one argument of type <span class='texttt'>T1</span>,
where <span class='texttt'>Ret</span> is <span class='texttt'>pm</span>'s return type.</p></div><div class='para' id='depr.func.adaptor.typedefs-12'><div class='marginalizedparent'><a class='marginalized' href='#depr.func.adaptor.typedefs-12'>12</a></div><p >The following member names are defined in addition to names specified in Clause <a href='containers'>[containers]</a>:</p><p ><span class='indexparent'><a class='index' id='result_type,map::value_compare'></a></span><span class='indexparent'><a class='index' id='map::value_compare,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,map::value_compare'></a></span><span class='indexparent'><a class='index' id='map::value_compare,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,map::value_compare'></a></span><span class='indexparent'><a class='index' id='map::value_compare,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,multimap::value_compare'></a></span><span class='indexparent'><a class='index' id='multimap::value_compare,result_type'></a></span><span class='indexparent'><a class='index' id='first_argument_type,multimap::value_compare'></a></span><span class='indexparent'><a class='index' id='multimap::value_compare,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,multimap::value_compare'></a></span><span class='indexparent'><a class='index' id='multimap::value_compare,second_argument_type'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class Key, class T, class Compare, class Allocator&gt;
  class map&lt;Key, T, Compare, Allocator&gt;::value_compare {
  public:
    using result_type          = bool;
    using first_argument_type  = value_type;
    using second_argument_type = value_type;
  };

  template &lt;class Key, class T, class Compare, class Allocator&gt;
  class multimap&lt;Key, T, Compare, Allocator&gt;::value_compare {
  public:
    using result_type          = bool;
    using first_argument_type  = value_type;
    using second_argument_type = value_type;
  };
}
</pre></div></div><div id='depr.negators'><h3 ><a class='secnum' href='#depr.negators' style='min-width:103pt'>D.7.3</a> Negators <a class='abbr_ref' href='depr.negators'>[depr.negators]</a></h3><div class='para' id='depr.negators-1'><div class='marginalizedparent'><a class='marginalized' href='#depr.negators-1'>1</a></div><p >The header
<span class='indexparent'><a class='index' id='functional'></a></span><span class='texttt'>&lt;functional&gt;</span> has the following additions:</p><p ><span class='indexparent'><a class='index' id='unary_negate'></a></span><span class='indexparent'><a class='index' id='not1'></a></span><span class='indexparent'><a class='index' id='binary_negate'></a></span><span class='indexparent'><a class='index' id='not2'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class Predicate&gt; class unary_negate;
  template &lt;class Predicate&gt;
    constexpr unary_negate&lt;Predicate&gt; not1(const Predicate&amp;);
  template &lt;class Predicate&gt; class binary_negate;
  template &lt;class Predicate&gt;
    constexpr binary_negate&lt;Predicate&gt; not2(const Predicate&amp;);
}
</pre></div><div class='para' id='depr.negators-2'><div class='marginalizedparent'><a class='marginalized' href='#depr.negators-2'>2</a></div><p >Negators <span class='texttt'>not1</span> and <span class='texttt'>not2</span>
take a unary and a binary predicate, respectively,
and return their logical negations (<a href='expr.unary.op'>[expr.unary.op]</a>).</p><p ><span class='indexparent'><a class='index' id='unary_negate'></a></span><span class='indexparent'><a class='index' id='argument_type,unary_negate'></a></span><span class='indexparent'><a class='index' id='unary_negate,argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,unary_negate'></a></span><span class='indexparent'><a class='index' id='unary_negate,result_type'></a></span></p><pre class='codeblock'>
template &lt;class Predicate&gt;
class unary_negate {
public:
  constexpr explicit unary_negate(const Predicate&amp; pred);
  constexpr bool operator()(const typename Predicate::argument_type&amp; x) const;
  using argument_type = typename Predicate::argument_type;
  using result_type   = bool;
};
</pre><p ><span class='indexparent'><a class='index' id='operator(),unary_negate'></a></span><span class='indexparent'><a class='index' id='unary_negate,operator()'></a></span><code class='itemdecl'>
constexpr bool operator()(const typename Predicate::argument_type&amp; x) const;
</code></p></div><div class='itemdescr'></div><div class='para' id='depr.negators-3'><div class='marginalizedparent'><a class='marginalized' href='#depr.negators-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!pred(x)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='not1'></a></span><code class='itemdecl'>
template &lt;class Predicate&gt;
   constexpr unary_negate&lt;Predicate&gt; not1(const Predicate&amp; pred);
</code></p><div class='itemdescr'></div><div class='para' id='depr.negators-4'><div class='marginalizedparent'><a class='marginalized' href='#depr.negators-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>unary_negate&lt;Predicate&gt;(pred)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='binary_negate'></a></span><span class='indexparent'><a class='index' id='first_argument_type,binary_negate'></a></span><span class='indexparent'><a class='index' id='binary_negate,first_argument_type'></a></span><span class='indexparent'><a class='index' id='second_argument_type,binary_negate'></a></span><span class='indexparent'><a class='index' id='binary_negate,second_argument_type'></a></span><span class='indexparent'><a class='index' id='result_type,binary_negate'></a></span><span class='indexparent'><a class='index' id='binary_negate,result_type'></a></span></p><pre class='codeblock'>
template &lt;class Predicate&gt;
class binary_negate {
public:
  constexpr explicit binary_negate(const Predicate&amp; pred);
  constexpr bool operator()(const typename Predicate::first_argument_type&amp; x,
                            const typename Predicate::second_argument_type&amp; y) const;
  using first_argument_type  = typename Predicate::first_argument_type;
  using second_argument_type = typename Predicate::second_argument_type;
  using result_type          = bool;

};
</pre><p ><span class='indexparent'><a class='index' id='operator(),binary_negate'></a></span><span class='indexparent'><a class='index' id='binary_negate,operator()'></a></span><code class='itemdecl'>
constexpr bool operator()(const typename Predicate::first_argument_type&amp; x,
                          const typename Predicate::second_argument_type&amp; y) const;
</code></p><div class='itemdescr'></div><div class='para' id='depr.negators-5'><div class='marginalizedparent'><a class='marginalized' href='#depr.negators-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>!pred(x,y)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='not2'></a></span><code class='itemdecl'>
template &lt;class Predicate&gt;
  constexpr binary_negate&lt;Predicate&gt; not2(const Predicate&amp; pred);
</code></p><div class='itemdescr'></div><div class='para' id='depr.negators-6'><div class='marginalizedparent'><a class='marginalized' href='#depr.negators-6'>6</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>binary_negate&lt;Predicate&gt;(pred)</span>.
</p></div></div></div></div></div></body></html>