<!DOCTYPE html><html lang='en'><head><title>[re.traits]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>28</a> Regular expressions library <a class='abbr_ref' href='./#re'>[re]</a></h1><div id='re.traits'><h2 ><a class='secnum' style='min-width:88pt'>28.7</a> Class template <span class='texttt'>regex_traits</span> <a class='abbr_ref'>[re.traits]</a></h2><p ><span class='indexparent'><a class='index' id='regex_traits'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class charT&gt;
  struct regex_traits {
  public:
     using char_type       = charT;
     using string_type     = std::basic_string&lt;char_type&gt;;
     using locale_type     = std::locale;
     using char_class_type = <i> bitmask_type</i>;

     regex_traits();
     static std::size_t length(const char_type* p);
     charT translate(charT c) const;
     charT translate_nocase(charT c) const;
     template &lt;class ForwardIterator&gt;
       string_type transform(ForwardIterator first, ForwardIterator last) const;
     template &lt;class ForwardIterator&gt;
       string_type transform_primary(
         ForwardIterator first, ForwardIterator last) const;
     template &lt;class ForwardIterator&gt;
       string_type lookup_collatename(
         ForwardIterator first, ForwardIterator last) const;
     template &lt;class ForwardIterator&gt;
       char_class_type lookup_classname(
         ForwardIterator first, ForwardIterator last, bool icase = false) const;
     bool isctype(charT c, char_class_type f) const;
     int value(charT ch, int radix) const;
     locale_type imbue(locale_type l);
     locale_type getloc() const;
  };
}
</pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='regular_expression_traits,requirements'></a></span><span class='indexparent'><a class='index' id='requirements,regular_expression_traits'></a></span><span class='indexparent'><a class='index' id='regex_traits,specializations'></a></span>The specializations <span class='texttt'>regex_traits&lt;char&gt;</span> and
<span class='texttt'>regex_traits&lt;wchar_t&gt;</span> shall be valid and shall satisfy the
requirements for a regular expression traits class (<a href='re.req'>[re.req]</a>).</p><p ><span class='indexparent'><a class='index' id='regex_traits,char_class_type'></a></span><span class='indexparent'><a class='index' id='char_class_type,regex_traits'></a></span><code class='itemdecl'>
using char_class_type = <i>bitmask_type</i>; 
</code></p></div><div class='itemdescr'></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><p >The type <span class='texttt'>char_class_type</span> is used to represent a character
classification and is capable of holding an implementation specific
set returned by <span class='texttt'>lookup_classname</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='length,regex_traits'></a></span><span class='indexparent'><a class='index' id='regex_traits,length'></a></span><code class='itemdecl'>
static std::size_t length(const char_type* p); 
</code></p><div class='itemdescr'></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>char_traits&lt;charT&gt;::length(p)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_traits,translate'></a></span><span class='indexparent'><a class='index' id='translate,regex_traits'></a></span><code class='itemdecl'>
charT translate(charT c) const; 
</code></p><div class='itemdescr'></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>c</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_traits,translate_nocase'></a></span><span class='indexparent'><a class='index' id='translate_nocase,regex_traits'></a></span><code class='itemdecl'>
charT translate_nocase(charT c) const; 
</code></p><div class='itemdescr'></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>use_facet&lt;ctype&lt;charT&gt;&gt;(getloc()).tolower(c)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_traits,transform'></a></span><span class='indexparent'><a class='index' id='transform,regex_traits'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator&gt;
  string_type transform(ForwardIterator first, ForwardIterator last) const; 
</code></p><div class='itemdescr'></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i>
As if by:
</p><pre class='codeblock'>
string_type str(first, last);
return use_facet&lt;collate&lt;charT&gt;&gt;(
  getloc()).transform(&amp;*str.begin(), &amp;*str.begin() + str.length());
</pre></div></div><p ><span class='indexparent'><a class='index' id='regex_traits,transform_primary'></a></span><span class='indexparent'><a class='index' id='transform_primary,regex_traits'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator&gt;
  string_type transform_primary(ForwardIterator first, ForwardIterator last) const; 
</code></p><div class='itemdescr'></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>typeid(use_facet&lt;collate&lt;charT&gt;&gt;) 
== typeid(collate_byname&lt;charT&gt;)</span>
and the form of the sort key returned
by <span class='texttt'>collate_byname&lt;charT&gt; :: transform(first, last)</span> is known and
can be converted into a primary sort key then returns that key,
otherwise returns an empty string.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_traits,lookup_collatename'></a></span><span class='indexparent'><a class='index' id='lookup_collatename,regex_traits'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator&gt;
  string_type lookup_collatename(ForwardIterator first, ForwardIterator last) const; 
</code></p><div class='itemdescr'></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> a sequence of one or more characters that
represents the collating element consisting of the character
sequence designated by the iterator range <span class='texttt'>[first, last)</span>.
Returns an empty string if the character sequence is not a
valid collating element.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_traits,lookup_classname'></a></span><span class='indexparent'><a class='index' id='lookup_classname,regex_traits'></a></span><code class='itemdecl'>
template &lt;class ForwardIterator&gt;
  char_class_type lookup_classname(
    ForwardIterator first, ForwardIterator last, bool icase = false) const; 
</code></p><div class='itemdescr'></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> an unspecified value that represents
the character classification named by the character sequence
designated by the iterator range <span class='texttt'>[first, last)</span>.
If the parameter <span class='texttt'>icase</span> is <span class='texttt'>true</span> then the returned mask identifies the
character classification without regard to the case of the characters being
matched, otherwise it does honor the case of the characters being
matched.<a class='footnotenum' href='#footnote-333'>333</a>
The value
returned shall be independent of the case of the characters in
the character sequence. If the name
is not recognized then returns <span class='texttt'>char_class_type()</span>.</p></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='itemdescr'><p ><i>Remarks:</i>  For <span class='texttt'>regex_traits&lt;char&gt;</span>, at least the narrow character names
in Table <a href='#tab:re.traits.classnames'>[tab:re.traits.classnames]</a> shall be recognized.
For <span class='texttt'>regex_traits&lt;wchar_t&gt;</span>, at least the wide character names
in Table <a href='#tab:re.traits.classnames'>[tab:re.traits.classnames]</a> shall be recognized.
</p></div></div><p ><span class='indexparent'><a class='index' id='regex_traits,isctype'></a></span><span class='indexparent'><a class='index' id='isctype,regex_traits'></a></span><code class='itemdecl'>
bool isctype(charT c, char_class_type f) const; 
</code></p><div class='itemdescr'></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i>  Determines if the character <span class='texttt'>c</span> is a member of the character
classification represented by <span class='texttt'>f</span>.</p></div></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> Given the following function declaration:
</p><pre class='codeblock'>
<span class='comment'>// for exposition only
</span>template&lt;class C&gt;
  ctype_base::mask convert(typename regex_traits&lt;C&gt;::char_class_type f);
</pre><p >that returns a value in which each <span class='texttt'>ctype_base::mask</span> value corresponding to
a value in <span class='texttt'>f</span> named in Table <a href='#tab:re.traits.classnames'>[tab:re.traits.classnames]</a> is set, then the
result is determined as if by:
</p><pre class='codeblock'>
ctype_base::mask m = convert&lt;charT&gt;(f);
const ctype&lt;charT&gt;&amp; ct = use_facet&lt;ctype&lt;charT&gt;&gt;(getloc());
if (ct.is(m, c)) {
  return true;
} else if (c == ct.widen('_')) {
  charT w[1] = { ct.widen('w') };
  char_class_type x = lookup_classname(w, w+1);
  return (f&amp;x) == x;
} else {
  return false;
} 
</pre><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
regex_traits&lt;char&gt; t;
string d("d");
string u("upper");
regex_traits&lt;char&gt;::char_class_type f;
f = t.lookup_classname(d.begin(), d.end());
f |= t.lookup_classname(u.begin(), u.end());
ctype_base::mask m = convert&lt;char&gt;(f); <span class='comment'>// <span class='texttt'>m == ctype_base::digit|ctype_base::upper</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
regex_traits&lt;char&gt; t;
string w("w");
regex_traits&lt;char&gt;::char_class_type f;
f = t.lookup_classname(w.begin(), w.end());
t.isctype('A', f); <span class='comment'>// returns <span class='texttt'>true</span>
</span>t.isctype('_', f); <span class='comment'>// returns <span class='texttt'>true</span>
</span>t.isctype(' ', f); <span class='comment'>// returns <span class='texttt'>false</span>
</span></pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div><p ><span class='indexparent'><a class='index' id='value,regex_traits'></a></span><span class='indexparent'><a class='index' id='regex_traits,value'></a></span><code class='itemdecl'>
int value(charT ch, int radix) const;
</code></p><div class='itemdescr'></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i>  The value of <span class='texttt'>radix</span> shall be 8, 10, or 16.</p></div></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> the value represented by the digit <span class='texttt'>ch</span> in base
<span class='texttt'>radix</span> if the character <span class='texttt'>ch</span> is a valid digit in base
<span class='texttt'>radix</span>; otherwise returns -1.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale'></a></span><span class='indexparent'><a class='index' id='imbue'></a></span><code class='itemdecl'>
locale_type imbue(locale_type loc); 
</code></p><div class='itemdescr'></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i>  Imbues <span class='texttt'>this</span> with a copy of the
locale <span class='texttt'>loc</span>. [&nbsp;<i>Note:</i> Calling <span class='texttt'>imbue</span> with a
different locale than the one currently in use invalidates all cached
data held by <span class='texttt'>*this</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><div class='itemdescr'><p ><i>Returns:</i> if no locale has been previously imbued then a copy of the
global locale in effect at the time of construction of <span class='texttt'>*this</span>,
otherwise a copy of the last argument passed to <span class='texttt'>imbue</span>.</p></div></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><div class='itemdescr'><p ><i>Postconditions:</i>  <span class='texttt'>getloc() == loc</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='locale'></a></span><span class='indexparent'><a class='index' id='getloc'></a></span><code class='itemdecl'>
locale_type getloc() const;
</code></p><div class='itemdescr'></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><div class='itemdescr'><p ><i>Returns:</i> if no locale has been imbued then a copy of the global locale
in effect at the time of construction of <span class='texttt'>*this</span>, otherwise a copy of
the last argument passed to <span class='texttt'>imbue</span>.
</p></div></div><div class='numberedTable' id='tab:re.traits.classnames'>Table <a href='#tab:re.traits.classnames'>127</a> — Character class names and corresponding <span class='texttt'>ctype</span> masks<br><table ><tr class='rowsep'><td colspan='1' class='center'><b>Narrow character name</b></td><td colspan='1' class='center'><b>Wide character name</b></td><td colspan='1' class='center'><b>Corresponding <span class='texttt'>ctype_base::mask</span> value</b></td></tr><tr class='capsep'><td class='left'>
<span class='texttt'>"alnum"</span>  </td><td class='left'> <span class='texttt'>L"alnum"</span>  </td><td class='left'> <span class='texttt'>ctype_base::alnum</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"alpha"</span>  </td><td class='left'> <span class='texttt'>L"alpha"</span>  </td><td class='left'> <span class='texttt'>ctype_base::alpha</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"blank"</span>  </td><td class='left'> <span class='texttt'>L"blank"</span>  </td><td class='left'> <span class='texttt'>ctype_base::blank</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"cntrl"</span>  </td><td class='left'> <span class='texttt'>L"cntrl"</span>  </td><td class='left'> <span class='texttt'>ctype_base::cntrl</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"digit"</span>  </td><td class='left'> <span class='texttt'>L"digit"</span>  </td><td class='left'> <span class='texttt'>ctype_base::digit</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"d"</span>      </td><td class='left'> <span class='texttt'>L"d"</span>      </td><td class='left'> <span class='texttt'>ctype_base::digit</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"graph"</span>  </td><td class='left'> <span class='texttt'>L"graph"</span>  </td><td class='left'> <span class='texttt'>ctype_base::graph</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"lower"</span>  </td><td class='left'> <span class='texttt'>L"lower"</span>  </td><td class='left'> <span class='texttt'>ctype_base::lower</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"print"</span>  </td><td class='left'> <span class='texttt'>L"print"</span>  </td><td class='left'> <span class='texttt'>ctype_base::print</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"punct"</span>  </td><td class='left'> <span class='texttt'>L"punct"</span>  </td><td class='left'> <span class='texttt'>ctype_base::punct</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"space"</span>  </td><td class='left'> <span class='texttt'>L"space"</span>  </td><td class='left'> <span class='texttt'>ctype_base::space</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"s"</span>      </td><td class='left'> <span class='texttt'>L"s"</span>      </td><td class='left'> <span class='texttt'>ctype_base::space</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"upper"</span>  </td><td class='left'> <span class='texttt'>L"upper"</span>  </td><td class='left'> <span class='texttt'>ctype_base::upper</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"w"</span>      </td><td class='left'> <span class='texttt'>L"w"</span>      </td><td class='left'> <span class='texttt'>ctype_base::alnum</span>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>"xdigit"</span> </td><td class='left'> <span class='texttt'>L"xdigit"</span> </td><td class='left'> <span class='texttt'>ctype_base::xdigit</span> </td></tr></table></div><div class='footnote' id='footnote-333'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-333'>333)</a></div><p >For example, if the parameter <span class='texttt'>icase</span> is <span class='texttt'>true</span> then
<span class='texttt'>[[:lower:]]</span> is the same as <span class='texttt'>[[:alpha:]]</span>.</p></div></div></div></body></html>