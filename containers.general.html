<!DOCTYPE html><html lang='en'><head><title>[containers.general]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>23</a> Containers library <a class='abbr_ref' href='./#containers'>[containers]</a></h1><div id='containers.general'><h2 ><a class='secnum' style='min-width:88pt'>23.1</a> General <a class='abbr_ref'>[containers.general]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >This Clause describes components that C++ programs may use to
organize collections of information.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The following subclauses describe
container requirements,
and components for
sequence containers and
associative containers,
as summarized in
Table <a href='#tab:containers.lib.summary'>[tab:containers.lib.summary]</a>.</p><div class='numberedTable' id='tab:containers.lib.summary'>Table <a href='#tab:containers.lib.summary'>75</a> — Containers library summary<br><table ><tr class='rowsep'><td colspan='2' class='center'><b>Subclause</b></td><td class='left'>	<b>Header(s)</b>	</td></tr><tr class='capsep'><td class='left'> 


<a href='container.requirements'>[container.requirements]</a> </td><td class='left'> Requirements                     </td><td class='left'>                           </td></tr><tr class='rowsep'><td class='left'> 
<a href='sequences'>[sequences]</a>              </td><td class='left'> Sequence containers              </td><td class='left'> <span class='texttt'>&lt;array&gt;</span>         </td></tr><tr ><td class='left'>
                             </td><td class='left'>                                  </td><td class='left'> <span class='texttt'>&lt;deque&gt;</span>         </td></tr><tr ><td class='left'>
                             </td><td class='left'>                                  </td><td class='left'> <span class='texttt'>&lt;forward_list&gt;</span>  </td></tr><tr ><td class='left'>
                             </td><td class='left'>                                  </td><td class='left'> <span class='texttt'>&lt;list&gt;</span>          </td></tr><tr ><td class='left'>
                             </td><td class='left'>                                  </td><td class='left'> <span class='texttt'>&lt;vector&gt;</span>        </td></tr><tr class='rowsep'><td class='left'> 
<a href='associative'>[associative]</a>            </td><td class='left'> Associative containers           </td><td class='left'> <span class='texttt'>&lt;map&gt;</span>           </td></tr><tr ><td class='left'>
                             </td><td class='left'>                                  </td><td class='left'> <span class='texttt'>&lt;set&gt;</span>           </td></tr><tr class='rowsep'><td class='left'> 
<a href='unord'>[unord]</a>                  </td><td class='left'> Unordered associative containers </td><td class='left'> <span class='texttt'>&lt;unordered_map&gt;</span> </td></tr><tr ><td class='left'>
                             </td><td class='left'>                                  </td><td class='left'> <span class='texttt'>&lt;unordered_set&gt;</span> </td></tr><tr class='rowsep'><td class='left'> 
<a href='container.adaptors'>[container.adaptors]</a>     </td><td class='left'> Container adaptors               </td><td class='left'> <span class='texttt'>&lt;queue&gt;</span>         </td></tr><tr ><td class='left'>
                             </td><td class='left'>                                  </td><td class='left'> <span class='texttt'>&lt;stack&gt;</span>         </td></tr></table></div></div><div id='container.node'><h3 ><a class='secnum' href='#container.node' style='min-width:103pt'>23.1.1</a> Node handles <a class='abbr_ref' href='container.node'>[container.node]</a></h3><div id='container.node.overview'><h4 ><a class='secnum' href='#container.node.overview' style='min-width:118pt'>23.1.1.1</a> <span class='texttt'>node_handle</span> overview <a class='abbr_ref' href='container.node.overview'>[container.node.overview]</a></h4><div class='para' id='container.node.overview-1'><div class='marginalizedparent'><a class='marginalized' href='#container.node.overview-1'>1</a></div><p >A <i>node handle</i> is an object that accepts ownership of a single element
from an associative container (<a href='associative.reqmts'>[associative.reqmts]</a>) or an unordered
associative container (<a href='unord.req'>[unord.req]</a>). It may be used to transfer that
ownership to another container with compatible nodes.  Containers with
compatible nodes have the same node handle type. Elements may be transferred in
either direction between container types in the same row of
Table <a href='#tab:containers.node.compat'>[tab:containers.node.compat]</a>.</p><div class='numberedTable' id='tab:containers.node.compat'>Table <a href='#tab:containers.node.compat'>76</a> — Container types with compatible nodes<br><table ><tr class='rowsep'><td class='left'>



<span class='texttt'>map&lt;K, T, C1, A&gt;</span>               </td><td class='left'> <span class='texttt'>map&lt;K, T, C2, A&gt;</span>                    </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>map&lt;K, T, C1, A&gt;</span>               </td><td class='left'> <span class='texttt'>multimap&lt;K, T, C2, A&gt;</span>               </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>set&lt;K, C1, A&gt;</span>                  </td><td class='left'> <span class='texttt'>set&lt;K, C2, A&gt;</span>                       </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>set&lt;K, C1, A&gt;</span>                  </td><td class='left'> <span class='texttt'>multiset&lt;K, C2, A&gt;</span>                  </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>unordered_map&lt;K, T, H1, E1, A&gt;</span> </td><td class='left'> <span class='texttt'>unordered_map&lt;K, T, H2, E2, A&gt;</span>      </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>unordered_map&lt;K, T, H1, E1, A&gt;</span> </td><td class='left'> <span class='texttt'>unordered_multimap&lt;K, T, H2, E2, A&gt;</span> </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>unordered_set&lt;K, H1, E1, A&gt;</span>    </td><td class='left'> <span class='texttt'>unordered_set&lt;K, H2, E2, A&gt;</span>         </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>unordered_set&lt;K, H1, E1, A&gt;</span>    </td><td class='left'> <span class='texttt'>unordered_multiset&lt;K, H2, E2, A&gt;</span>    </td></tr></table></div></div><div class='para' id='container.node.overview-2'><div class='marginalizedparent'><a class='marginalized' href='#container.node.overview-2'>2</a></div><p >If a node handle is not empty, then it contains an allocator that is equal to
the allocator of the container when the element was extracted. If a node handle
is empty, it contains no allocator.</p></div><div class='para' id='container.node.overview-3'><div class='marginalizedparent'><a class='marginalized' href='#container.node.overview-3'>3</a></div><p >Class <span class='texttt'><i>node_handle</i></span> is for exposition only. An implementation is
permitted to provide equivalent functionality without providing a class with
this name.</p></div><div class='para' id='container.node.overview-4'><div class='marginalizedparent'><a class='marginalized' href='#container.node.overview-4'>4</a></div><p >If a user-defined specialization of <span class='texttt'>std::pair</span> exists for
<span class='texttt'>pair&lt;const Key, T&gt;</span> or <span class='texttt'>pair&lt;Key, T&gt;</span>, where <span class='texttt'>Key</span> is the
container's <span class='texttt'>key_type</span> and <span class='texttt'>T</span> is the container's
<span class='texttt'>mapped_type</span>, the behavior of operations involving node handles is
undefined.</p><pre class='codeblock'>
template&lt;<i><span class='texttt'>unspecified</span><span class='nocorr'></span></i>&gt;
class <i>node_handle</i> {
public:
  <span class='comment'>// These type declarations are described in Tables <a href='associative.reqmts#tab:containers.associative.requirements'>[tab:containers.associative.requirements]</a> and <a href='unord.req#tab:HashRequirements'>[tab:HashRequirements]</a>
</span>  using value_type     = <i><span class='texttt'>see below</span><span class='nocorr'></span></i>; <span class='comment'>// Not present for map containers
</span>  using key_type       = <i><span class='texttt'>see below</span><span class='nocorr'></span></i>; <span class='comment'>// Not present for set containers
</span>  using mapped_type    = <i><span class='texttt'>see below</span><span class='nocorr'></span></i>; <span class='comment'>// Not present for set containers
</span>  using allocator_type = <i><span class='texttt'>see below</span><span class='nocorr'></span></i>;

private:
  using container_node_type = <i><span class='texttt'>unspecified</span><span class='nocorr'></span></i>;
  using ator_traits         = allocator_traits&lt;allocator_type&gt;;
  typename ator_traits::rebind_traits&lt;container_node_type&gt;::pointer ptr_;
  optional&lt;allocator_type&gt; alloc_;

public:
  constexpr <i>node_handle</i>() noexcept : ptr_(), alloc_() {}
  ~<i>node_handle</i>();
  <i>node_handle</i>(<i>node_handle</i>&amp;&amp;) noexcept;
  <i>node_handle</i>&amp; operator=(<i>node_handle</i>&amp;&amp;);
  value_type&amp; value() const;    <span class='comment'>// Not present for map containers
</span>  key_type&amp; key() const;        <span class='comment'>// Not present for set containers
</span>  mapped_type&amp; mapped() const;  <span class='comment'>// Not present for set containers
</span>  allocator_type get_allocator() const;
  explicit operator bool() const noexcept;
  bool empty() const noexcept;
  void swap(<i>node_handle</i>&amp;)
    noexcept(ator_traits::propagate_on_container_swap::value ||
             ator_traits::is_always_equal::value);
  friend void swap(<i>node_handle</i>&amp; x, <i>node_handle</i>&amp; y) noexcept(noexcept(x.swap(y)))
    { x.swap(y); }
};
</pre></div></div><div id='container.node.cons'><h4 ><a class='secnum' href='#container.node.cons' style='min-width:118pt'>23.1.1.2</a> <span class='texttt'><i>node_handle</i></span> constructors, copy, and assignment <a class='abbr_ref' href='container.node.cons'>[container.node.cons]</a></h4><p ><code class='itemdecl'>
<i>node_handle</i>(<i>node_handle</i>&amp;&amp; nh) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='container.node.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#container.node.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'><i>node_handle</i></span> object initializing
<span class='texttt'>ptr_</span> with <span class='texttt'>nh.ptr_</span>.  Move constructs <span class='texttt'>alloc_</span> with
<span class='texttt'>nh.alloc_</span>.  Assigns <span class='texttt'>nullptr</span> to <span class='texttt'>nh.ptr_</span> and assigns
<span class='texttt'>nullopt</span> to <span class='texttt'>nh.alloc_</span>.
</p></div></div><p ><code class='itemdecl'>
<i>node_handle</i>&amp; operator=(<i>node_handle</i>&amp;&amp; nh);
</code></p><div class='itemdescr'></div><div class='para' id='container.node.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#container.node.cons-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> Either <span class='texttt'>!alloc_</span>, or
<span class='texttt'>ator_traits::propagate_on_container_move_assignment</span>
is <span class='texttt'>true</span>, or <span class='texttt'>alloc_ ==  nh.alloc_</span>.</p></div></div><div class='para' id='container.node.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#container.node.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>ptr_ != nullptr</span>, destroys the <span class='texttt'>value_type</span>
subobject in the <span class='texttt'>container_node_type</span> object pointed to by <span class='texttt'>ptr_</span>
by calling <span class='texttt'>ator_traits::destroy</span>, then deallocates <span class='texttt'>ptr_</span> by
calling <span class='texttt'>ator_traits::rebind_traits&lt;container_node_type&gt;::deallocate</span>.
Assigns <span class='texttt'>nh.ptr_</span> to <span class='texttt'>ptr_</span>.
If <span class='texttt'>!alloc_</span> or <span class='texttt'>ator_traits::propagate_on_container_move_assignment</span>
is <span class='texttt'>true</span>, move assigns <span class='texttt'>nh.alloc_</span> to <span class='texttt'>alloc_</span>. Assigns
<span class='texttt'>nullptr</span> to <span class='texttt'>nh.ptr_</span> and assigns <span class='texttt'>nullopt</span> to
<span class='texttt'>nh.alloc_</span>.</p></div></div><div class='para' id='container.node.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#container.node.cons-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.</p></div></div><div class='para' id='container.node.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#container.node.cons-5'>5</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div></div><div id='container.node.dtor'><h4 ><a class='secnum' href='#container.node.dtor' style='min-width:118pt'>23.1.1.3</a> <span class='texttt'><i>node_handle</i></span> destructor <a class='abbr_ref' href='container.node.dtor'>[container.node.dtor]</a></h4><p ><code class='itemdecl'>
~<i>node_handle</i>();
</code></p><div class='itemdescr'></div><div class='para' id='container.node.dtor-1'><div class='marginalizedparent'><a class='marginalized' href='#container.node.dtor-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> If <span class='texttt'>ptr_ != nullptr</span>, destroys the <span class='texttt'>value_type</span> subobject
in the <span class='texttt'>container_node_type</span> object pointed to by <span class='texttt'>ptr_</span> by calling
<span class='texttt'>ator_traits::destroy</span>, then deallocates <span class='texttt'>ptr_</span> by calling
<span class='texttt'>ator_traits::rebind_traits&lt;container_node_type&gt;::deallocate</span>.
</p></div></div></div><div id='container.node.observers'><h4 ><a class='secnum' href='#container.node.observers' style='min-width:118pt'>23.1.1.4</a> <span class='texttt'><i>node_handle</i></span> observers <a class='abbr_ref' href='container.node.observers'>[container.node.observers]</a></h4><p ><code class='itemdecl'>
value_type&amp; value() const;
</code></p><div class='itemdescr'></div><div class='para' id='container.node.observers-1'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>empty() == false</span>.</p></div></div><div class='para' id='container.node.observers-2'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to the <span class='texttt'>value_type</span> subobject in the
<span class='texttt'>container_node_type</span> object pointed to by <span class='texttt'>ptr_</span>.</p></div></div><div class='para' id='container.node.observers-3'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-3'>3</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><code class='itemdecl'>
key_type&amp; key() const;
</code></p><div class='itemdescr'></div><div class='para' id='container.node.observers-4'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>empty() == false</span>.</p></div></div><div class='para' id='container.node.observers-5'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i> A non-const reference to the <span class='texttt'>key_type</span> member of the
<span class='texttt'>value_type</span> subobject in the <span class='texttt'>container_node_type</span> object
pointed to by <span class='texttt'>ptr_</span>.</p></div></div><div class='para' id='container.node.observers-6'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-6'>6</a></div><div class='itemdescr'><p ><i>Throws:</i>  Nothing.</p></div></div><div class='para' id='container.node.observers-7'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-7'>7</a></div><div class='itemdescr'><p ><i>Remarks:</i> Modifying the key through the returned reference is permitted.
</p></div></div><p ><code class='itemdecl'>
mapped_type&amp; mapped() const;
</code></p><div class='itemdescr'></div><div class='para' id='container.node.observers-8'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-8'>8</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>empty() == false</span>.</p></div></div><div class='para' id='container.node.observers-9'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i> A reference to the <span class='texttt'>mapped_type</span> member of the
<span class='texttt'>value_type</span> subobject in the <span class='texttt'>container_node_type</span> object
pointed to by <span class='texttt'>ptr_</span>.</p></div></div><div class='para' id='container.node.observers-10'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-10'>10</a></div><div class='itemdescr'><p ><i>Throws:</i>  Nothing.
</p></div></div><p ><code class='itemdecl'>
allocator_type get_allocator() const;
</code></p><div class='itemdescr'></div><div class='para' id='container.node.observers-11'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>empty() == false</span>.</p></div></div><div class='para' id='container.node.observers-12'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-12'>12</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*alloc_</span>.</p></div></div><div class='para' id='container.node.observers-13'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-13'>13</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing.
</p></div></div><p ><code class='itemdecl'>
explicit operator bool() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='container.node.observers-14'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-14'>14</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>ptr_ != nullptr</span>.
</p></div></div><p ><code class='itemdecl'>
bool empty() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='container.node.observers-15'><div class='marginalizedparent'><a class='marginalized' href='#container.node.observers-15'>15</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>ptr_ == nullptr</span>.
</p></div></div></div><div id='container.node.modifiers'><h4 ><a class='secnum' href='#container.node.modifiers' style='min-width:118pt'>23.1.1.5</a> <span class='texttt'><i>node_handle</i></span> modifiers <a class='abbr_ref' href='container.node.modifiers'>[container.node.modifiers]</a></h4><p ><code class='itemdecl'>
void swap(<i>node_handle</i>&amp; nh)
  noexcept(ator_traits::propagate_on_container_swap::value ||
           ator_traits::is_always_equal::value);
</code></p><div class='itemdescr'></div><div class='para' id='container.node.modifiers-1'><div class='marginalizedparent'><a class='marginalized' href='#container.node.modifiers-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>!alloc_</span>, or <span class='texttt'>!nh.alloc_</span>, or
<span class='texttt'>ator_traits::propagate_on_container_swap</span> is <span class='texttt'>true</span>,
or <span class='texttt'>alloc_ == nh.alloc_</span>.</p></div></div><div class='para' id='container.node.modifiers-2'><div class='marginalizedparent'><a class='marginalized' href='#container.node.modifiers-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Calls <span class='texttt'>swap(ptr_, nh.ptr_)</span>. If <span class='texttt'>!alloc_</span>, or
<span class='texttt'>!nh.alloc_</span>, or <span class='texttt'>ator_traits::propagate_on_container_swap</span>
is <span class='texttt'>true</span> calls <span class='texttt'>swap(alloc_, nh.alloc_)</span>.
</p></div></div></div></div></div></div></body></html>