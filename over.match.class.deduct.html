<!DOCTYPE html><html lang='en'><head><title>[over.match.class.deduct]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>13.3</a> Overload resolution <a class='abbr_ref' href='over.match#class.deduct'>[over.match]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>13.3.1</a> Candidate functions and argument lists <a class='abbr_ref' href='over.match.funcs#over.match.class.deduct'>[over.match.funcs]</a></h3><div id='over.match.class.deduct'><h4 ><a class='secnum' style='min-width:118pt'>13.3.1.8</a> Class template argument deduction <a class='abbr_ref'>[over.match.class.deduct]</a></h4><p ><span class='indexparent'><a class='index' id='deduction,class_template_arguments'></a></span>
</p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/overloading.tex#L1389'>#</a></div><p >A set of functions and function templates is formed comprising:</p><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p >For each constructor
of the class template
designated by the <i ><a href='temp.names#nt:template-name'>template-name</a></i>,
a function template with the following properties:
</p><ul class='itemize'><li id='1.1.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#1.1.1'>(1.1.1)</a></div><p >The template parameters are the template parameters of the class template
followed
by the template parameters (including default template arguments) of the constructor,
if any.
</p></li><li id='1.1.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#1.1.2'>(1.1.2)</a></div><p >The types of the function parameters are those of the constructor.
</p></li><li id='1.1.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#1.1.3'>(1.1.3)</a></div><p >The return type is the class template specialization
designated by the <i ><a href='temp.names#nt:template-name'>template-name</a></i>
and template arguments
corresponding to the template parameters
obtained from the class template.
</p></li></ul></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p >For each <i ><a href='temp.deduct.guide#nt:deduction-guide'>deduction-guide</a></i>,
a function or function template
with the following properties:</p><ul class='itemize'><li id='1.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#1.2.1'>(1.2.1)</a></div><p >The template parameters, if any,
and function parameters
are those of the <i ><a href='temp.deduct.guide#nt:deduction-guide'>deduction-guide</a></i>.
</p></li><li id='1.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#1.2.2'>(1.2.2)</a></div><p >The return type
is the <i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i>
of the <i ><a href='temp.deduct.guide#nt:deduction-guide'>deduction-guide</a></i>.
</p></li></ul></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/overloading.tex#L1431'>#</a></div><p >Initialization and overload resolution are performed as described
in <a href='dcl.init'>[dcl.init]</a> and <a href='over.match.ctor'>[over.match.ctor]</a>, <a href='over.match.copy'>[over.match.copy]</a>,
or <a href='over.match.list'>[over.match.list]</a> (as appropriate for the type of initialization
performed) for an object of a hypothetical class type, where
the selected functions and function templates are considered to be the
constructors of that class type for the purpose of forming an overload
set, and the initializer is provided by the context in which class
template argument deduction was performed. Each such notional constructor
is considered to be explicit if the function or function template was
generated from a constructor or <i ><a href='temp.deduct.guide#nt:deduction-guide'>deduction-guide</a></i> that was
declared <span class='texttt'>explicit</span>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/overloading.tex#L1444'>#</a></div><p >[ <i>Example:</i>
</p><pre class='codeblock'>
template &lt;class T&gt; struct A {
  explicit A(const T&amp;, ...) noexcept;  <span class='comment'>// #1
</span>  A(T&amp;&amp;, ...);                         <span class='comment'>// #2
</span>};

int i;
A a1 = { i, i };    <span class='comment'>// error: explicit constructor #1 selected in copy-list-initialization during deduction,
</span>                    <span class='comment'>// cannot deduce from non-forwarding rvalue reference in #2
</span>
A a2{i, i};         <span class='comment'>// OK, #1 deduces to <span class='texttt'>A&lt;int&gt;</span> and also initializes
</span>A a3{0, i};         <span class='comment'>// OK, #2 deduces to <span class='texttt'>A&lt;int&gt;</span> and also initializes
</span>A a4 = {0, i};      <span class='comment'>// OK, #2 deduces to <span class='texttt'>A&lt;int&gt;</span> and also initializes
</span>
template &lt;class T&gt; A(const T&amp;, const T&amp;) -&gt; A&lt;T&amp;&gt;;  <span class='comment'>// #3
</span>template &lt;class T&gt; explicit A(T&amp;&amp;, T&amp;&amp;) -&gt; A&lt;T&gt;;    <span class='comment'>// #4
</span>
A a5 = {0, 1};      <span class='comment'>// error: explicit deduction guide #4 selected in copy-list-initialization during deduction
</span>A a6{0,1};          <span class='comment'>// OK, #4 deduces to <span class='texttt'>A&lt;int&gt;</span> and #2 initializes
</span>A a7 = {0, i};      <span class='comment'>// error: #3 deduces to <span class='texttt'>A&lt;int&amp;&gt;</span>, #1 and #2 declare same constructor
</span>A a8{0,i};          <span class='comment'>// error: #3 deduces to <span class='texttt'>A&lt;int&amp;&gt;</span>, #1 and #2 declare same constructor
</span>
template &lt;class T&gt; struct B {
  template &lt;class U&gt; using TA = T;
  template &lt;class U&gt; B(U, TA&lt;U&gt;);
};

B b{(int*)0, (char*)0};         <span class='comment'>// OK, deduces <span class='texttt'>B&lt;char*&gt;</span>
</span></pre><p ><i> â€” end example</i> ]<span class='indexparent'><a class='index' id='overloading,argument_lists'></a></span><span class='indexparent'><a class='index' id='overloading,candidate_functions'></a></span></p></div></div></div></body></html>