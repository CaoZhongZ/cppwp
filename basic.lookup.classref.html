<!DOCTYPE html><html lang='en'><head><title>[basic.lookup.classref]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>3</a> Basic concepts <a class='abbr_ref' href='./#basic'>[basic]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>3.4</a> Name lookup <a class='abbr_ref' href='basic.lookup#classref'>[basic.lookup]</a></h2><div id='basic.lookup.classref'><h3 ><a class='secnum' style='min-width:103pt'>3.4.5</a> Class member access <a class='abbr_ref'>[basic.lookup.classref]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p ><span class='indexparent'><a class='index' id='lookup,class_member'></a></span>In a class member access expression (<a href='expr.ref'>[expr.ref]</a>), if the <span class='texttt'>.</span>
or <span class='texttt'>-&gt;</span> token is immediately followed by an <i ><a href='lex.name#nt:identifier'>identifier</a></i>
followed by a <span class='texttt'>&lt;</span>, the identifier must be looked up to determine
whether the <span class='texttt'>&lt;</span> is the beginning of a template argument
list (<a href='temp.names'>[temp.names]</a>) or a less-than operator. The identifier is first
looked up in the class of the object expression. If the identifier is
not found, it is then looked up in the context of the entire
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> and shall name a class template.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >If the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> in a class member
access (<a href='expr.ref'>[expr.ref]</a>) is an <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i>, and the type of
the object expression is of a class type <span class='texttt'>C</span>, the
<i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> is looked up in the scope of class <span class='texttt'>C</span>.
For a pseudo-destructor call (<a href='expr.pseudo'>[expr.pseudo]</a>),
the <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> is looked up in the context of the complete
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >If the <i ><a href='expr.prim.id.unqual#nt:unqualified-id'>unqualified-id</a></i> is <span class='texttt'>~</span><i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>, the
<i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i> is looked up in the context of the entire
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>. If the type <span class='texttt'>T</span> of the object
expression is of a class type <span class='texttt'>C</span>, the <i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i> is
also looked up in the scope of class <span class='texttt'>C</span>. At least one of the
lookups shall find a name that refers to (possibly cv-qualified)
<span class='texttt'>T</span>. [&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
struct A { };

struct B {
  struct A { };
  void f(::A* a);
};

void B::f(::A* a) {
  a-&gt;~A();                      <span class='comment'>// OK: lookup in <span class='texttt'>*a</span> finds the injected-class-name
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >If the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> in a class member access is a
<i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> of the form
</p><pre class='codeblock'>
class-name-or-namespace-name::...
</pre><p >the <span class='grammarterm'>class-name-or-namespace-name</span> following the <span class='texttt'>.</span> or
<span class='texttt'>-&gt;</span> operator is
first looked up in the class of the object expression and the name, if found,
is used. Otherwise it is looked up in the context of the entire
<i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>. [&nbsp;<i>Note:</i><span class='space'></span> See <a href='basic.lookup.qual'>[basic.lookup.qual]</a>, which
describes the lookup of a name before <span class='texttt'>::</span>, which will only find a type
or namespace name. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >If the <i ><a href='expr.prim.id.qual#nt:qualified-id'>qualified-id</a></i> has the form
</p><pre class='codeblock'>
::class-name-or-namespace-name::...
</pre><p >the <span class='grammarterm'>class-name-or-namespace-name</span> is looked up in global scope
as a <i ><a href='class#nt:class-name'>class-name</a></i> or <i ><a href='namespace.def#nt:namespace-name'>namespace-name</a></i>.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >If the <i ><a href='expr.prim.id.qual#nt:nested-name-specifier'>nested-name-specifier</a></i> contains a
<i ><a href='temp.names#nt:simple-template-id'>simple-template-id</a></i> (<a href='temp.names'>[temp.names]</a>), the names in its
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i> are looked up in the context in which the
entire <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i> occurs.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >If the <i ><a href='expr.prim.id#nt:id-expression'>id-expression</a></i> is a <i ><a href='class.conv.fct#nt:conversion-function-id'>conversion-function-id</a></i>,
its <i ><a href='class.conv.fct#nt:conversion-type-id'>conversion-type-id</a></i>
is first looked up in the class of the object expression and the name, if
found, is used. Otherwise it is looked up in the context
of the entire <i ><a href='expr.post#nt:postfix-expression'>postfix-expression</a></i>.
In each of these lookups, only names that denote types or templates whose
specializations are types are considered.
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
struct A { };
namespace N {
  struct A {
    void g() { }
    template &lt;class T&gt; operator T();
  };
}

int main() {
  N::A a;
  a.operator A();               <span class='comment'>// calls <span class='texttt'>N::A::operator N::A</span>
</span>}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></body></html>