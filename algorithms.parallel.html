<!DOCTYPE html><html lang='en'><head><title>[algorithms.parallel]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>25</a> Algorithms library <a class='abbr_ref' href='./#algorithms'>[algorithms]</a></h1><div id='algorithms.parallel'><h2 ><a class='secnum' style='min-width:88pt'>25.4</a> Parallel algorithms <a class='abbr_ref'>[algorithms.parallel]</a></h2><p >This section describes components that C++ programs may use to perform
operations on containers and other sequences in parallel.</p><div id='defns'><h3 ><a class='secnum' href='#defns' style='min-width:103pt'>25.4.1</a> Terms and definitions <a class='abbr_ref' href='algorithms.parallel.defns'>[algorithms.parallel.defns]</a></h3><div class='para' id='defns-1'><div class='marginalizedparent'><a class='marginalized' href='#defns-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/algorithms.tex#L1205'>#</a></div><p >A <a class='hidden_link' href='#def:parallel_algorithm' id='def:parallel_algorithm'><i>parallel algorithm</i></a> is a function template listed in this standard with
a template parameter named <span class='texttt'>ExecutionPolicy</span>.</p></div><div class='para' id='defns-2'><div class='marginalizedparent'><a class='marginalized' href='#defns-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/algorithms.tex#L1209'>#</a></div><p >Parallel algorithms access objects indirectly accessible via their arguments by
invoking the following functions:</p><ul class='itemize'><li id='defns-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#defns-2.1'>(2.1)</a></div><p >All operations of the categories of the iterators that the algorithm is
instantiated with.</p></li><li id='defns-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#defns-2.2'>(2.2)</a></div><p >Operations on those sequence elements that are required by its specification.</p></li><li id='defns-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#defns-2.3'>(2.3)</a></div><p >User-provided function objects to be applied during the execution of the
algorithm, if required by the specification.</p></li><li id='defns-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#defns-2.4'>(2.4)</a></div><p >Operations on those function objects required by the specification.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> See <a href='algorithms.general'>[algorithms.general]</a>.<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
</p></li></ul><p >These functions are herein called <a class='hidden_link' href='#def:element_access_functions' id='def:element_access_functions'><i>element access functions</i></a>.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
The <span class='texttt'>sort</span> function may invoke the following element access functions:</p><ul class='itemize'><li id='defns-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#defns-2.5'>(2.5)</a></div><p >Operations of the random-access iterator of the actual template argument
(as per <a href='random.access.iterators'>[random.access.iterators]</a>),
as implied by the name of the template parameter <span class='texttt'>RandomAccessIterator</span>.</p></li><li id='defns-2.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#defns-2.6'>(2.6)</a></div><p >The <span class='texttt'>swap</span> function on the elements of the sequence (as per the
preconditions specified in <a href='sort'>[sort]</a>).</p></li><li id='defns-2.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#defns-2.7'>(2.7)</a></div><p >The user-provided <span class='texttt'>Compare</span> function object.
</p></li></ul><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div id='user'><h3 ><a class='secnum' href='#user' style='min-width:103pt'>25.4.2</a> Requirements on user-provided function objects <a class='abbr_ref' href='algorithms.parallel.user'>[algorithms.parallel.user]</a></h3><div class='para' id='user-1'><div class='marginalizedparent'><a class='marginalized' href='#user-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/algorithms.tex#L1251'>#</a></div><p >Function objects passed into parallel algorithms as objects of type
<span class='texttt'>Predicate</span>, <span class='texttt'>BinaryPredicate</span>, <span class='texttt'>Compare</span>, and
<span class='texttt'>BinaryOperation</span> shall not directly or indirectly modify objects via
their arguments.</p></div></div><div id='exec'><h3 ><a class='secnum' href='#exec' style='min-width:103pt'>25.4.3</a> Effect of execution policies on algorithm execution <a class='abbr_ref' href='algorithms.parallel.exec'>[algorithms.parallel.exec]</a></h3><div class='para' id='exec-1'><div class='marginalizedparent'><a class='marginalized' href='#exec-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/algorithms.tex#L1259'>#</a></div><p >Parallel algorithms have template parameters
named <span class='texttt'>ExecutionPolicy</span> (<a href='execpol'>[execpol]</a>)
which describe the manner in which the execution of these algorithms may be
parallelized and the manner in which they apply the element access functions.</p></div><div class='para' id='exec-2'><div class='marginalizedparent'><a class='marginalized' href='#exec-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/algorithms.tex#L1265'>#</a></div><p >The invocations of element access functions in parallel algorithms invoked with
an execution policy object of type <span class='texttt'>execution::sequenced_policy</span> all occur
in the calling thread of execution.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
The invocations are not interleaved; see <a href='intro.execution'>[intro.execution]</a>.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='exec-3'><div class='marginalizedparent'><a class='marginalized' href='#exec-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/algorithms.tex#L1273'>#</a></div><p >The invocations of element access functions in parallel algorithms invoked with
an execution policy object of type <span class='texttt'>execution::parallel_policy</span> are
permitted to execute in either the invoking thread of execution or in a
thread of execution implicitly
created by the library to support parallel algorithm execution.
If the threads of execution created by <span class='texttt'>thread</span> (<a href='thread.thread.class'>[thread.thread.class]</a>) provide concurrent
forward progress guarantees (<a href='intro.progress'>[intro.progress]</a>), then a thread of execution
implicitly created by the library will provide parallel forward progress guarantees;
otherwise, the provided forward progress guarantee is
<span class='indexparent'><a class='index' id='forward_progress_guarantees_for_implicit_threads_of_parallel_algorithms_(if_not_defined_for_thread)'></a></span>implementation-defined.
Any such
invocations executing in the same thread of execution are indeterminately sequenced with
respect to each other.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
It is the caller's responsibility to ensure that the
invocation does not introduce data races or deadlocks.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
int a[] = {0,1};
std::vector&lt;int&gt; v;
std::for_each(std::execution::par, std::begin(a), std::end(a), [&amp;](int i) {
  v.push_back(i*2+1); <span class='comment'>// incorrect: data race
</span>});</pre><p >The program above has a data race because of the unsynchronized access to the
container <span class='texttt'>v</span>.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
std::atomic&lt;int&gt; x{0};
int a[] = {1,2};
std::for_each(std::execution::par, std::begin(a), std::end(a), [&amp;](int) {
  x.fetch_add(1, std::memory_order_relaxed);
  <span class='comment'>// spin wait for another iteration to change the value of x
</span>  while (x.load(std::memory_order_relaxed) == 1) { } <span class='comment'>// incorrect: assumes execution order
</span>});</pre><p >The above example depends on the order of execution of the iterations, and
will not terminate if both iterations are executed sequentially on the same
thread of execution.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
int x = 0;
std::mutex m;
int a[] = {1,2};
std::for_each(std::execution::par, std::begin(a), std::end(a), [&amp;](int) {
  std::lock_guard&lt;mutex&gt; guard(m);
  ++x;
});</pre><p >The above example synchronizes access to object <span class='texttt'>x</span> ensuring that it is
incremented correctly.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='exec-4'><div class='marginalizedparent'><a class='marginalized' href='#exec-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/algorithms.tex#L1330'>#</a></div><p >The invocations of element access functions in parallel algorithms invoked with
an execution policy of type <span class='texttt'>execution::parallel_unsequenced_policy</span> are
permitted to execute in an unordered fashion in unspecified threads of execution, and
unsequenced with respect to one another within each thread of execution.
These threads of execution are either the invoking thread of execution or threads of
execution implicitly created by the library; the latter will provide weakly parallel
forward progress guarantees. 
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
This means that multiple function object invocations may be interleaved on a
single thread of execution, which overrides the usual guarantee from <a href='intro.execution'>[intro.execution]</a>
that function executions do not interleave with one another.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
Since <span class='texttt'>execution::parallel_unsequenced_policy</span> allows the execution of element
access functions to be interleaved on a single thread of execution, blocking synchronization,
including the use of mutexes, risks deadlock. Thus, the synchronization with
<span class='texttt'>execution::parallel_unsequenced_policy</span> is restricted as
follows:
A standard library function is <a class='hidden_link' href='#def:vectorization-unsafe' id='def:vectorization-unsafe'><i>vectorization-unsafe</i></a> if it is specified
to synchronize with another function invocation, or another function invocation
is specified to synchronize with it, and if it is not a memory allocation or
deallocation function. Vectorization-unsafe standard library functions may not
be invoked by user code called from <span class='texttt'>execution::parallel_unsequenced_policy</span>
algorithms.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
Implementations must ensure that internal synchronization inside standard
library functions does not prevent forward progress when those functions are
executed by threads of execution with weakly parallel forward progress guarantees.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
int x = 0;
std::mutex m;
int a[] = {1,2};
std::for_each(std::execution::par_unseq, std::begin(a), std::end(a), [&amp;](int) {
  std::lock_guard&lt;mutex&gt; guard(m); <span class='comment'>// incorrect: <span class='texttt'>lock_guard</span> constructor calls <span class='texttt'>m.lock()</span>
</span>  ++x;
});</pre><p >The above program may result in two consecutive calls to <span class='texttt'>m.lock()</span> on
the same thread of execution (which may deadlock), because the applications of the function
object are not guaranteed to run on different threads of execution.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
The semantics of the <span class='texttt'>execution::parallel_policy</span> or the
<span class='texttt'>execution::parallel_unsequenced_policy</span> invocation allow the implementation to
fall back to sequential execution if the system cannot parallelize an algorithm
invocation due to lack of resources.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='exec-5'><div class='marginalizedparent'><a class='marginalized' href='#exec-5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/algorithms.tex#L1380'>#</a></div><p >If an invocation of a parallel algorithm uses threads of execution implicitly
created by the library, then the invoking thread of execution will either</p><ul class='itemize'><li id='exec-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#exec-5.1'>(5.1)</a></div><p >temporarily block with forward progress guarantee delegation (<a href='intro.progress'>[intro.progress]</a>)
      on the completion of these library-managed threads of execution, or
</p></li><li id='exec-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#exec-5.2'>(5.2)</a></div><p >eventually execute an element access function;
</p></li></ul><p >the thread of execution will continue to do so until the algorithm is finished.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
In blocking with forward progress guarantee delegation in this context,
a thread of execution created by the library is considered to have
finished execution as soon as it has finished the execution of the
particular element access function that the invoking thread of execution
logically depends on.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='exec-6'><div class='marginalizedparent'><a class='marginalized' href='#exec-6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/algorithms.tex#L1399'>#</a></div><p >The semantics of parallel algorithms invoked with an execution policy object of
<span class='indexparent'><a class='index' id='additional_execution_policies_supported_by_parallel_algorithms'></a></span>implementation-defined type are
<span class='indexparent'><a class='index' id='semantics_of_parallel_algorithms_invoked_with_implementation-defined_execution_policies'></a></span>implementation-defined.</p></div></div><div id='exceptions'><h3 ><a class='secnum' href='#exceptions' style='min-width:103pt'>25.4.4</a> Parallel algorithm exceptions <a class='abbr_ref' href='algorithms.parallel.exceptions'>[algorithms.parallel.exceptions]</a></h3><div class='para' id='exceptions-1'><div class='marginalizedparent'><a class='marginalized' href='#exceptions-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/algorithms.tex#L1407'>#</a></div><p >During the execution of a parallel algorithm, if temporary memory resources are
required for parallelization and none are available, the algorithm throws a
<span class='texttt'>bad_alloc</span> exception.</p></div><div class='para' id='exceptions-2'><div class='marginalizedparent'><a class='marginalized' href='#exceptions-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/algorithms.tex#L1412'>#</a></div><p >During the execution of a parallel algorithm, if the invocation of an element
access function exits via an uncaught exception,
the behavior is determined by the <span class='texttt'>ExecutionPolicy</span>.</p></div></div><div id='overloads'><h3 ><a class='secnum' href='#overloads' style='min-width:103pt'>25.4.5</a> <span class='texttt'>ExecutionPolicy</span> algorithm overloads <a class='abbr_ref' href='algorithms.parallel.overloads'>[algorithms.parallel.overloads]</a></h3><div class='para' id='overloads-1'><div class='marginalizedparent'><a class='marginalized' href='#overloads-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/algorithms.tex#L1419'>#</a></div><p >Parallel algorithms are algorithm overloads. Each parallel algorithm overload
has an additional template type parameter named <span class='texttt'>ExecutionPolicy</span>, which
is the first template parameter.
Additionally, each parallel algorithm overload has an additional function
parameter of type <span class='texttt'>ExecutionPolicy&amp;&amp;</span>, which is the first
function parameter.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i> Not all algorithms have parallel algorithm overloads.<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='overloads-2'><div class='marginalizedparent'><a class='marginalized' href='#overloads-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/algorithms.tex#L1428'>#</a></div><p >Unless otherwise specified, the semantics of <span class='texttt'>ExecutionPolicy</span> algorithm
overloads are identical to their overloads without.</p></div><div class='para' id='overloads-3'><div class='marginalizedparent'><a class='marginalized' href='#overloads-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/8dbc0ac22069c102d3b97e67d31390c4e4c6247a/source/algorithms.tex#L1432'>#</a></div><p >Parallel algorithms shall not participate in overload resolution unless
<span class='texttt'>is_execution_policy_v&lt;decay_t&lt;ExecutionPolicy&gt;&gt;</span> is <span class='texttt'>true</span>.</p></div></div></div></div></body></html>