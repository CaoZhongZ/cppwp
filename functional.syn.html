<!DOCTYPE html><html lang='en'><head><title>[functional.syn]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>20.14</a> Function objects <a class='abbr_ref' href='function.objects#functional.syn'>[function.objects]</a></h2><div id='functional.syn'><h3 ><a class='secnum' style='min-width:103pt'>20.14.1</a> Header <span class='texttt'>&lt;functional&gt;</span> synopsis <a class='abbr_ref'>[functional.syn]</a></h3><p ><span class='indexparent'><a class='index' id='functional'></a></span><span class='indexparent'><a class='index' id='functional'></a></span></p><pre class='codeblock'>
namespace std {
  <span class='comment'>// <a href='func.invoke'>[func.invoke]</a>, invoke
</span>  template &lt;class F, class... Args&gt; result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args);

  <span class='comment'>// <a href='refwrap'>[refwrap]</a>, reference_wrapper
</span>  template &lt;class T&gt; class reference_wrapper;

  template &lt;class T&gt; reference_wrapper&lt;T&gt; ref(T&amp;) noexcept;
  template &lt;class T&gt; reference_wrapper&lt;const T&gt; cref(const T&amp;) noexcept;
  template &lt;class T&gt; void ref(const T&amp;&amp;) = delete;
  template &lt;class T&gt; void cref(const T&amp;&amp;) = delete;

  template &lt;class T&gt; reference_wrapper&lt;T&gt; ref(reference_wrapper&lt;T&gt;) noexcept;
  template &lt;class T&gt; reference_wrapper&lt;const T&gt; cref(reference_wrapper&lt;T&gt;) noexcept;

  <span class='comment'>// <a href='arithmetic.operations'>[arithmetic.operations]</a>, arithmetic operations
</span>  template &lt;class T = void&gt; struct plus;
  template &lt;class T = void&gt; struct minus;
  template &lt;class T = void&gt; struct multiplies;
  template &lt;class T = void&gt; struct divides;
  template &lt;class T = void&gt; struct modulus;
  template &lt;class T = void&gt; struct negate;
  template &lt;&gt; struct plus&lt;void&gt;;
  template &lt;&gt; struct minus&lt;void&gt;;
  template &lt;&gt; struct multiplies&lt;void&gt;;
  template &lt;&gt; struct divides&lt;void&gt;;
  template &lt;&gt; struct modulus&lt;void&gt;;
  template &lt;&gt; struct negate&lt;void&gt;;

  <span class='comment'>// <a href='comparisons'>[comparisons]</a>, comparisons
</span>  template &lt;class T = void&gt; struct equal_to;
  template &lt;class T = void&gt; struct not_equal_to;
  template &lt;class T = void&gt; struct greater;
  template &lt;class T = void&gt; struct less;
  template &lt;class T = void&gt; struct greater_equal;
  template &lt;class T = void&gt; struct less_equal;
  template &lt;&gt; struct equal_to&lt;void&gt;;
  template &lt;&gt; struct not_equal_to&lt;void&gt;;
  template &lt;&gt; struct greater&lt;void&gt;;
  template &lt;&gt; struct less&lt;void&gt;;
  template &lt;&gt; struct greater_equal&lt;void&gt;;
  template &lt;&gt; struct less_equal&lt;void&gt;;

  <span class='comment'>// <a href='logical.operations'>[logical.operations]</a>, logical operations
</span>  template &lt;class T = void&gt; struct logical_and;
  template &lt;class T = void&gt; struct logical_or;
  template &lt;class T = void&gt; struct logical_not;
  template &lt;&gt; struct logical_and&lt;void&gt;;
  template &lt;&gt; struct logical_or&lt;void&gt;;
  template &lt;&gt; struct logical_not&lt;void&gt;;

  <span class='comment'>// <a href='bitwise.operations'>[bitwise.operations]</a>, bitwise operations
</span>  template &lt;class T = void&gt; struct bit_and;
  template &lt;class T = void&gt; struct bit_or;
  template &lt;class T = void&gt; struct bit_xor;
  template &lt;class T = void&gt; struct bit_not;
  template &lt;&gt; struct bit_and&lt;void&gt;;
  template &lt;&gt; struct bit_or&lt;void&gt;;
  template &lt;&gt; struct bit_xor&lt;void&gt;;
  template &lt;&gt; struct bit_not&lt;void&gt;;

  <span class='comment'>// <a href='func.not_fn'>[func.not_fn]</a>, function template <span class='texttt'>not_fn</span>
</span>  template &lt;class F&gt; <i><span class='texttt'>unspecified</span></i> not_fn(F&amp;&amp; f);

  <span class='comment'>// <a href='func.bind'>[func.bind]</a>, bind
</span>  template&lt;class T&gt; struct is_bind_expression;
  template&lt;class T&gt; struct is_placeholder;

  template&lt;class F, class... BoundArgs&gt;
    <i><span class='texttt'>unspecified</span></i> bind(F&amp;&amp;, BoundArgs&amp;&amp;...);
  template&lt;class R, class F, class... BoundArgs&gt;
    <i><span class='texttt'>unspecified</span></i> bind(F&amp;&amp;, BoundArgs&amp;&amp;...);

  namespace placeholders {
    <span class='comment'>// M is the <span class='indexparent'><a class='index' id='number_of_placeholders_for_bind_expressions'></a></span>implementation-defined number of placeholders
</span>    <i><span class='texttt'>see below</span></i> _1;
    <i><span class='texttt'>see below</span></i> _2;
                .
                .
                .
    <i><span class='texttt'>see below</span></i> _M;
  }

  <span class='comment'>// <a href='func.memfn'>[func.memfn]</a>, member function adaptors
</span>  template&lt;class R, class T&gt; <i><span class='texttt'>unspecified</span></i> mem_fn(R T::*) noexcept;

  <span class='comment'>// <a href='func.wrap'>[func.wrap]</a>, polymorphic function wrappers
</span>  class bad_function_call;

  template&lt;class&gt; class function; <span class='comment'>// not defined
</span>  template&lt;class R, class... ArgTypes&gt; class function&lt;R(ArgTypes...)&gt;;

  template&lt;class R, class... ArgTypes&gt;
    void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;) noexcept;

  template&lt;class R, class... ArgTypes&gt;
    bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;
  template&lt;class R, class... ArgTypes&gt;
    bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;
  template&lt;class R, class... ArgTypes&gt;
    bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;
  template&lt;class R, class... ArgTypes&gt;
    bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;

  <span class='comment'>// <a href='func.search'>[func.search]</a>, searchers
</span>  template&lt;class ForwardIterator, class BinaryPredicate = equal_to&lt;&gt;&gt;
    class default_searcher;
  template&lt;class RandomAccessIterator,
           class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt;,
           class BinaryPredicate = equal_to&lt;&gt;&gt;
    class boyer_moore_searcher;
  template&lt;class RandomAccessIterator,
           class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt;,
           class BinaryPredicate = equal_to&lt;&gt;&gt;
    class boyer_moore_horspool_searcher;

  template&lt;class ForwardIterator, class BinaryPredicate = equal_to&lt;&gt;&gt;
  default_searcher&lt;ForwardIterator, BinaryPredicate&gt;
  make_default_searcher(ForwardIterator pat_first, ForwardIterator pat_last,
                        BinaryPredicate pred = BinaryPredicate());
  template&lt;class RandomAccessIterator,
           class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt;,
           class BinaryPredicate = equal_to&lt;&gt;&gt;
  boyer_moore_searcher&lt;RandomAccessIterator, Hash, BinaryPredicate&gt;
  make_boyer_moore_searcher(
      RandomAccessIterator pat_first, RandomAccessIterator pat_last,
      Hash hf = Hash(), BinaryPredicate pred = BinaryPredicate());
  template&lt;class RandomAccessIterator,
           class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt;,
           class BinaryPredicate = equal_to&lt;&gt;&gt;
  boyer_moore_horspool_searcher&lt;RandomAccessIterator, Hash, BinaryPredicate&gt;
  make_boyer_moore_horspool_searcher(
      RandomAccessIterator pat_first, RandomAccessIterator pat_last,
      Hash hf = Hash(), BinaryPredicate pred = BinaryPredicate());

  <span class='comment'>// <a href='unord.hash'>[unord.hash]</a>, hash function primary template
</span>  template &lt;class T&gt; struct hash;

  <span class='comment'>// <a href='func.default.traits'>[func.default.traits]</a>, default functor traits
</span>  template &lt;class T = void&gt;
  struct default_order;

  template &lt;class T = void&gt;
  using default_order_t = typename default_order&lt;T&gt;::type;

  <span class='comment'>// <a href='func.bind'>[func.bind]</a>, function object binders
</span>  template &lt;class T&gt; constexpr bool is_bind_expression_v
    = is_bind_expression&lt;T&gt;::value;
  template &lt;class T&gt; constexpr int is_placeholder_v
    = is_placeholder&lt;T&gt;::value;
}</pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/utilities.tex#L12811'>#</a></div><p >[ <i>Example:</i>
If a C++ program wants to have a by-element addition of two vectors <span class='texttt'>a</span>
and <span class='texttt'>b</span> containing <span class='texttt'>double</span> and put the result into <span class='texttt'>a</span>,
it can do:</p><pre class='codeblock'>
transform(a.begin(), a.end(), b.begin(), a.begin(), plus&lt;double&gt;());</pre><p ><i> â€” end example</i> ]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/utilities.tex#L12822'>#</a></div><p >[ <i>Example:</i>
To negate every element of <span class='texttt'>a</span>:</p><pre class='codeblock'>
transform(a.begin(), a.end(), a.begin(), negate&lt;double&gt;());</pre><p ><i> â€” end example</i> ]</p></div></div></div></body></html>