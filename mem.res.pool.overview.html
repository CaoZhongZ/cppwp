<!DOCTYPE html><html lang='en'><head><title>[mem.res.pool.overview]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>20.12</a> Memory resources <a class='abbr_ref' href='mem.res#pool.overview'>[mem.res]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>20.12.5</a> Pool resource classes <a class='abbr_ref' href='mem.res.pool#overview'>[mem.res.pool]</a></h3><div id='mem.res.pool.overview'><h4 ><a class='secnum' style='min-width:118pt'>20.12.5.1</a> Classes <span class='texttt'>synchronized_pool_resource</span> and <span class='texttt'>unsynchronized_pool_resource</span> <a class='abbr_ref'>[mem.res.pool.overview]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The <span class='texttt'>synchronized_pool_resource</span> and
<span class='texttt'>unsynchronized_pool_resource</span> classes
(collectively called <a class='hidden_link' href='#def:pool_resource_classes' id='def:pool_resource_classes'><i>pool resource classes</i></a>)
are general-purpose memory resources having the following qualities:
</p><ul ><li ><p >Each resource <a class='hidden_link' href='#def:owns' id='def:owns'><i>owns</i></a> the allocated memory, and frees it on destruction –
even if <span class='texttt'>deallocate</span> has not been called for some of the allocated blocks.
</p></li><li ><p >A pool resource consists of a collection of <a class='hidden_link' href='#def:pools' id='def:pools'><i>pools</i></a>,
serving requests for different block sizes.
Each individual pool manages a collection of <a class='hidden_link' href='#def:chunks' id='def:chunks'><i>chunks</i></a>
that are in turn divided into blocks of uniform size,
returned via calls to <span class='texttt'>do_allocate</span>.
Each call to <span class='texttt'>do_allocate(size, alignment)</span> is dispatched
to the pool serving the smallest blocks accommodating at least <span class='texttt'>size</span> bytes.
</p></li><li ><p >When a particular pool is exhausted,
allocating a block from that pool results in the allocation
of an additional chunk of memory from the <a class='hidden_link' href='#def:upstream_allocator' id='def:upstream_allocator'><i>upstream allocator</i></a>
(supplied at construction), thus replenishing the pool.
With each successive replenishment,
the chunk size obtained increases geometrically.
[&nbsp;<i>Note:</i><span class='space'></span>
By allocating memory in chunks,
the pooling strategy increases the chance that consecutive allocations
will be close together in memory.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li><li ><p >Allocation requests that exceed the largest block size of any pool
are fulfilled directly from the upstream allocator.
</p></li><li ><p >A <span class='texttt'>pool_options</span> struct may be passed to the pool resource constructors
to tune the largest block size and the maximum chunk size.
</p></li></ul></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >A <span class='texttt'>synchronized_pool_resource</span> may be accessed from multiple threads
without external synchronization
and may have thread-specific pools to reduce synchronization costs.
An <span class='texttt'>unsynchronized_pool_resource</span> class may not be accessed
from multiple threads simultaneously
and thus avoids the cost of synchronization entirely
in single-threaded applications.</p><p ><span class='indexparent'><a class='index' id='pool_options'></a></span><span class='indexparent'><a class='index' id='synchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='unsynchronized_pool_resource'></a></span></p><pre class='codeblock'>
struct pool_options {
  size_t max_blocks_per_chunk = 0;
  size_t largest_required_pool_block = 0;
};

class synchronized_pool_resource : public memory_resource {
public:
  synchronized_pool_resource(const pool_options &amp;opts,
                             memory_resource *upstream);

  synchronized_pool_resource()
      : synchronized_pool_resource(pool_options(), get_default_resource()) {}
  explicit synchronized_pool_resource(memory_resource *upstream)
      : synchronized_pool_resource(pool_options(), upstream) {}
  explicit synchronized_pool_resource(const pool_options &amp;opts)
      : synchronized_pool_resource(opts, get_default_resource()) {}

  synchronized_pool_resource(const synchronized_pool_resource &amp;) = delete;
  virtual ~synchronized_pool_resource();

  synchronized_pool_resource &amp;
    operator=(const synchronized_pool_resource &amp;) = delete;

  void release();
  memory_resource *upstream_resource() const;
  pool_options options() const;

protected:
  void *do_allocate(size_t bytes, size_t alignment) override;
  void do_deallocate(void *p, size_t bytes, size_t alignment) override;

  bool do_is_equal(const memory_resource &amp;other) const noexcept override;
};

class unsynchronized_pool_resource : public memory_resource {
public:
  unsynchronized_pool_resource(const pool_options &amp;opts,
                               memory_resource *upstream);

  unsynchronized_pool_resource()
      : unsynchronized_pool_resource(pool_options(), get_default_resource()) {}
  explicit unsynchronized_pool_resource(memory_resource *upstream)
      : unsynchronized_pool_resource(pool_options(), upstream) {}
  explicit unsynchronized_pool_resource(const pool_options &amp;opts)
      : unsynchronized_pool_resource(opts, get_default_resource()) {}

  unsynchronized_pool_resource(const unsynchronized_pool_resource &amp;) = delete;
  virtual ~unsynchronized_pool_resource();

  unsynchronized_pool_resource &amp;
    operator=(const unsynchronized_pool_resource &amp;) = delete;

  void release();
  memory_resource *upstream_resource() const;
  pool_options options() const;

protected:
  void *do_allocate(size_t bytes, size_t alignment) override;
  void do_deallocate(void *p, size_t bytes, size_t alignment) override;

  bool do_is_equal(const memory_resource &amp;other) const noexcept override;
};
</pre></div></div></div></body></html>