<!DOCTYPE html><html lang='en'><head><title>[mem.res.pool.overview]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>23</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>23.12</a> Memory resources <a class='abbr_ref' href='mem.res#pool.overview'>[mem.res]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>23.12.5</a> Pool resource classes <a class='abbr_ref' href='mem.res.pool#overview'>[mem.res.pool]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>23.12.5.1</a> Classes <span class='texttt'>synchronized_&shy;pool_&shy;resource</span> and <span class='texttt'>unsynchronized_&shy;pool_&shy;resource</span> <a class='abbr_ref'>[mem.res.pool.overview]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/4ba4e9c2c04b7680ac2a56b65c241ec10c427c3f/source/utilities.tex#L11525'>#</a></div><div id='1.sentence-1' class='sentence'>The <span class='texttt'>synchronized_&shy;pool_&shy;resource</span> and
<span class='texttt'>unsynchronized_&shy;pool_&shy;resource</span> classes
(collectively called <a class='hidden_link' href='#def:pool_resource_classes' id='def:pool_resource_classes'><i >pool resource classes</i></a>)
are general-purpose memory resources having the following qualities:
<ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><div id='1.1.sentence-1' class='sentence'>Each resource frees its allocated memory on destruction,
even if <span class='texttt'>deallocate</span> has not been called for some of the allocated blocks<a class='hidden_link' href='#1.1.sentence-1'>.</a></div></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><div id='1.2.sentence-1' class='sentence'>A pool resource consists of a collection of <a class='hidden_link' href='#def:pools' id='def:pools'><i >pools</i></a>,
serving requests for different block sizes<a class='hidden_link' href='#1.2.sentence-1'>.</a></div> <div id='1.2.sentence-2' class='sentence'>Each individual pool manages a collection of <a class='hidden_link' href='#def:chunks' id='def:chunks'><i >chunks</i></a>
that are in turn divided into blocks of uniform size,
returned via calls to <span class='texttt'>do_&shy;allocate</span><a class='hidden_link' href='#1.2.sentence-2'>.</a></div> <div id='1.2.sentence-3' class='sentence'>Each call to <span class='texttt'>do_&shy;allocate(size, alignment)</span> is dispatched
to the pool serving the smallest blocks accommodating at least <span class='texttt'>size</span> bytes<a class='hidden_link' href='#1.2.sentence-3'>.</a></div></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><div id='1.3.sentence-1' class='sentence'>When a particular pool is exhausted,
allocating a block from that pool results in the allocation
of an additional chunk of memory from the <a class='hidden_link' href='#def:upstream_allocator' id='def:upstream_allocator'><i >upstream allocator</i></a>
(supplied at construction), thus replenishing the pool<a class='hidden_link' href='#1.3.sentence-1'>.</a></div> <div id='1.3.sentence-2' class='sentence'>With each successive replenishment,
the chunk size obtained increases geometrically<a class='hidden_link' href='#1.3.sentence-2'>.</a></div> <div id='1.3.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#1.3.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='1.3.sentence-3' class='sentence'>By allocating memory in chunks,
the pooling strategy increases the chance that consecutive allocations
will be close together in memory<a class='hidden_link' href='#1.3.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </li><li id='1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.4'>(1.4)</a></div><div id='1.4.sentence-1' class='sentence'>Allocation requests that exceed the largest block size of any pool
are fulfilled directly from the upstream allocator<a class='hidden_link' href='#1.4.sentence-1'>.</a></div></li><li id='1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.5'>(1.5)</a></div><div id='1.5.sentence-1' class='sentence'>A <span class='texttt'>pool_&shy;options</span> struct may be passed to the pool resource constructors
to tune the largest block size and the maximum chunk size<a class='hidden_link' href='#1.5.sentence-1'>.</a></div></li></ul></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/4ba4e9c2c04b7680ac2a56b65c241ec10c427c3f/source/utilities.tex#L11561'>#</a></div><div id='2.sentence-1' class='sentence'>A <span class='texttt'>synchronized_&shy;pool_&shy;resource</span> may be accessed from multiple threads
without external synchronization
and may have thread-specific pools to reduce synchronization costs<a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>An <span class='texttt'>unsynchronized_&shy;pool_&shy;resource</span> class may not be accessed
from multiple threads simultaneously
and thus avoids the cost of synchronization entirely
in single-threaded applications<a class='hidden_link' href='#2.sentence-2'>.</a></div><span class='indexparent'><a class='index' id='lib:pool_options'></a></span><span class='indexparent'><a class='index' id='lib:synchronized_pool_resource'></a></span><span class='indexparent'><a class='index' id='lib:unsynchronized_pool_resource'></a></span><pre class='codeblock'>
namespace std::pmr {
  struct pool_options {
    size_t max_blocks_per_chunk = 0;
    size_t largest_required_pool_block = 0;
  };

  class synchronized_pool_resource : public memory_resource {
  public:
    synchronized_pool_resource(const pool_options&amp; opts, memory_resource* upstream);

    synchronized_pool_resource()
        : synchronized_pool_resource(pool_options(), get_default_resource()) {}
    explicit synchronized_pool_resource(memory_resource* upstream)
        : synchronized_pool_resource(pool_options(), upstream) {}
    explicit synchronized_pool_resource(const pool_options&amp; opts)
        : synchronized_pool_resource(opts, get_default_resource()) {}

    synchronized_pool_resource(const synchronized_pool_resource&amp;) = delete;
    virtual ~synchronized_pool_resource();

    synchronized_pool_resource&amp; operator=(const synchronized_pool_resource&amp;) = delete;

    void release();
    memory_resource* upstream_resource() const;
    pool_options options() const;

  protected:
    void *do_allocate(size_t bytes, size_t alignment) override;
    void do_deallocate(void *p, size_t bytes, size_t alignment) override;

    bool do_is_equal(const memory_resource&amp; other) const noexcept override;
  };

  class unsynchronized_pool_resource : public memory_resource {
  public:
    unsynchronized_pool_resource(const pool_options&amp; opts, memory_resource* upstream);

    unsynchronized_pool_resource()
        : unsynchronized_pool_resource(pool_options(), get_default_resource()) {}
    explicit unsynchronized_pool_resource(memory_resource* upstream)
        : unsynchronized_pool_resource(pool_options(), upstream) {}
    explicit unsynchronized_pool_resource(const pool_options&amp; opts)
        : unsynchronized_pool_resource(opts, get_default_resource()) {}

    unsynchronized_pool_resource(const unsynchronized_pool_resource&amp;) = delete;
    virtual ~unsynchronized_pool_resource();

    unsynchronized_pool_resource&amp; operator=(const unsynchronized_pool_resource&amp;) = delete;

    void release();
    memory_resource *upstream_resource() const;
    pool_options options() const;

  protected:
    void* do_allocate(size_t bytes, size_t alignment) override;
    void do_deallocate(void* p, size_t bytes, size_t alignment) override;

    bool do_is_equal(const memory_resource&amp; other) const noexcept override;
  };
}</pre></div></div></body></html>