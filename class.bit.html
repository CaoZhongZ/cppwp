<!DOCTYPE html><html lang='en'><head><title>[class.bit]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>9</a> Classes <a class='abbr_ref' href='./#class'>[class]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>9.2</a> Class members <a class='abbr_ref' href='class.mem#class.bit'>[class.mem]</a></h2><div id='class.bit'><h3 ><a class='secnum' style='min-width:103pt'>9.2.4</a> Bit-fields <a class='abbr_ref'>[class.bit]</a></h3><p ><span class='indexparent'><a class='index' id='bit-field'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >A <i ><a href='class.mem#member-declarator'>member-declarator</a></i> of the form</p><pre class='bnf'><i ><a href='lex.name#identifier'>identifier</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span>  <i ><a href='dcl.attr.grammar#attribute-specifier-seq'>attribute-specifier-seq</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>:</span> <i ><a href='expr.const#constant-expression'>constant-expression</a></i></pre><p ><span class='indexparent'><a class='index' id=':!field declaration'></a></span><span class='indexparent'><a class='index' id='declaration!bit-field'></a></span>specifies a bit-field;
its length is set off from the bit-field name by a colon. The optional <i ><a href='dcl.attr.grammar#attribute-specifier-seq'>attribute-specifier-seq</a></i> appertains to the entity being declared. The bit-field
attribute is not part of the type of the class member. The
<i ><a href='expr.const#constant-expression'>constant-expression</a></i> shall be an integral constant expression
with a value greater than or equal to zero. The
value of the integral constant expression may
be larger than the number of bits in the object
representation (<a href='basic.types'>[basic.types]</a>) of the bit-field's type; in such
cases the extra bits are used as padding bits and do not participate in
the value representation (<a href='basic.types'>[basic.types]</a>) of the bit-field.
<span class='indexparent'><a class='index' id='allocation!implementation~defined bit-field'></a></span>Allocation of bit-fields within a class object is
<span class='indexparent'><a class='index' id='allocation of bit-fields within a class object'></a></span>implementation-defined.
<span class='indexparent'><a class='index' id='bit-field!implementation~defined alignment~of'></a></span>Alignment of bit-fields is <span class='indexparent'><a class='index' id='alignment of bit-fields within a class object'></a></span>implementation-defined.
<span class='indexparent'><a class='index' id='layout!bit-field'></a></span>Bit-fields are packed into some addressable allocation unit.
[&nbsp;<i>Note:</i><span class='space'></span>
Bit-fields straddle allocation units on some machines and not on others.
Bit-fields are assigned right-to-left on some machines, left-to-right on
others.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='bit-field!unnamed'></a></span>A declaration for a bit-field that omits the <i ><a href='lex.name#identifier'>identifier</a></i>
declares an <span class='grammarterm'>unnamed</span> bit-field. Unnamed bit-fields are not
members and cannot be initialized.
[&nbsp;<i>Note:</i><span class='space'></span>
An unnamed bit-field is useful for padding to conform to
externally-imposed layouts.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
<span class='indexparent'><a class='index' id='bit-field!zero~width~of'></a></span><span class='indexparent'><a class='index' id='bit-field!alignment~of'></a></span>As a special case, an unnamed bit-field with a width of zero specifies
alignment of the next bit-field at an allocation unit boundary. Only
when declaring an unnamed bit-field may the value of the
<i ><a href='expr.const#constant-expression'>constant-expression</a></i> be equal to zero.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p ><span class='indexparent'><a class='index' id='bit-field!type~of'></a></span>A bit-field shall not be a static member. A bit-field shall have
integral or enumeration type (<a href='basic.fundamental'>[basic.fundamental]</a>).
<span class='indexparent'><a class='index' id='Boolean'></a></span>A <span class='texttt'>bool</span> value can successfully be stored in a bit-field of any
nonzero size.
<span class='indexparent'><a class='index' id='bit-field!address~of'></a></span>The address-of operator <span class='texttt'>&amp;</span> shall not be applied to a bit-field,
so there are no pointers to bit-fields.
<span class='indexparent'><a class='index' id='restriction!bit-field'></a></span><span class='indexparent'><a class='index' id='restriction!address~of bit-field'></a></span><span class='indexparent'><a class='index' id='restriction!pointer~to bit-field'></a></span>A non-const reference shall not be bound to a
bit-field (<a href='dcl.init.ref'>[dcl.init.ref]</a>).
[&nbsp;<i>Note:</i><span class='space'></span>
If the initializer for a reference of type <span class='texttt'>const</span> <span class='texttt'>T&amp;</span> is
an lvalue that refers to a bit-field, the reference is bound to a
temporary initialized to hold the value of the bit-field; the reference
is not bound to the bit-field directly. See <a href='dcl.init.ref'>[dcl.init.ref]</a>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >If the value <span class='texttt'>true</span> or <span class='texttt'>false</span> is stored into a bit-field of
type <span class='texttt'>bool</span> of any size (including a one bit bit-field), the
original <span class='texttt'>bool</span> value and the value of the bit-field shall compare
equal. If the value of an enumerator is stored into a bit-field of the
same enumeration type and the number of bits in the bit-field is large
enough to hold all the values of that enumeration type (<a href='dcl.enum'>[dcl.enum]</a>),
the original enumerator value and the value of the bit-field shall
compare equal.
[&nbsp;<i>Example:</i><span class='space'></span></p><pre class='codeblock'>
enum BOOL { FALSE=0, TRUE=1 };
struct A {
  BOOL b:1;
};
A a;
void f() {
  a.b = TRUE;
  if (a.b == TRUE)              <span class='comment'>// yields <span class='texttt'>true</span>
</span>    { <span class='comment'>/* ... */</span> }
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]</p></div></div></div></body></html>