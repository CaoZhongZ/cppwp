<!DOCTYPE html><html lang='en'><head><title>[temp.over.link]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.5</a> Template declarations <a class='abbr_ref' href='temp.decls#temp.over.link'>[temp.decls]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>14.5.6</a> Function templates <a class='abbr_ref' href='temp.fct#temp.over.link'>[temp.fct]</a></h3><div id='temp.over.link'><h4 ><a class='secnum' style='min-width:118pt'>14.5.6.1</a> Function template overloading <a class='abbr_ref'>[temp.over.link]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/templates.tex#L2596'>#</a></div><p ><span class='indexparent'><a class='index' id='overloading'></a></span>It is possible to overload function templates so that two different
function template specializations have the same type.
[ <i>Example:</i></p><div class='minipage'><pre class='codeblock'>
<span class='comment'>// translation unit 1:
</span>template&lt;class T&gt;
  void f(T*);
void g(int* p) {
  f(p); <span class='comment'>// calls <span class='texttt'>f&lt;int&gt;(int*)</span>
</span>}</pre></div><div class='minipage'><pre class='codeblock'>
<span class='comment'>// translation unit 2:
</span>template&lt;class T&gt;
  void f(T);
void h(int* p) {
  f(p); <span class='comment'>// calls <span class='texttt'>f&lt;int*&gt;(int*)</span>
</span>}</pre></div><p ><i> — end example</i> ]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/templates.tex#L2625'>#</a></div><p >Such specializations are distinct functions and do not violate the one-definition
rule (<a href='basic.def.odr'>[basic.def.odr]</a>).</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/templates.tex#L2629'>#</a></div><p >The signature of a function template
is defined in <a href='intro.defs'>[intro.defs]</a>.
The names of the template parameters are significant only for establishing
the relationship between the template parameters and the rest of the
signature.
[ <i>Note:</i>
Two distinct function templates may have identical function return types and
function parameter lists, even if overload resolution alone cannot distinguish
them.</p><pre class='codeblock'>
template&lt;class T&gt; void f();
template&lt;int I&gt; void f();       <span class='comment'>// OK: overloads the first template
</span>                                <span class='comment'>// distinguishable with an explicit template argument list
</span></pre><p ><i> — end note</i> ]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/templates.tex#L2647'>#</a></div><p >When an expression that references a template parameter is used in the
function parameter list or the return type in the declaration of a
function template, the expression that references the template
parameter is part of the signature of the function template.
This is
necessary to permit a declaration of a function template in one
translation unit to be linked with another declaration of the function
template in another translation unit and, conversely, to ensure that
function templates that are intended to be distinct are not linked
with one another.
[ <i>Example:</i></p><pre class='codeblock'>
template &lt;int I, int J&gt; A&lt;I+J&gt; f(A&lt;I&gt;, A&lt;J&gt;);   <span class='comment'>// #1
</span>template &lt;int K, int L&gt; A&lt;K+L&gt; f(A&lt;K&gt;, A&lt;L&gt;);   <span class='comment'>// same as #1
</span>template &lt;int I, int J&gt; A&lt;I-J&gt; f(A&lt;I&gt;, A&lt;J&gt;);   <span class='comment'>// different from #1
</span></pre><p ><i> — end example</i> ]
[ <i>Note:</i>
Most expressions that use template parameters use non-type template
parameters, but it is possible for an expression to reference a type
parameter.
For example, a template type parameter can be used in the
<span class='texttt'>sizeof</span> operator.
<i> — end note</i> ]</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/templates.tex#L2674'>#</a></div><p >Two expressions involving template parameters are considered
<a class='hidden_link' href='#def:equivalent' id='def:equivalent'><i>equivalent</i></a>
if two function definitions containing the expressions would satisfy
the one-definition rule (<a href='basic.def.odr'>[basic.def.odr]</a>), except that the tokens used
to name the template parameters may differ as long as a token used to
name a template parameter in one expression is replaced by another token
that names the same template parameter in the other expression. For
determining whether two dependent names (<a href='temp.dep'>[temp.dep]</a>) are
equivalent, only the name itself is considered, not the result of name
lookup in the context of the template. If multiple declarations of the
same function template differ in the result of this name lookup, the
result for the first declaration is used.
[ <i>Example:</i></p><pre class='codeblock'>
template &lt;int I, int J&gt; void f(A&lt;I+J&gt;);         <span class='comment'>// #1
</span>template &lt;int K, int L&gt; void f(A&lt;K+L&gt;);         <span class='comment'>// same as #1
</span>
template &lt;class T&gt; decltype(g(T())) h();
int g(int);
template &lt;class T&gt; decltype(g(T())) h()         <span class='comment'>// redeclaration of <span class='texttt'>h()</span> uses the earlier lookup
</span>  { return g(T()); }                            <span class='comment'>// ...although the lookup here does find <span class='texttt'>g(int)</span>
</span>int i = h&lt;int&gt;();                               <span class='comment'>// template argument substitution fails; <span class='texttt'>g(int)</span>
</span>                                                <span class='comment'>// was not in scope at the first declaration of <span class='texttt'>h()</span>
</span></pre><p ><i> — end example</i> ]
Two expressions involving template parameters that are not equivalent are
<a class='hidden_link' href='#def:functionally_equivalent' id='def:functionally_equivalent'><i>functionally equivalent</i></a>
if, for any given set of template arguments, the evaluation of the
expression results in the same value.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/templates.tex#L2706'>#</a></div><p >Two function templates are
<a class='hidden_link' href='#def:equivalent' id='def:equivalent'><i>equivalent</i></a>
if they are declared in the same scope, have the same name, have
identical template parameter lists, and have return types and parameter
lists that are equivalent using the rules described above to compare
expressions involving
template parameters.
Two function templates are
<a class='hidden_link' href='#def:functionally_equivalent' id='def:functionally_equivalent'><i>functionally equivalent</i></a>
if they are equivalent except that one or more
expressions
that involve template parameters in the return types and parameter
lists are functionally equivalent using the rules described above to
compare expressions involving
template parameters.
If a program contains declarations of function templates that are
functionally equivalent but not equivalent, the program is ill-formed;
no diagnostic is required.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/e5ca011e3f449e4ae1ac4777e587a4534be46224/source/templates.tex#L2726'>#</a></div><p >[ <i>Note:</i>
This rule guarantees that equivalent declarations will be linked with
one another, while not requiring implementations to use heroic efforts
to guarantee that functionally equivalent declarations will be treated
as distinct.
For example, the last two declarations are functionally
equivalent and would cause a program to be ill-formed:</p><pre class='codeblock'>
<span class='comment'>// Guaranteed to be the same
</span>template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);
template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);

<span class='comment'>// Guaranteed to be different
</span>template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);
template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+11&gt;);

<span class='comment'>// Ill-formed, no diagnostic required
</span>template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);
template &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+1+2+3+4&gt;);</pre><p ><i> — end note</i> ]</p></div></div></div></body></html>