<!DOCTYPE html><html lang='en'><head><title>[over.over]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>16</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>16.4</a> Address of overloaded function <a class='abbr_ref'>[over.over]</a></h2><p ><span class='indexparent'><a class='index' id=':overloading,address_of_overloaded_function'></a></span><span class='indexparent'><a class='index' id=':overloaded_function,address_of'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/overloading.tex#L2693'>#</a></div><p >A use of an overloaded function name without arguments is resolved
in certain contexts to a function, a pointer to function or a pointer to
member function for a specific function from the overload set.
A function template name is considered to name a set of overloaded functions
in such contexts.
A function with type <span class='texttt'>F</span> is selected for the function type <span class='texttt'>FT</span>
of the target type required in the context if <span class='texttt'>F</span>
(after possibly applying the <a href='conv.fctptr'>function pointer conversion</a>)
is identical to <span class='texttt'>FT</span>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
That is, the class of which the function is a member is ignored when matching a
pointer-to-member-function type.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
The target can be</p><ul class='itemize'><li id='1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.1'>(1.1)</a></div><p >an object or reference being initialized (<a href='dcl.init'>[dcl.init]</a>, <a href='dcl.init.ref'>[dcl.init.ref]</a>,
<a href='dcl.init.list'>[dcl.init.list]</a>),
</p></li><li id='1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.2'>(1.2)</a></div><p >the left side of an <a href='expr.ass'>assignment</a>,
</p></li><li id='1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.3'>(1.3)</a></div><p >a parameter of a function (<a href='expr.call'>[expr.call]</a>),
</p></li><li id='1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.4'>(1.4)</a></div><p >a parameter of a <a href='over.oper'>user-defined operator</a>,
</p></li><li id='1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.5'>(1.5)</a></div><p >the return value of a function, operator function, or conversion (<a href='stmt.return'>[stmt.return]</a>),
</p></li><li id='1.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.6'>(1.6)</a></div><p >an explicit type conversion (<a href='expr.type.conv'>[expr.type.conv]</a>, <a href='expr.static.cast'>[expr.static.cast]</a>,
<a href='expr.cast'>[expr.cast]</a>), or
</p></li><li id='1.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#1.7'>(1.7)</a></div><p >a non-type
<i ><a href='temp.param#nt:template-parameter'>template-parameter</a></i> (<a href='temp.arg.nontype'>[temp.arg.nontype]</a>).
</p></li></ul><p >The overloaded function name can be preceded by the
<span class='texttt'>&amp;</span>
operator.
An overloaded function name shall not be used without arguments in contexts
other than those listed.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
Any redundant set of parentheses surrounding the overloaded function name is
ignored (<a href='expr.prim'>[expr.prim]</a>).
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/overloading.tex#L2739'>#</a></div><p >If the name is a function template, template argument deduction is
done (<a href='temp.deduct.funcaddr'>[temp.deduct.funcaddr]</a>), and if the argument deduction succeeds,
the
resulting template argument list is
used to generate a single
function template specialization,
which is added to the set of overloaded functions
considered.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
As described in <a href='temp.arg.explicit'>[temp.arg.explicit]</a>, if deduction fails and the
function template name is followed by an explicit template argument list,
the
<i ><a href='temp.names#nt:template-id'>template-id</a></i>
is then examined to see whether it identifies a single function template
specialization. If it does, the
<i ><a href='temp.names#nt:template-id'>template-id</a></i>
is considered to be an lvalue for that function template specialization.
The target type is not used in that determination.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/overloading.tex#L2760'>#</a></div><p >Non-member functions and static member functions
match targets of function pointer type or
reference to function type.
Non-static member functions match targets of
pointer to member function type.
If a non-static member function is selected, the reference to the overloaded
function name is required to have the form of a pointer to member as
described in <a href='expr.unary.op'>[expr.unary.op]</a>.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/overloading.tex#L2770'>#</a></div><p >If more than one function is selected, any
function template specializations
in the set
are eliminated if the set also contains a function that is not a
function template specialization, and
any given
function template specialization
<span class='texttt'>F1</span>
is eliminated if the set contains a second
function template specialization whose function template
is more specialized than the
function template of
<span class='texttt'>F1</span>
according to
the partial ordering rules of <a href='temp.func.order'>[temp.func.order]</a>.
After such eliminations,
if any, there shall remain exactly one selected function.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/overloading.tex#L2789'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
int f(double);
int f(int);
int (*pfd)(double) = &amp;f;        <span class='comment'>// selects <span class='tcode_in_codeblock'>f(double)</span>
</span>int (*pfi)(int) = &amp;f;           <span class='comment'>// selects <span class='tcode_in_codeblock'>f(int)</span>
</span>int (*pfe)(...) = &amp;f;           <span class='comment'>// error: type mismatch
</span>int (&amp;rfi)(int) = f;            <span class='comment'>// selects <span class='tcode_in_codeblock'>f(int)</span>
</span>int (&amp;rfd)(double) = f;         <span class='comment'>// selects <span class='tcode_in_codeblock'>f(double)</span>
</span>void g() {
  (int (*)(int))&amp;f;             <span class='comment'>// cast expression as selector
</span>}</pre><p >The initialization of
<span class='texttt'>pfe</span>
is ill-formed because no
<span class='texttt'>f()</span>
with type
<span class='texttt'>int(...)</span>
has been declared, and not because of any ambiguity.
For another example,</p><pre class='codeblock'>
struct X {
  int f(int);
  static int f(long);
};

int (X::*p1)(int)  = &amp;X::f;     <span class='comment'>// OK
</span>int    (*p2)(int)  = &amp;X::f;     <span class='comment'>// error: mismatch
</span>int    (*p3)(long) = &amp;X::f;     <span class='comment'>// OK
</span>int (X::*p4)(long) = &amp;X::f;     <span class='comment'>// error: mismatch
</span>int (X::*p5)(int)  = &amp;(X::f);   <span class='comment'>// error: wrong syntax for
</span>                                <span class='comment'>// pointer to member
</span>int    (*p6)(long) = &amp;(X::f);   <span class='comment'>// OK
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/overloading.tex#L2829'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
If
<span class='texttt'>f()</span>
and
<span class='texttt'>g()</span>
are both overloaded functions, the
cross product of possibilities must be considered
to resolve
<span class='texttt'>f(&amp;g)</span>,
or the equivalent expression
<span class='texttt'>f(g)</span>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/overloading.tex#L2843'>#</a></div><p ><span class='indexparent'><a class='index' id=':conversion,overload_resolution_and_pointer'></a></span>[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
Even if <span class='texttt'>B</span> is a public base of <span class='texttt'>D</span>,
we have</p><pre class='codeblock'>
D* f();
B* (*p1)() = &amp;f;                <span class='comment'>// error
</span>
void g(D*);
void (*p2)(B*) = &amp;g;            <span class='comment'>// error
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div></div></body></html>