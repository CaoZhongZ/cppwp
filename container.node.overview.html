<!DOCTYPE html><html lang='en'><head><title>[container.node.overview]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>26</a> Containers library <a class='abbr_ref' href='./#containers'>[containers]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>26.2</a> Container requirements <a class='abbr_ref' href='container.requirements#container.node.overview'>[container.requirements]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>26.2.4</a> Node handles <a class='abbr_ref' href='container.node#overview'>[container.node]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>26.2.4.1</a> <span class='texttt'>node_&shy;handle</span> overview <a class='abbr_ref'>[container.node.overview]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/9d8d06a6601794478075b01009c82d61e7d47445/source/containers.tex#L1194'>#</a></div><div id='1.sentence-1' class='sentence'>A <a class='hidden_link' href='#def:node_handle' id='def:node_handle'><i>node handle</i></a> is an object that accepts ownership of a single element
from an <a href='associative.reqmts'>associative container</a> or an <a href='unord.req'>unordered
associative container</a><a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.sentence-2' class='sentence'>It may be used to transfer that
ownership to another container with compatible nodes<a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.sentence-3' class='sentence'>Containers with
compatible nodes have the same node handle type<a class='hidden_link' href='#1.sentence-3'>.</a></div> <div id='1.sentence-4' class='sentence'>Elements may be transferred in
either direction between container types in the same row of
Table <a href='#tab:containers.node.compat'>89</a><a class='hidden_link' href='#1.sentence-4'>.</a></div><div class='numberedTable' id='tab:containers.node.compat'>Table <a href='#tab:containers.node.compat'>89</a> â€” Container types with compatible nodes<br><table ><tr class='rowsep'><td class='left'><div id='1.sentence-5' class='sentence'><span class='texttt'>map&lt;K, T, C1, A&gt;</span></div></td><td class='left'><div id='1.sentence-6' class='sentence'><span class='texttt'>map&lt;K, T, C2, A&gt;</span></div></td></tr><tr class='rowsep'><td class='left'><div id='1.sentence-7' class='sentence'><span class='texttt'>map&lt;K, T, C1, A&gt;</span></div></td><td class='left'><div id='1.sentence-8' class='sentence'><span class='texttt'>multimap&lt;K, T, C2, A&gt;</span></div></td></tr><tr class='rowsep'><td class='left'><div id='1.sentence-9' class='sentence'><span class='texttt'>set&lt;K, C1, A&gt;</span></div></td><td class='left'><div id='1.sentence-10' class='sentence'><span class='texttt'>set&lt;K, C2, A&gt;</span></div></td></tr><tr class='rowsep'><td class='left'><div id='1.sentence-11' class='sentence'><span class='texttt'>set&lt;K, C1, A&gt;</span></div></td><td class='left'><div id='1.sentence-12' class='sentence'><span class='texttt'>multiset&lt;K, C2, A&gt;</span></div></td></tr><tr class='rowsep'><td class='left'><div id='1.sentence-13' class='sentence'><span class='texttt'>unordered_&shy;map&lt;K, T, H1, E1, A&gt;</span></div></td><td class='left'><div id='1.sentence-14' class='sentence'><span class='texttt'>unordered_&shy;map&lt;K, T, H2, E2, A&gt;</span></div></td></tr><tr class='rowsep'><td class='left'><div id='1.sentence-15' class='sentence'><span class='texttt'>unordered_&shy;map&lt;K, T, H1, E1, A&gt;</span></div></td><td class='left'><div id='1.sentence-16' class='sentence'><span class='texttt'>unordered_&shy;multimap&lt;K, T, H2, E2, A&gt;</span></div></td></tr><tr class='rowsep'><td class='left'><div id='1.sentence-17' class='sentence'><span class='texttt'>unordered_&shy;set&lt;K, H1, E1, A&gt;</span></div></td><td class='left'><div id='1.sentence-18' class='sentence'><span class='texttt'>unordered_&shy;set&lt;K, H2, E2, A&gt;</span></div></td></tr><tr class='rowsep'><td class='left'><div id='1.sentence-19' class='sentence'><span class='texttt'>unordered_&shy;set&lt;K, H1, E1, A&gt;</span></div></td><td class='left'><div id='1.sentence-20' class='sentence'><span class='texttt'>unordered_&shy;multiset&lt;K, H2, E2, A&gt;</span></div></td></tr></table></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/9d8d06a6601794478075b01009c82d61e7d47445/source/containers.tex#L1223'>#</a></div><div id='2.sentence-1' class='sentence'>If a node handle is not empty, then it contains an allocator that is equal to
the allocator of the container when the element was extracted<a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>If a node handle
is empty, it contains no allocator<a class='hidden_link' href='#2.sentence-2'>.</a></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/9d8d06a6601794478075b01009c82d61e7d47445/source/containers.tex#L1228'>#</a></div><div id='3.sentence-1' class='sentence'>Class <span class='texttt'><span class='textit'>node_&shy;handle</span></span> is for exposition only<a class='hidden_link' href='#3.sentence-1'>.</a></div> <div id='3.sentence-2' class='sentence'>An implementation is
permitted to provide equivalent functionality without providing a class with
this name<a class='hidden_link' href='#3.sentence-2'>.</a></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/9d8d06a6601794478075b01009c82d61e7d47445/source/containers.tex#L1233'>#</a></div><div id='4.sentence-1' class='sentence'>If a user-defined specialization of <span class='texttt'>pair</span> exists for
<span class='texttt'>pair&lt;const Key, T&gt;</span> or <span class='texttt'>pair&lt;Key, T&gt;</span>, where <span class='texttt'>Key</span> is the
container's <span class='texttt'>key_&shy;type</span> and <span class='texttt'>T</span> is the container's
<span class='texttt'>mapped_&shy;type</span>, the behavior of operations involving node handles is
undefined<a class='hidden_link' href='#4.sentence-1'>.</a></div><pre class='codeblock'>
template&lt;<span class='textit'><span class='texttt'>unspecified</span></span>&gt;
  class <span class='textit'>node_handle</span> {
  public:
    <span class='comment'>// These type declarations are described in Tables <a href='associative.reqmts#tab:containers.associative.requirements'>90</a> and <a href='unord.req#tab:HashRequirements'>91</a>.
</span>    using value_type     = <span class='textit'><span class='texttt'>see below</span></span>;   <span class='comment'>// not present for map containers
</span>    using key_type       = <span class='textit'><span class='texttt'>see below</span></span>;   <span class='comment'>// not present for set containers
</span>    using mapped_type    = <span class='textit'><span class='texttt'>see below</span></span>;   <span class='comment'>// not present for set containers
</span>    using allocator_type = <span class='textit'><span class='texttt'>see below</span></span>;

  private:
    using container_node_type = <span class='textit'><span class='texttt'>unspecified</span></span>;
    using ator_traits = allocator_traits&lt;allocator_type&gt;;

    typename ator_traits::rebind_traits&lt;container_node_type&gt;::pointer ptr_;
    optional&lt;allocator_type&gt; alloc_;

  public:
    constexpr <span class='textit'>node_handle</span>() noexcept : ptr_(), alloc_() {}
    ~<span class='textit'>node_handle</span>();
    <span class='textit'>node_handle</span>(<span class='textit'>node_handle</span>&amp;&amp;) noexcept;
    <span class='textit'>node_handle</span>&amp; operator=(<span class='textit'>node_handle</span>&amp;&amp;);

    value_type&amp; value() const;          <span class='comment'>// not present for map containers
</span>    key_type&amp; key() const;              <span class='comment'>// not present for set containers
</span>    mapped_type&amp; mapped() const;        <span class='comment'>// not present for set containers
</span>
    allocator_type get_allocator() const;
    explicit operator bool() const noexcept;
    [[nodiscard]] bool empty() const noexcept;

    void swap(<span class='textit'>node_handle</span>&amp;)
      noexcept(ator_traits::propagate_on_container_swap::value ||
               ator_traits::is_always_equal::value);

    friend void swap(<span class='textit'>node_handle</span>&amp; x, <span class='textit'>node_handle</span>&amp; y) noexcept(noexcept(x.swap(y))) {
      x.swap(y);
    }
};</pre></div></div></body></html>