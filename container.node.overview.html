<!DOCTYPE html><html lang='en'><head><title>[container.node.overview]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>26</a> Containers library <a class='abbr_ref' href='./#containers'>[containers]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>26.2</a> Container requirements <a class='abbr_ref' href='container.requirements#container.node.overview'>[container.requirements]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>26.2.4</a> Node handles <a class='abbr_ref' href='container.node#overview'>[container.node]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>26.2.4.1</a> <span class='texttt'>node_&shy;handle</span> overview <a class='abbr_ref'>[container.node.overview]</a></h4><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/containers.tex#L1194'>#</a></div><p >A <a class='hidden_link' href='#def:node_handle' id='def:node_handle'><i>node handle</i></a> is an object that accepts ownership of a single element
from an <a href='associative.reqmts'>associative container</a> or an <a href='unord.req'>unordered
associative container</a>. It may be used to transfer that
ownership to another container with compatible nodes.  Containers with
compatible nodes have the same node handle type. Elements may be transferred in
either direction between container types in the same row of
Table <a href='#tab:containers.node.compat'>89</a>.</p><div class='numberedTable' id='tab:containers.node.compat'>Table <a href='#tab:containers.node.compat'>89</a> â€” Container types with compatible nodes<br><table ><tr class='rowsep'><td class='left'>

<span class='texttt'>map&lt;K, T, C1, A&gt;</span>               </td><td class='left'> <span class='texttt'>map&lt;K, T, C2, A&gt;</span>                    </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>map&lt;K, T, C1, A&gt;</span>               </td><td class='left'> <span class='texttt'>multimap&lt;K, T, C2, A&gt;</span>               </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>set&lt;K, C1, A&gt;</span>                  </td><td class='left'> <span class='texttt'>set&lt;K, C2, A&gt;</span>                       </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>set&lt;K, C1, A&gt;</span>                  </td><td class='left'> <span class='texttt'>multiset&lt;K, C2, A&gt;</span>                  </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>unordered_&shy;map&lt;K, T, H1, E1, A&gt;</span> </td><td class='left'> <span class='texttt'>unordered_&shy;map&lt;K, T, H2, E2, A&gt;</span>      </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>unordered_&shy;map&lt;K, T, H1, E1, A&gt;</span> </td><td class='left'> <span class='texttt'>unordered_&shy;multimap&lt;K, T, H2, E2, A&gt;</span> </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>unordered_&shy;set&lt;K, H1, E1, A&gt;</span>    </td><td class='left'> <span class='texttt'>unordered_&shy;set&lt;K, H2, E2, A&gt;</span>         </td></tr><tr class='rowsep'><td class='left'>

<span class='texttt'>unordered_&shy;set&lt;K, H1, E1, A&gt;</span>    </td><td class='left'> <span class='texttt'>unordered_&shy;multiset&lt;K, H2, E2, A&gt;</span>    </td></tr></table></div></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/containers.tex#L1223'>#</a></div><p >If a node handle is not empty, then it contains an allocator that is equal to
the allocator of the container when the element was extracted. If a node handle
is empty, it contains no allocator.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/containers.tex#L1228'>#</a></div><p >Class <span class='texttt'><span class='textit'>node_&shy;handle</span></span> is for exposition only. An implementation is
permitted to provide equivalent functionality without providing a class with
this name.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/33316c99af9acd689e81d52f6e13bb102301f5d8/source/containers.tex#L1233'>#</a></div><p >If a user-defined specialization of <span class='texttt'>pair</span> exists for
<span class='texttt'>pair&lt;const Key, T&gt;</span> or <span class='texttt'>pair&lt;Key, T&gt;</span>, where <span class='texttt'>Key</span> is the
container's <span class='texttt'>key_&shy;type</span> and <span class='texttt'>T</span> is the container's
<span class='texttt'>mapped_&shy;type</span>, the behavior of operations involving node handles is
undefined.</p><pre class='codeblock'>
template&lt;<span class='textit'><span class='texttt'>unspecified</span></span>&gt;
  class <span class='textit'>node_handle</span> {
  public:
    <span class='comment'>// These type declarations are described in Tables <a href='associative.reqmts#tab:containers.associative.requirements'>90</a> and <a href='unord.req#tab:HashRequirements'>91</a>.
</span>    using value_type     = <span class='textit'><span class='texttt'>see below</span></span>;   <span class='comment'>// not present for map containers
</span>    using key_type       = <span class='textit'><span class='texttt'>see below</span></span>;   <span class='comment'>// not present for set containers
</span>    using mapped_type    = <span class='textit'><span class='texttt'>see below</span></span>;   <span class='comment'>// not present for set containers
</span>    using allocator_type = <span class='textit'><span class='texttt'>see below</span></span>;

  private:
    using container_node_type = <span class='textit'><span class='texttt'>unspecified</span></span>;
    using ator_traits = allocator_traits&lt;allocator_type&gt;;

    typename ator_traits::rebind_traits&lt;container_node_type&gt;::pointer ptr_;
    optional&lt;allocator_type&gt; alloc_;

  public:
    constexpr <span class='textit'>node_handle</span>() noexcept : ptr_(), alloc_() {}
    ~<span class='textit'>node_handle</span>();
    <span class='textit'>node_handle</span>(<span class='textit'>node_handle</span>&amp;&amp;) noexcept;
    <span class='textit'>node_handle</span>&amp; operator=(<span class='textit'>node_handle</span>&amp;&amp;);

    value_type&amp; value() const;          <span class='comment'>// not present for map containers
</span>    key_type&amp; key() const;              <span class='comment'>// not present for set containers
</span>    mapped_type&amp; mapped() const;        <span class='comment'>// not present for set containers
</span>
    allocator_type get_allocator() const;
    explicit operator bool() const noexcept;
    bool empty() const noexcept;

    void swap(<span class='textit'>node_handle</span>&amp;)
      noexcept(ator_traits::propagate_on_container_swap::value ||
               ator_traits::is_always_equal::value);

    friend void swap(<span class='textit'>node_handle</span>&amp; x, <span class='textit'>node_handle</span>&amp; y) noexcept(noexcept(x.swap(y))) {
      x.swap(y);
    }
};</pre></div></div></body></html>