<!DOCTYPE html><html lang='en'><head><title>[over.match.oper]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>16</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>16.3</a> Overload resolution <a class='abbr_ref' href='over.match#oper'>[over.match]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>16.3.1</a> Candidate functions and argument lists <a class='abbr_ref' href='over.match.funcs#over.match.oper'>[over.match.funcs]</a></h3><h4 ><a class='secnum' style='min-width:118pt'>16.3.1.2</a> Operators in expressions <a class='abbr_ref'>[over.match.oper]</a></h4><span class='indexparent'><a class='index' id=':overloading,resolution,operators'></a></span><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/119b98d70d24612e425fb2ae1b6caffb93689b89/source/overloading.tex#L901'>#</a></div><div id='1.sentence-1' class='sentence'>If no operand of an operator in an expression has a type that is a class
or an enumeration, the operator is assumed to be a built-in operator
and interpreted according to Clause <a href='expr'>[expr]</a><a class='hidden_link' href='#1.sentence-1'>.</a></div> <div id='1.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#1.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='1.sentence-2' class='sentence'>Because
<span class='texttt'>.</span>,
<span class='texttt'>.*</span>,
and
<span class='texttt'>&#x200b;::&#x200b;</span>
cannot be overloaded,
these operators are always built-in operators interpreted according to
Clause <a href='expr'>[expr]</a><a class='hidden_link' href='#1.sentence-2'>.</a></div> <div id='1.sentence-3' class='sentence'><span class='texttt'>?:</span>
cannot be overloaded, but the rules in this subclause are used to determine
the conversions to be applied to the second and third operands when they
have class or enumeration type (<a href='expr.cond'>[expr.cond]</a>)<a class='hidden_link' href='#1.sentence-3'>.</a></div> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div>  <div id='1.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#1.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct String {
  String (const String&amp;);
  String (const char*);
  operator const char* ();
};
String operator + (const String&amp;, const String&amp;);

void f() {
 const char* p= "one" + "two";  <span class='comment'>// ill-formed because neither operand has class or enumeration type
</span> int I = 1 + 1;                 <span class='comment'>// always evaluates to <span class='tcode_in_codeblock'>2</span> even if class or enumeration types exist
</span>                                <span class='comment'>// that would perform the operation.
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/119b98d70d24612e425fb2ae1b6caffb93689b89/source/overloading.tex#L937'>#</a></div><div id='2.sentence-1' class='sentence'>If either operand has a type that is a class or an enumeration, a
user-defined operator function might be declared that implements
this operator or a user-defined conversion can be necessary to
convert the operand to a type that is appropriate for a built-in
operator<a class='hidden_link' href='#2.sentence-1'>.</a></div> <div id='2.sentence-2' class='sentence'>In this case, overload resolution is used to determine
which operator function or built-in operator is to be invoked to implement the
operator<a class='hidden_link' href='#2.sentence-2'>.</a></div> <div id='2.sentence-3' class='sentence'>Therefore, the operator notation is first transformed
to the equivalent function-call notation as summarized in
Table <a href='#tab:over.rel.op.func'>12</a>
(where <span class='texttt'>@</span> denotes one of the operators covered in the specified subclause)<a class='hidden_link' href='#2.sentence-3'>.</a></div> <div id='2.sentence-4' class='sentence'>However, the operands are sequenced in the order prescribed
for the built-in operator (Clause <a href='expr'>[expr]</a>)<a class='hidden_link' href='#2.sentence-4'>.</a></div><div class='numberedTable' id='tab:over.rel.op.func'>Table <a href='#tab:over.rel.op.func'>12</a> — Relationship between operator and function call notation<br><table ><tr class='rowsep'><td class='left'><div id='2.sentence-5' class='sentence'>
<b>Subclause</b></div></td><td class='border left'><div id='2.sentence-6' class='sentence'><b>Expression</b></div></td><td class='border left'><div id='2.sentence-7' class='sentence'><b>As member function</b></div></td><td class='border left'><div id='2.sentence-8' class='sentence'><b>As non-member function</b></div></td></tr><tr class='capsep'><td class='left'><div id='2.sentence-9' class='sentence'>
<a href='over.unary'>[over.unary]</a></div></td><td class='border left'><div id='2.sentence-10' class='sentence'><span class='texttt'>@a</span></div></td><td class='border left'><div id='2.sentence-11' class='sentence'><span class='texttt'>(a).operator@ (<span style='white-space:nowrap'>&thinsp;</span>)</span></div></td><td class='border left'><div id='2.sentence-12' class='sentence'><span class='texttt'>operator@(a)</span></div></td></tr><tr ><td class='left'><div id='2.sentence-13' class='sentence'><a href='over.binary'>[over.binary]</a></div></td><td class='border left'><div id='2.sentence-14' class='sentence'><span class='texttt'>a@b</span></div></td><td class='border left'><div id='2.sentence-15' class='sentence'><span class='texttt'>(a).operator@ (b)</span></div></td><td class='border left'><div id='2.sentence-16' class='sentence'><span class='texttt'>operator@(a, b)</span></div></td></tr><tr ><td class='left'><div id='2.sentence-17' class='sentence'><a href='over.ass'>[over.ass]</a></div></td><td class='border left'><div id='2.sentence-18' class='sentence'><span class='texttt'>a=b</span></div></td><td class='border left'><div id='2.sentence-19' class='sentence'><span class='texttt'>(a).operator= (b)</span></div></td><td class='border left'></td></tr><tr ><td class='left'><div id='2.sentence-20' class='sentence'><a href='over.sub'>[over.sub]</a></div></td><td class='border left'><div id='2.sentence-21' class='sentence'><span class='texttt'>a[b]</span></div></td><td class='border left'><div id='2.sentence-22' class='sentence'><span class='texttt'>(a).operator[](b)</span></div></td><td class='border left'></td></tr><tr ><td class='left'><div id='2.sentence-23' class='sentence'><a href='over.ref'>[over.ref]</a></div></td><td class='border left'><div id='2.sentence-24' class='sentence'><span class='texttt'>a-&gt;</span></div></td><td class='border left'><div id='2.sentence-25' class='sentence'><span class='texttt'>(a).operator-&gt;(<span style='white-space:nowrap'>&thinsp;</span>)</span></div></td><td class='border left'></td></tr><tr ><td class='left'><div id='2.sentence-26' class='sentence'><a href='over.inc'>[over.inc]</a></div></td><td class='border left'><div id='2.sentence-27' class='sentence'><span class='texttt'>a@</span></div></td><td class='border left'><div id='2.sentence-28' class='sentence'><span class='texttt'>(a).operator@ (0)</span></div></td><td class='border left'><div id='2.sentence-29' class='sentence'><span class='texttt'>operator@(a, 0)</span></div></td></tr></table></div></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/119b98d70d24612e425fb2ae1b6caffb93689b89/source/overloading.tex#L965'>#</a></div><div id='3.sentence-1' class='sentence'>For a unary operator
<span class='texttt'>@</span>
with an operand of a type whose cv-unqualified version is
<span class='texttt'>T1</span>,
and for a binary operator
<span class='texttt'>@</span>
with a left operand of a type whose cv-unqualified version is
<span class='texttt'>T1</span>
and a right operand of a type whose cv-unqualified version is
<span class='texttt'>T2</span>,
three sets of candidate functions, designated
<a class='hidden_link' href='#def:member_candidates' id='def:member_candidates'><i>member candidates</i></a>,
<a class='hidden_link' href='#def:non-member_candidates' id='def:non-member_candidates'><i>non-member candidates</i></a>
and
<a class='hidden_link' href='#def:built-in_candidates' id='def:built-in_candidates'><i>built-in candidates</i></a>,
are constructed as follows:
<ul class='itemize'><li id='3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.1'>(3.1)</a></div><div id='3.1.sentence-1' class='sentence'>If
<span class='texttt'>T1</span>
is a complete class type or a class currently being defined, the set of member candidates is the
result of the qualified lookup of
<span class='texttt'>T1&#x200b;::&#x200b;operator@</span> (<a href='over.call.func'>[over.call.func]</a>); otherwise, the set of member
candidates is empty<a class='hidden_link' href='#3.1.sentence-1'>.</a></div></li><li id='3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.2'>(3.2)</a></div><div id='3.2.sentence-1' class='sentence'>The set of non-member candidates is the result of the unqualified lookup of
<span class='texttt'>operator@</span>
in the context of
the expression according to the usual rules for name
lookup in unqualified function calls (<a href='basic.lookup.argdep'>[basic.lookup.argdep]</a>) except
that all member functions are ignored<a class='hidden_link' href='#3.2.sentence-1'>.</a></div> <div id='3.2.sentence-2' class='sentence'>However, if no operand has a class type, only those non-member
functions in the lookup set that have a first parameter of type
<span class='texttt'>T1</span>
or “reference to <span class='textit'>cv</span> <span class='texttt'>T1</span>”,
when
<span class='texttt'>T1</span>
is an enumeration type,
or (if there is a right operand) a second parameter of type
<span class='texttt'>T2</span>
or “reference to <span class='textit'>cv</span> <span class='texttt'>T2</span>”,
when
<span class='texttt'>T2</span>
is an enumeration type,
are candidate functions<a class='hidden_link' href='#3.2.sentence-2'>.</a></div></li><li id='3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#3.3'>(3.3)</a></div><div id='3.3.sentence-1' class='sentence'>For the operator
<span class='texttt'>,</span>,
the unary operator
<span class='texttt'>&amp;</span>,
or the operator
<span class='texttt'>-&gt;</span>,
the built-in candidates set is empty<a class='hidden_link' href='#3.3.sentence-1'>.</a></div> <div id='3.3.sentence-2' class='sentence'>For all other operators, the built-in candidates include all
of the candidate operator functions defined in <a href='over.built'>[over.built]</a> that,
compared to the given operator,</div><div id='3.3.sentence-3' class='sentence'><ul class='itemize'><li id='3.3.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.3.1'>(3.3.1)</a></div><div id='3.3.1.sentence-1' class='sentence'>have the same operator name, and</div></li><li id='3.3.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.3.2'>(3.3.2)</a></div><div id='3.3.2.sentence-1' class='sentence'>accept the same number of operands, and</div></li><li id='3.3.3'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.3.3'>(3.3.3)</a></div><div id='3.3.3.sentence-1' class='sentence'>accept operand types to which the given operand or
operands can be converted according to <a href='over.best.ics'>[over.best.ics]</a>, and</div></li><li id='3.3.4'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#3.3.4'>(3.3.4)</a></div><div id='3.3.4.sentence-1' class='sentence'>do not have the same parameter-type-list as any non-member candidate
that is not a function template specialization<a class='hidden_link' href='#3.3.4.sentence-1'>.</a></div></li></ul></div></li></ul></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/119b98d70d24612e425fb2ae1b6caffb93689b89/source/overloading.tex#L1037'>#</a></div><div id='4.sentence-1' class='sentence'>For the built-in assignment operators, conversions of the left
operand are restricted as follows:</div><div id='4.sentence-2' class='sentence'><ul class='itemize'><li id='4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.1'>(4.1)</a></div><div id='4.1.sentence-1' class='sentence'>no temporaries are introduced to hold the left operand, and</div></li><li id='4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#4.2'>(4.2)</a></div><div id='4.2.sentence-1' class='sentence'>no user-defined conversions are applied to the left operand to achieve
a type match with the left-most parameter of a built-in candidate<a class='hidden_link' href='#4.2.sentence-1'>.</a></div></li></ul></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/119b98d70d24612e425fb2ae1b6caffb93689b89/source/overloading.tex#L1049'>#</a></div><div id='5.sentence-1' class='sentence'>For all other operators, no such restrictions apply<a class='hidden_link' href='#5.sentence-1'>.</a></div></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/119b98d70d24612e425fb2ae1b6caffb93689b89/source/overloading.tex#L1052'>#</a></div><div id='6.sentence-1' class='sentence'>The set of candidate functions for overload resolution is the
union of the member candidates, the non-member candidates, and
the built-in candidates<a class='hidden_link' href='#6.sentence-1'>.</a></div> <div id='6.sentence-2' class='sentence'>The argument list contains all of the
operands of the operator<a class='hidden_link' href='#6.sentence-2'>.</a></div> <div id='6.sentence-3' class='sentence'>The best function from the set of candidate functions is selected
according to <a href='over.match.viable'>[over.match.viable]</a>
and <a href='over.match.best'>[over.match.best]</a><a class='hidden_link' href='#6.sentence-3'>.</a><a class='footnotenum' href='#footnote-128'>128</a></div> <div id='6.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#6.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct A {
  operator int();
};
A operator+(const A&amp;, const A&amp;);
void m() {
  A a, b;
  a + b;                        <span class='comment'>// <span class='tcode_in_codeblock'>operator+(a, b)</span> chosen over <span class='tcode_in_codeblock'>int(a) + int(b)</span>
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/119b98d70d24612e425fb2ae1b6caffb93689b89/source/overloading.tex#L1077'>#</a></div><div id='7.sentence-1' class='sentence'>If a built-in candidate is selected by overload resolution, the
operands of class type are converted to the types of the corresponding parameters
of the selected operation function, except that the second standard conversion
sequence of a <a href='over.ics.user'>user-defined conversion sequence</a> is not applied<a class='hidden_link' href='#7.sentence-1'>.</a></div> <div id='7.sentence-2' class='sentence'>Then the operator is treated as the corresponding
built-in operator and interpreted according to Clause <a href='expr'>[expr]</a><a class='hidden_link' href='#7.sentence-2'>.</a></div> <div id='7.example-1' class='example'>[<span style='white-space:nowrap'> </span><a class='example_link' href='#7.example-1'><span class='textit'>Example</span></a><div class='exampleBody'><span class='textit'>:</span> <pre class='codeblock'>
struct X {
  operator double();
};

struct Y {
  operator int*();
};

int *a = Y() + 100.0;           <span class='comment'>// error: pointer arithmetic requires integral operand
</span>int *b = Y() + X();             <span class='comment'>// error: pointer arithmetic requires integral operand
</span></pre> —<span style='white-space:nowrap'> </span><i>end example</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/119b98d70d24612e425fb2ae1b6caffb93689b89/source/overloading.tex#L1099'>#</a></div><div id='8.sentence-1' class='sentence'>The second operand of operator
<span class='texttt'>-&gt;</span>
is ignored in selecting an
<span class='texttt'>operator-&gt;</span>
function, and is not an argument when the
<span class='texttt'>operator-&gt;</span>
function is called<a class='hidden_link' href='#8.sentence-1'>.</a></div> <div id='8.sentence-2' class='sentence'>When
<span class='texttt'>operator-&gt;</span>
returns, the operator
<span class='texttt'>-&gt;</span>
is applied to the value returned, with the original second
operand<a class='hidden_link' href='#8.sentence-2'>.</a><a class='footnotenum' href='#footnote-129'>129</a></div></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/119b98d70d24612e425fb2ae1b6caffb93689b89/source/overloading.tex#L1121'>#</a></div><div id='9.sentence-1' class='sentence'>If the operator is the operator
<span class='texttt'>,</span>,
the unary operator
<span class='texttt'>&amp;</span>,
or the operator
<span class='texttt'>-&gt;</span>,
and there are no viable functions, then the operator is
assumed to be the built-in operator and interpreted according to
Clause <a href='expr'>[expr]</a><a class='hidden_link' href='#9.sentence-1'>.</a></div></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/119b98d70d24612e425fb2ae1b6caffb93689b89/source/overloading.tex#L1132'>#</a></div><div id='10.note-1' class='note'>[<span style='white-space:nowrap'> </span><a class='note_link' href='#10.note-1'><span class='textit'>Note</span></a><div class='noteBody'><span class='textit'>:</span> <div id='10.sentence-1' class='sentence'>The lookup rules for operators in expressions are different than
the lookup
rules for operator function names in a function call, as shown in the following
example:</div><pre class='codeblock'>
struct A { };
void operator + (A, A);

struct B {
  void operator + (B);
  void f ();
};

A a;

void B::f() {
  operator+ (a,a);              <span class='comment'>// error: global operator hidden by member
</span>  a + a;                        <span class='comment'>// OK: calls global <span class='tcode_in_codeblock'>operator+</span>
</span>}</pre> —<span style='white-space:nowrap'> </span><i>end note</i></div><span style='white-space:nowrap'> </span>]</div> </div><div class='footnote' id='footnote-128'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-128'>128)</a></div><div id='footnote-128.sentence-1' class='sentence'>If the set of candidate functions is empty,
overload resolution is unsuccessful<a class='hidden_link' href='#footnote-128.sentence-1'>.</a></div></div><div class='footnote' id='footnote-129'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-129'>129)</a></div><div id='footnote-129.sentence-1' class='sentence'>If the value returned by the
<span class='texttt'>operator-&gt;</span>
function has class type, this may result in selecting and calling another
<span class='texttt'>operator-&gt;</span>
function<a class='hidden_link' href='#footnote-129.sentence-1'>.</a></div> <div id='footnote-129.sentence-2' class='sentence'>The process repeats until an
<span class='texttt'>operator-&gt;</span>
function returns a value of non-class type<a class='hidden_link' href='#footnote-129.sentence-2'>.</a></div></div></div></body></html>