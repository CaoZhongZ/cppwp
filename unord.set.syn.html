<!DOCTYPE html><html lang='en'><head><title>[unord.set.syn]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>26</a> Containers library <a class='abbr_ref' href='./#containers'>[containers]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>26.5</a> Unordered associative containers <a class='abbr_ref' href='unord#set.syn'>[unord]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>26.5.3</a> Header <span class='texttt'>&lt;unordered_&shy;set&gt;</span> synopsis <a class='abbr_ref'>[unord.set.syn]</a></h3><span class='indexparent'><a class='index' id=':<unordered_set>'></a></span><span class='indexparent'><a class='index' id=':<unordered_set>'></a></span><span class='indexparent'><a class='index' id='lib:unordered_set'></a></span><span class='indexparent'><a class='index' id='lib:unordered_multiset'></a></span><pre class='codeblock'>
#include &lt;initializer_list&gt;

namespace std {
  <span class='comment'>// <a href='unord.set'>[unord.set]</a>, class template <span class='tcode_in_codeblock'>unordered_&shy;set</span>
</span>  template &lt;class Key,
            class Hash = hash&lt;Key&gt;,
            class Pred = equal_to&lt;Key&gt;,
            class Alloc = allocator&lt;Key&gt;&gt;
    class unordered_set;

  <span class='comment'>// <a href='unord.multiset'>[unord.multiset]</a>, class template <span class='tcode_in_codeblock'>unordered_&shy;multiset</span>
</span>  template &lt;class Key,
            class Hash = hash&lt;Key&gt;,
            class Pred = equal_to&lt;Key&gt;,
            class Alloc = allocator&lt;Key&gt;&gt;
    class unordered_multiset;

  template &lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool operator==(const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; a,
                    const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; b);
  template &lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool operator!=(const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; a,
                    const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; b);

  template &lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool operator==(const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; a,
                    const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; b);
  template &lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool operator!=(const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; a,
                    const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; b);

  template &lt;class Key, class Hash, class Pred, class Alloc&gt;
    void swap(unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
              unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template &lt;class Key, class Hash, class Pred, class Alloc&gt;
    void swap(unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
              unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  namespace pmr {
    template &lt;class Key,
              class Hash = hash&lt;Key&gt;,
              class Pred = equal_to&lt;Key&gt;&gt;
      using unordered_set = std::unordered_set&lt;Key, Hash, Pred,
                                               polymorphic_allocator&lt;Key&gt;&gt;;

    template &lt;class Key,
              class Hash = hash&lt;Key&gt;,
              class Pred = equal_to&lt;Key&gt;&gt;
      using unordered_multiset = std::unordered_multiset&lt;Key, Hash, Pred,
                                                         polymorphic_allocator&lt;Key&gt;&gt;;
  }
}</pre></div></body></html>