<!DOCTYPE html><html lang='en'><head><title>[stmt.jump]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>6</a> Statements <a class='abbr_ref' href='./#stmt.stmt'>[stmt.stmt]</a></h1><div id='stmt.jump'><h2 ><a class='secnum' style='min-width:88pt'>6.6</a> Jump statements <a class='abbr_ref'>[stmt.jump]</a></h2><p ><span class='indexparent'><a class='index' id='statement,jump'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >Jump statements unconditionally transfer control.
<span class='indexparent'><a class='index' id='statement,jump'></a></span>
<span class='indexparent'><a class='index' id='statement,break'></a></span><span class='indexparent'><a class='index' id='statement,continue'></a></span><span class='indexparent'><a class='index' id='return_statement'></a></span><span class='indexparent'><a class='index' id='return'></a></span><span class='indexparent'><a class='index' id='statement,goto'></a></span></p><pre class='bnf'><a id='nt:jump-statement'>jump-statement:</a>
    <span class='terminal'>break ;</span>
    <span class='terminal'>continue ;</span>
    <span class='terminal'>return</span> <i ><a href='dcl.init#nt:expr-or-braced-init-list'>expr-or-braced-init-list</a></i><span class='math'><sub ><span class='mathit'>opt</span></sub></span> <span class='terminal'>;</span>
    <span class='terminal'>goto</span> <i ><a href='lex.name#nt:identifier'>identifier</a></i> <span class='terminal'>;</span></pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p ><span class='indexparent'><a class='index' id='local_variable,destruction_of'></a></span><span class='indexparent'><a class='index' id='scope,destructor_and_exit_from'></a></span>On exit from a scope (however accomplished), objects with automatic storage
duration (<a href='basic.stc.auto'>[basic.stc.auto]</a>) that have been constructed in that scope are destroyed
in the reverse order of their construction. [&nbsp;<i>Note:</i><span class='space'></span> For temporaries,
see <a href='class.temporary'>[class.temporary]</a>. <i>&nbsp;—&nbsp;end note</i>&nbsp;] Transfer out of a loop, out of a block, or back
past
an initialized variable with automatic storage duration involves the
destruction of objects with automatic storage duration that are in
scope at the point transferred from but not at the point transferred to.
(See <a href='stmt.dcl'>[stmt.dcl]</a> for transfers into blocks).
[&nbsp;<i>Note:</i><span class='space'></span>
However, the program can be terminated (by calling
<span class='indexparent'><a class='index' id='exit'></a></span><span class='indexparent'><a class='index' id='exit'></a></span><span class='texttt'>std::exit()</span> or
<span class='indexparent'><a class='index' id='abort'></a></span><span class='indexparent'><a class='index' id='abort'></a></span><span class='texttt'>std::abort()</span> (<a href='support.start.term'>[support.start.term]</a>), for example) without
destroying class objects with automatic storage duration.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div id='stmt.break'><h3 ><a class='secnum' href='#stmt.break' style='min-width:103pt'>6.6.1</a> The <span class='texttt'>break</span> statement <a class='abbr_ref' href='stmt.break'>[stmt.break]</a></h3><p ><span class='indexparent'><a class='index' id='statement,break'></a></span></p><div class='para' id='stmt.break-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.break-1'>1</a></div><p >The <span class='texttt'>break</span> statement shall occur only in an
<span class='indexparent'><a class='index' id='iteration-statement'></a></span><span class='indexparent'><a class='index' id='statement,switch'></a></span><i ><a href='stmt.iter#nt:iteration-statement'>iteration-statement</a></i> or a <span class='texttt'>switch</span> statement and causes
termination of the smallest enclosing <i ><a href='stmt.iter#nt:iteration-statement'>iteration-statement</a></i> or
<span class='texttt'>switch</span> statement; control passes to the statement following the
terminated statement, if any.</p></div></div><div id='stmt.cont'><h3 ><a class='secnum' href='#stmt.cont' style='min-width:103pt'>6.6.2</a> The <span class='texttt'>continue</span> statement <a class='abbr_ref' href='stmt.cont'>[stmt.cont]</a></h3><p ><span class='indexparent'><a class='index' id='statement,continue'></a></span></p><div class='para' id='stmt.cont-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.cont-1'>1</a></div><p >The
<span class='texttt'>continue</span>
statement shall occur only in an
<span class='indexparent'><a class='index' id='iteration-statement'></a></span><i ><a href='stmt.iter#nt:iteration-statement'>iteration-statement</a></i>
and causes control to pass to the loop-continuation portion of the
smallest enclosing <i ><a href='stmt.iter#nt:iteration-statement'>iteration-statement</a></i>, that is, to the end
of the loop. More precisely, in each of the statements</p><div class='minipage'><pre class='codeblock'>
while (foo) {
  {
    <span class='comment'>// ...
</span>  }
contin: ;
}
</pre></div><div class='minipage'><pre class='codeblock'>
do {
  {
    <span class='comment'>// ...
</span>  }
contin: ;
} while (foo);
</pre></div><div class='minipage'><pre class='codeblock'>
for (;;) {
  {
    <span class='comment'>// ...
</span>  }
contin: ;
}
</pre></div><p >a <span class='texttt'>continue</span> not contained in an enclosed iteration statement is
equivalent to <span class='texttt'>goto</span> <span class='texttt'>contin</span>.</p></div></div><div id='stmt.return'><h3 ><a class='secnum' href='#stmt.return' style='min-width:103pt'>6.6.3</a> The <span class='texttt'>return</span> statement <a class='abbr_ref' href='stmt.return'>[stmt.return]</a></h3><p ><span class='indexparent'><a class='index' id='return'></a></span><span class='indexparent'><a class='index' id='function_return'></a></span>
</p><div class='para' id='stmt.return-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.return-1'>1</a></div><p >A function returns to its caller by the <span class='texttt'>return</span> statement.</p></div><div class='para' id='stmt.return-2'><div class='marginalizedparent'><a class='marginalized' href='#stmt.return-2'>2</a></div><p >The <i ><a href='dcl.init#nt:expr-or-braced-init-list'>expr-or-braced-init-list</a></i>
of a return statement is called its operand. A return statement with
no operand shall be used only in a function whose return type is
<i>cv</i> <span class='texttt'>void</span>, a constructor (<a href='class.ctor'>[class.ctor]</a>), or a
destructor (<a href='class.dtor'>[class.dtor]</a>).
<span class='indexparent'><a class='index' id='return,constructor_and'></a></span><span class='indexparent'><a class='index' id='return,constructor_and'></a></span>A return statement with an operand of type <span class='texttt'>void</span> shall be used only
in a function whose return type is <i>cv</i> <span class='texttt'>void</span>.
A return statement with any other operand shall be used only
in a function whose return type is not <i>cv</i> <span class='texttt'>void</span>;
<span class='indexparent'><a class='index' id='conversion,return_type'></a></span>the return statement initializes the
glvalue result or prvalue result object of the (explicit or implicit) function call
by copy-initialization (<a href='dcl.init'>[dcl.init]</a>) from the operand.
[&nbsp;<i>Note:</i><span class='space'></span>
A return statement can involve
an invocation of a constructor to perform a copy or move of the operand
if it is not a prvalue or if its type differs from the return type of the function.
A copy operation associated with a return statement may be elided or
converted to a move operation if an automatic storage duration variable is returned (<a href='class.copy'>[class.copy]</a>).
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
[&nbsp;<i>Example:</i><span class='space'></span>
</p><pre class='codeblock'>
std::pair&lt;std::string,int&gt; f(const char* p, int x) {
  return {p,x};
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
Flowing off the end of
a constructor,
a destructor, or
a function with a <i>cv</i> <span class='texttt'>void</span> return type is
equivalent to a <span class='texttt'>return</span> with no operand.
Otherwise, flowing off the end of a function
other than <span class='texttt'>main</span> (<a href='basic.start.main'>[basic.start.main]</a>)
results in undefined behavior.</p></div><div class='para' id='stmt.return-3'><div class='marginalizedparent'><a class='marginalized' href='#stmt.return-3'>3</a></div><p >The copy-initialization of the result of the call is sequenced before the
destruction of temporaries at the end of the full-expression established
by the operand of the return statement, which, in turn, is sequenced
before the destruction of local variables (<a href='stmt.jump'>[stmt.jump]</a>) of the block
enclosing the return statement.</p></div></div><div id='stmt.goto'><h3 ><a class='secnum' href='#stmt.goto' style='min-width:103pt'>6.6.4</a> The <span class='texttt'>goto</span> statement <a class='abbr_ref' href='stmt.goto'>[stmt.goto]</a></h3><p ><span class='indexparent'><a class='index' id='statement,goto'></a></span></p><div class='para' id='stmt.goto-1'><div class='marginalizedparent'><a class='marginalized' href='#stmt.goto-1'>1</a></div><p >The <span class='texttt'>goto</span> statement unconditionally transfers control to the
statement labeled by the identifier. The identifier shall be a
<span class='indexparent'><a class='index' id='label'></a></span>label (<a href='stmt.label'>[stmt.label]</a>) located in the current function.</p></div></div></div></div></body></html>