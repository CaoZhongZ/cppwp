<!DOCTYPE html><html lang='en'><head><title>[depr.default.allocator]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='annexnum' style='min-width:73pt'>Annex D&emsp;(normative)</a> Compatibility features <a class='abbr_ref' href='./#depr'>[depr]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>D.8</a> The default allocator <a class='abbr_ref'>[depr.default.allocator]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/future.tex#L1682'>#</a></div><p >The following members and explicit class template specialization are defined in
addition to those specified in <a href='default.allocator'>[default.allocator]</a>:</p><p ><span class='indexparent'><a class='index' id='lib:allocator'></a></span></p><pre class='codeblock'>
namespace std {
  <span class='comment'>// specialize for <span class='tcode_in_codeblock'>void</span>:
</span>  template &lt;&gt; class allocator&lt;void&gt; {
  public:
    using value_type    = void;
    using pointer       = void*;
    using const_pointer = const void*;
    <span class='comment'>// reference-to-<span class='tcode_in_codeblock'>void</span> members are impossible.
</span>
    template &lt;class U&gt; struct rebind { using other = allocator&lt;U&gt;; };
  };

  template &lt;class T&gt; class allocator {
   public:
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using pointer         = T*;
    using const_pointer   = const T*;
    using reference       = T&amp;;
    using const_reference = const T&amp;;
    template &lt;class U&gt; struct rebind { using other = allocator&lt;U&gt;; };

    T* address(T&amp; x) const noexcept;
    const T* address(const T&amp; x) const noexcept;

    T* allocate(size_t n, const void* hint);

    template&lt;class U, class... Args&gt;
      void construct(U* p, Args&amp;&amp;... args);
    template &lt;class U&gt;
      void destroy(U* p);

    size_t max_size() const noexcept;
  };
}</pre><p ><span class='indexparent'><a class='index' id='lib:address,allocator'></a></span><span class='indexparent'><a class='index' id='lib:allocator,address'></a></span></p></div><p ><code class='itemdecl'>T* address(T&amp; x) const noexcept;
const T* address(const T&amp; x) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/future.tex#L1732'>#</a></div><p ><span class='textit'>Returns:</span> <span class='texttt'>addressof(x)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:allocate,allocator'></a></span><span class='indexparent'><a class='index' id='lib:allocator,allocate'></a></span></p><p ><code class='itemdecl'>T* allocate(size_t n, const void* hint);
</code></p><div class='itemdescr'></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/future.tex#L1742'>#</a></div><p ><span class='textit'>Returns:</span> 
A pointer to the initial element of an array of storage of size <span class='texttt'>n</span>
<span class='texttt'>* sizeof(T)</span>, aligned appropriately for objects of type <span class='texttt'>T</span>.
It is <span class='indexparent'><a class='index' id=':support_for_over-aligned_types'></a></span>implementation-defined whether over-aligned types are
supported (<a href='basic.align'>[basic.align]</a>).</p></div></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/future.tex#L1749'>#</a></div><p ><span class='textit'>Remarks:</span> 
The storage is obtained by calling <span class='texttt'>&#x200b;::&#x200b;operator new(std&#x200b;::&#x200b;size_&shy;t)</span> (<a href='new.delete'>[new.delete]</a>),
but it is unspecified when or how often this function is called.</p></div></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/future.tex#L1754'>#</a></div><p ><span class='textit'>Throws:</span> 
<span class='texttt'>bad_&shy;alloc</span> if the storage cannot be obtained.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:construct,allocator'></a></span><span class='indexparent'><a class='index' id='lib:allocator,construct'></a></span></p><p ><code class='itemdecl'>template &lt;class U, class... Args&gt;
  void construct(U* p, Args&amp;&amp;... args);
</code></p><div class='itemdescr'></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/future.tex#L1766'>#</a></div><p ><span class='textit'>Effects:</span> 
As if by: <span class='texttt'>&#x200b;::&#x200b;new((void *)p) U(std&#x200b;::&#x200b;forward&lt;Args&gt;(args)...);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:destroy,allocator'></a></span><span class='indexparent'><a class='index' id='lib:allocator,destroy'></a></span></p><p ><code class='itemdecl'>template &lt;class U&gt;
  void destroy(U* p);
</code></p><div class='itemdescr'></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/future.tex#L1778'>#</a></div><p ><span class='textit'>Effects:</span> 
As if by <span class='texttt'>p-&gt;~U()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:max_size,allocator'></a></span><span class='indexparent'><a class='index' id='lib:allocator,max_size'></a></span></p><p ><code class='itemdecl'>size_t max_size() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/2f6aff7e71cc33243671d1e501911d331af61fa3/source/future.tex#L1789'>#</a></div><p ><span class='textit'>Returns:</span> 
The largest value <span class='textit'>N</span> for which the call <span class='texttt'>allocate(N, 0)</span>
might succeed.
</p></div></div></div></body></html>