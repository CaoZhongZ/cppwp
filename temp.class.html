<!DOCTYPE html><html lang='en'><head><title>[temp.class]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>14</a> Templates <a class='abbr_ref' href='./#temp'>[temp]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>14.5</a> Template declarations <a class='abbr_ref' href='temp.decls#temp.class'>[temp.decls]</a></h2><div id='temp.class'><h3 ><a class='secnum' style='min-width:103pt'>14.5.1</a> Class templates <a class='abbr_ref'>[temp.class]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/templates.tex#L1360'>#</a></div><p >A class
<a class='hidden_link' href='#def:template' id='def:template'><i>template</i></a>
defines the layout and operations
for an unbounded set of related types.</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/templates.tex#L1366'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
A single class template
<span class='texttt'>List</span>
might provide an unbounded set of class definitions:
one class <span class='texttt'>List&lt;T&gt;</span> for every type <span class='texttt'>T</span>,
each describing a linked list of elements of type <span class='texttt'>T</span>.
Similarly, a class template <span class='texttt'>Array</span> describing a contiguous,
dynamic array might be defined like this:
</p><pre class='codeblock'>
template&lt;class T&gt; class Array {
  T* v;
  int sz;
public:
  explicit Array(int);
  T&amp; operator[](int);
  T&amp; elem(int i) { return v[i]; }
};</pre><p >The prefix <span class='texttt'>template&lt;class T&gt;</span>
specifies that a template is being declared and that a
<i ><a href='dcl.type.simple#nt:type-name'>type-name</a></i>
<span class='texttt'>T</span>
may be used in the declaration.
In other words,
<span class='texttt'>Array</span>
is a parameterized type with
<span class='texttt'>T</span>
as its parameter.
<i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/templates.tex#L1397'>#</a></div><p >When a member function, a member class, a member enumeration, a static data member or
a member template of a class
template is defined outside of the class template definition,
the member definition is defined as a template definition in which the
<i ><a href='temp.param#nt:template-parameter'>template-parameters</a></i>
are those of the class template.
The names of the template parameters used in the definition of the member may
be different from the template parameter names used in the class
template definition.
The template argument list following the class template name in the member
definition shall name the parameters in the same order as the one used in
the template parameter list of the member. Each template
parameter pack shall be expanded with an ellipsis in the template
argument list.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
template&lt;class T1, class T2&gt; struct A {
  void f1();
  void f2();
};

template&lt;class T2, class T1&gt; void A&lt;T2,T1&gt;::f1() { }    <span class='comment'>// OK
</span>template&lt;class T2, class T1&gt; void A&lt;T1,T2&gt;::f2() { }    <span class='comment'>// error
</span></pre><pre class='codeblock'>
template&lt;class ... Types&gt; struct B {
  void f3();
  void f4();
};

template&lt;class ... Types&gt; void B&lt;Types ...&gt;::f3() { }    <span class='comment'>// OK
</span>template&lt;class ... Types&gt; void B&lt;Types&gt;::f4() { }        <span class='comment'>// error
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/templates.tex#L1436'>#</a></div><p >In a redeclaration, partial
specialization,
explicit specialization or explicit
instantiation of a class template, the
<i ><a href='class#nt:class-key'>class-key</a></i>
shall agree in kind with the original class template declaration (<a href='dcl.type.elab'>[dcl.type.elab]</a>).</p></div><div id='temp.mem.func'><h4 ><a class='secnum' href='#temp.mem.func' style='min-width:118pt'>14.5.1.1</a> Member functions of class templates <a class='abbr_ref' href='temp.mem.func'>[temp.mem.func]</a></h4><div class='para' id='temp.mem.func-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem.func-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/templates.tex#L1446'>#</a></div><p ><span class='indexparent'><a class='index' id='template,member_function'></a></span>A member function
of a class template
may be defined outside of the class
template definition in which it is declared.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; class Array {
  T* v;
  int sz;
public:
  explicit Array(int);
  T&amp; operator[](int);
  T&amp; elem(int i) { return v[i]; }
};</pre><p >declares three function templates.
The subscript function might be defined like this:</p><pre class='codeblock'>
template&lt;class T&gt; T&amp; Array&lt;T&gt;::operator[](int i) {
  if (i&lt;0 || sz&lt;=i) error("Array: range error");
  return v[i];
}</pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='temp.mem.func-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem.func-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/templates.tex#L1476'>#</a></div><p >The
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>
for a member function of a class template are determined by the
<i ><a href='temp.names#nt:template-argument'>template-arguments</a></i>
of the type of the object for which the member function is called.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
the
<i ><a href='temp.names#nt:template-argument'>template-argument</a></i>
for
<span class='texttt'>Array&lt;T&gt;&#x200b;::&#x200b;operator[]()</span>
will be determined by the
<span class='texttt'>Array</span>
to which the subscripting operation is applied.</p><pre class='codeblock'>
Array&lt;int&gt; v1(20);
Array&lt;dcomplex&gt; v2(30);

v1[3] = 7;                      <span class='comment'>// <span class='texttt'>Array&lt;int&gt;&#x200b;::&#x200b;operator[]()</span>
</span>v2[3] = dcomplex(7,8);          <span class='comment'>// <span class='texttt'>Array&lt;dcomplex&gt;&#x200b;::&#x200b;operator[]()</span>
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div id='temp.mem.class'><h4 ><a class='secnum' href='#temp.mem.class' style='min-width:118pt'>14.5.1.2</a> Member classes of class templates <a class='abbr_ref' href='temp.mem.class'>[temp.mem.class]</a></h4><div class='para' id='temp.mem.class-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem.class-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/templates.tex#L1502'>#</a></div><p >A member class of a class template may be defined outside the class template
definition in which it is declared.
[<span style='white-space:nowrap'>&thinsp;</span><i>Note:</i>
The member class must be defined before its first use that requires
an instantiation (<a href='temp.inst'>[temp.inst]</a>).
For example,</p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  class B;
};
A&lt;int&gt;::B* b1;                  <span class='comment'>// OK: requires <span class='texttt'>A</span> to be defined but not <span class='texttt'>A&#x200b;::&#x200b;B</span>
</span>template&lt;class T&gt; class A&lt;T&gt;::B { };
A&lt;int&gt;::B  b2;                  <span class='comment'>// OK: requires <span class='texttt'>A&#x200b;::&#x200b;B</span> to be defined
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div id='temp.static'><h4 ><a class='secnum' href='#temp.static' style='min-width:118pt'>14.5.1.3</a> Static data members of class templates <a class='abbr_ref' href='temp.static'>[temp.static]</a></h4><div class='para' id='temp.static-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.static-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/templates.tex#L1522'>#</a></div><p ><span class='indexparent'><a class='index' id='member,template_and_static'></a></span>A definition for a static data member or static data member template may be
provided in a namespace scope enclosing the definition of the static member's
class template.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
template&lt;class T&gt; class X {
  static T s;
};
template&lt;class T&gt; T X&lt;T&gt;::s = 0;

struct limits {
  template&lt;class T&gt;
    static const T min;         <span class='comment'>// declaration
</span>};

template&lt;class T&gt;
  const T limits::min = { };    <span class='comment'>// definition
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='temp.static-2'><div class='marginalizedparent'><a class='marginalized' href='#temp.static-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/templates.tex#L1545'>#</a></div><p >An explicit specialization of a static data member declared as an array of unknown
bound can have a different bound from its definition, if any. [<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i></p><pre class='codeblock'>
template &lt;class T&gt; struct A {
  static int i[];
};
template &lt;class T&gt; int A&lt;T&gt;::i[4];              <span class='comment'>// 4 elements
</span>template &lt;&gt; int A&lt;int&gt;::i[] = { 1 };            <span class='comment'>// OK: 1 element
</span></pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div><div id='temp.mem.enum'><h4 ><a class='secnum' href='#temp.mem.enum' style='min-width:118pt'>14.5.1.4</a> Enumeration members of class templates <a class='abbr_ref' href='temp.mem.enum'>[temp.mem.enum]</a></h4><div class='para' id='temp.mem.enum-1'><div class='marginalizedparent'><a class='marginalized' href='#temp.mem.enum-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/d2263429a07205edf8d2ffcd6d41cfe5d61544f8/source/templates.tex#L1560'>#</a></div><p >An enumeration member of a class template may be defined outside the class
template definition.
[<span style='white-space:nowrap'>&thinsp;</span><i>Example:</i>
</p><pre class='codeblock'>
template&lt;class T&gt; struct A {
  enum E : T;
};
A&lt;int&gt; a;
template&lt;class T&gt; enum A&lt;T&gt;::E : T { e1, e2 };
A&lt;int&gt;::E e = A&lt;int&gt;::e1;</pre><p ><i><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</i><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div></div></div></body></html>