<!DOCTYPE html><html lang='en'><head><title>[over.built]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>13</a> Overloading <a class='abbr_ref' href='./#over'>[over]</a></h1><div id='over.built'><h2 ><a class='secnum' style='min-width:88pt'>13.6</a> Built-in operators <a class='abbr_ref'>[over.built]</a></h2><p ><span class='indexparent'><a class='index' id='overloading,built-in_operators_and'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The candidate operator functions that represent the built-in operators
defined in Clause <a href='expr'>[expr]</a> are specified in this subclause.
These candidate
functions participate in the operator overload resolution process as
described in <a href='over.match.oper'>[over.match.oper]</a> and are used for no other purpose.
[&nbsp;<i>Note:</i><span class='space'></span>
Because built-in operators take only operands with non-class type,
and operator overload resolution occurs only when an operand expression
originally has class or enumeration type,
operator overload resolution can resolve to a built-in operator only
when an operand has a class type that has a user-defined conversion to
a non-class type appropriate for the operator, or when an operand has
an enumeration type that can be converted to a type appropriate
for the operator.
Also note that some of the candidate operator functions given in this subclause are
more permissive than the built-in operators themselves.
As
described in <a href='over.match.oper'>[over.match.oper]</a>, after a built-in operator is selected
by overload resolution the expression is subject to the requirements for
the built-in operator given in Clause <a href='expr'>[expr]</a>, and therefore to any
additional semantic constraints given there.
If there is a user-written
candidate with the same name and parameter types as a built-in
candidate operator function, the built-in operator function
is hidden and is not included in the set of candidate functions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >In this subclause, the term
<a class='hidden_link' href='#def:promoted_integral_type' id='def:promoted_integral_type'><i>promoted integral type</i></a>
is used to refer to those integral types which are preserved by
integral promotion (including e.g.
<span class='texttt'>int</span>
and
<span class='texttt'>long</span>
but excluding e.g.
<span class='texttt'>char</span>).
Similarly, the term
<a class='hidden_link' href='#def:promoted_arithmetic_type' id='def:promoted_arithmetic_type'><i>promoted arithmetic type</i></a>
refers to floating types plus promoted integral types.
[&nbsp;<i>Note:</i><span class='space'></span>
In all cases where a promoted integral type or promoted arithmetic type is
required, an operand of enumeration type will be acceptable by way of the
integral promotions.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >For every pair
(<i>T</i>,
<i>VQ</i>),
where
<i>T</i>
is an arithmetic type other than <span class='texttt'>bool</span>, and
<i>VQ</i>
is either
<span class='texttt'>volatile</span>
or empty,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<i>VQ T</i>&amp; operator++(<i>VQ T</i>&amp;);
<i>T</i> operator++(<i>VQ T</i>&amp;, int);
</pre></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >For every pair
(<i>T</i>,
<i>VQ</i>),
where
<i>T</i>
is an arithmetic type other than
<i>bool</i>,
and
<i>VQ</i>
is either
<span class='texttt'>volatile</span>
or empty,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<i>VQ T</i>&amp; operator--(<i>VQ T</i>&amp;);
<i>T</i> operator--(<i>VQ T</i>&amp;, int);
</pre></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >For every pair
(<i>T</i>,
<i>VQ</i>),
where
<i>T</i>
is a cv-qualified or cv-unqualified object type, and
<i>VQ</i>
is either
<span class='texttt'>volatile</span>
or empty,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<i>T</i>*<i>VQ</i>&amp; operator++(<i>T</i>*<i>VQ</i>&amp;);
<i>T</i>*<i>VQ</i>&amp; operator--(<i>T</i>*<i>VQ</i>&amp;);
<i>T</i>*    operator++(<i>T</i>*<i>VQ</i>&amp;, int);
<i>T</i>*    operator--(<i>T</i>*<i>VQ</i>&amp;, int);
</pre></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >For every cv-qualified or cv-unqualified object type
<i>T</i>,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<i>T</i>&amp;    operator*(<i>T</i>*);
</pre></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >For every function type
<i>T</i> that does not have cv-qualifiers or a <i ><a href='dcl.decl#nt:ref-qualifier'>ref-qualifier</a></i>,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<i>T</i>&amp;    operator*(<i>T</i>*);
</pre></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >For every type <i>T</i> there exist candidate operator functions of the form</p><pre class='codeblock'>
<i>T</i>*    operator+(<i>T</i>*);
</pre></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >For every promoted arithmetic type
<i>T</i>,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<i>T</i> operator+(<i>T</i>);
<i>T</i> operator-(<i>T</i>);
</pre></div><div class='para' id='10'><div class='marginalizedparent'><a class='marginalized' href='#10'>10</a></div><p >For every promoted integral type
<i>T</i>,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<i>T</i> operator~(<i>T</i>);
</pre></div><div class='para' id='11'><div class='marginalizedparent'><a class='marginalized' href='#11'>11</a></div><p >For every quintuple
(<i>C1</i>,
<i>C2</i>,
<i>T</i>,
<i>CV1</i>,
<i>CV2</i>),
where
<i>C2</i>
is a class type,
<i>C1</i>
is the same type as C2 or is a derived class of C2,
<i>T</i>
is an object type or a function type,
and
<i>CV1</i>
and
<i>CV2</i>
are
<i ><a href='dcl.decl#nt:cv-qualifier-seq'>cv-qualifier-seqs</a></i>,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<i>CV12 T</i>&amp; operator-&gt;*(<i>CV1 C1</i>*, <i>CV2 T C2</i>::*);
</pre><p >where
<i>CV12</i>
is the union of
<i>CV1</i>
and
<i>CV2</i>.
The return type is shown for exposition only; see <a href='expr.mptr.oper'>[expr.mptr.oper]</a> for the
determination of the operator's result type.</p></div><div class='para' id='12'><div class='marginalizedparent'><a class='marginalized' href='#12'>12</a></div><p >For every pair of promoted arithmetic types
<i>L</i>
and
<i>R</i>,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<i>LR</i>      operator*(<i>L</i>, <i>R</i>);
<i>LR</i>      operator/(<i>L</i>, <i>R</i>);
<i>LR</i>      operator+(<i>L</i>, <i>R</i>);
<i>LR</i>      operator-(<i>L</i>, <i>R</i>);
bool    operator&lt;(<i>L</i>, <i>R</i>);
bool    operator&gt;(<i>L</i>, <i>R</i>);
bool    operator&lt;=(<i>L</i>, <i>R</i>);
bool    operator&gt;=(<i>L</i>, <i>R</i>);
bool    operator==(<i>L</i>, <i>R</i>);
bool    operator!=(<i>L</i>, <i>R</i>);
</pre><p >where
<i>LR</i>
is the result of the usual arithmetic conversions between types
<i>L</i>
and
<i>R</i>.</p></div><div class='para' id='13'><div class='marginalizedparent'><a class='marginalized' href='#13'>13</a></div><p >For every cv-qualified or cv-unqualified object type
<i>T</i>
there exist candidate operator functions of the form</p><pre class='codeblock'>
<i>T</i>*      operator+(<i>T</i>*, std::ptrdiff_t);
<i>T</i>&amp;      operator[](<i>T</i>*, std::ptrdiff_t);
<i>T</i>*      operator-(<i>T</i>*, std::ptrdiff_t);
<i>T</i>*      operator+(std::ptrdiff_t, <i>T</i>*);
<i>T</i>&amp;      operator[](std::ptrdiff_t, <i>T</i>*);
</pre></div><div class='para' id='14'><div class='marginalizedparent'><a class='marginalized' href='#14'>14</a></div><p >For every
<i>T</i>,
where
<i>T</i>
is a pointer to object type,
there exist candidate operator functions of the form</p><pre class='codeblock'>
std::ptrdiff_t   operator-(<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>, <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>);
</pre></div><div class='para' id='15'><div class='marginalizedparent'><a class='marginalized' href='#15'>15</a></div><p >For every <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>, where <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a> is an enumeration type or a pointer type,
there exist candidate operator functions of the form</p><pre class='codeblock'>
bool    operator&lt;(<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>, <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>);
bool    operator&gt;(<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>, <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>);
bool    operator&lt;=(<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>, <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>);
bool    operator&gt;=(<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>, <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>);
bool    operator==(<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>, <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>);
bool    operator!=(<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>, <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>);
</pre></div><div class='para' id='16'><div class='marginalizedparent'><a class='marginalized' href='#16'>16</a></div><p >For every pointer to member type <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a> or type <span class='texttt'>std::nullptr_t</span> there
exist candidate operator functions of the form</p><pre class='codeblock'>
bool    operator==(<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>, <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>);
bool    operator!=(<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>, <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>);
</pre></div><div class='para' id='17'><div class='marginalizedparent'><a class='marginalized' href='#17'>17</a></div><p >For every pair of promoted integral types
<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>
and
<a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<a class='hidden_link' href='#def:LR' id='def:LR'><i>LR</i></a>      operator%(<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
<a class='hidden_link' href='#def:LR' id='def:LR'><i>LR</i></a>      operator&amp;(<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
<a class='hidden_link' href='#def:LR' id='def:LR'><i>LR</i></a>      operator^(<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
<a class='hidden_link' href='#def:LR' id='def:LR'><i>LR</i></a>      operator|(<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>       operator&lt;&lt;(<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>       operator&gt;&gt;(<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
</pre><p >where
<a class='hidden_link' href='#def:LR' id='def:LR'><i>LR</i></a>
is the result of the usual arithmetic conversions between types
<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>
and
<a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>.</p></div><div class='para' id='18'><div class='marginalizedparent'><a class='marginalized' href='#18'>18</a></div><p >For every triple
(<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>,
<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>,
<a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>),
where
<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>
is an arithmetic type,
<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>
is either
<span class='texttt'>volatile</span>
or empty,
and
<a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>
is a promoted arithmetic type,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;   operator=(<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;   operator*=(<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;   operator/=(<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;   operator+=(<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;   operator-=(<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
</pre></div><div class='para' id='19'><div class='marginalizedparent'><a class='marginalized' href='#19'>19</a></div><p >For every pair (<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>, <a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>), where <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a> is any type and <a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a> is either
<span class='texttt'>volatile</span> or empty, there exist candidate operator functions of the form</p><pre class='codeblock'>
<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>*<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>&amp;   operator=(<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>*<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>&amp;, <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>*);
</pre></div><div class='para' id='20'><div class='marginalizedparent'><a class='marginalized' href='#20'>20</a></div><p >For every pair
(<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>,
<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>),
where
<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>
is an enumeration or pointer to member type and
<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>
is either
<span class='texttt'>volatile</span>
or empty,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a> <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>&amp;   operator=(<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a> <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>&amp;, <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>);
</pre></div><div class='para' id='21'><div class='marginalizedparent'><a class='marginalized' href='#21'>21</a></div><p >For every pair
(<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>,
<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>),
where
<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>
is a cv-qualified or cv-unqualified object type and
<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>
is either
<span class='texttt'>volatile</span>
or empty,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>*<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>&amp;   operator+=(<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>*<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>&amp;, std::ptrdiff_t);
<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>*<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>&amp;   operator-=(<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>*<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>&amp;, std::ptrdiff_t);
</pre></div><div class='para' id='22'><div class='marginalizedparent'><a class='marginalized' href='#22'>22</a></div><p >For every triple
(<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>,
<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>,
<a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>),
where
<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>
is an integral type,
<a class='hidden_link' href='#def:VQ' id='def:VQ'><i>VQ</i></a>
is either
<span class='texttt'>volatile</span>
or empty,
and
<a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>
is a promoted integral type,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;   operator%=(<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;   operator&lt;&lt;=(<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;   operator&gt;&gt;=(<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;   operator&amp;=(<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;   operator^=(<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;   operator|=(<a class='hidden_link' href='#def:VQ_L' id='def:VQ_L'><i>VQ L</i></a>&amp;, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
</pre></div><div class='para' id='23'><div class='marginalizedparent'><a class='marginalized' href='#23'>23</a></div><p >There also exist candidate operator functions of the form</p><pre class='codeblock'>
bool    operator!(bool);
bool    operator&amp;&amp;(bool, bool);
bool    operator||(bool, bool);
</pre></div><div class='para' id='24'><div class='marginalizedparent'><a class='marginalized' href='#24'>24</a></div><p >For every pair of promoted arithmetic types
<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>
and
<a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>,
there exist candidate operator functions of the form</p><pre class='codeblock'>
<a class='hidden_link' href='#def:LR' id='def:LR'><i>LR</i></a>      operator?:(bool, <a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>, <a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>);
</pre><p >where
<a class='hidden_link' href='#def:LR' id='def:LR'><i>LR</i></a>
is the result of the usual arithmetic conversions between types
<a class='hidden_link' href='#def:L' id='def:L'><i>L</i></a>
and
<a class='hidden_link' href='#def:R' id='def:R'><i>R</i></a>.
[&nbsp;<i>Note:</i><span class='space'></span>
As with all these descriptions of candidate functions, this declaration serves
only to describe the built-in operator for purposes of overload resolution.
The operator
“<span class='texttt'>?:</span>”
cannot be overloaded.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='25'><div class='marginalizedparent'><a class='marginalized' href='#25'>25</a></div><p >For every type
<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>,
where
<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>
is a pointer, pointer-to-member, or scoped enumeration type, there exist candidate operator
functions of the form</p><pre class='codeblock'>
<a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>       operator?:(bool, <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>, <a class='hidden_link' href='#def:T' id='def:T'><i>T</i></a>);
</pre><p ><span class='indexparent'><a class='index' id='overloading'></a></span>
</p></div></div></div></body></html>