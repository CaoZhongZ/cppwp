<!DOCTYPE html><html lang='en'><head><title>[atomics.types.generic]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>29</a> Atomic operations library <a class='abbr_ref' href='./#atomics'>[atomics]</a></h1><div id='atomics.types.generic'><h2 ><a class='secnum' style='min-width:88pt'>29.5</a> Atomic types <a class='abbr_ref'>[atomics.types.generic]</a></h2><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; struct atomic {
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    static constexpr bool is_always_lock_free = <i>implementation-defined</i>;
    void store(T, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(T, memory_order = memory_order_seq_cst) noexcept;
    T load(memory_order = memory_order_seq_cst) const volatile noexcept;
    T load(memory_order = memory_order_seq_cst) const noexcept;
    operator T() const volatile noexcept;
    operator T() const noexcept;
    T exchange(T, memory_order = memory_order_seq_cst) volatile noexcept;
    T exchange(T, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    T operator=(T) volatile noexcept;
    T operator=(T) noexcept;
  };

  template &lt;&gt; struct atomic&lt;<i>integral</i>&gt; {
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    static constexpr bool is_always_lock_free = <i>implementation-defined</i>;
    void store(<i>integral</i>, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(<i>integral</i>, memory_order = memory_order_seq_cst) noexcept;
    <i>integral</i> load(memory_order = memory_order_seq_cst) const volatile noexcept;
    <i>integral</i> load(memory_order = memory_order_seq_cst) const noexcept;
    operator <i>integral()</i> const volatile noexcept;
    operator <i>integral()</i> const noexcept;
    <i>integral</i> exchange(<i>integral</i>, memory_order = memory_order_seq_cst) volatile noexcept;
    <i>integral</i> exchange(<i>integral</i>, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(<i>integral</i>&amp;, <i>integral</i>, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(<i>integral</i>&amp;, <i>integral</i>, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(<i>integral</i>&amp;, <i>integral</i>, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(<i>integral</i>&amp;, <i>integral</i>, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(<i>integral</i>&amp;, <i>integral</i>, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(<i>integral</i>&amp;, <i>integral</i>, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(<i>integral</i>&amp;, <i>integral</i>, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(<i>integral</i>&amp;, <i>integral</i>, memory_order = memory_order_seq_cst) noexcept;
    <i>integral</i> fetch_add(<i>integral</i>, memory_order = memory_order_seq_cst) volatile noexcept;
    <i>integral</i> fetch_add(<i>integral</i>, memory_order = memory_order_seq_cst) noexcept;
    <i>integral</i> fetch_sub(<i>integral</i>, memory_order = memory_order_seq_cst) volatile noexcept;
    <i>integral</i> fetch_sub(<i>integral</i>, memory_order = memory_order_seq_cst) noexcept;
    <i>integral</i> fetch_and(<i>integral</i>, memory_order = memory_order_seq_cst) volatile noexcept;
    <i>integral</i> fetch_and(<i>integral</i>, memory_order = memory_order_seq_cst) noexcept;
    <i>integral</i> fetch_or(<i>integral</i>, memory_order = memory_order_seq_cst) volatile noexcept;
    <i>integral</i> fetch_or(<i>integral</i>, memory_order = memory_order_seq_cst) noexcept;
    <i>integral</i> fetch_xor(<i>integral</i>, memory_order = memory_order_seq_cst) volatile noexcept;
    <i>integral</i> fetch_xor(<i>integral</i>, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(<i>integral</i>) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    <i>integral</i> operator=(<i>integral</i>) volatile noexcept;
    <i>integral</i> operator=(<i>integral</i>) noexcept;

    <i>integral</i> operator++(int) volatile noexcept;
    <i>integral</i> operator++(int) noexcept;
    <i>integral</i> operator--(int) volatile noexcept;
    <i>integral</i> operator--(int) noexcept;
    <i>integral</i> operator++() volatile noexcept;
    <i>integral</i> operator++() noexcept;
    <i>integral</i> operator--() volatile noexcept;
    <i>integral</i> operator--() noexcept;
    <i>integral</i> operator+=(<i>integral</i>) volatile noexcept;
    <i>integral</i> operator+=(<i>integral</i>) noexcept;
    <i>integral</i> operator-=(<i>integral</i>) volatile noexcept;
    <i>integral</i> operator-=(<i>integral</i>) noexcept;
    <i>integral</i> operator&amp;=(<i>integral</i>) volatile noexcept;
    <i>integral</i> operator&amp;=(<i>integral</i>) noexcept;
    <i>integral</i> operator|=(<i>integral</i>) volatile noexcept;
    <i>integral</i> operator|=(<i>integral</i>) noexcept;
    <i>integral</i> operator^=(<i>integral</i>) volatile noexcept;
    <i>integral</i> operator^=(<i>integral</i>) noexcept;
  };

  template &lt;class T&gt; struct atomic&lt;T*&gt; {
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    static constexpr bool is_always_lock_free = <i>implementation-defined</i>;
    void store(T*, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(T*, memory_order = memory_order_seq_cst) noexcept;
    T* load(memory_order = memory_order_seq_cst) const volatile noexcept;
    T* load(memory_order = memory_order_seq_cst) const noexcept;
    operator T*() const volatile noexcept;
    operator T*() const noexcept;
    T* exchange(T*, memory_order = memory_order_seq_cst) volatile noexcept;
    T* exchange(T*, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order = memory_order_seq_cst) noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T*) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    T* operator=(T*) volatile noexcept;
    T* operator=(T*) noexcept;

    T* operator++(int) volatile noexcept;
    T* operator++(int) noexcept;
    T* operator--(int) volatile noexcept;
    T* operator--(int) noexcept;
    T* operator++() volatile noexcept;
    T* operator++() noexcept;
    T* operator--() volatile noexcept;
    T* operator--() noexcept;
    T* operator+=(ptrdiff_t) volatile noexcept;
    T* operator+=(ptrdiff_t) noexcept;
    T* operator-=(ptrdiff_t) volatile noexcept;
    T* operator-=(ptrdiff_t) noexcept;
  };
}
</pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >There is a generic class template <span class='texttt'>atomic&lt;T&gt;</span>. The type of the template argument
<span class='texttt'>T</span> shall be trivially copyable (<a href='basic.types'>[basic.types]</a>). [&nbsp;<i>Note:</i><span class='space'></span> Type arguments that are
not also statically initializable may be difficult to use. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >The semantics of the operations on specializations of <span class='texttt'>atomic</span> are defined
in <a href='atomics.types.operations'>[atomics.types.operations]</a>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >Specializations and instantiations of the <span class='texttt'>atomic</span> template shall have a deleted copy constructor, a deleted
copy assignment operator, and a constexpr value constructor.</p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><p >There shall be explicit specializations of the <span class='texttt'>atomic</span>
template for the integral types
<span class='texttt'>char</span>,
<span class='texttt'>signed char</span>,
<span class='texttt'>unsigned char</span>,
<span class='texttt'>short</span>,
<span class='texttt'>unsigned short</span>,
<span class='texttt'>int</span>,
<span class='texttt'>unsigned int</span>,
<span class='texttt'>long</span>,
<span class='texttt'>unsigned long</span>,
<span class='texttt'>long long</span>,
<span class='texttt'>unsigned long long</span>,
<span class='texttt'>char16_t</span>,
<span class='texttt'>char32_t</span>,
<span class='texttt'>wchar_t</span>,
and any other types needed by the typedefs in the header <span class='texttt'>&lt;cstdint&gt;</span>.
For each integral type <i>integral</i>, the specialization
<span class='texttt'>atomic&lt;integral&gt;</span> provides additional atomic operations appropriate to integral types.
There shall be a specialization <span class='texttt'>atomic&lt;bool&gt;</span> which provides the general
atomic operations as specified in <a href='atomics.types.operations.general'>[atomics.types.operations.general]</a>.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><p >The atomic integral specializations and the specialization <span class='texttt'>atomic&lt;bool&gt;</span>
shall be standard-layout structs. They shall each have a trivial default constructor
and a trivial destructor. They shall each support aggregate initialization
syntax.</p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><p >There shall be pointer partial specializations of the <span class='texttt'>atomic</span> class template.
These specializations shall be standard-layout structs.
They shall each have a trivial default constructor and a trivial destructor.
They shall each support aggregate initialization syntax.</p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><p >There shall be named types corresponding to the integral specializations of
<span class='texttt'>atomic</span>, as specified in Table <a href='#tab:atomics.integral'>[tab:atomics.integral]</a>, and a named type
<span class='texttt'>atomic_bool</span> corresponding to the specified <span class='texttt'>atomic&lt;bool&gt;</span>. Each named
type is either a typedef to the corresponding specialization or a base class of the
corresponding specialization. If it is a base class, it shall support the same
member functions as the corresponding specialization.</p><div class='numberedTable' id='tab:atomics.integral'>Table <a href='#tab:atomics.integral'>130</a> â€” Named atomic types<br><table ><tr class='rowsep'><td class='left'>


<b>Named atomic type</b> </td><td class='left'> <b>Corresponding non-atomic type</b> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>atomic_char</span>     </td><td class='left'> <span class='texttt'>char</span>                    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_schar</span>    </td><td class='left'> <span class='texttt'>signed char</span>             </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uchar</span>    </td><td class='left'> <span class='texttt'>unsigned char</span>           </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_short</span>    </td><td class='left'> <span class='texttt'>short</span>                   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_ushort</span>   </td><td class='left'> <span class='texttt'>unsigned short</span>          </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_int</span>      </td><td class='left'> <span class='texttt'>int</span>                     </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uint</span>     </td><td class='left'> <span class='texttt'>unsigned int</span>            </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_long</span>     </td><td class='left'> <span class='texttt'>long</span>                    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_ulong</span>    </td><td class='left'> <span class='texttt'>unsigned long</span>           </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_llong</span>    </td><td class='left'> <span class='texttt'>long long</span>               </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_ullong</span>   </td><td class='left'> <span class='texttt'>unsigned long long</span>      </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_char16_t</span> </td><td class='left'> <span class='texttt'>char16_t</span>                </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_char32_t</span> </td><td class='left'> <span class='texttt'>char32_t</span>                </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_wchar_t</span>  </td><td class='left'> <span class='texttt'>wchar_t</span>                 </td></tr></table></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><p >There shall be atomic typedefs corresponding to non-atomic typedefs as
specified in Table <a href='#tab:atomics.typedefs'>[tab:atomics.typedefs]</a>.
<span class='texttt'>atomic_int<span class='math'><span class='mathalpha'>N</span></span>_t</span>, <span class='texttt'>atomic_uint<span class='math'><span class='mathalpha'>N</span></span>_t</span>,
<span class='texttt'>atomic_intptr_t</span>, and <span class='texttt'>atomic_uintptr_t</span>
shall be defined if and only if
<span class='texttt'>int<span class='math'><span class='mathalpha'>N</span></span>_t</span>, <span class='texttt'>uint<span class='math'><span class='mathalpha'>N</span></span>_t</span>,
<span class='texttt'>intptr_t</span>, and <span class='texttt'>uintptr_t</span>
are defined, respectively.</p><div class='numberedTable' id='tab:atomics.typedefs'>Table <a href='#tab:atomics.typedefs'>131</a> â€” Atomic typedefs<br><table ><tr class='rowsep'><td class='left'>


<b>Atomic typedef</b> </td><td class='left'> <b>Corresponding non-atomic typedef</b> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>atomic_int8_t</span>         </td><td class='left'> <span class='texttt'>int8_t</span>          </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uint8_t</span>        </td><td class='left'> <span class='texttt'>uint8_t</span>         </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_int16_t</span>        </td><td class='left'> <span class='texttt'>int16_t</span>         </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uint16_t</span>       </td><td class='left'> <span class='texttt'>uint16_t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_int32_t</span>        </td><td class='left'> <span class='texttt'>int32_t</span>         </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uint32_t</span>       </td><td class='left'> <span class='texttt'>uint32_t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_int64_t</span>        </td><td class='left'> <span class='texttt'>int64_t</span>         </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uint64_t</span>       </td><td class='left'> <span class='texttt'>uint64_t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_int_least8_t</span>   </td><td class='left'> <span class='texttt'>int_least8_t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uint_least8_t</span>  </td><td class='left'> <span class='texttt'>uint_least8_t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_int_least16_t</span>  </td><td class='left'> <span class='texttt'>int_least16_t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uint_least16_t</span> </td><td class='left'> <span class='texttt'>uint_least16_t</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_int_least32_t</span>  </td><td class='left'> <span class='texttt'>int_least32_t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uint_least32_t</span> </td><td class='left'> <span class='texttt'>uint_least32_t</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_int_least64_t</span>  </td><td class='left'> <span class='texttt'>int_least64_t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uint_least64_t</span> </td><td class='left'> <span class='texttt'>uint_least64_t</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_int_fast8_t</span>    </td><td class='left'> <span class='texttt'>int_fast8_t</span>     </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uint_fast8_t</span>   </td><td class='left'> <span class='texttt'>uint_fast8_t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_int_fast16_t</span>   </td><td class='left'> <span class='texttt'>int_fast16_t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uint_fast16_t</span>  </td><td class='left'> <span class='texttt'>uint_fast16_t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_int_fast32_t</span>   </td><td class='left'> <span class='texttt'>int_fast32_t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uint_fast32_t</span>  </td><td class='left'> <span class='texttt'>uint_fast32_t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_int_fast64_t</span>   </td><td class='left'> <span class='texttt'>int_fast64_t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uint_fast64_t</span>  </td><td class='left'> <span class='texttt'>uint_fast64_t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_intptr_t</span>       </td><td class='left'> <span class='texttt'>intptr_t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uintptr_t</span>      </td><td class='left'> <span class='texttt'>uintptr_t</span>       </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_size_t</span>         </td><td class='left'> <span class='texttt'>size_t</span>          </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_ptrdiff_t</span>      </td><td class='left'> <span class='texttt'>ptrdiff_t</span>       </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_intmax_t</span>       </td><td class='left'> <span class='texttt'>intmax_t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_uintmax_t</span>      </td><td class='left'> <span class='texttt'>uintmax_t</span>       </td></tr></table></div></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><p >[&nbsp;<i>Note:</i><span class='space'></span> The representation of an atomic specialization need not have the same size as its
corresponding argument type. Specializations should have the same size whenever possible, as
this reduces the effort required to port existing code. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div></div></body></html>