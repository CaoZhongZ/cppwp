<!DOCTYPE html><html lang='en'><head><title>[atomics.types.generic]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>29</a> Atomic operations library <a class='abbr_ref' href='./#atomics'>[atomics]</a></h1><div id='atomics.types.generic'><h2 ><a class='secnum' style='min-width:88pt'>29.5</a> Atomic types <a class='abbr_ref'>[atomics.types.generic]</a></h2><p ><span class='indexparent'><a class='index' id='atomic'></a></span><span class='indexparent'><a class='index' id='atomic<T*>'></a></span><span class='indexparent'><a class='index' id='atomic<integral>'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; struct atomic {
    static constexpr bool is_always_lock_free = <span class='indexparent'><a class='index' id='whether_a_given_atomic_type&#39;s_operations_are_always_lock_free'></a></span><span class='textit'>implementation-defined</span>;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(T, memory_order = memory_order_seq_cst) noexcept;
    T load(memory_order = memory_order_seq_cst) const volatile noexcept;
    T load(memory_order = memory_order_seq_cst) const noexcept;
    operator T() const volatile noexcept;
    operator T() const noexcept;
    T exchange(T, memory_order = memory_order_seq_cst) volatile noexcept;
    T exchange(T, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    T operator=(T) volatile noexcept;
    T operator=(T) noexcept;
  };

  template &lt;&gt; struct atomic&lt;<span class='textit'>integral</span>&gt; {
    static constexpr bool is_always_lock_free = <span class='indexparent'><a class='index' id='whether_a_given_atomic_type&#39;s_operations_are_always_lock_free'></a></span><span class='textit'>implementation-defined</span>;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> load(memory_order = memory_order_seq_cst) const volatile noexcept;
    <span class='textit'>integral</span> load(memory_order = memory_order_seq_cst) const noexcept;
    operator <span class='textit'>integral</span>() const volatile noexcept;
    operator <span class='textit'>integral</span>() const noexcept;
    <span class='textit'>integral</span> exchange(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> exchange(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order, memory_order) noexcept;
    bool compare_exchange_strong(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                                 memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                                 memory_order, memory_order) noexcept;
    bool compare_exchange_weak(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_add(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_add(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_sub(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_sub(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_and(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_and(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_or(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_or(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_xor(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_xor(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(<span class='textit'>integral</span>) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    <span class='textit'>integral</span> operator=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator=(<span class='textit'>integral</span>) noexcept;

    <span class='textit'>integral</span> operator++(int) volatile noexcept;
    <span class='textit'>integral</span> operator++(int) noexcept;
    <span class='textit'>integral</span> operator--(int) volatile noexcept;
    <span class='textit'>integral</span> operator--(int) noexcept;
    <span class='textit'>integral</span> operator++() volatile noexcept;
    <span class='textit'>integral</span> operator++() noexcept;
    <span class='textit'>integral</span> operator--() volatile noexcept;
    <span class='textit'>integral</span> operator--() noexcept;
    <span class='textit'>integral</span> operator+=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator+=(<span class='textit'>integral</span>) noexcept;
    <span class='textit'>integral</span> operator-=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator-=(<span class='textit'>integral</span>) noexcept;
    <span class='textit'>integral</span> operator&amp;=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator&amp;=(<span class='textit'>integral</span>) noexcept;
    <span class='textit'>integral</span> operator|=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator|=(<span class='textit'>integral</span>) noexcept;
    <span class='textit'>integral</span> operator^=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator^=(<span class='textit'>integral</span>) noexcept;
  };

  template &lt;class T&gt; struct atomic&lt;T*&gt; {
    static constexpr bool is_always_lock_free = <span class='indexparent'><a class='index' id='whether_a_given_atomic_type&#39;s_operations_are_always_lock_free'></a></span><span class='textit'>implementation-defined</span>;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T*, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(T*, memory_order = memory_order_seq_cst) noexcept;
    T* load(memory_order = memory_order_seq_cst) const volatile noexcept;
    T* load(memory_order = memory_order_seq_cst) const noexcept;
    operator T*() const volatile noexcept;
    operator T*() const noexcept;
    T* exchange(T*, memory_order = memory_order_seq_cst) volatile noexcept;
    T* exchange(T*, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order = memory_order_seq_cst) noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T*) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    T* operator=(T*) volatile noexcept;
    T* operator=(T*) noexcept;

    T* operator++(int) volatile noexcept;
    T* operator++(int) noexcept;
    T* operator--(int) volatile noexcept;
    T* operator--(int) noexcept;
    T* operator++() volatile noexcept;
    T* operator++() noexcept;
    T* operator--() volatile noexcept;
    T* operator--() noexcept;
    T* operator+=(ptrdiff_t) volatile noexcept;
    T* operator+=(ptrdiff_t) noexcept;
    T* operator-=(ptrdiff_t) volatile noexcept;
    T* operator-=(ptrdiff_t) noexcept;
  };
}</pre><p ><span class='indexparent'><a class='index' id='atomic'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L589'>#</a></div><p >There is a generic class template <span class='texttt'>atomic&lt;T&gt;</span>. The type of the template argument
<span class='texttt'>T</span> shall be trivially copyable (<a href='basic.types'>[basic.types]</a>). [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> Type arguments that are
not also statically initializable may be difficult to use. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L594'>#</a></div><p >The semantics of the operations on specializations of <span class='texttt'>atomic</span> are defined
in <a href='atomics.types.operations'>[atomics.types.operations]</a>.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L598'>#</a></div><p >Specializations and instantiations of the <span class='texttt'>atomic</span> template shall have a deleted copy constructor, a deleted
copy assignment operator, and a constexpr value constructor.</p><p ><span class='indexparent'><a class='index' id='atomic<integral>'></a></span></p></div><div class='para' id='4'><div class='marginalizedparent'><a class='marginalized' href='#4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L603'>#</a></div><p >There shall be explicit specializations of the <span class='texttt'>atomic</span>
template for the integral types
<span class='texttt'>char</span>,
<span class='texttt'>signed char</span>,
<span class='texttt'>unsigned char</span>,
<span class='texttt'>short</span>,
<span class='texttt'>unsigned short</span>,
<span class='texttt'>int</span>,
<span class='texttt'>unsigned int</span>,
<span class='texttt'>long</span>,
<span class='texttt'>unsigned long</span>,
<span class='texttt'>long long</span>,
<span class='texttt'>unsigned long long</span>,
<span class='texttt'>char16_&shy;t</span>,
<span class='texttt'>char32_&shy;t</span>,
<span class='texttt'>wchar_&shy;t</span>,
and any other types needed by the typedefs in the header <span class='texttt'>&lt;cstdint&gt;</span>.
For each integral type <span class='texttt'><span class='textit'>integral</span></span>, the specialization
<span class='texttt'>atomic&lt;<span class='textit'>integral</span>&gt;</span> provides additional atomic operations appropriate to integral types.
There shall be a specialization <span class='texttt'>atomic&lt;bool&gt;</span> which provides the general
atomic operations as specified in <a href='atomics.types.operations.general'>[atomics.types.operations.general]</a>.</p></div><div class='para' id='5'><div class='marginalizedparent'><a class='marginalized' href='#5'>5</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L626'>#</a></div><p >The atomic integral specializations and the specialization <span class='texttt'>atomic&lt;bool&gt;</span>
shall be standard-layout structs. They shall each have a trivial default constructor
and a trivial destructor. They shall each support aggregate initialization
syntax.</p><p ><span class='indexparent'><a class='index' id='atomic<T*>'></a></span></p></div><div class='para' id='6'><div class='marginalizedparent'><a class='marginalized' href='#6'>6</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L633'>#</a></div><p >There shall be pointer partial specializations of the <span class='texttt'>atomic</span> class template.
These specializations shall be standard-layout structs.
They shall each have a trivial default constructor and a trivial destructor.
They shall each support aggregate initialization syntax.</p><p ><span class='indexparent'><a class='index' id='atomic_bool'></a></span></p></div><div class='para' id='7'><div class='marginalizedparent'><a class='marginalized' href='#7'>7</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L640'>#</a></div><p >There shall be named types corresponding to the integral specializations of
<span class='texttt'>atomic</span>, as specified in Table <a href='#tab:atomics.integral'>[tab:atomics.integral]</a>, and a named type
<span class='texttt'>atomic_&shy;bool</span> corresponding to the specified <span class='texttt'>atomic&lt;bool&gt;</span>. Each named
type is either a typedef to the corresponding specialization or a base class of the
corresponding specialization. If it is a base class, it shall support the same
member functions as the corresponding specialization.</p><p ><span class='indexparent'><a class='index' id='atomic_char'></a></span><span class='indexparent'><a class='index' id='atomic_schar'></a></span><span class='indexparent'><a class='index' id='atomic_uchar'></a></span><span class='indexparent'><a class='index' id='atomic_short'></a></span><span class='indexparent'><a class='index' id='atomic_ushort'></a></span><span class='indexparent'><a class='index' id='atomic_int'></a></span><span class='indexparent'><a class='index' id='atomic_uint'></a></span><span class='indexparent'><a class='index' id='atomic_long'></a></span><span class='indexparent'><a class='index' id='atomic_ulong'></a></span><span class='indexparent'><a class='index' id='atomic_llong'></a></span><span class='indexparent'><a class='index' id='atomic_ullong'></a></span><span class='indexparent'><a class='index' id='atomic_char16_t'></a></span><span class='indexparent'><a class='index' id='atomic_char32_t'></a></span><span class='indexparent'><a class='index' id='atomic_wchar_t'></a></span>
 </p><div class='numberedTable' id='tab:atomics.integral'>Table <a href='#tab:atomics.integral'>138</a> — Named atomic types<br><table ><tr class='rowsep'><td class='left'>
<b>Named atomic type</b> </td><td class='left'> <b>Corresponding non-atomic type</b> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>atomic_&shy;char</span>     </td><td class='left'> <span class='texttt'>char</span>                    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;schar</span>    </td><td class='left'> <span class='texttt'>signed char</span>             </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uchar</span>    </td><td class='left'> <span class='texttt'>unsigned char</span>           </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;short</span>    </td><td class='left'> <span class='texttt'>short</span>                   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;ushort</span>   </td><td class='left'> <span class='texttt'>unsigned short</span>          </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int</span>      </td><td class='left'> <span class='texttt'>int</span>                     </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint</span>     </td><td class='left'> <span class='texttt'>unsigned int</span>            </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;long</span>     </td><td class='left'> <span class='texttt'>long</span>                    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;ulong</span>    </td><td class='left'> <span class='texttt'>unsigned long</span>           </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;llong</span>    </td><td class='left'> <span class='texttt'>long long</span>               </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;ullong</span>   </td><td class='left'> <span class='texttt'>unsigned long long</span>      </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;char16_&shy;t</span> </td><td class='left'> <span class='texttt'>char16_&shy;t</span>                </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;char32_&shy;t</span> </td><td class='left'> <span class='texttt'>char32_&shy;t</span>                </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;wchar_&shy;t</span>  </td><td class='left'> <span class='texttt'>wchar_&shy;t</span>                 </td></tr></table></div></div><div class='para' id='8'><div class='marginalizedparent'><a class='marginalized' href='#8'>8</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L683'>#</a></div><p >There shall be atomic typedefs corresponding to non-atomic typedefs as
specified in Table <a href='#tab:atomics.typedefs'>[tab:atomics.typedefs]</a>.
<span class='texttt'>atomic_&shy;int<span class='math'><span class='mathalpha'>N</span></span>_&shy;t</span>, <span class='texttt'>atomic_&shy;uint<span class='math'><span class='mathalpha'>N</span></span>_&shy;t</span>,
<span class='texttt'>atomic_&shy;intptr_&shy;t</span>, and <span class='texttt'>atomic_&shy;uintptr_&shy;t</span>
shall be defined if and only if
<span class='texttt'>int<span class='math'><span class='mathalpha'>N</span></span>_&shy;t</span>, <span class='texttt'>uint<span class='math'><span class='mathalpha'>N</span></span>_&shy;t</span>,
<span class='texttt'>intptr_&shy;t</span>, and <span class='texttt'>uintptr_&shy;t</span>
are defined, respectively.</p><p ><span class='indexparent'><a class='index' id='atomic_int8_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint8_t'></a></span><span class='indexparent'><a class='index' id='atomic_int16_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint16_t'></a></span><span class='indexparent'><a class='index' id='atomic_int32_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint32_t'></a></span><span class='indexparent'><a class='index' id='atomic_int64_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint64_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_least8_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_least8_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_least16_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_least16_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_least32_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_least32_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_least64_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_least64_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_fast8_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_fast8_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_fast16_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_fast16_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_fast32_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_fast32_t'></a></span><span class='indexparent'><a class='index' id='atomic_int_fast64_t'></a></span><span class='indexparent'><a class='index' id='atomic_uint_fast64_t'></a></span><span class='indexparent'><a class='index' id='atomic_intptr_t'></a></span><span class='indexparent'><a class='index' id='atomic_uintptr_t'></a></span><span class='indexparent'><a class='index' id='atomic_size_t'></a></span><span class='indexparent'><a class='index' id='atomic_ptrdiff_t'></a></span><span class='indexparent'><a class='index' id='atomic_intmax_t'></a></span><span class='indexparent'><a class='index' id='atomic_uintmax_t'></a></span>
 </p><div class='numberedTable' id='tab:atomics.typedefs'>Table <a href='#tab:atomics.typedefs'>139</a> — Atomic typedefs<br><table ><tr class='rowsep'><td class='left'>
<b>Atomic typedef</b> </td><td class='left'> <b>Corresponding non-atomic typedef</b> </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>atomic_&shy;int8_&shy;t</span>         </td><td class='left'> <span class='texttt'>int8_&shy;t</span>          </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint8_&shy;t</span>        </td><td class='left'> <span class='texttt'>uint8_&shy;t</span>         </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int16_&shy;t</span>        </td><td class='left'> <span class='texttt'>int16_&shy;t</span>         </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint16_&shy;t</span>       </td><td class='left'> <span class='texttt'>uint16_&shy;t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int32_&shy;t</span>        </td><td class='left'> <span class='texttt'>int32_&shy;t</span>         </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint32_&shy;t</span>       </td><td class='left'> <span class='texttt'>uint32_&shy;t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int64_&shy;t</span>        </td><td class='left'> <span class='texttt'>int64_&shy;t</span>         </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint64_&shy;t</span>       </td><td class='left'> <span class='texttt'>uint64_&shy;t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;least8_&shy;t</span>   </td><td class='left'> <span class='texttt'>int_&shy;least8_&shy;t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;least8_&shy;t</span>  </td><td class='left'> <span class='texttt'>uint_&shy;least8_&shy;t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;least16_&shy;t</span>  </td><td class='left'> <span class='texttt'>int_&shy;least16_&shy;t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;least16_&shy;t</span> </td><td class='left'> <span class='texttt'>uint_&shy;least16_&shy;t</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;least32_&shy;t</span>  </td><td class='left'> <span class='texttt'>int_&shy;least32_&shy;t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;least32_&shy;t</span> </td><td class='left'> <span class='texttt'>uint_&shy;least32_&shy;t</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;least64_&shy;t</span>  </td><td class='left'> <span class='texttt'>int_&shy;least64_&shy;t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;least64_&shy;t</span> </td><td class='left'> <span class='texttt'>uint_&shy;least64_&shy;t</span>  </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;fast8_&shy;t</span>    </td><td class='left'> <span class='texttt'>int_&shy;fast8_&shy;t</span>     </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;fast8_&shy;t</span>   </td><td class='left'> <span class='texttt'>uint_&shy;fast8_&shy;t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;fast16_&shy;t</span>   </td><td class='left'> <span class='texttt'>int_&shy;fast16_&shy;t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;fast16_&shy;t</span>  </td><td class='left'> <span class='texttt'>uint_&shy;fast16_&shy;t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;fast32_&shy;t</span>   </td><td class='left'> <span class='texttt'>int_&shy;fast32_&shy;t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;fast32_&shy;t</span>  </td><td class='left'> <span class='texttt'>uint_&shy;fast32_&shy;t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;int_&shy;fast64_&shy;t</span>   </td><td class='left'> <span class='texttt'>int_&shy;fast64_&shy;t</span>    </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uint_&shy;fast64_&shy;t</span>  </td><td class='left'> <span class='texttt'>uint_&shy;fast64_&shy;t</span>   </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;intptr_&shy;t</span>       </td><td class='left'> <span class='texttt'>intptr_&shy;t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uintptr_&shy;t</span>      </td><td class='left'> <span class='texttt'>uintptr_&shy;t</span>       </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;size_&shy;t</span>         </td><td class='left'> <span class='texttt'>size_&shy;t</span>          </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;ptrdiff_&shy;t</span>      </td><td class='left'> <span class='texttt'>ptrdiff_&shy;t</span>       </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;intmax_&shy;t</span>       </td><td class='left'> <span class='texttt'>intmax_&shy;t</span>        </td></tr><tr ><td class='left'>
<span class='texttt'>atomic_&shy;uintmax_&shy;t</span>      </td><td class='left'> <span class='texttt'>uintmax_&shy;t</span>       </td></tr></table></div></div><div class='para' id='9'><div class='marginalizedparent'><a class='marginalized' href='#9'>9</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/atomics.tex#L760'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> The representation of an atomic specialization need not have the same size as its
corresponding argument type. Specializations should have the same size whenever possible, as
this reduces the effort required to port existing code. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>]</p></div></div></div></body></html>