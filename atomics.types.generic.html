<!DOCTYPE html><html lang='en'><head><title>[atomics.types.generic]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>32</a> Atomic operations library <a class='abbr_ref' href='./#atomics'>[atomics]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>32.6</a> Class template <span class='texttt'>atomic</span> <a class='abbr_ref'>[atomics.types.generic]</a></h2><p ><span class='indexparent'><a class='index' id='lib:atomic'></a></span></p><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; struct atomic {
    using value_type = T;
    static constexpr bool is_always_lock_free = <span class='indexparent'><a class='index' id=':whether_a_given_atomic_type&#39;s_operations_are_always_lock_free'></a></span><span class='textit'>implementation-defined</span>;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(T, memory_order = memory_order_seq_cst) noexcept;
    T load(memory_order = memory_order_seq_cst) const volatile noexcept;
    T load(memory_order = memory_order_seq_cst) const noexcept;
    operator T() const volatile noexcept;
    operator T() const noexcept;
    T exchange(T, memory_order = memory_order_seq_cst) volatile noexcept;
    T exchange(T, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(T&amp;, T, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(T&amp;, T, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    T operator=(T) volatile noexcept;
    T operator=(T) noexcept;
  };
}</pre><p ><span class='indexparent'><a class='index' id='lib:atomic_'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L586'>#</a></div><p >The template argument for
<span class='texttt'>T</span> shall be trivially copyable (<a href='basic.types'>[basic.types]</a>). [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  Type arguments that are
not also statically initializable may be difficult to use. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L591'>#</a></div><p >The specialization <span class='texttt'>atomic&lt;bool&gt;</span> is a standard-layout struct.</p></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L594'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  The representation of an atomic specialization need not have the same size as its
corresponding argument type. Specializations should have the same size whenever possible, as
this reduces the effort required to port existing code. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div><div id='atomics.types.operations'><h3 ><a class='secnum' href='#atomics.types.operations' style='min-width:103pt'>32.6.1</a> Operations on atomic types <a class='abbr_ref' href='atomics.types.operations'>[atomics.types.operations]</a></h3><div class='para' id='atomics.types.operations-1'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L601'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  Many operations are volatile-qualified. The “volatile as device register”
semantics have not changed in the standard. This qualification means that volatility is
preserved when applying these operations to volatile objects. It does not mean that
operations on non-volatile objects become volatile. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p><p ><span class='indexparent'><a class='index' id='lib:atomic,constructor'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,constructor'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,constructor'></a></span></p></div><p ><code class='itemdecl'>atomic() noexcept = default;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.operations-2'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L615'>#</a></div><p ><span class='textit'>Effects:</span> 
Leaves the atomic object in an uninitialized state.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
These semantics ensure compatibility with C.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:atomic,constructor_'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,constructor_'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,constructor_'></a></span></p><p ><code class='itemdecl'>constexpr atomic(T desired) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.operations-3'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-3'>3</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L631'>#</a></div><p ><span class='textit'>Effects:</span> Initializes the object with the value <span class='texttt'>desired</span>.
Initialization is not an atomic operation (<a href='intro.multithread'>[intro.multithread]</a>).
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  It is possible to have an access to an atomic object <span class='texttt'>A</span>
race with its construction, for example by communicating the address of the
just-constructed object <span class='texttt'>A</span> to another thread via
<span class='texttt'>memory_&shy;order_&shy;relaxed</span> operations on a suitable atomic pointer
variable, and then immediately accessing <span class='texttt'>A</span> in the receiving thread.
This results in undefined behavior. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:ATOMIC_VAR_INIT'></a></span></p><p ><code class='itemdecl'>#define ATOMIC_VAR_INIT(value) <span class='textit'><span class='texttt'>see below</span></span>
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.operations-4'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L648'>#</a></div><p >The macro expands to a token sequence suitable for
constant initialization of
an atomic variable of static storage duration of a type that is
initialization-compatible with <span class='texttt'>value</span>.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  This operation may need to initialize locks. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
Concurrent access to the variable being initialized, even via an atomic operation,
constitutes a data race. [<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span> 
</p><pre class='codeblock'>
atomic&lt;int&gt; v = ATOMIC_VAR_INIT(5);</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] 
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:is_always_lock_free,atomic'></a></span><span class='indexparent'><a class='index' id='lib:atomic,is_always_lock_free'></a></span><span class='indexparent'><a class='index' id='lib:is_always_lock_free,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,is_always_lock_free'></a></span><span class='indexparent'><a class='index' id='lib:is_always_lock_free,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,is_always_lock_free'></a></span></p><p ><code class='itemdecl'>static constexpr bool is_always_lock_free = <span class='indexparent'><a class='index' id=':whether_a_given_atomic_type&#39;s_operations_are_always_lock_free_'></a></span><span class='textit'>implementation-defined</span>;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.operations-5'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L670'>#</a></div><p >The <span class='texttt'>static</span> data member <span class='texttt'>is_&shy;always_&shy;lock_&shy;free</span> is <span class='texttt'>true</span>
if the atomic type's operations are always lock-free, and <span class='texttt'>false</span> otherwise.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
The value of <span class='texttt'>is_&shy;always_&shy;lock_&shy;free</span> is consistent with the value of
the corresponding <span class='texttt'>ATOMIC_&shy;..._&shy;LOCK_&shy;FREE</span> macro, if defined.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:atomic_is_lock_free'></a></span><span class='indexparent'><a class='index' id='lib:is_lock_free,atomic'></a></span><span class='indexparent'><a class='index' id='lib:atomic,is_lock_free'></a></span><span class='indexparent'><a class='index' id='lib:is_lock_free,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,is_lock_free'></a></span><span class='indexparent'><a class='index' id='lib:is_lock_free,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,is_lock_free'></a></span></p><p ><code class='itemdecl'>bool is_lock_free() const volatile noexcept;
bool is_lock_free() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.operations-6'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L689'>#</a></div><p ><span class='textit'>Returns:</span> <span class='texttt'>true</span> if the object's operations are lock-free, <span class='texttt'>false</span> otherwise.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
The return value of the <span class='texttt'>is_&shy;lock_&shy;free</span> member function
is consistent with the value of <span class='texttt'>is_&shy;always_&shy;lock_&shy;free</span> for the same type.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:atomic_store'></a></span><span class='indexparent'><a class='index' id='lib:atomic_store_explicit'></a></span><span class='indexparent'><a class='index' id='lib:store,atomic'></a></span><span class='indexparent'><a class='index' id='lib:atomic,store'></a></span><span class='indexparent'><a class='index' id='lib:store,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,store'></a></span><span class='indexparent'><a class='index' id='lib:store,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,store'></a></span></p><p ><code class='itemdecl'>void store(T desired, memory_order order = memory_order_seq_cst) volatile noexcept;
void store(T desired, memory_order order = memory_order_seq_cst) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.operations-7'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L708'>#</a></div><p ><span class='textit'>Requires:</span> The <span class='texttt'>order</span> argument shall not be <span class='texttt'>memory_&shy;order_&shy;consume</span>,
<span class='texttt'>memory_&shy;order_&shy;acquire</span>, nor <span class='texttt'>memory_&shy;order_&shy;acq_&shy;rel</span>.</p></div></div><div class='para' id='atomics.types.operations-8'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-8'>8</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L712'>#</a></div><p ><span class='textit'>Effects:</span> Atomically replaces the value pointed to by <span class='texttt'>this</span>
with the value of <span class='texttt'>desired</span>. Memory is affected according to the value of
<span class='texttt'>order</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:operator=,atomic'></a></span><span class='indexparent'><a class='index' id='lib:atomic,operator='></a></span><span class='indexparent'><a class='index' id='lib:operator=,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,operator='></a></span><span class='indexparent'><a class='index' id='lib:operator=,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,operator='></a></span></p><p ><code class='itemdecl'>T operator=(T desired) volatile noexcept;
T operator=(T desired) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.operations-9'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-9'>9</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L727'>#</a></div><p ><span class='textit'>Effects:</span> Equivalent to: <span class='texttt'>store(desired)</span>.</p></div></div><div class='para' id='atomics.types.operations-10'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-10'>10</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L730'>#</a></div><p ><span class='textit'>Returns:</span> <span class='texttt'>desired</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:atomic_load'></a></span><span class='indexparent'><a class='index' id='lib:atomic_load_explicit'></a></span><span class='indexparent'><a class='index' id='lib:load,atomic'></a></span><span class='indexparent'><a class='index' id='lib:atomic,load'></a></span><span class='indexparent'><a class='index' id='lib:load,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,load'></a></span><span class='indexparent'><a class='index' id='lib:load,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,load'></a></span></p><p ><code class='itemdecl'>T load(memory_order order = memory_order_seq_cst) const volatile noexcept;
T load(memory_order order = memory_order_seq_cst) const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.operations-11'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-11'>11</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L745'>#</a></div><p ><span class='textit'>Requires:</span> The <span class='texttt'>order</span> argument shall not be <span class='texttt'>memory_&shy;order_&shy;release</span> nor <span class='texttt'>memory_&shy;order_&shy;acq_&shy;rel</span>.</p></div></div><div class='para' id='atomics.types.operations-12'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-12'>12</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L748'>#</a></div><p ><span class='textit'>Effects:</span> Memory is affected according to the value of <span class='texttt'>order</span>.</p></div></div><div class='para' id='atomics.types.operations-13'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-13'>13</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L751'>#</a></div><p ><span class='textit'>Returns:</span> Atomically returns the value pointed to by <span class='texttt'>this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:operator_type,atomic'></a></span><span class='indexparent'><a class='index' id='lib:atomic,operator_type'></a></span><span class='indexparent'><a class='index' id='lib:operator_T*,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,operator_T*'></a></span><span class='indexparent'><a class='index' id='lib:operator_integral,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,operator_integral'></a></span></p><p ><code class='itemdecl'>operator T() const volatile noexcept;
operator T() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.operations-14'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-14'>14</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L764'>#</a></div><p ><span class='textit'>Effects:</span> Equivalent to: <span class='texttt'>return load();</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:atomic_exchange'></a></span><span class='indexparent'><a class='index' id='lib:atomic_exchange_explicit'></a></span><span class='indexparent'><a class='index' id='lib:exchange,atomic'></a></span><span class='indexparent'><a class='index' id='lib:atomic,exchange'></a></span><span class='indexparent'><a class='index' id='lib:exchange,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,exchange'></a></span><span class='indexparent'><a class='index' id='lib:exchange,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,exchange'></a></span></p><p ><code class='itemdecl'>T exchange(T desired, memory_order order = memory_order_seq_cst) volatile noexcept;
T exchange(T desired, memory_order order = memory_order_seq_cst) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.operations-15'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-15'>15</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L780'>#</a></div><p ><span class='textit'>Effects:</span> Atomically replaces the value pointed to by <span class='texttt'>this</span>
with <span class='texttt'>desired</span>.
Memory is affected according to the value of <span class='texttt'>order</span>.
These operations are atomic read-modify-write operations (<a href='intro.multithread'>[intro.multithread]</a>).</p></div></div><div class='para' id='atomics.types.operations-16'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-16'>16</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L786'>#</a></div><p ><span class='textit'>Returns:</span> Atomically returns the value pointed to by <span class='texttt'>this</span> immediately before the effects.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:atomic_compare_exchange_weak'></a></span><span class='indexparent'><a class='index' id='lib:atomic_compare_exchange_strong'></a></span><span class='indexparent'><a class='index' id='lib:atomic_compare_exchange_weak_explicit'></a></span><span class='indexparent'><a class='index' id='lib:atomic_compare_exchange_strong_explicit'></a></span><span class='indexparent'><a class='index' id='lib:compare_exchange_weak,atomic'></a></span><span class='indexparent'><a class='index' id='lib:atomic,compare_exchange_weak'></a></span><span class='indexparent'><a class='index' id='lib:compare_exchange_weak,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,compare_exchange_weak'></a></span><span class='indexparent'><a class='index' id='lib:compare_exchange_weak,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,compare_exchange_weak'></a></span><span class='indexparent'><a class='index' id='lib:compare_exchange_strong,atomic'></a></span><span class='indexparent'><a class='index' id='lib:atomic,compare_exchange_strong'></a></span><span class='indexparent'><a class='index' id='lib:compare_exchange_strong,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,compare_exchange_strong'></a></span><span class='indexparent'><a class='index' id='lib:compare_exchange_strong,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,compare_exchange_strong'></a></span></p><p ><code class='itemdecl'>bool compare_exchange_weak(T&amp; expected, T desired,
                           memory_order success, memory_order failure) volatile noexcept;
bool compare_exchange_weak(T&amp; expected, T desired,
                           memory_order success, memory_order failure) noexcept;
bool compare_exchange_strong(T&amp; expected, T desired,
                             memory_order success, memory_order failure) volatile noexcept;
bool compare_exchange_strong(T&amp; expected, T desired,
                             memory_order success, memory_order failure) noexcept;
bool compare_exchange_weak(T&amp; expected, T desired,
                           memory_order order = memory_order_seq_cst) volatile noexcept;
bool compare_exchange_weak(T&amp; expected, T desired,
                           memory_order order = memory_order_seq_cst) noexcept;
bool compare_exchange_strong(T&amp; expected, T desired,
                             memory_order order = memory_order_seq_cst) volatile noexcept;
bool compare_exchange_strong(T&amp; expected, T desired,
                             memory_order order = memory_order_seq_cst) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.operations-17'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-17'>17</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L820'>#</a></div><p ><span class='textit'>Requires:</span> The <span class='texttt'>failure</span> argument shall not be <span class='texttt'>memory_&shy;order_&shy;release</span> nor
<span class='texttt'>memory_&shy;order_&shy;acq_&shy;rel</span>.</p></div></div><div class='para' id='atomics.types.operations-18'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-18'>18</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L824'>#</a></div><p ><span class='textit'>Effects:</span> Retrieves the value in <span class='texttt'>expected</span>. It then atomically
compares the contents of the memory pointed to by <span class='texttt'>this</span>
for equality with that previously retrieved from <span class='texttt'>expected</span>,
and if true, replaces the contents of the memory pointed to
by <span class='texttt'>this</span> with that in <span class='texttt'>desired</span>.
If and only if the comparison is true, memory is affected according to the
value of <span class='texttt'>success</span>, and if the comparison is false, memory is affected according
to the value of <span class='texttt'>failure</span>. When only one <span class='texttt'>memory_&shy;order</span> argument is
supplied, the value of <span class='texttt'>success</span> is <span class='texttt'>order</span>, and the value of
<span class='texttt'>failure</span> is <span class='texttt'>order</span> except that a value of <span class='texttt'>memory_&shy;order_&shy;acq_&shy;rel</span>
shall be replaced by the value <span class='texttt'>memory_&shy;order_&shy;acquire</span> and a value of
<span class='texttt'>memory_&shy;order_&shy;release</span> shall be replaced by the value
<span class='texttt'>memory_&shy;order_&shy;relaxed</span>.
If and only if the comparison is false then, after the atomic operation,
the contents of the memory in <span class='texttt'>expected</span> are replaced by the value
read from the memory pointed to by <span class='texttt'>this</span> during the atomic comparison.
If the operation returns <span class='texttt'>true</span>, these
operations are atomic read-modify-write
operations (<a href='intro.multithread'>[intro.multithread]</a>) on the memory
pointed to by <span class='texttt'>this</span>.
Otherwise, these operations are atomic load operations on that memory.</p></div></div><div class='para' id='atomics.types.operations-19'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-19'>19</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L847'>#</a></div><p ><span class='textit'>Returns:</span> The result of the comparison.</p></div></div><div class='para' id='atomics.types.operations-20'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-20'>20</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L850'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  For example, the effect of
<span class='texttt'>compare_&shy;exchange_&shy;strong</span> is
</p><pre class='codeblock'>
if (memcmp(this, &amp;expected, sizeof(*this)) == 0)
  memcpy(this, &amp;desired, sizeof(*this));
else
  memcpy(expected, this, sizeof(*this));</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>  The expected use of the compare-and-exchange operations is as follows. The
compare-and-exchange operations will update <span class='texttt'>expected</span> when another iteration of
the loop is needed.
</p><pre class='codeblock'>
expected = current.load();
do {
  desired = function(expected);
} while (!current.compare_exchange_weak(expected, desired));</pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] 
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Example:</span>  Because the expected value is updated only on failure,
code releasing the memory containing the <span class='texttt'>expected</span> value on success will work.
E.g. list head insertion will act atomically and would not introduce a
data race in the following code:
</p><pre class='codeblock'>
do {
  p-&gt;next = head; <span class='comment'>// make new list node point to the current head
</span>} while (!head.compare_exchange_weak(p-&gt;next, p)); <span class='comment'>// try to insert
</span></pre><p ><span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end example</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div></div><div class='para' id='atomics.types.operations-21'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-21'>21</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L881'>#</a></div><p >Implementations should ensure that weak compare-and-exchange operations do not
consistently return <span class='texttt'>false</span> unless either the atomic object has value
different from <span class='texttt'>expected</span> or there are concurrent modifications to the
atomic object.</p></div></div><div class='para' id='atomics.types.operations-22'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-22'>22</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L887'>#</a></div><p ><span class='textit'>Remarks:</span> 
A weak compare-and-exchange operation may fail spuriously. That is, even when
the contents of memory referred to by <span class='texttt'>expected</span> and <span class='texttt'>this</span> are
equal, it may return <span class='texttt'>false</span> and store back to <span class='texttt'>expected</span> the same memory
contents that were originally there.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  This
spurious failure enables implementation of compare-and-exchange on a broader class of
machines, e.g., load-locked store-conditional machines. A
consequence of spurious failure is that nearly all uses of weak compare-and-exchange
will be in a loop.</p><p >When a compare-and-exchange is in a loop, the weak version will yield better performance
on some platforms. When a weak compare-and-exchange would require a loop and a strong one
would not, the strong one is preferable.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div></div><div class='para' id='atomics.types.operations-23'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.operations-23'>23</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L904'>#</a></div><p >[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  The <span class='texttt'>memcpy</span> and <span class='texttt'>memcmp</span> semantics of the compare-and-exchange
operations may result in failed comparisons for values that compare equal with
<span class='texttt'>operator==</span> if the underlying type has padding bits, trap bits, or alternate
representations of the same value. Thus, <span class='texttt'>compare_&shy;exchange_&shy;strong</span> should be used
with extreme care. On the other hand, <span class='texttt'>compare_&shy;exchange_&shy;weak</span> should converge
rapidly. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] 
</p></div></div></div><div id='atomics.types.int'><h3 ><a class='secnum' href='#atomics.types.int' style='min-width:103pt'>32.6.2</a> Specializations for integers <a class='abbr_ref' href='atomics.types.int'>[atomics.types.int]</a></h3><p ><span class='indexparent'><a class='index' id='lib:atomic<integral>'></a></span></p><div class='para' id='atomics.types.int-1'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.int-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L916'>#</a></div><p >There are specializations of the <span class='texttt'>atomic</span>
template for the integral types
<span class='texttt'>char</span>,
<span class='texttt'>signed char</span>,
<span class='texttt'>unsigned char</span>,
<span class='texttt'>short</span>,
<span class='texttt'>unsigned short</span>,
<span class='texttt'>int</span>,
<span class='texttt'>unsigned int</span>,
<span class='texttt'>long</span>,
<span class='texttt'>unsigned long</span>,
<span class='texttt'>long long</span>,
<span class='texttt'>unsigned long long</span>,
<span class='texttt'>char16_&shy;t</span>,
<span class='texttt'>char32_&shy;t</span>,
<span class='texttt'>wchar_&shy;t</span>,
and any other types needed by the typedefs in the header <span class='texttt'>&lt;cstdint&gt;</span>.
For each such integral type <span class='texttt'><span class='textit'>integral</span></span>, the specialization
<span class='texttt'>atomic&lt;<span class='textit'>integral</span>&gt;</span> provides additional atomic operations appropriate to integral types.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span> 
For the specialization <span class='texttt'>atomic&lt;bool&gt;</span>, see <a href='atomics.types.generic'>[atomics.types.generic]</a>.
<span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p><pre class='codeblock'>
namespace std {
  template &lt;&gt; struct atomic&lt;<span class='textit'>integral</span>&gt; {
    using value_type = <span class='textit'>integral</span>;
    using difference_type = value_type;
    static constexpr bool is_always_lock_free = <span class='indexparent'><a class='index' id=':whether_a_given_atomic_type&#39;s_operations_are_always_lock_free__'></a></span><span class='textit'>implementation-defined</span>;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> load(memory_order = memory_order_seq_cst) const volatile noexcept;
    <span class='textit'>integral</span> load(memory_order = memory_order_seq_cst) const noexcept;
    operator <span class='textit'>integral</span>() const volatile noexcept;
    operator <span class='textit'>integral</span>() const noexcept;
    <span class='textit'>integral</span> exchange(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> exchange(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order, memory_order) noexcept;
    bool compare_exchange_strong(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                                 memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                                 memory_order, memory_order) noexcept;
    bool compare_exchange_weak(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(<span class='textit'>integral</span>&amp;, <span class='textit'>integral</span>,
                               memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_add(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_add(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_sub(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_sub(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_and(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_and(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_or(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_or(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;
    <span class='textit'>integral</span> fetch_xor(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) volatile noexcept;
    <span class='textit'>integral</span> fetch_xor(<span class='textit'>integral</span>, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(<span class='textit'>integral</span>) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    <span class='textit'>integral</span> operator=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator=(<span class='textit'>integral</span>) noexcept;

    <span class='textit'>integral</span> operator++(int) volatile noexcept;
    <span class='textit'>integral</span> operator++(int) noexcept;
    <span class='textit'>integral</span> operator--(int) volatile noexcept;
    <span class='textit'>integral</span> operator--(int) noexcept;
    <span class='textit'>integral</span> operator++() volatile noexcept;
    <span class='textit'>integral</span> operator++() noexcept;
    <span class='textit'>integral</span> operator--() volatile noexcept;
    <span class='textit'>integral</span> operator--() noexcept;
    <span class='textit'>integral</span> operator+=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator+=(<span class='textit'>integral</span>) noexcept;
    <span class='textit'>integral</span> operator-=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator-=(<span class='textit'>integral</span>) noexcept;
    <span class='textit'>integral</span> operator&amp;=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator&amp;=(<span class='textit'>integral</span>) noexcept;
    <span class='textit'>integral</span> operator|=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator|=(<span class='textit'>integral</span>) noexcept;
    <span class='textit'>integral</span> operator^=(<span class='textit'>integral</span>) volatile noexcept;
    <span class='textit'>integral</span> operator^=(<span class='textit'>integral</span>) noexcept;
  };
}</pre></div><div class='para' id='atomics.types.int-2'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.int-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1013'>#</a></div><p >The atomic integral specializations
are standard-layout structs.
They each have a trivial default constructor
and a trivial destructor.</p></div><div class='para' id='atomics.types.int-3'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.int-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1019'>#</a></div><p >Descriptions are provided below only for members that differ from the primary template.</p></div><div class='para' id='atomics.types.int-4'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.int-4'>4</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1022'>#</a></div><p >The following operations perform arithmetic computations. The key, operator, and computation correspondence is:</p><div class='numberedTable' id='tab:atomic.arithmetic.computations'>Table <a href='#tab:atomic.arithmetic.computations'>138</a> — Atomic arithmetic computations<br><table ><tr class='rowsep'><td class='left'>

<b><span class='texttt'><span class='textit'>key</span></span></b>   </td><td class='left'>
  <b>Op</b>                        </td><td class='left'>
  <b>Computation</b>               </td><td class='border left'>
<b><span class='texttt'><span class='textit'>key</span></span></b>   </td><td class='left'>
  <b>Op</b>                        </td><td class='left'>
  <b>Computation</b>  </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>add</span>       </td><td class='left'>
  <span class='texttt'>+</span>       </td><td class='left'>
  addition        </td><td class='border left'>
<span class='texttt'>sub</span>       </td><td class='left'>
  <span class='texttt'>-</span>       </td><td class='left'>
  subtraction     </td></tr><tr ><td class='left'>
<span class='texttt'>or</span>        </td><td class='left'>
  <span class='texttt'>|</span>       </td><td class='left'>
  bitwise inclusive or  </td><td class='border left'>
<span class='texttt'>xor</span>       </td><td class='left'>
  <span class='texttt'>^</span>        </td><td class='left'>
  bitwise exclusive or  </td></tr><tr ><td class='left'>
<span class='texttt'>and</span>       </td><td class='left'>
  <span class='texttt'>&amp;</span>      </td><td class='left'>
  bitwise and     </td><td class='border left'></td><td class='left'></td><td class='left'></td></tr></table></div><p ><span class='indexparent'><a class='index' id='lib:atomic_fetch_add'></a></span><span class='indexparent'><a class='index' id='lib:atomic_fetch_and'></a></span><span class='indexparent'><a class='index' id='lib:atomic_fetch_or'></a></span><span class='indexparent'><a class='index' id='lib:atomic_fetch_sub'></a></span><span class='indexparent'><a class='index' id='lib:atomic_fetch_xor'></a></span><span class='indexparent'><a class='index' id='lib:atomic_fetch_add_explicit'></a></span><span class='indexparent'><a class='index' id='lib:atomic_fetch_and_explicit'></a></span><span class='indexparent'><a class='index' id='lib:atomic_fetch_or_explicit'></a></span><span class='indexparent'><a class='index' id='lib:atomic_fetch_sub_explicit'></a></span><span class='indexparent'><a class='index' id='lib:atomic_fetch_xor_explicit'></a></span><span class='indexparent'><a class='index' id='lib:fetch_add,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,fetch_add'></a></span><span class='indexparent'><a class='index' id='lib:fetch_and,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,fetch_and'></a></span><span class='indexparent'><a class='index' id='lib:fetch_or,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,fetch_or'></a></span><span class='indexparent'><a class='index' id='lib:fetch_sub,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,fetch_sub'></a></span><span class='indexparent'><a class='index' id='lib:fetch_xor,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,fetch_xor'></a></span></p></div><p ><code class='itemdecl'>T fetch_<span class='textit'>key</span>(T operand, memory_order order = memory_order_seq_cst) volatile noexcept;
T fetch_<span class='textit'>key</span>(T operand, memory_order order = memory_order_seq_cst) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.int-5'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.int-5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1072'>#</a></div><p ><span class='textit'>Effects:</span> Atomically replaces the value pointed to by
<span class='texttt'>this</span> with the result of the computation applied to the
value pointed to by <span class='texttt'>this</span> and the given <span class='texttt'>operand</span>.
Memory is affected according to the value of <span class='texttt'>order</span>.
These operations are atomic read-modify-write operations (<a href='intro.multithread'>[intro.multithread]</a>).</p></div></div><div class='para' id='atomics.types.int-6'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.int-6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1079'>#</a></div><p ><span class='textit'>Returns:</span> Atomically, the value pointed to by <span class='texttt'>this</span> immediately before the effects.</p></div></div><div class='para' id='atomics.types.int-7'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.int-7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1082'>#</a></div><p ><span class='indexparent'><a class='index' id=':signed_integer_representation,two&#39;s_complement'></a></span><span class='textit'>Remarks:</span> For signed integer types, arithmetic is defined to use two's complement representation.
There are no undefined results.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:operator+=,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,operator+='></a></span><span class='indexparent'><a class='index' id='lib:operator-=,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,operator-='></a></span><span class='indexparent'><a class='index' id='lib:operator+=,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,operator+='></a></span><span class='indexparent'><a class='index' id='lib:operator-=,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,operator-='></a></span><span class='indexparent'><a class='index' id='lib:operator&=,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,operator&='></a></span><span class='indexparent'><a class='index' id='lib:operator|=,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,operator|='></a></span><span class='indexparent'><a class='index' id='lib:operator^=,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,operator^='></a></span></p><p ><code class='itemdecl'>T operator <span class='textit'>op</span>=(T operand) volatile noexcept;
T operator <span class='textit'>op</span>=(T operand) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.int-8'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.int-8'>8</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1101'>#</a></div><p ><span class='textit'>Effects:</span> Equivalent to: <span class='texttt'>return fetch_&shy;<span class='textit'>key</span>(operand) <span class='textit'>op</span> operand;</span>
</p></div></div></div><div id='atomics.types.pointer'><h3 ><a class='secnum' href='#atomics.types.pointer' style='min-width:103pt'>32.6.3</a> Partial specialization for pointers <a class='abbr_ref' href='atomics.types.pointer'>[atomics.types.pointer]</a></h3><p ><span class='indexparent'><a class='index' id='lib:atomic<T*>'></a></span>
</p><pre class='codeblock'>
namespace std {
  template &lt;class T&gt; struct atomic&lt;T*&gt; {
    using value_type = T*;
    using difference_type = ptrdiff_t;
    static constexpr bool is_always_lock_free = <span class='indexparent'><a class='index' id=':whether_a_given_atomic_type&#39;s_operations_are_always_lock_free___'></a></span><span class='textit'>implementation-defined</span>;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T*, memory_order = memory_order_seq_cst) volatile noexcept;
    void store(T*, memory_order = memory_order_seq_cst) noexcept;
    T* load(memory_order = memory_order_seq_cst) const volatile noexcept;
    T* load(memory_order = memory_order_seq_cst) const noexcept;
    operator T*() const volatile noexcept;
    operator T*() const noexcept;
    T* exchange(T*, memory_order = memory_order_seq_cst) volatile noexcept;
    T* exchange(T*, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order, memory_order) volatile noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order, memory_order) noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(T*&amp;, T*, memory_order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(T*&amp;, T*, memory_order = memory_order_seq_cst) noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;

    atomic() noexcept = default;
    constexpr atomic(T*) noexcept;
    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;
    T* operator=(T*) volatile noexcept;
    T* operator=(T*) noexcept;

    T* operator++(int) volatile noexcept;
    T* operator++(int) noexcept;
    T* operator--(int) volatile noexcept;
    T* operator--(int) noexcept;
    T* operator++() volatile noexcept;
    T* operator++() noexcept;
    T* operator--() volatile noexcept;
    T* operator--() noexcept;
    T* operator+=(ptrdiff_t) volatile noexcept;
    T* operator+=(ptrdiff_t) noexcept;
    T* operator-=(ptrdiff_t) volatile noexcept;
    T* operator-=(ptrdiff_t) noexcept;
  };
}</pre><p ><span class='indexparent'><a class='index' id='lib:atomic<T*>_'></a></span></p><div class='para' id='atomics.types.pointer-1'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.pointer-1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1162'>#</a></div><p >There is a partial specialization of the <span class='texttt'>atomic</span> class template for pointers.
Specializations of this partial specialization are standard-layout structs.
They each have a trivial default constructor and a trivial destructor.</p></div><div class='para' id='atomics.types.pointer-2'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.pointer-2'>2</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1167'>#</a></div><p >Descriptions are provided below only for members that differ from the primary template.</p></div><div class='para' id='atomics.types.pointer-3'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.pointer-3'>3</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1170'>#</a></div><p >The following operations perform pointer arithmetic. The key, operator,
and computation correspondence is:</p><div class='numberedTable' id='tab:atomic.pointer.computations'>Table <a href='#tab:atomic.pointer.computations'>139</a> — Atomic pointer computations<br><table ><tr class='rowsep'><td class='left'>

<span class='texttt'>Key</span>       </td><td class='left'>
  Op          </td><td class='left'>
  Computation     </td><td class='border left'>
<span class='texttt'>Key</span>       </td><td class='left'>
  Op          </td><td class='left'>
  Computation     </td></tr><tr class='rowsep'><td class='left'> 
<span class='texttt'>add</span>       </td><td class='left'>
  <span class='texttt'>+</span>       </td><td class='left'>
  addition        </td><td class='border left'>
<span class='texttt'>sub</span>       </td><td class='left'>
  <span class='texttt'>-</span>       </td><td class='left'>
  subtraction     </td></tr></table></div><p ><span class='indexparent'><a class='index' id='lib:atomic_fetch_add_'></a></span><span class='indexparent'><a class='index' id='lib:atomic_fetch_sub_'></a></span><span class='indexparent'><a class='index' id='lib:atomic_fetch_add_explicit_'></a></span><span class='indexparent'><a class='index' id='lib:atomic_fetch_sub_explicit_'></a></span><span class='indexparent'><a class='index' id='lib:fetch_add,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,fetch_add'></a></span><span class='indexparent'><a class='index' id='lib:fetch_sub,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,fetch_sub'></a></span></p></div><p ><code class='itemdecl'>T* fetch_<span class='textit'>key</span>(ptrdiff_t operand, memory_order order = memory_order_seq_cst) volatile noexcept;
T* fetch_<span class='textit'>key</span>(ptrdiff_t operand, memory_order order = memory_order_seq_cst) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.pointer-4'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.pointer-4'>4</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1203'>#</a></div><p ><span class='textit'>Requires:</span> T shall be an object type, otherwise the program is ill-formed.
[<span style='white-space:nowrap'>&thinsp;</span><span class='textit'>Note:</span>  Pointer arithmetic on <span class='texttt'>void*</span> or function pointers is ill-formed. <span class='textit'><span style='white-space:nowrap'>&thinsp;</span>—<span style='white-space:nowrap'>&thinsp;</span>end note</span><span style='white-space:nowrap'>&thinsp;</span>] </p></div></div><div class='para' id='atomics.types.pointer-5'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.pointer-5'>5</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1207'>#</a></div><p ><span class='textit'>Effects:</span> Atomically replaces the value pointed to by
<span class='texttt'>this</span> with the result of the computation applied to the
value pointed to by <span class='texttt'>this</span> and the given <span class='texttt'>operand</span>.
Memory is affected according to the value of <span class='texttt'>order</span>.
These operations are atomic read-modify-write operations (<a href='intro.multithread'>[intro.multithread]</a>).</p></div></div><div class='para' id='atomics.types.pointer-6'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.pointer-6'>6</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1214'>#</a></div><p ><span class='textit'>Returns:</span> Atomically, the value pointed to by <span class='texttt'>this</span> immediately before the effects.</p></div></div><div class='para' id='atomics.types.pointer-7'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.pointer-7'>7</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1217'>#</a></div><p ><span class='textit'>Remarks:</span> The result may be an undefined address,
but the operations otherwise have no undefined behavior.
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:operator+=,atomic<T*>_'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,operator+=_'></a></span><span class='indexparent'><a class='index' id='lib:operator-=,atomic<T*>_'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,operator-=_'></a></span></p><p ><code class='itemdecl'>T* operator <span class='textit'>op</span>=(ptrdiff_t operand) volatile noexcept;
T* operator <span class='textit'>op</span>=(ptrdiff_t operand) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.pointer-8'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.pointer-8'>8</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1230'>#</a></div><p ><span class='textit'>Effects:</span> Equivalent to: <span class='texttt'>return fetch_&shy;<span class='textit'>key</span>(operand) <span class='textit'>op</span> operand;</span>
</p></div></div></div><div id='atomics.types.memop'><h3 ><a class='secnum' href='#atomics.types.memop' style='min-width:103pt'>32.6.4</a> Member operators common to integers and pointers to objects <a class='abbr_ref' href='atomics.types.memop'>[atomics.types.memop]</a></h3><p ><span class='indexparent'><a class='index' id='lib:operator++,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,operator++'></a></span><span class='indexparent'><a class='index' id='lib:operator++,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,operator++'></a></span></p><p ><code class='itemdecl'>T operator++(int) volatile noexcept;
T operator++(int) noexcept;
</code></p><div class='itemdescr'><p ><span class='textit'>Effects:</span> Equivalent to: <span class='texttt'>return fetch_&shy;add(1);</span>
</p></div><p ><span class='indexparent'><a class='index' id='lib:operator--,atomic<T*>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,operator--'></a></span><span class='indexparent'><a class='index' id='lib:operator--,atomic<integral>'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,operator--'></a></span></p><p ><code class='itemdecl'>T operator--(int) volatile noexcept;
T operator--(int) noexcept;
</code></p><div class='itemdescr'><p ><span class='textit'>Effects:</span> Equivalent to: <span class='texttt'>return fetch_&shy;sub(1);</span>
</p></div><p ><span class='indexparent'><a class='index' id='lib:operator++,atomic<T*>_'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,operator++_'></a></span><span class='indexparent'><a class='index' id='lib:operator++,atomic<integral>_'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,operator++_'></a></span></p><p ><code class='itemdecl'>T operator++() volatile noexcept;
T operator++() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.memop-1'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.memop-1'>1</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1266'>#</a></div><p ><span class='textit'>Effects:</span> Equivalent to: <span class='texttt'>return fetch_&shy;add(1) + 1;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='lib:operator--,atomic<T*>_'></a></span><span class='indexparent'><a class='index' id='lib:atomic<T*>,operator--_'></a></span><span class='indexparent'><a class='index' id='lib:operator--,atomic<integral>_'></a></span><span class='indexparent'><a class='index' id='lib:atomic<integral>,operator--_'></a></span></p><p ><code class='itemdecl'>T operator--() volatile noexcept;
T operator--() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='atomics.types.memop-2'><div class='marginalizedparent'><a class='marginalized' href='#atomics.types.memop-2'>2</a></div><div class='itemdescr'><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/ae6271c88727c3fabe7dd8258f8687b369d83d6d/source/atomics.tex#L1278'>#</a></div><p ><span class='textit'>Effects:</span> Equivalent to: <span class='texttt'>return fetch_&shy;sub(1) - 1;</span>
</p></div></div></div></div></body></html>