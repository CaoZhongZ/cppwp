<!DOCTYPE html><html lang='en'><head><title>[func.bind]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>20</a> General utilities library <a class='abbr_ref' href='./#utilities'>[utilities]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>20.14</a> Function objects <a class='abbr_ref' href='function.objects#func.bind'>[function.objects]</a></h2><div id='func.bind'><h3 ><a class='secnum' style='min-width:103pt'>20.14.10</a> Function object binders <a class='abbr_ref'>[func.bind]</a></h3><p ><span class='indexparent'><a class='index' id='function_object,binders'></a></span></p><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >This subclause describes a uniform mechanism for binding
arguments of callable objects.</p></div><div id='isbind'><h4 ><a class='secnum' href='#isbind' style='min-width:118pt'>20.14.10.1</a> Class template <span class='texttt'>is_bind_expression</span> <a class='abbr_ref' href='func.bind.isbind'>[func.bind.isbind]</a></h4><p ><span class='indexparent'><a class='index' id='is_bind_expression'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; struct is_bind_expression; <span class='comment'>// see below
</span>}
</pre><div class='para' id='isbind-1'><div class='marginalizedparent'><a class='marginalized' href='#isbind-1'>1</a></div><p ><span class='texttt'>is_bind_expression</span> can be used to detect function objects
generated by <span class='texttt'>bind</span>. <span class='texttt'>bind</span>
uses <span class='texttt'>is_bind_expression</span> to detect subexpressions.</p></div><div class='para' id='isbind-2'><div class='marginalizedparent'><a class='marginalized' href='#isbind-2'>2</a></div><p >Instantiations of the <span class='texttt'>is_bind_expression</span> template shall meet
the UnaryTypeTrait requirements (<a href='meta.rqmts'>[meta.rqmts]</a>). The implementation
shall provide a definition that has a BaseCharacteristic of
<span class='texttt'>true_type</span> if <span class='texttt'>T</span> is a type returned from <span class='texttt'>bind</span>,
otherwise it shall have a BaseCharacteristic of <span class='texttt'>false_type</span>.
A program may specialize this template for a user-defined type <span class='texttt'>T</span>
to have a BaseCharacteristic of <span class='texttt'>true_type</span> to indicate that
<span class='texttt'>T</span> should be treated as a subexpression in a <span class='texttt'>bind</span> call.</p></div></div><div id='isplace'><h4 ><a class='secnum' href='#isplace' style='min-width:118pt'>20.14.10.2</a> Class template <span class='texttt'>is_placeholder</span> <a class='abbr_ref' href='func.bind.isplace'>[func.bind.isplace]</a></h4><p ><span class='indexparent'><a class='index' id='is_placeholder'></a></span></p><pre class='codeblock'>
namespace std {
  template&lt;class T&gt; struct is_placeholder; <span class='comment'>// see below
</span>}
</pre><div class='para' id='isplace-1'><div class='marginalizedparent'><a class='marginalized' href='#isplace-1'>1</a></div><p ><span class='texttt'>is_placeholder</span> can be used to detect the standard placeholders
<span class='texttt'>_1</span>, <span class='texttt'>_2</span>, and so on. <span class='texttt'>bind</span> uses
<span class='texttt'>is_placeholder</span> to detect placeholders.</p></div><div class='para' id='isplace-2'><div class='marginalizedparent'><a class='marginalized' href='#isplace-2'>2</a></div><p >Instantiations of the <span class='texttt'>is_placeholder</span> template shall meet
the UnaryTypeTrait requirements (<a href='meta.rqmts'>[meta.rqmts]</a>). The implementation
shall provide a definition that has the BaseCharacteristic of
<span class='texttt'>integral_constant&lt;int, J&gt;</span> if <span class='texttt'>T</span> is the type of
<span class='texttt'>std::placeholders::_J</span>, otherwise it shall have a
BaseCharacteristic of <span class='texttt'>integral_constant&lt;int, 0&gt;</span>. A program
may specialize this template for a user-defined type <span class='texttt'>T</span> to
have a BaseCharacteristic of <span class='texttt'>integral_constant&lt;int, <i>N</i>&gt;</span>
with <span class='texttt'><i>N</i> &gt; 0</span> to indicate that <span class='texttt'>T</span> should be
treated as a placeholder type.</p></div></div><div id='bind'><h4 ><a class='secnum' href='#bind' style='min-width:118pt'>20.14.10.3</a> Function template <span class='texttt'>bind</span> <a class='abbr_ref' href='func.bind.bind'>[func.bind.bind]</a></h4><p ><span class='indexparent'><a class='index' id='bind'></a></span></p><div class='para' id='bind-1'><div class='marginalizedparent'><a class='marginalized' href='#bind-1'>1</a></div><p >In the text that follows:</p><ul ><li ><p ><span class='texttt'>FD</span> is the type <span class='texttt'>decay_t&lt;F&gt;</span>,
</p></li><li ><p ><span class='texttt'>fd</span> is an lvalue of type <span class='texttt'>FD</span> constructed from <span class='texttt'>std::forward&lt;F&gt;(f)</span>,
</p></li><li ><p ><span class='texttt'>Ti</span> is the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> type in the template parameter pack <span class='texttt'>BoundArgs</span>,
</p></li><li ><p ><span class='texttt'>TiD</span> is the type <span class='texttt'>decay_t&lt;Ti&gt;</span>,
</p></li><li ><p ><span class='texttt'>ti</span> is the <span class='math'><span class='mathalpha'>i</span><sup ><span class='mathalpha'>th</span></sup></span> argument in the function parameter pack <span class='texttt'>bound_args</span>,
</p></li><li ><p ><span class='texttt'>tid</span> is an lvalue of type <span class='texttt'>TiD</span> constructed from <span class='texttt'>std::forward&lt;Ti&gt;(ti)</span>,
</p></li><li ><p ><span class='texttt'>Uj</span> is the <span class='math'><span class='mathalpha'>j</span><sup ><span class='mathalpha'>th</span></sup></span> deduced type of the <span class='texttt'>UnBoundArgs&amp;&amp;...</span> parameter
  of the forwarding call wrapper, and
</p></li><li ><p ><span class='texttt'>uj</span> is the <span class='math'><span class='mathalpha'>j</span><sup ><span class='mathalpha'>th</span></sup></span> argument associated with <span class='texttt'>Uj</span>.
</p></li></ul><p ><span class='indexparent'><a class='index' id='bind'></a></span><code class='itemdecl'>
template&lt;class F, class... BoundArgs&gt;
  <i><span class='texttt'>unspecified</span></i> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);
</code></p></div><div class='itemdescr'></div><div class='para' id='bind-2'><div class='marginalizedparent'><a class='marginalized' href='#bind-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>is_constructible_v&lt;FD, F&gt;</span> shall be <span class='texttt'>true</span>. For each <span class='texttt'>Ti</span>
in <span class='texttt'>BoundArgs</span>, <span class='texttt'>is_constructible_v&lt;TiD, Ti&gt;</span> shall be <span class='texttt'>true</span>.
<span class='texttt'><i>INVOKE</i> (fd, w1, w2, ...,
wN)</span> (<a href='func.require'>[func.require]</a>) shall be a valid expression for some
values <i>w1, w2, ..., wN</i>, where
<span class='texttt'>N == sizeof...(bound_args)</span>.
The cv-qualifiers <i>cv</i> of the call wrapper <span class='texttt'>g</span>,
as specified below, shall be neither <span class='texttt'>volatile</span> nor <span class='texttt'>const volatile</span>.</p></div></div><div class='para' id='bind-3'><div class='marginalizedparent'><a class='marginalized' href='#bind-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
A forwarding call wrapper <span class='texttt'>g</span> (<a href='func.require'>[func.require]</a>).
The effect of <span class='texttt'>g(u1, u2, ..., uM)</span> shall
be <span class='texttt'><i>INVOKE</i>(fd, std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ..., std::forward&lt;VN&gt;(vN))</span>,
where the values and types of the bound
arguments <span class='texttt'>v1, v2, ..., vN</span> are determined as specified below.
The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <span class='texttt'>FD</span> or of any of the types
<span class='texttt'>TiD</span> throws an exception.</p></div></div><div class='para' id='bind-4'><div class='marginalizedparent'><a class='marginalized' href='#bind-4'>4</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing unless the construction of
<span class='texttt'>fd</span> or of one of the values <span class='texttt'>tid</span> throws an exception.</p></div></div><div class='para' id='bind-5'><div class='marginalizedparent'><a class='marginalized' href='#bind-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> The return type shall satisfy the requirements of <span class='texttt'>MoveConstructible</span>. If all
of <span class='texttt'>FD</span> and <span class='texttt'>TiD</span> satisfy the requirements of <span class='texttt'>CopyConstructible</span>, then the
return type shall satisfy the requirements of <span class='texttt'>CopyConstructible</span>. [&nbsp;<i>Note:</i><span class='space'></span> This implies
that all of <span class='texttt'>FD</span> and <span class='texttt'>TiD</span> are <span class='texttt'>MoveConstructible</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
</p></div></div><p ><span class='indexparent'><a class='index' id='bind'></a></span><code class='itemdecl'>
template&lt;class R, class F, class... BoundArgs&gt;
  <i><span class='texttt'>unspecified</span></i> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);
</code></p><div class='itemdescr'></div><div class='para' id='bind-6'><div class='marginalizedparent'><a class='marginalized' href='#bind-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>is_constructible_v&lt;FD, F&gt;</span> shall be <span class='texttt'>true</span>. For each <span class='texttt'>Ti</span>
in <span class='texttt'>BoundArgs</span>, <span class='texttt'>is_constructible_v&lt;TiD, Ti&gt;</span> shall be <span class='texttt'>true</span>.
<span class='texttt'><i>INVOKE</i>(fd, w1, w2, ..., wN)</span> shall be  a valid
expression for some
values <i>w1, w2, ..., wN</i>, where
<span class='texttt'>N == sizeof...(bound_args)</span>.
The cv-qualifiers <i>cv</i> of the call wrapper <span class='texttt'>g</span>,
as specified below, shall be neither <span class='texttt'>volatile</span> nor <span class='texttt'>const volatile</span>.</p></div></div><div class='para' id='bind-7'><div class='marginalizedparent'><a class='marginalized' href='#bind-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
A forwarding call wrapper <span class='texttt'>g</span> (<a href='func.require'>[func.require]</a>).
The effect of
<span class='texttt'>g(u1, u2, ..., uM)</span> shall be <span class='texttt'><i>INVOKE</i>(fd,
std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ...,
std::forward&lt;VN&gt;(vN), R)</span>, where the values and types of the bound
arguments <span class='texttt'>v1, v2, ..., vN</span> are determined as specified below.
The copy constructor and move constructor of the forwarding call wrapper shall throw an
exception if and only if the corresponding constructor of <span class='texttt'>FD</span> or of any of the types
<span class='texttt'>TiD</span> throws an exception.</p></div></div><div class='para' id='bind-8'><div class='marginalizedparent'><a class='marginalized' href='#bind-8'>8</a></div><div class='itemdescr'><p ><i>Throws:</i> Nothing unless the construction of
<span class='texttt'>fd</span> or of one of the values <span class='texttt'>tid</span> throws an exception.</p></div></div><div class='para' id='bind-9'><div class='marginalizedparent'><a class='marginalized' href='#bind-9'>9</a></div><div class='itemdescr'><p ><i>Remarks:</i> The return type shall satisfy the requirements of <span class='texttt'>MoveConstructible</span>. If all
of <span class='texttt'>FD</span> and <span class='texttt'>TiD</span> satisfy the requirements of <span class='texttt'>CopyConstructible</span>, then the
return type shall satisfy the requirements of <span class='texttt'>CopyConstructible</span>. [&nbsp;<i>Note:</i><span class='space'></span> This implies
that all of <span class='texttt'>FD</span> and <span class='texttt'>TiD</span> are <span class='texttt'>MoveConstructible</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
</p></div></div><div class='para' id='bind-10'><div class='marginalizedparent'><a class='marginalized' href='#bind-10'>10</a></div><p ><span class='indexparent'><a class='index' id='bound_arguments'></a></span>The values of the <i>bound arguments</i> <span class='texttt'>v1, v2, ..., vN</span> and their
corresponding types <span class='texttt'>V1, V2, ..., VN</span> depend on the
types <span class='texttt'>TiD</span> derived from
the call to <span class='texttt'>bind</span> and the
cv-qualifiers <i>cv</i> of the call wrapper <span class='texttt'>g</span> as follows:</p><ul ><li ><p >if <span class='texttt'>TiD</span> is <span class='texttt'>reference_wrapper&lt;T&gt;</span>, the
argument is <span class='texttt'>tid.get()</span> and its type <span class='texttt'>Vi</span> is <span class='texttt'>T&amp;</span>;</p></li><li ><p >if the value of <span class='texttt'>is_bind_expression_v&lt;TiD&gt;</span>
is <span class='texttt'>true</span>, the argument is <span class='texttt'>tid(std::forward&lt;Uj&gt;(<span class='discretionary'></span>uj)...)</span>  and its
type <span class='texttt'>Vi</span> is
<span class='texttt'>result_of_t&lt;TiD <i>cv</i> &amp; (Uj&amp;&amp;...)&gt;&amp;&amp;</span>;</p></li><li ><p >if the value <span class='texttt'>j</span> of <span class='texttt'>is_placeholder_v&lt;TiD&gt;</span>
is not zero, the  argument is <span class='texttt'>std::forward&lt;Uj&gt;(uj)</span>
and its type <span class='texttt'>Vi</span>
is <span class='texttt'>Uj&amp;&amp;</span>;</p></li><li ><p >otherwise, the value is <span class='texttt'>tid</span> and its type <span class='texttt'>Vi</span>
is <span class='texttt'>TiD <i>cv</i> &amp;</span>.
</p></li></ul></div></div><div id='place'><h4 ><a class='secnum' href='#place' style='min-width:118pt'>20.14.10.4</a> Placeholders <a class='abbr_ref' href='func.bind.place'>[func.bind.place]</a></h4><p ><span class='indexparent'><a class='index' id='placeholders'></a></span><span class='indexparent'><a class='index' id='1'></a></span></p><pre class='codeblock'>
namespace std::placeholders {
  <span class='comment'>// M is the <span class='indexparent'><a class='index' id='number_of_placeholders_for_bind_expressions'></a></span>implementation-defined number of placeholders
</span>  <i><span class='texttt'>see below</span></i> _1;
  <i><span class='texttt'>see below</span></i> _2;
              .
              .
              .
  <i><span class='texttt'>see below</span></i> _M;
}
</pre><div class='para' id='place-1'><div class='marginalizedparent'><a class='marginalized' href='#place-1'>1</a></div><p >All placeholder types shall be <span class='texttt'>DefaultConstructible</span> and
<span class='texttt'>CopyConstructible</span>, and their default constructors and copy/move
constructors shall not throw exceptions. It is <span class='indexparent'><a class='index' id='assignability_of_placeholder_objects'></a></span>implementation-defined whether
placeholder types are <span class='texttt'>CopyAssignable</span>. <span class='texttt'>CopyAssignable</span> placeholders' copy
assignment operators shall not throw exceptions.<span class='indexparent'><a class='index' id='bind'></a></span><span class='indexparent'><a class='index' id='function_object,binders'></a></span></p></div><div class='para' id='place-2'><div class='marginalizedparent'><a class='marginalized' href='#place-2'>2</a></div><p >Placeholders should be defined as:
</p><pre class='codeblock'>
constexpr <i><span class='texttt'>unspecified</span></i> _1{};
</pre><p >If they are not, they shall be declared as:
</p><pre class='codeblock'>
extern <i><span class='texttt'>unspecified</span></i> _1;
</pre></div></div></div></div></body></html>