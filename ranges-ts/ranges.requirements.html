<!DOCTYPE html><html lang='en'><head><title>[ranges.requirements]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>9</a> Iterators library <a class='abbr_ref' href='./#iterators'>[iterators]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>9.9</a> Range concepts <a class='abbr_ref' href='ranges#requirements'>[ranges]</a></h2><div id='ranges.requirements'><h3 ><a class='secnum' style='min-width:103pt'>9.9.2</a> Range requirements <a class='abbr_ref'>[ranges.requirements]</a></h3><div id='general'><h4 ><a class='secnum' href='#general' style='min-width:118pt'>9.9.2.1</a> In general <a class='abbr_ref' href='ranges.requirements.general'>[ranges.requirements.general]</a></h4><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p >Ranges are an abstraction of containers that allow a C++ program to
operate on elements of data structures uniformly. It their simplest form, a
range object is one on which one can call <span class='texttt'>begin</span> and
<span class='texttt'>end</span> to get an iterator (<a href='iterators.iterator'>[iterators.iterator]</a>) and a
sentinel (<a href='iterators.sentinel'>[iterators.sentinel]</a>). To be able to construct
template algorithms and range adaptors that work correctly and efficiently on
different types of sequences, the library formalizes not just the interfaces but
also the semantics and complexity assumptions of ranges.</p></div><div class='para' id='general-2'><div class='marginalizedparent'><a class='marginalized' href='#general-2'>2</a></div><p >This document defines three fundamental categories of ranges
based on the syntax and semantics supported by each: <i>range</i>,
<i>sized range</i> and <i>view</i>, as shown in
Table <a href='#tab:ranges.relations'>[tab:ranges.relations]</a>.</p><div class='numberedTable' id='tab:ranges.relations'>Table <a href='#tab:ranges.relations'>10</a> — Relations among range categories<br><table ><tr class='rowsep'><td class='left'>


  
  <b>Sized Range</b>  </td><td class='left'>               </td><td class='left'>                   </td></tr><tr ><td class='left'>
                        </td><td class='left'> <span class='math'>&#x2198;</span>    </td><td class='left'>                   </td></tr><tr ><td class='left'>
                        </td><td class='left'>               </td><td class='left'>  <b>Range</b>   </td></tr><tr ><td class='left'>
                        </td><td class='left'> <span class='math'>&#x2197;</span>    </td><td class='left'>                   </td></tr><tr ><td class='left'>
  <b>View</b>         </td><td class='left'>               </td><td class='left'>                   </td></tr></table></div></div><div class='para' id='general-3'><div class='marginalizedparent'><a class='marginalized' href='#general-3'>3</a></div><p >The <span class='texttt'>Range</span> concept requires only that <span class='texttt'>begin</span> and <span class='texttt'>end</span>
return an iterator and a sentinel. The <span class='texttt'>SizedRange</span> concept refines <span class='texttt'>Range</span>
with the requirement that the number of elements in the range can be determined
in constant time using the <span class='texttt'>size</span> function. The <span class='texttt'>View</span> concept
specifies requirements on an <span class='texttt'>Range</span> type
with constant-time copy and assign operations.</p></div><div class='para' id='general-4'><div class='marginalizedparent'><a class='marginalized' href='#general-4'>4</a></div><p >In addition to the three fundamental range categories, this document defines
a number of convenience refinements of <span class='texttt'>Range</span> that group together requirements
that appear often in the concepts, algorithms, and range adaptors.
<i>Bounded ranges</i> are ranges for which <span class='texttt'>begin</span> and <span class='texttt'>end</span> return objects of the
same type. <i>Random access ranges</i> are ranges for which
<span class='texttt'>begin</span> returns a type that satisfies
<span class='texttt'>RandomAccessIterator</span> (<a href='iterators.random.access'>[iterators.random.access]</a>). The range
categories <i>bidirectional ranges</i>,
<i>forward ranges</i>,
<i>input ranges</i>, and
<i>output ranges</i> are defined similarly.</p></div></div><div id='ranges.range'><h4 ><a class='secnum' href='#ranges.range' style='min-width:118pt'>9.9.2.2</a> Ranges <a class='abbr_ref' href='ranges.range'>[ranges.range]</a></h4><div class='para' id='ranges.range-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.range-1'>1</a></div><p >The <span class='texttt'>Range</span> concept defines the requirements of a type that allows
iteration over its elements by providing a <span class='texttt'>begin</span> iterator and an
<span class='texttt'>end</span> sentinel.
[&nbsp;<i>Note:</i> Most algorithms requiring this concept simply forward to an
<span class='texttt'>Iterator</span>-based algorithm by calling <span class='texttt'>begin</span> and <span class='texttt'>end</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><code class='itemdecl'>
template &lt;class T&gt;
using iterator_t = decltype(ranges::begin(declval&lt;T&amp;&gt;()));

template &lt;class T&gt;
using sentinel_t = decltype(ranges::end(declval&lt;T&amp;&gt;()));

template &lt;class T&gt;
concept bool Range() {
  return requires(T&amp;&amp; t) {
    ranges::end(t);
  };
}
</code></p></div><div class='itemdescr'></div><div class='para' id='ranges.range-2'><div class='marginalizedparent'><a class='marginalized' href='#ranges.range-2'>2</a></div><div class='itemdescr'><p >Given an lvalue <span class='texttt'>t</span> of type <span class='texttt'>remove_reference_t&lt;T&gt;</span>, <span class='texttt'>Range&lt;T&gt;()</span> is satisfied
if and only if</p><ul class='itemize'><li id='ranges.range-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.range-2.1'>(2.1)</a></div><p ><span class='texttt'>[begin(t),end(t))</span> denotes a range.</p></li><li id='ranges.range-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.range-2.2'>(2.2)</a></div><p >Both <span class='texttt'>begin(t)</span> and <span class='texttt'>end(t)</span> are amortized constant time
and non-modifying. [&nbsp;<i>Note:</i> <span class='texttt'>begin(t)</span> and <span class='texttt'>end(t)</span> do not require
implicit expression variants. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></li><li id='ranges.range-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.range-2.3'>(2.3)</a></div><p >If <span class='texttt'>iterator_t&lt;T&gt;</span> satisfies <span class='texttt'>ForwardIterator</span>,
<span class='texttt'>begin(t)</span> is equality preserving.
</p></li></ul></div></div><div class='para' id='ranges.range-3'><div class='marginalizedparent'><a class='marginalized' href='#ranges.range-3'>3</a></div><p >[&nbsp;<i>Note:</i>
Equality preservation of both <span class='texttt'>begin</span> and <span class='texttt'>end</span> enables passing a <span class='texttt'>Range</span>
whose iterator type satisfies <span class='texttt'>ForwardIterator</span>
to multiple algorithms and
making multiple passes over the range by repeated calls to <span class='texttt'>begin</span> and <span class='texttt'>end</span>.
Since <span class='texttt'>begin</span> is not required to be equality preserving when the return type does
not satisfy <span class='texttt'>ForwardIterator</span>, repeated calls might not return equal values or
might not be well-defined; <span class='texttt'>begin</span> should be called at most once for such a range.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='ranges.sized'><h4 ><a class='secnum' href='#ranges.sized' style='min-width:118pt'>9.9.2.3</a> Sized ranges <a class='abbr_ref' href='ranges.sized'>[ranges.sized]</a></h4><div class='para' id='ranges.sized-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.sized-1'>1</a></div><p >The <span class='texttt'>SizedRange</span> concept specifies the requirements
of a <span class='texttt'>Range</span> type that knows its size in constant time with the
<span class='texttt'>size</span> function.</p><p ><code class='itemdecl'>
template &lt;class&gt;
constexpr bool disable_sized_range = false;

template &lt;class T&gt;
concept bool SizedRange() {
  return Range&lt;T&gt;() &amp;&amp;
    !disable_sized_range&lt;remove_cv_t&lt;remove_reference_t&lt;T&gt;&gt;&gt; &amp;&amp;
    requires(const remove_reference_t&lt;T&gt;&amp; t) {
      { ranges::size(t) } -&gt; ConvertibleTo&lt;difference_type_t&lt;iterator_t&lt;T&gt;&gt;&gt;;
    };
}
</code></p></div><div class='itemdescr'></div><div class='para' id='ranges.sized-2'><div class='marginalizedparent'><a class='marginalized' href='#ranges.sized-2'>2</a></div><div class='itemdescr'><p >Given an lvalue <span class='texttt'>t</span> of type <span class='texttt'>remove_reference_t&lt;T&gt;</span>, <span class='texttt'>SizedRange&lt;T&gt;()</span> is satisfied if and only if:</p><ul class='itemize'><li id='ranges.sized-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.sized-2.1'>(2.1)</a></div><p ><span class='texttt'>size(t)</span> returns the number of elements in <span class='texttt'>t</span>.
</p></li><li id='ranges.sized-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.sized-2.2'>(2.2)</a></div><p >If <span class='texttt'>iterator_t&lt;T&gt;</span> satisfies <span class='texttt'>ForwardIterator</span>,
<span class='texttt'>size(t)</span> is well-defined regardless of the evaluation of
<span class='texttt'>begin(t)</span>. [&nbsp;<i>Note:</i> <span class='texttt'>size(t)</span> is otherwise not required be
well-defined after evaluating <span class='texttt'>begin(t)</span>. For a <span class='texttt'>SizedRange</span>
whose iterator type does not model <span class='texttt'>ForwardIterator</span>, for
example, <span class='texttt'>size(t)</span> might only be well-defined if evaluated before
the first call to <span class='texttt'>begin(t)</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li></ul></div></div><div class='para' id='ranges.sized-3'><div class='marginalizedparent'><a class='marginalized' href='#ranges.sized-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The <span class='texttt'>disable_sized_range</span> predicate provides a mechanism to enable use
of range types with the library that meet the syntactic requirements but do
not in fact satisfy <span class='texttt'>SizedRange</span>. A program that instantiates a library template
that requires a <span class='texttt'>Range</span> with such a range type <span class='texttt'>R</span> is ill-formed with no
diagnostic required unless
<span class='texttt'>disable_sized_range&lt;remove_cv_t&lt;remove_reference_t&lt;R&gt;&gt;&gt;</span> evaluates
to <span class='texttt'>true</span> (<a href='structure.requirements'>[structure.requirements]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='ranges.view'><h4 ><a class='secnum' href='#ranges.view' style='min-width:118pt'>9.9.2.4</a> Views <a class='abbr_ref' href='ranges.view'>[ranges.view]</a></h4><div class='para' id='ranges.view-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.view-1'>1</a></div><p >The <span class='texttt'>View</span> concept specifies the requirements of a
<span class='texttt'>Range</span> type that has constant time copy, move and assignment operators; that
is, the cost of these operations is not proportional to the number of elements in
the <span class='texttt'>View</span>.</p></div><div class='para' id='ranges.view-2'><div class='marginalizedparent'><a class='marginalized' href='#ranges.view-2'>2</a></div><p >[&nbsp;<i>Example:</i>
Examples of <span class='texttt'>View</span>s are:</p><ul class='itemize'><li id='ranges.view-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-2.1'>(2.1)</a></div><p >A <span class='texttt'>Range</span> type that wraps a pair of iterators.</p></li><li id='ranges.view-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-2.2'>(2.2)</a></div><p >A <span class='texttt'>Range</span> type that holds its elements by <span class='texttt'>shared_ptr</span>
and shares ownership with all its copies.</p></li><li id='ranges.view-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-2.3'>(2.3)</a></div><p >A <span class='texttt'>Range</span> type that generates its elements on demand.
</p></li></ul><p >A container (  ISO/IEC 14882:2014 &sect;<a href='../n4140/containers'>[containers]</a>) is not a <span class='texttt'>View</span> since copying the
container copies the elements, which cannot be done in constant time.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]</p><p ><code class='itemdecl'>
template &lt;class T&gt;
struct enable_view { };

struct view_base { };

<span class='comment'>// <i>exposition only</i>
</span>template &lt;class T&gt;
constexpr bool __view_predicate = <i><span class='texttt'>see below</span></i>;

template &lt;class T&gt;
concept bool View() {
  return Range&lt;T&gt;() &amp;&amp;
    Semiregular&lt;T&gt;() &amp;&amp;
    __view_predicate&lt;T&gt;;
}
</code></p></div><div class='itemdescr'></div><div class='para' id='ranges.view-3'><div class='marginalizedparent'><a class='marginalized' href='#ranges.view-3'>3</a></div><div class='itemdescr'><p >Since the difference between <span class='texttt'>Range</span> and <span class='texttt'>View</span> is largely semantic, the
two are differentiated with the help of the <span class='texttt'>enable_view</span>
trait. Users may specialize <span class='texttt'>enable_view</span>
to derive from <span class='texttt'>true_type</span> or <span class='texttt'>false_type</span>.</p></div></div><div class='para' id='ranges.view-4'><div class='marginalizedparent'><a class='marginalized' href='#ranges.view-4'>4</a></div><div class='itemdescr'><p >For a type <span class='texttt'>T</span>, the value of <span class='texttt'>__view_predicate&lt;T&gt;</span> shall be:
</p><ul class='itemize'><li id='ranges.view-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-4.1'>(4.1)</a></div><p >If <span class='texttt'>enable_view&lt;T&gt;</span> has a member type <span class='texttt'>type</span>, <span class='texttt'>enable_view&lt;T&gt;::type::value</span>;
</p></li><li id='ranges.view-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-4.2'>(4.2)</a></div><p >Otherwise, if <span class='texttt'>T</span> is derived from <span class='texttt'>view_base</span>, <span class='texttt'>true</span>;
</p></li><li id='ranges.view-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-4.3'>(4.3)</a></div><p >Otherwise, if <span class='texttt'>T</span> is an instantiation of class template
<span class='texttt'>initializer_list</span> (  ISO/IEC 14882:2014 &sect;<a href='../n4140/support.initlist'>[support.initlist]</a>),
<span class='texttt'>set</span> (  ISO/IEC 14882:2014 &sect;<a href='../n4140/set'>[set]</a>),
<span class='texttt'>multiset</span> (  ISO/IEC 14882:2014 &sect;<a href='../n4140/multiset'>[multiset]</a>),
<span class='texttt'>unordered_set</span> (  ISO/IEC 14882:2014 &sect;<a href='../n4140/unord.set'>[unord.set]</a>), or
<span class='texttt'>unordered_multiset</span> (  ISO/IEC 14882:2014 &sect;<a href='../n4140/unord.multiset'>[unord.multiset]</a>), <span class='texttt'>false</span>;
</p></li><li id='ranges.view-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-4.4'>(4.4)</a></div><p >Otherwise, if both <span class='texttt'>T</span> and <span class='texttt'>const T</span> satisfy <span class='texttt'>Range</span> and <span class='texttt'>reference_t</span>
<span class='texttt'>&lt;iterator_t&lt;T&gt;&gt;</span> is not the same type as <span class='texttt'>reference_t</span>
<span class='texttt'>&lt;iterator_t&lt;const T&gt;&gt;</span>,
<span class='texttt'>false</span>; [&nbsp;<i>Note:</i> Deep <span class='texttt'>const</span>-ness implies element ownership, whereas shallow <span class='texttt'>const</span>-ness
implies reference semantics. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></li><li id='ranges.view-4.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-4.5'>(4.5)</a></div><p >Otherwise, <span class='texttt'>true</span>.
</p></li></ul></div></div></div><div id='ranges.bounded'><h4 ><a class='secnum' href='#ranges.bounded' style='min-width:118pt'>9.9.2.5</a> Bounded ranges <a class='abbr_ref' href='ranges.bounded'>[ranges.bounded]</a></h4><div class='para' id='ranges.bounded-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.bounded-1'>1</a></div><p >The <span class='texttt'>BoundedRange</span> concept specifies requirements
of an <span class='texttt'>Range</span> type for which <span class='texttt'>begin</span> and <span class='texttt'>end</span> return objects of
the same type. [&nbsp;<i>Note:</i> The standard containers (  ISO/IEC 14882:2014 &sect;<a href='../n4140/containers'>[containers]</a>)
satisfy <span class='texttt'>BoundedRange</span>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><pre class='codeblock'>
template &lt;class T&gt;
concept bool BoundedRange() {
  return Range&lt;T&gt;() &amp;&amp; Same&lt;iterator_t&lt;T&gt;, sentinel_t&lt;T&gt;&gt;();
}
</pre></div></div><div id='ranges.input'><h4 ><a class='secnum' href='#ranges.input' style='min-width:118pt'>9.9.2.6</a> Input ranges <a class='abbr_ref' href='ranges.input'>[ranges.input]</a></h4><div class='para' id='ranges.input-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.input-1'>1</a></div><p >The <span class='texttt'>InputRange</span> concept specifies requirements of
an <span class='texttt'>Range</span> type for which <span class='texttt'>begin</span> returns a type
that satisfies <span class='texttt'>InputIterator</span> (<a href='iterators.input'>[iterators.input]</a>).</p><pre class='codeblock'>
template &lt;class T&gt;
concept bool InputRange() {
  return Range&lt;T&gt;() &amp;&amp; InputIterator&lt;iterator_t&lt;T&gt;&gt;();
}
</pre></div></div><div id='ranges.output'><h4 ><a class='secnum' href='#ranges.output' style='min-width:118pt'>9.9.2.7</a> Output ranges <a class='abbr_ref' href='ranges.output'>[ranges.output]</a></h4><div class='para' id='ranges.output-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.output-1'>1</a></div><p >The <span class='texttt'>OutputRange</span> concept specifies requirements of
an <span class='texttt'>Range</span> type for which <span class='texttt'>begin</span> returns a type that satisfies
<span class='texttt'>OutputIterator</span> (<a href='iterators.output'>[iterators.output]</a>).</p><pre class='codeblock'>
template &lt;class R, class T&gt;
concept bool OutputRange() {
  return Range&lt;R&gt;() &amp;&amp; OutputIterator&lt;iterator_t&lt;R&gt;, T&gt;();
}
</pre></div></div><div id='ranges.forward'><h4 ><a class='secnum' href='#ranges.forward' style='min-width:118pt'>9.9.2.8</a> Forward ranges <a class='abbr_ref' href='ranges.forward'>[ranges.forward]</a></h4><div class='para' id='ranges.forward-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.forward-1'>1</a></div><p >The <span class='texttt'>ForwardRange</span> concept specifies requirements of an
<span class='texttt'>InputRange</span> type for which <span class='texttt'>begin</span> returns a type that satisfies
<span class='texttt'>ForwardIterator</span> (<a href='iterators.forward'>[iterators.forward]</a>).</p><pre class='codeblock'>
template &lt;class T&gt;
concept bool ForwardRange() {
  return InputRange&lt;T&gt;() &amp;&amp; ForwardIterator&lt;iterator_t&lt;T&gt;&gt;();
}
</pre></div></div><div id='ranges.bidirectional'><h4 ><a class='secnum' href='#ranges.bidirectional' style='min-width:118pt'>9.9.2.9</a> Bidirectional ranges <a class='abbr_ref' href='ranges.bidirectional'>[ranges.bidirectional]</a></h4><div class='para' id='ranges.bidirectional-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.bidirectional-1'>1</a></div><p >The <span class='texttt'>BidirectionalRange</span> concept specifies requirements of a
<span class='texttt'>ForwardRange</span> type for which <span class='texttt'>begin</span> returns a type that satisfies
<span class='texttt'>BidirectionalIterator</span> (<a href='iterators.bidirectional'>[iterators.bidirectional]</a>).</p><pre class='codeblock'>
template &lt;class T&gt;
concept bool BidirectionalRange() {
  return ForwardRange&lt;T&gt;() &amp;&amp; BidirectionalIterator&lt;iterator_t&lt;T&gt;&gt;();
}
</pre></div></div><div id='ranges.random.access'><h4 ><a class='secnum' href='#ranges.random.access' style='min-width:118pt'>9.9.2.10</a> Random access ranges <a class='abbr_ref' href='ranges.random.access'>[ranges.random.access]</a></h4><div class='para' id='ranges.random.access-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.random.access-1'>1</a></div><p >The <span class='texttt'>RandomAccessRange</span> concept specifies requirements of a
<span class='texttt'>BidirectionalRange</span> type for which <span class='texttt'>begin</span> returns a type that satisfies
<span class='texttt'>RandomAccessIterator</span> (<a href='iterators.random.access'>[iterators.random.access]</a>).</p><pre class='codeblock'>
template &lt;class T&gt;
concept bool RandomAccessRange() {
  return BidirectionalRange&lt;T&gt;() &amp;&amp; RandomAccessIterator&lt;iterator_t&lt;T&gt;&gt;();
}
</pre></div></div></div></div></body></html>