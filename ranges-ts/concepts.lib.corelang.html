<!DOCTYPE html><html lang='en'><head><title>[concepts.lib.corelang]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Concepts library <a class='abbr_ref' href='./#concepts.lib'>[concepts.lib]</a></h1><div id='concepts.lib.corelang'><h2 ><a class='secnum' style='min-width:88pt'>7.3</a> Core language concepts <a class='abbr_ref'>[concepts.lib.corelang]</a></h2><div id='general'><h3 ><a class='secnum' href='#general' style='min-width:103pt'>7.3.1</a> In general <a class='abbr_ref' href='concepts.lib.corelang.general'>[concepts.lib.corelang.general]</a></h3><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p >This section contains the definition of concepts corresponding to language features.
These concepts express relationships between types, type classifications, and
fundamental type properties.</p></div></div><div id='same'><h3 ><a class='secnum' href='#same' style='min-width:103pt'>7.3.2</a> Concept <span class='texttt'>Same</span> <a class='abbr_ref' href='concepts.lib.corelang.same'>[concepts.lib.corelang.same]</a></h3><p ><span class='indexparent'><a class='index' id='Same'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool Same() {
  return <i><span class='texttt'>see below</span></i>;
}
</code></p><div class='itemdescr'></div><div class='para' id='same-1'><div class='marginalizedparent'><a class='marginalized' href='#same-1'>1</a></div><div class='itemdescr'><p ><span class='texttt'>Same&lt;T, U&gt;()</span> is satisfied if and
only if <span class='texttt'>T</span> and <span class='texttt'>U</span> denote the same type.</p></div></div><div class='para' id='same-2'><div class='marginalizedparent'><a class='marginalized' href='#same-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> For the purposes of constraint checking, <span class='texttt'>Same&lt;T, U&gt;()</span> implies
<span class='texttt'>Same&lt;U, T&gt;()</span>.
</p></div></div></div><div id='derived'><h3 ><a class='secnum' href='#derived' style='min-width:103pt'>7.3.3</a> Concept <span class='texttt'>DerivedFrom</span> <a class='abbr_ref' href='concepts.lib.corelang.derived'>[concepts.lib.corelang.derived]</a></h3><p ><span class='indexparent'><a class='index' id='DerivedFrom'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool DerivedFrom() {
  return <i><span class='texttt'>see below</span></i>;
}
</code></p><div class='itemdescr'></div><div class='para' id='derived-1'><div class='marginalizedparent'><a class='marginalized' href='#derived-1'>1</a></div><div class='itemdescr'><p ><span class='texttt'>DerivedFrom&lt;T, U&gt;()</span> is satisfied if and only if
<span class='texttt'>is_base_of&lt;U, T&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='convertibleto'><h3 ><a class='secnum' href='#convertibleto' style='min-width:103pt'>7.3.4</a> Concept <span class='texttt'>ConvertibleTo</span> <a class='abbr_ref' href='concepts.lib.corelang.convertibleto'>[concepts.lib.corelang.convertibleto]</a></h3><p ><span class='indexparent'><a class='index' id='ConvertibleTo'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool ConvertibleTo() {
  return <i><span class='texttt'>see below</span></i>;
}
</code></p><div class='itemdescr'></div><div class='para' id='convertibleto-1'><div class='marginalizedparent'><a class='marginalized' href='#convertibleto-1'>1</a></div><div class='itemdescr'><p ><span class='texttt'>ConvertibleTo&lt;T, U&gt;()</span> is satisfied
if and only if <span class='texttt'>is_convertible&lt;T, U&gt;::value</span> is <span class='texttt'>true</span>.
</p></div></div></div><div id='commonref'><h3 ><a class='secnum' href='#commonref' style='min-width:103pt'>7.3.5</a> Concept <span class='texttt'>CommonReference</span> <a class='abbr_ref' href='concepts.lib.corelang.commonref'>[concepts.lib.corelang.commonref]</a></h3><div class='para' id='commonref-1'><div class='marginalizedparent'><a class='marginalized' href='#commonref-1'>1</a></div><p >For two types <span class='texttt'>T</span> and <span class='texttt'>U</span>, if <span class='texttt'>common_reference_t&lt;T, U&gt;</span>
is well-formed and denotes a type <span class='texttt'>C</span> such that both
<span class='texttt'>ConvertibleTo&lt;T, C&gt;()</span> and <span class='texttt'>ConvertibleTo&lt;U, C&gt;()</span> are
satisfied, then <span class='texttt'>T</span> and <span class='texttt'>U</span> share a <i>common reference
type</i>, <span class='texttt'>C</span>. [&nbsp;<i>Note:</i> <span class='texttt'>C</span> could be the same as <span class='texttt'>T</span>, or
<span class='texttt'>U</span>, or it could be a different type. <span class='texttt'>C</span> may be a reference
type. <span class='texttt'>C</span> need not be unique.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='CommonReference'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool CommonReference() {
  return requires(T (&amp;t)(), U (&amp;u)()) {
    typename common_reference_t&lt;T, U&gt;;
    typename common_reference_t&lt;U, T&gt;;
    requires Same&lt;common_reference_t&lt;T, U&gt;,
                  common_reference_t&lt;U, T&gt;&gt;();
    common_reference_t&lt;T, U&gt;(t());
    common_reference_t&lt;T, U&gt;(u());
  };
}
</code></p></div><div class='itemdescr'></div><div class='para' id='commonref-2'><div class='marginalizedparent'><a class='marginalized' href='#commonref-2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'>C</span> be <span class='texttt'>common_reference_t&lt;T, U&gt;</span>. Let <span class='texttt'>t</span> be a
function whose return type is <span class='texttt'>T</span>, and let <span class='texttt'>u</span> be a function
whose return type is <span class='texttt'>U</span>. <span class='texttt'>CommonReference&lt;T, U&gt;()</span> is satisfied
if and only if:
</p><ul class='itemize'><li id='commonref-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#commonref-2.1'>(2.1)</a></div><p ><span class='texttt'>C(t())</span> equals <span class='texttt'>C(t())</span> if and only if <span class='texttt'>t()</span> is an
  equality preserving expression (<a href='concepts.lib.general.equality'>[concepts.lib.general.equality]</a>).
</p></li><li id='commonref-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#commonref-2.2'>(2.2)</a></div><p ><span class='texttt'>C(u())</span> equals <span class='texttt'>C(u())</span> if and only if <span class='texttt'>u()</span> is an
  equality preserving expression.
</p></li></ul></div></div><div class='para' id='commonref-3'><div class='marginalizedparent'><a class='marginalized' href='#commonref-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Users can customize the behavior of <span class='texttt'>CommonReference</span> by specializing the
<span class='texttt'>basic_common_reference</span> class template (<a href='meta.trans.other'>[meta.trans.other]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='common'><h3 ><a class='secnum' href='#common' style='min-width:103pt'>7.3.6</a> Concept <span class='texttt'>Common</span> <a class='abbr_ref' href='concepts.lib.corelang.common'>[concepts.lib.corelang.common]</a></h3><div class='para' id='common-1'><div class='marginalizedparent'><a class='marginalized' href='#common-1'>1</a></div><p >If <span class='texttt'>T</span> and <span class='texttt'>U</span> can both be explicitly converted to some third type,
<span class='texttt'>C</span>, then <span class='texttt'>T</span> and <span class='texttt'>U</span> share a <i>common type</i>,
<span class='texttt'>C</span>. [&nbsp;<i>Note:</i> <span class='texttt'>C</span> could be the same as <span class='texttt'>T</span>, or <span class='texttt'>U</span>, or
it could be a different type. <span class='texttt'>C</span> may not be unique.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='Common'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool Common() {
  return CommonReference&lt;const T&amp;, const U&amp;&gt;() &amp;&amp;
    requires(T (&amp;t)(), U (&amp;u)()) {
      typename common_type_t&lt;T, U&gt;;
      typename common_type_t&lt;U, T&gt;;
      requires Same&lt;common_type_t&lt;U, T&gt;, common_type_t&lt;T, U&gt;&gt;();
      common_type_t&lt;T, U&gt;(t());
      common_type_t&lt;T, U&gt;(u());
      requires CommonReference&lt;add_lvalue_reference_t&lt;common_type_t&lt;T, U&gt;&gt;,
                               common_reference_t&lt;add_lvalue_reference_t&lt;const T&gt;,
                                                  add_lvalue_reference_t&lt;const U&gt;&gt;&gt;();
    };
}
</code></p></div><div class='itemdescr'></div><div class='para' id='common-2'><div class='marginalizedparent'><a class='marginalized' href='#common-2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'>C</span> be <span class='texttt'>common_type_t&lt;T, U&gt;</span>. Let
<span class='texttt'>t</span> be a function whose return type is <span class='texttt'>T</span>, and let <span class='texttt'>u</span> be a function
whose return type is <span class='texttt'>U</span>. <span class='texttt'>Common&lt;T, U&gt;()</span> is satisfied if and only if:
</p><ul class='itemize'><li id='common-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common-2.1'>(2.1)</a></div><p ><span class='texttt'>C(t())</span> equals <span class='texttt'>C(t())</span> if and only if
  <span class='texttt'>t()</span> is an equality preserving
  expression (<a href='concepts.lib.general.equality'>[concepts.lib.general.equality]</a>).
</p></li><li id='common-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common-2.2'>(2.2)</a></div><p ><span class='texttt'>C(u())</span> equals <span class='texttt'>C(u())</span> if and only if
  <span class='texttt'>u()</span> is an equality preserving
  expression (<a href='concepts.lib.general.equality'>[concepts.lib.general.equality]</a>).
</p></li></ul></div></div><div class='para' id='common-3'><div class='marginalizedparent'><a class='marginalized' href='#common-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Users can customize the behavior of <span class='texttt'>Common</span> by specializing the <span class='texttt'>common_type</span>
class template (<a href='meta.unary.prop'>[meta.unary.prop]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='integral'><h3 ><a class='secnum' href='#integral' style='min-width:103pt'>7.3.7</a> Concept <span class='texttt'>Integral</span> <a class='abbr_ref' href='concepts.lib.corelang.integral'>[concepts.lib.corelang.integral]</a></h3><p ><span class='indexparent'><a class='index' id='Integral'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Integral() {
  return is_integral&lt;T&gt;::value;
}
</code></p></div><div id='signedintegral'><h3 ><a class='secnum' href='#signedintegral' style='min-width:103pt'>7.3.8</a> Concept <span class='texttt'>SignedIntegral</span> <a class='abbr_ref' href='concepts.lib.corelang.signedintegral'>[concepts.lib.corelang.signedintegral]</a></h3><p ><span class='indexparent'><a class='index' id='SignedIntegral'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool SignedIntegral() {
  return Integral&lt;T&gt;() &amp;&amp; is_signed&lt;T&gt;::value;
}
</code></p><div class='itemdescr'></div><div class='para' id='signedintegral-1'><div class='marginalizedparent'><a class='marginalized' href='#signedintegral-1'>1</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> <span class='texttt'>SignedIntegral&lt;T&gt;()</span> may be satisfied even for
types that are not signed integral types (  ISO/IEC 14882:2014 &sect;<a href='../n4140/basic.fundamental'>[basic.fundamental]</a>);
for example, <span class='texttt'>char</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='unsignedintegral'><h3 ><a class='secnum' href='#unsignedintegral' style='min-width:103pt'>7.3.9</a> Concept <span class='texttt'>UnsignedIntegral</span> <a class='abbr_ref' href='concepts.lib.corelang.unsignedintegral'>[concepts.lib.corelang.unsignedintegral]</a></h3><p ><span class='indexparent'><a class='index' id='UnsignedIntegral'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool UnsignedIntegral() {
  return Integral&lt;T&gt;() &amp;&amp; !SignedIntegral&lt;T&gt;();
}
</code></p><div class='itemdescr'></div><div class='para' id='unsignedintegral-1'><div class='marginalizedparent'><a class='marginalized' href='#unsignedintegral-1'>1</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> <span class='texttt'>UnsignedIntegral&lt;T&gt;()</span> may be satisfied even for
types that are not unsigned integral types (  ISO/IEC 14882:2014 &sect;<a href='../n4140/basic.fundamental'>[basic.fundamental]</a>);
for example, <span class='texttt'>char</span>.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='assignable'><h3 ><a class='secnum' href='#assignable' style='min-width:103pt'>7.3.10</a> Concept <span class='texttt'>Assignable</span> <a class='abbr_ref' href='concepts.lib.corelang.assignable'>[concepts.lib.corelang.assignable]</a></h3><p ><span class='indexparent'><a class='index' id='Assignable'></a></span><code class='itemdecl'>
template &lt;class T, class U&gt;
concept bool Assignable() {
  return CommonReference&lt;const T&amp;, const U&amp;&gt;() &amp;&amp; requires(T&amp;&amp; t, U&amp;&amp; u) {
    { std::forward&lt;T&gt;(t) = std::forward&lt;U&gt;(u) } -&gt; Same&lt;T&amp;&gt;;
  };
}
</code></p><div class='itemdescr'></div><div class='para' id='assignable-1'><div class='marginalizedparent'><a class='marginalized' href='#assignable-1'>1</a></div><div class='itemdescr'><p >Let <span class='texttt'>t</span> be an lvalue of type <span class='texttt'>T</span>, and <span class='texttt'>R</span> be the
type <span class='texttt'>remove_reference_t&lt;U&gt;</span>. If <span class='texttt'>U</span> is an lvalue reference
type, let <span class='texttt'>v</span> be an lvalue of type <span class='texttt'>R</span>;
otherwise, let <span class='texttt'>v</span> be an rvalue of type <span class='texttt'>R</span>.
Let <span class='texttt'>uu</span> be a distinct object of type <span class='texttt'>R</span> such that
<span class='texttt'>uu</span> is equal to <span class='texttt'>v</span>.
Then <span class='texttt'>Assignable&lt;T, U&gt;()</span> is satisfied if and only if</p><ul class='itemize'><li id='assignable-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assignable-1.1'>(1.1)</a></div><p ><span class='texttt'>addressof(t = v) == addressof(t)</span>.
</p></li><li id='assignable-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#assignable-1.2'>(1.2)</a></div><p >After evaluating <span class='texttt'>t = v</span>, <span class='texttt'>t</span> is equal to <span class='texttt'>uu</span> and:
</p><ul class='itemize'><li id='assignable-1.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#assignable-1.2.1'>(1.2.1)</a></div><p >If <span class='texttt'>v</span> is a non-<span class='texttt'>const</span> rvalue, its resulting
state is valid but unspecified (  ISO/IEC 14882:2014 &sect;<a href='../n4140/lib.types.movedfrom'>[lib.types.movedfrom]</a>).
</p></li><li id='assignable-1.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#assignable-1.2.2'>(1.2.2)</a></div><p >Otherwise, <span class='texttt'>v</span> is not modified.
</p></li></ul></li></ul></div></div></div><div id='swappable'><h3 ><a class='secnum' href='#swappable' style='min-width:103pt'>7.3.11</a> Concept <span class='texttt'>Swappable</span> <a class='abbr_ref' href='concepts.lib.corelang.swappable'>[concepts.lib.corelang.swappable]</a></h3><p ><span class='indexparent'><a class='index' id='Swappable'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Swappable() {
  return requires(T&amp;&amp; a, T&amp;&amp; b) {
    ranges::swap(std::forward&lt;T&gt;(a), std::forward&lt;T&gt;(b));
  };
}

template &lt;class T, class U&gt;
concept bool Swappable() {
  return Swappable&lt;T&gt;() &amp;&amp;
    Swappable&lt;U&gt;() &amp;&amp;
    CommonReference&lt;const T&amp;, const U&amp;&gt;() &amp;&amp;
    requires(T&amp;&amp; t, U&amp;&amp; u) {
      ranges::swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));
      ranges::swap(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t));
    };
}
</code></p><div class='itemdescr'></div><div class='para' id='swappable-1'><div class='marginalizedparent'><a class='marginalized' href='#swappable-1'>1</a></div><div class='itemdescr'><p >This subclause provides definitions for swappable types and expressions. In these
definitions, let <span class='texttt'>t</span> denote an expression of type <span class='texttt'>T</span>, and let <span class='texttt'>u</span>
denote an expression of type <span class='texttt'>U</span>.</p></div></div><div class='para' id='swappable-2'><div class='marginalizedparent'><a class='marginalized' href='#swappable-2'>2</a></div><div class='itemdescr'><p >An object <span class='texttt'>t</span> is <a class='hidden_link' href='#def:swappable_with' id='def:swappable_with'><i>swappable with</i></a> an object <span class='texttt'>u</span> if and only if
<span class='texttt'>Swappable&lt;T, U&gt;()</span> is satisfied. <span class='texttt'>Swappable&lt;T, U&gt;()</span> is satisfied if
and only if given distinct objects <span class='texttt'>t2</span> equal to <span class='texttt'>t</span>
and <span class='texttt'>u2</span> equal to <span class='texttt'>u</span>, after evaluating either
<span class='texttt'>ranges::swap(t, u)</span> or <span class='texttt'>ranges::swap(u, t)</span>, <span class='texttt'>t2</span> is equal to
<span class='texttt'>u</span> and <span class='texttt'>u2</span> is equal to <span class='texttt'>t</span>.</p></div></div><div class='para' id='swappable-3'><div class='marginalizedparent'><a class='marginalized' href='#swappable-3'>3</a></div><div class='itemdescr'><p >An rvalue or lvalue <span class='texttt'>t</span> is <a class='hidden_link' href='#def:swappable' id='def:swappable'><i>swappable</i></a> if and only if <span class='texttt'>t</span> is
swappable with any rvalue or lvalue, respectively, of type <span class='texttt'>T</span>.</p><p >[&nbsp;<i>Example:</i> User code can ensure that the evaluation of <span class='texttt'>swap</span> calls
is performed in an appropriate context under the various conditions as follows:
</p><pre class='codeblock'>
#include &lt;utility&gt;

<span class='comment'>// Requires: <span class='texttt'>std::forward&lt;T&gt;(t)</span> shall be swappable with <span class='texttt'>std::forward&lt;U&gt;(u)</span>.
</span>template &lt;class T, class U&gt;
void value_swap(T&amp;&amp; t, U&amp;&amp; u) {
  using std::experimental::ranges::swap;
  swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));         <span class='comment'>// OK: uses “swappable with” conditions
</span>                                                        <span class='comment'>// for rvalues and lvalues
</span>}

<span class='comment'>// Requires: lvalues of <span class='texttt'>T</span> shall be swappable.
</span>template &lt;class T&gt;
void lv_swap(T&amp; t1, T&amp; t2) {
  using std::experimental::ranges::swap;
  swap(t1, t2);                                         <span class='comment'>// OK: uses swappable conditions for
</span>}                                                       <span class='comment'>// lvalues of type <span class='texttt'>T</span>
</span>
namespace N {
  struct A { int m; };
  struct Proxy { A* a; };
  Proxy proxy(A&amp; a) { return Proxy{ &amp;a }; }

  void swap(A&amp; x, Proxy p) {
    std::experimental::ranges::swap(x.m, p.a-&gt;m);  <span class='comment'>// OK: uses context equivalent to swappable
</span>                                                   <span class='comment'>// conditions for fundamental types
</span>  }
  void swap(Proxy p, A&amp; x) { swap(x, p); }         <span class='comment'>// satisfy symmetry constraint
</span>}

int main() {
  int i = 1, j = 2;
  lv_swap(i, j);
  assert(i == 2 &amp;&amp; j == 1);

  N::A a1 = { 5 }, a2 = { -5 };
  value_swap(a1, proxy(a2));
  assert(a1.m == -5 &amp;&amp; a2.m == 5);
}
</pre><p ><i>&nbsp;—&nbsp;end example</i>&nbsp;]
</p></div></div></div></div></div></body></html>