<!DOCTYPE html><html lang='en'><head><title>[iterator.requirements]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>9</a> Iterators library <a class='abbr_ref' href='./#iterators'>[iterators]</a></h1><div id='iterator.requirements'><h2 ><a class='secnum' style='min-width:88pt'>9.3</a> Iterator requirements <a class='abbr_ref'>[iterator.requirements]</a></h2><div id='general'><h3 ><a class='secnum' href='#general' style='min-width:103pt'>9.3.1</a> In general <a class='abbr_ref' href='iterator.requirements.general'>[iterator.requirements.general]</a></h3><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p ><span class='indexparent'><a class='index' id='requirements,iterator'></a></span>Iterators are a generalization of pointers that allow a C++ program to work with different data structures
(for example, containers and ranges) in a uniform manner.
To be able to construct template algorithms that work correctly and
efficiently on different types of data structures, the library formalizes not just the interfaces but also the
semantics and complexity assumptions of iterators.
All input iterators
<span class='texttt'>i</span>
support the expression
<span class='texttt'>*i</span>,
resulting in a value of some object type
<span class='texttt'>T</span>,
called the
<a class='hidden_link' href='#def:value_type' id='def:value_type'><i>value type</i></a>
of the iterator.
All output iterators support the expression
<span class='texttt'>*i = o</span>
where
<span class='texttt'>o</span>
is a value of some type that is in the set of types that are
<a class='hidden_link' href='#def:writable' id='def:writable'><i>writable</i></a>
to the particular iterator type of
<span class='texttt'>i</span>.
For every iterator type
<span class='texttt'>X</span>
there is a corresponding signed integer type called the
<a class='hidden_link' href='#def:difference_type' id='def:difference_type'><i>difference type</i></a>
of the iterator.</p></div><div class='para' id='general-2'><div class='marginalizedparent'><a class='marginalized' href='#general-2'>2</a></div><p >Since iterators are an abstraction of pointers, their semantics are
a generalization of most of the semantics of pointers in C++.
This ensures that every
function template
that takes iterators
works as well with regular pointers.
This document defines
five categories of iterators, according to the operations
defined on them:
<i>input iterators</i>,
<i>output iterators</i>,
<i>forward iterators</i>,
<i>bidirectional iterators</i>
and
<i>random access iterators</i>,
as shown in Table <a href='#tab:iterators.relations'>[tab:iterators.relations]</a>.</p><div class='numberedTable' id='tab:iterators.relations'>Table <a href='#tab:iterators.relations'>8</a> — Relations among iterator categories<br><table ><tr class='rowsep'><td class='left'>



<b>Random Access</b>          </td><td class='left'>   <span class='math'>→</span> <b>Bidirectional</b>    </td><td class='left'>
<span class='math'>→</span> <b>Forward</b>  </td><td class='left'>   <span class='math'>→</span> <b>Input</b>            </td></tr><tr ><td class='left'>
                        </td><td class='left'>   </td><td class='left'>   </td><td class='left'>   <span class='math'>→</span> <b>Output</b>           </td></tr></table></div></div><div class='para' id='general-3'><div class='marginalizedparent'><a class='marginalized' href='#general-3'>3</a></div><p >The five categories of iterators correspond to the iterator concepts
<span class='texttt'>InputIterator</span>,
<span class='texttt'>OutputIterator</span>,
<span class='texttt'>ForwardIterator</span>,
<span class='texttt'>BidirectionalIterator</span>, and
<span class='texttt'>RandomAccessIterator</span>, respectively. The generic term <i>iterator</i> refers to
any type that satisfies <span class='texttt'>Iterator</span>.</p></div><div class='para' id='general-4'><div class='marginalizedparent'><a class='marginalized' href='#general-4'>4</a></div><p >Forward iterators satisfy all the requirements of input
iterators and can be used whenever an input iterator is specified;
Bidirectional iterators also satisfy all the requirements of
forward iterators and can be used whenever a forward iterator is specified;
Random access iterators also satisfy all the requirements of bidirectional
iterators and can be used whenever a bidirectional iterator is specified.</p></div><div class='para' id='general-5'><div class='marginalizedparent'><a class='marginalized' href='#general-5'>5</a></div><p >Iterators that further satisfy the requirements of output iterators are
called <a class='hidden_link' href='#def:mutable_iterator' id='def:mutable_iterator'><i>mutable iterator</i></a>s. Nonmutable iterators are referred to
as <a class='hidden_link' href='#def:constant_iterator' id='def:constant_iterator'><i>constant iterator</i></a>s.</p></div><div class='para' id='general-6'><div class='marginalizedparent'><a class='marginalized' href='#general-6'>6</a></div><p >Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element
of the array, so for any iterator type there is an iterator value that points past the last element of a
corresponding sequence.
These values are called
<a class='hidden_link' href='#def:past-the-end' id='def:past-the-end'><i>past-the-end</i></a>
values.
Values of an iterator
<span class='texttt'>i</span>
for which the expression
<span class='texttt'>*i</span>
is defined are called
<a class='hidden_link' href='#def:dereferenceable' id='def:dereferenceable'><i>dereferenceable</i></a>.
The library never assumes that past-the-end values are dereferenceable.
Iterators can also have singular values that are not associated with any
sequence.
[&nbsp;<i>Example:</i>
After the declaration of an uninitialized pointer
<span class='texttt'>x</span>
(as with
<span class='texttt'>int* x;</span>),
<span class='texttt'>x</span>
must always be assumed to have a singular value of a pointer.
<i>&nbsp;—&nbsp;end example</i>&nbsp;]
Results of most expressions are undefined for singular values;
the only exceptions are destroying an iterator that holds a singular value,
the assignment of a non-singular value to
an iterator that holds a singular value, and using a value-initialized iterator
as the source of a copy or move operation. [&nbsp;<i>Note:</i> This guarantee is not
offered for default initialization, although the distinction only matters for types
with trivial default constructors such as pointers or aggregates holding pointers.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]
In these cases the singular
value is overwritten the same way as any other value.
Dereferenceable
values are always non-singular.</p></div><div class='para' id='general-7'><div class='marginalizedparent'><a class='marginalized' href='#general-7'>7</a></div><p >Most of the library's algorithmic templates that operate on data structures have
interfaces that use ranges. A range is an iterator and a <a class='hidden_link' href='#def:sentinel' id='def:sentinel'><i>sentinel</i></a> that designate
the beginning and end of the computation, or an iterator and a count that designate
the beginning and the number of elements to which the computation is to be applied.</p></div><div class='para' id='general-8'><div class='marginalizedparent'><a class='marginalized' href='#general-8'>8</a></div><p >An iterator and a sentinel denoting a range are comparable. The types of a sentinel
and an iterator that denote a range must satisfy
<span class='texttt'>Sentinel</span> (<a href='iterators.sentinel'>[iterators.sentinel]</a>).
A range <span class='texttt'>[i,s)</span>
is empty if <span class='texttt'>i == s</span>;
otherwise, <span class='texttt'>[i,s)</span>
refers to the elements in the data structure starting with the element
pointed to by
<span class='texttt'>i</span>
and up to but not including the element pointed to by
the first iterator <span class='texttt'>j</span> such that <span class='texttt'>j == s</span>.</p></div><div class='para' id='general-9'><div class='marginalizedparent'><a class='marginalized' href='#general-9'>9</a></div><p >A sentinel
<span class='texttt'>s</span>
is called
<a class='hidden_link' href='#def:reachable' id='def:reachable'><i>reachable</i></a>
from an iterator
<span class='texttt'>i</span>
if and only if there is a finite sequence of applications of
the expression
<span class='texttt'>++i</span>
that makes
<span class='texttt'>i == s</span>.
If
<span class='texttt'>s</span>
is reachable from
<span class='texttt'>i</span>,
<span class='texttt'>[i,s)</span> denotes a range.</p></div><div class='para' id='general-10'><div class='marginalizedparent'><a class='marginalized' href='#general-10'>10</a></div><p >A counted range <span class='texttt'>[i,n)</span> is empty if <span class='texttt'>n == 0</span>; otherwise, <span class='texttt'>[i,n)</span>
refers to the <span class='texttt'>n</span> elements in the data structure starting with the element
pointed to by <span class='texttt'>i</span> and up to but not including the element pointed to by the
result of incrementing <span class='texttt'>i</span> <span class='texttt'>n</span> times.</p></div><div class='para' id='general-11'><div class='marginalizedparent'><a class='marginalized' href='#general-11'>11</a></div><p >A range <span class='texttt'>[i,s)</span>
is valid if and only if
<span class='texttt'>s</span>
is reachable from
<span class='texttt'>i</span>.
A counted range <span class='texttt'>[i,n)</span> is valid if and only if <span class='texttt'>n == 0</span>; or <span class='texttt'>n</span>
is positive, <span class='texttt'>i</span> is dereferenceable, and <span class='texttt'>[++i,--n)</span> is valid.
The result of the application of functions in the library to invalid ranges is
undefined.</p></div><div class='para' id='general-12'><div class='marginalizedparent'><a class='marginalized' href='#general-12'>12</a></div><p >All the categories of iterators require only those functions that are realizable for a given category in
constant time (amortized).</p></div><div class='para' id='general-13'><div class='marginalizedparent'><a class='marginalized' href='#general-13'>13</a></div><p >Destruction of an iterator may invalidate pointers and references
previously obtained from that iterator.</p></div><div class='para' id='general-14'><div class='marginalizedparent'><a class='marginalized' href='#general-14'>14</a></div><p >An
<i>invalid</i>
iterator is an iterator that may be singular.<a class='footnotenum' href='#footnote-3'>3</a></p></div><div class='footnote' id='footnote-3'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-3'>3)</a></div><p >This definition applies to pointers, since pointers are iterators.
The effect of dereferencing an iterator that has been invalidated
is undefined.
</p></div></div><div id='iterator.custpoints'><h3 ><a class='secnum' href='#iterator.custpoints' style='min-width:103pt'>9.3.2</a> Customization points <a class='abbr_ref' href='iterator.custpoints'>[iterator.custpoints]</a></h3><div id='iterator.custpoints.iter_move'><h4 ><a class='secnum' href='#iterator.custpoints.iter_move' style='min-width:118pt'>9.3.2.1</a> <span class='texttt'>iter_move</span> <a class='abbr_ref' href='iterator.custpoints.iter_move'>[iterator.custpoints.iter_move]</a></h4><div class='para' id='iterator.custpoints.iter_move-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.custpoints.iter_move-1'>1</a></div><p >The name <span class='texttt'>iter_move</span> denotes a <i>customization point
object</i> (<a href='customization.point.object'>[customization.point.object]</a>). The expression
<span class='texttt'>ranges::iter_move(E)</span> for some subexpression <span class='texttt'>E</span> is expression-equivalent to the
following:</p><ul class='itemize'><li id='iterator.custpoints.iter_move-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.custpoints.iter_move-1.1'>(1.1)</a></div><p ><span class='texttt'>static_cast&lt;decltype(iter_move(E))&gt;(iter_move(E))</span>, if that expression is well-formed when evaluated in
a context that does not include <span class='texttt'>ranges::iter_move</span> but does include the
lookup set produced by argument-dependent lookup (  ISO/IEC 14882:2014 &sect;<a href='../n4140/basic.lookup.argdep'>[basic.lookup.argdep]</a>).</p></li><li id='iterator.custpoints.iter_move-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.custpoints.iter_move-1.2'>(1.2)</a></div><p >Otherwise, if the expression <span class='texttt'>*E</span> is well-formed:
</p><ul class='itemize'><li id='iterator.custpoints.iter_move-1.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#iterator.custpoints.iter_move-1.2.1'>(1.2.1)</a></div><p >if <span class='texttt'>*E</span> is an lvalue, <span class='texttt'>std::move(*E)</span>;</p></li><li id='iterator.custpoints.iter_move-1.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#iterator.custpoints.iter_move-1.2.2'>(1.2.2)</a></div><p >otherwise, <span class='texttt'>static_cast&lt;decltype(*E)&gt;(*E)</span>.
</p></li></ul></li><li id='iterator.custpoints.iter_move-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.custpoints.iter_move-1.3'>(1.3)</a></div><p >Otherwise, <span class='texttt'>ranges::iter_move(E)</span> is ill-formed.
</p></li></ul></div><div class='para' id='iterator.custpoints.iter_move-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.custpoints.iter_move-2'>2</a></div><p >If <span class='texttt'>ranges::iter_move(E)</span> does not equal <span class='texttt'>*E</span>, the program is
ill-formed with no diagnostic required.</p></div></div><div id='iterator.custpoints.iter_swap'><h4 ><a class='secnum' href='#iterator.custpoints.iter_swap' style='min-width:118pt'>9.3.2.2</a> <span class='texttt'>iter_swap</span> <a class='abbr_ref' href='iterator.custpoints.iter_swap'>[iterator.custpoints.iter_swap]</a></h4><div class='para' id='iterator.custpoints.iter_swap-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.custpoints.iter_swap-1'>1</a></div><p >The name <span class='texttt'>iter_swap</span> denotes a <i>customization point
object</i> (<a href='customization.point.object'>[customization.point.object]</a>). The expression
<span class='texttt'>ranges::iter_swap(E1, E2)</span> for some subexpressions <span class='texttt'>E1</span> and <span class='texttt'>E2</span>
is expression-equivalent to the following:</p><ul class='itemize'><li id='iterator.custpoints.iter_swap-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.custpoints.iter_swap-1.1'>(1.1)</a></div><p ><span class='texttt'>(void)iter_swap(E1, E2)</span>, if that expression is well-formed when
evaluated in a context that does not include <span class='texttt'>ranges::iter_swap</span> but does
include the lookup set produced by argument-dependent
lookup (  ISO/IEC 14882:2014 &sect;<a href='../n4140/basic.lookup.argdep'>[basic.lookup.argdep]</a>) and the following declaration:
</p><pre class='codeblock'>
void iter_swap(auto, auto) = delete;
</pre></li><li id='iterator.custpoints.iter_swap-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.custpoints.iter_swap-1.2'>(1.2)</a></div><p >Otherwise, if the types of <span class='texttt'>E1</span> and <span class='texttt'>E2</span> both satisfy
<span class='texttt'>Readable</span>, and if the reference type of <span class='texttt'>E1</span> is swappable
with (<a href='concepts.lib.corelang.swappable'>[concepts.lib.corelang.swappable]</a>) the reference type of <span class='texttt'>E2</span>,
then <span class='texttt'>ranges::swap(*E1, *E2)</span></p></li><li id='iterator.custpoints.iter_swap-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.custpoints.iter_swap-1.3'>(1.3)</a></div><p >Otherwise, if the types <span class='texttt'>T1</span> and <span class='texttt'>T2</span> of <span class='texttt'>E1</span> and
<span class='texttt'>E2</span> satisfy <span class='texttt'>IndirectlyMovableStorable&lt;T1, T2&gt; &amp;&amp;
IndirectlyMovableStorable&lt;T2, T1&gt;</span>, <span class='texttt'>(void)(*E1 = iter_exchange_move(E2, E1))</span>,
except that <span class='texttt'>E1</span> is evaluated only once.</p></li><li id='iterator.custpoints.iter_swap-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.custpoints.iter_swap-1.4'>(1.4)</a></div><p >Otherwise, <span class='texttt'>ranges::iter_swap(E1, E2)</span> is ill-formed.
</p></li></ul></div><div class='para' id='iterator.custpoints.iter_swap-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.custpoints.iter_swap-2'>2</a></div><p >If <span class='texttt'>ranges::iter_swap(E1, E2)</span> does not swap the values denoted by the
expressions <span class='texttt'>E1</span> and <span class='texttt'>E2</span>, the program is ill-formed with no
diagnostic required.</p></div><div class='para' id='iterator.custpoints.iter_swap-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.custpoints.iter_swap-3'>3</a></div><p ><span class='texttt'>iter_exchange_move</span> is an exposition-only function specified as:
<code class='itemdecl'>
template &lt;class X, class Y&gt;
  constexpr value_type_t&lt;remove_reference_t&lt;X&gt;&gt; iter_exchange_move(X&amp;&amp; x, Y&amp;&amp; y)
    noexcept(<i><span class='texttt'>see below</span></i>);
</code></p></div><div class='itemdescr'></div><div class='para' id='iterator.custpoints.iter_swap-4'><div class='marginalizedparent'><a class='marginalized' href='#iterator.custpoints.iter_swap-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
value_type_t&lt;remove_reference_t&lt;X&gt;&gt; old_value(iter_move(x));
*x = iter_move(y);
return old_value;
</pre></div></div><div class='para' id='iterator.custpoints.iter_swap-5'><div class='marginalizedparent'><a class='marginalized' href='#iterator.custpoints.iter_swap-5'>5</a></div><div class='itemdescr'><p ><i>Remarks:</i> The expression in the <span class='texttt'>noexcept</span> is equivalent to:
</p><pre class='codeblock'>
NE(remove_reference_t&lt;X&gt;, remove_reference_t&lt;Y&gt;) &amp;&amp;
NE(remove_reference_t&lt;Y&gt;, remove_reference_t&lt;X&gt;)
</pre><p >Where <span class='texttt'>NE(T1, T2)</span> is the expression:
</p><pre class='codeblock'>
is_nothrow_constructible&lt;value_type_t&lt;T1&gt;, rvalue_reference_t&lt;T1&gt;&gt;::value &amp;&amp;
is_nothrow_assignable&lt;value_type_t&lt;T1&gt;&amp;, rvalue_reference_t&lt;T1&gt;&gt;::value &amp;&amp;
is_nothrow_assignable&lt;reference_t&lt;T1&gt;, rvalue_reference_t&lt;T2&gt;&gt;::value &amp;&amp;
is_nothrow_assignable&lt;reference_t&lt;T1&gt;, value_type_t&lt;T2&gt;&gt;::value&gt; &amp;&amp;
is_nothrow_move_constructible&lt;value_type_t&lt;T1&gt;&gt;::value &amp;&amp;
noexcept(ranges::iter_move(declval&lt;T1&amp;&gt;()))
</pre></div></div></div></div><div id='iterator.assoc.types'><h3 ><a class='secnum' href='#iterator.assoc.types' style='min-width:103pt'>9.3.3</a> Iterator associated types <a class='abbr_ref' href='iterator.assoc.types'>[iterator.assoc.types]</a></h3><div class='para' id='iterator.assoc.types-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types-1'>1</a></div><p >To implement algorithms only in terms of iterators, it is often necessary to
determine the value and
difference types that correspond to a particular iterator type.
Accordingly, it is required that if
<span class='texttt'>WI</span> is the name of a type that
satisfies the <span class='texttt'>WeaklyIncrementable</span> concept (<a href='iterators.weaklyincrementable'>[iterators.weaklyincrementable]</a>),
<span class='texttt'>R</span> is the name of a type that
satisfies the <span class='texttt'>Readable</span> concept (<a href='iterators.readable'>[iterators.readable]</a>), and
<span class='texttt'>II</span> is the name of a type that satisfies the
<span class='texttt'>InputIterator</span> concept (<a href='iterators.input'>[iterators.input]</a>) concept, the types</p><pre class='codeblock'>
difference_type_t&lt;WI&gt;
value_type_t&lt;R&gt;
iterator_category_t&lt;II&gt;
</pre><p >be defined as the iterator's difference type, value type and iterator category, respectively.</p></div><div id='iterator.assoc.types.difference_type'><h4 ><a class='secnum' href='#iterator.assoc.types.difference_type' style='min-width:118pt'>9.3.3.1</a> <span class='texttt'>difference_type</span> <a class='abbr_ref' href='iterator.assoc.types.difference_type'>[iterator.assoc.types.difference_type]</a></h4><div class='para' id='iterator.assoc.types.difference_type-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.difference_type-1'>1</a></div><p ><span class='indexparent'><a class='index' id='difference_type_t'></a></span><span class='texttt'>difference_type_t&lt;T&gt;</span> is implemented as if:</p><p ><span class='indexparent'><a class='index' id='difference_type'></a></span></p><pre class='codeblock'>
  template &lt;class&gt; struct difference_type { };

  template &lt;class T&gt;
  struct difference_type&lt;T*&gt;
    : enable_if&lt;is_object&lt;T&gt;::value, ptrdiff_t&gt; { };

  template &lt;class I&gt;
  struct difference_type&lt;const I&gt; : difference_type&lt;decay_t&lt;I&gt;&gt; { };

  template &lt;class T&gt;
    requires requires { typename T::difference_type; }
  struct difference_type&lt;T&gt; {
    using type = typename T::difference_type;
  };

  template &lt;class T&gt;
    requires !requires { typename T::difference_type; } &amp;&amp;
      requires(const T&amp; a, const T&amp; b) { { a - b } -&gt; Integral; }
  struct difference_type&lt;T&gt;
    : make_signed&lt; decltype(declval&lt;T&gt;() - declval&lt;T&gt;()) &gt; {
  };

  template &lt;class T&gt; using difference_type_t
    = typename difference_type&lt;T&gt;::type;
</pre></div><div class='para' id='iterator.assoc.types.difference_type-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.difference_type-2'>2</a></div><p >Users may specialize <span class='texttt'>difference_type</span> on user-defined types.</p></div></div><div id='iterator.assoc.types.value_type'><h4 ><a class='secnum' href='#iterator.assoc.types.value_type' style='min-width:118pt'>9.3.3.2</a> <span class='texttt'>value_type</span> <a class='abbr_ref' href='iterator.assoc.types.value_type'>[iterator.assoc.types.value_type]</a></h4><div class='para' id='iterator.assoc.types.value_type-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.value_type-1'>1</a></div><p >A <span class='texttt'>Readable</span> type has an associated value type that can be accessed with the
<span class='texttt'>value_type_t</span> alias template.</p><p ><span class='indexparent'><a class='index' id='value_type'></a></span></p><pre class='codeblock'>
  template &lt;class&gt; struct value_type { };

  template &lt;class T&gt;
  struct value_type&lt;T*&gt;
    : enable_if&lt;is_object&lt;T&gt;::value, remove_cv_t&lt;T&gt;&gt; { };

  template &lt;class I&gt;
    requires is_array&lt;I&gt;::value
  struct value_type&lt;I&gt; : value_type&lt;decay_t&lt;I&gt;&gt; { };

  template &lt;class I&gt;
  struct value_type&lt;const I&gt; : value_type&lt;decay_t&lt;I&gt;&gt; { };

  template &lt;class T&gt;
    requires requires { typename T::value_type; }
  struct value_type&lt;T&gt;
    : enable_if&lt;is_object&lt;typename T::value_type&gt;::value, typename T::value_type&gt; { };

  template &lt;class T&gt;
    requires requires { typename T::element_type; }
  struct value_type&lt;T&gt;
    : enable_if&lt;
        is_object&lt;typename T::element_type&gt;::value,
        remove_cv_t&lt;typename T::element_type&gt;&gt;
    { };

  template &lt;class T&gt; using value_type_t
    = typename value_type&lt;T&gt;::type;
</pre></div><div class='para' id='iterator.assoc.types.value_type-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.value_type-2'>2</a></div><p >If a type <span class='texttt'>I</span> has an associated value type, then <span class='texttt'>value_type&lt;I&gt;::type</span> shall name the
value type. Otherwise, there shall be no nested type <span class='texttt'>type</span>.</p></div><div class='para' id='iterator.assoc.types.value_type-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.value_type-3'>3</a></div><p >The <span class='texttt'>value_type</span> class template may be specialized on user-defined types.</p></div><div class='para' id='iterator.assoc.types.value_type-4'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.value_type-4'>4</a></div><p >When instantiated with a type <span class='texttt'>I</span>
such that <span class='texttt'>I::value_type</span> is valid and denotes a type,
<span class='texttt'>value_type&lt;I&gt;::type</span> names that type, unless it is not an object type (  ISO/IEC 14882:2014 &sect;<a href='../n4140/basic.types'>[basic.types]</a>) in which case
<span class='texttt'>value_type&lt;I&gt;</span> shall have no nested type <span class='texttt'>type</span>. [&nbsp;<i>Note:</i> Some legacy output
iterators define a nested type named <span class='texttt'>value_type</span> that is an alias for <span class='texttt'>void</span>. These
types are not <span class='texttt'>Readable</span> and have no associated value types.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='iterator.assoc.types.value_type-5'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.value_type-5'>5</a></div><p >When instantiated with a type <span class='texttt'>I</span>
such that <span class='texttt'>I::element_type</span> is valid and denotes a type,
<span class='texttt'>value_type&lt;I&gt;::type</span> names the type <span class='texttt'>remove_cv_t&lt;I::element_type&gt;</span>, unless it is
not an object type (  ISO/IEC 14882:2014 &sect;<a href='../n4140/basic.types'>[basic.types]</a>) in which case
<span class='texttt'>value_type&lt;I&gt;</span> shall have no nested type <span class='texttt'>type</span>. [&nbsp;<i>Note:</i> Smart pointers like
<span class='texttt'>shared_ptr&lt;int&gt;</span> are <span class='texttt'>Readable</span> and have an associated value type. But a smart pointer
like <span class='texttt'>shared_ptr&lt;void&gt;</span> is not <span class='texttt'>Readable</span> and has no associated value type.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterator.assoc.types.iterator_category'><h4 ><a class='secnum' href='#iterator.assoc.types.iterator_category' style='min-width:118pt'>9.3.3.3</a> <span class='texttt'>iterator_category</span> <a class='abbr_ref' href='iterator.assoc.types.iterator_category'>[iterator.assoc.types.iterator_category]</a></h4><div class='para' id='iterator.assoc.types.iterator_category-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.iterator_category-1'>1</a></div><p ><span class='indexparent'><a class='index' id='iterator_category_t'></a></span><span class='texttt'>iterator_category_t&lt;T&gt;</span>
is implemented as if:</p><p ><span class='indexparent'><a class='index' id='iterator_category'></a></span></p><pre class='codeblock'>
  template &lt;class&gt; struct iterator_category { };

  template &lt;class T&gt;
  struct iterator_category&lt;T*&gt;
    : enable_if&lt;is_object&lt;T&gt;::value, random_access_iterator_tag&gt; { };

  template &lt;class T&gt;
  struct iterator_category&lt;T const&gt; : iterator_category&lt;T&gt; { };

  template &lt;class T&gt;
    requires requires { typename T::iterator_category; }
  struct iterator_category&lt;T&gt; {
    using type = <i><span class='texttt'>see below</span></i>;
  };

  template &lt;class T&gt; using iterator_category_t
    = typename iterator_category&lt;T&gt;::type;
</pre></div><div class='para' id='iterator.assoc.types.iterator_category-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.iterator_category-2'>2</a></div><p >Users may specialize <span class='texttt'>iterator_category</span> on user-defined types.</p></div><div class='para' id='iterator.assoc.types.iterator_category-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.iterator_category-3'>3</a></div><p >If
<span class='texttt'>T::iterator_category</span> is valid and denotes a type, then the
type <span class='texttt'>iterator_category&lt;T&gt;::type</span> is computed as follows:
</p><ul class='itemize'><li id='iterator.assoc.types.iterator_category-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.assoc.types.iterator_category-3.1'>(3.1)</a></div><p >If <span class='texttt'>T::iterator_category</span> is the same as or derives from <span class='texttt'>std::random_access_iterator_tag</span>,
      <span class='texttt'>iterator_category&lt;T&gt;::type</span> is <span class='texttt'>ranges::random_access_iterator_tag</span>.
</p></li><li id='iterator.assoc.types.iterator_category-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.assoc.types.iterator_category-3.2'>(3.2)</a></div><p >Otherwise, if <span class='texttt'>T::iterator_category</span> is the same as or derives from <span class='texttt'>std::bidirectional_iterator_tag</span>,
      <span class='texttt'>iterator_category&lt;T&gt;::type</span> is <span class='texttt'>ranges::bidirectional_iterator_tag</span>.
</p></li><li id='iterator.assoc.types.iterator_category-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.assoc.types.iterator_category-3.3'>(3.3)</a></div><p >Otherwise, if <span class='texttt'>T::iterator_category</span> is the same as or derives from <span class='texttt'>std::forward_iterator_tag</span>,
      <span class='texttt'>iterator_category&lt;T&gt;::type</span> is <span class='texttt'>ranges::forward_iterator_tag</span>.
</p></li><li id='iterator.assoc.types.iterator_category-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.assoc.types.iterator_category-3.4'>(3.4)</a></div><p >Otherwise, if <span class='texttt'>T::iterator_category</span> is the same as or derives from <span class='texttt'>std::input_iterator_tag</span>,
      <span class='texttt'>iterator_category&lt;T&gt;::type</span> is <span class='texttt'>ranges::input_iterator_tag</span>.
</p></li><li id='iterator.assoc.types.iterator_category-3.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.assoc.types.iterator_category-3.5'>(3.5)</a></div><p >Otherwise, if <span class='texttt'>T::iterator_category</span> is the same as or derives from <span class='texttt'>std::output_iterator_tag</span>,
      <span class='texttt'>iterator_category&lt;T&gt;</span> has no nested <span class='texttt'>type</span>.
</p></li><li id='iterator.assoc.types.iterator_category-3.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.assoc.types.iterator_category-3.6'>(3.6)</a></div><p >Otherwise, <span class='texttt'>iterator_category&lt;T&gt;::type</span> is <span class='texttt'>T::iterator_category</span>
</p></li></ul></div><div class='para' id='iterator.assoc.types.iterator_category-4'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.iterator_category-4'>4</a></div><p ><span class='indexparent'><a class='index' id='rvalue_reference_t'></a></span><span class='texttt'>rvalue_reference_t&lt;T&gt;</span> is implemented as if:</p><p ><code class='itemdecl'>
  template &lt;<i>dereferenceable</i> T&gt;
      requires <i><span class='texttt'>see below</span></i> using rvalue_reference_t
    = decltype(ranges::iter_move(declval&lt;T&amp;&gt;()));
</code></p></div><div class='itemdescr'></div><div class='para' id='iterator.assoc.types.iterator_category-5'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.iterator_category-5'>5</a></div><div class='itemdescr'><p >The expression in the <span class='texttt'>requires</span> clause is equivalent to:
</p><pre class='codeblock'>
requires(T&amp; t) { { ranges::iter_move(t) } -&gt; auto&amp;&amp;; }
</pre></div></div></div></div><div id='iterators.readable'><h3 ><a class='secnum' href='#iterators.readable' style='min-width:103pt'>9.3.4</a> Concept <span class='texttt'>Readable</span> <a class='abbr_ref' href='iterators.readable'>[iterators.readable]</a></h3><div class='para' id='iterators.readable-1'><div class='marginalizedparent'><a class='marginalized' href='#iterators.readable-1'>1</a></div><p >The <span class='texttt'>Readable</span> concept is satisfied by types that are readable by
applying <span class='texttt'>operator*</span> including pointers, smart pointers, and iterators.</p><p ><span class='indexparent'><a class='index' id='Readable'></a></span></p><pre class='codeblock'>
  template &lt;class In&gt;
  concept bool Readable =
    requires {
      typename value_type_t&lt;In&gt;;
      typename reference_t&lt;In&gt;;
      typename rvalue_reference_t&lt;In&gt;;
    } &amp;&amp;
    CommonReference&lt;reference_t&lt;In&gt;&amp;&amp;, value_type_t&lt;In&gt;&amp;&gt; &amp;&amp;
    CommonReference&lt;reference_t&lt;In&gt;&amp;&amp;, rvalue_reference_t&lt;In&gt;&amp;&amp;&gt; &amp;&amp;
    CommonReference&lt;rvalue_reference_t&lt;In&gt;&amp;&amp;, const value_type_t&lt;In&gt;&amp;&gt;;
</pre></div></div><div id='iterators.writable'><h3 ><a class='secnum' href='#iterators.writable' style='min-width:103pt'>9.3.5</a> Concept <span class='texttt'>Writable</span> <a class='abbr_ref' href='iterators.writable'>[iterators.writable]</a></h3><div class='para' id='iterators.writable-1'><div class='marginalizedparent'><a class='marginalized' href='#iterators.writable-1'>1</a></div><p >The <span class='texttt'>Writable</span> concept specifies the requirements for writing a value into an iterator's
referenced object.</p><p ><span class='indexparent'><a class='index' id='Writable'></a></span></p><pre class='codeblock'>
  template &lt;class Out, class T&gt;
  concept bool Writable =
    requires(Out&amp;&amp; o, T&amp;&amp; t) {
      *o = std::forward&lt;T&gt;(t); <span class='comment'>// not required to be equality preserving
</span>      *std::forward&lt;Out&gt;(o) = std::forward&lt;T&gt;(t); <span class='comment'>// not required to be equality preserving
</span>      const_cast&lt;const reference_t&lt;Out&gt;&amp;&amp;&gt;(*o) =
        std::forward&lt;T&gt;(t); <span class='comment'>// not required to be equality preserving
</span>      const_cast&lt;const reference_t&lt;Out&gt;&amp;&amp;&gt;(*std::forward&lt;Out&gt;(o)) =
        std::forward&lt;T&gt;(t); <span class='comment'>// not required to be equality preserving
</span>    };
</pre></div><div class='para' id='iterators.writable-2'><div class='marginalizedparent'><a class='marginalized' href='#iterators.writable-2'>2</a></div><p >Let <span class='texttt'>E</span> be an an expression such that <span class='texttt'>decltype((E))</span> is <span class='texttt'>T</span>, and let <span class='texttt'>o</span>
be a dereferenceable object of type <span class='texttt'>Out</span>. <span class='texttt'>Writable&lt;Out, T&gt;</span> is satisfied only if</p><ul class='itemize'><li id='iterators.writable-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.writable-2.1'>(2.1)</a></div><p >If <span class='texttt'>Readable&lt;Out&gt; &amp;&amp; Same&lt;value_type_t&lt;Out&gt;, decay_t&lt;T&gt;&gt;</span> is satisfied,
then <span class='texttt'>*o</span> after any above assignment is equal
to the value of <span class='texttt'>E</span> before the assignment.
</p></li></ul></div><div class='para' id='iterators.writable-3'><div class='marginalizedparent'><a class='marginalized' href='#iterators.writable-3'>3</a></div><p >After evaluating any above assignment expression, <span class='texttt'>o</span> is not required to be dereferenceable.</p></div><div class='para' id='iterators.writable-4'><div class='marginalizedparent'><a class='marginalized' href='#iterators.writable-4'>4</a></div><p >If <span class='texttt'>E</span> is an xvalue (  ISO/IEC 14882:2014 &sect;<a href='../n4140/basic.lval'>[basic.lval]</a>), the resulting
state of the object it denotes is valid but unspecified (  ISO/IEC 14882:2014 &sect;<a href='../n4140/lib.types.movedfrom'>[lib.types.movedfrom]</a>).</p></div><div class='para' id='iterators.writable-5'><div class='marginalizedparent'><a class='marginalized' href='#iterators.writable-5'>5</a></div><p >[&nbsp;<i>Note:</i>
The only valid use of an <span class='texttt'>operator*</span> is on the left side of the assignment statement.
<i>Assignment through the same value of the writable type happens only once.</i>
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterators.weaklyincrementable'><h3 ><a class='secnum' href='#iterators.weaklyincrementable' style='min-width:103pt'>9.3.6</a> Concept <span class='texttt'>WeaklyIncrementable</span> <a class='abbr_ref' href='iterators.weaklyincrementable'>[iterators.weaklyincrementable]</a></h3><div class='para' id='iterators.weaklyincrementable-1'><div class='marginalizedparent'><a class='marginalized' href='#iterators.weaklyincrementable-1'>1</a></div><p >The <span class='texttt'>WeaklyIncrementable</span> concept specifies the requirements on
types that can be incremented with the pre- and post-increment operators.
The increment operations are not required to be equality-preserving,
nor is the type required to be <span class='texttt'>EqualityComparable</span>.</p><p ><span class='indexparent'><a class='index' id='WeaklyIncrementable'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool WeaklyIncrementable =
    Semiregular&lt;I&gt; &amp;&amp;
    requires(I i) {
      typename difference_type_t&lt;I&gt;;
      requires SignedIntegral&lt;difference_type_t&lt;I&gt;&gt;;
      { ++i } -&gt; Same&lt;I&gt;&amp;; <span class='comment'>// not required to be equality preserving
</span>      i++; <span class='comment'>// not required to be equality preserving
</span>    };
</pre></div><div class='para' id='iterators.weaklyincrementable-2'><div class='marginalizedparent'><a class='marginalized' href='#iterators.weaklyincrementable-2'>2</a></div><p >Let <span class='texttt'>i</span> be an object of type <span class='texttt'>I</span>. When <span class='texttt'>i</span> is in the domain of
both pre- and post-increment, <span class='texttt'>i</span> is said to be <i>incrementable</i>.
<span class='texttt'>WeaklyIncrementable&lt;I&gt;</span> is satisfied only if</p><ul class='itemize'><li id='iterators.weaklyincrementable-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.weaklyincrementable-2.1'>(2.1)</a></div><p >The expressions <span class='texttt'>++i</span> and <span class='texttt'>i++</span> have the same domain.
</p></li><li id='iterators.weaklyincrementable-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.weaklyincrementable-2.2'>(2.2)</a></div><p >If <span class='texttt'>i</span> is incrementable, then both <span class='texttt'>++i</span>
  and <span class='texttt'>i++</span> advance <span class='texttt'>i</span> to the next element.
</p></li><li id='iterators.weaklyincrementable-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.weaklyincrementable-2.3'>(2.3)</a></div><p >If <span class='texttt'>i</span> is incrementable, then <span class='texttt'>&amp;++i</span> is equal to <span class='texttt'>&amp;i</span>.
</p></li></ul></div><div class='para' id='iterators.weaklyincrementable-3'><div class='marginalizedparent'><a class='marginalized' href='#iterators.weaklyincrementable-3'>3</a></div><p >[&nbsp;<i>Note:</i> For <span class='texttt'>WeaklyIncrementable</span> types, <span class='texttt'>a</span> equals <span class='texttt'>b</span> does not imply that <span class='texttt'>++a</span>
equals <span class='texttt'>++b</span>. (Equality does not guarantee the substitution property or referential
transparency.) Algorithms on weakly incrementable types should never attempt to pass
through the same incrementable value twice. They should be single pass algorithms. These algorithms
can be used with istreams as the source of the input data through the <span class='texttt'>istream_iterator</span> class
template.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterators.incrementable'><h3 ><a class='secnum' href='#iterators.incrementable' style='min-width:103pt'>9.3.7</a> Concept <span class='texttt'>Incrementable</span> <a class='abbr_ref' href='iterators.incrementable'>[iterators.incrementable]</a></h3><div class='para' id='iterators.incrementable-1'><div class='marginalizedparent'><a class='marginalized' href='#iterators.incrementable-1'>1</a></div><p >The <span class='texttt'>Incrementable</span> concept specifies requirements on types that can be incremented with the pre-
and post-increment operators. The increment operations are required to be equality-preserving,
and the type is required to be <span class='texttt'>EqualityComparable</span>. [&nbsp;<i>Note:</i> This requirement
supersedes the annotations on the increment expressions in the definition of
<span class='texttt'>WeaklyIncrementable</span>. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='Incrementable'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool Incrementable =
    Regular&lt;I&gt; &amp;&amp;
    WeaklyIncrementable&lt;I&gt; &amp;&amp;
    requires(I i) {
      { i++ } -&gt; Same&lt;I&gt;&amp;&amp;;
    };
</pre></div><div class='para' id='iterators.incrementable-2'><div class='marginalizedparent'><a class='marginalized' href='#iterators.incrementable-2'>2</a></div><p >Let <span class='texttt'>a</span> and <span class='texttt'>b</span> be incrementable objects of type <span class='texttt'>I</span>.
<span class='texttt'>Incrementable&lt;I&gt;</span> is satisfied only if</p><ul class='itemize'><li id='iterators.incrementable-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.incrementable-2.1'>(2.1)</a></div><p >If <span class='texttt'>bool(a == b)</span> then <span class='texttt'>bool(a++ == b)</span>.
</p></li><li id='iterators.incrementable-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.incrementable-2.2'>(2.2)</a></div><p >If <span class='texttt'>bool(a == b)</span> then <span class='texttt'>bool((a++, a) == ++b)</span>.
</p></li></ul></div><div class='para' id='iterators.incrementable-3'><div class='marginalizedparent'><a class='marginalized' href='#iterators.incrementable-3'>3</a></div><p >[&nbsp;<i>Note:</i> The requirement that <span class='texttt'>a</span> equals <span class='texttt'>b</span> implies <span class='texttt'>++a</span> equals <span class='texttt'>++b</span>
(which is not true for weakly incrementable types) allows the use of multi-pass one-directional
algorithms with types that satisfy <span class='texttt'>Incrementable</span>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterators.iterator'><h3 ><a class='secnum' href='#iterators.iterator' style='min-width:103pt'>9.3.8</a> Concept <span class='texttt'>Iterator</span> <a class='abbr_ref' href='iterators.iterator'>[iterators.iterator]</a></h3><div class='para' id='iterators.iterator-1'><div class='marginalizedparent'><a class='marginalized' href='#iterators.iterator-1'>1</a></div><p >The <span class='texttt'>Iterator</span> concept forms
the basis of the iterator concept taxonomy; every iterator satisfies the
<span class='texttt'>Iterator</span> requirements. This
concept specifies operations for dereferencing and incrementing
an iterator. Most algorithms will require additional operations
to compare iterators with sentinels (<a href='iterators.sentinel'>[iterators.sentinel]</a>), to
read (<a href='iterators.input'>[iterators.input]</a>) or write (<a href='iterators.output'>[iterators.output]</a>) values, or
to provide a richer set of iterator movements (<a href='iterators.forward'>[iterators.forward]</a>,
<a href='iterators.bidirectional'>[iterators.bidirectional]</a>, <a href='iterators.random.access'>[iterators.random.access]</a>).)</p><p ><span class='indexparent'><a class='index' id='Iterator'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool Iterator =
    requires(I i) {
      { *i } -&gt; auto&amp;&amp;; <span class='comment'>// Requires: i is dereferenceable
</span>    } &amp;&amp;
    WeaklyIncrementable&lt;I&gt;;
</pre></div><div class='para' id='iterators.iterator-2'><div class='marginalizedparent'><a class='marginalized' href='#iterators.iterator-2'>2</a></div><p >[&nbsp;<i>Note:</i> The requirement that the result of dereferencing the iterator is deducible from
<span class='texttt'>auto&amp;&amp;</span> means that it cannot be <span class='texttt'>void</span>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterators.sentinel'><h3 ><a class='secnum' href='#iterators.sentinel' style='min-width:103pt'>9.3.9</a> Concept <span class='texttt'>Sentinel</span> <a class='abbr_ref' href='iterators.sentinel'>[iterators.sentinel]</a></h3><div class='para' id='iterators.sentinel-1'><div class='marginalizedparent'><a class='marginalized' href='#iterators.sentinel-1'>1</a></div><p >The <span class='texttt'>Sentinel</span> concept
specifies the relationship
between an <span class='texttt'>Iterator</span> type and a <span class='texttt'>Semiregular</span> type whose values
denote a range.</p><p ><span class='indexparent'><a class='index' id='Sentinel'></a></span><code class='itemdecl'>
  template &lt;class S, class I&gt;
  concept bool Sentinel =
    Semiregular&lt;S&gt; &amp;&amp;
    Iterator&lt;I&gt; &amp;&amp;
    WeaklyEqualityComparableWith&lt;S, I&gt;;
</code></p></div><div class='itemdescr'></div><div class='para' id='iterators.sentinel-2'><div class='marginalizedparent'><a class='marginalized' href='#iterators.sentinel-2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'>s</span> and <span class='texttt'>i</span> be values of type <span class='texttt'>S</span> and
<span class='texttt'>I</span> such that <span class='texttt'>[i,s)</span> denotes a range. Types
<span class='texttt'>S</span> and <span class='texttt'>I</span> satisfy <span class='texttt'>Sentinel&lt;S, I&gt;</span> only if:</p><ul class='itemize'><li id='iterators.sentinel-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.sentinel-2.1'>(2.1)</a></div><p ><span class='texttt'>i == s</span> is well-defined.</p></li><li id='iterators.sentinel-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.sentinel-2.2'>(2.2)</a></div><p >If <span class='texttt'>bool(i != s)</span> then <span class='texttt'>i</span> is dereferenceable and
      <span class='texttt'>[++i,s)</span> denotes a range.
</p></li></ul></div></div><div class='para' id='iterators.sentinel-3'><div class='marginalizedparent'><a class='marginalized' href='#iterators.sentinel-3'>3</a></div><p >The domain of <span class='texttt'>==</span> can change over time.
Given an iterator <span class='texttt'>i</span> and sentinel <span class='texttt'>s</span> such that <span class='texttt'>[i,s)</span>
denotes a range and <span class='texttt'>i != s</span>, <span class='texttt'>[i,s)</span> is not required to continue to
denote a range after incrementing any iterator equal to <span class='texttt'>i</span>. Consequently,
<span class='texttt'>i == s</span> is no longer required to be well-defined.</p></div></div><div id='iterators.sizedsentinel'><h3 ><a class='secnum' href='#iterators.sizedsentinel' style='min-width:103pt'>9.3.10</a> Concept <span class='texttt'>SizedSentinel</span> <a class='abbr_ref' href='iterators.sizedsentinel'>[iterators.sizedsentinel]</a></h3><div class='para' id='iterators.sizedsentinel-1'><div class='marginalizedparent'><a class='marginalized' href='#iterators.sizedsentinel-1'>1</a></div><p >The <span class='texttt'>SizedSentinel</span> concept specifies
requirements on an <span class='texttt'>Iterator</span> and a <span class='texttt'>Sentinel</span>
that allow the use of the <span class='texttt'>-</span> operator to compute the distance
between them in constant time.</p><p ><span class='indexparent'><a class='index' id='SizedSentinel'></a></span>
<code class='itemdecl'>
  template &lt;class S, class I&gt;
  concept bool SizedSentinel =
    Sentinel&lt;S, I&gt; &amp;&amp;
    !disable_sized_sentinel&lt;remove_cv_t&lt;S&gt;, remove_cv_t&lt;I&gt;&gt; &amp;&amp;
    requires(const I&amp; i, const S&amp; s) {
      { s - i } -&gt; Same&lt;difference_type_t&lt;I&gt;&gt;&amp;&amp;;
      { i - s } -&gt; Same&lt;difference_type_t&lt;I&gt;&gt;&amp;&amp;;
    };
</code></p></div><div class='itemdescr'></div><div class='para' id='iterators.sizedsentinel-2'><div class='marginalizedparent'><a class='marginalized' href='#iterators.sizedsentinel-2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'>i</span> be an iterator of type <span class='texttt'>I</span>, and <span class='texttt'>s</span>
a sentinel of type <span class='texttt'>S</span> such that <span class='texttt'>[i,s)</span> denotes a range.
Let <span class='math'><span class='mathalpha'>N</span></span> be the smallest number of applications of <span class='texttt'>++i</span>
necessary to make <span class='texttt'>bool(i == s)</span> be <span class='texttt'>true</span>.
<span class='texttt'>SizedSentinel&lt;S, I&gt;</span> is satisfied only if:</p><ul class='itemize'><li id='iterators.sizedsentinel-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.sizedsentinel-2.1'>(2.1)</a></div><p >If <span class='math'><span class='mathalpha'>N</span></span> is representable by <span class='texttt'>difference_type_t&lt;I&gt;</span>,
      then <span class='texttt'>s - i</span> is well-defined and equals <span class='math'><span class='mathalpha'>N</span></span>.</p></li><li id='iterators.sizedsentinel-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.sizedsentinel-2.2'>(2.2)</a></div><p >If <span class='math'>-<span class='mathalpha'>N</span></span> is representable by <span class='texttt'>difference_type_t&lt;I&gt;</span>,
      then <span class='texttt'>i - s</span> is well-defined and equals <span class='math'>-<span class='mathalpha'>N</span></span>.
</p></li></ul></div></div><div class='para' id='iterators.sizedsentinel-3'><div class='marginalizedparent'><a class='marginalized' href='#iterators.sizedsentinel-3'>3</a></div><p >[&nbsp;<i>Note:</i> <span class='texttt'>disable_sized_sentinel</span> provides a mechanism to
enable use of sentinels and iterators with the library that meet the
syntactic requirements but do not in fact satisfy <span class='texttt'>SizedSentinel</span>.
A program that instantiates a library template that requires
<span class='texttt'>SizedSentinel</span> with an iterator type <span class='texttt'>I</span> and sentinel type
<span class='texttt'>S</span> that meet the syntactic requirements of <span class='texttt'>SizedSentinel&lt;S, I&gt;</span>
but do not satisfy <span class='texttt'>SizedSentinel</span> is ill-formed with no diagnostic required
unless <span class='texttt'>disable_sized_sentinel&lt;S, I&gt;</span> evaluates to
<span class='texttt'>true</span> (<a href='structure.requirements'>[structure.requirements]</a>). <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='iterators.sizedsentinel-4'><div class='marginalizedparent'><a class='marginalized' href='#iterators.sizedsentinel-4'>4</a></div><p >[&nbsp;<i>Note:</i> The <span class='texttt'>SizedSentinel</span>
concept is satisfied by pairs of
<span class='texttt'>RandomAccessIterator</span>s (<a href='iterators.random.access'>[iterators.random.access]</a>) and by
counted iterators and their sentinels (<a href='counted.iterator'>[counted.iterator]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterators.input'><h3 ><a class='secnum' href='#iterators.input' style='min-width:103pt'>9.3.11</a> Concept <span class='texttt'>InputIterator</span> <a class='abbr_ref' href='iterators.input'>[iterators.input]</a></h3><div class='para' id='iterators.input-1'><div class='marginalizedparent'><a class='marginalized' href='#iterators.input-1'>1</a></div><p >The <span class='texttt'>InputIterator</span> concept is a refinement of
<span class='texttt'>Iterator</span> (<a href='iterators.iterator'>[iterators.iterator]</a>). It
defines requirements for a type whose referenced values can be read (from the requirement for
<span class='texttt'>Readable</span> (<a href='iterators.readable'>[iterators.readable]</a>)) and which can be both pre- and post-incremented.
[&nbsp;<i>Note:</i> Unlike in ISO/IEC 14882, input iterators are not required to satisfy
<span class='texttt'>EqualityComparable</span> (<a href='concepts.lib.compare.equalitycomparable'>[concepts.lib.compare.equalitycomparable]</a>).<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='InputIterator'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool InputIterator =
    Iterator&lt;I&gt; &amp;&amp;
    Readable&lt;I&gt; &amp;&amp;
    requires { typename iterator_category_t&lt;I&gt;; } &amp;&amp;
    DerivedFrom&lt;iterator_category_t&lt;I&gt;, input_iterator_tag&gt;;
</pre></div></div><div id='iterators.output'><h3 ><a class='secnum' href='#iterators.output' style='min-width:103pt'>9.3.12</a> Concept <span class='texttt'>OutputIterator</span> <a class='abbr_ref' href='iterators.output'>[iterators.output]</a></h3><div class='para' id='iterators.output-1'><div class='marginalizedparent'><a class='marginalized' href='#iterators.output-1'>1</a></div><p >The <span class='texttt'>OutputIterator</span> concept is a refinement of
<span class='texttt'>Iterator</span> (<a href='iterators.iterator'>[iterators.iterator]</a>). It defines requirements for a type that
can be used to write values (from the requirement for
<span class='texttt'>Writable</span> (<a href='iterators.writable'>[iterators.writable]</a>)) and which can be both pre- and post-incremented.
However, output iterators are not required to
satisfy <span class='texttt'>EqualityComparable</span>.</p><p ><span class='indexparent'><a class='index' id='OutputIterator'></a></span></p><pre class='codeblock'>
  template &lt;class I, class T&gt;
  concept bool OutputIterator =
    Iterator&lt;I&gt; &amp;&amp; Writable&lt;I, T&gt; &amp;&amp;
    requires(I i, T&amp;&amp; t) {
      *i++ = std::forward(t); <span class='comment'>// not required to be equality preserving
</span>    };
</pre></div><div class='para' id='iterators.output-2'><div class='marginalizedparent'><a class='marginalized' href='#iterators.output-2'>2</a></div><p >Let <span class='texttt'>E</span> be an expression such that <span class='texttt'>decltype((E))</span> is <span class='texttt'>T</span>, and let <span class='texttt'>i</span> be a
dereferenceable object of type <span class='texttt'>I</span>. <span class='texttt'>OutputIterator&lt;I, T&gt;</span> is satisfied only if
<span class='texttt'>*i++ = E;</span> has effects equivalent to:
</p><pre class='codeblock'>
  *i = E;
  ++i;
</pre></div><div class='para' id='iterators.output-3'><div class='marginalizedparent'><a class='marginalized' href='#iterators.output-3'>3</a></div><p >[&nbsp;<i>Note:</i>
Algorithms on output iterators should never attempt to pass through the same iterator twice.
They should be
<a class='hidden_link' href='#def:single_pass' id='def:single_pass'><i>single pass</i></a>
algorithms.
Algorithms that take output iterators can be used with ostreams as the destination
for placing data through the
<span class='texttt'>ostream_iterator</span>
class as well as with insert iterators and insert pointers.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterators.forward'><h3 ><a class='secnum' href='#iterators.forward' style='min-width:103pt'>9.3.13</a> Concept <span class='texttt'>ForwardIterator</span> <a class='abbr_ref' href='iterators.forward'>[iterators.forward]</a></h3><div class='para' id='iterators.forward-1'><div class='marginalizedparent'><a class='marginalized' href='#iterators.forward-1'>1</a></div><p >The <span class='texttt'>ForwardIterator</span> concept refines <span class='texttt'>InputIterator</span> (<a href='iterators.input'>[iterators.input]</a>),
adding equality comparison and the multi-pass guarantee, specified below.</p><p ><span class='indexparent'><a class='index' id='ForwardIterator'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool ForwardIterator =
    InputIterator&lt;I&gt; &amp;&amp;
    DerivedFrom&lt;iterator_category_t&lt;I&gt;, forward_iterator_tag&gt; &amp;&amp;
    Incrementable&lt;I&gt; &amp;&amp;
    Sentinel&lt;I, I&gt;;
</pre></div><div class='para' id='iterators.forward-2'><div class='marginalizedparent'><a class='marginalized' href='#iterators.forward-2'>2</a></div><p >The domain of <span class='texttt'>==</span> for forward iterators is that of iterators over the same
underlying sequence. However, value-initialized iterators of the same type
may be compared and shall compare equal to other value-initialized iterators of the same type.
[&nbsp;<i>Note:</i> Value-initialized iterators behave as if they refer past the end of
the same empty sequence. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='iterators.forward-3'><div class='marginalizedparent'><a class='marginalized' href='#iterators.forward-3'>3</a></div><p >Pointers and references obtained from a forward iterator into a range <span class='texttt'>[i,s)</span>
shall remain valid while <span class='texttt'>[i,s)</span> continues to denote a range.</p></div><div class='para' id='iterators.forward-4'><div class='marginalizedparent'><a class='marginalized' href='#iterators.forward-4'>4</a></div><p >Two dereferenceable iterators <span class='texttt'>a</span> and <span class='texttt'>b</span> of type <span class='texttt'>X</span> offer the
<a class='hidden_link' href='#def:multi-pass_guarantee' id='def:multi-pass_guarantee'><i>multi-pass guarantee</i></a> if:</p><ul class='itemize'><li id='iterators.forward-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.forward-4.1'>(4.1)</a></div><p ><span class='texttt'>a == b</span> implies <span class='texttt'>++a == ++b</span> and
</p></li><li id='iterators.forward-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.forward-4.2'>(4.2)</a></div><p >The expression
<span class='texttt'>([](X x){++x;}(a), *a)</span> is equivalent to the expression <span class='texttt'>*a</span>.
</p></li></ul></div><div class='para' id='iterators.forward-5'><div class='marginalizedparent'><a class='marginalized' href='#iterators.forward-5'>5</a></div><p >[&nbsp;<i>Note:</i>
The requirement that
<span class='texttt'>a == b</span>
implies
<span class='texttt'>++a == ++b</span>
(which is not true for weaker iterators)
and the removal of the restrictions on the number of assignments through
a mutable iterator
(which applies to output iterators)
allow the use of multi-pass one-directional algorithms with forward iterators.
<i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterators.bidirectional'><h3 ><a class='secnum' href='#iterators.bidirectional' style='min-width:103pt'>9.3.14</a> Concept <span class='texttt'>BidirectionalIterator</span> <a class='abbr_ref' href='iterators.bidirectional'>[iterators.bidirectional]</a></h3><div class='para' id='iterators.bidirectional-1'><div class='marginalizedparent'><a class='marginalized' href='#iterators.bidirectional-1'>1</a></div><p >The <span class='texttt'>BidirectionalIterator</span> concept refines <span class='texttt'>ForwardIterator</span> (<a href='iterators.forward'>[iterators.forward]</a>),
and adds the ability to move an iterator backward as well as forward.</p><p ><span class='indexparent'><a class='index' id='BidirectionalIterator'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool BidirectionalIterator =
    ForwardIterator&lt;I&gt; &amp;&amp;
    DerivedFrom&lt;iterator_category_t&lt;I&gt;, bidirectional_iterator_tag&gt; &amp;&amp;
    requires(I i) {
      { --i } -&gt; Same&lt;I&gt;&amp;;
      { i-- } -&gt; Same&lt;I&gt;&amp;&amp;;
    };
</pre></div><div class='para' id='iterators.bidirectional-2'><div class='marginalizedparent'><a class='marginalized' href='#iterators.bidirectional-2'>2</a></div><p >A bidirectional iterator <span class='texttt'>r</span> is decrementable if and only if there exists some <span class='texttt'>s</span> such that
<span class='texttt'>++s == r</span>. Decrementable iterators <span class='texttt'>r</span> shall be in the domain of the expressions
<span class='texttt'>--r</span> and <span class='texttt'>r--</span>.</p></div><div class='para' id='iterators.bidirectional-3'><div class='marginalizedparent'><a class='marginalized' href='#iterators.bidirectional-3'>3</a></div><p >Let <span class='texttt'>a</span> and <span class='texttt'>b</span> be decrementable objects of type <span class='texttt'>I</span>.
<span class='texttt'>BidirectionalIterator&lt;I&gt;</span> is satisfied only if:</p><ul class='itemize'><li id='iterators.bidirectional-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.bidirectional-3.1'>(3.1)</a></div><p ><span class='texttt'>&amp;--a == &amp;a</span>.
</p></li><li id='iterators.bidirectional-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.bidirectional-3.2'>(3.2)</a></div><p >If <span class='texttt'>bool(a == b)</span>, then <span class='texttt'>bool(a-- == b)</span>.
</p></li><li id='iterators.bidirectional-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.bidirectional-3.3'>(3.3)</a></div><p >If <span class='texttt'>bool(a == b)</span>, then after evaluating both <span class='texttt'>a--</span> and <span class='texttt'>--b</span>,
<span class='texttt'>bool(a == b)</span> still holds.
</p></li><li id='iterators.bidirectional-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.bidirectional-3.4'>(3.4)</a></div><p >If <span class='texttt'>a</span> is incrementable and <span class='texttt'>bool(a == b)</span>, then
      <span class='texttt'>bool(--(++a) == b)</span>.
</p></li><li id='iterators.bidirectional-3.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.bidirectional-3.5'>(3.5)</a></div><p >If <span class='texttt'>bool(a == b)</span>, then <span class='texttt'>bool(++(--a) == b)</span>.
</p></li></ul></div></div><div id='iterators.random.access'><h3 ><a class='secnum' href='#iterators.random.access' style='min-width:103pt'>9.3.15</a> Concept <span class='texttt'>RandomAccessIterator</span> <a class='abbr_ref' href='iterators.random.access'>[iterators.random.access]</a></h3><div class='para' id='iterators.random.access-1'><div class='marginalizedparent'><a class='marginalized' href='#iterators.random.access-1'>1</a></div><p >The <span class='texttt'>RandomAccessIterator</span> concept refines <span class='texttt'>BidirectionalIterator</span> (<a href='iterators.bidirectional'>[iterators.bidirectional]</a>)
and adds support for constant-time advancement with <span class='texttt'>+=</span>, <span class='texttt'>+</span>,  <span class='texttt'>-=</span>, and <span class='texttt'>-</span>, and the
computation of distance in constant time with <span class='texttt'>-</span>. Random access iterators also support array
notation via subscripting.</p><p ><span class='indexparent'><a class='index' id='RandomAccessIterator'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool RandomAccessIterator =
    BidirectionalIterator&lt;I&gt; &amp;&amp;
    DerivedFrom&lt;iterator_category_t&lt;I&gt;, random_access_iterator_tag&gt; &amp;&amp;
    StrictTotallyOrdered&lt;I&gt; &amp;&amp;
    SizedSentinel&lt;I, I&gt; &amp;&amp;
    requires(I i, const I j, const difference_type_t&lt;I&gt; n) {
      { i += n } -&gt; Same&lt;I&gt;&amp;;
      { j + n }  -&gt; Same&lt;I&gt;&amp;&amp;;
      { n + j }  -&gt; Same&lt;I&gt;&amp;&amp;;
      { i -= n } -&gt; Same&lt;I&gt;&amp;;
      { j - n }  -&gt; Same&lt;I&gt;&amp;&amp;;
      j[n];
      requires Same&lt;decltype(j[n]), reference_t&lt;I&gt;&gt;;
    };
</pre></div><div class='para' id='iterators.random.access-2'><div class='marginalizedparent'><a class='marginalized' href='#iterators.random.access-2'>2</a></div><p >Let <span class='texttt'>a</span> and <span class='texttt'>b</span> be valid iterators of type <span class='texttt'>I</span> such that <span class='texttt'>b</span> is reachable
from <span class='texttt'>a</span>. Let <span class='texttt'>n</span> be the smallest value of type
<span class='texttt'>difference_type_t&lt;I&gt;</span> such that after
<span class='texttt'>n</span> applications of <span class='texttt'>++a</span>, then <span class='texttt'>bool(a == b)</span>.
<span class='texttt'>RandomAccessIterator&lt;I&gt;</span> is satisfied only if:</p><ul class='itemize'><li id='iterators.random.access-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.random.access-2.1'>(2.1)</a></div><p ><span class='texttt'>(a += n)</span> is equal to <span class='texttt'>b</span>.
</p></li><li id='iterators.random.access-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.random.access-2.2'>(2.2)</a></div><p ><span class='texttt'>&amp;(a += n)</span> is equal to <span class='texttt'>&amp;a</span>.
</p></li><li id='iterators.random.access-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.random.access-2.3'>(2.3)</a></div><p ><span class='texttt'>(a + n)</span> is equal to <span class='texttt'>(a += n)</span>.
</p></li><li id='iterators.random.access-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.random.access-2.4'>(2.4)</a></div><p >For any two positive integers <span class='texttt'>x</span> and <span class='texttt'>y</span>, if <span class='texttt'>a + (x + y)</span> is valid, then
<span class='texttt'>a + (x + y)</span> is equal to <span class='texttt'>(a + x) + y</span>.
</p></li><li id='iterators.random.access-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.random.access-2.5'>(2.5)</a></div><p ><span class='texttt'>a + 0</span> is equal to <span class='texttt'>a</span>.
</p></li><li id='iterators.random.access-2.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.random.access-2.6'>(2.6)</a></div><p >If <span class='texttt'>(a + (n - 1))</span> is valid, then <span class='texttt'>a + n</span> is equal to <span class='texttt'>++(a + (n - 1))</span>.
</p></li><li id='iterators.random.access-2.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.random.access-2.7'>(2.7)</a></div><p ><span class='texttt'>(b += -n)</span> is equal to <span class='texttt'>a</span>.
</p></li><li id='iterators.random.access-2.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.random.access-2.8'>(2.8)</a></div><p ><span class='texttt'>(b -= n)</span> is equal to <span class='texttt'>a</span>.
</p></li><li id='iterators.random.access-2.9'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.random.access-2.9'>(2.9)</a></div><p ><span class='texttt'>&amp;(b -= n)</span> is equal to <span class='texttt'>&amp;b</span>.
</p></li><li id='iterators.random.access-2.10'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.random.access-2.10'>(2.10)</a></div><p ><span class='texttt'>(b - n)</span> is equal to <span class='texttt'>(b -= n)</span>.
</p></li><li id='iterators.random.access-2.11'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterators.random.access-2.11'>(2.11)</a></div><p >If <span class='texttt'>b</span> is dereferenceable, then <span class='texttt'>a[n]</span> is valid and is equal to <span class='texttt'>*b</span>.
</p></li></ul></div></div></div></div></body></html>