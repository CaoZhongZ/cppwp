<!DOCTYPE html><html lang='en'><head><title>[iterators.weaklyincrementable]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>9</a> Iterators library <a class='abbr_ref' href='index.html#iterators'>[iterators]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>9.3</a> Iterator requirements <a class='abbr_ref' href='iterator.requirements.html#iterators.weaklyincrementable'>[iterator.requirements]</a></h2><div id='iterators.weaklyincrementable'><h3 ><a class='secnum' style='min-width:103pt'>9.3.6</a> Concept <span class='texttt'>WeaklyIncrementable</span> <a class='abbr_ref'>[iterators.weaklyincrementable]</a></h3><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >The <span class='texttt'>WeaklyIncrementable</span> concept specifies the requirements on
types that can be incremented with the pre- and post-increment operators.
The increment operations are not required to be equality-preserving,
nor is the type required to be <span class='texttt'>EqualityComparable</span>.</p><p ><span class='indexparent'><a class='index' id='WeaklyIncrementable'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool WeaklyIncrementable() {
    return Semiregular&lt;I&gt;() &amp;&amp;
      requires(I i) {
        typename difference_type_t&lt;I&gt;;
        requires SignedIntegral&lt;difference_type_t&lt;I&gt;&gt;();
        { ++i } -&gt; Same&lt;I&amp;&gt;; <span class='comment'>// not required to be equality preserving
</span>        i++; <span class='comment'>// not required to be equality preserving
</span>      };
  }
</pre></div><div class='para' id='2'><div class='marginalizedparent'><a class='marginalized' href='#2'>2</a></div><p >Let <span class='texttt'>i</span> be an object of type <span class='texttt'>I</span>. When both pre- and post-increment
are valid, <span class='texttt'>i</span> is said to be <i>incrementable</i>. Then
<span class='texttt'>WeaklyIncrementable&lt;I&gt;()</span> is satisfied if and only if</p><ul class='itemize'><li id='2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.1'>(2.1)</a></div><p ><span class='texttt'>++i</span> is valid if and only if <span class='texttt'>i++</span> is valid.
</p></li><li id='2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.2'>(2.2)</a></div><p >If <span class='texttt'>i</span> is incrementable, then both <span class='texttt'>++i</span>
  and <span class='texttt'>i++</span> advance <span class='texttt'>i</span> to the next element.
</p></li><li id='2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#2.3'>(2.3)</a></div><p >If <span class='texttt'>i</span> is incrementable, then <span class='texttt'>&amp;++i</span> is equal to <span class='texttt'>&amp;i</span>.
</p></li></ul></div><div class='para' id='3'><div class='marginalizedparent'><a class='marginalized' href='#3'>3</a></div><p >[&nbsp;<i>Note:</i> For <span class='texttt'>WeaklyIncrementable</span> types, <span class='texttt'>a</span> equals <span class='texttt'>b</span> does not imply that <span class='texttt'>++a</span>
equals <span class='texttt'>++b</span>. (Equality does not guarantee the substitution property or referential
transparency.) Algorithms on weakly incrementable types should never attempt to pass
through the same incrementable value twice. They should be single pass algorithms. These algorithms
can be used with istreams as the source of the input data through the <span class='texttt'>istream_iterator</span> class
template.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div></div></body></html>