<!DOCTYPE html><html lang='en'><head><title>[concepts.lib.object]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>7</a> Concepts library <a class='abbr_ref' href='./#concepts.lib'>[concepts.lib]</a></h1><div id='concepts.lib.object'><h2 ><a class='secnum' style='min-width:88pt'>7.5</a> Object concepts <a class='abbr_ref'>[concepts.lib.object]</a></h2><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><p >This section describes concepts that specify the basis of the
value-oriented programming style on which the library is based.

</p></div><div id='destructible'><h3 ><a class='secnum' href='#destructible' style='min-width:103pt'>7.5.1</a> Concept <span class='texttt'>Destructible</span> <a class='abbr_ref' href='concepts.lib.object.destructible'>[concepts.lib.object.destructible]</a></h3><div class='para' id='destructible-1'><div class='marginalizedparent'><a class='marginalized' href='#destructible-1'>1</a></div><p >The <span class='texttt'>Destructible</span> concept is the base of the hierarchy of object concepts.
It specifies properties that all such object types have in common.</p><p ><span class='indexparent'><a class='index' id='Destructible'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Destructible() {
  return requires(T t, const T ct, T* p) {
    { t.<span class='math'>~</span>T() } noexcept;
    { &amp;t } -&gt; Same&lt;T*&gt;; <span class='comment'>// not required to be equality preserving
</span>    { &amp;ct } -&gt; Same&lt;const T*&gt;; <span class='comment'>// not required to be equality preserving
</span>    delete p;
    delete[] p;
  };
}
</code></p></div><div class='itemdescr'></div><div class='para' id='destructible-2'><div class='marginalizedparent'><a class='marginalized' href='#destructible-2'>2</a></div><div class='itemdescr'><p >The expression requirement <span class='texttt'>&amp;ct</span> does not require implicit expression variants.</p></div></div><div class='para' id='destructible-3'><div class='marginalizedparent'><a class='marginalized' href='#destructible-3'>3</a></div><div class='itemdescr'><p >Given a (possibly <span class='texttt'>const</span>) lvalue <span class='texttt'>t</span> of type <span class='texttt'>T</span> and pointer
<span class='texttt'>p</span> of type <span class='texttt'>T*</span>, <span class='texttt'>Destructible&lt;T&gt;()</span> is satisfied if and only if</p><ul class='itemize'><li id='destructible-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#destructible-3.1'>(3.1)</a></div><p >After evaluating the expression <span class='texttt'>t.<span class='math'>~</span>T()</span>,
<span class='texttt'>delete p</span>, or <span class='texttt'>delete[] p</span>, all resources owned by
the denoted object(s) are reclaimed.
</p></li><li id='destructible-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#destructible-3.2'>(3.2)</a></div><p ><span class='texttt'>&amp;t == addressof(t)</span>.
</p></li><li id='destructible-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#destructible-3.3'>(3.3)</a></div><p >The expression <span class='texttt'>&amp;t</span> is non-modifying.
</p></li></ul></div></div><div class='para' id='destructible-4'><div class='marginalizedparent'><a class='marginalized' href='#destructible-4'>4</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> Unlike the <span class='texttt'>Destructible</span> library concept in the C++
Standard (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> utility.arg.requirements <span class='endcsname'></span>), this concept forbids destructors
that are <span class='texttt'>noexcept(false)</span>, even if non-throwing. <i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='constructible'><h3 ><a class='secnum' href='#constructible' style='min-width:103pt'>7.5.2</a> Concept <span class='texttt'>Constructible</span> <a class='abbr_ref' href='concepts.lib.object.constructible'>[concepts.lib.object.constructible]</a></h3><div class='para' id='constructible-1'><div class='marginalizedparent'><a class='marginalized' href='#constructible-1'>1</a></div><p >The <span class='texttt'>Constructible</span> concept is used to constrain the type of a
variable to be either an object type constructible from a given set of argument
types, or a reference type that can be bound to those arguments.</p><p ><span class='indexparent'><a class='index' id='Constructible'></a></span><code class='itemdecl'>
template &lt;class T, class... Args&gt;
concept bool __ConstructibleObject = <span class='comment'>// <i>exposition only</i>
</span>  Destructible&lt;T&gt;() &amp;&amp; requires(Args&amp;&amp;... args) {
    T{std::forward&lt;Args&gt;(args)...}; <span class='comment'>// not required to be equality preserving
</span>    new T{std::forward&lt;Args&gt;(args)...}; <span class='comment'>// not required to be equality preserving
</span>  };

template &lt;class T, class... Args&gt;
concept bool __BindableReference = <span class='comment'>// <i>exposition only</i>
</span>  is_reference&lt;T&gt;::value &amp;&amp; requires(Args&amp;&amp;... args) {
    T(std::forward&lt;Args&gt;(args)...);
  };

template &lt;class T, class... Args&gt;
concept bool Constructible() {
  return __ConstructibleObject&lt;T, Args...&gt; ||
    __BindableReference&lt;T, Args...&gt;;
}
</code></p></div></div><div id='defaultconstructible'><h3 ><a class='secnum' href='#defaultconstructible' style='min-width:103pt'>7.5.3</a> Concept <span class='texttt'>DefaultConstructible</span> <a class='abbr_ref' href='concepts.lib.object.defaultconstructible'>[concepts.lib.object.defaultconstructible]</a></h3><p ><span class='indexparent'><a class='index' id='DefaultConstructible'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool DefaultConstructible() {
  return Constructible&lt;T&gt;() &amp;&amp;
    requires(const size_t n) {
      new T[n]{}; <span class='comment'>// not required to be equality preserving
</span>    };
}
</code></p><div class='para' id='defaultconstructible-1'><div class='marginalizedparent'><a class='marginalized' href='#defaultconstructible-1'>1</a></div><p >[&nbsp;<i>Note:</i> The array allocation expression <span class='texttt'>new T[n]{}</span> implicitly
requires that <span class='texttt'>T</span> has a non-explicit default constructor. <i>&nbsp;—&nbsp;end note</i>&nbsp;]</p></div></div><div id='moveconstructible'><h3 ><a class='secnum' href='#moveconstructible' style='min-width:103pt'>7.5.4</a> Concept <span class='texttt'>MoveConstructible</span> <a class='abbr_ref' href='concepts.lib.object.moveconstructible'>[concepts.lib.object.moveconstructible]</a></h3><p ><span class='indexparent'><a class='index' id='MoveConstructible'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool MoveConstructible() {
  return Constructible&lt;T, remove_cv_t&lt;T&gt;&amp;&amp;&gt;() &amp;&amp;
    ConvertibleTo&lt;remove_cv_t&lt;T&gt;&amp;&amp;, T&gt;();
}
</code></p><div class='itemdescr'></div><div class='para' id='moveconstructible-1'><div class='marginalizedparent'><a class='marginalized' href='#moveconstructible-1'>1</a></div><div class='itemdescr'><p >Let <span class='texttt'>U</span> be the type <span class='texttt'>remove_cv_t&lt;T&gt;</span>,
<span class='texttt'>rv</span> be an rvalue of type <span class='texttt'>U</span>,
and <span class='texttt'>u2</span> be a distinct object of type <span class='texttt'>T</span> equal to <span class='texttt'>rv</span>.
Then <span class='texttt'>MoveConstructible&lt;T&gt;()</span> is satisfied if and only if</p><ul class='itemize'><li id='moveconstructible-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#moveconstructible-1.1'>(1.1)</a></div><p >After the definition <span class='texttt'>T u = rv;</span>, <span class='texttt'>u</span> is equal to <span class='texttt'>u2</span>.
</p></li><li id='moveconstructible-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#moveconstructible-1.2'>(1.2)</a></div><p ><span class='texttt'>T{rv}</span> or <span class='texttt'>*new T{rv}</span> is equal to <span class='texttt'>u2</span>.
</p></li></ul></div></div><div class='para' id='moveconstructible-2'><div class='marginalizedparent'><a class='marginalized' href='#moveconstructible-2'>2</a></div><div class='itemdescr'><p ><span class='texttt'>rv</span>'s resulting state is valid but unspecified (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> lib.types.movedfrom <span class='endcsname'></span>).</p></div></div></div><div id='copyconstructible'><h3 ><a class='secnum' href='#copyconstructible' style='min-width:103pt'>7.5.5</a> Concept <span class='texttt'>CopyConstructible</span> <a class='abbr_ref' href='concepts.lib.object.copyconstructible'>[concepts.lib.object.copyconstructible]</a></h3><p ><span class='indexparent'><a class='index' id='CopyConstructible'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool CopyConstructible() {
  return MoveConstructible&lt;T&gt;() &amp;&amp;
    Constructible&lt;T, const remove_cv_t&lt;T&gt;&amp;&gt;() &amp;&amp;
    ConvertibleTo&lt;remove_cv_t&lt;T&gt;&amp;, T&gt;() &amp;&amp;
    ConvertibleTo&lt;const remove_cv_t&lt;T&gt;&amp;, T&gt;() &amp;&amp;
    ConvertibleTo&lt;const remove_cv_t&lt;T&gt;&amp;&amp;, T&gt;();
}
</code></p><div class='itemdescr'></div><div class='para' id='copyconstructible-1'><div class='marginalizedparent'><a class='marginalized' href='#copyconstructible-1'>1</a></div><div class='itemdescr'><p >Let <span class='texttt'>v</span> be an lvalue of type (possibly <span class='texttt'>const</span>)
<span class='texttt'>remove_cv_t&lt;T&gt;</span> or an rvalue of type <span class='texttt'>const remove_cv_t&lt;T&gt;</span>.
Then <span class='texttt'>CopyConstructible&lt;T&gt;()</span> is satisfied if and only if</p><ul class='itemize'><li id='copyconstructible-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#copyconstructible-1.1'>(1.1)</a></div><p >After the definition <span class='texttt'>T u = v;</span>, <span class='texttt'>u</span> is equal
to <span class='texttt'>v</span>.
</p></li><li id='copyconstructible-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#copyconstructible-1.2'>(1.2)</a></div><p ><span class='texttt'>T{v}</span> or <span class='texttt'>*new T{v}</span> is equal
to <span class='texttt'>v</span>.
</p></li></ul></div></div></div><div id='movable'><h3 ><a class='secnum' href='#movable' style='min-width:103pt'>7.5.6</a> Concept <span class='texttt'>Movable</span> <a class='abbr_ref' href='concepts.lib.object.movable'>[concepts.lib.object.movable]</a></h3><p ><span class='indexparent'><a class='index' id='Movable'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Movable() {
  return MoveConstructible&lt;T&gt;() &amp;&amp;
    Assignable&lt;T&amp;, T&gt;() &amp;&amp;
    Swappable&lt;T&amp;&gt;();
}
</code></p></div><div id='copyable'><h3 ><a class='secnum' href='#copyable' style='min-width:103pt'>7.5.7</a> Concept <span class='texttt'>Copyable</span> <a class='abbr_ref' href='concepts.lib.object.copyable'>[concepts.lib.object.copyable]</a></h3><p ><span class='indexparent'><a class='index' id='Copyable'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Copyable() {
  return CopyConstructible&lt;T&gt;() &amp;&amp;
    Movable&lt;T&gt;() &amp;&amp;
    Assignable&lt;T&amp;, const T&amp;&gt;();
}
</code></p></div><div id='semiregular'><h3 ><a class='secnum' href='#semiregular' style='min-width:103pt'>7.5.8</a> Concept <span class='texttt'>Semiregular</span> <a class='abbr_ref' href='concepts.lib.object.semiregular'>[concepts.lib.object.semiregular]</a></h3><p ><span class='indexparent'><a class='index' id='Semiregular'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Semiregular() {
  return Copyable&lt;T&gt;() &amp;&amp;
    DefaultConstructible&lt;T&gt;();
}
</code></p><div class='itemdescr'></div><div class='para' id='semiregular-1'><div class='marginalizedparent'><a class='marginalized' href='#semiregular-1'>1</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The <span class='texttt'>Semiregular</span> concept is satisfied by types that
behave similarly to built-in types like <span class='texttt'>int</span>, except that they may not be
comparable with <span class='texttt'>==</span>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='regular'><h3 ><a class='secnum' href='#regular' style='min-width:103pt'>7.5.9</a> Concept <span class='texttt'>Regular</span> <a class='abbr_ref' href='concepts.lib.object.regular'>[concepts.lib.object.regular]</a></h3><p ><span class='indexparent'><a class='index' id='Regular'></a></span><code class='itemdecl'>
template &lt;class T&gt;
concept bool Regular() {
  return Semiregular&lt;T&gt;() &amp;&amp;
    EqualityComparable&lt;T&gt;();
}
</code></p><div class='itemdescr'></div><div class='para' id='regular-1'><div class='marginalizedparent'><a class='marginalized' href='#regular-1'>1</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The <span class='texttt'>Regular</span> concept is satisfied by types that behave
similarly to built-in types like <span class='texttt'>int</span> and that are comparable with <span class='texttt'>==</span>.<i>&nbsp;—&nbsp;end note</i>&nbsp;]
</p></div></div></div></div></div></body></html>