<!DOCTYPE html><html lang='en'><head><title>[iterator.synopsis]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>9</a> Iterators library <a class='abbr_ref' href='./#iterators'>[iterators]</a></h1><div id='iterator.synopsis'><h2 ><a class='secnum' style='min-width:88pt'>9.2</a> Header <span class='texttt'>&lt;experimental/ranges/iterator&gt;</span> synopsis <a class='abbr_ref'>[iterator.synopsis]</a></h2><p ><span class='indexparent'><a class='index' id='experimental/ranges/iterator'></a></span></p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;class T&gt; concept bool <i>dereferenceable</i> <span class='comment'>// <i>exposition only</i>
</span>    = requires(T&amp; t) { {*t} -&gt; auto&amp;&amp;; };

  <span class='comment'>// <a href='iterator.requirements'>[iterator.requirements]</a>, iterator requirements:
</span>  <span class='comment'>// <a href='iterator.custpoints'>[iterator.custpoints]</a>, customization points:
</span>  namespace {
    <span class='comment'>// <a href='iterator.custpoints.iter_move'>[iterator.custpoints.iter_move]</a>, iter_move:
</span>    constexpr <i><span class='texttt'>unspecified</span></i> iter_move = <i><span class='texttt'>unspecified</span></i>;

    <span class='comment'>// <a href='iterator.custpoints.iter_swap'>[iterator.custpoints.iter_swap]</a>, iter_swap:
</span>    constexpr <i><span class='texttt'>unspecified</span></i> iter_swap = <i><span class='texttt'>unspecified</span></i>;
  }

  <span class='comment'>// <a href='iterator.assoc.types'>[iterator.assoc.types]</a>, associated types:
</span>  <span class='comment'>// <a href='iterator.assoc.types.difference_type'>[iterator.assoc.types.difference_type]</a>, difference_type:
</span>  template &lt;class&gt; struct difference_type;
  template &lt;class T&gt; using difference_type_t
    = typename difference_type&lt;T&gt;::type;

  <span class='comment'>// <a href='iterator.assoc.types.value_type'>[iterator.assoc.types.value_type]</a>, value_type:
</span>  template &lt;class&gt; struct value_type;
  template &lt;class T&gt; using value_type_t
    = typename value_type&lt;T&gt;::type;

  <span class='comment'>// <a href='iterator.assoc.types.iterator_category'>[iterator.assoc.types.iterator_category]</a>, iterator_category:
</span>  template &lt;class&gt; struct iterator_category;
  template &lt;class T&gt; using iterator_category_t
    = typename iterator_category&lt;T&gt;::type;

  template &lt;<i>dereferenceable</i> T&gt; using reference_t
    = decltype(*declval&lt;T&amp;&gt;());

  template &lt;<i>dereferenceable</i> T&gt;
      requires <i><span class='texttt'>see below</span></i> using rvalue_reference_t
    = decltype(ranges::iter_move(declval&lt;T&amp;&gt;()));

  <span class='comment'>// <a href='iterators.readable'>[iterators.readable]</a>, Readable:
</span>  template &lt;class In&gt;
  concept bool Readable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='iterators.writable'>[iterators.writable]</a>, Writable:
</span>  template &lt;class Out, class T&gt;
  concept bool Writable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='iterators.weaklyincrementable'>[iterators.weaklyincrementable]</a>, WeaklyIncrementable:
</span>  template &lt;class I&gt;
  concept bool WeaklyIncrementable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='iterators.incrementable'>[iterators.incrementable]</a>, Incrementable:
</span>  template &lt;class I&gt;
  concept bool Incrementable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='iterators.iterator'>[iterators.iterator]</a>, Iterator:
</span>  template &lt;class I&gt;
  concept bool Iterator = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='iterators.sentinel'>[iterators.sentinel]</a>, Sentinel:
</span>  template &lt;class S, class I&gt;
  concept bool Sentinel = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='iterators.sizedsentinel'>[iterators.sizedsentinel]</a>, SizedSentinel:
</span>  template &lt;class S, class I&gt;
    constexpr bool disable_sized_sentinel = false;

  template &lt;class S, class I&gt;
  concept bool SizedSentinel = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='iterators.input'>[iterators.input]</a>, InputIterator:
</span>  template &lt;class I&gt;
  concept bool InputIterator = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='iterators.output'>[iterators.output]</a>, OutputIterator:
</span>  template &lt;class I&gt;
  concept bool OutputIterator = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='iterators.forward'>[iterators.forward]</a>, ForwardIterator:
</span>  template &lt;class I&gt;
  concept bool ForwardIterator = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='iterators.bidirectional'>[iterators.bidirectional]</a>, BidirectionalIterator:
</span>  template &lt;class I&gt;
  concept bool BidirectionalIterator = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='iterators.random.access'>[iterators.random.access]</a>, RandomAccessIterator:
</span>  template &lt;class I&gt;
  concept bool RandomAccessIterator = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='indirectcallable'>[indirectcallable]</a>, indirect callable requirements:
</span>  <span class='comment'>// <a href='indirectcallable.indirectinvocable'>[indirectcallable.indirectinvocable]</a>, indirect callables:
</span>  template &lt;class F, class I&gt;
  concept bool IndirectUnaryInvocable = <i><span class='texttt'>see below</span></i>;

  template &lt;class F, class I&gt;
  concept bool IndirectRegularUnaryInvocable = <i><span class='texttt'>see below</span></i>;

  template &lt;class F, class I&gt;
  concept bool IndirectUnaryPredicate = <i><span class='texttt'>see below</span></i>;

  template &lt;class F, class I1, class I2 = I1&gt;
  concept bool IndirectRelation = <i><span class='texttt'>see below</span></i>;

  template &lt;class F, class I1, class I2 = I1&gt;
  concept bool IndirectStrictWeakOrder = <i><span class='texttt'>see below</span></i>;

  template &lt;class&gt; struct indirect_result_of;

  template &lt;class F, class... Is&gt;
    requires Invocable&lt;F, reference_t&lt;Is&gt;...&gt;
  struct indirect_result_of&lt;F(Is...)&gt;;

  template &lt;class F&gt;
  using indirect_result_of_t
    = typename indirect_result_of&lt;F&gt;::type;

  <span class='comment'>// <a href='projected'>[projected]</a>, projected:
</span>  template &lt;Readable I, IndirectRegularUnaryInvocable&lt;I&gt; Proj&gt;
  struct projected;

  template &lt;WeaklyIncrementable I, class Proj&gt;
  struct difference_type&lt;projected&lt;I, Proj&gt;&gt;;

  <span class='comment'>// <a href='commonalgoreq'>[commonalgoreq]</a>, common algorithm requirements:
</span>  <span class='comment'>// <a href='commonalgoreq.indirectlymovable'>[commonalgoreq.indirectlymovable]</a> IndirectlyMovable:
</span>  template &lt;class In, class Out&gt;
  concept bool IndirectlyMovable = <i><span class='texttt'>see below</span></i>;

  template &lt;class In, class Out&gt;
  concept bool IndirectlyMovableStorable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='commonalgoreq.indirectlycopyable'>[commonalgoreq.indirectlycopyable]</a> IndirectlyCopyable:
</span>  template &lt;class In, class Out&gt;
  concept bool IndirectlyCopyable = <i><span class='texttt'>see below</span></i>;

  template &lt;class In, class Out&gt;
  concept bool IndirectlyCopyableStorable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='commonalgoreq.indirectlyswappable'>[commonalgoreq.indirectlyswappable]</a> IndirectlySwappable:
</span>  template &lt;class I1, class I2 = I1&gt;
  concept bool IndirectlySwappable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='commonalgoreq.indirectlycomparable'>[commonalgoreq.indirectlycomparable]</a> IndirectlyComparable:
</span>  template &lt;class I1, class I2, class R = equal_to&lt;&gt;, class P1 = identity,
      class P2 = identity&gt;
  concept bool IndirectlyComparable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='commonalgoreq.permutable'>[commonalgoreq.permutable]</a> Permutable:
</span>  template &lt;class I&gt;
  concept bool Permutable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='commonalgoreq.mergeable'>[commonalgoreq.mergeable]</a> Mergeable:
</span>  template &lt;class I1, class I2, class Out,
      class R = less&lt;&gt;, class P1 = identity, class P2 = identity&gt;
  concept bool Mergeable = <i><span class='texttt'>see below</span></i>;

  template &lt;class I, class R = less&lt;&gt;, class P = identity&gt;
  concept bool Sortable = <i><span class='texttt'>see below</span></i>;

  <span class='comment'>// <a href='iterator.primitives'>[iterator.primitives]</a>, primitives:
</span>  <span class='comment'>// <a href='iterator.traits'>[iterator.traits]</a>, traits:
</span>  template &lt;class Iterator&gt; using iterator_traits = <i><span class='texttt'>see below</span></i>;

  template &lt;Readable T&gt; using iter_common_reference_t
    = common_reference_t&lt;reference_t&lt;T&gt;, value_type_t&lt;T&gt;&amp;&gt;;

  <span class='comment'>// <a href='std.iterator.tags'>[std.iterator.tags]</a>, iterator tags:
</span>  struct output_iterator_tag { };
  struct input_iterator_tag { };
  struct forward_iterator_tag : input_iterator_tag { };
  struct bidirectional_iterator_tag : forward_iterator_tag { };
  struct random_access_iterator_tag : bidirectional_iterator_tag { };

  <span class='comment'>// <a href='iterator.operations'>[iterator.operations]</a>, iterator operations:
</span>  namespace {
    constexpr <i><span class='texttt'>unspecified</span></i> advance = <i><span class='texttt'>unspecified</span></i>;
    constexpr <i><span class='texttt'>unspecified</span></i> distance = <i><span class='texttt'>unspecified</span></i>;
    constexpr <i><span class='texttt'>unspecified</span></i> next = <i><span class='texttt'>unspecified</span></i>;
    constexpr <i><span class='texttt'>unspecified</span></i> prev = <i><span class='texttt'>unspecified</span></i>;
  }

  <span class='comment'>// <a href='iterators.predef'>[iterators.predef]</a>, predefined iterators and sentinels:
</span>
  <span class='comment'>// <a href='iterators.reverse'>[iterators.reverse]</a>, reverse iterators:
</span>  template &lt;BidirectionalIterator I&gt; class reverse_iterator;

  template &lt;class I1, class I2&gt;
      requires EqualityComparableWith&lt;I1, I2&gt;
    constexpr bool operator==(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires EqualityComparableWith&lt;I1, I2&gt;
    constexpr bool operator!=(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrderedWith&lt;I1, I2&gt;
    constexpr bool operator&lt;(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrderedWith&lt;I1, I2&gt;
    constexpr bool operator&gt;(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrderedWith&lt;I1, I2&gt;
    constexpr bool operator&gt;=(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrderedWith&lt;I1, I2&gt;
    constexpr bool operator&lt;=(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);

  template &lt;class I1, class I2&gt;
      requires SizedSentinel&lt;I1, I2&gt;
    constexpr difference_type_t&lt;I2&gt; operator-(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;RandomAccessIterator I&gt;
    constexpr reverse_iterator&lt;I&gt; operator+(
      difference_type_t&lt;I&gt; n,
      const reverse_iterator&lt;I&gt;&amp; x);

  template &lt;BidirectionalIterator I&gt;
    constexpr reverse_iterator&lt;I&gt; make_reverse_iterator(I i);

  <span class='comment'>// <a href='iterators.insert'>[iterators.insert]</a>, insert iterators:
</span>  template &lt;class Container&gt; class back_insert_iterator;
  template &lt;class Container&gt;
    back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; x);

  template &lt;class Container&gt; class front_insert_iterator;
  template &lt;class Container&gt;
    front_insert_iterator&lt;Container&gt; front_inserter(Container&amp; x);

  template &lt;class Container&gt; class insert_iterator;
  template &lt;class Container&gt;
    insert_iterator&lt;Container&gt; inserter(Container&amp; x, iterator_t&lt;Container&gt; i);

  <span class='comment'>// <a href='iterators.move'>[iterators.move]</a>, move iterators and sentinels:
</span>  template &lt;InputIterator I&gt; class move_iterator;
  template &lt;class I1, class I2&gt;
      requires EqualityComparableWith&lt;I1, I2&gt;
    constexpr bool operator==(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires EqualityComparableWith&lt;I1, I2&gt;
    constexpr bool operator!=(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrderedWith&lt;I1, I2&gt;
    constexpr bool operator&lt;(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrderedWith&lt;I1, I2&gt;
    constexpr bool operator&lt;=(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrderedWith&lt;I1, I2&gt;
    constexpr bool operator&gt;(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrderedWith&lt;I1, I2&gt;
    constexpr bool operator&gt;=(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);

  template &lt;class I1, class I2&gt;
      requires SizedSentinel&lt;I1, I2&gt;
    constexpr difference_type_t&lt;I2&gt; operator-(
      const move_iterator&lt;I1&gt;&amp; x,
      const move_iterator&lt;I2&gt;&amp; y);
  template &lt;RandomAccessIterator I&gt;
    constexpr move_iterator&lt;I&gt; operator+(
      difference_type_t&lt;I&gt; n,
      const move_iterator&lt;I&gt;&amp; x);
  template &lt;InputIterator I&gt;
    constexpr move_iterator&lt;I&gt; make_move_iterator(I i);

  template &lt;Semiregular S&gt; class move_sentinel;

  template &lt;class I, Sentinel&lt;I&gt; S&gt;
    constexpr bool operator==(
      const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);
  template &lt;class I, Sentinel&lt;I&gt; S&gt;
    constexpr bool operator==(
      const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);
  template &lt;class I, Sentinel&lt;I&gt; S&gt;
    constexpr bool operator!=(
      const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);
  template &lt;class I, Sentinel&lt;I&gt; S&gt;
    constexpr bool operator!=(
      const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);

  template &lt;class I, SizedSentinel&lt;I&gt; S&gt;
    constexpr difference_type_t&lt;I&gt; operator-(
      const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);
  template &lt;class I, SizedSentinel&lt;I&gt; S&gt;
    constexpr difference_type_t&lt;I&gt; operator-(
      const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);

  template &lt;Semiregular S&gt;
    constexpr move_sentinel&lt;S&gt; make_move_sentinel(S s);

  <span class='comment'>// <a href='iterators.common'>[iterators.common]</a>, common iterators:
</span>  template &lt;Iterator I, Sentinel&lt;I&gt; S&gt;
    requires !Same&lt;I, S&gt;
  class common_iterator;

  template &lt;Readable I, class S&gt;
  struct value_type&lt;common_iterator&lt;I, S&gt;&gt;;

  template &lt;InputIterator I, class S&gt;
  struct iterator_category&lt;common_iterator&lt;I, S&gt;&gt;;

  template &lt;ForwardIterator I, class S&gt;
  struct iterator_category&lt;common_iterator&lt;I, S&gt;&gt;;

  template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
  bool operator==(
    const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
  template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
    requires EqualityComparableWith&lt;I1, I2&gt;
  bool operator==(
    const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
  template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
  bool operator!=(
    const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);

  template &lt;class I2, SizedSentinel&lt;I2&gt; I1, SizedSentinel&lt;I2&gt; S1, SizedSentinel&lt;I1&gt; S2&gt;
  difference_type_t&lt;I2&gt; operator-(
    const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);

  <span class='comment'>// <a href='default.sentinels'>[default.sentinels]</a>, default sentinels:
</span>  class default_sentinel;

  <span class='comment'>// <a href='iterators.counted'>[iterators.counted]</a>, counted iterators:
</span>  template &lt;Iterator I&gt; class counted_iterator;

  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;
    constexpr bool operator==(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  constexpr bool operator==(
    const counted_iterator&lt;auto&gt;&amp; x, default_sentinel);
  constexpr bool operator==(
    default_sentinel, const counted_iterator&lt;auto&gt;&amp; x);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;
    constexpr bool operator!=(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  constexpr bool operator!=(
    const counted_iterator&lt;auto&gt;&amp; x, default_sentinel y);
  constexpr bool operator!=(
    default_sentinel x, const counted_iterator&lt;auto&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;
    constexpr bool operator&lt;(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;
    constexpr bool operator&lt;=(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;
    constexpr bool operator&gt;(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;
    constexpr bool operator&gt;=(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;
    constexpr difference_type_t&lt;I2&gt; operator-(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I&gt;
    constexpr difference_type_t&lt;I&gt; operator-(
      const counted_iterator&lt;I&gt;&amp; x, default_sentinel y);
  template &lt;class I&gt;
    constexpr difference_type_t&lt;I&gt; operator-(
      default_sentinel x, const counted_iterator&lt;I&gt;&amp; y);
  template &lt;RandomAccessIterator I&gt;
    constexpr counted_iterator&lt;I&gt;
      operator+(difference_type_t&lt;I&gt; n, const counted_iterator&lt;I&gt;&amp; x);
  template &lt;Iterator I&gt;
    constexpr counted_iterator&lt;I&gt; make_counted_iterator(I i, difference_type_t&lt;I&gt; n);

  <span class='comment'>// <a href='unreachable.sentinels'>[unreachable.sentinels]</a>, unreachable sentinels:
</span>  class unreachable;
  template &lt;Iterator I&gt;
    constexpr bool operator==(const I&amp;, unreachable) noexcept;
  template &lt;Iterator I&gt;
    constexpr bool operator==(unreachable, const I&amp;) noexcept;
  template &lt;Iterator I&gt;
    constexpr bool operator!=(const I&amp;, unreachable) noexcept;
  template &lt;Iterator I&gt;
    constexpr bool operator!=(unreachable, const I&amp;) noexcept;

  <span class='comment'>// <a href='dangling.wrappers'>[dangling.wrappers]</a>, dangling wrapper:
</span>  template &lt;class T&gt; class dangling;

  <span class='comment'>// <a href='iterators.stream'>[iterators.stream]</a>, stream iterators:
</span>  template &lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;,
      class Distance = ptrdiff_t&gt;
  class istream_iterator;
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator==(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
            const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator==(default_sentinel x,
            const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator==(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
            default_sentinel y);
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator!=(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
            const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
  template &lt;class T, class charT, class traits, class Distance&gt;
   bool operator!=(default_sentinel x,
            const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator!=(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
            default_sentinel y);

  template &lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;&gt;
      class ostream_iterator;

  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
    class istreambuf_iterator;
  template &lt;class charT, class traits&gt;
    bool operator==(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
            const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
  template &lt;class charT, class traits&gt;
    bool operator==(default_sentinel a,
            const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
  template &lt;class charT, class traits&gt;
    bool operator==(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
            default_sentinel b);
  template &lt;class charT, class traits&gt;
    bool operator!=(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
            const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
  template &lt;class charT, class traits&gt;
    bool operator!=(default_sentinel a,
            const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
  template &lt;class charT, class traits&gt;
    bool operator!=(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
            default_sentinel b);

  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
    class ostreambuf_iterator;
}}}}

namespace std {
  <span class='comment'>// <a href='iterator.stdtraits'>[iterator.stdtraits]</a>, iterator traits:
</span>  template &lt;experimental::ranges::Iterator Out&gt;
    struct iterator_traits&lt;Out&gt;;
  template &lt;experimental::ranges::InputIterator In&gt;
    struct iterator_traits&lt;In&gt;;
  template &lt;experimental::ranges::InputIterator In&gt;
      requires experimental::ranges::Sentinel&lt;In, In&gt;
    struct iterator_traits;
}
</pre></div></div></body></html>