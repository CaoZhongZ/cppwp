<!DOCTYPE html><html lang='en'><head><title>[iterators]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/></head><body><div class='wrapper'><div id='iterators'><h1 ><a class='secnum' style='min-width:73pt'>9</a> Iterators library <a class='abbr_ref' href='index.html#iterators'>[iterators]</a></h1><div id='general'><h2 ><a class='secnum' href='#general' style='min-width:88pt'>9.1</a> General <a class='abbr_ref' href='iterators.general.html'>[iterators.general]</a></h2><div class='para' id='general-1'><div class='marginalizedparent'><a class='marginalized' href='#general-1'>1</a></div><p >This Clause describes components that C++ programs may use to perform
iterations over containers (Clause   ISO/IEC 14882:2014 &sect;  <span class='csname'></span> containers <span class='endcsname'></span>),
streams (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> iostream.format <span class='endcsname'></span>),
stream buffers (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> stream.buffers <span class='endcsname'></span>),
and ranges (<a href='ranges.html'>[ranges]</a>).</p></div><div class='para' id='general-2'><div class='marginalizedparent'><a class='marginalized' href='#general-2'>2</a></div><p >The following subclauses describe
iterator requirements, and
components for
iterator primitives,
predefined iterators,
and stream iterators,
as summarized in Table <a href='#tab:iterators.lib.summary'>[tab:iterators.lib.summary]</a>.</p><div class='numberedTable' id='tab:iterators.lib.summary'>Table <a href='#tab:iterators.lib.summary'>7</a> â€” Iterators library summary<br><table ><tr class='rowsep'><td colspan='2' class='center'><b>Subclause</b></td><td class='left'>	<b>Header(s)</b>	</td></tr><tr class='capsep'><td class='left'> 


<a href='iterator.requirements.html'>[iterator.requirements]</a> </td><td class='left'> Iterator requirements          </td><td class='left'>                           </td></tr><tr ><td class='left'>
<a href='indirectcallable.html'>[indirectcallable]</a>      </td><td class='left'> Indirect callable requirements </td><td class='left'>                           </td></tr><tr ><td class='left'>
<a href='commonalgoreq.html'>[commonalgoreq]</a>         </td><td class='left'> Common algorithm requirements  </td><td class='left'>                           </td></tr><tr class='rowsep'><td class='left'> 
<a href='iterator.primitives.html'>[iterator.primitives]</a>   </td><td class='left'> Iterator primitives            </td><td class='left'> <span class='texttt'>&lt;experimental/ranges/iterator&gt;</span> </td></tr><tr ><td class='left'>
<a href='iterators.predef.html'>[iterators.predef]</a>      </td><td class='left'> Predefined iterators           </td><td class='left'>                           </td></tr><tr ><td class='left'>
<a href='iterators.stream.html'>[iterators.stream]</a>      </td><td class='left'> Stream iterators               </td><td class='left'>                           </td></tr><tr ><td class='left'>
<a href='ranges.html'>[ranges]</a>                </td><td class='left'> Ranges                         </td><td class='left'>                           </td></tr></table></div></div></div><div id='iterator.synopsis'><h2 ><a class='secnum' href='#iterator.synopsis' style='min-width:88pt'>9.2</a> Header <span class='texttt'>&lt;experimental/ranges/iterator&gt;</span> synopsis <a class='abbr_ref' href='iterator.synopsis.html'>[iterator.synopsis]</a></h2><p ><span class='indexparent'><a class='index' id='experimental/ranges/iterator'></a></span></p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;class T&gt; concept bool <i>dereferenceable</i> <span class='comment'>// <i>exposition only</i>
</span>    = requires(T&amp; t) { {*t} -&gt; auto&amp;&amp;; };

  <span class='comment'>// <a href='iterator.requirements.html'>[iterator.requirements]</a>, iterator requirements:
</span>  <span class='comment'>// <a href='iterator.custpoints.html'>[iterator.custpoints]</a>, customization points:
</span>  namespace {
    <span class='comment'>// <a href='iterator.custpoints.iter_move.html'>[iterator.custpoints.iter_move]</a>, iter_move:
</span>    constexpr <i><span class='texttt'>unspecified</span></i> iter_move = <i><span class='texttt'>unspecified</span></i>;

    <span class='comment'>// <a href='iterator.custpoints.iter_swap.html'>[iterator.custpoints.iter_swap]</a>, iter_swap:
</span>    constexpr <i><span class='texttt'>unspecified</span></i> iter_swap = <i><span class='texttt'>unspecified</span></i>;
  }

  <span class='comment'>// <a href='iterator.assoc.types.html'>[iterator.assoc.types]</a>, associated types:
</span>  <span class='comment'>// <a href='iterator.assoc.types.difference_type.html'>[iterator.assoc.types.difference_type]</a>, difference_type:
</span>  template &lt;class&gt; struct difference_type;
  template &lt;class T&gt; using difference_type_t
    = typename difference_type&lt;T&gt;::type;

  <span class='comment'>// <a href='iterator.assoc.types.value_type.html'>[iterator.assoc.types.value_type]</a>, value_type:
</span>  template &lt;class&gt; struct value_type;
  template &lt;class T&gt; using value_type_t
    = typename value_type&lt;T&gt;::type;

  <span class='comment'>// <a href='iterator.assoc.types.iterator_category.html'>[iterator.assoc.types.iterator_category]</a>, iterator_category:
</span>  template &lt;class&gt; struct iterator_category;
  template &lt;class T&gt; using iterator_category_t
    = typename iterator_category&lt;T&gt;::type;

  template &lt;<i>dereferenceable</i> T&gt; using reference_t
    = decltype(*declval&lt;T&amp;&gt;());

  template &lt;<i>dereferenceable</i> T&gt;
      requires <i><span class='texttt'>see below</span></i> using rvalue_reference_t
    = decltype(ranges::iter_move(declval&lt;T&amp;&gt;()));

  <span class='comment'>// <a href='iterators.readable.html'>[iterators.readable]</a>, Readable:
</span>  template &lt;class In&gt;
  concept bool Readable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='iterators.writable.html'>[iterators.writable]</a>, Writable:
</span>  template &lt;class Out, class T&gt;
  concept bool Writable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='iterators.weaklyincrementable.html'>[iterators.weaklyincrementable]</a>, WeaklyIncrementable:
</span>  template &lt;class I&gt;
  concept bool WeaklyIncrementable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='iterators.incrementable.html'>[iterators.incrementable]</a>, Incrementable:
</span>  template &lt;class I&gt;
  concept bool Incrementable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='iterators.iterator.html'>[iterators.iterator]</a>, Iterator:
</span>  template &lt;class I&gt;
  concept bool Iterator() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='iterators.sentinel.html'>[iterators.sentinel]</a>, Sentinel:
</span>  template &lt;class S, class I&gt;
  concept bool Sentinel() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='iterators.sizedsentinel.html'>[iterators.sizedsentinel]</a>, SizedSentinel:
</span>  template &lt;class S, class I&gt;
    constexpr bool disable_sized_sentinel = false;

  template &lt;class S, class I&gt;
  concept bool SizedSentinel() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='iterators.input.html'>[iterators.input]</a>, InputIterator:
</span>  template &lt;class I&gt;
  concept bool InputIterator() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='iterators.output.html'>[iterators.output]</a>, OutputIterator:
</span>  template &lt;class I&gt;
  concept bool OutputIterator() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='iterators.forward.html'>[iterators.forward]</a>, ForwardIterator:
</span>  template &lt;class I&gt;
  concept bool ForwardIterator() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='iterators.bidirectional.html'>[iterators.bidirectional]</a>, BidirectionalIterator:
</span>  template &lt;class I&gt;
  concept bool BidirectionalIterator() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='iterators.random.access.html'>[iterators.random.access]</a>, RandomAccessIterator:
</span>  template &lt;class I&gt;
  concept bool RandomAccessIterator() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='indirectcallable.html'>[indirectcallable]</a>, indirect callable requirements:
</span>  <span class='comment'>// <a href='indirectcallable.indirectinvocable.html'>[indirectcallable.indirectinvocable]</a>, indirect callables:
</span>  template &lt;class F&gt;
  concept bool IndirectInvocable() {
    return <i><span class='texttt'>see below</span></i>;
  }
  template &lt;class F, class I&gt;
  concept bool IndirectInvocable() {
    return <i><span class='texttt'>see below</span></i>;
  }
  template &lt;class F, class I1, class I2&gt;
  concept bool IndirectInvocable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  template &lt;class F&gt;
  concept bool IndirectRegularInvocable() {
    return <i><span class='texttt'>see below</span></i>;
  }
  template &lt;class F, class I&gt;
  concept bool IndirectRegularInvocable() {
    return <i><span class='texttt'>see below</span></i>;
  }
  template &lt;class F, class I1, class I2&gt;
  concept bool IndirectRegularInvocable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  template &lt;class F, class I&gt;
  concept bool IndirectPredicate() {
    return <i><span class='texttt'>see below</span></i>;
  }
  template &lt;class F, class I1, class I2&gt;
  concept bool IndirectPredicate() {
    return <i><span class='texttt'>see below</span></i>;
  }

  template &lt;class F, class I1, class I2 = I1&gt;
  concept bool IndirectRelation() {
    return <i><span class='texttt'>see below</span></i>;
  }

  template &lt;class F, class I1, class I2 = I1&gt;
  concept bool IndirectStrictWeakOrder() {
    return <i><span class='texttt'>see below</span></i>;
  }

  template &lt;class&gt; struct indirect_result_of;

  template &lt;class F, class... Is&gt;
    requires IndirectInvocable&lt;decay_t&lt;F&gt;, Is...&gt;()
  struct indirect_result_of&lt;F(Is...)&gt;;

  template &lt;class F&gt;
  using indirect_result_of_t
    = typename indirect_result_of&lt;F&gt;::type;

  <span class='comment'>// <a href='projected.html'>[projected]</a>, projected:
</span>  template &lt;Readable I, IndirectRegularInvocable&lt;I&gt; Proj&gt;
  struct projected;

  template &lt;WeaklyIncrementable I, class Proj&gt;
  struct difference_type&lt;projected&lt;I, Proj&gt;&gt;;

  <span class='comment'>// <a href='commonalgoreq.html'>[commonalgoreq]</a>, common algorithm requirements:
</span>  <span class='comment'>// <a href='commonalgoreq.indirectlymovable.html'>[commonalgoreq.indirectlymovable]</a> IndirectlyMovable:
</span>  template &lt;class In, class Out&gt;
  concept bool IndirectlyMovable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  template &lt;class In, class Out&gt;
  concept bool IndirectlyMovableStorable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='commonalgoreq.indirectlycopyable.html'>[commonalgoreq.indirectlycopyable]</a> IndirectlyCopyable:
</span>  template &lt;class In, class Out&gt;
  concept bool IndirectlyCopyable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  template &lt;class In, class Out&gt;
  concept bool IndirectlyCopyableStorable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='commonalgoreq.indirectlyswappable.html'>[commonalgoreq.indirectlyswappable]</a> IndirectlySwappable:
</span>  template &lt;class I1, class I2 = I1&gt;
  concept bool IndirectlySwappable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='commonalgoreq.indirectlycomparable.html'>[commonalgoreq.indirectlycomparable]</a> IndirectlyComparable:
</span>  template &lt;class I1, class I2, class R = equal_to&lt;&gt;, class P1 = identity,
      class P2 = identity&gt;
  concept bool IndirectlyComparable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='commonalgoreq.permutable.html'>[commonalgoreq.permutable]</a> Permutable:
</span>  template &lt;class I&gt;
  concept bool Permutable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='commonalgoreq.mergeable.html'>[commonalgoreq.mergeable]</a> Mergeable:
</span>  template &lt;class I1, class I2, class Out,
      class R = less&lt;&gt;, class P1 = identity, class P2 = identity&gt;
  concept bool Mergeable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  template &lt;class I, class R = less&lt;&gt;, class P = identity&gt;
  concept bool Sortable() {
    return <i><span class='texttt'>see below</span></i>;
  }

  <span class='comment'>// <a href='iterator.primitives.html'>[iterator.primitives]</a>, primitives:
</span>  <span class='comment'>// <a href='iterator.traits.html'>[iterator.traits]</a>, traits:
</span>  template &lt;class I1, class I2&gt; struct is_indirectly_movable;
  template &lt;class I1, class I2 = I1&gt; struct is_indirectly_swappable;
  template &lt;class I1, class I2&gt; struct is_nothrow_indirectly_movable;
  template &lt;class I1, class I2 = I1&gt; struct is_nothrow_indirectly_swappable;

  template &lt;class I1, class I2&gt; constexpr bool is_indirectly_movable_v
    = is_indirectly_movable&lt;I1, I2&gt;::value;
  template &lt;class I1, class I2&gt; constexpr bool is_indirectly_swappable_v
    = is_indirectly_swappable&lt;I1, I2&gt;::value;
  template &lt;class I1, class I2&gt; constexpr bool is_nothrow_indirectly_movable_v
    = is_nothrow_indirectly_movable&lt;I1, I2&gt;::value;
  template &lt;class I1, class I2&gt; constexpr bool is_nothrow_indirectly_swappable_v
    = is_nothrow_indirectly_swappable&lt;I1, I2&gt;::value;

  template &lt;class Iterator&gt; using iterator_traits = <i><span class='texttt'>see below</span></i>;

  template &lt;Readable T&gt; using iter_common_reference_t
    = common_reference_t&lt;reference_t&lt;T&gt;, value_type_t&lt;T&gt;&amp;&gt;;

  <span class='comment'>// <a href='std.iterator.tags.html'>[std.iterator.tags]</a>, iterator tags:
</span>  struct output_iterator_tag { };
  struct input_iterator_tag { };
  struct forward_iterator_tag : input_iterator_tag { };
  struct bidirectional_iterator_tag : forward_iterator_tag { };
  struct random_access_iterator_tag : bidirectional_iterator_tag { };

  <span class='comment'>// <a href='iterator.operations.html'>[iterator.operations]</a>, iterator operations:
</span>  template &lt;Iterator I&gt;
    void advance(I&amp; i, difference_type_t&lt;I&gt; n);
  template &lt;Iterator I, Sentinel&lt;I&gt; S&gt;
    void advance(I&amp; i, S bound);
  template &lt;Iterator I, Sentinel&lt;I&gt; S&gt;
    difference_type_t&lt;I&gt; advance(I&amp; i, difference_type_t&lt;I&gt; n, S bound);
  template &lt;Iterator I, Sentinel&lt;I&gt; S&gt;
    difference_type_t&lt;I&gt; distance(I first, S last);
  template &lt;Iterator I&gt;
    I next(I x, difference_type_t&lt;I&gt; n = 1);
  template &lt;Iterator I, Sentinel&lt;I&gt; S&gt;
    I next(I x, S bound);
  template &lt;Iterator I, Sentinel&lt;I&gt; S&gt;
    I next(I x, difference_type_t&lt;I&gt; n, S bound);
  template &lt;BidirectionalIterator I&gt;
    I prev(I x, difference_type_t&lt;I&gt; n = 1);
  template &lt;BidirectionalIterator I&gt;
    I prev(I x, difference_type_t&lt;I&gt; n, I bound);

  <span class='comment'>// <a href='iterators.predef.html'>[iterators.predef]</a>, predefined iterators and sentinels:
</span>
  <span class='comment'>// <a href='iterators.reverse.html'>[iterators.reverse]</a>, reverse iterators:
</span>  template &lt;BidirectionalIterator I&gt; class reverse_iterator;

  template &lt;class I1, class I2&gt;
      requires EqualityComparable&lt;I1, I2&gt;()
    bool operator==(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires EqualityComparable&lt;I1, I2&gt;()
    bool operator!=(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&lt;(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&gt;(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&gt;=(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&lt;=(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);

  template &lt;class I1, class I2&gt;
      requires SizedSentinel&lt;I1, I2&gt;()
    difference_type_t&lt;I2&gt; operator-(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;RandomAccessIterator I&gt;
    reverse_iterator&lt;I&gt;
      operator+(
    difference_type_t&lt;I&gt; n,
    const reverse_iterator&lt;I&gt;&amp; x);

  template &lt;BidirectionalIterator I&gt;
    reverse_iterator&lt;I&gt; make_reverse_iterator(I i);

  <span class='comment'>// <a href='iterators.insert.html'>[iterators.insert]</a>, insert iterators:
</span>  template &lt;class Container&gt; class back_insert_iterator;
  template &lt;class Container&gt;
    back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; x);

  template &lt;class Container&gt; class front_insert_iterator;
  template &lt;class Container&gt;
    front_insert_iterator&lt;Container&gt; front_inserter(Container&amp; x);

  template &lt;class Container&gt; class insert_iterator;
  template &lt;class Container&gt;
    insert_iterator&lt;Container&gt; inserter(Container&amp; x, iterator_t&lt;Container&gt; i);

  <span class='comment'>// <a href='iterators.move.html'>[iterators.move]</a>, move iterators and sentinels:
</span>  template &lt;InputIterator I&gt; class move_iterator;
  template &lt;class I1, class I2&gt;
      requires EqualityComparable&lt;I1, I2&gt;()
    bool operator==(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires EqualityComparable&lt;I1, I2&gt;()
    bool operator!=(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&lt;(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&lt;=(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&gt;(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&gt;=(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);

  template &lt;class I1, class I2&gt;
      requires SizedSentinel&lt;I1, I2&gt;()
    difference_type_t&lt;I2&gt; operator-(
      const move_iterator&lt;I1&gt;&amp; x,
      const move_iterator&lt;I2&gt;&amp; y);
  template &lt;RandomAccessIterator I&gt;
    move_iterator&lt;I&gt;
      operator+(
    difference_type_t&lt;I&gt; n,
    const move_iterator&lt;I&gt;&amp; x);
  template &lt;InputIterator I&gt;
    move_iterator&lt;I&gt; make_move_iterator(I i);

  template &lt;Semiregular S&gt; class move_sentinel;

  template &lt;class I, Sentinel&lt;I&gt; S&gt;
    bool operator==(
      const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);
  template &lt;class I, Sentinel&lt;I&gt; S&gt;
    bool operator==(
      const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);
  template &lt;class I, Sentinel&lt;I&gt; S&gt;
    bool operator!=(
      const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);
  template &lt;class I, Sentinel&lt;I&gt; S&gt;
    bool operator!=(
      const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);

  template &lt;class I, SizedSentinel&lt;I&gt; S&gt;
    difference_type_t&lt;I&gt; operator-(
      const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);
  template &lt;class I, SizedSentinel&lt;I&gt; S&gt;
    difference_type_t&lt;I&gt; operator-(
      const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);

  template &lt;Semiregular S&gt;
    move_sentinel&lt;S&gt; make_move_sentinel(S s);

  <span class='comment'>// <a href='iterators.common.html'>[iterators.common]</a>, common iterators:
</span>  template &lt;Iterator I, Sentinel&lt;I&gt; S&gt;
    requires !Same&lt;I, S&gt;()
  class common_iterator;

  template &lt;Readable I, class S&gt;
  struct value_type&lt;common_iterator&lt;I, S&gt;&gt;;

  template &lt;InputIterator I, class S&gt;
  struct iterator_category&lt;common_iterator&lt;I, S&gt;&gt;;

  template &lt;ForwardIterator I, class S&gt;
  struct iterator_category&lt;common_iterator&lt;I, S&gt;&gt;;

  template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
  bool operator==(
    const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
  template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
    requires EqualityComparable&lt;I1, I2&gt;()
  bool operator==(
    const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
  template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
  bool operator!=(
    const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);

  template &lt;class I2, SizedSentinel&lt;I2&gt; I1, SizedSentinel&lt;I2&gt; S1, SizedSentinel&lt;I1&gt; S2&gt;
  difference_type_t&lt;I2&gt; operator-(
    const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);

  <span class='comment'>// <a href='default.sentinels.html'>[default.sentinels]</a>, default sentinels:
</span>  class default_sentinel;

  <span class='comment'>// <a href='iterators.counted.html'>[iterators.counted]</a>, counted iterators:
</span>  template &lt;Iterator I&gt; class counted_iterator;

  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
    bool operator==(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
    bool operator==(
      const counted_iterator&lt;auto&gt;&amp; x, default_sentinel);
    bool operator==(
      default_sentinel, const counted_iterator&lt;auto&gt;&amp; x);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
    bool operator!=(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
    bool operator!=(
      const counted_iterator&lt;auto&gt;&amp; x, default_sentinel y);
    bool operator!=(
      default_sentinel x, const counted_iterator&lt;auto&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
    bool operator&lt;(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
    bool operator&lt;=(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
    bool operator&gt;(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
    bool operator&gt;=(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
    difference_type_t&lt;I2&gt; operator-(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I&gt;
    difference_type_t&lt;I&gt; operator-(
      const counted_iterator&lt;I&gt;&amp; x, default_sentinel y);
  template &lt;class I&gt;
    difference_type_t&lt;I&gt; operator-(
      default_sentinel x, const counted_iterator&lt;I&gt;&amp; y);
  template &lt;RandomAccessIterator I&gt;
    counted_iterator&lt;I&gt;
      operator+(difference_type_t&lt;I&gt; n, const counted_iterator&lt;I&gt;&amp; x);
  template &lt;Iterator I&gt;
    counted_iterator&lt;I&gt; make_counted_iterator(I i, difference_type_t&lt;I&gt; n);

  template &lt;Iterator I&gt;
    void advance(counted_iterator&lt;I&gt;&amp; i, difference_type_t&lt;I&gt; n);

  <span class='comment'>// <a href='unreachable.sentinels.html'>[unreachable.sentinels]</a>, unreachable sentinels:
</span>  class unreachable;
  template &lt;Iterator I&gt;
    constexpr bool operator==(const I&amp;, unreachable) noexcept;
  template &lt;Iterator I&gt;
    constexpr bool operator==(unreachable, const I&amp;) noexcept;
  template &lt;Iterator I&gt;
    constexpr bool operator!=(const I&amp;, unreachable) noexcept;
  template &lt;Iterator I&gt;
    constexpr bool operator!=(unreachable, const I&amp;) noexcept;

  <span class='comment'>// <a href='dangling.wrappers.html'>[dangling.wrappers]</a>, dangling wrapper:
</span>  template &lt;class T&gt; class dangling;

  <span class='comment'>// <a href='iterators.stream.html'>[iterators.stream]</a>, stream iterators:
</span>  template &lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;,
      class Distance = ptrdiff_t&gt;
  class istream_iterator;
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator==(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
            const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator==(default_sentinel x,
            const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator==(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
            default_sentinel y);
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator!=(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
            const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
  template &lt;class T, class charT, class traits, class Distance&gt;
   bool operator!=(default_sentinel x,
            const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator!=(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
            default_sentinel y);

  template &lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;&gt;
      class ostream_iterator;

  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
    class istreambuf_iterator;
  template &lt;class charT, class traits&gt;
    bool operator==(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
            const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
  template &lt;class charT, class traits&gt;
    bool operator==(default_sentinel a,
            const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
  template &lt;class charT, class traits&gt;
    bool operator==(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
            default_sentinel b);
  template &lt;class charT, class traits&gt;
    bool operator!=(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
            const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
  template &lt;class charT, class traits&gt;
    bool operator!=(default_sentinel a,
            const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
  template &lt;class charT, class traits&gt;
    bool operator!=(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
            default_sentinel b);

  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
    class ostreambuf_iterator;

  <span class='comment'>// <a href='iterator.range.html'>[iterator.range]</a>, range access:
</span>  namespace {
    constexpr <i><span class='texttt'>unspecified</span></i> begin = <i><span class='texttt'>unspecified</span></i>;
    constexpr <i><span class='texttt'>unspecified</span></i> end = <i><span class='texttt'>unspecified</span></i>;
    constexpr <i><span class='texttt'>unspecified</span></i> cbegin = <i><span class='texttt'>unspecified</span></i>;
    constexpr <i><span class='texttt'>unspecified</span></i> cend = <i><span class='texttt'>unspecified</span></i>;
    constexpr <i><span class='texttt'>unspecified</span></i> rbegin = <i><span class='texttt'>unspecified</span></i>;
    constexpr <i><span class='texttt'>unspecified</span></i> rend = <i><span class='texttt'>unspecified</span></i>;
    constexpr <i><span class='texttt'>unspecified</span></i> crbegin = <i><span class='texttt'>unspecified</span></i>;
    constexpr <i><span class='texttt'>unspecified</span></i> crend = <i><span class='texttt'>unspecified</span></i>;
  }

  <span class='comment'>// <a href='range.primitives.html'>[range.primitives]</a>, range primitives:
</span>  namespace {
    constexpr <i><span class='texttt'>unspecified</span></i> size = <i><span class='texttt'>unspecified</span></i>;
    constexpr <i><span class='texttt'>unspecified</span></i> empty = <i><span class='texttt'>unspecified</span></i>;
    constexpr <i><span class='texttt'>unspecified</span></i> data = <i><span class='texttt'>unspecified</span></i>;
    constexpr <i><span class='texttt'>unspecified</span></i> cdata = <i><span class='texttt'>unspecified</span></i>;
  }
  template &lt;Range R&gt;
  difference_type_t&lt;iterator_t&lt;R&gt;&gt; distance(R&amp;&amp; r);
  template &lt;SizedRange R&gt;
  difference_type_t&lt;iterator_t&lt;R&gt;&gt; distance(R&amp;&amp; r);
}}}}

namespace std {
  <span class='comment'>// <a href='iterator.stdtraits.html'>[iterator.stdtraits]</a>, iterator traits:
</span>  template &lt;experimental::ranges::Iterator I&gt;
    struct iterator_traits;
  template &lt;experimental::ranges::InputIterator I&gt;
    struct iterator_traits;
  template &lt;experimental::ranges::InputIterator I&gt;
      requires experimental::ranges::Sentinel&lt;I, I&gt;()
    struct iterator_traits;
}
</pre><div class='para' id='iterator.synopsis-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.synopsis-1'>1</a></div><p >Any entities declared or defined in namespace <span class='texttt'>std</span> in header <span class='texttt'>&lt;iterator&gt;</span>
that are not already defined in namespace <span class='texttt'>std::experimental::ranges</span> in header
<span class='texttt'>&lt;experimental/ranges/iterator&gt;</span> are imported with
<span class='grammarterm'>using-declarations</span> (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> namespace.udecl <span class='endcsname'></span>).</p></div></div><div id='iterator.requirements'><h2 ><a class='secnum' href='#iterator.requirements' style='min-width:88pt'>9.3</a> Iterator requirements <a class='abbr_ref' href='iterator.requirements.html'>[iterator.requirements]</a></h2><div id='iterator.requirements.general'><h3 ><a class='secnum' href='#iterator.requirements.general' style='min-width:103pt'>9.3.1</a> In general <a class='abbr_ref' href='iterator.requirements.general.html'>[iterator.requirements.general]</a></h3><div class='para' id='iterator.requirements.general-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.requirements.general-1'>1</a></div><p ><span class='indexparent'><a class='index' id='requirements,iterator'></a></span>Iterators are a generalization of pointers that allow a C++ program to work with different data structures
(for example, containers and ranges) in a uniform manner.
To be able to construct template algorithms that work correctly and
efficiently on different types of data structures, the library formalizes not just the interfaces but also the
semantics and complexity assumptions of iterators.
All input iterators
<span class='texttt'>i</span>
support the expression
<span class='texttt'>*i</span>,
resulting in a value of some object type
<span class='texttt'>T</span>,
called the
<a class='hidden_link' href='#def:value_type' id='def:value_type'><i>value type</i></a>
of the iterator.
All output iterators support the expression
<span class='texttt'>*i = o</span>
where
<span class='texttt'>o</span>
is a value of some type that is in the set of types that are
<a class='hidden_link' href='#def:writable' id='def:writable'><i>writable</i></a>
to the particular iterator type of
<span class='texttt'>i</span>.
For every iterator type
<span class='texttt'>X</span>
there is a corresponding signed integer type called the
<a class='hidden_link' href='#def:difference_type' id='def:difference_type'><i>difference type</i></a>
of the iterator.</p></div><div class='para' id='iterator.requirements.general-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.requirements.general-2'>2</a></div><p >Since iterators are an abstraction of pointers, their semantics are
a generalization of most of the semantics of pointers in C++.
This ensures that every
function template
that takes iterators
works as well with regular pointers.
This document defines
five categories of iterators, according to the operations
defined on them:
<i>input iterators</i>,
<i>output iterators</i>,
<i>forward iterators</i>,
<i>bidirectional iterators</i>
and
<i>random access iterators</i>,
as shown in Table <a href='#tab:iterators.relations'>[tab:iterators.relations]</a>.</p><div class='numberedTable' id='tab:iterators.relations'>Table <a href='#tab:iterators.relations'>8</a> â€” Relations among iterator categories<br><table ><tr class='rowsep'><td class='left'>



<b>Random Access</b>          </td><td class='left'>   <span class='math'>â†’</span> <b>Bidirectional</b>    </td><td class='left'>
<span class='math'>â†’</span> <b>Forward</b>  </td><td class='left'>   <span class='math'>â†’</span> <b>Input</b>            </td></tr><tr ><td class='left'>
                        </td><td class='left'>   </td><td class='left'>   </td><td class='left'>   <span class='math'>â†’</span> <b>Output</b>           </td></tr></table></div></div><div class='para' id='iterator.requirements.general-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.requirements.general-3'>3</a></div><p >The five categories of iterators correspond to the iterator concepts
<span class='texttt'>InputIterator</span>,
<span class='texttt'>OutputIterator</span>,
<span class='texttt'>ForwardIterator</span>,
<span class='texttt'>BidirectionalIterator</span>, and
<span class='texttt'>RandomAccessIterator</span>, respectively. The generic term <i>iterator</i> refers to
any type that satisfies <span class='texttt'>Iterator</span>.</p></div><div class='para' id='iterator.requirements.general-4'><div class='marginalizedparent'><a class='marginalized' href='#iterator.requirements.general-4'>4</a></div><p >Forward iterators satisfy all the requirements of input
iterators and can be used whenever an input iterator is specified;
Bidirectional iterators also satisfy all the requirements of
forward iterators and can be used whenever a forward iterator is specified;
Random access iterators also satisfy all the requirements of bidirectional
iterators and can be used whenever a bidirectional iterator is specified.</p></div><div class='para' id='iterator.requirements.general-5'><div class='marginalizedparent'><a class='marginalized' href='#iterator.requirements.general-5'>5</a></div><p >Iterators that further satisfy the requirements of output iterators are
called <a class='hidden_link' href='#def:mutable_iterator' id='def:mutable_iterator'><i>mutable iterator</i></a>s. Nonmutable iterators are referred to
as <a class='hidden_link' href='#def:constant_iterator' id='def:constant_iterator'><i>constant iterator</i></a>s.</p></div><div class='para' id='iterator.requirements.general-6'><div class='marginalizedparent'><a class='marginalized' href='#iterator.requirements.general-6'>6</a></div><p >Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element
of the array, so for any iterator type there is an iterator value that points past the last element of a
corresponding sequence.
These values are called
<a class='hidden_link' href='#def:past-the-end' id='def:past-the-end'><i>past-the-end</i></a>
values.
Values of an iterator
<span class='texttt'>i</span>
for which the expression
<span class='texttt'>*i</span>
is defined are called
<a class='hidden_link' href='#def:dereferenceable' id='def:dereferenceable'><i>dereferenceable</i></a>.
The library never assumes that past-the-end values are dereferenceable.
Iterators can also have singular values that are not associated with any
sequence.
[&nbsp;<i>Example:</i>
After the declaration of an uninitialized pointer
<span class='texttt'>x</span>
(as with
<span class='texttt'>int* x;</span>),
<span class='texttt'>x</span>
must always be assumed to have a singular value of a pointer.
<i>&nbsp;â€”&nbsp;end example</i>&nbsp;]
Results of most expressions are undefined for singular values;
the only exceptions are destroying an iterator that holds a singular value,
the assignment of a non-singular value to
an iterator that holds a singular value, and using a value-initialized iterator
as the source of a copy or move operation. [&nbsp;<i>Note:</i> This guarantee is not
offered for default initialization, although the distinction only matters for types
with trivial default constructors such as pointers or aggregates holding pointers.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
In these cases the singular
value is overwritten the same way as any other value.
Dereferenceable
values are always non-singular.</p></div><div class='para' id='iterator.requirements.general-7'><div class='marginalizedparent'><a class='marginalized' href='#iterator.requirements.general-7'>7</a></div><p >Most of the library's algorithmic templates that operate on data structures have
interfaces that use ranges. A range is an iterator and a <a class='hidden_link' href='#def:sentinel' id='def:sentinel'><i>sentinel</i></a> that designate
the beginning and end of the computation. An iterator and a sentinel denoting a range
are comparable. A sentinel denotes an element when it compares equal to an iterator
<span class='texttt'>i</span>, and <span class='texttt'>i</span> points to that element. The types of a sentinel and an
iterator that denote a range must satisfy <span class='texttt'>Sentinel</span> (<a href='iterators.sentinel.html'>[iterators.sentinel]</a>).</p></div><div class='para' id='iterator.requirements.general-8'><div class='marginalizedparent'><a class='marginalized' href='#iterator.requirements.general-8'>8</a></div><p >A range <span class='texttt'>[i,s)</span>
is empty if <span class='texttt'>i == s</span>;
otherwise, <span class='texttt'>[i,s)</span>
refers to the elements in the data structure starting with the element
pointed to by
<span class='texttt'>i</span>
and up to but not including the element pointed to by
the first iterator <span class='texttt'>j</span> such that <span class='texttt'>j == s</span>.</p></div><div class='para' id='iterator.requirements.general-9'><div class='marginalizedparent'><a class='marginalized' href='#iterator.requirements.general-9'>9</a></div><p >A sentinel
<span class='texttt'>s</span>
is called
<a class='hidden_link' href='#def:reachable' id='def:reachable'><i>reachable</i></a>
from an iterator
<span class='texttt'>i</span>
if and only if there is a finite sequence of applications of
the expression
<span class='texttt'>++i</span>
that makes
<span class='texttt'>i == s</span>.
If
<span class='texttt'>s</span>
is reachable from
<span class='texttt'>i</span>,
they denote a range.</p></div><div class='para' id='iterator.requirements.general-10'><div class='marginalizedparent'><a class='marginalized' href='#iterator.requirements.general-10'>10</a></div><p >A range <span class='texttt'>[i,s)</span>
is valid if and only if
<span class='texttt'>s</span>
is reachable from
<span class='texttt'>i</span>.
The result of the application of functions in the library to invalid ranges is
undefined.</p></div><div class='para' id='iterator.requirements.general-11'><div class='marginalizedparent'><a class='marginalized' href='#iterator.requirements.general-11'>11</a></div><p >All the categories of iterators require only those functions that are realizable for a given category in
constant time (amortized).</p></div><div class='para' id='iterator.requirements.general-12'><div class='marginalizedparent'><a class='marginalized' href='#iterator.requirements.general-12'>12</a></div><p >Destruction of an iterator may invalidate pointers and references
previously obtained from that iterator.</p></div><div class='para' id='iterator.requirements.general-13'><div class='marginalizedparent'><a class='marginalized' href='#iterator.requirements.general-13'>13</a></div><p >An
<i>invalid</i>
iterator is an iterator that may be singular.<a class='footnotenum' href='#footnote-3'>3</a></p></div><div class='footnote' id='footnote-3'><div class='footnoteNumberParent'><a class='marginalized' href='#footnote-3'>3)</a></div><p >This definition applies to pointers, since pointers are iterators.
The effect of dereferencing an iterator that has been invalidated
is undefined.
</p></div></div><div id='iterator.custpoints'><h3 ><a class='secnum' href='#iterator.custpoints' style='min-width:103pt'>9.3.2</a> Customization points <a class='abbr_ref' href='iterator.custpoints.html'>[iterator.custpoints]</a></h3><div id='iterator.custpoints.iter_move'><h4 ><a class='secnum' href='#iterator.custpoints.iter_move' style='min-width:118pt'>9.3.2.1</a> <span class='texttt'>iter_move</span> <a class='abbr_ref' href='iterator.custpoints.iter_move.html'>[iterator.custpoints.iter_move]</a></h4><div class='para' id='iterator.custpoints.iter_move-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.custpoints.iter_move-1'>1</a></div><p >The name <span class='texttt'>iter_move</span> denotes a <i>customization point
object</i> (<a href='customization.point.object.html'>[customization.point.object]</a>). The effect of the expression
<span class='texttt'>ranges::iter_move(E)</span> for some expression <span class='texttt'>E</span> is equivalent to the
following:</p><ul class='itemize'><li id='iterator.custpoints.iter_move-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.custpoints.iter_move-1.1'>(1.1)</a></div><p ><span class='texttt'>iter_move(E)</span>, if that expression is well-formed when evaluated in
a context that does not include <span class='texttt'>ranges::iter_move</span> but does include the
lookup set produced by argument-dependent lookup (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> basic.lookup.argdep <span class='endcsname'></span>).
</p></li><li id='iterator.custpoints.iter_move-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.custpoints.iter_move-1.2'>(1.2)</a></div><p >Otherwise, if the expression <span class='texttt'>*E</span> is well-formed
</p><ul class='itemize'><li id='iterator.custpoints.iter_move-1.2.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#iterator.custpoints.iter_move-1.2.1'>(1.2.1)</a></div><p >If <span class='texttt'>*E</span> is an lvalue, <span class='texttt'>std::move(*E)</span>
</p></li><li id='iterator.custpoints.iter_move-1.2.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#iterator.custpoints.iter_move-1.2.2'>(1.2.2)</a></div><p >Otherwise, <span class='texttt'>*E</span>
</p></li></ul></li><li id='iterator.custpoints.iter_move-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.custpoints.iter_move-1.3'>(1.3)</a></div><p >Otherwise, <span class='texttt'>ranges::iter_move(E)</span> is ill-formed.
</p></li></ul></div><div class='para' id='iterator.custpoints.iter_move-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.custpoints.iter_move-2'>2</a></div><p >If <span class='texttt'>ranges::iter_move(E)</span> does not equal <span class='texttt'>*E</span>, the program is
ill-formed with no diagnostic required.</p></div></div><div id='iterator.custpoints.iter_swap'><h4 ><a class='secnum' href='#iterator.custpoints.iter_swap' style='min-width:118pt'>9.3.2.2</a> <span class='texttt'>iter_swap</span> <a class='abbr_ref' href='iterator.custpoints.iter_swap.html'>[iterator.custpoints.iter_swap]</a></h4><div class='para' id='iterator.custpoints.iter_swap-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.custpoints.iter_swap-1'>1</a></div><p >The name <span class='texttt'>iter_swap</span> denotes a <i>customization point
object</i> (<a href='customization.point.object.html'>[customization.point.object]</a>). The effect of the expression
<span class='texttt'>ranges::iter_swap(E1, E2)</span> for some expressions <span class='texttt'>E1</span> and <span class='texttt'>E2</span>
is equivalent to the following:</p><ul class='itemize'><li id='iterator.custpoints.iter_swap-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.custpoints.iter_swap-1.1'>(1.1)</a></div><p ><span class='texttt'>(void)iter_swap(E1, E2)</span>, if that expression is well-formed when
evaluated in a context that does not include <span class='texttt'>ranges::iter_swap</span> but does
include the lookup set produced by argument-dependent
lookup (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> basic.lookup.argdep <span class='endcsname'></span>) and the following declaration:
</p><pre class='codeblock'>
void iter_swap(auto, auto) = delete;
</pre></li><li id='iterator.custpoints.iter_swap-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.custpoints.iter_swap-1.2'>(1.2)</a></div><p >Otherwise, if the types of <span class='texttt'>E1</span> and <span class='texttt'>E2</span> both satisfy
<span class='texttt'>Readable</span>, and if the reference type of <span class='texttt'>E1</span> is swappable
with (<a href='concepts.lib.corelang.swappable.html'>[concepts.lib.corelang.swappable]</a>) the reference type of <span class='texttt'>E2</span>,
then <span class='texttt'>ranges::swap(*E1, *E2)</span>
</p></li><li id='iterator.custpoints.iter_swap-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.custpoints.iter_swap-1.3'>(1.3)</a></div><p >Otherwise, if the types <span class='texttt'>T1</span> and <span class='texttt'>T2</span> of <span class='texttt'>E1</span> and
<span class='texttt'>E2</span> satisfy <span class='texttt'>IndirectlyMovableStorable&lt;T1, T2&gt;() &amp;&amp;
IndirectlyMovableStorable&lt;T2, T1&gt;()</span>, exchanges the values denoted by
<span class='texttt'>E1</span> and <span class='texttt'>E2</span>.
</p></li><li id='iterator.custpoints.iter_swap-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.custpoints.iter_swap-1.4'>(1.4)</a></div><p >Otherwise, <span class='texttt'>ranges::iter_swap(E1, E2)</span> is ill-formed.
</p></li></ul></div><div class='para' id='iterator.custpoints.iter_swap-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.custpoints.iter_swap-2'>2</a></div><p >If <span class='texttt'>ranges::iter_swap(E1, E2)</span> does not swap the values denoted by the
expressions <span class='texttt'>E1</span> and <span class='texttt'>E2</span>, the program is ill-formed with no
diagnostic required.</p></div></div></div><div id='iterator.assoc.types'><h3 ><a class='secnum' href='#iterator.assoc.types' style='min-width:103pt'>9.3.3</a> Iterator associated types <a class='abbr_ref' href='iterator.assoc.types.html'>[iterator.assoc.types]</a></h3><div class='para' id='iterator.assoc.types-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types-1'>1</a></div><p >To implement algorithms only in terms of iterators, it is often necessary to
determine the value and
difference types that correspond to a particular iterator type.
Accordingly, it is required that if
<span class='texttt'>WI</span> is the name of a type that
satisfies the <span class='texttt'>WeaklyIncrementable</span> concept (<a href='iterators.weaklyincrementable.html'>[iterators.weaklyincrementable]</a>),
<span class='texttt'>R</span> is the name of a type that
satisfies the <span class='texttt'>Readable</span> concept (<a href='iterators.readable.html'>[iterators.readable]</a>), and
<span class='texttt'>II</span> is the name of a type that satisfies the
<span class='texttt'>InputIterator</span> concept (<a href='iterators.input.html'>[iterators.input]</a>) concept, the types</p><pre class='codeblock'>
difference_type_t&lt;WI&gt;
value_type_t&lt;R&gt;
iterator_category_t&lt;II&gt;
</pre><p >be defined as the iterator's difference type, value type and iterator category, respectively.</p></div><div id='iterator.assoc.types.difference_type'><h4 ><a class='secnum' href='#iterator.assoc.types.difference_type' style='min-width:118pt'>9.3.3.1</a> <span class='texttt'>difference_type</span> <a class='abbr_ref' href='iterator.assoc.types.difference_type.html'>[iterator.assoc.types.difference_type]</a></h4><div class='para' id='iterator.assoc.types.difference_type-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.difference_type-1'>1</a></div><p ><span class='indexparent'><a class='index' id='difference_type_t'></a></span><span class='texttt'>difference_type_t&lt;T&gt;</span> is implemented as if:</p><p ><span class='indexparent'><a class='index' id='difference_type'></a></span></p><pre class='codeblock'>
  template &lt;class&gt; struct difference_type { };

  template &lt;class T&gt;
  struct difference_type&lt;T*&gt;
    : enable_if&lt;is_object&lt;T&gt;::value, ptrdiff_t&gt; { };

  template &lt;class I&gt;
  struct difference_type&lt;I const&gt; : difference_type&lt;decay_t&lt;I&gt;&gt; { };

  template &lt;class T&gt;
    requires requires { typename T::difference_type; }
  struct difference_type&lt;T&gt; {
    using type = typename T::difference_type;
  };

  template &lt;class T&gt;
    requires !requires { typename T::difference_type; } &amp;&amp;
      requires(const T&amp; a, const T&amp; b) { { a - b } -&gt; Integral; }
  struct difference_type&lt;T&gt;
    : make_signed&lt; decltype(declval&lt;T&gt;() - declval&lt;T&gt;()) &gt; {
  };

  template &lt;class T&gt; using difference_type_t
    = typename difference_type&lt;T&gt;::type;
</pre></div><div class='para' id='iterator.assoc.types.difference_type-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.difference_type-2'>2</a></div><p >Users may specialize <span class='texttt'>difference_type</span> on user-defined types.</p></div></div><div id='iterator.assoc.types.value_type'><h4 ><a class='secnum' href='#iterator.assoc.types.value_type' style='min-width:118pt'>9.3.3.2</a> <span class='texttt'>value_type</span> <a class='abbr_ref' href='iterator.assoc.types.value_type.html'>[iterator.assoc.types.value_type]</a></h4><div class='para' id='iterator.assoc.types.value_type-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.value_type-1'>1</a></div><p >A <span class='texttt'>Readable</span> type has an associated value type that can be accessed with the
<span class='texttt'>value_type_t</span> alias template.</p><p ><span class='indexparent'><a class='index' id='value_type'></a></span></p><pre class='codeblock'>
  template &lt;class&gt; struct value_type { };

  template &lt;class T&gt;
  struct value_type&lt;T*&gt;
    : enable_if&lt;is_object&lt;T&gt;::value, remove_cv_t&lt;T&gt;&gt; { };

  template &lt;class I&gt;
    requires is_array&lt;I&gt;::value
  struct value_type&lt;I&gt; : value_type&lt;decay_t&lt;I&gt;&gt; { };

  template &lt;class I&gt;
  struct value_type&lt;I const&gt; : value_type&lt;decay_t&lt;I&gt;&gt; { };

  template &lt;class T&gt;
    requires requires { typename T::value_type; }
  struct value_type&lt;T&gt;
    : enable_if&lt;is_object&lt;typename T::value_type&gt;::value, typename T::value_type&gt; { };

  template &lt;class T&gt;
    requires requires { typename T::element_type; }
  struct value_type&lt;T&gt;
    : enable_if&lt;is_object&lt;typename T::element_type&gt;::value, typename T::element_type&gt; { };

  template &lt;class T&gt; using value_type_t
    = typename value_type&lt;T&gt;::type;
</pre></div><div class='para' id='iterator.assoc.types.value_type-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.value_type-2'>2</a></div><p >If a type <span class='texttt'>I</span> has an associated value type, then <span class='texttt'>value_type&lt;I&gt;::type</span> shall name the
value type. Otherwise, there shall be no nested type <span class='texttt'>type</span>.</p></div><div class='para' id='iterator.assoc.types.value_type-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.value_type-3'>3</a></div><p >The <span class='texttt'>value_type</span> class template may be specialized on user-defined types.</p></div><div class='para' id='iterator.assoc.types.value_type-4'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.value_type-4'>4</a></div><p >When instantiated with a type <span class='texttt'>I</span>
such that <span class='texttt'>I::value_type</span> is valid and denotes a type,
<span class='texttt'>value_type&lt;I&gt;::type</span> names that type, unless it is not an object type (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> basic.types <span class='endcsname'></span>) in which case
<span class='texttt'>value_type&lt;I&gt;</span> shall have no nested type <span class='texttt'>type</span>. [&nbsp;<i>Note:</i> Some legacy output
iterators define a nested type named <span class='texttt'>value_type</span> that is an alias for <span class='texttt'>void</span>. These
types are not <span class='texttt'>Readable</span> and have no associated value types.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='iterator.assoc.types.value_type-5'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.value_type-5'>5</a></div><p >When instantiated with a type <span class='texttt'>I</span>
such that <span class='texttt'>I::element_type</span> is valid and denotes a type,
<span class='texttt'>value_type&lt;I&gt;::type</span> names that type, unless it is not an object type (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> basic.types <span class='endcsname'></span>) in which case
<span class='texttt'>value_type&lt;I&gt;</span> shall have no nested type <span class='texttt'>type</span>. [&nbsp;<i>Note:</i> Smart pointers like
<span class='texttt'>shared_ptr&lt;int&gt;</span> are <span class='texttt'>Readable</span> and have an associated value type. But a smart pointer
like <span class='texttt'>shared_ptr&lt;void&gt;</span> is not <span class='texttt'>Readable</span> and has no associated value type.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterator.assoc.types.iterator_category'><h4 ><a class='secnum' href='#iterator.assoc.types.iterator_category' style='min-width:118pt'>9.3.3.3</a> <span class='texttt'>iterator_category</span> <a class='abbr_ref' href='iterator.assoc.types.iterator_category.html'>[iterator.assoc.types.iterator_category]</a></h4><div class='para' id='iterator.assoc.types.iterator_category-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.iterator_category-1'>1</a></div><p ><span class='indexparent'><a class='index' id='iterator_category_t'></a></span><span class='texttt'>iterator_category_t&lt;T&gt;</span>
is implemented as if:</p><p ><span class='indexparent'><a class='index' id='iterator_category'></a></span></p><pre class='codeblock'>
  template &lt;class&gt; struct iterator_category { };

  template &lt;class T&gt;
  struct iterator_category&lt;T*&gt;
    : enable_if&lt;is_object&lt;T&gt;::value, random_access_iterator_tag&gt; { };

  template &lt;class T&gt;
  struct iterator_category&lt;T const&gt; : iterator_category&lt;T&gt; { };

  template &lt;class T&gt;
    requires requires { typename T::iterator_category; }
  struct iterator_category&lt;T&gt; {
    using type = <i><span class='texttt'>see below</span></i>;
  };

  template &lt;class T&gt; using iterator_category_t
    = typename iterator_category&lt;T&gt;::type;
</pre></div><div class='para' id='iterator.assoc.types.iterator_category-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.iterator_category-2'>2</a></div><p >Users may specialize <span class='texttt'>iterator_category</span> on user-defined types.</p></div><div class='para' id='iterator.assoc.types.iterator_category-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.iterator_category-3'>3</a></div><p >If
<span class='texttt'>T::iterator_category</span> is valid and denotes a type, then the
type <span class='texttt'>iterator_category&lt;T&gt;::type</span> is computed as follows:
</p><ul class='itemize'><li id='iterator.assoc.types.iterator_category-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.assoc.types.iterator_category-3.1'>(3.1)</a></div><p >If <span class='texttt'>T::iterator_category</span> is the same as or derives from <span class='texttt'>std::random_access_iterator_tag</span>,
      <span class='texttt'>iterator_category&lt;T&gt;::type</span> is <span class='texttt'>ranges::random_access_iterator_tag</span>.
</p></li><li id='iterator.assoc.types.iterator_category-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.assoc.types.iterator_category-3.2'>(3.2)</a></div><p >Otherwise, if <span class='texttt'>T::iterator_category</span> is the same as or derives from <span class='texttt'>std::bidirectional_iterator_tag</span>,
      <span class='texttt'>iterator_category&lt;T&gt;::type</span> is <span class='texttt'>ranges::bidirectional_iterator_tag</span>.
</p></li><li id='iterator.assoc.types.iterator_category-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.assoc.types.iterator_category-3.3'>(3.3)</a></div><p >Otherwise, if <span class='texttt'>T::iterator_category</span> is the same as or derives from <span class='texttt'>std::forward_iterator_tag</span>,
      <span class='texttt'>iterator_category&lt;T&gt;::type</span> is <span class='texttt'>ranges::forward_iterator_tag</span>.
</p></li><li id='iterator.assoc.types.iterator_category-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.assoc.types.iterator_category-3.4'>(3.4)</a></div><p >Otherwise, if <span class='texttt'>T::iterator_category</span> is the same as or derives from <span class='texttt'>std::input_iterator_tag</span>,
      <span class='texttt'>iterator_category&lt;T&gt;::type</span> is <span class='texttt'>ranges::input_iterator_tag</span>.
</p></li><li id='iterator.assoc.types.iterator_category-3.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.assoc.types.iterator_category-3.5'>(3.5)</a></div><p >Otherwise, if <span class='texttt'>T::iterator_category</span> is the same as or derives from <span class='texttt'>std::output_iterator_tag</span>,
      <span class='texttt'>iterator_category&lt;T&gt;</span> has no nested <span class='texttt'>type</span>.
</p></li><li id='iterator.assoc.types.iterator_category-3.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.assoc.types.iterator_category-3.6'>(3.6)</a></div><p >Otherwise, <span class='texttt'>iterator_category&lt;T&gt;::type</span> is <span class='texttt'>T::iterator_category</span>
</p></li></ul></div><div class='para' id='iterator.assoc.types.iterator_category-4'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.iterator_category-4'>4</a></div><p ><span class='indexparent'><a class='index' id='rvalue_reference_t'></a></span><span class='texttt'>rvalue_reference_t&lt;T&gt;</span> is implemented as if:</p><p ><code class='itemdecl'>
  template &lt;<i>dereferenceable</i> T&gt;
      requires <i><span class='texttt'>see below</span></i> using rvalue_reference_t
    = decltype(ranges::iter_move(declval&lt;T&amp;&gt;()));
</code></p></div><div class='itemdescr'></div><div class='para' id='iterator.assoc.types.iterator_category-5'><div class='marginalizedparent'><a class='marginalized' href='#iterator.assoc.types.iterator_category-5'>5</a></div><div class='itemdescr'><p >The expression in the <span class='texttt'>requires</span> clause is equivalent to:
</p><pre class='codeblock'>
requires(T&amp; t) { { ranges::iter_move(t) } -&gt; auto&amp;&amp;; }
</pre></div></div></div></div><div id='readable'><h3 ><a class='secnum' href='#readable' style='min-width:103pt'>9.3.4</a> Concept <span class='texttt'>Readable</span> <a class='abbr_ref' href='iterators.readable.html'>[iterators.readable]</a></h3><div class='para' id='readable-1'><div class='marginalizedparent'><a class='marginalized' href='#readable-1'>1</a></div><p >The <span class='texttt'>Readable</span> concept is satisfied by types that are readable by
applying <span class='texttt'>operator*</span> including pointers, smart pointers, and iterators.</p><p ><span class='indexparent'><a class='index' id='Readable'></a></span></p><pre class='codeblock'>
  template &lt;class In&gt;
  concept bool Readable() {
    return Movable&lt;In&gt;() &amp;&amp; DefaultConstructible&lt;In&gt;() &amp;&amp;
      requires(const In&amp; i) {
        typename value_type_t&lt;In&gt;;
        typename reference_t&lt;In&gt;;
        typename rvalue_reference_t&lt;In&gt;;
        { *i } -&gt; Same&lt;reference_t&lt;In&gt;&gt;;
        { ranges::iter_move(i) } -&gt; Same&lt;rvalue_reference_t&lt;In&gt;&gt;;
      } &amp;&amp;
      CommonReference&lt;reference_t&lt;In&gt;, value_type_t&lt;In&gt;&amp;&gt;() &amp;&amp;
      CommonReference&lt;reference_t&lt;In&gt;, rvalue_reference_t&lt;In&gt;&gt;() &amp;&amp;
      CommonReference&lt;rvalue_reference_t&lt;In&gt;, const value_type_t&lt;In&gt;&amp;&gt;();
  }
</pre></div></div><div id='writable'><h3 ><a class='secnum' href='#writable' style='min-width:103pt'>9.3.5</a> Concept <span class='texttt'>Writable</span> <a class='abbr_ref' href='iterators.writable.html'>[iterators.writable]</a></h3><div class='para' id='writable-1'><div class='marginalizedparent'><a class='marginalized' href='#writable-1'>1</a></div><p >The <span class='texttt'>Writable</span> concept specifies the requirements for writing a value into an iterator's
referenced object.</p><p ><span class='indexparent'><a class='index' id='Writable'></a></span></p><pre class='codeblock'>
  template &lt;class Out, class T&gt;
  concept bool Writable() {
    return Movable&lt;Out&gt;() &amp;&amp; DefaultConstructible&lt;Out&gt;() &amp;&amp;
      requires(Out o, T&amp;&amp; t) {
        *o = std::forward&lt;T&gt;(t); <span class='comment'>// not required to be equality preserving
</span>      };
  }
</pre></div><div class='para' id='writable-2'><div class='marginalizedparent'><a class='marginalized' href='#writable-2'>2</a></div><p >Let <span class='texttt'>E</span> be an an expression such that <span class='texttt'>decltype((E))</span> is <span class='texttt'>T</span>, and let <span class='texttt'>o</span>
be a dereferenceable object of type <span class='texttt'>Out</span>. Then <span class='texttt'>Writable&lt;Out, T&gt;()</span> is satisfied if and only if</p><ul class='itemize'><li id='writable-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#writable-2.1'>(2.1)</a></div><p >If <span class='texttt'>Readable&lt;Out&gt;() &amp;&amp; Same&lt;value_type_t&lt;Out&gt;, decay_t&lt;T&gt;&gt;()</span> is satisfied,
then <span class='texttt'>*o</span> after the assignment is equal
to the value of <span class='texttt'>E</span> before the assignment.
</p></li></ul></div><div class='para' id='writable-3'><div class='marginalizedparent'><a class='marginalized' href='#writable-3'>3</a></div><p >After evaluating the assignment expression, <span class='texttt'>o</span> is not required to be dereferenceable.</p></div><div class='para' id='writable-4'><div class='marginalizedparent'><a class='marginalized' href='#writable-4'>4</a></div><p >If <span class='texttt'>E</span> is an xvalue (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> basic.lval <span class='endcsname'></span>), the resulting
state of the object it denotes is valid but unspecified (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> lib.types.movedfrom <span class='endcsname'></span>).</p></div><div class='para' id='writable-5'><div class='marginalizedparent'><a class='marginalized' href='#writable-5'>5</a></div><p >[&nbsp;<i>Note:</i>
The only valid use of an <span class='texttt'>operator*</span> is on the left side of the assignment statement.
<i>Assignment through the same value of the writable type happens only once.</i>
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='weaklyincrementable'><h3 ><a class='secnum' href='#weaklyincrementable' style='min-width:103pt'>9.3.6</a> Concept <span class='texttt'>WeaklyIncrementable</span> <a class='abbr_ref' href='iterators.weaklyincrementable.html'>[iterators.weaklyincrementable]</a></h3><div class='para' id='weaklyincrementable-1'><div class='marginalizedparent'><a class='marginalized' href='#weaklyincrementable-1'>1</a></div><p >The <span class='texttt'>WeaklyIncrementable</span> concept specifies the requirements on
types that can be incremented with the pre- and post-increment operators.
The increment operations are not required to be equality-preserving,
nor is the type required to be <span class='texttt'>EqualityComparable</span>.</p><p ><span class='indexparent'><a class='index' id='WeaklyIncrementable'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool WeaklyIncrementable() {
    return Semiregular&lt;I&gt;() &amp;&amp;
      requires(I i) {
        typename difference_type_t&lt;I&gt;;
        requires SignedIntegral&lt;difference_type_t&lt;I&gt;&gt;();
        { ++i } -&gt; Same&lt;I&amp;&gt;; <span class='comment'>// not required to be equality preserving
</span>        i++; <span class='comment'>// not required to be equality preserving
</span>      };
  }
</pre></div><div class='para' id='weaklyincrementable-2'><div class='marginalizedparent'><a class='marginalized' href='#weaklyincrementable-2'>2</a></div><p >Let <span class='texttt'>i</span> be an object of type <span class='texttt'>I</span>. When both pre- and post-increment
are valid, <span class='texttt'>i</span> is said to be <i>incrementable</i>. Then
<span class='texttt'>WeaklyIncrementable&lt;I&gt;()</span> is satisfied if and only if</p><ul class='itemize'><li id='weaklyincrementable-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#weaklyincrementable-2.1'>(2.1)</a></div><p ><span class='texttt'>++i</span> is valid if and only if <span class='texttt'>i++</span> is valid.
</p></li><li id='weaklyincrementable-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#weaklyincrementable-2.2'>(2.2)</a></div><p >If <span class='texttt'>i</span> is incrementable, then both <span class='texttt'>++i</span>
  and <span class='texttt'>i++</span> advance <span class='texttt'>i</span> to the next element.
</p></li><li id='weaklyincrementable-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#weaklyincrementable-2.3'>(2.3)</a></div><p >If <span class='texttt'>i</span> is incrementable, then <span class='texttt'>&amp;++i</span> is equal to <span class='texttt'>&amp;i</span>.
</p></li></ul></div><div class='para' id='weaklyincrementable-3'><div class='marginalizedparent'><a class='marginalized' href='#weaklyincrementable-3'>3</a></div><p >[&nbsp;<i>Note:</i> For <span class='texttt'>WeaklyIncrementable</span> types, <span class='texttt'>a</span> equals <span class='texttt'>b</span> does not imply that <span class='texttt'>++a</span>
equals <span class='texttt'>++b</span>. (Equality does not guarantee the substitution property or referential
transparency.) Algorithms on weakly incrementable types should never attempt to pass
through the same incrementable value twice. They should be single pass algorithms. These algorithms
can be used with istreams as the source of the input data through the <span class='texttt'>istream_iterator</span> class
template.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='incrementable'><h3 ><a class='secnum' href='#incrementable' style='min-width:103pt'>9.3.7</a> Concept <span class='texttt'>Incrementable</span> <a class='abbr_ref' href='iterators.incrementable.html'>[iterators.incrementable]</a></h3><div class='para' id='incrementable-1'><div class='marginalizedparent'><a class='marginalized' href='#incrementable-1'>1</a></div><p >The <span class='texttt'>Incrementable</span> concept specifies requirements on types that can be incremented with the pre-
and post-increment operators. The increment operations are required to be equality-preserving,
and the type is required to be <span class='texttt'>EqualityComparable</span>. [&nbsp;<i>Note:</i> This requirement
supersedes the annotations on the increment expressions in the definition of
<span class='texttt'>WeaklyIncrementable</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='Incrementable'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool Incrementable() {
    return Regular&lt;I&gt;() &amp;&amp;
      WeaklyIncrementable&lt;I&gt;() &amp;&amp;
      requires(I i) {
        { i++ } -&gt; Same&lt;I&gt;;
      };
  }
</pre></div><div class='para' id='incrementable-2'><div class='marginalizedparent'><a class='marginalized' href='#incrementable-2'>2</a></div><p >Let <span class='texttt'>a</span> and <span class='texttt'>b</span> be incrementable objects of type <span class='texttt'>I</span>.
Then <span class='texttt'>Incrementable&lt;I&gt;()</span> is satisfied
if and only if</p><ul class='itemize'><li id='incrementable-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#incrementable-2.1'>(2.1)</a></div><p >If <span class='texttt'>bool(a == b)</span> then <span class='texttt'>bool(a++ == b)</span>.
</p></li><li id='incrementable-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#incrementable-2.2'>(2.2)</a></div><p >If <span class='texttt'>bool(a == b)</span> then <span class='texttt'>bool((a++, a) == ++b)</span>.
</p></li></ul></div><div class='para' id='incrementable-3'><div class='marginalizedparent'><a class='marginalized' href='#incrementable-3'>3</a></div><p >[&nbsp;<i>Note:</i> The requirement that <span class='texttt'>a</span> equals <span class='texttt'>b</span> implies <span class='texttt'>++a</span> equals <span class='texttt'>++b</span>
(which is not true for weakly incrementable types) allows the use of multi-pass one-directional
algorithms with types that satisfy <span class='texttt'>Incrementable</span>.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterator'><h3 ><a class='secnum' href='#iterator' style='min-width:103pt'>9.3.8</a> Concept <span class='texttt'>Iterator</span> <a class='abbr_ref' href='iterators.iterator.html'>[iterators.iterator]</a></h3><div class='para' id='iterator-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator-1'>1</a></div><p >The <span class='texttt'>Iterator</span> concept forms
the basis of the iterator concept taxonomy; every iterator satisfies the
<span class='texttt'>Iterator</span> requirements. This
concept specifies operations for dereferencing and incrementing
an iterator. Most algorithms will require additional operations
to compare iterators with sentinels (<a href='iterators.sentinel.html'>[iterators.sentinel]</a>), to
read (<a href='iterators.input.html'>[iterators.input]</a>) or write (<a href='iterators.output.html'>[iterators.output]</a>) values, or
to provide a richer set of iterator movements (<a href='iterators.forward.html'>[iterators.forward]</a>,
<a href='iterators.bidirectional.html'>[iterators.bidirectional]</a>, <a href='iterators.random.access.html'>[iterators.random.access]</a>).)</p><p ><span class='indexparent'><a class='index' id='Iterator'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool Iterator() {
    return WeaklyIncrementable&lt;I&gt;() &amp;&amp;
      requires(I i) {
        { *i } -&gt; auto&amp;&amp;; <span class='comment'>// Requires: i is dereferenceable
</span>      };
  }
</pre></div><div class='para' id='iterator-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator-2'>2</a></div><p >[&nbsp;<i>Note:</i> The requirement that the result of dereferencing the iterator is deducible from
<span class='texttt'>auto&amp;&amp;</span> means that it cannot be <span class='texttt'>void</span>.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='sentinel'><h3 ><a class='secnum' href='#sentinel' style='min-width:103pt'>9.3.9</a> Concept <span class='texttt'>Sentinel</span> <a class='abbr_ref' href='iterators.sentinel.html'>[iterators.sentinel]</a></h3><div class='para' id='sentinel-1'><div class='marginalizedparent'><a class='marginalized' href='#sentinel-1'>1</a></div><p >The <span class='texttt'>Sentinel</span> concept
specifies the relationship
between an <span class='texttt'>Iterator</span> type and a <span class='texttt'>Semiregular</span> type whose values
denote a range.</p><p ><span class='indexparent'><a class='index' id='Sentinel'></a></span><code class='itemdecl'>
  template &lt;class S, class I&gt;
  concept bool Sentinel() {
    return Semiregular&lt;S&gt;() &amp;&amp;
      Iterator&lt;I&gt;() &amp;&amp;
      WeaklyEqualityComparable&lt;S, I&gt;();
  }
</code></p></div><div class='itemdescr'></div><div class='para' id='sentinel-2'><div class='marginalizedparent'><a class='marginalized' href='#sentinel-2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'>s</span> and <span class='texttt'>i</span> be values of type <span class='texttt'>S</span> and
<span class='texttt'>I</span> such that <span class='texttt'>[i,s)</span> denotes a range. Types
<span class='texttt'>S</span> and <span class='texttt'>I</span> satisfy <span class='texttt'>Sentinel&lt;S, I&gt;()</span>
if and only if:</p><ul class='itemize'><li id='sentinel-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#sentinel-2.1'>(2.1)</a></div><p ><span class='texttt'>i == s</span> is well-defined.</p></li><li id='sentinel-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#sentinel-2.2'>(2.2)</a></div><p >If <span class='texttt'>bool(i != s)</span> then <span class='texttt'>i</span> is dereferenceable and
      <span class='texttt'>[++i,s)</span> denotes a range.
</p></li></ul></div></div><div class='para' id='sentinel-3'><div class='marginalizedparent'><a class='marginalized' href='#sentinel-3'>3</a></div><p >The domain of <span class='texttt'>==</span> can change over time.
Given an iterator <span class='texttt'>i</span> and sentinel <span class='texttt'>s</span> such that <span class='texttt'>[i,s)</span>
denotes a range and <span class='texttt'>i != s</span>, <span class='texttt'>[i,s)</span> is not required to continue to
denote a range after incrementing any iterator equal to <span class='texttt'>i</span>. Consequently,
<span class='texttt'>i == s</span> is no longer required to be well-defined.</p></div></div><div id='sizedsentinel'><h3 ><a class='secnum' href='#sizedsentinel' style='min-width:103pt'>9.3.10</a> Concept <span class='texttt'>SizedSentinel</span> <a class='abbr_ref' href='iterators.sizedsentinel.html'>[iterators.sizedsentinel]</a></h3><div class='para' id='sizedsentinel-1'><div class='marginalizedparent'><a class='marginalized' href='#sizedsentinel-1'>1</a></div><p >The <span class='texttt'>SizedSentinel</span> concept specifies
requirements on an <span class='texttt'>Iterator</span> and a <span class='texttt'>Sentinel</span>
that allow the use of the <span class='texttt'>-</span> operator to compute the distance
between them in constant time.</p><p ><span class='indexparent'><a class='index' id='SizedSentinel'></a></span>
<code class='itemdecl'>
  template &lt;class S, class I&gt;
  concept bool SizedSentinel() {
    return Sentinel&lt;S, I&gt;() &amp;&amp;
      !disable_sized_sentinel&lt;remove_cv_t&lt;S&gt;, remove_cv_t&lt;I&gt;&gt; &amp;&amp;
      requires(const I&amp; i, const S&amp; s) {
        { s - i } -&gt; Same&lt;difference_type_t&lt;I&gt;&gt;;
        { i - s } -&gt; Same&lt;difference_type_t&lt;I&gt;&gt;;
      };
  }
</code></p></div><div class='itemdescr'></div><div class='para' id='sizedsentinel-2'><div class='marginalizedparent'><a class='marginalized' href='#sizedsentinel-2'>2</a></div><div class='itemdescr'><p >Let <span class='texttt'>i</span> be an iterator of type <span class='texttt'>I</span>, and <span class='texttt'>s</span>
a sentinel of type <span class='texttt'>S</span> such that <span class='texttt'>[i,s)</span> denotes a range.
Let <span class='math'><span class='mathalpha'>N</span></span> be the smallest number of applications of <span class='texttt'>++i</span>
necessary to make <span class='texttt'>bool(i == s)</span> be <span class='texttt'>true</span>.
<span class='texttt'>SizedSentinel&lt;S, I&gt;()</span> is satisfied if and only if:</p><ul class='itemize'><li id='sizedsentinel-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#sizedsentinel-2.1'>(2.1)</a></div><p >If <span class='math'><span class='mathalpha'>N</span></span> is representable by <span class='texttt'>difference_type_t&lt;I&gt;</span>,
      then <span class='texttt'>s - i</span> is well-defined and equals <span class='math'><span class='mathalpha'>N</span></span>.</p></li><li id='sizedsentinel-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#sizedsentinel-2.2'>(2.2)</a></div><p >If <span class='math'>-<span class='mathalpha'>N</span></span> is representable by <span class='texttt'>difference_type_t&lt;I&gt;</span>,
      then <span class='texttt'>i - s</span> is well-defined and equals <span class='math'>-<span class='mathalpha'>N</span></span>.
</p></li></ul></div></div><div class='para' id='sizedsentinel-3'><div class='marginalizedparent'><a class='marginalized' href='#sizedsentinel-3'>3</a></div><p >[&nbsp;<i>Note:</i> <span class='texttt'>disable_sized_sentinel</span> provides a mechanism to
enable use of sentinels and iterators with the library that meet the
syntactic requirements but do not in fact satisfy <span class='texttt'>SizedSentinel</span>.
A program that instantiates a library template that requires
<span class='texttt'>SizedSentinel</span> with an iterator type <span class='texttt'>I</span> and sentinel type
<span class='texttt'>S</span> that meet the syntactic requirements of <span class='texttt'>SizedSentinel&lt;S, I&gt;()</span>
but do not satisfy <span class='texttt'>SizedSentinel</span> is ill-formed with no diagnostic required
unless <span class='texttt'>disable_sized_sentinel&lt;S, I&gt;</span> evaluates to
<span class='texttt'>true</span> (<a href='structure.requirements.html'>[structure.requirements]</a>). <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='sizedsentinel-4'><div class='marginalizedparent'><a class='marginalized' href='#sizedsentinel-4'>4</a></div><p >[&nbsp;<i>Note:</i> The <span class='texttt'>SizedSentinel</span>
concept is satisfied by pairs of
<span class='texttt'>RandomAccessIterator</span>s (<a href='iterators.random.access.html'>[iterators.random.access]</a>) and by
counted iterators and their sentinels (<a href='counted.iterator.html'>[counted.iterator]</a>).<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='input'><h3 ><a class='secnum' href='#input' style='min-width:103pt'>9.3.11</a> Concept <span class='texttt'>InputIterator</span> <a class='abbr_ref' href='iterators.input.html'>[iterators.input]</a></h3><div class='para' id='input-1'><div class='marginalizedparent'><a class='marginalized' href='#input-1'>1</a></div><p >The <span class='texttt'>InputIterator</span> concept is a refinement of
<span class='texttt'>Iterator</span> (<a href='iterators.iterator.html'>[iterators.iterator]</a>). It
defines requirements for a type whose referenced values can be read (from the requirement for
<span class='texttt'>Readable</span> (<a href='iterators.readable.html'>[iterators.readable]</a>)) and which can be both pre- and post-incremented.
[&nbsp;<i>Note:</i> Unlike in ISO/IEC 14882, input iterators are not required to satisfy
<span class='texttt'>EqualityComparable</span> (<a href='concepts.lib.compare.equalitycomparable.html'>[concepts.lib.compare.equalitycomparable]</a>).<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='InputIterator'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool InputIterator() {
    return Iterator&lt;I&gt;() &amp;&amp;
      Readable&lt;I&gt;() &amp;&amp;
      requires(I i, const I ci) {
        typename iterator_category_t&lt;I&gt;;
        requires DerivedFrom&lt;iterator_category_t&lt;I&gt;, input_iterator_tag&gt;();
        { i++ } -&gt; Readable; <span class='comment'>// not required to be equality preserving
</span>        requires Same&lt;value_type_t&lt;I&gt;, value_type_t&lt;decltype(i++)&gt;&gt;();
        { *ci } -&gt; const value_type_t&lt;I&gt;&amp;;
      };
  }
</pre></div></div><div id='output'><h3 ><a class='secnum' href='#output' style='min-width:103pt'>9.3.12</a> Concept <span class='texttt'>OutputIterator</span> <a class='abbr_ref' href='iterators.output.html'>[iterators.output]</a></h3><div class='para' id='output-1'><div class='marginalizedparent'><a class='marginalized' href='#output-1'>1</a></div><p >The <span class='texttt'>OutputIterator</span> concept is a refinement of
<span class='texttt'>Iterator</span> (<a href='iterators.iterator.html'>[iterators.iterator]</a>). It defines requirements for a type that
can be used to write values (from the requirement for
<span class='texttt'>Writable</span> (<a href='iterators.writable.html'>[iterators.writable]</a>)) and which can be both pre- and post-incremented.
However, output iterators are not required to
satisfy <span class='texttt'>EqualityComparable</span>.</p><p ><span class='indexparent'><a class='index' id='OutputIterator'></a></span></p><pre class='codeblock'>
  template &lt;class I, class T&gt;
  concept bool OutputIterator() {
    return Iterator&lt;I&gt;() &amp;&amp; Writable&lt;I, T&gt;();
  }
</pre></div><div class='para' id='output-2'><div class='marginalizedparent'><a class='marginalized' href='#output-2'>2</a></div><p >[&nbsp;<i>Note:</i>
Algorithms on output iterators should never attempt to pass through the same iterator twice.
They should be
<a class='hidden_link' href='#def:single_pass' id='def:single_pass'><i>single pass</i></a>
algorithms.
Algorithms that take output iterators can be used with ostreams as the destination
for placing data through the
<span class='texttt'>ostream_iterator</span>
class as well as with insert iterators and insert pointers.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='forward'><h3 ><a class='secnum' href='#forward' style='min-width:103pt'>9.3.13</a> Concept <span class='texttt'>ForwardIterator</span> <a class='abbr_ref' href='iterators.forward.html'>[iterators.forward]</a></h3><div class='para' id='forward-1'><div class='marginalizedparent'><a class='marginalized' href='#forward-1'>1</a></div><p >The <span class='texttt'>ForwardIterator</span> concept refines <span class='texttt'>InputIterator</span> (<a href='iterators.input.html'>[iterators.input]</a>),
adding equality comparison and the multi-pass guarantee, specified below.</p><p ><span class='indexparent'><a class='index' id='ForwardIterator'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool ForwardIterator() {
    return InputIterator&lt;I&gt;() &amp;&amp;
      DerivedFrom&lt;iterator_category_t&lt;I&gt;, forward_iterator_tag&gt;() &amp;&amp;
      Incrementable&lt;I&gt;()&amp;&amp;
      Sentinel&lt;I, I&gt;();
  }
</pre></div><div class='para' id='forward-2'><div class='marginalizedparent'><a class='marginalized' href='#forward-2'>2</a></div><p >The domain of <span class='texttt'>==</span> for forward iterators is that of iterators over the same
underlying sequence. However, value-initialized iterators of the same type
may be compared and shall compare equal to other value-initialized iterators of the same type.
[&nbsp;<i>Note:</i> Value-initialized iterators behave as if they refer past the end of
the same empty sequence. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='forward-3'><div class='marginalizedparent'><a class='marginalized' href='#forward-3'>3</a></div><p >Two dereferenceable iterators <span class='texttt'>a</span> and <span class='texttt'>b</span> of type <span class='texttt'>X</span> offer the
<a class='hidden_link' href='#def:multi-pass_guarantee' id='def:multi-pass_guarantee'><i>multi-pass guarantee</i></a> if:</p><ul class='itemize'><li id='forward-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#forward-3.1'>(3.1)</a></div><p ><span class='texttt'>a == b</span> implies <span class='texttt'>++a == ++b</span> and
</p></li><li id='forward-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#forward-3.2'>(3.2)</a></div><p >The expression
<span class='texttt'>([](X x){++x;}(a), *a)</span> is equivalent to the expression <span class='texttt'>*a</span>.
</p></li></ul></div><div class='para' id='forward-4'><div class='marginalizedparent'><a class='marginalized' href='#forward-4'>4</a></div><p >[&nbsp;<i>Note:</i>
The requirement that
<span class='texttt'>a == b</span>
implies
<span class='texttt'>++a == ++b</span>
(which is not true for weaker iterators)
and the removal of the restrictions on the number of assignments through
a mutable iterator
(which applies to output iterators)
allow the use of multi-pass one-directional algorithms with forward iterators.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='bidirectional'><h3 ><a class='secnum' href='#bidirectional' style='min-width:103pt'>9.3.14</a> Concept <span class='texttt'>BidirectionalIterator</span> <a class='abbr_ref' href='iterators.bidirectional.html'>[iterators.bidirectional]</a></h3><div class='para' id='bidirectional-1'><div class='marginalizedparent'><a class='marginalized' href='#bidirectional-1'>1</a></div><p >The <span class='texttt'>BidirectionalIterator</span> concept refines <span class='texttt'>ForwardIterator</span> (<a href='iterators.forward.html'>[iterators.forward]</a>),
and adds the ability to move an iterator backward as well as forward.</p><p ><span class='indexparent'><a class='index' id='BidirectionalIterator'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool BidirectionalIterator() {
    return ForwardIterator&lt;I&gt;() &amp;&amp;
      DerivedFrom&lt;iterator_category_t&lt;I&gt;, bidirectional_iterator_tag&gt;() &amp;&amp;
      requires(I i) {
        { --i } -&gt; Same&lt;I&amp;&gt;;
        { i-- } -&gt; Same&lt;I&gt;;
      };
  }
</pre></div><div class='para' id='bidirectional-2'><div class='marginalizedparent'><a class='marginalized' href='#bidirectional-2'>2</a></div><p >A bidirectional iterator <span class='texttt'>r</span> is decrementable if and only if there exists some <span class='texttt'>s</span> such that
<span class='texttt'>++s == r</span>. The expressions <span class='texttt'>--r</span> and <span class='texttt'>r--</span> are only valid if <span class='texttt'>r</span> is
decrementable.</p></div><div class='para' id='bidirectional-3'><div class='marginalizedparent'><a class='marginalized' href='#bidirectional-3'>3</a></div><p >Let <span class='texttt'>a</span> and <span class='texttt'>b</span> be decrementable objects of type <span class='texttt'>I</span>. Then
<span class='texttt'>BidirectionalIterator&lt;I&gt;()</span> is satisfied if and only if:</p><ul class='itemize'><li id='bidirectional-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#bidirectional-3.1'>(3.1)</a></div><p ><span class='texttt'>&amp;--a == &amp;a</span>.
</p></li><li id='bidirectional-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#bidirectional-3.2'>(3.2)</a></div><p >If <span class='texttt'>bool(a == b)</span>, then <span class='texttt'>bool(a-- == b)</span>.
</p></li><li id='bidirectional-3.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#bidirectional-3.3'>(3.3)</a></div><p >If <span class='texttt'>bool(a == b)</span>, then after evaluating both <span class='texttt'>a--</span> and <span class='texttt'>--b</span>,
<span class='texttt'>bool(a == b)</span> still holds.
</p></li><li id='bidirectional-3.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#bidirectional-3.4'>(3.4)</a></div><p >If <span class='texttt'>a</span> is incrementable and <span class='texttt'>bool(a == b)</span>, then
      <span class='texttt'>bool(--(++a) == b)</span>.
</p></li><li id='bidirectional-3.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#bidirectional-3.5'>(3.5)</a></div><p >If <span class='texttt'>bool(a == b)</span>, then <span class='texttt'>bool(++(--a) == b)</span>.
</p></li></ul></div></div><div id='random.access'><h3 ><a class='secnum' href='#random.access' style='min-width:103pt'>9.3.15</a> Concept <span class='texttt'>RandomAccessIterator</span> <a class='abbr_ref' href='iterators.random.access.html'>[iterators.random.access]</a></h3><div class='para' id='random.access-1'><div class='marginalizedparent'><a class='marginalized' href='#random.access-1'>1</a></div><p >The <span class='texttt'>RandomAccessIterator</span> concept refines <span class='texttt'>BidirectionalIterator</span> (<a href='iterators.bidirectional.html'>[iterators.bidirectional]</a>)
and adds support for constant-time advancement with <span class='texttt'>+=</span>, <span class='texttt'>+</span>,  <span class='texttt'>-=</span>, and <span class='texttt'>-</span>, and the
computation of distance in constant time with <span class='texttt'>-</span>. Random access iterators also support array
notation via subscripting.</p><p ><span class='indexparent'><a class='index' id='RandomAccessIterator'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool RandomAccessIterator() {
    return BidirectionalIterator&lt;I&gt;() &amp;&amp;
      DerivedFrom&lt;iterator_category_t&lt;I&gt;, random_access_iterator_tag&gt;() &amp;&amp;
      StrictTotallyOrdered&lt;I&gt;() &amp;&amp;
      SizedSentinel&lt;I, I&gt;() &amp;&amp;
      requires(I i, const I j, const difference_type_t&lt;I&gt; n) {
        { i += n } -&gt; Same&lt;I&amp;&gt;;
        { j + n } -&gt; Same&lt;I&gt;;
        { n + j } -&gt; Same&lt;I&gt;;
        { i -= n } -&gt; Same&lt;I&amp;&gt;;
        { j - n } -&gt; Same&lt;I&gt;;
        { j[n] } -&gt; Same&lt;reference_t&lt;I&gt;&gt;;
      };
  }
</pre></div><div class='para' id='random.access-2'><div class='marginalizedparent'><a class='marginalized' href='#random.access-2'>2</a></div><p >Let <span class='texttt'>a</span> and <span class='texttt'>b</span> be valid iterators of type <span class='texttt'>I</span> such that <span class='texttt'>b</span> is reachable
from <span class='texttt'>a</span>. Let <span class='texttt'>n</span> be the smallest value of type
<span class='texttt'>difference_type_t&lt;I&gt;</span> such that after
<span class='texttt'>n</span> applications of <span class='texttt'>++a</span>, then <span class='texttt'>bool(a == b)</span>. Then
<span class='texttt'>RandomAccessIterator&lt;I&gt;()</span> is satisfied if and only if:</p><ul class='itemize'><li id='random.access-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#random.access-2.1'>(2.1)</a></div><p ><span class='texttt'>(a += n)</span> is equal to <span class='texttt'>b</span>.
</p></li><li id='random.access-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#random.access-2.2'>(2.2)</a></div><p ><span class='texttt'>&amp;(a += n)</span> is equal to <span class='texttt'>&amp;a</span>.
</p></li><li id='random.access-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#random.access-2.3'>(2.3)</a></div><p ><span class='texttt'>(a + n)</span> is equal to <span class='texttt'>(a += n)</span>.
</p></li><li id='random.access-2.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#random.access-2.4'>(2.4)</a></div><p >For any two positive integers <span class='texttt'>x</span> and <span class='texttt'>y</span>, if <span class='texttt'>a + (x + y)</span> is valid, then
<span class='texttt'>a + (x + y)</span> is equal to <span class='texttt'>(a + x) + y</span>.
</p></li><li id='random.access-2.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#random.access-2.5'>(2.5)</a></div><p ><span class='texttt'>a + 0</span> is equal to <span class='texttt'>a</span>.
</p></li><li id='random.access-2.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#random.access-2.6'>(2.6)</a></div><p >If <span class='texttt'>(a + (n - 1))</span> is valid, then <span class='texttt'>a + n</span> is equal to <span class='texttt'>++(a + (n - 1))</span>.
</p></li><li id='random.access-2.7'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#random.access-2.7'>(2.7)</a></div><p ><span class='texttt'>(b += -n)</span> is equal to <span class='texttt'>a</span>.
</p></li><li id='random.access-2.8'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#random.access-2.8'>(2.8)</a></div><p ><span class='texttt'>(b -= n)</span> is equal to <span class='texttt'>a</span>.
</p></li><li id='random.access-2.9'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#random.access-2.9'>(2.9)</a></div><p ><span class='texttt'>&amp;(b -= n)</span> is equal to <span class='texttt'>&amp;b</span>.
</p></li><li id='random.access-2.10'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#random.access-2.10'>(2.10)</a></div><p ><span class='texttt'>(b - n)</span> is equal to <span class='texttt'>(b -= n)</span>.
</p></li><li id='random.access-2.11'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#random.access-2.11'>(2.11)</a></div><p >If <span class='texttt'>b</span> is dereferenceable, then <span class='texttt'>a[n]</span> is valid and is equal to <span class='texttt'>*b</span>.
</p></li></ul></div></div></div><div id='indirectcallable'><h2 ><a class='secnum' href='#indirectcallable' style='min-width:88pt'>9.4</a> Indirect callable requirements <a class='abbr_ref' href='indirectcallable.html'>[indirectcallable]</a></h2><div id='indirectcallable.general'><h3 ><a class='secnum' href='#indirectcallable.general' style='min-width:103pt'>9.4.1</a> In general <a class='abbr_ref' href='indirectcallable.general.html'>[indirectcallable.general]</a></h3><div class='para' id='indirectcallable.general-1'><div class='marginalizedparent'><a class='marginalized' href='#indirectcallable.general-1'>1</a></div><p >There are several concepts that group requirements of algorithms that take callable
objects (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> func.require <span class='endcsname'></span>) as arguments.</p></div></div><div id='indirectcallable.indirectinvocable'><h3 ><a class='secnum' href='#indirectcallable.indirectinvocable' style='min-width:103pt'>9.4.2</a> Indirect callables <a class='abbr_ref' href='indirectcallable.indirectinvocable.html'>[indirectcallable.indirectinvocable]</a></h3><div class='para' id='indirectcallable.indirectinvocable-1'><div class='marginalizedparent'><a class='marginalized' href='#indirectcallable.indirectinvocable-1'>1</a></div><p >The indirect callable concepts are used to constrain those algorithms that accept
callable objects (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> func.def <span class='endcsname'></span>) as arguments.</p><p ><span class='indexparent'><a class='index' id='IndirectInvocable'></a></span><span class='indexparent'><a class='index' id='IndirectRegularInvocable'></a></span><span class='indexparent'><a class='index' id='IndirectPredicate'></a></span><span class='indexparent'><a class='index' id='IndirectRelation'></a></span><span class='indexparent'><a class='index' id='IndirectStrictWeakOrder'></a></span></p><pre class='codeblock'>
  template &lt;class F&gt;
  concept bool IndirectInvocable() {
    return CopyConstructible&lt;F&gt;() &amp;&amp;
      Invocable&lt;F&amp;&gt;();
  }
  template &lt;class F, class I&gt;
  concept bool IndirectInvocable() {
    return Readable&lt;I&gt;() &amp;&amp;
      CopyConstructible&lt;F&gt;() &amp;&amp;
      Invocable&lt;F&amp;, value_type_t&lt;I&gt;&amp;&gt;() &amp;&amp;
      Invocable&lt;F&amp;, reference_t&lt;I&gt;&gt;() &amp;&amp;
      Invocable&lt;F&amp;, iter_common_reference_t&lt;I&gt;&gt;();
  }
  template &lt;class F, class I1, class I2&gt;
  concept bool IndirectInvocable() {
    return Readable&lt;I1&gt;() &amp;&amp; Readable&lt;I2&gt;() &amp;&amp;
      CopyConstructible&lt;F&gt;() &amp;&amp;
      Invocable&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;
      Invocable&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, reference_t&lt;I2&gt;&gt;() &amp;&amp;
      Invocable&lt;F&amp;, reference_t&lt;I1&gt;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;
      Invocable&lt;F&amp;, reference_t&lt;I1&gt;, reference_t&lt;I2&gt;&gt;() &amp;&amp;
      Invocable&lt;F&amp;, iter_common_reference_t&lt;I1&gt;, iter_common_reference_t&lt;I2&gt;&gt;();
  }

  template &lt;class F&gt;
  concept bool IndirectRegularInvocable() {
    return CopyConstructible&lt;F&gt;() &amp;&amp;
      RegularInvocable&lt;F&amp;&gt;();
  }
  template &lt;class F, class I&gt;
  concept bool IndirectRegularInvocable() {
    return Readable&lt;I&gt;() &amp;&amp;
      CopyConstructible&lt;F&gt;() &amp;&amp;
      RegularInvocable&lt;F&amp;, value_type_t&lt;I&gt;&amp;&gt;() &amp;&amp;
      RegularInvocable&lt;F&amp;, reference_t&lt;I&gt;&gt;() &amp;&amp;
      RegularInvocable&lt;F&amp;, iter_common_reference_t&lt;I&gt;&gt;();
  }
  template &lt;class F, class I1, class I2&gt;
  concept bool IndirectRegularInvocable() {
    return Readable&lt;I1&gt;() &amp;&amp; Readable&lt;I2&gt;() &amp;&amp;
      CopyConstructible&lt;F&gt;() &amp;&amp;
      RegularInvocable&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;
      RegularInvocable&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, reference_t&lt;I2&gt;&gt;() &amp;&amp;
      RegularInvocable&lt;F&amp;, reference_t&lt;I1&gt;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;
      RegularInvocable&lt;F&amp;, reference_t&lt;I1&gt;, reference_t&lt;I2&gt;&gt;() &amp;&amp;
      RegularInvocable&lt;F&amp;, iter_common_reference_t&lt;I1&gt;, iter_common_reference_t&lt;I2&gt;&gt;();
  }

  template &lt;class F, class I&gt;
  concept bool IndirectPredicate() {
    return Readable&lt;I&gt;() &amp;&amp;
      CopyConstructible&lt;F&gt;() &amp;&amp;
      Predicate&lt;F&amp;, value_type_t&lt;I&gt;&amp;&gt;() &amp;&amp;
      Predicate&lt;F&amp;, reference_t&lt;I&gt;&gt;() &amp;&amp;
      Predicate&lt;F&amp;, iter_common_reference_t&lt;I&gt;&gt;();
  }
  template &lt;class F, class I1, class I2&gt;
  concept bool IndirectPredicate() {
    return Readable&lt;I1&gt;() &amp;&amp; Readable&lt;I2&gt;() &amp;&amp;
      CopyConstructible&lt;F&gt;() &amp;&amp;
      Predicate&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;
      Predicate&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, reference_t&lt;I2&gt;&gt;() &amp;&amp;
      Predicate&lt;F&amp;, reference_t&lt;I1&gt;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;
      Predicate&lt;F&amp;, reference_t&lt;I1&gt;, reference_t&lt;I2&gt;&gt;() &amp;&amp;
      Predicate&lt;F&amp;, iter_common_reference_t&lt;I1&gt;, iter_common_reference_t&lt;I2&gt;&gt;();
  }

  template &lt;class F, class I1, class I2 = I1&gt;
  concept bool IndirectRelation() {
    return Readable&lt;I1&gt;() &amp;&amp; Readable&lt;I2&gt;() &amp;&amp;
      CopyConstructible&lt;F&gt;() &amp;&amp;
      Relation&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;
      Relation&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, reference_t&lt;I2&gt;&gt;() &amp;&amp;
      Relation&lt;F&amp;, reference_t&lt;I1&gt;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;
      Relation&lt;F&amp;, reference_t&lt;I1&gt;, reference_t&lt;I2&gt;&gt;() &amp;&amp;
      Relation&lt;F&amp;, iter_common_reference_t&lt;I1&gt;, iter_common_reference_t&lt;I2&gt;&gt;();
  }

  template &lt;class F, class I1, class I2 = I1&gt;
  concept bool IndirectStrictWeakOrder() {
    return Readable&lt;I1&gt;() &amp;&amp; Readable&lt;I2&gt;() &amp;&amp;
      CopyConstructible&lt;F&gt;() &amp;&amp;
      StrictWeakOrder&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;
      StrictWeakOrder&lt;F&amp;, value_type_t&lt;I1&gt;&amp;, reference_t&lt;I2&gt;&gt;() &amp;&amp;
      StrictWeakOrder&lt;F&amp;, reference_t&lt;I1&gt;, value_type_t&lt;I2&gt;&amp;&gt;() &amp;&amp;
      StrictWeakOrder&lt;F&amp;, reference_t&lt;I1&gt;, reference_t&lt;I2&gt;&gt;() &amp;&amp;
      StrictWeakOrder&lt;F&amp;, iter_common_reference_t&lt;I1&gt;, iter_common_reference_t&lt;I2&gt;&gt;();
  }
</pre></div></div><div id='projected'><h3 ><a class='secnum' href='#projected' style='min-width:103pt'>9.4.3</a> Class template <span class='texttt'>projected</span> <a class='abbr_ref' href='projected.html'>[projected]</a></h3><div class='para' id='projected-1'><div class='marginalizedparent'><a class='marginalized' href='#projected-1'>1</a></div><p >The <span class='texttt'>projected</span> class template is intended for use when specifying the constraints of
algorithms that accept callable objects and projections (<a href='defns.projection.html'>[defns.projection]</a>). It bundles a <span class='texttt'>Readable</span> type
<span class='texttt'>I</span> and a function <span class='texttt'>Proj</span> into a new <span class='texttt'>Readable</span> type whose
<span class='texttt'>reference</span> type is the result of applying <span class='texttt'>Proj</span> to the
<span class='texttt'>reference_t</span> of <span class='texttt'>I</span>.</p><p ><span class='indexparent'><a class='index' id='projected'></a></span></p><pre class='codeblock'>
  template &lt;Readable I, IndirectRegularInvocable&lt;I&gt; Proj&gt;
  struct projected {
    using value_type = remove_cv_t&lt;remove_reference_t&lt;indirect_result_of_t&lt;Proj&amp;(I)&gt;&gt;&gt;;
    indirect_result_of_t&lt;Proj&amp;(I)&gt; operator*() const;
  };

  template &lt;WeaklyIncrementable I, class Proj&gt;
  struct difference_type&lt;projected&lt;I, Proj&gt;&gt; {
    using type = difference_type_t&lt;I&gt;;
  };
</pre></div><div class='para' id='projected-2'><div class='marginalizedparent'><a class='marginalized' href='#projected-2'>2</a></div><p >[&nbsp;<i>Note:</i> <span class='texttt'>projected</span> is only used to ease constraints specification. Its
member function need not be defined.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='commonalgoreq'><h2 ><a class='secnum' href='#commonalgoreq' style='min-width:88pt'>9.5</a> Common algorithm requirements <a class='abbr_ref' href='commonalgoreq.html'>[commonalgoreq]</a></h2><div id='commonalgoreq.general'><h3 ><a class='secnum' href='#commonalgoreq.general' style='min-width:103pt'>9.5.1</a> In general <a class='abbr_ref' href='commonalgoreq.general.html'>[commonalgoreq.general]</a></h3><div class='para' id='commonalgoreq.general-1'><div class='marginalizedparent'><a class='marginalized' href='#commonalgoreq.general-1'>1</a></div><p >There are several additional iterator concepts that are commonly applied to families of algorithms.
These group together iterator requirements of algorithm families. There are three relational
concepts that specify how element values are transferred between <span class='texttt'>Readable</span> and <span class='texttt'>Writable</span> types:
<span class='texttt'>IndirectlyMovable</span>, <span class='texttt'>IndirectlyCopyable</span>, and <span class='texttt'>IndirectlySwappable</span>. There are three relational concepts
for rearrangements: <span class='texttt'>Permutable</span>, <span class='texttt'>Mergeable</span>, and <span class='texttt'>Sortable</span>.
There is one relational concept for comparing values from different sequences: <span class='texttt'>IndirectlyComparable</span>.</p></div><div class='para' id='commonalgoreq.general-2'><div class='marginalizedparent'><a class='marginalized' href='#commonalgoreq.general-2'>2</a></div><p >[&nbsp;<i>Note:</i> The <span class='texttt'>equal_to&lt;&gt;</span> and <span class='texttt'>less&lt;&gt;</span> (<a href='comparisons.html'>[comparisons]</a>) function types used in the
concepts below impose additional constraints on their arguments beyond those that appear explicitly in the
concepts' bodies. <span class='texttt'>equal_to&lt;&gt;</span> requires its arguments satisfy <span class='texttt'>EqualityComparable</span> (<a href='concepts.lib.compare.equalitycomparable.html'>[concepts.lib.compare.equalitycomparable]</a>),
and <span class='texttt'>less&lt;&gt;</span> requires its arguments satisfy <span class='texttt'>StrictTotallyOrdered</span> (<a href='concepts.lib.compare.stricttotallyordered.html'>[concepts.lib.compare.stricttotallyordered]</a>).<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='commonalgoreq.indirectlymovable'><h3 ><a class='secnum' href='#commonalgoreq.indirectlymovable' style='min-width:103pt'>9.5.2</a> Concept <span class='texttt'>IndirectlyMovable</span> <a class='abbr_ref' href='commonalgoreq.indirectlymovable.html'>[commonalgoreq.indirectlymovable]</a></h3><div class='para' id='commonalgoreq.indirectlymovable-1'><div class='marginalizedparent'><a class='marginalized' href='#commonalgoreq.indirectlymovable-1'>1</a></div><p >The <span class='texttt'>IndirectlyMovable</span> concept specifies the relationship between a <span class='texttt'>Readable</span>
type and a <span class='texttt'>Writable</span> type between which values may be moved.</p><p ><span class='indexparent'><a class='index' id='IndirectlyMovable'></a></span></p><pre class='codeblock'>
  template &lt;class In, class Out&gt;
  concept bool IndirectlyMovable() {
    return Readable&lt;In&gt;() &amp;&amp;
      Writable&lt;Out, rvalue_reference_t&lt;In&gt;&gt;();
  }
</pre></div><div class='para' id='commonalgoreq.indirectlymovable-2'><div class='marginalizedparent'><a class='marginalized' href='#commonalgoreq.indirectlymovable-2'>2</a></div><p >The <span class='texttt'>IndirectlyMovableStorable</span> concept augments <span class='texttt'>IndirectlyMovable</span> with additional
requirements enabling the transfer to be performed through an intermediate object of the
<span class='texttt'>Readable</span> type's value type.</p><p ><span class='indexparent'><a class='index' id='IndirectlyMovableStorable'></a></span></p><pre class='codeblock'>
  template &lt;class In, class Out&gt;
  concept bool IndirectlyMovableStorable() {
    return IndirectlyMovable&lt;In, Out&gt;() &amp;&amp;
      Writable&lt;Out, value_type_t&lt;In&gt;&gt;() &amp;&amp;
      Movable&lt;value_type_t&lt;In&gt;&gt;() &amp;&amp;
      Constructible&lt;value_type_t&lt;In&gt;, rvalue_reference_t&lt;In&gt;&gt;() &amp;&amp;
      Assignable&lt;value_type_t&lt;In&gt;&amp;, rvalue_reference_t&lt;In&gt;&gt;();
  }
</pre></div></div><div id='commonalgoreq.indirectlycopyable'><h3 ><a class='secnum' href='#commonalgoreq.indirectlycopyable' style='min-width:103pt'>9.5.3</a> Concept <span class='texttt'>IndirectlyCopyable</span> <a class='abbr_ref' href='commonalgoreq.indirectlycopyable.html'>[commonalgoreq.indirectlycopyable]</a></h3><div class='para' id='commonalgoreq.indirectlycopyable-1'><div class='marginalizedparent'><a class='marginalized' href='#commonalgoreq.indirectlycopyable-1'>1</a></div><p >The <span class='texttt'>IndirectlyCopyable</span> concept specifies the relationship between a <span class='texttt'>Readable</span>
type and a <span class='texttt'>Writable</span> type between which values may be copied.</p><p ><span class='indexparent'><a class='index' id='IndirectlyCopyable'></a></span></p><pre class='codeblock'>
  template &lt;class In, class Out&gt;
  concept bool IndirectlyCopyable() {
    return Readable&lt;In&gt;() &amp;&amp;
      Writable&lt;Out, reference_t&lt;In&gt;&gt;();
  }
</pre></div><div class='para' id='commonalgoreq.indirectlycopyable-2'><div class='marginalizedparent'><a class='marginalized' href='#commonalgoreq.indirectlycopyable-2'>2</a></div><p >The <span class='texttt'>IndirectlyCopyableStorable</span> concept augments <span class='texttt'>IndirectlyCopyable</span> with additional
requirements enabling the transfer to be performed through an intermediate object of the
<span class='texttt'>Readable</span> type's value type. It also requires the capability to make copies of values.</p><p ><span class='indexparent'><a class='index' id='IndirectlyCopyableStorable'></a></span></p><pre class='codeblock'>
  template &lt;class In, class Out&gt;
  concept bool IndirectlyCopyableStorable() {
    return IndirectlyCopyable&lt;In, Out&gt;() &amp;&amp;
      Writable&lt;Out, const value_type_t&lt;In&gt;&amp;&gt;() &amp;&amp;
      Copyable&lt;value_type_t&lt;In&gt;&gt;() &amp;&amp;
      Constructible&lt;value_type_t&lt;In&gt;, reference_t&lt;In&gt;&gt;() &amp;&amp;
      Assignable&lt;value_type_t&lt;In&gt;&amp;, reference_t&lt;In&gt;&gt;();
  }
</pre></div></div><div id='commonalgoreq.indirectlyswappable'><h3 ><a class='secnum' href='#commonalgoreq.indirectlyswappable' style='min-width:103pt'>9.5.4</a> Concept <span class='texttt'>IndirectlySwappable</span> <a class='abbr_ref' href='commonalgoreq.indirectlyswappable.html'>[commonalgoreq.indirectlyswappable]</a></h3><div class='para' id='commonalgoreq.indirectlyswappable-1'><div class='marginalizedparent'><a class='marginalized' href='#commonalgoreq.indirectlyswappable-1'>1</a></div><p >The <span class='texttt'>IndirectlySwappable</span> concept specifies a swappable relationship between the
values referenced by two <span class='texttt'>Readable</span> types.</p><p ><span class='indexparent'><a class='index' id='IndirectlySwappable'></a></span></p><pre class='codeblock'>
  template &lt;class I1, class I2 = I1&gt;
  concept bool IndirectlySwappable() {
    return Readable&lt;I1&gt;() &amp;&amp; Readable&lt;I2&gt;() &amp;&amp;
      requires(I1&amp;&amp; i1, I2&amp;&amp; i2) {
        ranges::iter_swap(std::forward&lt;I1&gt;(i1), std::forward&lt;I2&gt;(i2));
        ranges::iter_swap(std::forward&lt;I2&gt;(i2), std::forward&lt;I1&gt;(i1));
        ranges::iter_swap(std::forward&lt;I1&gt;(i1), std::forward&lt;I1&gt;(i1));
        ranges::iter_swap(std::forward&lt;I2&gt;(i2), std::forward&lt;I2&gt;(i2));
      };
  }
</pre></div><div class='para' id='commonalgoreq.indirectlyswappable-2'><div class='marginalizedparent'><a class='marginalized' href='#commonalgoreq.indirectlyswappable-2'>2</a></div><p >Given an object <span class='texttt'>i1</span> of type <span class='texttt'>I1</span> and an object <span class='texttt'>i2</span> of
type <span class='texttt'>I2</span>, <span class='texttt'>IndirectlySwappable&lt;I1, I2&gt;()</span> is satisfied if after
<span class='texttt'>ranges::iter_swap(i1, i2)</span>, the value of <span class='texttt'>*i1</span> is equal to the
value of <span class='texttt'>*i2</span> before the call, and <i>vice versa</i>.</p></div></div><div id='commonalgoreq.indirectlycomparable'><h3 ><a class='secnum' href='#commonalgoreq.indirectlycomparable' style='min-width:103pt'>9.5.5</a> Concept <span class='texttt'>IndirectlyComparable</span> <a class='abbr_ref' href='commonalgoreq.indirectlycomparable.html'>[commonalgoreq.indirectlycomparable]</a></h3><div class='para' id='commonalgoreq.indirectlycomparable-1'><div class='marginalizedparent'><a class='marginalized' href='#commonalgoreq.indirectlycomparable-1'>1</a></div><p >The <span class='texttt'>IndirectlyComparable</span> concept specifies the common requirements of algorithms that
compare values from two different sequences.</p><p ><span class='indexparent'><a class='index' id='IndirectlyComparable'></a></span></p><pre class='codeblock'>
  template &lt;class I1, class I2, class R = equal_to&lt;&gt;, class P1 = identity,
    class P2 = identity&gt;
  concept bool IndirectlyComparable() {
    return IndirectRelation&lt;R, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;();
  }
</pre></div></div><div id='commonalgoreq.permutable'><h3 ><a class='secnum' href='#commonalgoreq.permutable' style='min-width:103pt'>9.5.6</a> Concept <span class='texttt'>Permutable</span> <a class='abbr_ref' href='commonalgoreq.permutable.html'>[commonalgoreq.permutable]</a></h3><div class='para' id='commonalgoreq.permutable-1'><div class='marginalizedparent'><a class='marginalized' href='#commonalgoreq.permutable-1'>1</a></div><p >The <span class='texttt'>Permutable</span> concept specifies the common requirements of algorithms that reorder
elements in place by moving or swapping them.</p><p ><span class='indexparent'><a class='index' id='Permutable'></a></span></p><pre class='codeblock'>
  template &lt;class I&gt;
  concept bool Permutable() {
    return ForwardIterator&lt;I&gt;() &amp;&amp;
      IndirectlyMovableStorable&lt;I, I&gt;() &amp;&amp;
      IndirectlySwappable&lt;I, I&gt;();
  }
</pre></div></div><div id='commonalgoreq.mergeable'><h3 ><a class='secnum' href='#commonalgoreq.mergeable' style='min-width:103pt'>9.5.7</a> Concept <span class='texttt'>Mergeable</span> <a class='abbr_ref' href='commonalgoreq.mergeable.html'>[commonalgoreq.mergeable]</a></h3><div class='para' id='commonalgoreq.mergeable-1'><div class='marginalizedparent'><a class='marginalized' href='#commonalgoreq.mergeable-1'>1</a></div><p >The <span class='texttt'>Mergeable</span> concept specifies the requirements of
algorithms that merge sorted sequences into an output sequence by copying elements.</p><p ><span class='indexparent'><a class='index' id='Mergeable'></a></span></p><pre class='codeblock'>
  template &lt;class I1, class I2, class Out,
      class R = less&lt;&gt;, class P1 = identity, class P2 = identity&gt;
  concept bool Mergeable() {
    return InputIterator&lt;I1&gt;() &amp;&amp;
      InputIterator&lt;I2&gt;() &amp;&amp;
      WeaklyIncrementable&lt;Out&gt;() &amp;&amp;
      IndirectlyCopyable&lt;I1, Out&gt;() &amp;&amp;
      IndirectlyCopyable&lt;I2, Out&gt;() &amp;&amp;
      IndirectStrictWeakOrder&lt;R, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;();
  }
</pre></div></div><div id='commonalgoreq.sortable'><h3 ><a class='secnum' href='#commonalgoreq.sortable' style='min-width:103pt'>9.5.8</a> Concept <span class='texttt'>Sortable</span> <a class='abbr_ref' href='commonalgoreq.sortable.html'>[commonalgoreq.sortable]</a></h3><div class='para' id='commonalgoreq.sortable-1'><div class='marginalizedparent'><a class='marginalized' href='#commonalgoreq.sortable-1'>1</a></div><p >The <span class='texttt'>Sortable</span> concept specifies the common requirements of algorithms that permute
sequences into ordered sequences (e.g., <span class='texttt'>sort</span>).</p><p ><span class='indexparent'><a class='index' id='Sortable'></a></span></p><pre class='codeblock'>
  template &lt;class I, class R = less&lt;&gt;, class P = identity&gt;
  concept bool Sortable() {
    return Permutable&lt;I&gt;() &amp;&amp;
      IndirectStrictWeakOrder&lt;R, projected&lt;I, P&gt;&gt;();
  }
</pre></div></div></div><div id='iterator.primitives'><h2 ><a class='secnum' href='#iterator.primitives' style='min-width:88pt'>9.6</a> Iterator primitives <a class='abbr_ref' href='iterator.primitives.html'>[iterator.primitives]</a></h2><div class='para' id='iterator.primitives-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.primitives-1'>1</a></div><p >To simplify the task of defining iterators, the library provides
several classes and functions:</p></div><div id='iterator.traits'><h3 ><a class='secnum' href='#iterator.traits' style='min-width:103pt'>9.6.1</a> Iterator traits <a class='abbr_ref' href='iterator.traits.html'>[iterator.traits]</a></h3><div class='para' id='iterator.traits-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.traits-1'>1</a></div><p >The class templates <span class='texttt'>is_indirectly_movable</span>,
<span class='texttt'>is_nothrow_indirectly_movable</span>, <span class='texttt'>is_indirectly_swappable</span>,
and <span class='texttt'>is_nothrow_indirectly_swappable</span> shall be defined as follows:</p><pre class='codeblock'>
template &lt;class In, class Out&gt;
struct is_indirectly_movable : false_type { };

template &lt;class In, class Out&gt;
  requires IndirectlyMovable&lt;In, Out&gt;()
struct is_indirectly_movable&lt;In, Out&gt; : true_type { };

template &lt;class In, class Out&gt;
struct is_nothrow_indirectly_movable : false_type { };

template &lt;class In, class Out&gt;
  requires IndirectlyMovable&lt;In, Out&gt;()
struct is_nothrow_indirectly_movable&lt;In, Out&gt; :
  integral_constant&lt;bool,
    is_nothrow_constructible&lt;value_type_t&lt;In&gt;, rvalue_reference_t&lt;In&gt;&gt;::value &amp;&amp;
    is_nothrow_assignable&lt;value_type_t&lt;In&gt; &amp;, rvalue_reference_t&lt;In&gt;&gt;::value &amp;&amp;
    is_nothrow_assignable&lt;reference_t&lt;Out&gt;, rvalue_reference_t&lt;In&gt;&gt;::value &amp;&amp;
    is_nothrow_assignable&lt;reference_t&lt;Out&gt;, value_type_t&lt;In&gt;&gt;::value&gt;{ };

template &lt;class I1, class I2 = I1&gt;
struct is_indirectly_swappable : false_type { };

template &lt;class I1, class I2&gt;
  requires IndirectlySwappable&lt;I1, I2&gt;()
struct is_indirectly_swappable&lt;I1, I2&gt; : true_type { };

template &lt;class I1, class I2 = I1&gt;
struct is_nothrow_indirectly_swappable : false_type { };

template &lt;class I1, class I2&gt;
  requires IndirectlySwappable&lt;I1, I2&gt;()
struct is_nothrow_indirectly_swappable&lt;I1, I2&gt; :
  integral_constant&lt;bool,
    noexcept(ranges::iter_swap(declval&lt;I1&amp;&gt;(), declval&lt;I2&amp;&gt;())) &amp;&amp;
    noexcept(ranges::iter_swap(declval&lt;I2&amp;&gt;(), declval&lt;I1&amp;&gt;())) &amp;&amp;
    noexcept(ranges::iter_swap(declval&lt;I1&amp;&gt;(), declval&lt;I1&amp;&gt;())) &amp;&amp;
    noexcept(ranges::iter_swap(declval&lt;I2&amp;&gt;(), declval&lt;I2&amp;&gt;()))&gt;{ };
</pre></div><div class='para' id='iterator.traits-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.traits-2'>2</a></div><p >For the sake of backwards compatibility, this document specifies the existence of an <span class='texttt'>iterator_traits</span>
alias that collects an iterator's associated types. It is defined as if:</p><p ><span class='indexparent'><a class='index' id='iterator_traits'></a></span></p><pre class='codeblock'>
  template &lt;InputIterator I&gt; struct __pointer_type {        <span class='comment'>// <i>exposition only</i>
</span>    using type = add_pointer_t&lt;reference_t&lt;I&gt;&gt;;
  };
  template &lt;InputIterator I&gt;
    requires requires(I i) { { i.operator-&gt;() } -&gt; auto&amp;&amp;; }
  struct __pointer_type&lt;I&gt; {                                    <span class='comment'>// <i>exposition only</i>
</span>    using type = decltype(declval&lt;I&gt;().operator-&gt;());
  };
  template &lt;class&gt; struct __iterator_traits { };                <span class='comment'>// <i>exposition only</i>
</span>  template &lt;Iterator I&gt; struct __iterator_traits&lt;I&gt; {
    using difference_type = difference_type_t&lt;I&gt;;
    using value_type = void;
    using reference = void;
    using pointer = void;
    using iterator_category = output_iterator_tag;
  };
  template &lt;InputIterator I&gt; struct __iterator_traits&lt;I&gt; {  <span class='comment'>// <i>exposition only</i>
</span>    using difference_type = difference_type_t&lt;I&gt;;
    using value_type = value_type_t&lt;I&gt;;
    using reference = reference_t&lt;I&gt;;
    using pointer = typename __pointer_type&lt;I&gt;::type;
    using iterator_category = iterator_category_t&lt;I&gt;;
  };
  template &lt;class I&gt;
    using iterator_traits = __iterator_traits&lt;I&gt;;
</pre></div><div class='para' id='iterator.traits-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.traits-3'>3</a></div><p >[&nbsp;<i>Note:</i>
<span class='texttt'>iterator_traits</span> is an alias template
to prevent user code from specializing it.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='iterator.traits-4'><div class='marginalizedparent'><a class='marginalized' href='#iterator.traits-4'>4</a></div><p >[&nbsp;<i>Example:</i>
To implement a generic
<span class='texttt'>reverse</span>
function, a C++ program can do the following:</p><pre class='codeblock'>
template &lt;BidirectionalIterator I&gt;
void reverse(I first, I last) {
  difference_type_t&lt;I&gt; n = distance(first, last);
  --n;
  while(n &gt; 0) {
    value_type_t&lt;I&gt; tmp = *first;
    *first++ = *--last;
    *last = tmp;
    n -= 2;
  }
}
</pre><p ><i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p></div></div><div id='iterator.stdtraits'><h3 ><a class='secnum' href='#iterator.stdtraits' style='min-width:103pt'>9.6.2</a> Standard iterator traits <a class='abbr_ref' href='iterator.stdtraits.html'>[iterator.stdtraits]</a></h3><div class='para' id='iterator.stdtraits-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.stdtraits-1'>1</a></div><p >To facilitate interoperability between new code using iterators conforming to this document
and older code using iterators that conform to the iterator
requirements specified in ISO/IEC 14882, three specializations of <span class='texttt'>std::iterator_traits</span>
are provided to map the newer iterator categories and associated types to the older ones.</p><pre class='codeblock'>
namespace std {
  template &lt;experimental::ranges::Iterator Out&gt;
  struct iterator_traits&lt;Out&gt; {
    using difference_type   = experimental::ranges::difference_type_t&lt;Out&gt;;
    using value_type        = <i><span class='texttt'>see below</span></i>;
    using reference         = <i><span class='texttt'>see below</span></i>;
    using pointer           = <i><span class='texttt'>see below</span></i>;
    using iterator_category = std::output_iterator_tag;
  };
\end{codeblock}

\pnum
The nested type \tcode{value_type} is computed as follows:
\begin{itemize}
\item If
      \tcode{Out::value_type} is valid and denotes a type, then
      \tcode{std::iterator_traits&lt;Out&gt;::value_type} is \tcode{Out::value_type}.
\item Otherwise, \tcode{std::iterator_traits&lt;Out&gt;::value_type} is \tcode{void}.
\end{itemize}

\pnum
The nested type \tcode{reference} is computed as follows:
\begin{itemize}
\item If
      \tcode{Out::reference} is valid and denotes a type, then
      \tcode{std::iterator_traits&lt;Out&gt;::reference} is \tcode{Out::\brk{}reference}.
\item Otherwise, \tcode{std::iterator_traits&lt;Out&gt;::reference} is \tcode{void}.
\end{itemize}

\pnum
The nested type \tcode{pointer} is computed as follows:
\begin{itemize}
\item If
      \tcode{Out::pointer} is valid and denotes a type, then
      \tcode{std::iterator_traits&lt;Out&gt;::pointer} is \tcode{Out::pointer}.
\item Otherwise, \tcode{std::iterator_traits&lt;Out&gt;::pointer} is \tcode{void}.
\end{itemize}

\begin{codeblock}
  template &lt;experimental::ranges::InputIterator In&gt;
  struct iterator_traits&lt;In&gt; { };

  template &lt;experimental::ranges::InputIterator In&gt;
    requires experimental::ranges::Sentinel&lt;In, In&gt;()
  struct iterator_traits&lt;In&gt; {
    using difference_type   = experimental::ranges::difference_type_t&lt;In&gt;;
    using value_type        = experimental::ranges::value_type_t&lt;In&gt;;
    using reference         = <i><span class='texttt'>see below</span></i>;
    using pointer           = <i><span class='texttt'>see below</span></i>;
    using iterator_category = <i><span class='texttt'>see below</span></i>;
  };
}
</pre></div><div class='para' id='iterator.stdtraits-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.stdtraits-2'>2</a></div><p >The nested type <span class='texttt'>reference</span> is computed as follows:
</p><ul class='itemize'><li id='iterator.stdtraits-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.stdtraits-2.1'>(2.1)</a></div><p >If
      <span class='texttt'>In::reference</span> is valid and denotes a type, then
      <span class='texttt'>std::iterator_traits&lt;In&gt;::reference</span> is <span class='texttt'>In::reference</span>.
</p></li><li id='iterator.stdtraits-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.stdtraits-2.2'>(2.2)</a></div><p >Otherwise, <span class='texttt'>std::iterator_traits&lt;In&gt;::reference</span> is
      <span class='texttt'>experimental::ranges::reference_t&lt;In&gt;</span>.
</p></li></ul></div><div class='para' id='iterator.stdtraits-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.stdtraits-3'>3</a></div><p >The nested type <span class='texttt'>pointer</span> is computed as follows:
</p><ul class='itemize'><li id='iterator.stdtraits-3.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.stdtraits-3.1'>(3.1)</a></div><p >If
      <span class='texttt'>In::pointer</span> is valid and denotes a type, then
      <span class='texttt'>std::iterator_traits&lt;In&gt;::pointer</span> is <span class='texttt'>In::pointer</span>.
</p></li><li id='iterator.stdtraits-3.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.stdtraits-3.2'>(3.2)</a></div><p >Otherwise, <span class='texttt'>std::iterator_traits&lt;In&gt;::pointer</span> is
      <span class='texttt'>experimental::ranges::iterator_traits&lt;In&gt;::pointer</span>.
</p></li></ul></div><div class='para' id='iterator.stdtraits-4'><div class='marginalizedparent'><a class='marginalized' href='#iterator.stdtraits-4'>4</a></div><p >Let type <span class='texttt'>C</span> be <span class='texttt'>experimental::ranges::</span><span class='texttt'>iterator_category_t</span><span class='texttt'>&lt;In&gt;</span>.
The nested type <span class='texttt'>std::iterator_traits&lt;In&gt;::iterator_category</span> is computed as
follows:
</p><ul class='itemize'><li id='iterator.stdtraits-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.stdtraits-4.1'>(4.1)</a></div><p >If <span class='texttt'>C</span> is the same as or inherits from <span class='texttt'>std::input_iterator_tag</span> or
      <span class='texttt'>std::output_iterator_tag</span>, <span class='texttt'>std::iterator_traits&lt;In&gt;::iterator_category</span>
      is <span class='texttt'>C</span>.
</p></li><li id='iterator.stdtraits-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.stdtraits-4.2'>(4.2)</a></div><p >Otherwise, if <span class='texttt'>experimental::ranges::reference_t&lt;In&gt;</span> is not a reference type,
      <span class='texttt'>std::iterator_traits&lt;In&gt;::iterator_category</span> is <span class='texttt'>std::input_iterator_tag</span>.
</p></li><li id='iterator.stdtraits-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.stdtraits-4.3'>(4.3)</a></div><p >Otherwise, if <span class='texttt'>C</span> is the same as or inherits from <span class='texttt'>experimental::ranges::random_access_iterator_tag</span>,
      <span class='texttt'>std::iterator_traits&lt;In&gt;::iterator_category</span> is <span class='texttt'>std::random_access_iterator_tag</span>.
</p></li><li id='iterator.stdtraits-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.stdtraits-4.4'>(4.4)</a></div><p >Otherwise, if <span class='texttt'>C</span> is the same as or inherits from <span class='texttt'>experimental::ranges::bidirectional_iterator_tag</span>,
      <span class='texttt'>std::iterator_traits&lt;In&gt;::iterator_category</span> is <span class='texttt'>std::bidirectional_iterator_tag</span>.
</p></li><li id='iterator.stdtraits-4.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.stdtraits-4.5'>(4.5)</a></div><p >Otherwise, if <span class='texttt'>C</span> is the same as or inherits from <span class='texttt'>experimental::ranges::forward_iterator_tag</span>,
      <span class='texttt'>std::iterator_traits&lt;In&gt;::iterator_category</span> is <span class='texttt'>std::forward_iterator_tag</span>.
</p></li><li id='iterator.stdtraits-4.6'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.stdtraits-4.6'>(4.6)</a></div><p >Otherwise, <span class='texttt'>std::iterator_traits&lt;In&gt;::iterator_category</span> is <span class='texttt'>std::input_iterator_tag</span>.
</p></li></ul></div><div class='para' id='iterator.stdtraits-5'><div class='marginalizedparent'><a class='marginalized' href='#iterator.stdtraits-5'>5</a></div><p >[&nbsp;<i>Note:</i> Some implementations may find it necessary to add additional constraints to
these partial specializations to prevent them from being considered for types that
conform to the iterator requirements specified in ISO/IEC 14882.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='std.iterator.tags'><h3 ><a class='secnum' href='#std.iterator.tags' style='min-width:103pt'>9.6.3</a> Standard iterator tags <a class='abbr_ref' href='std.iterator.tags.html'>[std.iterator.tags]</a></h3><div class='para' id='std.iterator.tags-1'><div class='marginalizedparent'><a class='marginalized' href='#std.iterator.tags-1'>1</a></div><p ><span class='indexparent'><a class='index' id='output_iterator_tag'></a></span><span class='indexparent'><a class='index' id='input_iterator_tag'></a></span><span class='indexparent'><a class='index' id='forward_iterator_tag'></a></span><span class='indexparent'><a class='index' id='bidirectional_iterator_tag'></a></span><span class='indexparent'><a class='index' id='random_access_iterator_tag'></a></span>It is often desirable for a
function template specialization
to find out what is the most specific category of its iterator
argument, so that the function can select the most efficient algorithm at compile time.
To facilitate this, the
library introduces
<i>category tag</i>
classes which can be used as compile time tags for algorithm selection.
[&nbsp;<i>Note:</i> The preferred way to dispatch to more specialized algorithm implementations is
with concept-based overloading.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
The category tags are:
<span class='texttt'>input_iterator_tag</span>,
<span class='texttt'>output_iterator_tag</span>,
<span class='texttt'>forward_iterator_tag</span>,
<span class='texttt'>bidirectional_iterator_tag</span>
and
<span class='texttt'>random_access_iterator_tag</span>.
For every input iterator of type
<span class='texttt'>I</span>,
<span class='texttt'>iterator_category_t&lt;I&gt;</span>
shall be defined to be the most specific category tag that describes the
iterator's behavior.</p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  struct output_iterator_tag { };
  struct input_iterator_tag { };
  struct forward_iterator_tag : input_iterator_tag { };
  struct bidirectional_iterator_tag : forward_iterator_tag { };
  struct random_access_iterator_tag : bidirectional_iterator_tag { };
}}}}
</pre></div><div class='para' id='std.iterator.tags-2'><div class='marginalizedparent'><a class='marginalized' href='#std.iterator.tags-2'>2</a></div><p >[&nbsp;<i>Note:</i>
The <span class='texttt'>output_iterator_tag</span> is provided for the sake of backward compatibility.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='std.iterator.tags-3'><div class='marginalizedparent'><a class='marginalized' href='#std.iterator.tags-3'>3</a></div><p ><span class='indexparent'><a class='index' id='empty'></a></span><span class='indexparent'><a class='index' id='input_iterator_tag'></a></span><span class='indexparent'><a class='index' id='output_iterator_tag'></a></span><span class='indexparent'><a class='index' id='forward_iterator_tag'></a></span><span class='indexparent'><a class='index' id='bidirectional_iterator_tag'></a></span><span class='indexparent'><a class='index' id='random_access_iterator_tag'></a></span>[&nbsp;<i>Example:</i>
For a program-defined iterator
<span class='texttt'>BinaryTreeIterator</span>,
it could be included
into the bidirectional iterator category by specializing the
<span class='texttt'>difference_type</span>, <span class='texttt'>value_type</span>, and
<span class='texttt'>iterator_category</span> templates:</p><pre class='codeblock'>
template &lt;class T&gt; struct difference_type&lt;BinaryTreeIterator&lt;T&gt;&gt; {
  using type = ptrdiff_t;
};
template &lt;class T&gt; struct value_type&lt;BinaryTreeIterator&lt;T&gt;&gt; {
  using type = T;
};
template &lt;class T&gt; struct iterator_category&lt;BinaryTreeIterator&lt;T&gt;&gt; {
  using type = bidirectional_iterator_tag;
};
</pre><p ><i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p></div></div><div id='iterator.operations'><h3 ><a class='secnum' href='#iterator.operations' style='min-width:103pt'>9.6.4</a> Iterator operations <a class='abbr_ref' href='iterator.operations.html'>[iterator.operations]</a></h3><div class='para' id='iterator.operations-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-1'>1</a></div><p >Since only types that satisfy
<span class='texttt'>RandomAccessIterator</span> provide the <span class='texttt'>+</span> operator, and
types that satisfy <span class='texttt'>SizedSentinel</span> provide the <span class='texttt'>-</span>
operator, the library provides four function templates
<span class='texttt'>advance</span>, <span class='texttt'>distance</span>, <span class='texttt'>next</span>, and <span class='texttt'>prev</span>.
These
function templates
use
<span class='texttt'>+</span>
and
<span class='texttt'>-</span>
for random access iterators and ranges that satisfy <span class='texttt'>SizedSentinel</span>, respectively (and are, therefore, constant
time for them); for output, input, forward and bidirectional iterators they use
<span class='texttt'>++</span>
to provide linear time
implementations.</p><p ><span class='indexparent'><a class='index' id='advance'></a></span><code class='itemdecl'>
template &lt;Iterator I&gt;
  void advance(I&amp; i, difference_type_t&lt;I&gt; n);
</code></p></div><div class='itemdescr'></div><div class='para' id='iterator.operations-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>n</span>
shall be negative only for bidirectional iterators.</p></div></div><div class='para' id='iterator.operations-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
For random access iterators, equivalent to <span class='texttt'>i += n</span>.
Otherwise, increments (or decrements for negative
<span class='texttt'>n</span>)
iterator
<span class='texttt'>i</span>
by
<span class='texttt'>n</span>.
</p></div></div><p ><code class='itemdecl'>
template &lt;Iterator I, Sentinel&lt;I&gt; S&gt;
  void advance(I&amp; i, S bound);
</code></p><div class='itemdescr'></div><div class='para' id='iterator.operations-4'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
If
<span class='texttt'>Assignable&lt;I&amp;, S&gt;()</span> is not satisfied, <span class='texttt'>[i,bound)</span>
shall denote a range.</p></div></div><div class='para' id='iterator.operations-5'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='iterator.operations-5.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.operations-5.1'>(5.1)</a></div><p >If <span class='texttt'>Assignable&lt;I&amp;, S&gt;()</span> is satisfied,
      equivalent to <span class='texttt'>i = std::move(bound)</span>.</p></li><li id='iterator.operations-5.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.operations-5.2'>(5.2)</a></div><p >Otherwise, if
      <span class='texttt'>SizedSentinel&lt;S, I&gt;()</span> is satisfied, equivalent to <span class='texttt'>advance(i, bound - i)</span>.</p></li><li id='iterator.operations-5.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.operations-5.3'>(5.3)</a></div><p >Otherwise, increments <span class='texttt'>i</span> until <span class='texttt'>i == bound</span>.
</p></li></ul></div></div><p ><code class='itemdecl'>
template &lt;Iterator I, Sentinel&lt;I&gt; S&gt;
  difference_type_t&lt;I&gt; advance(I&amp; i, difference_type_t&lt;I&gt; n, S bound);
</code></p><div class='itemdescr'></div><div class='para' id='iterator.operations-6'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i>
If <span class='texttt'>n &gt; 0</span>, <span class='texttt'>[i,bound)</span> shall denote a range. If
<span class='texttt'>n == 0</span>, <span class='texttt'>[i,bound)</span> or <span class='texttt'>[bound,i)</span> shall denote a range. If <span class='texttt'>n &lt; 0</span>,
<span class='texttt'>[bound,i)</span> shall denote a range and <span class='texttt'>(BidirectionalIterator&lt;I&gt;() &amp;&amp; Same&lt;I, S&gt;())</span>
shall be satisfied.</p></div></div><div class='para' id='iterator.operations-7'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><ul class='itemize'><li id='iterator.operations-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.operations-7.1'>(7.1)</a></div><p >If <span class='texttt'>SizedSentinel&lt;S, I&gt;()</span> is satisfied:
      </p><ul class='itemize'><li id='iterator.operations-7.1.1'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#iterator.operations-7.1.1'>(7.1.1)</a></div><p >If <span class='math'>|<span class='texttt'>n</span>| &gt;= |<span class='texttt'>bound - i</span>|</span>, equivalent to <span class='texttt'>advance(i, bound)</span>.</p></li><li id='iterator.operations-7.1.2'><div class='marginalizedparent' style='left:-9em'><a class='marginalized' href='#iterator.operations-7.1.2'>(7.1.2)</a></div><p >Otherwise, equivalent to <span class='texttt'>advance(i, n)</span>.
      </p></li></ul></li><li id='iterator.operations-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.operations-7.2'>(7.2)</a></div><p >Otherwise, increments (or decrements for negative <span class='texttt'>n</span>)
      iterator <span class='texttt'>i</span> either <span class='texttt'>n</span> times or until <span class='texttt'>i == bound</span>,
      whichever comes first.
</p></li></ul></div></div><div class='para' id='iterator.operations-8'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>n - <span class='math'><span class='mathalpha'>M</span></span></span>, where <span class='math'><span class='mathalpha'>M</span></span> is the distance from the starting position of
<span class='texttt'>i</span> to the ending position.
</p></div></div><p ><span class='indexparent'><a class='index' id='distance'></a></span><code class='itemdecl'>
template &lt;Iterator I, Sentinel&lt;I&gt; S&gt;
  difference_type_t&lt;I&gt; distance(I first, S last);
</code></p><div class='itemdescr'></div><div class='para' id='iterator.operations-9'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>[first,last)</span> shall denote a range, or <span class='texttt'>(Same&lt;S, I&gt;() &amp;&amp; SizedSentinel&lt;S, I&gt;())</span> shall be
satisfied and <span class='texttt'>[last,first)</span> shall denote a range.</p></div></div><div class='para' id='iterator.operations-10'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
If <span class='texttt'>SizedSentinel&lt;S, I&gt;()</span> is satisfied, returns <span class='texttt'>(last - first)</span>; otherwise,
returns the number of increments needed to get from
<span class='texttt'>first</span>
to
<span class='texttt'>last</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='next'></a></span><code class='itemdecl'>
template &lt;Iterator I&gt;
  I next(I x, difference_type_t&lt;I&gt; n = 1);
</code></p><div class='itemdescr'></div><div class='para' id='iterator.operations-11'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-11'>11</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <span class='texttt'>advance(x, n); return x;</span>
</p></div></div><p ><code class='itemdecl'>
template &lt;Iterator I, Sentinel&lt;I&gt; S&gt;
  I next(I x, S bound);
</code></p><div class='itemdescr'></div><div class='para' id='iterator.operations-12'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <span class='texttt'>advance(x, bound); return x;</span>
</p></div></div><p ><code class='itemdecl'>
template &lt;Iterator I, Sentinel&lt;I&gt; S&gt;
  I next(I x, difference_type_t&lt;I&gt; n, S bound);
</code></p><div class='itemdescr'></div><div class='para' id='iterator.operations-13'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-13'>13</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <span class='texttt'>advance(x, n, bound); return x;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='prev'></a></span><code class='itemdecl'>
template &lt;BidirectionalIterator I&gt;
  I prev(I x, difference_type_t&lt;I&gt; n = 1);
</code></p><div class='itemdescr'></div><div class='para' id='iterator.operations-14'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <span class='texttt'>advance(x, -n); return x;</span>
</p></div></div><p ><code class='itemdecl'>
template &lt;BidirectionalIterator I&gt;
  I prev(I x, difference_type_t&lt;I&gt; n, I bound);
</code></p><div class='itemdescr'></div><div class='para' id='iterator.operations-15'><div class='marginalizedparent'><a class='marginalized' href='#iterator.operations-15'>15</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <span class='texttt'>advance(x, -n, bound); return x;</span>
</p></div></div></div></div><div id='predef'><h2 ><a class='secnum' href='#predef' style='min-width:88pt'>9.7</a> Iterator adaptors <a class='abbr_ref' href='iterators.predef.html'>[iterators.predef]</a></h2><div id='reverse'><h3 ><a class='secnum' href='#reverse' style='min-width:103pt'>9.7.1</a> Reverse iterators <a class='abbr_ref' href='iterators.reverse.html'>[iterators.reverse]</a></h3><div class='para' id='reverse-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse-1'>1</a></div><p >Class template <span class='texttt'>reverse_iterator</span> is an iterator adaptor that iterates from the end of the sequence defined by its underlying iterator to the beginning of that sequence.
The fundamental relation between a reverse iterator and its corresponding underlying iterator
<span class='texttt'>i</span>
is established by the identity:
<span class='texttt'>*make_reverse_iterator(i) == *prev(i)</span>.</p></div><div id='reverse.iterator'><h4 ><a class='secnum' href='#reverse.iterator' style='min-width:118pt'>9.7.1.1</a> Class template <span class='texttt'>reverse_iterator</span> <a class='abbr_ref' href='reverse.iterator.html'>[reverse.iterator]</a></h4><p ><span class='indexparent'><a class='index' id='reverse_iterator'></a></span></p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;BidirectionalIterator I&gt;
  class reverse_iterator {
  public:
    using iterator_type = I;
    using difference_type = difference_type_t&lt;I&gt;;
    using value_type = value_type_t&lt;I&gt;;
    using iterator_category = iterator_category_t&lt;I&gt;;
    using reference = reference_t&lt;I&gt;;
    using pointer = I;

    reverse_iterator();
    explicit reverse_iterator(I x);
    reverse_iterator(const reverse_iterator&lt;ConvertibleTo&lt;I&gt;&gt;&amp; i);
    reverse_iterator&amp; operator=(const reverse_iterator&lt;ConvertibleTo&lt;I&gt;&gt;&amp; i);

    I base() const;
    reference operator*() const;
    pointer operator-&gt;() const;

    reverse_iterator&amp; operator++();
    reverse_iterator  operator++(int);
    reverse_iterator&amp; operator--();
    reverse_iterator  operator--(int);

    reverse_iterator  operator+ (difference_type n) const
      requires RandomAccessIterator&lt;I&gt;();
    reverse_iterator&amp; operator+=(difference_type n)
      requires RandomAccessIterator&lt;I&gt;();
    reverse_iterator  operator- (difference_type n) const
      requires RandomAccessIterator&lt;I&gt;();
    reverse_iterator&amp; operator-=(difference_type n)
      requires RandomAccessIterator&lt;I&gt;();
    reference operator[](difference_type n) const
      requires RandomAccessIterator&lt;I&gt;();
  private:
    I current; <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class I1, class I2&gt;
      requires EqualityComparable&lt;I1, I2&gt;()
    bool operator==(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires EqualityComparable&lt;I1, I2&gt;()
    bool operator!=(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&lt;(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&gt;(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&gt;=(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&lt;=(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires SizedSentinel&lt;I1, I2&gt;()
    difference_type_t&lt;I2&gt; operator-(
      const reverse_iterator&lt;I1&gt;&amp; x,
      const reverse_iterator&lt;I2&gt;&amp; y);
  template &lt;RandomAccessIterator I&gt;
    reverse_iterator&lt;I&gt;
      operator+(
    difference_type_t&lt;I&gt; n,
    const reverse_iterator&lt;I&gt;&amp; x);

  template &lt;BidirectionalIterator I&gt;
    reverse_iterator&lt;I&gt; make_reverse_iterator(I i);
}}}}
</pre></div><div id='reverse.iter.ops'><h4 ><a class='secnum' href='#reverse.iter.ops' style='min-width:118pt'>9.7.1.2</a> <span class='texttt'>reverse_iterator</span> operations <a class='abbr_ref' href='reverse.iter.ops.html'>[reverse.iter.ops]</a></h4><div id='reverse.iter.cons'><h4 ><a class='secnum' href='#reverse.iter.cons' style='min-width:133pt'>9.7.1.2.1</a> <span class='texttt'>reverse_iterator</span> constructor <a class='abbr_ref' href='reverse.iter.cons.html'>[reverse.iter.cons]</a></h4><p ><span class='indexparent'><a class='index' id='reverse_iterator,reverse_iterator'></a></span><code class='itemdecl'>
reverse_iterator();
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Value-initializes
<span class='texttt'>current</span>.
Iterator operations applied to the resulting iterator have defined behavior
if and only if the corresponding operations are defined on a
value-initialized iterator of type
<span class='texttt'>I</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reverse_iterator,constructor'></a></span><code class='itemdecl'>
explicit reverse_iterator(I x);
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes
<span class='texttt'>current</span>
with <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='reverse_iterator,constructor'></a></span><code class='itemdecl'>
reverse_iterator(const reverse_iterator&lt;ConvertibleTo&lt;I&gt;&gt;&amp; i);
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes
<span class='texttt'>current</span>
with
<span class='texttt'>i.current</span>.
</p></div></div></div><div id='reverse.iter.op='><h4 ><a class='secnum' href='#reverse.iter.op=' style='min-width:133pt'>9.7.1.2.2</a> <span class='texttt'>reverse_iterator::operator=</span> <a class='abbr_ref' href='reverse.iter.op=.html'>[reverse.iter.op=]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,reverse_iterator'></a></span><code class='itemdecl'>
reverse_iterator&amp;
  operator=(const reverse_iterator&lt;ConvertibleTo&lt;I&gt;&gt;&amp; i);
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op=-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Assigns <span class='texttt'>i.current</span> to <span class='texttt'>current</span>.</p></div></div><div class='para' id='reverse.iter.op=-2'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op=-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div><div id='reverse.iter.conv'><h4 ><a class='secnum' href='#reverse.iter.conv' style='min-width:133pt'>9.7.1.2.3</a> Conversion <a class='abbr_ref' href='reverse.iter.conv.html'>[reverse.iter.conv]</a></h4><p ><span class='indexparent'><a class='index' id='base,reverse_iterator'></a></span><span class='indexparent'><a class='index' id='reverse_iterator,base'></a></span><code class='itemdecl'>
I base() const;
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.conv-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.conv-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>current</span>.
</p></div></div></div><div id='reverse.iter.op.star'><h4 ><a class='secnum' href='#reverse.iter.op.star' style='min-width:133pt'>9.7.1.2.4</a> <span class='texttt'>operator*</span> <a class='abbr_ref' href='reverse.iter.op.star.html'>[reverse.iter.op.star]</a></h4><p ><span class='indexparent'><a class='index' id='operator*,reverse_iterator'></a></span><code class='itemdecl'>
reference operator*() const;
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op.star-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op.star-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <span class='texttt'>return *prev(current);</span>
</p></div></div></div><div id='reverse.iter.opref'><h4 ><a class='secnum' href='#reverse.iter.opref' style='min-width:133pt'>9.7.1.2.5</a> <span class='texttt'>operator-&gt;</span> <a class='abbr_ref' href='reverse.iter.opref.html'>[reverse.iter.opref]</a></h4><p ><span class='indexparent'><a class='index' id='operator->,reverse_iterator'></a></span><code class='itemdecl'>
pointer operator-&gt;() const;
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.opref-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.opref-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <span class='texttt'>return prev(current);</span>
</p></div></div></div><div id='reverse.iter.op++'><h4 ><a class='secnum' href='#reverse.iter.op++' style='min-width:133pt'>9.7.1.2.6</a> <span class='texttt'>operator++</span> <a class='abbr_ref' href='reverse.iter.op++.html'>[reverse.iter.op++]</a></h4><p ><span class='indexparent'><a class='index' id='operator++,reverse_iterator'></a></span><code class='itemdecl'>
reverse_iterator&amp; operator++();
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op++-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op++-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
<span class='texttt'>-- current;</span></p></div></div><div class='para' id='reverse.iter.op++-2'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op++-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,reverse_iterator'></a></span><span class='indexparent'><a class='index' id='reverse_iterator,operator++'></a></span><code class='itemdecl'>
reverse_iterator operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op++-3'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op++-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
reverse_iterator tmp = *this;
--current;
return tmp;
</pre></div></div></div><div id='reverse.iter.op--'><h4 ><a class='secnum' href='#reverse.iter.op--' style='min-width:133pt'>9.7.1.2.7</a> <span class='texttt'>operator--</span> <a class='abbr_ref' href='reverse.iter.op--.html'>[reverse.iter.op--]</a></h4><p ><span class='indexparent'><a class='index' id='operator--,reverse_iterator'></a></span><code class='itemdecl'>
reverse_iterator&amp; operator--();
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op---1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op---1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
<span class='texttt'>++current</span></p></div></div><div class='para' id='reverse.iter.op---2'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op---2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator--,reverse_iterator'></a></span><span class='indexparent'><a class='index' id='reverse_iterator,operator--'></a></span><code class='itemdecl'>
reverse_iterator operator--(int);
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op---3'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op---3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
reverse_iterator tmp = *this;
++current;
return tmp;
</pre></div></div></div><div id='reverse.iter.op+'><h4 ><a class='secnum' href='#reverse.iter.op+' style='min-width:133pt'>9.7.1.2.8</a> <span class='texttt'>operator+</span> <a class='abbr_ref' href='reverse.iter.op+.html'>[reverse.iter.op+]</a></h4><p ><span class='indexparent'><a class='index' id='operator+,reverse_iterator'></a></span><code class='itemdecl'>
reverse_iterator
  operator+(difference_type n) const
    requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op+-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op+-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>reverse_iterator(current-n)</span>.
</p></div></div></div><div id='reverse.iter.op+='><h4 ><a class='secnum' href='#reverse.iter.op+=' style='min-width:133pt'>9.7.1.2.9</a> <span class='texttt'>operator+=</span> <a class='abbr_ref' href='reverse.iter.op+=.html'>[reverse.iter.op+=]</a></h4><p ><span class='indexparent'><a class='index' id='operator+=,reverse_iterator'></a></span><code class='itemdecl'>
reverse_iterator&amp;
  operator+=(difference_type n)
    requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op+=-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op+=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
<span class='texttt'>current -= n;</span></p></div></div><div class='para' id='reverse.iter.op+=-2'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op+=-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div><div id='reverse.iter.op-'><h4 ><a class='secnum' href='#reverse.iter.op-' style='min-width:133pt'>9.7.1.2.10</a> <span class='texttt'>operator-</span> <a class='abbr_ref' href='reverse.iter.op-.html'>[reverse.iter.op-]</a></h4><p ><span class='indexparent'><a class='index' id='operator-,reverse_iterator'></a></span><code class='itemdecl'>
reverse_iterator
  operator-(difference_type n) const
    requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op--1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op--1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>reverse_iterator(current+n)</span>.
</p></div></div></div><div id='reverse.iter.op-='><h4 ><a class='secnum' href='#reverse.iter.op-=' style='min-width:133pt'>9.7.1.2.11</a> <span class='texttt'>operator-=</span> <a class='abbr_ref' href='reverse.iter.op-=.html'>[reverse.iter.op-=]</a></h4><p ><span class='indexparent'><a class='index' id='operator-=,reverse_iterator'></a></span><code class='itemdecl'>
reverse_iterator&amp;
  operator-=(difference_type n)
    requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op-=-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op-=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
<span class='texttt'>current += n;</span></p></div></div><div class='para' id='reverse.iter.op-=-2'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op-=-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div><div id='reverse.iter.opindex'><h4 ><a class='secnum' href='#reverse.iter.opindex' style='min-width:133pt'>9.7.1.2.12</a> <span class='texttt'>operator[]</span> <a class='abbr_ref' href='reverse.iter.opindex.html'>[reverse.iter.opindex]</a></h4><p ><span class='indexparent'><a class='index' id='operator[],reverse_iterator'></a></span><code class='itemdecl'>
reference operator[](
  difference_type n) const
    requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.opindex-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.opindex-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>current[-n-1]</span>.
</p></div></div></div><div id='reverse.iter.op=='><h4 ><a class='secnum' href='#reverse.iter.op==' style='min-width:133pt'>9.7.1.2.13</a> <span class='texttt'>operator==</span> <a class='abbr_ref' href='reverse.iter.op==.html'>[reverse.iter.op==]</a></h4><p ><span class='indexparent'><a class='index' id='operator==,reverse_iterator'></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires EqualityComparable&lt;I1, I2&gt;()
  bool operator==(
    const reverse_iterator&lt;I1&gt;&amp; x,
    const reverse_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op==-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op==-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return x.current == y.current;</span>
</p></div></div></div><div id='reverse.iter.op!='><h4 ><a class='secnum' href='#reverse.iter.op!=' style='min-width:133pt'>9.7.1.2.14</a> <span class='texttt'>operator!=</span> <a class='abbr_ref' href='reverse.iter.op!=.html'>[reverse.iter.op!=]</a></h4><p ><span class='indexparent'><a class='index' id='operator!=,reverse_iterator'></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires EqualityComparable&lt;I1, I2&gt;()
  bool operator!=(
    const reverse_iterator&lt;I1&gt;&amp; x,
    const reverse_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op!=-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op!=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return x.current != y.current;</span>
</p></div></div></div><div id='reverse.iter.op&lt;'><h4 ><a class='secnum' href='#reverse.iter.op&lt;' style='min-width:133pt'>9.7.1.2.15</a> <span class='texttt'>operator&lt;</span> <a class='abbr_ref' href='reverse.iter.op%3c.html'>[reverse.iter.op&lt;]</a></h4><p ><span class='indexparent'><a class='index' id='operator<,reverse_iterator'></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrdered&lt;I1, I2&gt;()
  bool operator&lt;(
    const reverse_iterator&lt;I1&gt;&amp; x,
    const reverse_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op&lt;-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op&lt;-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return x.current &gt; y.current;</span>
</p></div></div></div><div id='reverse.iter.op&gt;'><h4 ><a class='secnum' href='#reverse.iter.op&gt;' style='min-width:133pt'>9.7.1.2.16</a> <span class='texttt'>operator&gt;</span> <a class='abbr_ref' href='reverse.iter.op%3e.html'>[reverse.iter.op&gt;]</a></h4><p ><span class='indexparent'><a class='index' id='operator>,reverse_iterator'></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrdered&lt;I1, I2&gt;()
  bool operator&gt;(
    const reverse_iterator&lt;I1&gt;&amp; x,
    const reverse_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op&gt;-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op&gt;-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return x.current &lt; y.current;</span>
</p></div></div></div><div id='reverse.iter.op&gt;='><h4 ><a class='secnum' href='#reverse.iter.op&gt;=' style='min-width:133pt'>9.7.1.2.17</a> <span class='texttt'>operator&gt;=</span> <a class='abbr_ref' href='reverse.iter.op%3e=.html'>[reverse.iter.op&gt;=]</a></h4><p ><span class='indexparent'><a class='index' id='operator>=,reverse_iterator'></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrdered&lt;I1, I2&gt;()
  bool operator&gt;=(
    const reverse_iterator&lt;I1&gt;&amp; x,
    const reverse_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op&gt;=-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op&gt;=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return x.current &lt;= y.current;</span>
</p></div></div></div><div id='reverse.iter.op&lt;='><h4 ><a class='secnum' href='#reverse.iter.op&lt;=' style='min-width:133pt'>9.7.1.2.18</a> <span class='texttt'>operator&lt;=</span> <a class='abbr_ref' href='reverse.iter.op%3c=.html'>[reverse.iter.op&lt;=]</a></h4><p ><span class='indexparent'><a class='index' id='operator<=,reverse_iterator'></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrdered&lt;I1, I2&gt;()
  bool operator&lt;=(
    const reverse_iterator&lt;I1&gt;&amp; x,
    const reverse_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.op&lt;=-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.op&lt;=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return x.current &gt;= y.current;</span>
</p></div></div></div><div id='reverse.iter.opdiff'><h4 ><a class='secnum' href='#reverse.iter.opdiff' style='min-width:133pt'>9.7.1.2.19</a> <span class='texttt'>operator-</span> <a class='abbr_ref' href='reverse.iter.opdiff.html'>[reverse.iter.opdiff]</a></h4><p ><span class='indexparent'><a class='index' id='operator-,reverse_iterator'></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires SizedSentinel&lt;I1, I2&gt;()
  difference_type_t&lt;I2&gt; operator-(
    const reverse_iterator&lt;I1&gt;&amp; x,
    const reverse_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.opdiff-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.opdiff-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return y.current - x.current;</span>
</p></div></div></div><div id='reverse.iter.opsum'><h4 ><a class='secnum' href='#reverse.iter.opsum' style='min-width:133pt'>9.7.1.2.20</a> <span class='texttt'>operator+</span> <a class='abbr_ref' href='reverse.iter.opsum.html'>[reverse.iter.opsum]</a></h4><p ><span class='indexparent'><a class='index' id='operator+,reverse_iterator'></a></span><code class='itemdecl'>
template &lt;RandomAccessIterator I&gt;
  reverse_iterator&lt;I&gt;
    operator+(
  difference_type_t&lt;I&gt; n,
  const reverse_iterator&lt;I&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.opsum-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.opsum-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return reverse_iterator&lt;I&gt;(x.current - n);</span>
</p></div></div></div><div id='reverse.iter.make'><h4 ><a class='secnum' href='#reverse.iter.make' style='min-width:133pt'>9.7.1.2.21</a> Non-member function <span class='texttt'>make_reverse_iterator()</span> <a class='abbr_ref' href='reverse.iter.make.html'>[reverse.iter.make]</a></h4><p ><span class='indexparent'><a class='index' id='reverse_iterator,make_reverse_iterator'></a></span>
<span class='indexparent'><a class='index' id='make_reverse_iterator'></a></span><code class='itemdecl'>
template &lt;BidirectionalIterator I&gt;
  reverse_iterator&lt;I&gt; make_reverse_iterator(I i);
</code></p><div class='itemdescr'></div><div class='para' id='reverse.iter.make-1'><div class='marginalizedparent'><a class='marginalized' href='#reverse.iter.make-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>reverse_iterator&lt;I&gt;(i)</span>.
</p></div></div></div></div></div><div id='insert'><h3 ><a class='secnum' href='#insert' style='min-width:103pt'>9.7.2</a> Insert iterators <a class='abbr_ref' href='iterators.insert.html'>[iterators.insert]</a></h3><div class='para' id='insert-1'><div class='marginalizedparent'><a class='marginalized' href='#insert-1'>1</a></div><p >To make it possible to deal with insertion in the same way as writing into an array, a special kind of iterator
adaptors, called
<i>insert iterators</i>,
are provided in the library.
With regular iterator classes,</p><pre class='codeblock'>
while (first != last) *result++ = *first++;
</pre><p >causes a range <span class='texttt'>[first,last)</span>
to be copied into a range starting with result.
The same code with
<span class='texttt'>result</span>
being an insert iterator will insert corresponding elements into the container.
This device allows all of the
copying algorithms in the library to work in the
<i>insert mode</i>
instead of the <i>regular overwrite</i> mode.</p></div><div class='para' id='insert-2'><div class='marginalizedparent'><a class='marginalized' href='#insert-2'>2</a></div><p >An insert iterator is constructed from a container and possibly one of its iterators pointing to where
insertion takes place if it is neither at the beginning nor at the end of the container.
Insert iterators satisfy <span class='texttt'>OutputIterator</span>.
<span class='texttt'>operator*</span>
returns the insert iterator itself.
The assignment
<span class='texttt'>operator=(const T&amp; x)</span>
is defined on insert iterators to allow writing into them, it inserts
<span class='texttt'>x</span>
right before where the insert iterator is pointing.
In other words, an insert iterator is like a cursor pointing into the
container where the insertion takes place.
<span class='texttt'>back_insert_iterator</span>
inserts elements at the end of a container,
<span class='texttt'>front_insert_iterator</span>
inserts elements at the beginning of a container, and
<span class='texttt'>insert_iterator</span>
inserts elements where the iterator points to in a container.
<span class='texttt'>back_inserter</span>,
<span class='texttt'>front_inserter</span>,
and
<span class='texttt'>inserter</span>
are three
functions making the insert iterators out of a container.</p></div><div id='back.insert.iterator'><h4 ><a class='secnum' href='#back.insert.iterator' style='min-width:118pt'>9.7.2.1</a> Class template <span class='texttt'>back_insert_iterator</span> <a class='abbr_ref' href='back.insert.iterator.html'>[back.insert.iterator]</a></h4><p ><span class='indexparent'><a class='index' id='back_insert_iterator'></a></span></p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;class Container&gt;
  class back_insert_iterator {
  public:
    using container_type = Container;
    using difference_type = ptrdiff_t;

    constexpr back_insert_iterator();
    explicit back_insert_iterator(Container&amp; x);
    back_insert_iterator&amp;
      operator=(const value_type_t&lt;Container&gt;&amp; value);
    back_insert_iterator&amp;
      operator=(value_type_t&lt;Container&gt;&amp;&amp; value);

    back_insert_iterator&amp; operator*();
    back_insert_iterator&amp; operator++();
    back_insert_iterator operator++(int);

  private:
    Container* container; <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class Container&gt;
    back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; x);
}}}}
</pre></div><div id='back.insert.iter.ops'><h4 ><a class='secnum' href='#back.insert.iter.ops' style='min-width:118pt'>9.7.2.2</a> <span class='texttt'>back_insert_iterator</span> operations <a class='abbr_ref' href='back.insert.iter.ops.html'>[back.insert.iter.ops]</a></h4><div id='back.insert.iter.cons'><h4 ><a class='secnum' href='#back.insert.iter.cons' style='min-width:133pt'>9.7.2.2.1</a> <span class='texttt'>back_insert_iterator</span> constructor <a class='abbr_ref' href='back.insert.iter.cons.html'>[back.insert.iter.cons]</a></h4><p ><span class='indexparent'><a class='index' id='back_insert_iterator,back_insert_iterator'></a></span><code class='itemdecl'>
constexpr back_insert_iterator();
</code></p><div class='itemdescr'></div><div class='para' id='back.insert.iter.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#back.insert.iter.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Value-initializes
<span class='texttt'>container</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='back_insert_iterator,constructor'></a></span>
<code class='itemdecl'>
explicit back_insert_iterator(Container&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='back.insert.iter.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#back.insert.iter.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes
<span class='texttt'>container</span>
with <span class='texttt'>addressof(x)</span>.
</p></div></div></div><div id='back.insert.iter.op='><h4 ><a class='secnum' href='#back.insert.iter.op=' style='min-width:133pt'>9.7.2.2.2</a> <span class='texttt'>back_insert_iterator::operator=</span> <a class='abbr_ref' href='back.insert.iter.op=.html'>[back.insert.iter.op=]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,back_insert_iterator'></a></span><code class='itemdecl'>
back_insert_iterator&amp;
  operator=(const value_type_t&lt;Container&gt;&amp; value);
</code></p><div class='itemdescr'></div><div class='para' id='back.insert.iter.op=-1'><div class='marginalizedparent'><a class='marginalized' href='#back.insert.iter.op=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to
<span class='texttt'>container-&gt;push_back(value)</span>.</p></div></div><div class='para' id='back.insert.iter.op=-2'><div class='marginalizedparent'><a class='marginalized' href='#back.insert.iter.op=-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,back_insert_iterator'></a></span><code class='itemdecl'>
back_insert_iterator&amp;
  operator=(value_type_t&lt;Container&gt;&amp;&amp; value);
</code></p><div class='itemdescr'></div><div class='para' id='back.insert.iter.op=-3'><div class='marginalizedparent'><a class='marginalized' href='#back.insert.iter.op=-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to
<span class='texttt'>container-&gt;push_back(std::move(value))</span>.</p></div></div><div class='para' id='back.insert.iter.op=-4'><div class='marginalizedparent'><a class='marginalized' href='#back.insert.iter.op=-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div><div id='back.insert.iter.op*'><h4 ><a class='secnum' href='#back.insert.iter.op*' style='min-width:133pt'>9.7.2.2.3</a> <span class='texttt'>back_insert_iterator::operator*</span> <a class='abbr_ref' href='back.insert.iter.op*.html'>[back.insert.iter.op*]</a></h4><p ><span class='indexparent'><a class='index' id='operator*,back_insert_iterator'></a></span><code class='itemdecl'>
back_insert_iterator&amp; operator*();
</code></p><div class='itemdescr'></div><div class='para' id='back.insert.iter.op*-1'><div class='marginalizedparent'><a class='marginalized' href='#back.insert.iter.op*-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div><div id='back.insert.iter.op++'><h4 ><a class='secnum' href='#back.insert.iter.op++' style='min-width:133pt'>9.7.2.2.4</a> <span class='texttt'>back_insert_iterator::operator++</span> <a class='abbr_ref' href='back.insert.iter.op++.html'>[back.insert.iter.op++]</a></h4><p ><span class='indexparent'><a class='index' id='operator++,back_insert_iterator'></a></span><code class='itemdecl'>
back_insert_iterator&amp; operator++();
back_insert_iterator operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='back.insert.iter.op++-1'><div class='marginalizedparent'><a class='marginalized' href='#back.insert.iter.op++-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div><div id='back.inserter'><h4 ><a class='secnum' href='#back.inserter' style='min-width:133pt'>9.7.2.2.5</a>  <span class='texttt'>back_inserter</span> <a class='abbr_ref' href='back.inserter.html'>[back.inserter]</a></h4><p ><span class='indexparent'><a class='index' id='back_inserter'></a></span><code class='itemdecl'>
template &lt;class Container&gt;
  back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='back.inserter-1'><div class='marginalizedparent'><a class='marginalized' href='#back.inserter-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>back_insert_iterator&lt;Container&gt;(x)</span>.
</p></div></div></div></div><div id='front.insert.iterator'><h4 ><a class='secnum' href='#front.insert.iterator' style='min-width:118pt'>9.7.2.3</a> Class template <span class='texttt'>front_insert_iterator</span> <a class='abbr_ref' href='front.insert.iterator.html'>[front.insert.iterator]</a></h4><p ><span class='indexparent'><a class='index' id='front_insert_iterator'></a></span></p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;class Container&gt;
  class front_insert_iterator {
  public:
    using container_type = Container;
    using difference_type = ptrdiff_t;

    constexpr front_insert_iterator();
    explicit front_insert_iterator(Container&amp; x);
    front_insert_iterator&amp;
      operator=(const value_type_t&lt;Container&gt;&amp; value);
    front_insert_iterator&amp;
      operator=(value_type_t&lt;Container&gt;&amp;&amp; value);

    front_insert_iterator&amp; operator*();
    front_insert_iterator&amp; operator++();
    front_insert_iterator operator++(int);

  private:
    Container* container; <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class Container&gt;
    front_insert_iterator&lt;Container&gt; front_inserter(Container&amp; x);
}}}}
</pre></div><div id='front.insert.iter.ops'><h4 ><a class='secnum' href='#front.insert.iter.ops' style='min-width:118pt'>9.7.2.4</a> <span class='texttt'>front_insert_iterator</span> operations <a class='abbr_ref' href='front.insert.iter.ops.html'>[front.insert.iter.ops]</a></h4><div id='front.insert.iter.cons'><h4 ><a class='secnum' href='#front.insert.iter.cons' style='min-width:133pt'>9.7.2.4.1</a> <span class='texttt'>front_insert_iterator</span> constructor <a class='abbr_ref' href='front.insert.iter.cons.html'>[front.insert.iter.cons]</a></h4><p ><span class='indexparent'><a class='index' id='front_insert_iterator,front_insert_iterator'></a></span><code class='itemdecl'>
constexpr front_insert_iterator();
</code></p><div class='itemdescr'></div><div class='para' id='front.insert.iter.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#front.insert.iter.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Value-initializes
<span class='texttt'>container</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='front_insert_iterator,constructor'></a></span><code class='itemdecl'>
explicit front_insert_iterator(Container&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='front.insert.iter.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#front.insert.iter.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes
<span class='texttt'>container</span>
with <span class='texttt'>addressof(x)</span>.
</p></div></div></div><div id='front.insert.iter.op='><h4 ><a class='secnum' href='#front.insert.iter.op=' style='min-width:133pt'>9.7.2.4.2</a> <span class='texttt'>front_insert_iterator::operator=</span> <a class='abbr_ref' href='front.insert.iter.op=.html'>[front.insert.iter.op=]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,front_insert_iterator'></a></span><code class='itemdecl'>
front_insert_iterator&amp;
  operator=(const value_type_t&lt;Container&gt;&amp; value);
</code></p><div class='itemdescr'></div><div class='para' id='front.insert.iter.op=-1'><div class='marginalizedparent'><a class='marginalized' href='#front.insert.iter.op=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to
<span class='texttt'>container-&gt;push_front(value)</span>.</p></div></div><div class='para' id='front.insert.iter.op=-2'><div class='marginalizedparent'><a class='marginalized' href='#front.insert.iter.op=-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,front_insert_iterator'></a></span><code class='itemdecl'>
front_insert_iterator&amp;
  operator=(value_type_t&lt;Container&gt;&amp;&amp; value);
</code></p><div class='itemdescr'></div><div class='para' id='front.insert.iter.op=-3'><div class='marginalizedparent'><a class='marginalized' href='#front.insert.iter.op=-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to
<span class='texttt'>container-&gt;push_front(std::move(value))</span>.</p></div></div><div class='para' id='front.insert.iter.op=-4'><div class='marginalizedparent'><a class='marginalized' href='#front.insert.iter.op=-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div><div id='front.insert.iter.op*'><h4 ><a class='secnum' href='#front.insert.iter.op*' style='min-width:133pt'>9.7.2.4.3</a> <span class='texttt'>front_insert_iterator::operator*</span> <a class='abbr_ref' href='front.insert.iter.op*.html'>[front.insert.iter.op*]</a></h4><p ><span class='indexparent'><a class='index' id='operator*,front_insert_iterator'></a></span><code class='itemdecl'>
front_insert_iterator&amp; operator*();
</code></p><div class='itemdescr'></div><div class='para' id='front.insert.iter.op*-1'><div class='marginalizedparent'><a class='marginalized' href='#front.insert.iter.op*-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div><div id='front.insert.iter.op++'><h4 ><a class='secnum' href='#front.insert.iter.op++' style='min-width:133pt'>9.7.2.4.4</a> <span class='texttt'>front_insert_iterator::operator++</span> <a class='abbr_ref' href='front.insert.iter.op++.html'>[front.insert.iter.op++]</a></h4><p ><span class='indexparent'><a class='index' id='operator++,front_insert_iterator'></a></span><code class='itemdecl'>
front_insert_iterator&amp; operator++();
front_insert_iterator operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='front.insert.iter.op++-1'><div class='marginalizedparent'><a class='marginalized' href='#front.insert.iter.op++-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div><div id='front.inserter'><h4 ><a class='secnum' href='#front.inserter' style='min-width:133pt'>9.7.2.4.5</a> <span class='texttt'>front_inserter</span> <a class='abbr_ref' href='front.inserter.html'>[front.inserter]</a></h4><p ><span class='indexparent'><a class='index' id='front_inserter'></a></span><code class='itemdecl'>
template &lt;class Container&gt;
  front_insert_iterator&lt;Container&gt; front_inserter(Container&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='front.inserter-1'><div class='marginalizedparent'><a class='marginalized' href='#front.inserter-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>front_insert_iterator&lt;Container&gt;(x)</span>.
</p></div></div></div></div><div id='insert.iterator'><h4 ><a class='secnum' href='#insert.iterator' style='min-width:118pt'>9.7.2.5</a> Class template <span class='texttt'>insert_iterator</span> <a class='abbr_ref' href='insert.iterator.html'>[insert.iterator]</a></h4><p ><span class='indexparent'><a class='index' id='insert_iterator'></a></span></p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;class Container&gt;
  class insert_iterator {
  public:
    using container_type = Container;
    using difference_type = ptrdiff_t;

    insert_iterator();
    insert_iterator(Container&amp; x, iterator_t&lt;Container&gt; i);
    insert_iterator&amp;
      operator=(const value_type_t&lt;Container&gt;&amp; value);
    insert_iterator&amp;
      operator=(value_type_t&lt;Container&gt;&amp;&amp; value);

    insert_iterator&amp; operator*();
    insert_iterator&amp; operator++();
    insert_iterator operator++(int);

  private:
    Container* container;       <span class='comment'>// <i>exposition only</i>
</span>    iterator_t&lt;Container&gt; iter; <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class Container&gt;
    insert_iterator&lt;Container&gt; inserter(Container&amp; x, iterator_t&lt;Container&gt; i);
}}}}
</pre></div><div id='insert.iter.ops'><h4 ><a class='secnum' href='#insert.iter.ops' style='min-width:118pt'>9.7.2.6</a> <span class='texttt'>insert_iterator</span> operations <a class='abbr_ref' href='insert.iter.ops.html'>[insert.iter.ops]</a></h4><div id='insert.iter.cons'><h4 ><a class='secnum' href='#insert.iter.cons' style='min-width:133pt'>9.7.2.6.1</a> <span class='texttt'>insert_iterator</span> constructor <a class='abbr_ref' href='insert.iter.cons.html'>[insert.iter.cons]</a></h4><p ><span class='indexparent'><a class='index' id='insert_iterator,insert_iterator'></a></span><code class='itemdecl'>
insert_iterator();
</code></p><div class='itemdescr'></div><div class='para' id='insert.iter.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#insert.iter.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Value-initializes
<span class='texttt'>container</span> and <span class='texttt'>iter</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='insert_iterator,constructor'></a></span><code class='itemdecl'>
insert_iterator(Container&amp; x, iterator_t&lt;Container&gt; i);
</code></p><div class='itemdescr'></div><div class='para' id='insert.iter.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#insert.iter.cons-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>i</span> is an iterator into <span class='texttt'>x</span>.</p></div></div><div class='para' id='insert.iter.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#insert.iter.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes
<span class='texttt'>container</span>
with <span class='texttt'>addressof(x)</span> and
<span class='texttt'>iter</span>
with <span class='texttt'>i</span>.
</p></div></div></div><div id='insert.iter.op='><h4 ><a class='secnum' href='#insert.iter.op=' style='min-width:133pt'>9.7.2.6.2</a> <span class='texttt'>insert_iterator::operator=</span> <a class='abbr_ref' href='insert.iter.op=.html'>[insert.iter.op=]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,insert_iterator'></a></span><code class='itemdecl'>
insert_iterator&amp;
  operator=(const value_type_t&lt;Container&gt;&amp; value);
</code></p><div class='itemdescr'></div><div class='para' id='insert.iter.op=-1'><div class='marginalizedparent'><a class='marginalized' href='#insert.iter.op=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
iter = container-&gt;insert(iter, value);
++iter;
</pre></div></div><div class='para' id='insert.iter.op=-2'><div class='marginalizedparent'><a class='marginalized' href='#insert.iter.op=-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator=,insert_iterator'></a></span><code class='itemdecl'>
insert_iterator&amp;
  operator=(value_type_t&lt;Container&gt;&amp;&amp; value);
</code></p><div class='itemdescr'></div><div class='para' id='insert.iter.op=-3'><div class='marginalizedparent'><a class='marginalized' href='#insert.iter.op=-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
iter = container-&gt;insert(iter, std::move(value));
++iter;
</pre></div></div><div class='para' id='insert.iter.op=-4'><div class='marginalizedparent'><a class='marginalized' href='#insert.iter.op=-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div><div id='insert.iter.op*'><h4 ><a class='secnum' href='#insert.iter.op*' style='min-width:133pt'>9.7.2.6.3</a> <span class='texttt'>insert_iterator::operator*</span> <a class='abbr_ref' href='insert.iter.op*.html'>[insert.iter.op*]</a></h4><p ><span class='indexparent'><a class='index' id='operator*,insert_iterator'></a></span><code class='itemdecl'>
insert_iterator&amp; operator*();
</code></p><div class='itemdescr'></div><div class='para' id='insert.iter.op*-1'><div class='marginalizedparent'><a class='marginalized' href='#insert.iter.op*-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div><div id='insert.iter.op++'><h4 ><a class='secnum' href='#insert.iter.op++' style='min-width:133pt'>9.7.2.6.4</a> <span class='texttt'>insert_iterator::operator++</span> <a class='abbr_ref' href='insert.iter.op++.html'>[insert.iter.op++]</a></h4><p ><span class='indexparent'><a class='index' id='operator++,insert_iterator'></a></span><code class='itemdecl'>
insert_iterator&amp; operator++();
insert_iterator operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='insert.iter.op++-1'><div class='marginalizedparent'><a class='marginalized' href='#insert.iter.op++-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div><div id='inserter'><h4 ><a class='secnum' href='#inserter' style='min-width:133pt'>9.7.2.6.5</a> <span class='texttt'>inserter</span> <a class='abbr_ref' href='inserter.html'>[inserter]</a></h4><p ><span class='indexparent'><a class='index' id='inserter'></a></span><code class='itemdecl'>
template &lt;class Container&gt;
  insert_iterator&lt;Container&gt; inserter(Container&amp; x, iterator_t&lt;Container&gt; i);
</code></p><div class='itemdescr'></div><div class='para' id='inserter-1'><div class='marginalizedparent'><a class='marginalized' href='#inserter-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>insert_iterator&lt;Container&gt;(x, i)</span>.
</p></div></div></div></div></div><div id='move'><h3 ><a class='secnum' href='#move' style='min-width:103pt'>9.7.3</a> Move iterators and sentinels <a class='abbr_ref' href='iterators.move.html'>[iterators.move]</a></h3><div id='move.iterator'><h4 ><a class='secnum' href='#move.iterator' style='min-width:118pt'>9.7.3.1</a> Class template <span class='texttt'>move_iterator</span> <a class='abbr_ref' href='move.iterator.html'>[move.iterator]</a></h4><div class='para' id='move.iterator-1'><div class='marginalizedparent'><a class='marginalized' href='#move.iterator-1'>1</a></div><p >Class template <span class='texttt'>move_iterator</span> is an iterator adaptor
with the same behavior as the underlying iterator except that its
indirection operator implicitly converts the value returned by the
underlying iterator's indirection operator to an rvalue
of the value type.
Some generic algorithms can be called with move iterators to replace
copying with moving.</p></div><div class='para' id='move.iterator-2'><div class='marginalizedparent'><a class='marginalized' href='#move.iterator-2'>2</a></div><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
list&lt;string&gt; s;
<span class='comment'>// populate the list <span class='texttt'>s</span>
</span>vector&lt;string&gt; v1(s.begin(), s.end());          <span class='comment'>// copies strings into <span class='texttt'>v1</span>
</span>vector&lt;string&gt; v2(make_move_iterator(s.begin()),
                  make_move_iterator(s.end())); <span class='comment'>// moves strings into <span class='texttt'>v2</span>
</span></pre><p ><i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='move_iterator'></a></span></p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;InputIterator I&gt;
  class move_iterator {
  public:
    using iterator_type     = I;
    using difference_type   = difference_type_t&lt;I&gt;;
    using value_type        = value_type_t&lt;I&gt;;
    using iterator_category = input_iterator_tag;
    using reference         = rvalue_reference_t&lt;I&gt;;

    move_iterator();
    explicit move_iterator(I i);
    move_iterator(const move_iterator&lt;ConvertibleTo&lt;I&gt;&gt;&amp; i);
    move_iterator&amp; operator=(const move_iterator&lt;ConvertibleTo&lt;I&gt;&gt;&amp; i);

    I base() const;
    reference operator*() const;

    move_iterator&amp; operator++();
    move_iterator operator++(int);
    move_iterator&amp; operator--()
      requires BidirectionalIterator&lt;I&gt;();
    move_iterator operator--(int)
      requires BidirectionalIterator&lt;I&gt;();

    move_iterator operator+(difference_type n) const
      requires RandomAccessIterator&lt;I&gt;();
    move_iterator&amp; operator+=(difference_type n)
      requires RandomAccessIterator&lt;I&gt;();
    move_iterator operator-(difference_type n) const
      requires RandomAccessIterator&lt;I&gt;();
    move_iterator&amp; operator-=(difference_type n)
      requires RandomAccessIterator&lt;I&gt;();
    reference operator[](difference_type n) const
      requires RandomAccessIterator&lt;I&gt;();

  private:
    I current; <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class I1, class I2&gt;
      requires EqualityComparable&lt;I1, I2&gt;()
    bool operator==(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires EqualityComparable&lt;I1, I2&gt;()
    bool operator!=(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&lt;(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&lt;=(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&gt;(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires StrictTotallyOrdered&lt;I1, I2&gt;()
    bool operator&gt;=(
      const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);

  template &lt;class I1, class I2&gt;
      requires SizedSentinel&lt;I1, I2&gt;()
    difference_type_t&lt;I2&gt; operator-(
      const move_iterator&lt;I1&gt;&amp; x,
      const move_iterator&lt;I2&gt;&amp; y);
  template &lt;RandomAccessIterator I&gt;
    move_iterator&lt;I&gt;
      operator+(
        difference_type_t&lt;I&gt; n,
        const move_iterator&lt;I&gt;&amp; x);
  template &lt;InputIterator I&gt;
    move_iterator&lt;I&gt; make_move_iterator(I i);
}}}}
</pre></div><div class='para' id='move.iterator-3'><div class='marginalizedparent'><a class='marginalized' href='#move.iterator-3'>3</a></div><p >[&nbsp;<i>Note:</i> <span class='texttt'>move_iterator</span> does not provide an <span class='texttt'>operator-&gt;</span> because the class member access
expression <span class='texttt'><i>i</i>-&gt;<i>m</i></span> may have different semantics than the expression
<span class='texttt'>(*<i>i</i>).<i>m</i></span> when the expression <span class='texttt'>*<i>i</i></span> is an rvalue.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='move.iter.ops'><h4 ><a class='secnum' href='#move.iter.ops' style='min-width:118pt'>9.7.3.2</a> <span class='texttt'>move_iterator</span> operations <a class='abbr_ref' href='move.iter.ops.html'>[move.iter.ops]</a></h4><div id='move.iter.op.const'><h4 ><a class='secnum' href='#move.iter.op.const' style='min-width:133pt'>9.7.3.2.1</a> <span class='texttt'>move_iterator</span> constructors <a class='abbr_ref' href='move.iter.op.const.html'>[move.iter.op.const]</a></h4><p ><span class='indexparent'><a class='index' id='move_iterator,move_iterator'></a></span><code class='itemdecl'>
move_iterator();
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.const-1'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.const-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>move_iterator</span>, value-initializing
<span class='texttt'>current</span>. Iterator operations applied to the resulting
iterator have defined behavior if and only if the corresponding operations are defined
on a value-initialized iterator of type <span class='texttt'>I</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='move_iterator,constructor'></a></span><code class='itemdecl'>
explicit move_iterator(I i);
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.const-2'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.const-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>move_iterator</span>, initializing
<span class='texttt'>current</span> with <span class='texttt'>i</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='move_iterator,constructor'></a></span><code class='itemdecl'>
move_iterator(const move_iterator&lt;ConvertibleTo&lt;I&gt;&gt;&amp; i);
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.const-3'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.const-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>move_iterator</span>, initializing
<span class='texttt'>current</span> with <span class='texttt'>i.current</span>.
</p></div></div></div><div id='move.iter.op='><h4 ><a class='secnum' href='#move.iter.op=' style='min-width:133pt'>9.7.3.2.2</a> <span class='texttt'>move_iterator::operator=</span> <a class='abbr_ref' href='move.iter.op=.html'>[move.iter.op=]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator='></a></span><code class='itemdecl'>
move_iterator&amp; operator=(const move_iterator&lt;ConvertibleTo&lt;I&gt;&gt;&amp; i);
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op=-1'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns <span class='texttt'>i.current</span> to
<span class='texttt'>current</span>.
</p></div></div></div><div id='move.iter.op.conv'><h4 ><a class='secnum' href='#move.iter.op.conv' style='min-width:133pt'>9.7.3.2.3</a> <span class='texttt'>move_iterator</span> conversion <a class='abbr_ref' href='move.iter.op.conv.html'>[move.iter.op.conv]</a></h4><p ><span class='indexparent'><a class='index' id='base,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,base'></a></span><code class='itemdecl'>
I base() const;
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.conv-1'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.conv-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>current</span>.
</p></div></div></div><div id='move.iter.op.star'><h4 ><a class='secnum' href='#move.iter.op.star' style='min-width:133pt'>9.7.3.2.4</a> <span class='texttt'>move_iterator::operator*</span> <a class='abbr_ref' href='move.iter.op.star.html'>[move.iter.op.star]</a></h4><p ><span class='indexparent'><a class='index' id='operator*,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator*'></a></span><code class='itemdecl'>
reference operator*() const;
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.star-1'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.star-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return iter_move(current);</span>
</p></div></div></div><div id='move.iter.op.incr'><h4 ><a class='secnum' href='#move.iter.op.incr' style='min-width:133pt'>9.7.3.2.5</a> <span class='texttt'>move_iterator::operator++</span> <a class='abbr_ref' href='move.iter.op.incr.html'>[move.iter.op.incr]</a></h4><p ><span class='indexparent'><a class='index' id='operator++,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator++'></a></span><code class='itemdecl'>
move_iterator&amp; operator++();
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.incr-1'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.incr-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>++current</span>.</p></div></div><div class='para' id='move.iter.op.incr-2'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.incr-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator++'></a></span><code class='itemdecl'>
move_iterator operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.incr-3'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.incr-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
move_iterator tmp = *this;
++current;
return tmp;
</pre></div></div></div><div id='move.iter.op.decr'><h4 ><a class='secnum' href='#move.iter.op.decr' style='min-width:133pt'>9.7.3.2.6</a> <span class='texttt'>move_iterator::operator--</span> <a class='abbr_ref' href='move.iter.op.decr.html'>[move.iter.op.decr]</a></h4><p ><span class='indexparent'><a class='index' id='operator--,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator--'></a></span><code class='itemdecl'>
move_iterator&amp; operator--()
  requires BidirectionalIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.decr-1'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.decr-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>--current</span>.</p></div></div><div class='para' id='move.iter.op.decr-2'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.decr-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator--,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator--'></a></span><code class='itemdecl'>
move_iterator operator--(int)
  requires BidirectionalIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.decr-3'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.decr-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
move_iterator tmp = *this;
--current;
return tmp;
</pre></div></div></div><div id='move.iter.op.+'><h4 ><a class='secnum' href='#move.iter.op.+' style='min-width:133pt'>9.7.3.2.7</a> <span class='texttt'>move_iterator::operator+</span> <a class='abbr_ref' href='move.iter.op.+.html'>[move.iter.op.+]</a></h4><p ><span class='indexparent'><a class='index' id='operator+,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator+'></a></span><code class='itemdecl'>
move_iterator operator+(difference_type n) const
  requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.+-1'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.+-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return move_iterator(current + n);</span>
</p></div></div></div><div id='move.iter.op.+='><h4 ><a class='secnum' href='#move.iter.op.+=' style='min-width:133pt'>9.7.3.2.8</a> <span class='texttt'>move_iterator::operator+=</span> <a class='abbr_ref' href='move.iter.op.+=.html'>[move.iter.op.+=]</a></h4><p ><span class='indexparent'><a class='index' id='operator+=,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator+='></a></span><code class='itemdecl'>
move_iterator&amp; operator+=(difference_type n)
  requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.+=-1'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.+=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>current += n</span>.</p></div></div><div class='para' id='move.iter.op.+=-2'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.+=-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='move.iter.op.-'><h4 ><a class='secnum' href='#move.iter.op.-' style='min-width:133pt'>9.7.3.2.9</a> <span class='texttt'>move_iterator::operator-</span> <a class='abbr_ref' href='move.iter.op.-.html'>[move.iter.op.-]</a></h4><p ><span class='indexparent'><a class='index' id='operator-,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator-'></a></span><code class='itemdecl'>
move_iterator operator-(difference_type n) const
  requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.--1'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.--1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return move_iterator(current - n);</span>
</p></div></div></div><div id='move.iter.op.-='><h4 ><a class='secnum' href='#move.iter.op.-=' style='min-width:133pt'>9.7.3.2.10</a> <span class='texttt'>move_iterator::operator-=</span> <a class='abbr_ref' href='move.iter.op.-=.html'>[move.iter.op.-=]</a></h4><p ><span class='indexparent'><a class='index' id='operator-=,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator-='></a></span><code class='itemdecl'>
move_iterator&amp; operator-=(difference_type n)
  requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.-=-1'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.-=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to <span class='texttt'>current -= n</span>.</p></div></div><div class='para' id='move.iter.op.-=-2'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.-=-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='move.iter.op.index'><h4 ><a class='secnum' href='#move.iter.op.index' style='min-width:133pt'>9.7.3.2.11</a> <span class='texttt'>move_iterator::operator[]</span> <a class='abbr_ref' href='move.iter.op.index.html'>[move.iter.op.index]</a></h4><p ><span class='indexparent'><a class='index' id='operator[],move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator[]'></a></span><code class='itemdecl'>
reference operator[](difference_type n) const
  requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.index-1'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.index-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return iter_move(current + n);</span>
</p></div></div></div><div id='move.iter.op.comp'><h4 ><a class='secnum' href='#move.iter.op.comp' style='min-width:133pt'>9.7.3.2.12</a> <span class='texttt'>move_iterator</span> comparisons <a class='abbr_ref' href='move.iter.op.comp.html'>[move.iter.op.comp]</a></h4><p ><span class='indexparent'><a class='index' id='operator==,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator=='></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires EqualityComparable&lt;I1, I2&gt;()
  bool operator==(
    const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.comp-1'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.comp-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return x.current == y.current;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator!='></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires EqualityComparable&lt;I1, I2&gt;()
  bool operator!=(
    const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.comp-2'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.comp-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return !(x == y);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator<'></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrdered&lt;I1, I2&gt;()
  bool operator&lt;(
    const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.comp-3'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.comp-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return x.current &lt; y.current;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator<='></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrdered&lt;I1, I2&gt;()
  bool operator&lt;=(
    const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.comp-4'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.comp-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return !(y &lt; x);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator>'></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrdered&lt;I1, I2&gt;()
  bool operator&gt;(
    const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.comp-5'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.comp-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return y &lt; x;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator>='></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrdered&lt;I1, I2&gt;()
  bool operator&gt;=(
    const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.op.comp-6'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.op.comp-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return !(x &lt; y);</span>.
</p></div></div></div><div id='move.iter.nonmember'><h4 ><a class='secnum' href='#move.iter.nonmember' style='min-width:133pt'>9.7.3.2.13</a> <span class='texttt'>move_iterator</span> non-member functions <a class='abbr_ref' href='move.iter.nonmember.html'>[move.iter.nonmember]</a></h4><p ><span class='indexparent'><a class='index' id='operator-,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator-'></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires SizedSentinel&lt;I1, I2&gt;()
  difference_type_t&lt;I2&gt; operator-(
    const move_iterator&lt;I1&gt;&amp; x,
    const move_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.nonmember-1'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.nonmember-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return x.current - y.current;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator+,move_iterator'></a></span><span class='indexparent'><a class='index' id='move_iterator,operator+'></a></span><code class='itemdecl'>
template &lt;RandomAccessIterator I&gt;
  move_iterator&lt;I&gt;
    operator+(
      difference_type_t&lt;I&gt; n,
      const move_iterator&lt;I&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.nonmember-2'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.nonmember-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return x + n;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='make_move_iterator'></a></span><code class='itemdecl'>
template &lt;InputIterator I&gt;
  move_iterator&lt;I&gt; make_move_iterator(I i);
</code></p><div class='itemdescr'></div><div class='para' id='move.iter.nonmember-3'><div class='marginalizedparent'><a class='marginalized' href='#move.iter.nonmember-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>move_iterator&lt;I&gt;(i)</span>.
</p></div></div></div></div><div id='move.sentinel'><h4 ><a class='secnum' href='#move.sentinel' style='min-width:118pt'>9.7.3.3</a> Class template <span class='texttt'>move_sentinel</span> <a class='abbr_ref' href='move.sentinel.html'>[move.sentinel]</a></h4><div class='para' id='move.sentinel-1'><div class='marginalizedparent'><a class='marginalized' href='#move.sentinel-1'>1</a></div><p >Class template <span class='texttt'>move_sentinel</span> is a sentinel adaptor useful for denoting
ranges together with <span class='texttt'>move_iterator</span>. When an input iterator type
<span class='texttt'>I</span> and sentinel type <span class='texttt'>S</span> satisfy <span class='texttt'>Sentinel&lt;S, I&gt;()</span>,
<span class='texttt'>Sentinel&lt;move_sentinel&lt;S&gt;, move_iterator&lt;I&gt;&gt;()</span> is satisfied as well.</p></div><div class='para' id='move.sentinel-2'><div class='marginalizedparent'><a class='marginalized' href='#move.sentinel-2'>2</a></div><p >[&nbsp;<i>Example:</i> A <span class='texttt'>move_if</span> algorithm is easily implemented with
<span class='texttt'>copy_if</span> using <span class='texttt'>move_iterator</span> and <span class='texttt'>move_sentinel</span>:</p><pre class='codeblock'>
template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O,
          IndirectPredicate&lt;I&gt; Pred&gt;
  requires IndirectlyMovable&lt;I, O&gt;()
void move_if(I first, S last, O out, Pred pred){
  copy_if(move_iterator&lt;I&gt;{first}, move_sentinel&lt;S&gt;{last}, out, pred);
}
</pre><p ><i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p><p ><span class='indexparent'><a class='index' id='move_sentinel'></a></span></p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;Semiregular S&gt;
  class move_sentinel {
  public:
    constexpr move_sentinel();
    explicit move_sentinel(S s);
    move_sentinel(const move_sentinel&lt;ConvertibleTo&lt;S&gt;&gt;&amp; s);
    move_sentinel&amp; operator=(const move_sentinel&lt;ConvertibleTo&lt;S&gt;&gt;&amp; s);

    S base() const;

  private:
    S last; <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class I, Sentinel&lt;I&gt; S&gt;
    bool operator==(
      const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);
  template &lt;class I, Sentinel&lt;I&gt; S&gt;
    bool operator==(
      const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);
  template &lt;class I, Sentinel&lt;I&gt; S&gt;
    bool operator!=(
      const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);
  template &lt;class I, Sentinel&lt;I&gt; S&gt;
    bool operator!=(
      const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);

  template &lt;class I, SizedSentinel&lt;I&gt; S&gt;
    difference_type_t&lt;I&gt; operator-(
      const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);
  template &lt;class I, SizedSentinel&lt;I&gt; S&gt;
    difference_type_t&lt;I&gt; operator-(
      const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);

  template &lt;Semiregular S&gt;
    move_sentinel&lt;S&gt; make_move_sentinel(S s);
}}}}
</pre></div></div><div id='move.sent.ops'><h4 ><a class='secnum' href='#move.sent.ops' style='min-width:118pt'>9.7.3.4</a> <span class='texttt'>move_sentinel</span> operations <a class='abbr_ref' href='move.sent.ops.html'>[move.sent.ops]</a></h4><div id='move.sent.op.const'><h4 ><a class='secnum' href='#move.sent.op.const' style='min-width:133pt'>9.7.3.4.1</a> <span class='texttt'>move_sentinel</span> constructors <a class='abbr_ref' href='move.sent.op.const.html'>[move.sent.op.const]</a></h4><p ><span class='indexparent'><a class='index' id='move_sentinel,move_sentinel'></a></span><code class='itemdecl'>
constexpr move_sentinel();
</code></p><div class='itemdescr'></div><div class='para' id='move.sent.op.const-1'><div class='marginalizedparent'><a class='marginalized' href='#move.sent.op.const-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>move_sentinel</span>, value-initializing
<span class='texttt'>last</span>. If <span class='texttt'>is_trivially_default_constructible&lt;S&gt;::value</span> is <span class='texttt'>true</span>, then this constructor
is a <span class='texttt'>constexpr</span> constructor.
</p></div></div><p ><span class='indexparent'><a class='index' id='move_sentinel,constructor'></a></span><code class='itemdecl'>
explicit move_sentinel(S s);
</code></p><div class='itemdescr'></div><div class='para' id='move.sent.op.const-2'><div class='marginalizedparent'><a class='marginalized' href='#move.sent.op.const-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>move_sentinel</span>, initializing
<span class='texttt'>last</span> with <span class='texttt'>s</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='move_sentinel,constructor'></a></span><code class='itemdecl'>
move_sentinel(const move_sentinel&lt;ConvertibleTo&lt;S&gt;&gt;&amp; s);
</code></p><div class='itemdescr'></div><div class='para' id='move.sent.op.const-3'><div class='marginalizedparent'><a class='marginalized' href='#move.sent.op.const-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>move_sentinel</span>, initializing
<span class='texttt'>last</span> with <span class='texttt'>s.last</span>.
</p></div></div></div><div id='move.sent.op='><h4 ><a class='secnum' href='#move.sent.op=' style='min-width:133pt'>9.7.3.4.2</a> <span class='texttt'>move_sentinel::operator=</span> <a class='abbr_ref' href='move.sent.op=.html'>[move.sent.op=]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,move_sentinel'></a></span><span class='indexparent'><a class='index' id='move_sentinel,operator='></a></span><code class='itemdecl'>
move_sentinel&amp; operator=(const move_sentinel&lt;ConvertibleTo&lt;S&gt;&gt;&amp; s);
</code></p><div class='itemdescr'></div><div class='para' id='move.sent.op=-1'><div class='marginalizedparent'><a class='marginalized' href='#move.sent.op=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns <span class='texttt'>s.last</span> to <span class='texttt'>last</span>.</p></div></div><div class='para' id='move.sent.op=-2'><div class='marginalizedparent'><a class='marginalized' href='#move.sent.op=-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='move.sent.op.comp'><h4 ><a class='secnum' href='#move.sent.op.comp' style='min-width:133pt'>9.7.3.4.3</a> <span class='texttt'>move_sentinel</span> comparisons <a class='abbr_ref' href='move.sent.op.comp.html'>[move.sent.op.comp]</a></h4><p ><span class='indexparent'><a class='index' id='operator==,move_sentinel'></a></span><span class='indexparent'><a class='index' id='move_sentinel,operator=='></a></span><code class='itemdecl'>
template &lt;class I, Sentinel&lt;I&gt; S&gt;
  bool operator==(
    const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);
template &lt;class I, Sentinel&lt;I&gt; S&gt;
  bool operator==(
    const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);
</code></p><div class='itemdescr'></div><div class='para' id='move.sent.op.comp-1'><div class='marginalizedparent'><a class='marginalized' href='#move.sent.op.comp-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <span class='texttt'>return i.current == s.last;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,move_sentinel'></a></span><span class='indexparent'><a class='index' id='move_sentinel,operator!='></a></span><code class='itemdecl'>
template &lt;class I, Sentinel&lt;I&gt; S&gt;
  bool operator!=(
    const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);
template &lt;class I, Sentinel&lt;I&gt; S&gt;
  bool operator!=(
    const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);
</code></p><div class='itemdescr'></div><div class='para' id='move.sent.op.comp-2'><div class='marginalizedparent'><a class='marginalized' href='#move.sent.op.comp-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <span class='texttt'>return !(i == s);</span>
</p></div></div></div><div id='move.sent.nonmember'><h4 ><a class='secnum' href='#move.sent.nonmember' style='min-width:133pt'>9.7.3.4.4</a> <span class='texttt'>move_sentinel</span> non-member functions <a class='abbr_ref' href='move.sent.nonmember.html'>[move.sent.nonmember]</a></h4><p ><span class='indexparent'><a class='index' id='operator-,move_sentinel'></a></span><span class='indexparent'><a class='index' id='move_sentinel,operator-'></a></span><code class='itemdecl'>
template &lt;class I, SizedSentinel&lt;I&gt; S&gt;
  difference_type_t&lt;I&gt; operator-(
    const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);
</code></p><div class='itemdescr'></div><div class='para' id='move.sent.nonmember-1'><div class='marginalizedparent'><a class='marginalized' href='#move.sent.nonmember-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <span class='texttt'>return s.last - i.current;</span>
</p></div></div><p ><code class='itemdecl'>
template &lt;class I, SizedSentinel&lt;I&gt; S&gt;
  difference_type_t&lt;I&gt; operator-(
    const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);
</code></p><div class='itemdescr'></div><div class='para' id='move.sent.nonmember-2'><div class='marginalizedparent'><a class='marginalized' href='#move.sent.nonmember-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <span class='texttt'>return i.current - s.last;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='make_move_sentinel'></a></span><code class='itemdecl'>
template &lt;Semiregular S&gt;
  move_sentinel&lt;S&gt; make_move_sentinel(S s);
</code></p><div class='itemdescr'></div><div class='para' id='move.sent.nonmember-3'><div class='marginalizedparent'><a class='marginalized' href='#move.sent.nonmember-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>move_sentinel&lt;S&gt;(s)</span>.
</p></div></div></div></div></div><div id='common'><h3 ><a class='secnum' href='#common' style='min-width:103pt'>9.7.4</a> Common iterators <a class='abbr_ref' href='iterators.common.html'>[iterators.common]</a></h3><div class='para' id='common-1'><div class='marginalizedparent'><a class='marginalized' href='#common-1'>1</a></div><p >Class template <span class='texttt'>common_iterator</span> is an iterator/sentinel adaptor that is
capable of representing a non-bounded range of elements (where the types of the
iterator and sentinel differ) as a bounded range (where they are the same). It
does this by holding either an iterator or a sentinel, and implementing the
equality comparison operators appropriately.</p></div><div class='para' id='common-2'><div class='marginalizedparent'><a class='marginalized' href='#common-2'>2</a></div><p >[&nbsp;<i>Note:</i> The <span class='texttt'>common_iterator</span> type is useful for interfacing with legacy
code that expects the begin and end of a range to have the same type.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='common-3'><div class='marginalizedparent'><a class='marginalized' href='#common-3'>3</a></div><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
template &lt;class ForwardIterator&gt;
void fun(ForwardIterator begin, ForwardIterator end);

list&lt;int&gt; s;
<span class='comment'>// populate the list <span class='texttt'>s</span>
</span>using CI =
  common_iterator&lt;counted_iterator&lt;list&lt;int&gt;::iterator&gt;,
                  default_sentinel&gt;;
<span class='comment'>// call <span class='texttt'>fun</span> on a range of 10 ints
</span>fun(CI(make_counted_iterator(s.begin(), 10)),
    CI(default_sentinel()));
</pre><p ><i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p></div><div id='common.iterator'><h4 ><a class='secnum' href='#common.iterator' style='min-width:118pt'>9.7.4.1</a> Class template <span class='texttt'>common_iterator</span> <a class='abbr_ref' href='common.iterator.html'>[common.iterator]</a></h4><p ><span class='indexparent'><a class='index' id='common_iterator'></a></span></p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;Iterator I, Sentinel&lt;I&gt; S&gt;
    requires !Same&lt;I, S&gt;()
  class common_iterator {
  public:
    using difference_type = difference_type_t&lt;I&gt;;

    common_iterator();
    common_iterator(I i);
    common_iterator(S s);
    common_iterator(const common_iterator&lt;ConvertibleTo&lt;I&gt;, ConvertibleTo&lt;S&gt;&gt;&amp; u);
    common_iterator&amp; operator=(const common_iterator&lt;ConvertibleTo&lt;I&gt;, ConvertibleTo&lt;S&gt;&gt;&amp; u);

    ~common_iterator();

    <i><span class='texttt'>see below</span></i> operator*();
    <i><span class='texttt'>see below</span></i> operator*() const;
    <i><span class='texttt'>see below</span></i> operator-&gt;() const requires Readable&lt;I&gt;();

    common_iterator&amp; operator++();
    common_iterator operator++(int);

  private:
    bool is_sentinel; <span class='comment'>// <i>exposition only</i>
</span>    I iter;           <span class='comment'>// <i>exposition only</i>
</span>    S sentinel;       <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;Readable I, class S&gt;
  struct value_type&lt;common_iterator&lt;I, S&gt;&gt; {
    using type = value_type_t&lt;I&gt;;
  };

  template &lt;InputIterator I, class S&gt;
  struct iterator_category&lt;common_iterator&lt;I, S&gt;&gt; {
    using type = input_iterator_tag;
  };

  template &lt;ForwardIterator I, class S&gt;
  struct iterator_category&lt;common_iterator&lt;I, S&gt;&gt; {
    using type = forward_iterator_tag;
  };

  template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
  bool operator==(
    const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
  template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
    requires EqualityComparable&lt;I1, I2&gt;()
  bool operator==(
    const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
  template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
  bool operator!=(
    const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);

  template &lt;class I2, SizedSentinel&lt;I2&gt; I1, SizedSentinel&lt;I2&gt; S1, SizedSentinel&lt;I1&gt; S2&gt;
  difference_type_t&lt;I2&gt; operator-(
    const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
}}}}
</pre><div class='para' id='common.iterator-1'><div class='marginalizedparent'><a class='marginalized' href='#common.iterator-1'>1</a></div><p >[&nbsp;<i>Note:</i> It is unspecified whether <span class='texttt'>common_iterator</span>'s members
<span class='texttt'>iter</span> and <span class='texttt'>sentinel</span> have distinct addresses or not.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='common.iter.ops'><h4 ><a class='secnum' href='#common.iter.ops' style='min-width:118pt'>9.7.4.2</a> <span class='texttt'>common_iterator</span> operations <a class='abbr_ref' href='common.iter.ops.html'>[common.iter.ops]</a></h4><div id='common.iter.op.const'><h4 ><a class='secnum' href='#common.iter.op.const' style='min-width:133pt'>9.7.4.2.1</a> <span class='texttt'>common_iterator</span> constructors <a class='abbr_ref' href='common.iter.op.const.html'>[common.iter.op.const]</a></h4><p ><span class='indexparent'><a class='index' id='common_iterator,common_iterator'></a></span><code class='itemdecl'>
common_iterator();
</code></p><div class='itemdescr'></div><div class='para' id='common.iter.op.const-1'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.const-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>common_iterator</span>, value-initializing <span class='texttt'>is_sentinel</span>
and <span class='texttt'>iter</span>. Iterator operations applied to the resulting iterator have defined
behavior if and only if the corresponding operations are defined on a
value-initialized iterator of type <span class='texttt'>I</span>.</p></div></div><div class='para' id='common.iter.op.const-2'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.const-2'>2</a></div><div class='itemdescr'><p ><i>Remarks:</i> It is unspecified whether any initialization is performed for
<span class='texttt'>sentinel</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='common_iterator,constructor'></a></span><code class='itemdecl'>
common_iterator(I i);
</code></p><div class='itemdescr'></div><div class='para' id='common.iter.op.const-3'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.const-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>common_iterator</span>, initializing
<span class='texttt'>is_sentinel</span> with <span class='texttt'>false</span> and <span class='texttt'>iter</span> with <span class='texttt'>i</span>.</p></div></div><div class='para' id='common.iter.op.const-4'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.const-4'>4</a></div><div class='itemdescr'><p ><i>Remarks:</i> It is unspecified whether any initialization is performed for
<span class='texttt'>sentinel</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='common_iterator,constructor'></a></span><code class='itemdecl'>
common_iterator(S s);
</code></p><div class='itemdescr'></div><div class='para' id='common.iter.op.const-5'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.const-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>common_iterator</span>, initializing
<span class='texttt'>is_sentinel</span> with <span class='texttt'>true</span> and <span class='texttt'>sentinel</span> with <span class='texttt'>s</span>.</p></div></div><div class='para' id='common.iter.op.const-6'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.const-6'>6</a></div><div class='itemdescr'><p ><i>Remarks:</i> It is unspecified whether any initialization is performed for
<span class='texttt'>iter</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='common_iterator,constructor'></a></span><code class='itemdecl'>
common_iterator(const common_iterator&lt;ConvertibleTo&lt;I&gt;, ConvertibleTo&lt;S&gt;&gt;&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='common.iter.op.const-7'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.const-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>common_iterator</span>, initializing
<span class='texttt'>is_sentinel</span> with <span class='texttt'>u.is_sentinel</span>.
</p><ul class='itemize'><li id='common.iter.op.const-7.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common.iter.op.const-7.1'>(7.1)</a></div><p >If <span class='texttt'>u.is_sentinel</span> is <span class='texttt'>true</span>, <span class='texttt'>sentinel</span> is initialized with <span class='texttt'>u.sentinel</span>.
</p></li><li id='common.iter.op.const-7.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common.iter.op.const-7.2'>(7.2)</a></div><p >If <span class='texttt'>u.is_sentinel</span> is <span class='texttt'>false</span>, <span class='texttt'>iter</span> is initialized with <span class='texttt'>u.iter</span>.
</p></li></ul></div></div><div class='para' id='common.iter.op.const-8'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.const-8'>8</a></div><div class='itemdescr'><p ><i>Remarks:</i>
</p><ul class='itemize'><li id='common.iter.op.const-8.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common.iter.op.const-8.1'>(8.1)</a></div><p >If <span class='texttt'>u.is_sentinel</span> is <span class='texttt'>true</span>, it is unspecified whether any initialization
is performed for <span class='texttt'>iter</span>.
</p></li><li id='common.iter.op.const-8.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common.iter.op.const-8.2'>(8.2)</a></div><p >If <span class='texttt'>u.is_sentinel</span> is <span class='texttt'>false</span>, it is unspecified whether any initialization
is performed for <span class='texttt'>sentinel</span>.
</p></li></ul></div></div></div><div id='common.iter.op='><h4 ><a class='secnum' href='#common.iter.op=' style='min-width:133pt'>9.7.4.2.2</a> <span class='texttt'>common_iterator::operator=</span> <a class='abbr_ref' href='common.iter.op=.html'>[common.iter.op=]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,common_iterator'></a></span><span class='indexparent'><a class='index' id='common_iterator,operator='></a></span><code class='itemdecl'>
common_iterator&amp; operator=(const common_iterator&lt;ConvertibleTo&lt;I&gt;, ConvertibleTo&lt;S&gt;&gt;&amp; u);
</code></p><div class='itemdescr'></div><div class='para' id='common.iter.op=-1'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns <span class='texttt'>u.is_sentinel</span> to <span class='texttt'>is_sentinel</span>.
</p><ul class='itemize'><li id='common.iter.op=-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common.iter.op=-1.1'>(1.1)</a></div><p >If <span class='texttt'>u.is_sentinel</span> is <span class='texttt'>true</span>, assigns <span class='texttt'>u.sentinel</span> to <span class='texttt'>sentinel</span>.
</p></li><li id='common.iter.op=-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common.iter.op=-1.2'>(1.2)</a></div><p >If <span class='texttt'>u.is_sentinel</span> is <span class='texttt'>false</span>, assigns <span class='texttt'>u.iter</span> to <span class='texttt'>iter</span>.
</p></li></ul><p ><i>Remarks:</i>
</p><ul class='itemize'><li id='common.iter.op=-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common.iter.op=-1.3'>(1.3)</a></div><p >If <span class='texttt'>u.is_sentinel</span> is <span class='texttt'>true</span>, it is unspecified whether any operation
is performed on <span class='texttt'>iter</span>.
</p></li><li id='common.iter.op=-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common.iter.op=-1.4'>(1.4)</a></div><p >If <span class='texttt'>u.is_sentinel</span> is <span class='texttt'>false</span>, it is unspecified whether any operation
is performed on <span class='texttt'>sentinel</span>.
</p></li></ul></div></div><div class='para' id='common.iter.op=-2'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op=-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='common_iterator,destructor'></a></span><code class='itemdecl'>
~common_iterator();
</code></p><div class='itemdescr'></div><div class='para' id='common.iter.op=-3'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op=-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Destroys all members that are currently initialized.
</p></div></div></div><div id='common.iter.op.star'><h4 ><a class='secnum' href='#common.iter.op.star' style='min-width:133pt'>9.7.4.2.3</a> <span class='texttt'>common_iterator::operator*</span> <a class='abbr_ref' href='common.iter.op.star.html'>[common.iter.op.star]</a></h4><p ><span class='indexparent'><a class='index' id='operator*,common_iterator'></a></span><span class='indexparent'><a class='index' id='common_iterator,operator*'></a></span><code class='itemdecl'>
decltype(auto) operator*();
decltype(auto) operator*() const;
</code></p><div class='itemdescr'></div><div class='para' id='common.iter.op.star-1'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.star-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>!is_sentinel</span></p></div></div><div class='para' id='common.iter.op.star-2'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.star-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <span class='texttt'>return *iter;</span>
</p></div></div></div><div id='common.iter.op.ref'><h4 ><a class='secnum' href='#common.iter.op.ref' style='min-width:133pt'>9.7.4.2.4</a> <span class='texttt'>common_iterator::operator-&gt;</span> <a class='abbr_ref' href='common.iter.op.ref.html'>[common.iter.op.ref]</a></h4><p ><span class='indexparent'><a class='index' id='operator->,common_iterator'></a></span><span class='indexparent'><a class='index' id='common_iterator,operator->'></a></span><code class='itemdecl'>
<i><span class='texttt'>see below</span></i> operator-&gt;() const requires Readable&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='common.iter.op.ref-1'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.ref-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>!is_sentinel</span></p></div></div><div class='para' id='common.iter.op.ref-2'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.ref-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Given an object <span class='texttt'>i</span> of type <span class='texttt'>I</span>
</p><ul class='itemize'><li id='common.iter.op.ref-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common.iter.op.ref-2.1'>(2.1)</a></div><p >if <span class='texttt'>I</span> is a pointer type or if the expression
      <span class='texttt'>i.operator-&gt;()</span> is well-formed, this function returns
      <span class='texttt'>iter</span>.
</p></li><li id='common.iter.op.ref-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common.iter.op.ref-2.2'>(2.2)</a></div><p >Otherwise, if the expression <span class='texttt'>*iter</span> is a glvalue, this function
      is equivalent to <span class='texttt'>return addressof(*iter);</span>
</p></li><li id='common.iter.op.ref-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#common.iter.op.ref-2.3'>(2.3)</a></div><p >Otherwise, this function returns a proxy object of an unspecified type
      equivalent to the following:
      </p><pre class='codeblock'>
      class proxy {               <span class='comment'>// <i>exposition only</i>
</span>        value_type_t&lt;I&gt; keep_;
        proxy(reference_t&lt;I&gt;&amp;&amp; x)
          : keep_(std::move(x)) {}
      public:
        const value_type_t&lt;I&gt;* operator-&gt;() const {
          return addressof(keep_);
        }
      };
      </pre><p >that is initialized with <span class='texttt'>*iter</span>.
</p></li></ul></div></div></div><div id='common.iter.op.incr'><h4 ><a class='secnum' href='#common.iter.op.incr' style='min-width:133pt'>9.7.4.2.5</a> <span class='texttt'>common_iterator::operator++</span> <a class='abbr_ref' href='common.iter.op.incr.html'>[common.iter.op.incr]</a></h4><p ><span class='indexparent'><a class='index' id='operator++,common_iterator'></a></span><span class='indexparent'><a class='index' id='common_iterator,operator++'></a></span><code class='itemdecl'>
common_iterator&amp; operator++();
</code></p><div class='itemdescr'></div><div class='para' id='common.iter.op.incr-1'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.incr-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>!is_sentinel</span></p></div></div><div class='para' id='common.iter.op.incr-2'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.incr-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> <span class='texttt'>++iter</span>.</p></div></div><div class='para' id='common.iter.op.incr-3'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.incr-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,common_iterator'></a></span><span class='indexparent'><a class='index' id='common_iterator,operator++'></a></span><code class='itemdecl'>
common_iterator operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='common.iter.op.incr-4'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.incr-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>!is_sentinel</span></p></div></div><div class='para' id='common.iter.op.incr-5'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.incr-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
common_iterator tmp = *this;
++iter;
return tmp;
</pre></div></div></div><div id='common.iter.op.comp'><h4 ><a class='secnum' href='#common.iter.op.comp' style='min-width:133pt'>9.7.4.2.6</a> <span class='texttt'>common_iterator</span> comparisons <a class='abbr_ref' href='common.iter.op.comp.html'>[common.iter.op.comp]</a></h4><p ><span class='indexparent'><a class='index' id='operator==,common_iterator'></a></span><span class='indexparent'><a class='index' id='common_iterator,operator=='></a></span><code class='itemdecl'>
template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
bool operator==(
  const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='common.iter.op.comp-1'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.comp-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
  return x.is_sentinel ?
    (y.is_sentinel || y.iter == x.sentinel) :
    (!y.is_sentinel || x.iter == y.sentinel);
</pre></div></div><p ><span class='indexparent'><a class='index' id='operator==,common_iterator'></a></span><span class='indexparent'><a class='index' id='common_iterator,operator=='></a></span><code class='itemdecl'>
template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
  requires EqualityComparable&lt;I1, I2&gt;()
bool operator==(
  const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='common.iter.op.comp-2'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.comp-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
  return x.is_sentinel ?
    (y.is_sentinel || y.iter == x.sentinel) :
    (y.is_sentinel ?
        x.iter == y.sentinel :
        x.iter == y.iter);
</pre></div></div><p ><span class='indexparent'><a class='index' id='operator!=,common_iterator'></a></span><span class='indexparent'><a class='index' id='common_iterator,operator!='></a></span><code class='itemdecl'>
template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
bool operator!=(
  const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='common.iter.op.comp-3'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.comp-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return !(x == y);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator-,common_iterator'></a></span><span class='indexparent'><a class='index' id='common_iterator,operator-'></a></span><code class='itemdecl'>
template &lt;class I2, SizedSentinel&lt;I2&gt; I1, SizedSentinel&lt;I2&gt; S1, SizedSentinel&lt;I1&gt; S2&gt;
difference_type_t&lt;I2&gt; operator-(
  const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='common.iter.op.comp-4'><div class='marginalizedparent'><a class='marginalized' href='#common.iter.op.comp-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
  return x.is_sentinel ?
    (y.is_sentinel ? 0 : x.sentinel - y.iter) :
    (y.is_sentinel ?
         x.iter - y.sentinel :
         x.iter - y.iter);
</pre></div></div></div></div></div><div id='default.sentinels'><h3 ><a class='secnum' href='#default.sentinels' style='min-width:103pt'>9.7.5</a> Default sentinels <a class='abbr_ref' href='default.sentinels.html'>[default.sentinels]</a></h3><div id='default.sent'><h4 ><a class='secnum' href='#default.sent' style='min-width:118pt'>9.7.5.1</a> Class <span class='texttt'>default_sentinel</span> <a class='abbr_ref' href='default.sent.html'>[default.sent]</a></h4><p ><span class='indexparent'><a class='index' id='default_sentinel'></a></span><code class='itemdecl'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  class default_sentinel { };
}}}}
</code></p><div class='para' id='default.sent-1'><div class='marginalizedparent'><a class='marginalized' href='#default.sent-1'>1</a></div><p >Class <span class='texttt'>default_sentinel</span> is an empty type used to denote the end of a
range. It is intended to be used together with iterator types that know the bound
of their range (e.g., <span class='texttt'>counted_iterator</span> (<a href='counted.iterator.html'>[counted.iterator]</a>)).</p></div></div></div><div id='counted'><h3 ><a class='secnum' href='#counted' style='min-width:103pt'>9.7.6</a> Counted iterators <a class='abbr_ref' href='iterators.counted.html'>[iterators.counted]</a></h3><div id='counted.iterator'><h4 ><a class='secnum' href='#counted.iterator' style='min-width:118pt'>9.7.6.1</a> Class template <span class='texttt'>counted_iterator</span> <a class='abbr_ref' href='counted.iterator.html'>[counted.iterator]</a></h4><div class='para' id='counted.iterator-1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iterator-1'>1</a></div><p >Class template <span class='texttt'>counted_iterator</span> is an iterator adaptor
with the same behavior as the underlying iterator except that it
keeps track of its distance from its starting position. It can be
used together with class <span class='texttt'>default_sentinel</span> in calls to generic
algorithms to operate on a range of <span class='math'><span class='mathalpha'>N</span></span> elements starting at a given
position without needing to know the end position <i>a priori</i>.</p></div><div class='para' id='counted.iterator-2'><div class='marginalizedparent'><a class='marginalized' href='#counted.iterator-2'>2</a></div><p >[&nbsp;<i>Example:</i></p><pre class='codeblock'>
list&lt;string&gt; s;
<span class='comment'>// populate the list <span class='texttt'>s</span> with at least 10 strings
</span>vector&lt;string&gt; v(make_counted_iterator(s.begin(), 10),
                 default_sentinel()); <span class='comment'>// copies 10 strings into <span class='texttt'>v</span>
</span></pre><p ><i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p></div><div class='para' id='counted.iterator-3'><div class='marginalizedparent'><a class='marginalized' href='#counted.iterator-3'>3</a></div><p >Two values <span class='texttt'>i1</span> and <span class='texttt'>i2</span> of (possibly differing) types
<span class='texttt'>counted_iterator&lt;I1&gt;</span> and <span class='texttt'>counted_iterator&lt;I2&gt;</span> refer to
elements of the same sequence if and only if <span class='texttt'>next(i1.base(), i1.count())</span>
and <span class='texttt'>next(i2.base(), i2.count())</span> refer to the same (possibly past-the-end) element.</p><p ><span class='indexparent'><a class='index' id='counted_iterator'></a></span></p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;Iterator I&gt;
  class counted_iterator {
  public:
    using iterator_type = I;
    using difference_type = difference_type_t&lt;I&gt;;

    counted_iterator();
    counted_iterator(I x, difference_type_t&lt;I&gt; n);
    counted_iterator(const counted_iterator&lt;ConvertibleTo&lt;I&gt;&gt;&amp; i);
    counted_iterator&amp; operator=(const counted_iterator&lt;ConvertibleTo&lt;I&gt;&gt;&amp; i);

    I base() const;
    difference_type_t&lt;I&gt; count() const;
    <i><span class='texttt'>see below</span></i> operator*();
    <i><span class='texttt'>see below</span></i> operator*() const;

    counted_iterator&amp; operator++();
    counted_iterator operator++(int);
    counted_iterator&amp; operator--()
      requires BidirectionalIterator&lt;I&gt;();
    counted_iterator operator--(int)
      requires BidirectionalIterator&lt;I&gt;();

    counted_iterator  operator+ (difference_type n) const
      requires RandomAccessIterator&lt;I&gt;();
    counted_iterator&amp; operator+=(difference_type n)
      requires RandomAccessIterator&lt;I&gt;();
    counted_iterator  operator- (difference_type n) const
      requires RandomAccessIterator&lt;I&gt;();
    counted_iterator&amp; operator-=(difference_type n)
      requires RandomAccessIterator&lt;I&gt;();
    <i><span class='texttt'>see below</span></i> operator[](difference_type n) const
      requires RandomAccessIterator&lt;I&gt;();
  private:
    I current; <span class='comment'>// <i>exposition only</i>
</span>    difference_type_t&lt;I&gt; cnt; <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;Readable I&gt;
  struct value_type&lt;counted_iterator&lt;I&gt;&gt; {
    using type = value_type_t&lt;I&gt;;
  };

  template &lt;InputIterator I&gt;
  struct iterator_category&lt;counted_iterator&lt;I&gt;&gt; {
    using type = iterator_category_t&lt;I&gt;;
  };

  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
    bool operator==(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
    bool operator==(
      const counted_iterator&lt;auto&gt;&amp; x, default_sentinel);
    bool operator==(
      default_sentinel, const counted_iterator&lt;auto&gt;&amp; x);

  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
    bool operator!=(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
    bool operator!=(
      const counted_iterator&lt;auto&gt;&amp; x, default_sentinel y);
    bool operator!=(
      default_sentinel x, const counted_iterator&lt;auto&gt;&amp; y);

  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
    bool operator&lt;(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
    bool operator&lt;=(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
    bool operator&gt;(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
    bool operator&gt;=(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
    difference_type_t&lt;I2&gt; operator-(
      const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  template &lt;class I&gt;
    difference_type_t&lt;I&gt; operator-(
      const counted_iterator&lt;I&gt;&amp; x, default_sentinel y);
  template &lt;class I&gt;
    difference_type_t&lt;I&gt; operator-(
      default_sentinel x, const counted_iterator&lt;I&gt;&amp; y);

  template &lt;RandomAccessIterator I&gt;
    counted_iterator&lt;I&gt;
      operator+(difference_type_t&lt;I&gt; n, const counted_iterator&lt;I&gt;&amp; x);

  template &lt;Iterator I&gt;
    counted_iterator&lt;I&gt; make_counted_iterator(I i, difference_type_t&lt;I&gt; n);

  template &lt;Iterator I&gt;
    void advance(counted_iterator&lt;I&gt;&amp; i, difference_type_t&lt;I&gt; n);
}}}}
</pre></div></div><div id='counted.iter.ops'><h4 ><a class='secnum' href='#counted.iter.ops' style='min-width:118pt'>9.7.6.2</a> <span class='texttt'>counted_iterator</span> operations <a class='abbr_ref' href='counted.iter.ops.html'>[counted.iter.ops]</a></h4><div id='counted.iter.op.const'><h4 ><a class='secnum' href='#counted.iter.op.const' style='min-width:133pt'>9.7.6.2.1</a> <span class='texttt'>counted_iterator</span> constructors <a class='abbr_ref' href='counted.iter.op.const.html'>[counted.iter.op.const]</a></h4><p ><span class='indexparent'><a class='index' id='counted_iterator,counted_iterator'></a></span><code class='itemdecl'>
counted_iterator();
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.const-1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.const-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>counted_iterator</span>, value-initializing
<span class='texttt'>current</span> and <span class='texttt'>cnt</span>. Iterator operations applied to the
resulting iterator have defined behavior if and only if the corresponding operations
are defined on a value-initialized iterator of type <span class='texttt'>I</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='counted_iterator,constructor'></a></span><code class='itemdecl'>
counted_iterator(I i, difference_type_t&lt;I&gt; n);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.const-2'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.const-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>n &gt;= 0</span></p></div></div><div class='para' id='counted.iter.op.const-3'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.const-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>counted_iterator</span>, initializing
<span class='texttt'>current</span> with <span class='texttt'>i</span> and <span class='texttt'>cnt</span> with <span class='texttt'>n</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='counted_iterator,constructor'></a></span><code class='itemdecl'>
counted_iterator(const counted_iterator&lt;ConvertibleTo&lt;I&gt;&gt;&amp; i);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.const-4'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.const-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>counted_iterator</span>, initializing
<span class='texttt'>current</span> with <span class='texttt'>i.current</span> and <span class='texttt'>cnt</span> with <span class='texttt'>i.cnt</span>.
</p></div></div></div><div id='counted.iter.op='><h4 ><a class='secnum' href='#counted.iter.op=' style='min-width:133pt'>9.7.6.2.2</a> <span class='texttt'>counted_iterator::operator=</span> <a class='abbr_ref' href='counted.iter.op=.html'>[counted.iter.op=]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator='></a></span><code class='itemdecl'>
counted_iterator&amp; operator=(const counted_iterator&lt;ConvertibleTo&lt;I&gt;&gt;&amp; i);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op=-1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Assigns <span class='texttt'>i.current</span> to
<span class='texttt'>current</span> and <span class='texttt'>i.cnt</span> to <span class='texttt'>cnt</span>.</p></div></div></div><div id='counted.iter.op.conv'><h4 ><a class='secnum' href='#counted.iter.op.conv' style='min-width:133pt'>9.7.6.2.3</a> <span class='texttt'>counted_iterator</span> conversion <a class='abbr_ref' href='counted.iter.op.conv.html'>[counted.iter.op.conv]</a></h4><p ><span class='indexparent'><a class='index' id='base,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,base'></a></span><code class='itemdecl'>
I base() const;
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.conv-1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.conv-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>current</span>.
</p></div></div></div><div id='counted.iter.op.cnt'><h4 ><a class='secnum' href='#counted.iter.op.cnt' style='min-width:133pt'>9.7.6.2.4</a> <span class='texttt'>counted_iterator</span> count <a class='abbr_ref' href='counted.iter.op.cnt.html'>[counted.iter.op.cnt]</a></h4><p ><span class='indexparent'><a class='index' id='count,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,count'></a></span><code class='itemdecl'>
difference_type_t&lt;I&gt; count() const;
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.cnt-1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.cnt-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>cnt</span>.
</p></div></div></div><div id='counted.iter.op.star'><h4 ><a class='secnum' href='#counted.iter.op.star' style='min-width:133pt'>9.7.6.2.5</a> <span class='texttt'>counted_iterator::operator*</span> <a class='abbr_ref' href='counted.iter.op.star.html'>[counted.iter.op.star]</a></h4><p ><span class='indexparent'><a class='index' id='operator*,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator*'></a></span><code class='itemdecl'>
decltype(auto) operator*();
decltype(auto) operator*() const;
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.star-1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.star-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return *current;</span>
</p></div></div></div><div id='counted.iter.op.incr'><h4 ><a class='secnum' href='#counted.iter.op.incr' style='min-width:133pt'>9.7.6.2.6</a> <span class='texttt'>counted_iterator::operator++</span> <a class='abbr_ref' href='counted.iter.op.incr.html'>[counted.iter.op.incr]</a></h4><p ><span class='indexparent'><a class='index' id='operator++,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator++'></a></span><code class='itemdecl'>
counted_iterator&amp; operator++();
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.incr-1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.incr-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>cnt &gt; 0</span></p></div></div><div class='para' id='counted.iter.op.incr-2'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.incr-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
++current;
--cnt;
</pre></div></div><div class='para' id='counted.iter.op.incr-3'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.incr-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator++'></a></span><code class='itemdecl'>
counted_iterator operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.incr-4'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.incr-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>cnt &gt; 0</span></p></div></div><div class='para' id='counted.iter.op.incr-5'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.incr-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
counted_iterator tmp = *this;
++current;
--cnt;
return tmp;
</pre></div></div></div><div id='counted.iter.op.decr'><h4 ><a class='secnum' href='#counted.iter.op.decr' style='min-width:133pt'>9.7.6.2.7</a> <span class='texttt'>counted_iterator::operator--</span> <a class='abbr_ref' href='counted.iter.op.decr.html'>[counted.iter.op.decr]</a></h4><p ><span class='indexparent'><a class='index' id='operator--,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator--'></a></span><code class='itemdecl'>
  counted_iterator&amp; operator--();
    requires BidirectionalIterator&lt;I&gt;()
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.decr-1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.decr-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
--current;
++cnt;
</pre></div></div><div class='para' id='counted.iter.op.decr-2'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.decr-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator--,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator--'></a></span><code class='itemdecl'>
  counted_iterator operator--(int)
    requires BidirectionalIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.decr-3'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.decr-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
counted_iterator tmp = *this;
--current;
++cnt;
return tmp;
</pre></div></div></div><div id='counted.iter.op.+'><h4 ><a class='secnum' href='#counted.iter.op.+' style='min-width:133pt'>9.7.6.2.8</a> <span class='texttt'>counted_iterator::operator+</span> <a class='abbr_ref' href='counted.iter.op.+.html'>[counted.iter.op.+]</a></h4><p ><span class='indexparent'><a class='index' id='operator+,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator+'></a></span><code class='itemdecl'>
  counted_iterator operator+(difference_type n) const
    requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.+-1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.+-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>n &lt;= cnt</span></p></div></div><div class='para' id='counted.iter.op.+-2'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.+-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return counted_iterator(current + n, cnt - n);</span>
</p></div></div></div><div id='counted.iter.op.+='><h4 ><a class='secnum' href='#counted.iter.op.+=' style='min-width:133pt'>9.7.6.2.9</a> <span class='texttt'>counted_iterator::operator+=</span> <a class='abbr_ref' href='counted.iter.op.+=.html'>[counted.iter.op.+=]</a></h4><p ><span class='indexparent'><a class='index' id='operator+=,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator+='></a></span><code class='itemdecl'>
  counted_iterator&amp; operator+=(difference_type n)
    requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.+=-1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.+=-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>n &lt;= cnt</span></p></div></div><div class='para' id='counted.iter.op.+=-2'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.+=-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
current += n;
cnt -= n;
</pre></div></div><div class='para' id='counted.iter.op.+=-3'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.+=-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='counted.iter.op.-'><h4 ><a class='secnum' href='#counted.iter.op.-' style='min-width:133pt'>9.7.6.2.10</a> <span class='texttt'>counted_iterator::operator-</span> <a class='abbr_ref' href='counted.iter.op.-.html'>[counted.iter.op.-]</a></h4><p ><span class='indexparent'><a class='index' id='operator-,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator-'></a></span><code class='itemdecl'>
  counted_iterator operator-(difference_type n) const
    requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.--1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.--1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>-n &lt;= cnt</span></p></div></div><div class='para' id='counted.iter.op.--2'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.--2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return counted_iterator(current - n, cnt + n);</span>
</p></div></div></div><div id='counted.iter.op.-='><h4 ><a class='secnum' href='#counted.iter.op.-=' style='min-width:133pt'>9.7.6.2.11</a> <span class='texttt'>counted_iterator::operator-=</span> <a class='abbr_ref' href='counted.iter.op.-=.html'>[counted.iter.op.-=]</a></h4><p ><span class='indexparent'><a class='index' id='operator-=,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator-='></a></span><code class='itemdecl'>
  counted_iterator&amp; operator-=(difference_type n)
    requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.-=-1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.-=-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>-n &lt;= cnt</span></p></div></div><div class='para' id='counted.iter.op.-=-2'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.-=-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
current -= n;
cnt += n;
</pre></div></div><div class='para' id='counted.iter.op.-=-3'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.-=-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>*this</span>.
</p></div></div></div><div id='counted.iter.op.index'><h4 ><a class='secnum' href='#counted.iter.op.index' style='min-width:133pt'>9.7.6.2.12</a> <span class='texttt'>counted_iterator::operator[]</span> <a class='abbr_ref' href='counted.iter.op.index.html'>[counted.iter.op.index]</a></h4><p ><span class='indexparent'><a class='index' id='operator[],counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator[]'></a></span><code class='itemdecl'>
  decltype(auto) operator[](difference_type n) const
    requires RandomAccessIterator&lt;I&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.index-1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.index-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>n &lt;= cnt</span></p></div></div><div class='para' id='counted.iter.op.index-2'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.index-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return current[n];</span>
</p></div></div></div><div id='counted.iter.op.comp'><h4 ><a class='secnum' href='#counted.iter.op.comp' style='min-width:133pt'>9.7.6.2.13</a> <span class='texttt'>counted_iterator</span> comparisons <a class='abbr_ref' href='counted.iter.op.comp.html'>[counted.iter.op.comp]</a></h4><p ><span class='indexparent'><a class='index' id='operator==,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator=='></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires Common&lt;I1, I2&gt;()
  bool operator==(
    const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.comp-1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.comp-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>x</span> and y shall refer to elements of the same
sequence (<a href='iterators.counted.html'>[iterators.counted]</a>).</p></div></div><div class='para' id='counted.iter.op.comp-2'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.comp-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return x.cnt == y.cnt;</span>
</p></div></div><p ><code class='itemdecl'>
  bool operator==(
    const counted_iterator&lt;auto&gt;&amp; x, default_sentinel);
  bool operator==(
    default_sentinel, const counted_iterator&lt;auto&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.comp-3'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.comp-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return x.cnt == 0;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator!='></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires Common&lt;I1, I2&gt;()
  bool operator!=(
    const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
  bool operator!=(
    const counted_iterator&lt;auto&gt;&amp; x, default_sentinel);
  bool operator!=(
    default_sentinel, const counted_iterator&lt;auto&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.comp-4'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.comp-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i> For the first overload, <span class='texttt'>x</span> and y shall refer to
elements of the same sequence (<a href='iterators.counted.html'>[iterators.counted]</a>).</p></div></div><div class='para' id='counted.iter.op.comp-5'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.comp-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return !(x == y);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator<,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator<'></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires Common&lt;I1, I2&gt;()
  bool operator&lt;(
    const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.comp-6'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.comp-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>x</span> and y shall refer to
elements of the same sequence (<a href='iterators.counted.html'>[iterators.counted]</a>).</p></div></div><div class='para' id='counted.iter.op.comp-7'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.comp-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return y.cnt &lt; x.cnt;</span></p></div></div><div class='para' id='counted.iter.op.comp-8'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.comp-8'>8</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The argument order in the <i>Effects</i> element is reversed because <span class='texttt'>cnt</span>
counts down, not up. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><p ><span class='indexparent'><a class='index' id='operator<=,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator<='></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires Common&lt;I1, I2&gt;()
  bool operator&lt;=(
    const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.comp-9'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.comp-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>x</span> and y shall refer to
elements of the same sequence (<a href='iterators.counted.html'>[iterators.counted]</a>).</p></div></div><div class='para' id='counted.iter.op.comp-10'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.comp-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return !(y &lt; x);</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator>'></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires Common&lt;I1, I2&gt;()
  bool operator&gt;(
    const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.comp-11'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.comp-11'>11</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>x</span> and y shall refer to
elements of the same sequence (<a href='iterators.counted.html'>[iterators.counted]</a>).</p></div></div><div class='para' id='counted.iter.op.comp-12'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.comp-12'>12</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return y &lt; x;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator>=,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator>='></a></span><code class='itemdecl'>
template &lt;class I1, class I2&gt;
    requires Common&lt;I1, I2&gt;()
  bool operator&gt;=(
    const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.op.comp-13'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.comp-13'>13</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>x</span> and y shall refer to
elements of the same sequence (<a href='iterators.counted.html'>[iterators.counted]</a>).</p></div></div><div class='para' id='counted.iter.op.comp-14'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.op.comp-14'>14</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return !(x &lt; y);</span>
</p></div></div></div><div id='counted.iter.nonmember'><h4 ><a class='secnum' href='#counted.iter.nonmember' style='min-width:133pt'>9.7.6.2.14</a> <span class='texttt'>counted_iterator</span> non-member functions <a class='abbr_ref' href='counted.iter.nonmember.html'>[counted.iter.nonmember]</a></h4><p ><span class='indexparent'><a class='index' id='operator-,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator-'></a></span><code class='itemdecl'>
  template &lt;class I1, class I2&gt;
      requires Common&lt;I1, I2&gt;()
  difference_type_t&lt;I2&gt; operator-(
    const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.nonmember-1'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.nonmember-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>x</span> and y shall refer to
elements of the same sequence (<a href='iterators.counted.html'>[iterators.counted]</a>).</p></div></div><div class='para' id='counted.iter.nonmember-2'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.nonmember-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return y.cnt - x.cnt;</span>
</p></div></div><p ><code class='itemdecl'>
template &lt;class I&gt;
  difference_type_t&lt;I&gt; operator-(
    const counted_iterator&lt;I&gt;&amp; x, default_sentinel y);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.nonmember-3'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.nonmember-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return -x.cnt;</span>
</p></div></div><p ><code class='itemdecl'>
template &lt;class I&gt;
  difference_type_t&lt;I&gt; operator-(
    default_sentinel x, const counted_iterator&lt;I&gt;&amp; y);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.nonmember-4'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.nonmember-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return y.cnt;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='operator+,counted_iterator'></a></span><span class='indexparent'><a class='index' id='counted_iterator,operator+'></a></span><code class='itemdecl'>
template &lt;RandomAccessIterator I&gt;
  counted_iterator&lt;I&gt;
    operator+(difference_type_t&lt;I&gt; n, const counted_iterator&lt;I&gt;&amp; x);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.nonmember-5'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.nonmember-5'>5</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>n &lt;= x.cnt</span>.</p></div></div><div class='para' id='counted.iter.nonmember-6'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.nonmember-6'>6</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return x + n;</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='make_counted_iterator'></a></span><code class='itemdecl'>
template &lt;Iterator I&gt;
  counted_iterator&lt;I&gt; make_counted_iterator(I i, difference_type_t&lt;I&gt; n);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.nonmember-7'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.nonmember-7'>7</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>n &gt;= 0</span>.</p></div></div><div class='para' id='counted.iter.nonmember-8'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.nonmember-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>counted_iterator&lt;I&gt;(i, n)</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='advance'></a></span><code class='itemdecl'>
template &lt;Iterator I&gt;
  void advance(counted_iterator&lt;I&gt;&amp; i, difference_type_t&lt;I&gt; n);
</code></p><div class='itemdescr'></div><div class='para' id='counted.iter.nonmember-9'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.nonmember-9'>9</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>n &lt;= i.cnt</span>.</p></div></div><div class='para' id='counted.iter.nonmember-10'><div class='marginalizedparent'><a class='marginalized' href='#counted.iter.nonmember-10'>10</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
i = make_counted_iterator(next(i.current, n), i.cnt - n);
</pre></div></div></div></div></div><div id='dangling.wrappers'><h3 ><a class='secnum' href='#dangling.wrappers' style='min-width:103pt'>9.7.7</a> Dangling wrapper <a class='abbr_ref' href='dangling.wrappers.html'>[dangling.wrappers]</a></h3><div id='dangling.wrap'><h4 ><a class='secnum' href='#dangling.wrap' style='min-width:118pt'>9.7.7.1</a> Class template <span class='texttt'>dangling</span> <a class='abbr_ref' href='dangling.wrap.html'>[dangling.wrap]</a></h4><div class='para' id='dangling.wrap-1'><div class='marginalizedparent'><a class='marginalized' href='#dangling.wrap-1'>1</a></div><p ><span class='indexparent'><a class='index' id='dangling'></a></span>Class template <span class='texttt'>dangling</span> is a wrapper for an object that refers to another object whose
lifetime may have ended. It is used by algorithms that accept rvalue ranges and return iterators.</p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;CopyConstructible T&gt;
  class dangling {
  public:
    dangling() requires DefaultConstructible&lt;T&gt;();
    dangling(T t);
    T get_unsafe() const;
  private:
    T value; <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;Range R&gt;
  using safe_iterator_t =
    conditional_t&lt;is_lvalue_reference&lt;R&gt;::value,
      iterator_t&lt;R&gt;,
      dangling&lt;iterator_t&lt;R&gt;&gt;&gt;;
}}}}
</pre></div></div><div id='dangling.wrap.ops'><h4 ><a class='secnum' href='#dangling.wrap.ops' style='min-width:118pt'>9.7.7.2</a> <span class='texttt'>dangling</span> operations <a class='abbr_ref' href='dangling.wrap.ops.html'>[dangling.wrap.ops]</a></h4><div id='dangling.wrap.op.const'><h4 ><a class='secnum' href='#dangling.wrap.op.const' style='min-width:133pt'>9.7.7.2.1</a> <span class='texttt'>dangling</span> constructors <a class='abbr_ref' href='dangling.wrap.op.const.html'>[dangling.wrap.op.const]</a></h4><p ><span class='indexparent'><a class='index' id='dangling,dangling'></a></span><code class='itemdecl'>
dangling() requires DefaultConstructible&lt;T&gt;();
</code></p><div class='itemdescr'></div><div class='para' id='dangling.wrap.op.const-1'><div class='marginalizedparent'><a class='marginalized' href='#dangling.wrap.op.const-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>dangling</span>, value-initializing <span class='texttt'>value</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='dangling,dangling'></a></span><code class='itemdecl'>
dangling(T t);
</code></p><div class='itemdescr'></div><div class='para' id='dangling.wrap.op.const-2'><div class='marginalizedparent'><a class='marginalized' href='#dangling.wrap.op.const-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Constructs a <span class='texttt'>dangling</span>, initializing <span class='texttt'>value</span> with <span class='texttt'>t</span>.
</p></div></div></div><div id='dangling.wrap.op.get'><h4 ><a class='secnum' href='#dangling.wrap.op.get' style='min-width:133pt'>9.7.7.2.2</a> <span class='texttt'>dangling::get_unsafe</span> <a class='abbr_ref' href='dangling.wrap.op.get.html'>[dangling.wrap.op.get]</a></h4><p ><span class='indexparent'><a class='index' id='get_unsafe,dangling'></a></span><span class='indexparent'><a class='index' id='dangling,get_unsafe'></a></span><code class='itemdecl'>
T get_unsafe() const;
</code></p><div class='itemdescr'></div><div class='para' id='dangling.wrap.op.get-1'><div class='marginalizedparent'><a class='marginalized' href='#dangling.wrap.op.get-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>value</span>.
</p></div></div></div></div></div><div id='unreachable.sentinels'><h3 ><a class='secnum' href='#unreachable.sentinels' style='min-width:103pt'>9.7.8</a> Unreachable sentinel <a class='abbr_ref' href='unreachable.sentinels.html'>[unreachable.sentinels]</a></h3><div id='unreachable.sentinel'><h4 ><a class='secnum' href='#unreachable.sentinel' style='min-width:118pt'>9.7.8.1</a> Class <span class='texttt'>unreachable</span> <a class='abbr_ref' href='unreachable.sentinel.html'>[unreachable.sentinel]</a></h4><div class='para' id='unreachable.sentinel-1'><div class='marginalizedparent'><a class='marginalized' href='#unreachable.sentinel-1'>1</a></div><p ><span class='indexparent'><a class='index' id='unreachable'></a></span>Class <span class='texttt'>unreachable</span> is a sentinel type that can be used with any
<span class='texttt'>Iterator</span> to denote an infinite range. Comparing an iterator for equality with
an object of type <span class='texttt'>unreachable</span> always returns <span class='texttt'>false</span>.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
char* p;
<span class='comment'>// set <span class='texttt'>p</span> to point to a character buffer containing newlines
</span>char* nl = find(p, unreachable(), '\n');
</pre><p >Provided a newline character really exists in the buffer, the use of <span class='texttt'>unreachable</span>
above potentially makes the call to <span class='texttt'>find</span> more efficient since the loop test against
the sentinel does not require a conditional branch.
<i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  class unreachable { };

  template &lt;Iterator I&gt;
    constexpr bool operator==(const I&amp;, unreachable) noexcept;
  template &lt;Iterator I&gt;
    constexpr bool operator==(unreachable, const I&amp;) noexcept;
  template &lt;Iterator I&gt;
    constexpr bool operator!=(const I&amp;, unreachable) noexcept;
  template &lt;Iterator I&gt;
    constexpr bool operator!=(unreachable, const I&amp;) noexcept;
}}}}
</pre></div></div><div id='unreachable.sentinel.ops'><h4 ><a class='secnum' href='#unreachable.sentinel.ops' style='min-width:118pt'>9.7.8.2</a> <span class='texttt'>unreachable</span> operations <a class='abbr_ref' href='unreachable.sentinel.ops.html'>[unreachable.sentinel.ops]</a></h4><div id='unreachable.sentinel.op=='><h4 ><a class='secnum' href='#unreachable.sentinel.op==' style='min-width:133pt'>9.7.8.2.1</a> <span class='texttt'>operator==</span> <a class='abbr_ref' href='unreachable.sentinel.op==.html'>[unreachable.sentinel.op==]</a></h4><p ><span class='indexparent'><a class='index' id='operator==,unreachable'></a></span><span class='indexparent'><a class='index' id='unreachable,operator=='></a></span><code class='itemdecl'>
template &lt;Iterator I&gt;
  constexpr bool operator==(const I&amp;, unreachable) noexcept;
template &lt;Iterator I&gt;
  constexpr bool operator==(unreachable, const I&amp;) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unreachable.sentinel.op==-1'><div class='marginalizedparent'><a class='marginalized' href='#unreachable.sentinel.op==-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i> <span class='texttt'>false</span>.
</p></div></div></div><div id='unreachable.sentinel.op!='><h4 ><a class='secnum' href='#unreachable.sentinel.op!=' style='min-width:133pt'>9.7.8.2.2</a> <span class='texttt'>operator!=</span> <a class='abbr_ref' href='unreachable.sentinel.op!=.html'>[unreachable.sentinel.op!=]</a></h4><p ><span class='indexparent'><a class='index' id='operator!=,unreachable'></a></span><span class='indexparent'><a class='index' id='unreachable,operator!='></a></span><code class='itemdecl'>
template &lt;Iterator I&gt;
  constexpr bool operator!=(const I&amp; x, unreachable y) noexcept;
template &lt;Iterator I&gt;
  constexpr bool operator!=(unreachable x, const I&amp; y) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='unreachable.sentinel.op!=-1'><div class='marginalizedparent'><a class='marginalized' href='#unreachable.sentinel.op!=-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>.
</p></div></div></div></div></div></div><div id='stream'><h2 ><a class='secnum' href='#stream' style='min-width:88pt'>9.8</a> Stream iterators <a class='abbr_ref' href='iterators.stream.html'>[iterators.stream]</a></h2><div class='para' id='stream-1'><div class='marginalizedparent'><a class='marginalized' href='#stream-1'>1</a></div><p >To make it possible for algorithmic templates to work directly with input/output streams, appropriate
iterator-like
class templates
are provided.</p><p >[&nbsp;<i>Example:</i>
</p><pre class='codeblock'>
partial_sum(istream_iterator&lt;double, char&gt;(cin),
  istream_iterator&lt;double, char&gt;(),
  ostream_iterator&lt;double, char&gt;(cout, "\n"));
</pre><p >reads a file containing floating point numbers from
<span class='texttt'>cin</span>,
and prints the partial sums onto
<span class='texttt'>cout</span>.
<i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p></div><div id='istream.iterator'><h3 ><a class='secnum' href='#istream.iterator' style='min-width:103pt'>9.8.1</a> Class template <span class='texttt'>istream_iterator</span> <a class='abbr_ref' href='istream.iterator.html'>[istream.iterator]</a></h3><div class='para' id='istream.iterator-1'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator-1'>1</a></div><p ><span class='indexparent'><a class='index' id='istream_iterator'></a></span>The class template
<span class='texttt'>istream_iterator</span>
is an input iterator (<a href='iterators.input.html'>[iterators.input]</a>) that
reads (using
<span class='texttt'>operator&gt;&gt;</span>)
successive elements from the input stream for which it was constructed.
After it is constructed, and every time
<span class='texttt'>++</span>
is used, the iterator reads and stores a value of
<span class='texttt'>T</span>.
If the iterator fails to read and store a value of <span class='texttt'>T</span>
(<span class='texttt'>fail()</span>
on the stream returns
<span class='texttt'>true</span>),
the iterator becomes equal to the
<a class='hidden_link' href='#def:end-of-stream' id='def:end-of-stream'><i>end-of-stream</i></a>
iterator value.
The constructor with no arguments
<span class='texttt'>istream_iterator()</span>
always constructs
an end-of-stream input iterator object, which is the only legitimate iterator to be used
for the end condition.
The result of
<span class='texttt'>operator*</span>
on an end-of-stream iterator is not defined.
For any other iterator value a
<span class='texttt'>const T&amp;</span>
is returned.
The result of
<span class='texttt'>operator-&gt;</span>
on an end-of-stream iterator is not defined.
For any other iterator value a
<span class='texttt'>const T*</span>
is returned.
The behavior of a program that applies <span class='texttt'>operator++()</span> to an end-of-stream
iterator is undefined.
It is impossible to store things into istream iterators.</p></div><div class='para' id='istream.iterator-2'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator-2'>2</a></div><p >Two end-of-stream iterators are always equal.
An end-of-stream iterator is not
equal to a non-end-of-stream iterator.
Two non-end-of-stream iterators are equal when they are constructed from the same stream.</p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;,
      class Distance = ptrdiff_t&gt;
  class istream_iterator {
  public:
    typedef input_iterator_tag iterator_category;
    typedef Distance difference_type;
    typedef T value_type;
    typedef const T&amp; reference;
    typedef const T* pointer;
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_istream&lt;charT, traits&gt; istream_type;
    <i><span class='texttt'>see below</span></i> istream_iterator();
    <i><span class='texttt'>see below</span></i> istream_iterator(default_sentinel);
    istream_iterator(istream_type&amp; s);
    istream_iterator(const istream_iterator&amp; x) = default;
    ~istream_iterator() = default;

    const T&amp; operator*() const;
    const T* operator-&gt;() const;
    istream_iterator&amp; operator++();
    istream_iterator  operator++(int);
  private:
    basic_istream&lt;charT, traits&gt;* in_stream; <span class='comment'>// <i>exposition only</i>
</span>    T value;                                 <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator==(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
            const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator==(default_sentinel x,
            const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator==(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
            default_sentinel y);
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator!=(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
            const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator!=(default_sentinel x,
            const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
  template &lt;class T, class charT, class traits, class Distance&gt;
    bool operator!=(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
            default_sentinel y);
}}}}
</pre></div><div id='istream.iterator.cons'><h4 ><a class='secnum' href='#istream.iterator.cons' style='min-width:118pt'>9.8.1.1</a> <span class='texttt'>istream_iterator</span> constructors and destructor <a class='abbr_ref' href='istream.iterator.cons.html'>[istream.iterator.cons]</a></h4><p ><span class='indexparent'><a class='index' id='istream_iterator,constructor'></a></span><code class='itemdecl'>
<i><span class='texttt'>see below</span></i> istream_iterator();
<i><span class='texttt'>see below</span></i> istream_iterator(default_sentinel);
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs the end-of-stream iterator. If <span class='texttt'>T</span> is a literal type, then these
constructors shall be <span class='texttt'>constexpr</span> constructors.</p></div></div><div class='para' id='istream.iterator.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.cons-2'>2</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>in_stream == nullptr</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='istream_iterator,constructor'></a></span><code class='itemdecl'>
istream_iterator(istream_type&amp; s);
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes <span class='texttt'>in_stream</span> with <span class='texttt'>&amp;s</span>. <span class='texttt'>value</span> may be initialized during
construction or the first time it is referenced.</p></div></div><div class='para' id='istream.iterator.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.cons-4'>4</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>in_stream == &amp;s</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='istream_iterator,constructor'></a></span><code class='itemdecl'>
istream_iterator(const istream_iterator&amp; x) = default;
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a copy of <span class='texttt'>x</span>. If <span class='texttt'>T</span> is a literal type, then this constructor shall be a trivial copy constructor.</p></div></div><div class='para' id='istream.iterator.cons-6'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.cons-6'>6</a></div><div class='itemdescr'><p ><i>Postcondition:</i> <span class='texttt'>in_stream == x.in_stream</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='istream_iterator,destructor'></a></span><code class='itemdecl'>
~istream_iterator() = default;
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.cons-7'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.cons-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
The iterator is destroyed. If <span class='texttt'>T</span> is a literal type, then this destructor shall be a trivial destructor.
</p></div></div></div><div id='istream.iterator.ops'><h4 ><a class='secnum' href='#istream.iterator.ops' style='min-width:118pt'>9.8.1.2</a> <span class='texttt'>istream_iterator</span> operations <a class='abbr_ref' href='istream.iterator.ops.html'>[istream.iterator.ops]</a></h4><p ><span class='indexparent'><a class='index' id='operator*,istream_iterator'></a></span><span class='indexparent'><a class='index' id='istream_iterator,operator*'></a></span><code class='itemdecl'>
const T&amp; operator*() const;
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>value</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator->,istream_iterator'></a></span><span class='indexparent'><a class='index' id='istream_iterator,operator->'></a></span><code class='itemdecl'>
const T* operator-&gt;() const;
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return addressof(operator*())</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,istream_iterator'></a></span><span class='indexparent'><a class='index' id='istream_iterator,operator++'></a></span><code class='itemdecl'>
istream_iterator&amp; operator++();
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-3'>3</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>in_stream != nullptr</span>.</p></div></div><div class='para' id='istream.iterator.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
<span class='texttt'>*in_stream &gt;&gt; value</span>.</p></div></div><div class='para' id='istream.iterator.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,istream_iterator'></a></span><span class='indexparent'><a class='index' id='istream_iterator,operator++'></a></span><code class='itemdecl'>
istream_iterator operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>in_stream != nullptr</span>.</p></div></div><div class='para' id='istream.iterator.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-7'>7</a></div><div class='itemdescr'><p ><i>Effects:</i>
</p><pre class='codeblock'>
istream_iterator tmp = *this;
*in_stream &gt;&gt; value;
return tmp;
</pre></div></div><p ><span class='indexparent'><a class='index' id='operator==,istream_iterator'></a></span><span class='indexparent'><a class='index' id='istream_iterator,operator=='></a></span><code class='itemdecl'>
template &lt;class T, class charT, class traits, class Distance&gt;
  bool operator==(const istream_iterator&lt;T, charT, traits, Distance&gt; &amp;x,
                  const istream_iterator&lt;T, charT, traits, Distance&gt; &amp;y);
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.ops-8'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-8'>8</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>x.in_stream == y.in_stream</span>.<span class='indexparent'><a class='index' id='istream_iterator,operator=='></a></span>
</p></div></div><p ><code class='itemdecl'>
template &lt;class T, class charT, class traits, class Distance&gt;
  bool operator==(default_sentinel x,
                  const istream_iterator&lt;T, charT, traits, Distance&gt; &amp;y);
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.ops-9'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-9'>9</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>nullptr == y.in_stream</span>.</p></div></div><p ><code class='itemdecl'>
template &lt;class T, class charT, class traits, class Distance&gt;
  bool operator==(const istream_iterator&lt;T, charT, traits, Distance&gt; &amp;x,
                  default_sentinel y);
</code></p><div class='itemdescr'></div><div class='para' id='istream.iterator.ops-10'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-10'>10</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>x.in_stream == nullptr</span>.</p></div></div><p ><span class='indexparent'><a class='index' id='operator!=,istream_iterator'></a></span><span class='indexparent'><a class='index' id='istream_iterator,operator!='></a></span><code class='itemdecl'>
template &lt;class T, class charT, class traits, class Distance&gt;
  bool operator!=(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
                  const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
template &lt;class T, class charT, class traits, class Distance&gt;
  bool operator!=(default_sentinel x,
                  const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
template &lt;class T, class charT, class traits, class Distance&gt;
  bool operator!=(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
                  default_sentinel y);
</code></p><p ><span class='indexparent'><a class='index' id='istream_iterator,operator!='></a></span></p><div class='itemdescr'></div><div class='para' id='istream.iterator.ops-11'><div class='marginalizedparent'><a class='marginalized' href='#istream.iterator.ops-11'>11</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>!(x == y)</span>
</p></div></div></div></div><div id='ostream.iterator'><h3 ><a class='secnum' href='#ostream.iterator' style='min-width:103pt'>9.8.2</a> Class template <span class='texttt'>ostream_iterator</span> <a class='abbr_ref' href='ostream.iterator.html'>[ostream.iterator]</a></h3><div class='para' id='ostream.iterator-1'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator-1'>1</a></div><p ><span class='indexparent'><a class='index' id='ostream_iterator'></a></span><span class='texttt'>ostream_iterator</span>
writes (using
<span class='texttt'>operator&lt;&lt;</span>)
successive elements onto the output stream from which it was constructed.
If it was constructed with
<span class='texttt'>charT*</span>
as a constructor argument, this string, called a
<a class='hidden_link' href='#def:delimiter_string' id='def:delimiter_string'><i>delimiter string</i></a>,
is written to the stream after every
<span class='texttt'>T</span>
is written.
It is not possible to get a value out of the output iterator.
Its only use is as an output iterator in situations like</p><pre class='codeblock'>
while (first != last)
  *result++ = *first++;
</pre></div><div class='para' id='ostream.iterator-2'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator-2'>2</a></div><p ><span class='texttt'>ostream_iterator</span>
is defined as:</p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;&gt;
  class ostream_iterator {
  public:
    typedef ptrdiff_t difference_type;
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_ostream&lt;charT, traits&gt; ostream_type;
    constexpr ostream_iterator() noexcept;
    ostream_iterator(ostream_type&amp; s) noexcept;
    ostream_iterator(ostream_type&amp; s, const charT* delimiter) noexcept;
    ostream_iterator(const ostream_iterator&amp; x) noexcept;
    ~ostream_iterator();
    ostream_iterator&amp; operator=(const T&amp; value);

    ostream_iterator&amp; operator*();
    ostream_iterator&amp; operator++();
    ostream_iterator operator++(int);
  private:
    basic_ostream&lt;charT, traits&gt;* out_stream;  <span class='comment'>// <i>exposition only</i>
</span>    const charT* delim;                        <span class='comment'>// <i>exposition only</i>
</span>  };
}}}}
</pre></div><div id='ostream.iterator.cons.des'><h4 ><a class='secnum' href='#ostream.iterator.cons.des' style='min-width:118pt'>9.8.2.1</a> <span class='texttt'>ostream_iterator</span> constructors and destructor <a class='abbr_ref' href='ostream.iterator.cons.des.html'>[ostream.iterator.cons.des]</a></h4><p ><span class='indexparent'><a class='index' id='ostream_iterator,constructor'></a></span><code class='itemdecl'>
constexpr ostream_iterator() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.cons.des-1'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.cons.des-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes <span class='texttt'>out_stream</span> and <span class='texttt'>delim</span> with <span class='texttt'>nullptr</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ostream_iterator,constructor'></a></span><code class='itemdecl'>
ostream_iterator(ostream_type&amp; s) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.cons.des-2'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.cons.des-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes <span class='texttt'>out_stream</span> with <span class='texttt'>&amp;s</span> and <span class='texttt'>delim</span> with <span class='texttt'>nullptr</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ostream_iterator,constructor'></a></span><code class='itemdecl'>
ostream_iterator(ostream_type&amp; s, const charT* delimiter) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.cons.des-3'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.cons.des-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes <span class='texttt'>out_stream</span> with <span class='texttt'>&amp;s</span> and <span class='texttt'>delim</span> with <span class='texttt'>delimiter</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ostream_iterator,constructor'></a></span><code class='itemdecl'>
ostream_iterator(const ostream_iterator&amp; x) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.cons.des-4'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.cons.des-4'>4</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a copy of <span class='texttt'>x</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ostream_iterator,destructor'></a></span><code class='itemdecl'>
~ostream_iterator();
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.cons.des-5'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.cons.des-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
The iterator is destroyed.
</p></div></div></div><div id='ostream.iterator.ops'><h4 ><a class='secnum' href='#ostream.iterator.ops' style='min-width:118pt'>9.8.2.2</a> <span class='texttt'>ostream_iterator</span> operations <a class='abbr_ref' href='ostream.iterator.ops.html'>[ostream.iterator.ops]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,ostream_iterator'></a></span><span class='indexparent'><a class='index' id='ostream_iterator,operator='></a></span><code class='itemdecl'>
ostream_iterator&amp; operator=(const T&amp; value);
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.ops-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
</p><pre class='codeblock'>
*out_stream &lt;&lt; value;
if(delim != nullptr)
  *out_stream &lt;&lt; delim;
return *this;
</pre></div></div><p ><span class='indexparent'><a class='index' id='operator*,ostream_iterator'></a></span><span class='indexparent'><a class='index' id='ostream_iterator,operator*'></a></span><code class='itemdecl'>
ostream_iterator&amp; operator*();
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.ops-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,ostream_iterator'></a></span><span class='indexparent'><a class='index' id='ostream_iterator,operator++'></a></span><code class='itemdecl'>
ostream_iterator&amp; operator++();
ostream_iterator operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='ostream.iterator.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#ostream.iterator.ops-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div></div></div><div id='istreambuf.iterator'><h3 ><a class='secnum' href='#istreambuf.iterator' style='min-width:103pt'>9.8.3</a> Class template <span class='texttt'>istreambuf_iterator</span> <a class='abbr_ref' href='istreambuf.iterator.html'>[istreambuf.iterator]</a></h3><div class='para' id='istreambuf.iterator-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator-1'>1</a></div><p >The
class template
<span class='texttt'>istreambuf_iterator</span>
defines an input iterator (<a href='iterators.input.html'>[iterators.input]</a>) that
reads successive
<i>characters</i>
from the streambuf for which it was constructed.
<span class='texttt'>operator*</span>
provides access to the current input character, if any.
[&nbsp;<i>Note:</i> <span class='texttt'>operator-&gt;</span> may return a proxy. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
Each time
<span class='texttt'>operator++</span>
is evaluated, the iterator advances to the next input character.
If the end of stream is reached (<span class='texttt'>streambuf_type::sgetc()</span> returns
<span class='texttt'>traits::eof()</span>),
the iterator becomes equal to the
<a class='hidden_link' href='#def:end-of-stream' id='def:end-of-stream'><i>end-of-stream</i></a>
iterator value.
The default constructor
<span class='texttt'>istreambuf_iterator()</span>
and the constructor
<span class='texttt'>istreambuf_iterator(nullptr)</span>
both construct an end-of-stream iterator object suitable for use
as an end-of-range.
All specializations of <span class='texttt'>istreambuf_iterator</span> shall have a trivial copy
constructor, a <span class='texttt'>constexpr</span> default constructor, and a trivial destructor.</p></div><div class='para' id='istreambuf.iterator-2'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator-2'>2</a></div><p >The result of
<span class='texttt'>operator*()</span>
on an end-of-stream iterator is undefined.
<span class='indexparent'><a class='index' id='undefined_behavior'></a></span>For any other iterator value a
<span class='texttt'>char_type</span>
value is returned.
It is impossible to assign a character via an input iterator.</p><p ><span class='indexparent'><a class='index' id='istreambuf_iterator'></a></span>
</p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
  class istreambuf_iterator {
  public:
    typedef input_iterator_tag             iterator_category;
    typedef charT                          value_type;
    typedef typename traits::off_type      difference_type;
    typedef charT                          reference;
    typedef <i><span class='texttt'>unspecified</span></i>                   pointer;
    typedef charT                          char_type;
    typedef traits                         traits_type;
    typedef typename traits::int_type      int_type;
    typedef basic_streambuf&lt;charT, traits&gt; streambuf_type;
    typedef basic_istream&lt;charT, traits&gt;   istream_type;

    class proxy;                           <span class='comment'>// <i>exposition only</i>
</span>
    constexpr istreambuf_iterator() noexcept;
    constexpr istreambuf_iterator(default_sentinel) noexcept;
    istreambuf_iterator(const istreambuf_iterator&amp;) noexcept = default;
    ~istreambuf_iterator() = default;
    istreambuf_iterator(istream_type&amp; s) noexcept;
    istreambuf_iterator(streambuf_type* s) noexcept;
    istreambuf_iterator(const proxy&amp; p) noexcept;
    charT operator*() const;
    pointer operator-&gt;() const;
    istreambuf_iterator&amp; operator++();
    proxy operator++(int);
    bool equal(const istreambuf_iterator&amp; b) const;
  private:
    streambuf_type* sbuf_;                <span class='comment'>// <i>exposition only</i>
</span>  };

  template &lt;class charT, class traits&gt;
    bool operator==(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
            const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
  template &lt;class charT, class traits&gt;
    bool operator==(default_sentinel a,
            const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
  template &lt;class charT, class traits&gt;
    bool operator==(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
            default_sentinel b);
  template &lt;class charT, class traits&gt;
    bool operator!=(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
            const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
  template &lt;class charT, class traits&gt;
    bool operator!=(default_sentinel a,
            const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
  template &lt;class charT, class traits&gt;
    bool operator!=(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
            default_sentinel b);
}}}}
</pre></div><div id='istreambuf.iterator::proxy'><h4 ><a class='secnum' href='#istreambuf.iterator::proxy' style='min-width:118pt'>9.8.3.1</a> Class template <span class='texttt'>istreambuf_iterator::proxy</span> <a class='abbr_ref' href='./istreambuf.iterator::proxy.html'>[istreambuf.iterator::proxy]</a></h4><p ><span class='indexparent'><a class='index' id='proxy,istreambuf_iterator'></a></span></p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
  class istreambuf_iterator&lt;charT, traits&gt;::proxy { <span class='comment'>// <i>exposition only</i>
</span>    charT keep_;
    basic_streambuf&lt;charT, traits&gt;* sbuf_;
    proxy(charT c, basic_streambuf&lt;charT, traits&gt;* sbuf)
      : keep_(c), sbuf_(sbuf) { }
  public:
    charT operator*() { return keep_; }
  };
}}}}
</pre><div class='para' id='istreambuf.iterator::proxy-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::proxy-1'>1</a></div><p >Class
<span class='texttt'>istreambuf_iterator&lt;charT, traits&gt;::proxy</span>
is for exposition only.
An implementation is permitted to provide equivalent functionality without
providing a class with this name.
Class
<span class='texttt'>istreambuf_iterator&lt;charT, traits&gt;::proxy</span>
provides a temporary
placeholder as the return value of the post-increment operator
(<span class='texttt'>operator++</span>).
It keeps the character pointed to by the previous value
of the iterator for some possible future access to get the character.</p></div></div><div id='istreambuf.iterator.cons'><h4 ><a class='secnum' href='#istreambuf.iterator.cons' style='min-width:118pt'>9.8.3.2</a> <span class='texttt'>istreambuf_iterator</span> constructors <a class='abbr_ref' href='istreambuf.iterator.cons.html'>[istreambuf.iterator.cons]</a></h4><p ><span class='indexparent'><a class='index' id='istreambuf_iterator,constructor'></a></span><code class='itemdecl'>
constexpr istreambuf_iterator() noexcept;
constexpr istreambuf_iterator(default_sentinel) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs the end-of-stream iterator.
</p></div></div><p ><span class='indexparent'><a class='index' id='istreambuf_iterator,constructor'></a></span><code class='itemdecl'>
istreambuf_iterator(basic_istream&lt;charT, traits&gt;&amp; s) noexcept;
istreambuf_iterator(basic_streambuf&lt;charT, traits&gt;* s) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator.cons-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs an
<span class='texttt'>istreambuf_iterator&lt;&gt;</span>
that uses the
<span class='texttt'>basic_streambuf&lt;&gt;</span>
object
<span class='texttt'>*(s.rdbuf())</span>,
or
<span class='texttt'>*s</span>,
respectively.
Constructs an end-of-stream iterator if
<span class='texttt'>s.rdbuf()</span>
is null.
</p></div></div><p ><span class='indexparent'><a class='index' id='istreambuf_iterator,constructor'></a></span><code class='itemdecl'>
istreambuf_iterator(const proxy&amp; p) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Constructs a
<span class='texttt'>istreambuf_iterator&lt;&gt;</span>
that uses the
<span class='texttt'>basic_streambuf&lt;&gt;</span>
object pointed to by the
<span class='texttt'>proxy</span>
object's constructor argument <span class='texttt'>p</span>.
</p></div></div></div><div id='istreambuf.iterator::op*'><h4 ><a class='secnum' href='#istreambuf.iterator::op*' style='min-width:118pt'>9.8.3.3</a> <span class='texttt'>istreambuf_iterator::operator*</span> <a class='abbr_ref' href='./istreambuf.iterator::op*.html'>[istreambuf.iterator::op*]</a></h4><p ><span class='indexparent'><a class='index' id='operator*,istreambuf_iterator'></a></span><code class='itemdecl'>
charT operator*() const
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator::op*-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::op*-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
The character obtained via the
<span class='texttt'>streambuf</span>
member
<span class='texttt'>sbuf_-&gt;sgetc()</span>.
</p></div></div></div><div id='istreambuf.iterator::op++'><h4 ><a class='secnum' href='#istreambuf.iterator::op++' style='min-width:118pt'>9.8.3.4</a> <span class='texttt'>istreambuf_iterator::operator++</span> <a class='abbr_ref' href='./istreambuf.iterator::op++.html'>[istreambuf.iterator::op++]</a></h4><p ><span class='indexparent'><a class='index' id='operator++,istreambuf_iterator'></a></span><code class='itemdecl'>
istreambuf_iterator&amp;
    istreambuf_iterator&lt;charT, traits&gt;::operator++();
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator::op++-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::op++-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to
<span class='texttt'>sbuf_-&gt;sbumpc()</span>.</p></div></div><div class='para' id='istreambuf.iterator::op++-2'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::op++-2'>2</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,istreambuf_iterator'></a></span><span class='indexparent'><a class='index' id='istreambuf_iterator,operator++'></a></span><code class='itemdecl'>
proxy istreambuf_iterator&lt;charT, traits&gt;::operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator::op++-3'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::op++-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return proxy(sbuf_-&gt;sbumpc(), sbuf_);</span>
</p></div></div></div><div id='istreambuf.iterator::equal'><h4 ><a class='secnum' href='#istreambuf.iterator::equal' style='min-width:118pt'>9.8.3.5</a> <span class='texttt'>istreambuf_iterator::equal</span> <a class='abbr_ref' href='./istreambuf.iterator::equal.html'>[istreambuf.iterator::equal]</a></h4><p ><span class='indexparent'><a class='index' id='equal,istreambuf_iterator'></a></span><code class='itemdecl'>
bool equal(const istreambuf_iterator&amp; b) const;
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator::equal-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::equal-1'>1</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>
if and only if both iterators are at end-of-stream,
or neither is at end-of-stream, regardless of what
<span class='texttt'>streambuf</span>
object they use.
</p></div></div></div><div id='istreambuf.iterator::op=='><h4 ><a class='secnum' href='#istreambuf.iterator::op==' style='min-width:118pt'>9.8.3.6</a> <span class='texttt'>operator==</span> <a class='abbr_ref' href='./istreambuf.iterator::op==.html'>[istreambuf.iterator::op==]</a></h4><p ><span class='indexparent'><a class='index' id='operator==,istreambuf_iterator'></a></span><code class='itemdecl'>
template &lt;class charT, class traits&gt;
  bool operator==(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
                  const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator::op==-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::op==-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return a.equal(b);</span>
</p></div></div><p ><code class='itemdecl'>
template &lt;class charT, class traits&gt;
  bool operator==(default_sentinel a,
                  const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator::op==-2'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::op==-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return istreambuf_iterator&lt;charT, traits&gt;{}.equal(b);</span>
</p></div></div><p ><code class='itemdecl'>
template &lt;class charT, class traits&gt;
  bool operator==(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
                  default_sentinel b);
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator::op==-3'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::op==-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return a.equal(istreambuf_iterator&lt;charT, traits&gt;{});</span>
</p></div></div></div><div id='istreambuf.iterator::op!='><h4 ><a class='secnum' href='#istreambuf.iterator::op!=' style='min-width:118pt'>9.8.3.7</a> <span class='texttt'>operator!=</span> <a class='abbr_ref' href='./istreambuf.iterator::op!=.html'>[istreambuf.iterator::op!=]</a></h4><p ><span class='indexparent'><a class='index' id='operator!=,istreambuf_iterator'></a></span><code class='itemdecl'>
template &lt;class charT, class traits&gt;
  bool operator!=(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
                  const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
template &lt;class charT, class traits&gt;
  bool operator!=(default_sentinel a,
                  const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
template &lt;class charT, class traits&gt;
  bool operator!=(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
                  default_sentinel b);
</code></p><div class='itemdescr'></div><div class='para' id='istreambuf.iterator::op!=-1'><div class='marginalizedparent'><a class='marginalized' href='#istreambuf.iterator::op!=-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to:
<span class='texttt'>return !(a == b);</span>
</p></div></div></div></div><div id='ostreambuf.iterator'><h3 ><a class='secnum' href='#ostreambuf.iterator' style='min-width:103pt'>9.8.4</a> Class template <span class='texttt'>ostreambuf_iterator</span> <a class='abbr_ref' href='ostreambuf.iterator.html'>[ostreambuf.iterator]</a></h3><p ><span class='indexparent'><a class='index' id='ostreambuf_iterator'></a></span></p><pre class='codeblock'>
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template &lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
  class ostreambuf_iterator {
  public:
    typedef ptrdiff_t                      difference_type;
    typedef charT                          char_type;
    typedef traits                         traits_type;
    typedef basic_streambuf&lt;charT, traits&gt; streambuf_type;
    typedef basic_ostream&lt;charT, traits&gt;   ostream_type;

    constexpr ostreambuf_iterator() noexcept;
    ostreambuf_iterator(ostream_type&amp; s) noexcept;
    ostreambuf_iterator(streambuf_type* s) noexcept;
    ostreambuf_iterator&amp; operator=(charT c);

    ostreambuf_iterator&amp; operator*();
    ostreambuf_iterator&amp; operator++();
    ostreambuf_iterator operator++(int);
    bool failed() const noexcept;

  private:
    streambuf_type* sbuf_;                <span class='comment'>// <i>exposition only</i>
</span>  };
}}}}
</pre><div class='para' id='ostreambuf.iterator-1'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iterator-1'>1</a></div><p >The
class template
<span class='texttt'>ostreambuf_iterator</span>
writes successive
<i>characters</i>
onto the output stream from which it was constructed.
It is not possible to get a character value out of the output iterator.</p></div><div id='ostreambuf.iter.cons'><h4 ><a class='secnum' href='#ostreambuf.iter.cons' style='min-width:118pt'>9.8.4.1</a> <span class='texttt'>ostreambuf_iterator</span> constructors <a class='abbr_ref' href='ostreambuf.iter.cons.html'>[ostreambuf.iter.cons]</a></h4><p ><span class='indexparent'><a class='index' id='ostreambuf_iterator,constructor'></a></span><code class='itemdecl'>
constexpr ostreambuf_iterator() noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.cons-1'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.cons-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes <span class='texttt'>sbuf_</span> with <span class='texttt'>nullptr</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ostreambuf_iterator,constructor'></a></span><code class='itemdecl'>
ostreambuf_iterator(ostream_type&amp; s) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.cons-2'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.cons-2'>2</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>s.rdbuf() != nullptr</span>.
</p></div></div><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.cons-3'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.cons-3'>3</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes <span class='texttt'>sbuf_</span> with <span class='texttt'>s.rdbuf()</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='ostreambuf_iterator,constructor'></a></span><code class='itemdecl'>
ostreambuf_iterator(streambuf_type* s) noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.cons-4'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.cons-4'>4</a></div><div class='itemdescr'><p ><i>Requires:</i>
<span class='texttt'>s != nullptr</span>.</p></div></div><div class='para' id='ostreambuf.iter.cons-5'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.cons-5'>5</a></div><div class='itemdescr'><p ><i>Effects:</i>
Initializes <span class='texttt'>sbuf_</span> with <span class='texttt'>s</span>.
</p></div></div></div><div id='ostreambuf.iter.ops'><h4 ><a class='secnum' href='#ostreambuf.iter.ops' style='min-width:118pt'>9.8.4.2</a> <span class='texttt'>ostreambuf_iterator</span> operations <a class='abbr_ref' href='ostreambuf.iter.ops.html'>[ostreambuf.iter.ops]</a></h4><p ><span class='indexparent'><a class='index' id='operator=,ostreambuf_iterator'></a></span><code class='itemdecl'>
ostreambuf_iterator&amp;
  operator=(charT c);
</code></p><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.ops-1'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.ops-1'>1</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>sbuf_ != nullptr</span>.</p></div></div><div class='para' id='ostreambuf.iter.ops-2'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.ops-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i>
If
<span class='texttt'>failed()</span>
yields
<span class='texttt'>false</span>,
calls
<span class='texttt'>sbuf_-&gt;sputc(c)</span>;
otherwise has no effect.</p></div></div><div class='para' id='ostreambuf.iter.ops-3'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.ops-3'>3</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator*,ostreambuf_iterator'></a></span><code class='itemdecl'>
ostreambuf_iterator&amp; operator*();
</code></p><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.ops-4'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.ops-4'>4</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='operator++,ostreambuf_iterator'></a></span><code class='itemdecl'>
ostreambuf_iterator&amp; operator++();
ostreambuf_iterator operator++(int);
</code></p><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.ops-5'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.ops-5'>5</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>*this</span>.
</p></div></div><p ><span class='indexparent'><a class='index' id='failed,ostreambuf_iterator'></a></span><code class='itemdecl'>
bool failed() const noexcept;
</code></p><div class='itemdescr'></div><div class='para' id='ostreambuf.iter.ops-6'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.ops-6'>6</a></div><div class='itemdescr'><p ><i>Requires:</i> <span class='texttt'>sbuf_ != nullptr</span>.</p></div></div><div class='para' id='ostreambuf.iter.ops-7'><div class='marginalizedparent'><a class='marginalized' href='#ostreambuf.iter.ops-7'>7</a></div><div class='itemdescr'><p ><i>Returns:</i>
<span class='texttt'>true</span>
if in any prior use of member
<span class='texttt'>operator=</span>,
the call to
<span class='texttt'>sbuf_-&gt;sputc()</span>
returned
<span class='texttt'>traits::eof()</span>;
or
<span class='texttt'>false</span>
otherwise.
</p></div></div></div></div></div><div id='ranges'><h2 ><a class='secnum' href='#ranges' style='min-width:88pt'>9.9</a> Range concepts <a class='abbr_ref' href='ranges.html'>[ranges]</a></h2><div id='ranges.general'><h3 ><a class='secnum' href='#ranges.general' style='min-width:103pt'>9.9.1</a> General <a class='abbr_ref' href='ranges.general.html'>[ranges.general]</a></h3><div class='para' id='ranges.general-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.general-1'>1</a></div><p >This subclause describes components for dealing with ranges of elements.</p></div><div class='para' id='ranges.general-2'><div class='marginalizedparent'><a class='marginalized' href='#ranges.general-2'>2</a></div><p >The following subclauses describe
range and view requirements, and
components for
range primitives,
predefined ranges,
and stream ranges,
as summarized in Table <a href='#tab:ranges.lib.summary'>[tab:ranges.lib.summary]</a>.</p><div class='numberedTable' id='tab:ranges.lib.summary'>Table <a href='#tab:ranges.lib.summary'>9</a> â€” Ranges library summary<br><table ><tr class='rowsep'><td colspan='2' class='center'><b>Subclause</b></td><td class='left'>	<b>Header(s)</b>	</td></tr><tr class='capsep'><td class='left'> 


  <a href='ranges.requirements.html'>[ranges.requirements]</a> </td><td class='left'> Requirements      </td><td class='left'> </td></tr><tr class='rowsep'><td class='left'> 
  <a href='iterator.range.html'>[iterator.range]</a>      </td><td class='left'> Range access      </td><td class='left'> <span class='texttt'>&lt;experimental/ranges/iterator&gt;</span> </td></tr><tr ><td class='left'>
  <a href='range.primitives.html'>[range.primitives]</a>    </td><td class='left'> Range primitives  </td><td class='left'> </td></tr></table></div></div></div><div id='ranges.requirements'><h3 ><a class='secnum' href='#ranges.requirements' style='min-width:103pt'>9.9.2</a> Range requirements <a class='abbr_ref' href='ranges.requirements.html'>[ranges.requirements]</a></h3><div id='ranges.requirements.general'><h4 ><a class='secnum' href='#ranges.requirements.general' style='min-width:118pt'>9.9.2.1</a> In general <a class='abbr_ref' href='ranges.requirements.general.html'>[ranges.requirements.general]</a></h4><div class='para' id='ranges.requirements.general-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.requirements.general-1'>1</a></div><p >Ranges are an abstraction of containers that allow a C++ program to
operate on elements of data structures uniformly. It their simplest form, a
range object is one on which one can call <span class='texttt'>begin</span> and
<span class='texttt'>end</span> to get an iterator (<a href='iterators.iterator.html'>[iterators.iterator]</a>) and a
sentinel (<a href='iterators.sentinel.html'>[iterators.sentinel]</a>). To be able to construct
template algorithms and range adaptors that work correctly and efficiently on
different types of sequences, the library formalizes not just the interfaces but
also the semantics and complexity assumptions of ranges.</p></div><div class='para' id='ranges.requirements.general-2'><div class='marginalizedparent'><a class='marginalized' href='#ranges.requirements.general-2'>2</a></div><p >This document defines three fundamental categories of ranges
based on the syntax and semantics supported by each: <i>range</i>,
<i>sized range</i> and <i>view</i>, as shown in
Table <a href='#tab:ranges.relations'>[tab:ranges.relations]</a>.</p><div class='numberedTable' id='tab:ranges.relations'>Table <a href='#tab:ranges.relations'>10</a> â€” Relations among range categories<br><table ><tr class='rowsep'><td class='left'>


  
  <b>Sized Range</b>  </td><td class='left'>               </td><td class='left'>                   </td></tr><tr ><td class='left'>
                        </td><td class='left'> <span class='math'><span class='searrow'></span></span>    </td><td class='left'>                   </td></tr><tr ><td class='left'>
                        </td><td class='left'>               </td><td class='left'>  <b>Range</b>   </td></tr><tr ><td class='left'>
                        </td><td class='left'> <span class='math'><span class='nearrow'></span></span>    </td><td class='left'>                   </td></tr><tr ><td class='left'>
  <b>View</b>         </td><td class='left'>               </td><td class='left'>                   </td></tr></table></div></div><div class='para' id='ranges.requirements.general-3'><div class='marginalizedparent'><a class='marginalized' href='#ranges.requirements.general-3'>3</a></div><p >The <span class='texttt'>Range</span> concept requires only that <span class='texttt'>begin</span> and <span class='texttt'>end</span>
return an iterator and a sentinel. The <span class='texttt'>SizedRange</span> concept refines <span class='texttt'>Range</span>
with the requirement that the number of elements in the range can be determined
in constant time using the <span class='texttt'>size</span> function. The <span class='texttt'>View</span> concept
specifies requirements on an <span class='texttt'>Range</span> type
with constant-time copy and assign operations.</p></div><div class='para' id='ranges.requirements.general-4'><div class='marginalizedparent'><a class='marginalized' href='#ranges.requirements.general-4'>4</a></div><p >In addition to the three fundamental range categories, this document defines
a number of convenience refinements of <span class='texttt'>Range</span> that group together requirements
that appear often in the concepts, algorithms, and range adaptors.
<i>Bounded ranges</i> are ranges for which <span class='texttt'>begin</span> and <span class='texttt'>end</span> return objects of the
same type. <i>Random access ranges</i> are ranges for which
<span class='texttt'>begin</span> returns a type that satisfies
<span class='texttt'>RandomAccessIterator</span> (<a href='iterators.random.access.html'>[iterators.random.access]</a>). The range
categories <i>bidirectional ranges</i>,
<i>forward ranges</i>,
<i>input ranges</i>, and
<i>output ranges</i> are defined similarly.</p></div></div><div id='ranges.range'><h4 ><a class='secnum' href='#ranges.range' style='min-width:118pt'>9.9.2.2</a> Ranges <a class='abbr_ref' href='ranges.range.html'>[ranges.range]</a></h4><div class='para' id='ranges.range-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.range-1'>1</a></div><p >The <span class='texttt'>Range</span> concept defines the requirements of a type that allows
iteration over its elements by providing a <span class='texttt'>begin</span> iterator and an
<span class='texttt'>end</span> sentinel.
[&nbsp;<i>Note:</i> Most algorithms requiring this concept simply forward to an
<span class='texttt'>Iterator</span>-based algorithm by calling <span class='texttt'>begin</span> and <span class='texttt'>end</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p><p ><code class='itemdecl'>
template &lt;class T&gt;
using iterator_t = decltype(ranges::begin(declval&lt;T&amp;&gt;()));

template &lt;class T&gt;
using sentinel_t = decltype(ranges::end(declval&lt;T&amp;&gt;()));

template &lt;class T&gt;
concept bool Range() {
  return requires(T&amp;&amp; t) {
    ranges::end(t);
  };
}
</code></p></div><div class='itemdescr'></div><div class='para' id='ranges.range-2'><div class='marginalizedparent'><a class='marginalized' href='#ranges.range-2'>2</a></div><div class='itemdescr'><p >Given an lvalue <span class='texttt'>t</span> of type <span class='texttt'>remove_reference_t&lt;T&gt;</span>, <span class='texttt'>Range&lt;T&gt;()</span> is satisfied
if and only if</p><ul class='itemize'><li id='ranges.range-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.range-2.1'>(2.1)</a></div><p ><span class='texttt'>[begin(t),end(t))</span> denotes a range.</p></li><li id='ranges.range-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.range-2.2'>(2.2)</a></div><p >Both <span class='texttt'>begin(t)</span> and <span class='texttt'>end(t)</span> are amortized constant time
and non-modifying. [&nbsp;<i>Note:</i> <span class='texttt'>begin(t)</span> and <span class='texttt'>end(t)</span> do not require
implicit expression variants. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></li><li id='ranges.range-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.range-2.3'>(2.3)</a></div><p >If <span class='texttt'>iterator_t&lt;T&gt;</span> satisfies <span class='texttt'>ForwardIterator</span>,
<span class='texttt'>begin(t)</span> is equality preserving.
</p></li></ul></div></div><div class='para' id='ranges.range-3'><div class='marginalizedparent'><a class='marginalized' href='#ranges.range-3'>3</a></div><p >[&nbsp;<i>Note:</i>
Equality preservation of both <span class='texttt'>begin</span> and <span class='texttt'>end</span> enables passing a <span class='texttt'>Range</span>
whose iterator type satisfies <span class='texttt'>ForwardIterator</span>
to multiple algorithms and
making multiple passes over the range by repeated calls to <span class='texttt'>begin</span> and <span class='texttt'>end</span>.
Since <span class='texttt'>begin</span> is not required to be equality preserving when the return type does
not satisfy <span class='texttt'>ForwardIterator</span>, repeated calls might not return equal values or
might not be well-defined; <span class='texttt'>begin</span> should be called at most once for such a range.
<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='ranges.sized'><h4 ><a class='secnum' href='#ranges.sized' style='min-width:118pt'>9.9.2.3</a> Sized ranges <a class='abbr_ref' href='ranges.sized.html'>[ranges.sized]</a></h4><div class='para' id='ranges.sized-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.sized-1'>1</a></div><p >The <span class='texttt'>SizedRange</span> concept specifies the requirements
of a <span class='texttt'>Range</span> type that knows its size in constant time with the
<span class='texttt'>size</span> function.</p><p ><code class='itemdecl'>
template &lt;class&gt;
constexpr bool disable_sized_range = false;

template &lt;class T&gt;
concept bool SizedRange() {
  return Range&lt;T&gt;() &amp;&amp;
    !disable_sized_range&lt;remove_cv_t&lt;remove_reference_t&lt;T&gt;&gt;&gt; &amp;&amp;
    requires(const remove_reference_t&lt;T&gt;&amp; t) {
      { ranges::size(t) } -&gt; ConvertibleTo&lt;difference_type_t&lt;iterator_t&lt;T&gt;&gt;&gt;;
    };
}
</code></p></div><div class='itemdescr'></div><div class='para' id='ranges.sized-2'><div class='marginalizedparent'><a class='marginalized' href='#ranges.sized-2'>2</a></div><div class='itemdescr'><p >Given an lvalue <span class='texttt'>t</span> of type <span class='texttt'>remove_reference_t&lt;T&gt;</span>, <span class='texttt'>SizedRange&lt;T&gt;()</span> is satisfied if and only if:</p><ul class='itemize'><li id='ranges.sized-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.sized-2.1'>(2.1)</a></div><p ><span class='texttt'>size(t)</span> returns the number of elements in <span class='texttt'>t</span>.
</p></li><li id='ranges.sized-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.sized-2.2'>(2.2)</a></div><p >If <span class='texttt'>iterator_t&lt;T&gt;</span> satisfies <span class='texttt'>ForwardIterator</span>,
<span class='texttt'>size(t)</span> is well-defined regardless of the evaluation of
<span class='texttt'>begin(t)</span>. [&nbsp;<i>Note:</i> <span class='texttt'>size(t)</span> is otherwise not required be
well-defined after evaluating <span class='texttt'>begin(t)</span>. For a <span class='texttt'>SizedRange</span>
whose iterator type does not model <span class='texttt'>ForwardIterator</span>, for
example, <span class='texttt'>size(t)</span> might only be well-defined if evaluated before
the first call to <span class='texttt'>begin(t)</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
</p></li></ul></div></div><div class='para' id='ranges.sized-3'><div class='marginalizedparent'><a class='marginalized' href='#ranges.sized-3'>3</a></div><div class='itemdescr'><p >[&nbsp;<i>Note:</i> The <span class='texttt'>disable_sized_range</span> predicate provides a mechanism to enable use
of range types with the library that meet the syntactic requirements but do
not in fact satisfy <span class='texttt'>SizedRange</span>. A program that instantiates a library template
that requires a <span class='texttt'>Range</span> with such a range type <span class='texttt'>R</span> is ill-formed with no
diagnostic required unless
<span class='texttt'>disable_sized_range&lt;remove_cv_t&lt;remove_reference_t&lt;R&gt;&gt;&gt;</span> evaluates
to <span class='texttt'>true</span> (<a href='structure.requirements.html'>[structure.requirements]</a>). <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
</p></div></div></div><div id='ranges.view'><h4 ><a class='secnum' href='#ranges.view' style='min-width:118pt'>9.9.2.4</a> Views <a class='abbr_ref' href='ranges.view.html'>[ranges.view]</a></h4><div class='para' id='ranges.view-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.view-1'>1</a></div><p >The <span class='texttt'>View</span> concept specifies the requirements of a
<span class='texttt'>Range</span> type that has constant time copy, move and assignment operators; that
is, the cost of these operations is not proportional to the number of elements in
the <span class='texttt'>View</span>.</p></div><div class='para' id='ranges.view-2'><div class='marginalizedparent'><a class='marginalized' href='#ranges.view-2'>2</a></div><p >[&nbsp;<i>Example:</i>
Examples of <span class='texttt'>View</span>s are:</p><ul class='itemize'><li id='ranges.view-2.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-2.1'>(2.1)</a></div><p >A <span class='texttt'>Range</span> type that wraps a pair of iterators.</p></li><li id='ranges.view-2.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-2.2'>(2.2)</a></div><p >A <span class='texttt'>Range</span> type that holds its elements by <span class='texttt'>shared_ptr</span>
and shares ownership with all its copies.</p></li><li id='ranges.view-2.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-2.3'>(2.3)</a></div><p >A <span class='texttt'>Range</span> type that generates its elements on demand.
</p></li></ul><p >A container (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> containers <span class='endcsname'></span>) is not a <span class='texttt'>View</span> since copying the
container copies the elements, which cannot be done in constant time.
<i>&nbsp;â€”&nbsp;end example</i>&nbsp;]</p><p ><code class='itemdecl'>
template &lt;class T&gt;
struct enable_view { };

struct view_base { };

<span class='comment'>// <i>exposition only</i>
</span>template &lt;class T&gt;
constexpr bool __view_predicate = <i><span class='texttt'>see below</span></i>;

template &lt;class T&gt;
concept bool View() {
  return Range&lt;T&gt;() &amp;&amp;
    Semiregular&lt;T&gt;() &amp;&amp;
    __view_predicate&lt;T&gt;;
}
</code></p></div><div class='itemdescr'></div><div class='para' id='ranges.view-3'><div class='marginalizedparent'><a class='marginalized' href='#ranges.view-3'>3</a></div><div class='itemdescr'><p >Since the difference between <span class='texttt'>Range</span> and <span class='texttt'>View</span> is largely semantic, the
two are differentiated with the help of the <span class='texttt'>enable_view</span>
trait. Users may specialize <span class='texttt'>enable_view</span>
to derive from <span class='texttt'>true_type</span> or <span class='texttt'>false_type</span>.</p></div></div><div class='para' id='ranges.view-4'><div class='marginalizedparent'><a class='marginalized' href='#ranges.view-4'>4</a></div><div class='itemdescr'><p >For a type <span class='texttt'>T</span>, the value of <span class='texttt'>__view_predicate&lt;T&gt;</span> shall be:
</p><ul class='itemize'><li id='ranges.view-4.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-4.1'>(4.1)</a></div><p >If <span class='texttt'>enable_view&lt;T&gt;</span> has a member type <span class='texttt'>type</span>, <span class='texttt'>enable_view&lt;T&gt;::type::value</span>;
</p></li><li id='ranges.view-4.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-4.2'>(4.2)</a></div><p >Otherwise, if <span class='texttt'>T</span> is derived from <span class='texttt'>view_base</span>, <span class='texttt'>true</span>;
</p></li><li id='ranges.view-4.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-4.3'>(4.3)</a></div><p >Otherwise, if <span class='texttt'>T</span> is an instantiation of class template
<span class='texttt'>initializer_list</span> (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> support.initlist <span class='endcsname'></span>),
<span class='texttt'>set</span> (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> set <span class='endcsname'></span>),
<span class='texttt'>multiset</span> (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> multiset <span class='endcsname'></span>),
<span class='texttt'>unordered_set</span> (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> unord.set <span class='endcsname'></span>), or
<span class='texttt'>unordered_multiset</span> (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> unord.multiset <span class='endcsname'></span>), <span class='texttt'>false</span>;
</p></li><li id='ranges.view-4.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-4.4'>(4.4)</a></div><p >Otherwise, if both <span class='texttt'>T</span> and <span class='texttt'>const T</span> satisfy <span class='texttt'>Range</span> and <span class='texttt'>reference_t</span>
<span class='texttt'>&lt;iterator_t&lt;T&gt;&gt;</span> is not the same type as <span class='texttt'>reference_t</span>
<span class='texttt'>&lt;iterator_t&lt;const T&gt;&gt;</span>,
<span class='texttt'>false</span>; [&nbsp;<i>Note:</i> Deep <span class='texttt'>const</span>-ness implies element ownership, whereas shallow <span class='texttt'>const</span>-ness
implies reference semantics. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
</p></li><li id='ranges.view-4.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#ranges.view-4.5'>(4.5)</a></div><p >Otherwise, <span class='texttt'>true</span>.
</p></li></ul></div></div></div><div id='ranges.bounded'><h4 ><a class='secnum' href='#ranges.bounded' style='min-width:118pt'>9.9.2.5</a> Bounded ranges <a class='abbr_ref' href='ranges.bounded.html'>[ranges.bounded]</a></h4><div class='para' id='ranges.bounded-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.bounded-1'>1</a></div><p >The <span class='texttt'>BoundedRange</span> concept specifies requirements
of an <span class='texttt'>Range</span> type for which <span class='texttt'>begin</span> and <span class='texttt'>end</span> return objects of
the same type. [&nbsp;<i>Note:</i> The standard containers (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> containers <span class='endcsname'></span>)
satisfy <span class='texttt'>BoundedRange</span>.<i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p><pre class='codeblock'>
template &lt;class T&gt;
concept bool BoundedRange() {
  return Range&lt;T&gt;() &amp;&amp; Same&lt;iterator_t&lt;T&gt;, sentinel_t&lt;T&gt;&gt;();
}
</pre></div></div><div id='ranges.input'><h4 ><a class='secnum' href='#ranges.input' style='min-width:118pt'>9.9.2.6</a> Input ranges <a class='abbr_ref' href='ranges.input.html'>[ranges.input]</a></h4><div class='para' id='ranges.input-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.input-1'>1</a></div><p >The <span class='texttt'>InputRange</span> concept specifies requirements of
an <span class='texttt'>Range</span> type for which <span class='texttt'>begin</span> returns a type
that satisfies <span class='texttt'>InputIterator</span> (<a href='iterators.input.html'>[iterators.input]</a>).</p><pre class='codeblock'>
template &lt;class T&gt;
concept bool InputRange() {
  return Range&lt;T&gt;() &amp;&amp; InputIterator&lt;iterator_t&lt;T&gt;&gt;();
}
</pre></div></div><div id='ranges.output'><h4 ><a class='secnum' href='#ranges.output' style='min-width:118pt'>9.9.2.7</a> Output ranges <a class='abbr_ref' href='ranges.output.html'>[ranges.output]</a></h4><div class='para' id='ranges.output-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.output-1'>1</a></div><p >The <span class='texttt'>OutputRange</span> concept specifies requirements of
an <span class='texttt'>Range</span> type for which <span class='texttt'>begin</span> returns a type that satisfies
<span class='texttt'>OutputIterator</span> (<a href='iterators.output.html'>[iterators.output]</a>).</p><pre class='codeblock'>
template &lt;class R, class T&gt;
concept bool OutputRange() {
  return Range&lt;R&gt;() &amp;&amp; OutputIterator&lt;iterator_t&lt;R&gt;, T&gt;();
}
</pre></div></div><div id='ranges.forward'><h4 ><a class='secnum' href='#ranges.forward' style='min-width:118pt'>9.9.2.8</a> Forward ranges <a class='abbr_ref' href='ranges.forward.html'>[ranges.forward]</a></h4><div class='para' id='ranges.forward-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.forward-1'>1</a></div><p >The <span class='texttt'>ForwardRange</span> concept specifies requirements of an
<span class='texttt'>InputRange</span> type for which <span class='texttt'>begin</span> returns a type that satisfies
<span class='texttt'>ForwardIterator</span> (<a href='iterators.forward.html'>[iterators.forward]</a>).</p><pre class='codeblock'>
template &lt;class T&gt;
concept bool ForwardRange() {
  return InputRange&lt;T&gt;() &amp;&amp; ForwardIterator&lt;iterator_t&lt;T&gt;&gt;();
}
</pre></div></div><div id='ranges.bidirectional'><h4 ><a class='secnum' href='#ranges.bidirectional' style='min-width:118pt'>9.9.2.9</a> Bidirectional ranges <a class='abbr_ref' href='ranges.bidirectional.html'>[ranges.bidirectional]</a></h4><div class='para' id='ranges.bidirectional-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.bidirectional-1'>1</a></div><p >The <span class='texttt'>BidirectionalRange</span> concept specifies requirements of a
<span class='texttt'>ForwardRange</span> type for which <span class='texttt'>begin</span> returns a type that satisfies
<span class='texttt'>BidirectionalIterator</span> (<a href='iterators.bidirectional.html'>[iterators.bidirectional]</a>).</p><pre class='codeblock'>
template &lt;class T&gt;
concept bool BidirectionalRange() {
  return ForwardRange&lt;T&gt;() &amp;&amp; BidirectionalIterator&lt;iterator_t&lt;T&gt;&gt;();
}
</pre></div></div><div id='ranges.random.access'><h4 ><a class='secnum' href='#ranges.random.access' style='min-width:118pt'>9.9.2.10</a> Random access ranges <a class='abbr_ref' href='ranges.random.access.html'>[ranges.random.access]</a></h4><div class='para' id='ranges.random.access-1'><div class='marginalizedparent'><a class='marginalized' href='#ranges.random.access-1'>1</a></div><p >The <span class='texttt'>RandomAccessRange</span> concept specifies requirements of a
<span class='texttt'>BidirectionalRange</span> type for which <span class='texttt'>begin</span> returns a type that satisfies
<span class='texttt'>RandomAccessIterator</span> (<a href='iterators.random.access.html'>[iterators.random.access]</a>).</p><pre class='codeblock'>
template &lt;class T&gt;
concept bool RandomAccessRange() {
  return BidirectionalRange&lt;T&gt;() &amp;&amp; RandomAccessIterator&lt;iterator_t&lt;T&gt;&gt;();
}
</pre></div></div></div></div><div id='iterator.range'><h2 ><a class='secnum' href='#iterator.range' style='min-width:88pt'>9.10</a> Range access <a class='abbr_ref' href='iterator.range.html'>[iterator.range]</a></h2><div id='iterator.range.begin'><h3 ><a class='secnum' href='#iterator.range.begin' style='min-width:103pt'>9.10.1</a> <span class='texttt'>begin</span> <a class='abbr_ref' href='iterator.range.begin.html'>[iterator.range.begin]</a></h3><div class='para' id='iterator.range.begin-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.begin-1'>1</a></div><p >The name <span class='texttt'>begin</span> denotes a customization point
 object (<a href='customization.point.object.html'>[customization.point.object]</a>). The effect of the expression
<span class='texttt'>ranges::begin(E)</span> for some expression <span class='texttt'>E</span> is equivalent to:</p><ul class='itemize'><li id='iterator.range.begin-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.begin-1.1'>(1.1)</a></div><p ><span class='texttt'>ranges::begin(static_cast&lt;const T&amp;&gt;(E))</span> if <span class='texttt'>E</span> is an rvalue of
  type <span class='texttt'>T</span>. This usage is deprecated.
  [&nbsp;<i>Note:</i> This deprecated usage exists so that
  <span class='texttt'>ranges::begin(E)</span> behaves similarly to <span class='texttt'>std::begin(E)</span>
  as defined in ISO/IEC 14882 when <span class='texttt'>E</span> is an rvalue. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></li><li id='iterator.range.begin-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.begin-1.2'>(1.2)</a></div><p >Otherwise, <span class='texttt'>(E) + 0</span> if <span class='texttt'>E</span> has array
  type (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> basic.compound <span class='endcsname'></span>).</p></li><li id='iterator.range.begin-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.begin-1.3'>(1.3)</a></div><p >Otherwise, <span class='texttt'>DECAY_COPY((E).begin())</span> if it is a valid expression and its type <span class='texttt'>I</span> meets the
  syntactic requirements of <span class='texttt'>Iterator&lt;I&gt;()</span>. If
  <span class='texttt'>Iterator</span> is not satisfied, the program is ill-formed
  with no diagnostic required.</p></li><li id='iterator.range.begin-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.begin-1.4'>(1.4)</a></div><p >Otherwise, <span class='texttt'>DECAY_COPY(begin(E))</span> if it is a valid expression and its type <span class='texttt'>I</span> meets the
  syntactic requirements of <span class='texttt'>Iterator&lt;I&gt;()</span> with overload
  resolution performed in a context that includes the declaration
  <span class='texttt'>void begin(auto&amp;) = delete;</span> and does not include
  a declaration of <span class='texttt'>ranges::begin</span>. If <span class='texttt'>Iterator</span>
  is not satisfied, the program is ill-formed with no diagnostic
  required.</p></li><li id='iterator.range.begin-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.begin-1.5'>(1.5)</a></div><p >Otherwise, <span class='texttt'>ranges::begin(E)</span> is ill-formed.
</p></li></ul></div><div class='para' id='iterator.range.begin-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.begin-2'>2</a></div><p >[&nbsp;<i>Note:</i> Whenever <span class='texttt'>ranges::begin(E)</span> is a valid expression, its
type satisfies <span class='texttt'>Iterator</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterator.range.end'><h3 ><a class='secnum' href='#iterator.range.end' style='min-width:103pt'>9.10.2</a> <span class='texttt'>end</span> <a class='abbr_ref' href='iterator.range.end.html'>[iterator.range.end]</a></h3><div class='para' id='iterator.range.end-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.end-1'>1</a></div><p >The name <span class='texttt'>end</span> denotes a customization point
object (<a href='customization.point.object.html'>[customization.point.object]</a>). The effect of the expression
<span class='texttt'>ranges::end(E)</span> for some expression <span class='texttt'>E</span> is equivalent to:</p><ul class='itemize'><li id='iterator.range.end-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.end-1.1'>(1.1)</a></div><p ><span class='texttt'>ranges::end(static_cast&lt;const T&amp;&gt;(E))</span> if <span class='texttt'>E</span> is an rvalue of
  type <span class='texttt'>T</span>. This usage is deprecated.
  [&nbsp;<i>Note:</i> This deprecated usage exists so that
  <span class='texttt'>ranges::end(E)</span> behaves similarly to <span class='texttt'>std::end(E)</span>
  as defined in ISO/IEC 14882 when <span class='texttt'>E</span> is an rvalue. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></li><li id='iterator.range.end-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.end-1.2'>(1.2)</a></div><p >Otherwise, <span class='texttt'>(E) + extent&lt;T&gt;::value</span> if <span class='texttt'>E</span> has array
  type (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> basic.compound <span class='endcsname'></span>) <span class='texttt'>T</span>.</p></li><li id='iterator.range.end-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.end-1.3'>(1.3)</a></div><p >Otherwise, <span class='texttt'>DECAY_COPY((E).end())</span> if it is a valid expression and its type <span class='texttt'>S</span> meets the
  syntactic requirements of
  <span class='texttt'>Sentinel&lt;S, decltype(ranges::begin(E))&gt;()</span>. If
  <span class='texttt'>Sentinel</span> is not satisfied, the program is ill-formed with
  no diagnostic required.</p></li><li id='iterator.range.end-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.end-1.4'>(1.4)</a></div><p >Otherwise, <span class='texttt'>DECAY_COPY(end(E))</span> if it is a valid expression and its type <span class='texttt'>S</span> meets the
  syntactic requirements of
  <span class='texttt'>Sentinel&lt;S, decltype(ranges::begin(E))&gt;()</span> with overload
  resolution performed in a context that includes the declaration
  <span class='texttt'>void end(auto&amp;) = delete;</span> and does not include
  a declaration of <span class='texttt'>ranges::end</span>. If <span class='texttt'>Sentinel</span> is not
  satisfied, the program is ill-formed with no diagnostic required.</p></li><li id='iterator.range.end-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.end-1.5'>(1.5)</a></div><p >Otherwise, <span class='texttt'>ranges::end(E)</span> is ill-formed.
</p></li></ul></div><div class='para' id='iterator.range.end-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.end-2'>2</a></div><p >[&nbsp;<i>Note:</i> Whenever <span class='texttt'>ranges::end(E)</span> is a valid expression, the
types of <span class='texttt'>ranges::end(E)</span> and <span class='texttt'>ranges::begin(E)</span> satisfy
<span class='texttt'>Sentinel</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterator.range.cbegin'><h3 ><a class='secnum' href='#iterator.range.cbegin' style='min-width:103pt'>9.10.3</a> <span class='texttt'>cbegin</span> <a class='abbr_ref' href='iterator.range.cbegin.html'>[iterator.range.cbegin]</a></h3><div class='para' id='iterator.range.cbegin-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.cbegin-1'>1</a></div><p >The name <span class='texttt'>cbegin</span> denotes a customization point
object (<a href='customization.point.object.html'>[customization.point.object]</a>). The effect of the expression
<span class='texttt'>ranges::cbegin(E)</span> for some expression <span class='texttt'>E</span> of type <span class='texttt'>T</span>
is equivalent to <span class='texttt'>ranges::begin(static_const&lt;const T&amp;&gt;(E))</span>.</p></div><div class='para' id='iterator.range.cbegin-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.cbegin-2'>2</a></div><p >Use of <span class='texttt'>ranges::cbegin(E)</span> with rvalue <span class='texttt'>E</span> is deprecated.
[&nbsp;<i>Note:</i> This deprecated usage exists so that <span class='texttt'>ranges::cbegin(E)</span>
behaves similarly to <span class='texttt'>std::cbegin(E)</span> as defined in ISO/IEC 14882 when
<span class='texttt'>E</span> is an rvalue. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='iterator.range.cbegin-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.cbegin-3'>3</a></div><p >[&nbsp;<i>Note:</i> Whenever <span class='texttt'>ranges::cbegin(E)</span> is a valid expression, its
type satisfies <span class='texttt'>Iterator</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterator.range.cend'><h3 ><a class='secnum' href='#iterator.range.cend' style='min-width:103pt'>9.10.4</a> <span class='texttt'>cend</span> <a class='abbr_ref' href='iterator.range.cend.html'>[iterator.range.cend]</a></h3><div class='para' id='iterator.range.cend-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.cend-1'>1</a></div><p >The name <span class='texttt'>cend</span> denotes a customization point
object (<a href='customization.point.object.html'>[customization.point.object]</a>). The effect of the expression
<span class='texttt'>ranges::cend(E)</span> for some expression <span class='texttt'>E</span> of type <span class='texttt'>T</span>
is equivalent to <span class='texttt'>ranges::end(static_cast&lt;const T&amp;&gt;(E))</span>.</p></div><div class='para' id='iterator.range.cend-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.cend-2'>2</a></div><p >Use of <span class='texttt'>ranges::cend(E)</span> with rvalue <span class='texttt'>E</span> is deprecated.
[&nbsp;<i>Note:</i> This deprecated usage exists so that <span class='texttt'>ranges::cend(E)</span>
behaves similarly to <span class='texttt'>std::cend(E)</span> as defined in ISO/IEC 14882 when
<span class='texttt'>E</span> is an rvalue. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='iterator.range.cend-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.cend-3'>3</a></div><p >[&nbsp;<i>Note:</i> Whenever <span class='texttt'>ranges::cend(E)</span> is a valid expression, the
types of <span class='texttt'>ranges::cend(E)</span> and <span class='texttt'>ranges::cbegin(E)</span> satisfy
<span class='texttt'>Sentinel</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterator.range.rbegin'><h3 ><a class='secnum' href='#iterator.range.rbegin' style='min-width:103pt'>9.10.5</a> <span class='texttt'>rbegin</span> <a class='abbr_ref' href='iterator.range.rbegin.html'>[iterator.range.rbegin]</a></h3><div class='para' id='iterator.range.rbegin-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.rbegin-1'>1</a></div><p >The name <span class='texttt'>rbegin</span> denotes a customization point
object (<a href='customization.point.object.html'>[customization.point.object]</a>). The effect of the expression
<span class='texttt'>ranges::rbegin(E)</span> for some expression <span class='texttt'>E</span> is equivalent
to:</p><ul class='itemize'><li id='iterator.range.rbegin-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.rbegin-1.1'>(1.1)</a></div><p ><span class='texttt'>ranges::rbegin(static_cast&lt;const T&amp;&gt;(E))</span> if <span class='texttt'>E</span> is an rvalue of
  type <span class='texttt'>T</span>. This usage is deprecated.
  [&nbsp;<i>Note:</i> This deprecated usage exists so that
  <span class='texttt'>ranges::rbegin(E)</span> behaves similarly to <span class='texttt'>std::rbegin(E)</span>
  as defined in ISO/IEC 14882 when <span class='texttt'>E</span> is an rvalue. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></li><li id='iterator.range.rbegin-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.rbegin-1.2'>(1.2)</a></div><p >Otherwise, <span class='texttt'>DECAY_COPY((E).rbegin())</span> if it is a valid expression and its type <span class='texttt'>I</span> meets the
  syntactic requirements of <span class='texttt'>Iterator&lt;I&gt;()</span>. If <span class='texttt'>Iterator</span>
  is not satisfied, the program is ill-formed with no diagnostic
  required.</p></li><li id='iterator.range.rbegin-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.rbegin-1.3'>(1.3)</a></div><p >Otherwise, <span class='texttt'>make_reverse_iterator(ranges::end(E))</span> if both
  <span class='texttt'>ranges::begin(E)</span> and <span class='texttt'>ranges::end(E)</span> are valid expressions of the same
  type <span class='texttt'>I</span> which meets the syntactic requirements of
  <span class='texttt'>BidirectionalIterator&lt;I&gt;()</span> (<a href='iterators.bidirectional.html'>[iterators.bidirectional]</a>).</p></li><li id='iterator.range.rbegin-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.rbegin-1.4'>(1.4)</a></div><p >Otherwise, <span class='texttt'>ranges::rbegin(E)</span> is ill-formed.
</p></li></ul></div><div class='para' id='iterator.range.rbegin-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.rbegin-2'>2</a></div><p >[&nbsp;<i>Note:</i> Whenever <span class='texttt'>ranges::rbegin(E)</span> is a valid expression, its
type satisfies <span class='texttt'>Iterator</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterator.range.rend'><h3 ><a class='secnum' href='#iterator.range.rend' style='min-width:103pt'>9.10.6</a> <span class='texttt'>rend</span> <a class='abbr_ref' href='iterator.range.rend.html'>[iterator.range.rend]</a></h3><div class='para' id='iterator.range.rend-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.rend-1'>1</a></div><p >The name <span class='texttt'>rend</span> denotes a customization point
object (<a href='customization.point.object.html'>[customization.point.object]</a>). The effect of the expression
<span class='texttt'>ranges::rend(E)</span> for some expression <span class='texttt'>E</span> is equivalent to:</p><ul class='itemize'><li id='iterator.range.rend-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.rend-1.1'>(1.1)</a></div><p ><span class='texttt'>ranges::rend(static_cast&lt;const T&amp;&gt;(E))</span> if <span class='texttt'>E</span> is an rvalue of
  type <span class='texttt'>T</span>. This usage is deprecated.
  [&nbsp;<i>Note:</i> This deprecated usage exists so that
  <span class='texttt'>ranges::rend(E)</span> behaves similarly to <span class='texttt'>std::rend(E)</span>
  as defined in ISO/IEC 14882 when <span class='texttt'>E</span> is an rvalue. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></li><li id='iterator.range.rend-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.rend-1.2'>(1.2)</a></div><p >Otherwise, <span class='texttt'>DECAY_COPY((E).rend())</span> if it is a valid expression and its type <span class='texttt'>S</span> meets the
  syntactic requirements of
  <span class='texttt'>Sentinel&lt;S, decltype(ranges::rbegin(E))&gt;()</span>. If
  <span class='texttt'>Sentinel</span> is not satisfied, the program is ill-formed with
  no diagnostic required.</p></li><li id='iterator.range.rend-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.rend-1.3'>(1.3)</a></div><p >Otherwise, <span class='texttt'>make_reverse_iterator(ranges::begin(E))</span> if both
  <span class='texttt'>ranges::begin(E)</span> and <span class='texttt'>ranges::end(E)</span> are valid expressions of the same
  type <span class='texttt'>I</span> which meets the syntactic requirements of
  <span class='texttt'>BidirectionalIterator&lt;I&gt;()</span> (<a href='iterators.bidirectional.html'>[iterators.bidirectional]</a>).</p></li><li id='iterator.range.rend-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#iterator.range.rend-1.4'>(1.4)</a></div><p >Otherwise, <span class='texttt'>ranges::rend(E)</span> is ill-formed.
</p></li></ul></div><div class='para' id='iterator.range.rend-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.rend-2'>2</a></div><p >[&nbsp;<i>Note:</i> Whenever <span class='texttt'>ranges::rend(E)</span> is a valid expression, the
types of <span class='texttt'>ranges::rend(E)</span> and <span class='texttt'>ranges::rbegin(E)</span> satisfy
<span class='texttt'>Sentinel</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterator.range.crbegin'><h3 ><a class='secnum' href='#iterator.range.crbegin' style='min-width:103pt'>9.10.7</a> <span class='texttt'>crbegin</span> <a class='abbr_ref' href='iterator.range.crbegin.html'>[iterator.range.crbegin]</a></h3><div class='para' id='iterator.range.crbegin-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.crbegin-1'>1</a></div><p >The name <span class='texttt'>crbegin</span> denotes a customization point
object (<a href='customization.point.object.html'>[customization.point.object]</a>). The effect of the expression
<span class='texttt'>ranges::crbegin(E)</span> for some expression <span class='texttt'>E</span> of type <span class='texttt'>T</span>
is equivalent to <span class='texttt'>ranges::rbegin(static_cast&lt;const T&amp;&gt;(E))</span>.</p></div><div class='para' id='iterator.range.crbegin-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.crbegin-2'>2</a></div><p >Use of <span class='texttt'>ranges::crbegin(E)</span> with rvalue <span class='texttt'>E</span> is deprecated.
[&nbsp;<i>Note:</i> This deprecated usage exists so that <span class='texttt'>ranges::crbegin(E)</span>
behaves similarly to <span class='texttt'>std::crbegin(E)</span> as defined in ISO/IEC 14882 when
<span class='texttt'>E</span> is an rvalue. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='iterator.range.crbegin-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.crbegin-3'>3</a></div><p >[&nbsp;<i>Note:</i> Whenever <span class='texttt'>ranges::crbegin(E)</span> is a valid expression, its
type satisfies <span class='texttt'>Iterator</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='iterator.range.crend'><h3 ><a class='secnum' href='#iterator.range.crend' style='min-width:103pt'>9.10.8</a> <span class='texttt'>crend</span> <a class='abbr_ref' href='iterator.range.crend.html'>[iterator.range.crend]</a></h3><div class='para' id='iterator.range.crend-1'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.crend-1'>1</a></div><p >The name <span class='texttt'>crend</span> denotes a customization point
object (<a href='customization.point.object.html'>[customization.point.object]</a>). The effect of the expression
<span class='texttt'>ranges::crend(E)</span> for some expression <span class='texttt'>E</span> of type <span class='texttt'>T</span>
is equivalent to <span class='texttt'>ranges::rend(static_cast&lt;const T&amp;&gt;(E))</span>.</p></div><div class='para' id='iterator.range.crend-2'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.crend-2'>2</a></div><p >Use of <span class='texttt'>ranges::crend(E)</span> with rvalue <span class='texttt'>E</span> is deprecated.
[&nbsp;<i>Note:</i> This deprecated usage exists so that <span class='texttt'>ranges::crend(E)</span>
behaves similarly to <span class='texttt'>std::crend(E)</span> as defined in ISO/IEC 14882 when
<span class='texttt'>E</span> is an rvalue. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='iterator.range.crend-3'><div class='marginalizedparent'><a class='marginalized' href='#iterator.range.crend-3'>3</a></div><p >[&nbsp;<i>Note:</i> Whenever <span class='texttt'>ranges::crend(E)</span> is a valid expression, the
types of <span class='texttt'>ranges::crend(E)</span> and <span class='texttt'>ranges::crbegin(E)</span> satisfy
<span class='texttt'>Sentinel</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div></div><div id='range.primitives'><h2 ><a class='secnum' href='#range.primitives' style='min-width:88pt'>9.11</a> Range primitives <a class='abbr_ref' href='range.primitives.html'>[range.primitives]</a></h2><p ><span class='indexparent'><a class='index' id='distance(R&&_r)'></a></span><code class='itemdecl'>
template &lt;Range R&gt;
difference_type_t&lt;iterator_t&lt;R&gt;&gt; distance(R&amp;&amp; r);
</code></p><div class='itemdescr'></div><div class='para' id='range.primitives-1'><div class='marginalizedparent'><a class='marginalized' href='#range.primitives-1'>1</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <span class='texttt'>return ranges::distance(ranges::begin(r), ranges::end(r));</span>
</p></div></div><p ><span class='indexparent'><a class='index' id='distance(R&&_r)'></a></span><code class='itemdecl'>
template &lt;SizedRange R&gt;
difference_type_t&lt;iterator_t&lt;R&gt;&gt; distance(R&amp;&amp; r);
</code></p><div class='itemdescr'></div><div class='para' id='range.primitives-2'><div class='marginalizedparent'><a class='marginalized' href='#range.primitives-2'>2</a></div><div class='itemdescr'><p ><i>Effects:</i> Equivalent to: <span class='texttt'>return ranges::size(r);</span>
</p></div></div><div id='range.primitives.size'><h3 ><a class='secnum' href='#range.primitives.size' style='min-width:103pt'>9.11.1</a> <span class='texttt'>size</span> <a class='abbr_ref' href='range.primitives.size.html'>[range.primitives.size]</a></h3><div class='para' id='range.primitives.size-1'><div class='marginalizedparent'><a class='marginalized' href='#range.primitives.size-1'>1</a></div><p >The name <span class='texttt'>size</span> denotes a customization point
object (<a href='customization.point.object.html'>[customization.point.object]</a>). The effect of the expression
<span class='texttt'>ranges::size(E)</span> for some expression <span class='texttt'>E</span> with type
<span class='texttt'>T</span> is equivalent to:</p><ul class='itemize'><li id='range.primitives.size-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#range.primitives.size-1.1'>(1.1)</a></div><p ><span class='texttt'>extent&lt;T&gt;::value</span> if <span class='texttt'>T</span> is an array
  type (  ISO/IEC 14882:2014 &sect;  <span class='csname'></span> basic.compound <span class='endcsname'></span>).</p></li><li id='range.primitives.size-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#range.primitives.size-1.2'>(1.2)</a></div><p >Otherwise, <span class='texttt'>DECAY_COPY(static_cast&lt;const T&amp;&gt;(E).size())</span> if it is a valid expression and its type <span class='texttt'>I</span>
  satisfies <span class='texttt'>Integral&lt;I&gt;()</span> and
  <span class='texttt'>disable_sized_range&lt;T&gt;</span> (<a href='ranges.sized.html'>[ranges.sized]</a>) is
  <span class='texttt'>false</span>.</p></li><li id='range.primitives.size-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#range.primitives.size-1.3'>(1.3)</a></div><p >Otherwise, <span class='texttt'>DECAY_COPY(size(static_cast&lt;const T&amp;&gt;(E)))</span> if it is a valid expression and its type <span class='texttt'>I</span>
  satisfies <span class='texttt'>Integral&lt;I&gt;()</span> with overload resolution
  performed in a context that includes the declaration
  <span class='texttt'>void size(const auto&amp;) = delete;</span> and does not include
  a declaration of <span class='texttt'>ranges::size</span>, and
  <span class='texttt'>disable_sized_range&lt;T&gt;</span> is <span class='texttt'>false</span>.</p></li><li id='range.primitives.size-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#range.primitives.size-1.4'>(1.4)</a></div><p >Otherwise,
  <span class='texttt'>DECAY_COPY(ranges::cend(E) - ranges::cbegin(E))</span>, except that <span class='texttt'>E</span>
  is only evaluated once, if it is a valid expression and the types <span class='texttt'>I</span> and <span class='texttt'>S</span> of
  <span class='texttt'>ranges::cbegin(E)</span> and <span class='texttt'>ranges::cend(E)</span> meet the
  syntactic requirements of
  <span class='texttt'>SizedSentinel&lt;S, I&gt;()</span> (<a href='iterators.sizedsentinel.html'>[iterators.sizedsentinel]</a>) and
  <span class='texttt'>ForwardIterator&lt;I&gt;()</span>. If <span class='texttt'>SizedSentinel</span> and
  <span class='texttt'>ForwardIterator</span> are not satisfied, the program is ill-formed with no
  diagnostic required.</p></li><li id='range.primitives.size-1.5'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#range.primitives.size-1.5'>(1.5)</a></div><p >Otherwise, <span class='texttt'>ranges::size(E)</span> is ill-formed.
</p></li></ul></div><div class='para' id='range.primitives.size-2'><div class='marginalizedparent'><a class='marginalized' href='#range.primitives.size-2'>2</a></div><p >[&nbsp;<i>Note:</i> Whenever <span class='texttt'>ranges::size(E)</span> is a valid expression, its
type satisfies <span class='texttt'>Integral</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='range.primitives.empty'><h3 ><a class='secnum' href='#range.primitives.empty' style='min-width:103pt'>9.11.2</a> <span class='texttt'>empty</span> <a class='abbr_ref' href='range.primitives.empty.html'>[range.primitives.empty]</a></h3><div class='para' id='range.primitives.empty-1'><div class='marginalizedparent'><a class='marginalized' href='#range.primitives.empty-1'>1</a></div><p >The name <span class='texttt'>empty</span> denotes a customization point
object (<a href='customization.point.object.html'>[customization.point.object]</a>). The effect of the expression
<span class='texttt'>ranges::empty(E)</span> for some expression <span class='texttt'>E</span> is
equivalent to:</p><ul class='itemize'><li id='range.primitives.empty-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#range.primitives.empty-1.1'>(1.1)</a></div><p ><span class='texttt'>bool((E).empty())</span> if it is a valid expression.</p></li><li id='range.primitives.empty-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#range.primitives.empty-1.2'>(1.2)</a></div><p >Otherwise, <span class='texttt'>ranges::size(E) == 0</span> if it is a valid expression.</p></li><li id='range.primitives.empty-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#range.primitives.empty-1.3'>(1.3)</a></div><p >Otherwise, <span class='texttt'>bool(ranges::begin(E) == ranges::end(E))</span>,
  except that <span class='texttt'>E</span> is only evaluated once, if it is a valid expression and the type of
  <span class='texttt'>ranges::begin(E)</span> satisfies <span class='texttt'>ForwardIterator</span>.</p></li><li id='range.primitives.empty-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#range.primitives.empty-1.4'>(1.4)</a></div><p >Otherwise, <span class='texttt'>ranges::empty(E)</span> is ill-formed.
</p></li></ul></div><div class='para' id='range.primitives.empty-2'><div class='marginalizedparent'><a class='marginalized' href='#range.primitives.empty-2'>2</a></div><p >[&nbsp;<i>Note:</i> Whenever <span class='texttt'>ranges::empty(E)</span> is a valid expression, it
has type <span class='texttt'>bool</span>. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='range.primitives.data'><h3 ><a class='secnum' href='#range.primitives.data' style='min-width:103pt'>9.11.3</a> <span class='texttt'>data</span> <a class='abbr_ref' href='range.primitives.data.html'>[range.primitives.data]</a></h3><div class='para' id='range.primitives.data-1'><div class='marginalizedparent'><a class='marginalized' href='#range.primitives.data-1'>1</a></div><p >The name <span class='texttt'>data</span> denotes a customization point
object (<a href='customization.point.object.html'>[customization.point.object]</a>). The effect of the expression
<span class='texttt'>ranges::data(E)</span> for some expression <span class='texttt'>E</span> is
equivalent to:</p><ul class='itemize'><li id='range.primitives.data-1.1'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#range.primitives.data-1.1'>(1.1)</a></div><p ><span class='texttt'>ranges::data(static_cast&lt;const T&amp;&gt;(E))</span> if <span class='texttt'>E</span> is an rvalue of
  type <span class='texttt'>T</span>. This usage is deprecated. [&nbsp;<i>Note:</i>
  This deprecated usage exists so that <span class='texttt'>ranges::data(E)</span> behaves
  similarly to <span class='texttt'>std::data(E)</span> as defined in the C++ Working
  Paper when <span class='texttt'>E</span> is an rvalue. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></li><li id='range.primitives.data-1.2'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#range.primitives.data-1.2'>(1.2)</a></div><p >Otherwise, <span class='texttt'>DECAY_COPY((E).data())</span> if it is a valid expression of pointer to object type.</p></li><li id='range.primitives.data-1.3'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#range.primitives.data-1.3'>(1.3)</a></div><p >Otherwise, <span class='texttt'>ranges::begin(E)</span> if it is a valid expression of pointer to object type.</p></li><li id='range.primitives.data-1.4'><div class='marginalizedparent' style='left:-7em'><a class='marginalized' href='#range.primitives.data-1.4'>(1.4)</a></div><p >Otherwise, <span class='texttt'>ranges::data(E)</span> is ill-formed.
</p></li></ul></div><div class='para' id='range.primitives.data-2'><div class='marginalizedparent'><a class='marginalized' href='#range.primitives.data-2'>2</a></div><p >[&nbsp;<i>Note:</i> Whenever <span class='texttt'>ranges::data(E)</span> is a valid expression, it
has pointer to object type. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div></div><div id='range.primitives.cdata'><h3 ><a class='secnum' href='#range.primitives.cdata' style='min-width:103pt'>9.11.4</a> <span class='texttt'>cdata</span> <a class='abbr_ref' href='range.primitives.cdata.html'>[range.primitives.cdata]</a></h3><div class='para' id='range.primitives.cdata-1'><div class='marginalizedparent'><a class='marginalized' href='#range.primitives.cdata-1'>1</a></div><p >The name <span class='texttt'>cdata</span> denotes a customization point
object (<a href='customization.point.object.html'>[customization.point.object]</a>). The effect of the expression
<span class='texttt'>ranges::cdata(E)</span> for some expression <span class='texttt'>E</span> of type <span class='texttt'>T</span>
is equivalent to <span class='texttt'>ranges::data(static_cast&lt;const T&amp;&gt;(E))</span>.</p></div><div class='para' id='range.primitives.cdata-2'><div class='marginalizedparent'><a class='marginalized' href='#range.primitives.cdata-2'>2</a></div><p >Use of <span class='texttt'>ranges::cdata(E)</span> with rvalue <span class='texttt'>E</span> is deprecated.
[&nbsp;<i>Note:</i> This deprecated usage exists so that <span class='texttt'>ranges::cdata(E)</span>
has behavior consistent with <span class='texttt'>ranges::data(E)</span> when <span class='texttt'>E</span> is
an rvalue. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]</p></div><div class='para' id='range.primitives.cdata-3'><div class='marginalizedparent'><a class='marginalized' href='#range.primitives.cdata-3'>3</a></div><p >[&nbsp;<i>Note:</i> Whenever <span class='texttt'>ranges::cdata(E)</span> is a valid expression, it
has pointer to object type. <i>&nbsp;â€”&nbsp;end note</i>&nbsp;]
</p></div></div></div></div></div></body></html>