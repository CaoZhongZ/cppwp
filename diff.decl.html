<!DOCTYPE html><html lang='en'><head><title>[diff.decl]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='stylesheet' type='text/css' href='expanded.css' title='Notes and examples expanded'/><link rel='alternate stylesheet' type='text/css' href='colored.css' title='Notes and examples colored'/><link rel='alternate stylesheet' type='text/css' href='collapsed.css' title='Notes and examples collapsed'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='annexnum' style='min-width:73pt'>Annex C&emsp;(informative)</a> Compatibility <a class='abbr_ref' href='./#diff'>[diff]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>C.1</a> C++ and ISO C <a class='abbr_ref' href='diff.iso#diff.decl'>[diff.iso]</a></h2><h3 ><a class='secnum' style='min-width:103pt'>C.1.7</a> <a href='dcl.decl'>[dcl.decl]</a>: declarators <a class='abbr_ref'>[diff.decl]</a></h3><div id='sentence-1' class='sentence'><a href='dcl.fct'>[dcl.fct]</a>
<br/><b>Change:</b> In C++, a function declared with an empty parameter list takes no arguments<a class='hidden_link' href='#sentence-1'>.</a></div> <div id='sentence-2' class='sentence'>In C, an empty parameter list means that the number and type of the function arguments are unknown<a class='hidden_link' href='#sentence-2'>.</a></div><div style='height:0.6em;display:block'></div><div id='sentence-3' class='sentence'>Example:</div><pre class='codeblock'>
int f();            <span class='comment'>// means   <span class='tcode_in_codeblock'>int f(void)</span> in C++
</span>                    <span class='comment'>// <span class='tcode_in_codeblock'>int f(</span> unknown <span class='tcode_in_codeblock'>)</span> in C
</span></pre><div id='sentence-4' class='sentence'><br/><b>Rationale:</b> 
This is to avoid erroneous function calls (i.e., function calls
with the wrong number or type of arguments).
<br/><b>Effect on original feature:</b> 
Change to semantics of well-defined feature<a class='hidden_link' href='#sentence-4'>.</a></div> <div id='sentence-5' class='sentence'>This feature was marked as “obsolescent” in C<a class='hidden_link' href='#sentence-5'>.</a></div> <div id='sentence-6' class='sentence'><br/><b>Difficulty of converting:</b> 
Syntactic transformation<a class='hidden_link' href='#sentence-6'>.</a></div> <div id='sentence-7' class='sentence'>The function declarations using C incomplete declaration style must
be completed to become full prototype declarations<a class='hidden_link' href='#sentence-7'>.</a></div> <div id='sentence-8' class='sentence'>A program may need to be updated further if different calls to the
same (non-prototype) function have different numbers of arguments or
if the type of corresponding arguments differed<a class='hidden_link' href='#sentence-8'>.</a></div> <div id='sentence-9' class='sentence'><br/><b>How widely used:</b> 
Common<a class='hidden_link' href='#sentence-9'>.</a></div><div style='height:0.6em;display:block'></div><div id='sentence-10' class='sentence'><a href='dcl.fct'>[dcl.fct]</a> [see <a href='expr.sizeof'>[expr.sizeof]</a>]
<br/><b>Change:</b> In C++, types may not be defined in return or parameter types<a class='hidden_link' href='#sentence-10'>.</a></div> <div id='sentence-11' class='sentence'>In C, these type definitions are allowed<a class='hidden_link' href='#sentence-11'>.</a></div><div style='height:0.6em;display:block'></div><div id='sentence-12' class='sentence'>Example:</div><pre class='codeblock'>
void f( struct S { int a; } arg ) {}    <span class='comment'>// valid C, invalid C++
</span>enum E { A, B, C } f() {}               <span class='comment'>// valid C, invalid C++
</span></pre><div id='sentence-13' class='sentence'><br/><b>Rationale:</b> 
When comparing types in different translation units, C++ relies
on name equivalence when C relies on structural equivalence<a class='hidden_link' href='#sentence-13'>.</a></div> <div id='sentence-14' class='sentence'>Regarding parameter types: since the type defined in a parameter list
would be in the scope of the function, the only legal calls in C++
would be from within the function itself<a class='hidden_link' href='#sentence-14'>.</a></div> <div id='sentence-15' class='sentence'><br/><b>Effect on original feature:</b> 
Deletion of semantically well-defined feature<a class='hidden_link' href='#sentence-15'>.</a></div> <div id='sentence-16' class='sentence'><br/><b>Difficulty of converting:</b> 
Semantic transformation<a class='hidden_link' href='#sentence-16'>.</a></div> <div id='sentence-17' class='sentence'>The type definitions must be moved to file scope, or in header files<a class='hidden_link' href='#sentence-17'>.</a></div> <div id='sentence-18' class='sentence'><br/><b>How widely used:</b> 
Seldom<a class='hidden_link' href='#sentence-18'>.</a></div> <div id='sentence-19' class='sentence'>This style of type definition is seen as poor coding style<a class='hidden_link' href='#sentence-19'>.</a></div><div style='height:0.6em;display:block'></div><div id='sentence-20' class='sentence'><a href='dcl.fct.def'>[dcl.fct.def]</a>
<br/><b>Change:</b> In C++, the syntax for function definition excludes the “old-style” C function<a class='hidden_link' href='#sentence-20'>.</a></div> <div id='sentence-21' class='sentence'>In C, “old-style” syntax is allowed, but deprecated as “obsolescent”<a class='hidden_link' href='#sentence-21'>.</a></div> <div id='sentence-22' class='sentence'><br/><b>Rationale:</b> 
Prototypes are essential to type safety<a class='hidden_link' href='#sentence-22'>.</a></div> <div id='sentence-23' class='sentence'><br/><b>Effect on original feature:</b> 
Deletion of semantically well-defined feature<a class='hidden_link' href='#sentence-23'>.</a></div> <div id='sentence-24' class='sentence'><br/><b>Difficulty of converting:</b> 
Syntactic transformation<a class='hidden_link' href='#sentence-24'>.</a></div> <div id='sentence-25' class='sentence'><br/><b>How widely used:</b> 
Common in old programs, but already known to be obsolescent<a class='hidden_link' href='#sentence-25'>.</a></div><div style='height:0.6em;display:block'></div><div id='sentence-26' class='sentence'><a href='dcl.init.aggr'>[dcl.init.aggr]</a>
<br/><b>Change:</b> 
In C++, designated initialization support is restricted
compared to the corresponding functionality in C<a class='hidden_link' href='#sentence-26'>.</a></div> <div id='sentence-27' class='sentence'>In C++,
designators for non-static data members
must be specified in declaration order,
designators for array elements and nested designators
are not supported,
and
designated and non-designated initializers
cannot be mixed in the same initializer list<a class='hidden_link' href='#sentence-27'>.</a></div><div style='height:0.6em;display:block'></div><div id='sentence-28' class='sentence'>Example:</div><pre class='codeblock'>
struct A { int x, y; };
struct B { struct A a; };
struct A a = {.y = 1, .x = 2};  <span class='comment'>// valid C, invalid C++
</span>int arr[3] = {[1] = 5};         <span class='comment'>// valid C, invalid C++
</span>struct B b = {.a.x = 0};        <span class='comment'>// valid C, invalid C++
</span>struct A c = {.x = 1, 2};       <span class='comment'>// valid C, invalid C++
</span></pre> <div id='sentence-29' class='sentence'><br/><b>Rationale:</b> 
In C++, members are destroyed in reverse construction order
and the elements of an initializer list are evaluated in lexical order,
so field initializers must be specified in order<a class='hidden_link' href='#sentence-29'>.</a></div> <div id='sentence-30' class='sentence'>Array designators conflict with <i ><a href='expr.prim.lambda#nt:lambda-expression'>lambda-expression</a></i> syntax<a class='hidden_link' href='#sentence-30'>.</a></div> <div id='sentence-31' class='sentence'>Nested designators are seldom used<a class='hidden_link' href='#sentence-31'>.</a></div> <div id='sentence-32' class='sentence'><br/><b>Effect on original feature:</b> 
Deletion of feature that is incompatible with C++<a class='hidden_link' href='#sentence-32'>.</a></div> <div id='sentence-33' class='sentence'><br/><b>Difficulty of converting:</b> 
Syntactic transformation<a class='hidden_link' href='#sentence-33'>.</a></div> <div id='sentence-34' class='sentence'><br/><b>How widely used:</b> 
Out-of-order initializers are common<a class='hidden_link' href='#sentence-34'>.</a></div> <div id='sentence-35' class='sentence'>The other features are seldom used<a class='hidden_link' href='#sentence-35'>.</a></div><div style='height:0.6em;display:block'></div><div id='sentence-36' class='sentence'><a href='dcl.init.string'>[dcl.init.string]</a>
<br/><b>Change:</b> In C++, when initializing an array of character with a string, the number of
characters in the string (including the terminating <span class='texttt'>'\0'</span>) must not exceed the
number of elements in the array<a class='hidden_link' href='#sentence-36'>.</a></div> <div id='sentence-37' class='sentence'>In C, an array can be initialized with a string even if
the array is not large enough to contain the string-terminating <span class='texttt'>'\0'</span><a class='hidden_link' href='#sentence-37'>.</a></div><div style='height:0.6em;display:block'></div><div id='sentence-38' class='sentence'>Example:</div><pre class='codeblock'>
char array[4] = "abcd";         <span class='comment'>// valid C, invalid C++
</span></pre> <div id='sentence-39' class='sentence'><br/><b>Rationale:</b> 
When these non-terminated arrays are manipulated by standard
string functions, there is potential for major catastrophe<a class='hidden_link' href='#sentence-39'>.</a></div> <div id='sentence-40' class='sentence'><br/><b>Effect on original feature:</b> 
Deletion of semantically well-defined feature<a class='hidden_link' href='#sentence-40'>.</a></div> <div id='sentence-41' class='sentence'><br/><b>Difficulty of converting:</b> 
Semantic transformation<a class='hidden_link' href='#sentence-41'>.</a></div> <div id='sentence-42' class='sentence'>The arrays must be declared one element bigger to contain the
string terminating <span class='texttt'>'\0'</span><a class='hidden_link' href='#sentence-42'>.</a></div> <div id='sentence-43' class='sentence'><br/><b>How widely used:</b> 
Seldom<a class='hidden_link' href='#sentence-43'>.</a></div> <div id='sentence-44' class='sentence'>This style of array initialization is seen as poor coding style<a class='hidden_link' href='#sentence-44'>.</a></div></div></body></html>