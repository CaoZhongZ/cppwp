<!DOCTYPE html><html lang='en'><head><title>[fs.filesystem.syn]</title><meta charset='UTF-8'/><link rel='stylesheet' type='text/css' href='14882.css'/><link rel='icon' href='icon.png'/></head><body><div class='wrapper'><h1 ><a class='secnum' style='min-width:73pt'>27</a> Input/output library <a class='abbr_ref' href='./#input.output'>[input.output]</a></h1><h2 ><a class='secnum' style='min-width:88pt'>27.10</a> File systems <a class='abbr_ref' href='filesystems#fs.filesystem.syn'>[filesystems]</a></h2><div id='fs.filesystem.syn'><h3 ><a class='secnum' style='min-width:103pt'>27.10.6</a> Header <span class='texttt'>&lt;filesystem&gt;</span> synopsis <a class='abbr_ref'>[fs.filesystem.syn]</a></h3><p ><span class='indexparent'><a class='index' id='filesystem'></a></span><span class='indexparent'><a class='index' id='filesystem'></a></span>
</p><pre class='codeblock'>
namespace std::filesystem {
  <span class='comment'>// <a href='class.path'>[class.path]</a>, paths
</span>  class path;

  <span class='comment'>// <a href='path.non-member'>[path.non-member]</a>, <span class='tcode_in_codeblock'>path</span> non-member functions
</span>  void swap(path&amp; lhs, path&amp; rhs) noexcept;
  size_t hash_value(const path&amp; p) noexcept;

  bool operator==(const path&amp; lhs, const path&amp; rhs) noexcept;
  bool operator!=(const path&amp; lhs, const path&amp; rhs) noexcept;
  bool operator&lt; (const path&amp; lhs, const path&amp; rhs) noexcept;
  bool operator&lt;=(const path&amp; lhs, const path&amp; rhs) noexcept;
  bool operator&gt; (const path&amp; lhs, const path&amp; rhs) noexcept;
  bool operator&gt;=(const path&amp; lhs, const path&amp; rhs) noexcept;

  path operator/ (const path&amp; lhs, const path&amp; rhs);

  <span class='comment'>// <a href='path.io'>[path.io]</a>, <span class='tcode_in_codeblock'>path</span> inserter and extractor
</span>  template &lt;class charT, class traits&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const path&amp; p);
  template &lt;class charT, class traits&gt;
    basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, path&amp; p);

  <span class='comment'>// <a href='path.factory'>[path.factory]</a>, <span class='tcode_in_codeblock'>path</span> factory functions
</span>  template &lt;class Source&gt;
    path u8path(const Source&amp; source);
  template &lt;class InputIterator&gt;
    path u8path(InputIterator first, InputIterator last);

  <span class='comment'>// <a href='class.filesystem_error'>[class.filesystem_error]</a>, filesystem errors
</span>  class filesystem_error;

  <span class='comment'>// <a href='class.directory_entry'>[class.directory_entry]</a>, directory entries
</span>  class directory_entry;

  <span class='comment'>// <a href='class.directory_iterator'>[class.directory_iterator]</a>, directory iterators
</span>  class directory_iterator;

  <span class='comment'>// <a href='directory_iterator.nonmembers'>[directory_iterator.nonmembers]</a>, range access for directory iterators
</span>  directory_iterator begin(directory_iterator iter) noexcept;
  directory_iterator end(const directory_iterator&amp;) noexcept;

  <span class='comment'>// <a href='class.rec.dir.itr'>[class.rec.dir.itr]</a>, recursive directory iterators
</span>  class recursive_directory_iterator;

  <span class='comment'>// <a href='rec.dir.itr.nonmembers'>[rec.dir.itr.nonmembers]</a>, range access for recursive directory iterators
</span>  recursive_directory_iterator begin(recursive_directory_iterator iter) noexcept;
  recursive_directory_iterator end(const recursive_directory_iterator&amp;) noexcept;

  <span class='comment'>// <a href='class.file_status'>[class.file_status]</a>, file status
</span>  class file_status;

  struct space_info {
    uintmax_t capacity;
    uintmax_t free;
    uintmax_t available;
  };

  <span class='comment'>// <a href='fs.enum'>[fs.enum]</a>, enumerations
</span>  enum class file_type;
  enum class perms;
  enum class copy_options;
  enum class directory_options;

  using file_time_type = chrono::time_point&lt;<span class='textit'>trivial-clock</span>&gt;;

  <span class='comment'>// <a href='fs.op.funcs'>[fs.op.funcs]</a>, filesystem operations
</span>  path absolute(const path&amp; p, const path&amp; base = current_path());

  path canonical(const path&amp; p, const path&amp; base = current_path());
  path canonical(const path&amp; p, error_code&amp; ec);
  path canonical(const path&amp; p, const path&amp; base, error_code&amp; ec);

  void copy(const path&amp; from, const path&amp; to);
  void copy(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;
  void copy(const path&amp; from, const path&amp; to, copy_options options);
  void copy(const path&amp; from, const path&amp; to, copy_options options,
            error_code&amp; ec) noexcept;

  bool copy_file(const path&amp; from, const path&amp; to);
  bool copy_file(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;
  bool copy_file(const path&amp; from, const path&amp; to, copy_options option);
  bool copy_file(const path&amp; from, const path&amp; to, copy_options option,
                 error_code&amp; ec) noexcept;

  void copy_symlink(const path&amp; existing_symlink, const path&amp; new_symlink);
  void copy_symlink(const path&amp; existing_symlink, const path&amp; new_symlink,
                    error_code&amp; ec) noexcept;

  bool create_directories(const path&amp; p);
  bool create_directories(const path&amp; p, error_code&amp; ec) noexcept;

  bool create_directory(const path&amp; p);
  bool create_directory(const path&amp; p, error_code&amp; ec) noexcept;

  bool create_directory(const path&amp; p, const path&amp; attributes);
  bool create_directory(const path&amp; p, const path&amp; attributes,
                        error_code&amp; ec) noexcept;

  void create_directory_symlink(const path&amp; to, const path&amp; new_symlink);
  void create_directory_symlink(const path&amp; to, const path&amp; new_symlink,
                                error_code&amp; ec) noexcept;

  void create_hard_link(const path&amp; to, const path&amp; new_hard_link);
  void create_hard_link(const path&amp; to, const path&amp; new_hard_link,
                        error_code&amp; ec) noexcept;

  void create_symlink(const path&amp; to, const path&amp; new_symlink);
  void create_symlink(const path&amp; to, const path&amp; new_symlink,
                      error_code&amp; ec) noexcept;

  path current_path();
  path current_path(error_code&amp; ec);
  void current_path(const path&amp; p);
  void current_path(const path&amp; p, error_code&amp; ec) noexcept;

  bool exists(file_status s) noexcept;
  bool exists(const path&amp; p);
  bool exists(const path&amp; p, error_code&amp; ec) noexcept;

  bool equivalent(const path&amp; p1, const path&amp; p2);
  bool equivalent(const path&amp; p1, const path&amp; p2, error_code&amp; ec) noexcept;

  uintmax_t file_size(const path&amp; p);
  uintmax_t file_size(const path&amp; p, error_code&amp; ec) noexcept;

  uintmax_t hard_link_count(const path&amp; p);
  uintmax_t hard_link_count(const path&amp; p, error_code&amp; ec) noexcept;

  bool is_block_file(file_status s) noexcept;
  bool is_block_file(const path&amp; p);
  bool is_block_file(const path&amp; p, error_code&amp; ec) noexcept;

  bool is_character_file(file_status s) noexcept;
  bool is_character_file(const path&amp; p);
  bool is_character_file(const path&amp; p, error_code&amp; ec) noexcept;

  bool is_directory(file_status s) noexcept;
  bool is_directory(const path&amp; p);
  bool is_directory(const path&amp; p, error_code&amp; ec) noexcept;

  bool is_empty(const path&amp; p);
  bool is_empty(const path&amp; p, error_code&amp; ec) noexcept;

  bool is_fifo(file_status s) noexcept;
  bool is_fifo(const path&amp; p);
  bool is_fifo(const path&amp; p, error_code&amp; ec) noexcept;

  bool is_other(file_status s) noexcept;
  bool is_other(const path&amp; p);
  bool is_other(const path&amp; p, error_code&amp; ec) noexcept;

  bool is_regular_file(file_status s) noexcept;
  bool is_regular_file(const path&amp; p);
  bool is_regular_file(const path&amp; p, error_code&amp; ec) noexcept;

  bool is_socket(file_status s) noexcept;
  bool is_socket(const path&amp; p);
  bool is_socket(const path&amp; p, error_code&amp; ec) noexcept;

  bool is_symlink(file_status s) noexcept;
  bool is_symlink(const path&amp; p);
  bool is_symlink(const path&amp; p, error_code&amp; ec) noexcept;

  file_time_type last_write_time(const path&amp; p);
  file_time_type last_write_time(const path&amp; p, error_code&amp; ec) noexcept;
  void last_write_time(const path&amp; p, file_time_type new_time);
  void last_write_time(const path&amp; p, file_time_type new_time,
                       error_code&amp; ec) noexcept;

  void permissions(const path&amp; p, perms prms);
  void permissions(const path&amp; p, perms prms, error_code&amp; ec);

  path proximate(const path&amp; p, error_code&amp; ec);
  path proximate(const path&amp; p, const path&amp; base = current_path());
  path proximate(const path&amp; p, const path&amp; base, error_code&amp; ec);

  path read_symlink(const path&amp; p);
  path read_symlink(const path&amp; p, error_code&amp; ec);

  path relative(const path&amp; p, error_code&amp; ec);
  path relative(const path&amp; p, const path&amp; base = current_path());
  path relative(const path&amp; p, const path&amp; base, error_code&amp; ec);

  bool remove(const path&amp; p);
  bool remove(const path&amp; p, error_code&amp; ec) noexcept;

  uintmax_t remove_all(const path&amp; p);
  uintmax_t remove_all(const path&amp; p, error_code&amp; ec) noexcept;

  void rename(const path&amp; from, const path&amp; to);
  void rename(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;

  void resize_file(const path&amp; p, uintmax_t size);
  void resize_file(const path&amp; p, uintmax_t size, error_code&amp; ec) noexcept;

  space_info space(const path&amp; p);
  space_info space(const path&amp; p, error_code&amp; ec) noexcept;

  file_status status(const path&amp; p);
  file_status status(const path&amp; p, error_code&amp; ec) noexcept;

  bool status_known(file_status s) noexcept;

  file_status symlink_status(const path&amp; p);
  file_status symlink_status(const path&amp; p, error_code&amp; ec) noexcept;

  path system_complete(const path&amp; p);
  path system_complete(const path&amp; p, error_code&amp; ec);

  path temp_directory_path();
  path temp_directory_path(error_code&amp; ec);

  path weakly_canonical(const path&amp; p);
  path weakly_canonical(const path&amp; p, error_code&amp; ec);
}</pre><div class='para' id='1'><div class='marginalizedparent'><a class='marginalized' href='#1'>1</a></div><div class='sourceLinkParent'><a class='sourceLink' href='https://github.com/cplusplus/draft/tree/fa6ac2cd9891439072e49bb10f0f14b4484938d4/source/iostreams.tex#L10329'>#</a></div><p ><span class='texttt'><span class='textit'>trivial-clock</span></span> is an <span class='indexparent'><a class='index' id='type_of_filesystem_trivial_clock'></a></span>implementation-defined type
that satisfies the <span class='texttt'>TrivialClock</span> requirements (<a href='time.clock.req'>[time.clock.req]</a>)
and that is capable of representing and measuring file time values.
Implementations should ensure that the resolution and range of
<span class='texttt'>file_&shy;time_&shy;type</span> reflect the operating system dependent resolution and range
of file time values.</p></div></div></div></body></html>